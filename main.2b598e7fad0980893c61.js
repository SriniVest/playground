(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{0:function(t,e,n){t.exports=n("zUnb")},1:function(t,e){},2:function(t,e){},3:function(t,e){},4:function(t,e){},5:function(t,e){},B9Yq:function(t,e){t.exports=function(){throw new Error("define cannot be used indirect")}},EUiz:function(t,e){(function(){"use strict";function t(t){var e=0;return function(){return e<t.length?{done:!1,value:t[e++]}:{done:!0}}}function e(e){var n="undefined"!=typeof Symbol&&Symbol.iterator&&e[Symbol.iterator];return n?n.call(e):{next:t(e)}}function n(t){if(!(t instanceof Array)){t=e(t);for(var n,r=[];!(n=t.next()).done;)r.push(n.value);t=r}return t}var r,i="function"==typeof Object.defineProperties?Object.defineProperty:function(t,e,n){return t==Array.prototype||t==Object.prototype||(t[e]=n.value),t},s=function(t){t=["object"==typeof globalThis&&globalThis,t,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof global&&global];for(var e=0;e<t.length;++e){var n=t[e];if(n&&n.Math==Math)return n}throw Error("Cannot find global object")}(this);function o(t,e){if(e)t:{var n=s;t=t.split(".");for(var r=0;r<t.length-1;r++){var o=t[r];if(!(o in n))break t;n=n[o]}(e=e(r=n[t=t[t.length-1]]))!=r&&null!=e&&i(n,t,{configurable:!0,writable:!0,value:e})}}if("function"==typeof Object.setPrototypeOf)r=Object.setPrototypeOf;else{var a;t:{var l={};try{l.__proto__={a:!0},a=l.a;break t}catch(U){}a=!1}r=a?function(t,e){if(t.__proto__=e,t.__proto__!==e)throw new TypeError(t+" is not extensible");return t}:null}var c=r;function u(){this.l=!1,this.h=null,this.j=void 0,this.g=1,this.s=this.m=0,this.i=null}function h(t){if(t.l)throw new TypeError("Generator is already running");t.l=!0}function d(t,e){t.i={J:e,K:!0},t.g=t.m||t.s}function p(t,e,n){return t.g=n,{value:e}}function f(t){this.g=new u,this.h=t}function m(t,e,n,r){try{var i=e.call(t.g.h,n);if(!(i instanceof Object))throw new TypeError("Iterator result "+i+" is not an object");if(!i.done)return t.g.l=!1,i;var s=i.value}catch(o){return t.g.h=null,d(t.g,o),g(t)}return t.g.h=null,r.call(t.g,s),g(t)}function g(t){for(;t.g.g;)try{var e=t.h(t.g);if(e)return t.g.l=!1,{value:e.value,done:!1}}catch(n){t.g.j=void 0,d(t.g,n)}if(t.g.l=!1,t.g.i){if(e=t.g.i,t.g.i=null,e.K)throw e.J;return{value:e.return,done:!0}}return{value:void 0,done:!0}}function y(t){this.next=function(e){return h(t.g),t.g.h?e=m(t,t.g.h.next,e,t.g.o):(t.g.o(e),e=g(t)),e},this.throw=function(e){return h(t.g),t.g.h?e=m(t,t.g.h.throw,e,t.g.o):(d(t.g,e),e=g(t)),e},this.return=function(e){return function(t,e){h(t.g);var n=t.g.h;return n?m(t,"return"in n?n.return:function(t){return{value:t,done:!0}},e,t.g.return):(t.g.return(e),g(t))}(t,e)},this[Symbol.iterator]=function(){return this}}function v(t,e){return e=new y(new f(e)),c&&t.prototype&&c(e,t.prototype),e}function b(t){return(t={next:t})[Symbol.iterator]=function(){return this},t}u.prototype.o=function(t){this.j=t},u.prototype.return=function(t){this.i={return:t},this.g=this.s},o("Symbol",function(t){function e(t,e){this.g=t,i(this,"description",{configurable:!0,writable:!0,value:e})}if(t)return t;e.prototype.toString=function(){return this.g};var n=0;return function t(r){if(this instanceof t)throw new TypeError("Symbol is not a constructor");return new e("jscomp_symbol_"+(r||"")+"_"+n++,r)}}),o("Symbol.iterator",function(e){if(e)return e;e=Symbol("Symbol.iterator");for(var n="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),r=0;r<n.length;r++){var o=s[n[r]];"function"==typeof o&&"function"!=typeof o.prototype[e]&&i(o.prototype,e,{configurable:!0,writable:!0,value:function(){return b(t(this))}})}return e});var _="function"==typeof Object.assign?Object.assign:function(t,e){for(var n=1;n<arguments.length;n++){var r=arguments[n];if(r)for(var i in r)Object.prototype.hasOwnProperty.call(r,i)&&(t[i]=r[i])}return t};o("Object.assign",function(t){return t||_}),o("Promise",function(t){function n(t){this.h=0,this.i=void 0,this.g=[],this.o=!1;var e=this.j();try{t(e.resolve,e.reject)}catch(n){e.reject(n)}}function r(){this.g=null}function i(t){return t instanceof n?t:new n(function(e){e(t)})}if(t)return t;r.prototype.h=function(t){if(null==this.g){this.g=[];var e=this;this.i(function(){e.l()})}this.g.push(t)};var o=s.setTimeout;r.prototype.i=function(t){o(t,0)},r.prototype.l=function(){for(;this.g&&this.g.length;){var t=this.g;this.g=[];for(var e=0;e<t.length;++e){var n=t[e];t[e]=null;try{n()}catch(r){this.j(r)}}}this.g=null},r.prototype.j=function(t){this.i(function(){throw t})},n.prototype.j=function(){function t(t){return function(r){n||(n=!0,t.call(e,r))}}var e=this,n=!1;return{resolve:t(this.B),reject:t(this.l)}},n.prototype.B=function(t){if(t===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(t instanceof n)this.H(t);else{t:switch(typeof t){case"object":var e=null!=t;break t;case"function":e=!0;break t;default:e=!1}e?this.A(t):this.m(t)}},n.prototype.A=function(t){var e=void 0;try{e=t.then}catch(n){return void this.l(n)}"function"==typeof e?this.I(e,t):this.m(t)},n.prototype.l=function(t){this.s(2,t)},n.prototype.m=function(t){this.s(1,t)},n.prototype.s=function(t,e){if(0!=this.h)throw Error("Cannot settle("+t+", "+e+"): Promise already settled in state"+this.h);this.h=t,this.i=e,2===this.h&&this.G(),this.D()},n.prototype.G=function(){var t=this;o(function(){if(t.F()){var e=s.console;void 0!==e&&e.error(t.i)}},1)},n.prototype.F=function(){if(this.o)return!1;var t=s.CustomEvent,e=s.Event,n=s.dispatchEvent;return void 0===n||("function"==typeof t?t=new t("unhandledrejection",{cancelable:!0}):"function"==typeof e?t=new e("unhandledrejection",{cancelable:!0}):(t=s.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection",!1,!0,t),t.promise=this,t.reason=this.i,n(t))},n.prototype.D=function(){if(null!=this.g){for(var t=0;t<this.g.length;++t)a.h(this.g[t]);this.g=null}};var a=new r;return n.prototype.H=function(t){var e=this.j();t.C(e.resolve,e.reject)},n.prototype.I=function(t,e){var n=this.j();try{t.call(e,n.resolve,n.reject)}catch(r){n.reject(r)}},n.prototype.then=function(t,e){function r(t,e){return"function"==typeof t?function(e){try{i(t(e))}catch(n){s(n)}}:e}var i,s,o=new n(function(t,e){i=t,s=e});return this.C(r(t,i),r(e,s)),o},n.prototype.catch=function(t){return this.then(void 0,t)},n.prototype.C=function(t,e){function n(){switch(r.h){case 1:t(r.i);break;case 2:e(r.i);break;default:throw Error("Unexpected state: "+r.h)}}var r=this;null==this.g?a.h(n):this.g.push(n),this.o=!0},n.resolve=i,n.reject=function(t){return new n(function(e,n){n(t)})},n.race=function(t){return new n(function(n,r){for(var s=e(t),o=s.next();!o.done;o=s.next())i(o.value).C(n,r)})},n.all=function(t){var r=e(t),s=r.next();return s.done?i([]):new n(function(t,e){function n(e){return function(n){o[e]=n,0==--a&&t(o)}}var o=[],a=0;do{o.push(void 0),a++,i(s.value).C(n(o.length-1),e),s=r.next()}while(!s.done)})},n}),o("Array.prototype.keys",function(t){return t||function(){return function(t,e){t instanceof String&&(t+="");var n=0,r=!1,i={next:function(){return!r&&n<t.length?{value:n++,done:!1}:(r=!0,{done:!0,value:void 0})}};return i[Symbol.iterator]=function(){return i},i}(this)}});var x=this||self;function w(t,e){t=t.split(".");var n,r=x;t[0]in r||void 0===r.execScript||r.execScript("var "+t[0]);for(;t.length&&(n=t.shift());)t.length||void 0===e?r=r[n]&&r[n]!==Object.prototype[n]?r[n]:r[n]={}:r[n]=e}function S(t,e){var n=void 0;return new(n||(n=Promise))(function(r,i){function s(t){try{a(e.next(t))}catch(n){i(n)}}function o(t){try{a(e.throw(t))}catch(n){i(n)}}function a(t){t.done?r(t.value):new n(function(e){e(t.value)}).then(s,o)}a((e=e.apply(t,void 0)).next())})}var E=[[61,146],[146,91],[91,181],[181,84],[84,17],[17,314],[314,405],[405,321],[321,375],[375,291],[61,185],[185,40],[40,39],[39,37],[37,0],[0,267],[267,269],[269,270],[270,409],[409,291],[78,95],[95,88],[88,178],[178,87],[87,14],[14,317],[317,402],[402,318],[318,324],[324,308],[78,191],[191,80],[80,81],[81,82],[82,13],[13,312],[312,311],[311,310],[310,415],[415,308]],C=[[263,249],[249,390],[390,373],[373,374],[374,380],[380,381],[381,382],[382,362],[263,466],[466,388],[388,387],[387,386],[386,385],[385,384],[384,398],[398,362]],T=[[276,283],[283,282],[282,295],[295,285],[300,293],[293,334],[334,296],[296,336]],A=[[33,7],[7,163],[163,144],[144,145],[145,153],[153,154],[154,155],[155,133],[33,246],[246,161],[161,160],[160,159],[159,158],[158,157],[157,173],[173,133]],M=[[46,53],[53,52],[52,65],[65,55],[70,63],[63,105],[105,66],[66,107]],k=[[10,338],[338,297],[297,332],[332,284],[284,251],[251,389],[389,356],[356,454],[454,323],[323,361],[361,288],[288,397],[397,365],[365,379],[379,378],[378,400],[400,377],[377,152],[152,148],[148,176],[176,149],[149,150],[150,136],[136,172],[172,58],[58,132],[132,93],[93,234],[234,127],[127,162],[162,21],[21,54],[54,103],[103,67],[67,109],[109,10]],R=[].concat(n(E),n(C),n(T),n(A),n(M),n(k));function I(t,e,n){if(n=t.createShader(0===n?t.VERTEX_SHADER:t.FRAGMENT_SHADER),t.shaderSource(n,e),t.compileShader(n),!t.getShaderParameter(n,t.COMPILE_STATUS))throw Error("Could not compile WebGL shader.\n\n"+t.getShaderInfoLog(n));return n}function N(t,e){this.g=t,this.j=e,this.i=0}var O=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function D(t,e){return e+t}function L(t,e){window[t]=e}function F(t){for(var e=[],n=t.size(),r=0;r<n;++r){var i=t.get(r);e.push({x:i.x,y:i.y,z:i.z,visibility:i.hasVisibility?i.visibility:void 0})}return e}function P(t,e,n){this.graph=t,this.locateFile=e,this.g=n}function $(t){if(this.h=t,this.listeners={},this.F={},this.B={},this.l=this.A=!0,this.o=Promise.resolve(),this.locateFile=t&&t.locateFile||D,"object"==typeof window)t=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else{if("undefined"==typeof location)throw Error("solutions can only be loaded on a web page or in a web worker");t=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/"}this.D=t}function B(t,e,n){if(n.isNumber())return n.getNumber();if(n.isRect())return n.getRect();if(n.isLandmarks())return n.getLandmarks();if(n.isLandmarksList())return n.getLandmarksList();if(n.isClassificationsList())return n.getClassificationsList();if(n.isObjectDetectionList())return n.getObjectDetectionList();if(n.isTexture2d()){var r=t.B[e];if(r||(r=new N(t.g,t.s),t.B[e]=r),t=r,n=n.getTexture2d(),e=t.j,void 0===t.l){r=I(e,"\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }",0);var i=I(e,"\n  precision highp float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }",1),s=e.createProgram();if(e.attachShader(s,r),e.attachShader(s,i),e.linkProgram(s),!e.getProgramParameter(s,e.LINK_STATUS))throw Error("Could not compile WebGL program.\n\n"+e.getProgramInfoLog(s));r=t.l=s,e.useProgram(r),i=e.getUniformLocation(r,"sampler0"),t.h={v:e.getAttribLocation(r,"aVertex"),u:e.getAttribLocation(r,"aTex"),W:i},t.o=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,t.o),e.enableVertexAttribArray(t.h.v),e.vertexAttribPointer(t.h.v,2,e.FLOAT,!1,0,0),e.bufferData(e.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,null),t.m=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,t.m),e.enableVertexAttribArray(t.h.u),e.vertexAttribPointer(t.h.u,2,e.FLOAT,!1,0,0),e.bufferData(e.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,null),e.uniform1i(i,0)}return r=t.h,e.useProgram(t.l),e.canvas.width=n.width,e.canvas.height=n.height,e.viewport(0,0,n.width,n.height),e.activeTexture(e.TEXTURE0),t.g.bindTexture2d(n.glName),e.enableVertexAttribArray(r.v),e.bindBuffer(e.ARRAY_BUFFER,t.o),e.vertexAttribPointer(r.v,2,e.FLOAT,!1,0,0),e.enableVertexAttribArray(r.u),e.bindBuffer(e.ARRAY_BUFFER,t.m),e.vertexAttribPointer(r.u,2,e.FLOAT,!1,0,0),e.bindFramebuffer(e.DRAW_FRAMEBUFFER,null),e.drawArrays(e.TRIANGLE_FAN,0,4),e.disableVertexAttribArray(r.v),e.disableVertexAttribArray(r.u),e.bindBuffer(e.ARRAY_BUFFER,null),t.g.bindTexture2d(0),t.j.canvas}}function z(t,r){for(var i=r.name||"$",s=[].concat(n(r.wants)),o=new t.g.StringList,a=e(r.wants),l=a.next();!l.done;l=a.next())o.push_back(l.value);a=t.g.PacketListener.implement({onResults:function(n){return S(t,function t(){var o,a,l,c,u=this;return v(t,function(t){if(1==t.g){for(o={},a=0;a<r.wants.length;++a)o[s[a]]=B(u,r.wants[a],n.get(a));if(r.outs){for(var h=o,d=r.outs,f={},m=e(Object.keys(d)),g=m.next();!g.done;g=m.next()){var y=d[g=g.value];if("string"==typeof y)f[g]=h[y];else{var v=h[y.stream];if(void 0!==v){if("landmarks"===y.type)f[g]=F(v);else if("landmarks_list"===y.type){for(var b=[],_=v.size(),x=0;x<_;++x){var w=v.get(x);b.push(F(w))}f[g]=b}else if("classifications_list"===y.type){for(b=[],_=v.size(),x=0;x<_;++x){for(var S=v.get(x),E=(w=b).push,C=[],T=S.size(),A=0;A<T;++A){var M=S.get(A);C.push({index:M.index,score:M.score,label:M.label})}E.call(w,C)}f[g]=b}else{if("object_detection_list"!==y.type)throw Error("Unknown output config type: '"+y.type+"'");for(b=[],_=v.size(),x=0;x<_;++x){S=v.get(x),E=(w=b).push,C=S.id,A=[],M=(T=S.keypoints).size();for(var k=0;k<M;++k){var R=T.get(k);A.push({id:R.id,point3d:{x:R.point3d.x,y:R.point3d.y,z:R.point3d.z},point2d:{x:R.point2d.x,y:R.point2d.y,depth:R.point2d.depth}})}E.call(w,{id:C,keypoints:A,visibility:S.visibility})}f[g]=b}y.transform&&(f[g]=y.transform(f[g]))}}}o=f}return(l=u.listeners[i])?t=p(t,u.o,3):(t.g=0,t=void 0),t}if(c=l(o))return u.o=c,t.return(c);t.g=0})})}}),t.i.attachMultiListener(o,a),o.delete()}function V(t){this.g=new $({locateFile:(t=t||{}).locateFile,files:[{url:"holistic_solution_packed_assets_loader.js"},{simd:!1,url:"holistic_solution_wasm_bin.js"},{simd:!0,url:"holistic_solution_simd_wasm_bin.js"}],graph:{url:"holistic.binarypb"},inputs:{image:{type:"video",stream:"input_frames_gpu"}},listeners:[{wants:["left_hand_landmarks","right_hand_landmarks","face_landmarks","pose_landmarks","image_transformed"],outs:{image:"image_transformed",leftHandLandmarks:{type:"landmarks",stream:"left_hand_landmarks"},rightHandLandmarks:{type:"landmarks",stream:"right_hand_landmarks"},faceLandmarks:{type:"landmarks",stream:"face_landmarks"},poseLandmarks:{type:"landmarks",stream:"pose_landmarks"}}}],options:{selfieMode:{type:1,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},upperBodyOnly:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorUpperBodyOnly",fieldName:"bool_value"}},smoothLandmarks:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},minDetectionConfidence:{type:0,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"holisticlandmarkgpu__poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:0,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"holisticlandmarkgpu__poselandmarkgpu__poselandmarkbyroigpu__ThresholdingCalculator",fieldName:"threshold"}}}})}P.prototype.toArrayBuffer=function(){return S(this,function t(){var e,n=this;return v(t,function(t){return 1==t.g?(n.graph.url?t=p(t,fetch(n.locateFile(n.graph.url,n.g)),3):(t.g=2,t=void 0),t):2!=t.g&&(e=t.j).body?t.return(e.arrayBuffer()):t.return(new ArrayBuffer(0))})})},$.prototype.close=function(){return this.i&&this.i.delete(),Promise.resolve()},$.prototype.setOptions=function(t){if(this.h.options){for(var n=[],r=e(Object.keys(t)),i=r.next();!i.done;i=r.next()){var s=i.value;(i=this.h.options[s])&&i.graphOptionXref&&(s={valueNumber:0===i.type?t[s]:0,valueBoolean:1===i.type&&t[s]},i=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),i.graphOptionXref),s),n.push(i))}0!==n.length&&(this.l=!0,this.m=n)}},$.prototype.initialize=function(){return S(this,function t(){var n=this;return v(t,function(t){return 1==t.g?p(t,S(n,function t(){var n,r,i,s,o,a,l,c,u=this;return v(t,function(t){switch(t.g){case 1:return n=u,u.A?(L("createMediapipeSolutionsWasm",{locateFile:u.locateFile}),L("createMediapipeSolutionsPackedAssets",{locateFile:u.locateFile}),r=u.h.files||[],p(t,function(){return S(this,function t(){return v(t,function(t){switch(t.g){case 1:return t.m=2,p(t,WebAssembly.instantiate(O),4);case 4:t.g=3,t.m=0;break;case 2:return t.m=0,t.i=null,t.return(!1);case 3:return t.return(!0)}})})}(),2)):t.return();case 2:return i=t.j,p(t,Promise.all(r.map(function(t){return void 0===t.simd||t.simd&&i||!t.simd&&!i?function(t){var e=document.createElement("script");return e.setAttribute("src",t),e.setAttribute("crossorigin","anonymous"),document.body.appendChild(e),new Promise(function(t){e.addEventListener("load",function(){t()},!1)})}(n.locateFile(t.url,n.D)):Promise.resolve()})),3);case 3:return s=window.createMediapipeSolutionsWasm,o=window.createMediapipeSolutionsPackedAssets,p(t,s(o),4);case 4:return u.g=t.j,u.j=document.createElement("canvas"),u.g.canvas=u.j,u.g.createContext(u.j,!0,!0,{}),u.i=new u.g.SolutionWasm,a=new P(u.h.graph,u.locateFile,u.D),p(t,u.loadGraph(a),5);case 5:if(u.h.listeners)for(l=e(u.h.listeners),c=l.next();!c.done;c=l.next())z(u,c.value);u.A=!1,t.g=0}})}),2):p(t,S(n,function t(){var n,r,i,s,o=this;return v(t,function(t){if(!o.l)return t.return();if(!(n=o.j.getContext("webgl2")))return alert("Failed to create WebGL canvas context when passing video frame."),t.return();if(o.s=n,o.m){for(r=new o.g.GraphOptionChangeRequestList,i=e(o.m),s=i.next();!s.done;s=i.next())r.push_back(s.value);o.i.changeOptions(r),r.delete(),o.m=void 0}o.l=!1,t.g=0})}),0)})})},$.prototype.loadGraph=function(t){return S(this,function e(){var n=this;return v(e,function(e){if(1==e.g)return p(e,t.toArrayBuffer(),2);n.i.loadGraph(e.j),e.g=0})})},$.prototype.send=function(t,n){return S(this,function r(){var i,s,o,a,l,c,u,h=this;return v(r,function(r){if(1==r.g)return h.h.inputs?(i=1e3*(n||performance.now()),p(r,h.o,2)):r.return();if(3!=r.g)return p(r,h.initialize(),3);for(s=new h.g.PacketDataList,o=e(Object.keys(t)),a=o.next();!a.done;a=o.next())if(c=h.h.inputs[l=a.value]){t:{var d=t[l];switch(c.type){case"video":var f=h.F[c.stream];if(f||(f=new N(h.g,h.s),h.F[c.stream]=f),0===f.i&&(f.i=f.g.createTexture()),d instanceof HTMLVideoElement)var m=d.videoWidth,g=d.videoHeight;else d instanceof HTMLImageElement?(m=d.naturalWidth,g=d.naturalHeight):(m=d.width,g=d.height);g={glName:f.i,width:m,height:g},(m=f.j).canvas.width=g.width,m.canvas.height=g.height,m.activeTexture(m.TEXTURE0),f.g.bindTexture2d(f.i),m.texImage2D(m.TEXTURE_2D,0,m.RGBA,m.RGBA,m.UNSIGNED_BYTE,d),f.g.bindTexture2d(0),f=g;break t;default:f={}}}u=c.stream,s.pushTexture2d(Object.assign(Object.assign({},f),{stream:u,timestamp:i}))}h.i.send(s),s.delete(),r.g=0})})},$.prototype.onResults=function(t,e){this.listeners[e||"$"]=t},w("Solution",$),w("OptionType",{NUMBER:0,BOOL:1,0:"NUMBER",1:"BOOL"}),V.prototype.close=function(){return this.g.close(),Promise.resolve()},V.prototype.onResults=function(t){this.g.onResults(t)},V.prototype.initialize=function(){return S(this,function t(){var e=this;return v(t,function(t){return p(t,e.g.initialize(),0)})})},V.prototype.send=function(t){return S(this,function e(){var n=this;return v(e,function(e){return p(e,n.g.send(t),0)})})},V.prototype.setOptions=function(t){this.g.setOptions(t)},w("Holistic",V),w("FACEMESH_LIPS",E),w("FACEMESH_LEFT_EYE",C),w("FACEMESH_LEFT_EYEBROW",T),w("FACEMESH_RIGHT_EYE",A),w("FACEMESH_RIGHT_EYEBROW",M),w("FACEMESH_FACE_OVAL",k),w("FACEMESH_CONTOURS",R),w("FACEMESH_TESSELATION",[[127,34],[34,139],[139,127],[11,0],[0,37],[37,11],[232,231],[231,120],[120,232],[72,37],[37,39],[39,72],[128,121],[121,47],[47,128],[232,121],[121,128],[128,232],[104,69],[69,67],[67,104],[175,171],[171,148],[148,175],[118,50],[50,101],[101,118],[73,39],[39,40],[40,73],[9,151],[151,108],[108,9],[48,115],[115,131],[131,48],[194,204],[204,211],[211,194],[74,40],[40,185],[185,74],[80,42],[42,183],[183,80],[40,92],[92,186],[186,40],[230,229],[229,118],[118,230],[202,212],[212,214],[214,202],[83,18],[18,17],[17,83],[76,61],[61,146],[146,76],[160,29],[29,30],[30,160],[56,157],[157,173],[173,56],[106,204],[204,194],[194,106],[135,214],[214,192],[192,135],[203,165],[165,98],[98,203],[21,71],[71,68],[68,21],[51,45],[45,4],[4,51],[144,24],[24,23],[23,144],[77,146],[146,91],[91,77],[205,50],[50,187],[187,205],[201,200],[200,18],[18,201],[91,106],[106,182],[182,91],[90,91],[91,181],[181,90],[85,84],[84,17],[17,85],[206,203],[203,36],[36,206],[148,171],[171,140],[140,148],[92,40],[40,39],[39,92],[193,189],[189,244],[244,193],[159,158],[158,28],[28,159],[247,246],[246,161],[161,247],[236,3],[3,196],[196,236],[54,68],[68,104],[104,54],[193,168],[168,8],[8,193],[117,228],[228,31],[31,117],[189,193],[193,55],[55,189],[98,97],[97,99],[99,98],[126,47],[47,100],[100,126],[166,79],[79,218],[218,166],[155,154],[154,26],[26,155],[209,49],[49,131],[131,209],[135,136],[136,150],[150,135],[47,126],[126,217],[217,47],[223,52],[52,53],[53,223],[45,51],[51,134],[134,45],[211,170],[170,140],[140,211],[67,69],[69,108],[108,67],[43,106],[106,91],[91,43],[230,119],[119,120],[120,230],[226,130],[130,247],[247,226],[63,53],[53,52],[52,63],[238,20],[20,242],[242,238],[46,70],[70,156],[156,46],[78,62],[62,96],[96,78],[46,53],[53,63],[63,46],[143,34],[34,227],[227,143],[123,117],[117,111],[111,123],[44,125],[125,19],[19,44],[236,134],[134,51],[51,236],[216,206],[206,205],[205,216],[154,153],[153,22],[22,154],[39,37],[37,167],[167,39],[200,201],[201,208],[208,200],[36,142],[142,100],[100,36],[57,212],[212,202],[202,57],[20,60],[60,99],[99,20],[28,158],[158,157],[157,28],[35,226],[226,113],[113,35],[160,159],[159,27],[27,160],[204,202],[202,210],[210,204],[113,225],[225,46],[46,113],[43,202],[202,204],[204,43],[62,76],[76,77],[77,62],[137,123],[123,116],[116,137],[41,38],[38,72],[72,41],[203,129],[129,142],[142,203],[64,98],[98,240],[240,64],[49,102],[102,64],[64,49],[41,73],[73,74],[74,41],[212,216],[216,207],[207,212],[42,74],[74,184],[184,42],[169,170],[170,211],[211,169],[170,149],[149,176],[176,170],[105,66],[66,69],[69,105],[122,6],[6,168],[168,122],[123,147],[147,187],[187,123],[96,77],[77,90],[90,96],[65,55],[55,107],[107,65],[89,90],[90,180],[180,89],[101,100],[100,120],[120,101],[63,105],[105,104],[104,63],[93,137],[137,227],[227,93],[15,86],[86,85],[85,15],[129,102],[102,49],[49,129],[14,87],[87,86],[86,14],[55,8],[8,9],[9,55],[100,47],[47,121],[121,100],[145,23],[23,22],[22,145],[88,89],[89,179],[179,88],[6,122],[122,196],[196,6],[88,95],[95,96],[96,88],[138,172],[172,136],[136,138],[215,58],[58,172],[172,215],[115,48],[48,219],[219,115],[42,80],[80,81],[81,42],[195,3],[3,51],[51,195],[43,146],[146,61],[61,43],[171,175],[175,199],[199,171],[81,82],[82,38],[38,81],[53,46],[46,225],[225,53],[144,163],[163,110],[110,144],[52,65],[65,66],[66,52],[229,228],[228,117],[117,229],[34,127],[127,234],[234,34],[107,108],[108,69],[69,107],[109,108],[108,151],[151,109],[48,64],[64,235],[235,48],[62,78],[78,191],[191,62],[129,209],[209,126],[126,129],[111,35],[35,143],[143,111],[117,123],[123,50],[50,117],[222,65],[65,52],[52,222],[19,125],[125,141],[141,19],[221,55],[55,65],[65,221],[3,195],[195,197],[197,3],[25,7],[7,33],[33,25],[220,237],[237,44],[44,220],[70,71],[71,139],[139,70],[122,193],[193,245],[245,122],[247,130],[130,33],[33,247],[71,21],[21,162],[162,71],[170,169],[169,150],[150,170],[188,174],[174,196],[196,188],[216,186],[186,92],[92,216],[2,97],[97,167],[167,2],[141,125],[125,241],[241,141],[164,167],[167,37],[37,164],[72,38],[38,12],[12,72],[38,82],[82,13],[13,38],[63,68],[68,71],[71,63],[226,35],[35,111],[111,226],[101,50],[50,205],[205,101],[206,92],[92,165],[165,206],[209,198],[198,217],[217,209],[165,167],[167,97],[97,165],[220,115],[115,218],[218,220],[133,112],[112,243],[243,133],[239,238],[238,241],[241,239],[214,135],[135,169],[169,214],[190,173],[173,133],[133,190],[171,208],[208,32],[32,171],[125,44],[44,237],[237,125],[86,87],[87,178],[178,86],[85,86],[86,179],[179,85],[84,85],[85,180],[180,84],[83,84],[84,181],[181,83],[201,83],[83,182],[182,201],[137,93],[93,132],[132,137],[76,62],[62,183],[183,76],[61,76],[76,184],[184,61],[57,61],[61,185],[185,57],[212,57],[57,186],[186,212],[214,207],[207,187],[187,214],[34,143],[143,156],[156,34],[79,239],[239,237],[237,79],[123,137],[137,177],[177,123],[44,1],[1,4],[4,44],[201,194],[194,32],[32,201],[64,102],[102,129],[129,64],[213,215],[215,138],[138,213],[59,166],[166,219],[219,59],[242,99],[99,97],[97,242],[2,94],[94,141],[141,2],[75,59],[59,235],[235,75],[24,110],[110,228],[228,24],[25,130],[130,226],[226,25],[23,24],[24,229],[229,23],[22,23],[23,230],[230,22],[26,22],[22,231],[231,26],[112,26],[26,232],[232,112],[189,190],[190,243],[243,189],[221,56],[56,190],[190,221],[28,56],[56,221],[221,28],[27,28],[28,222],[222,27],[29,27],[27,223],[223,29],[30,29],[29,224],[224,30],[247,30],[30,225],[225,247],[238,79],[79,20],[20,238],[166,59],[59,75],[75,166],[60,75],[75,240],[240,60],[147,177],[177,215],[215,147],[20,79],[79,166],[166,20],[187,147],[147,213],[213,187],[112,233],[233,244],[244,112],[233,128],[128,245],[245,233],[128,114],[114,188],[188,128],[114,217],[217,174],[174,114],[131,115],[115,220],[220,131],[217,198],[198,236],[236,217],[198,131],[131,134],[134,198],[177,132],[132,58],[58,177],[143,35],[35,124],[124,143],[110,163],[163,7],[7,110],[228,110],[110,25],[25,228],[356,389],[389,368],[368,356],[11,302],[302,267],[267,11],[452,350],[350,349],[349,452],[302,303],[303,269],[269,302],[357,343],[343,277],[277,357],[452,453],[453,357],[357,452],[333,332],[332,297],[297,333],[175,152],[152,377],[377,175],[347,348],[348,330],[330,347],[303,304],[304,270],[270,303],[9,336],[336,337],[337,9],[278,279],[279,360],[360,278],[418,262],[262,431],[431,418],[304,408],[408,409],[409,304],[310,415],[415,407],[407,310],[270,409],[409,410],[410,270],[450,348],[348,347],[347,450],[422,430],[430,434],[434,422],[313,314],[314,17],[17,313],[306,307],[307,375],[375,306],[387,388],[388,260],[260,387],[286,414],[414,398],[398,286],[335,406],[406,418],[418,335],[364,367],[367,416],[416,364],[423,358],[358,327],[327,423],[251,284],[284,298],[298,251],[281,5],[5,4],[4,281],[373,374],[374,253],[253,373],[307,320],[320,321],[321,307],[425,427],[427,411],[411,425],[421,313],[313,18],[18,421],[321,405],[405,406],[406,321],[320,404],[404,405],[405,320],[315,16],[16,17],[17,315],[426,425],[425,266],[266,426],[377,400],[400,369],[369,377],[322,391],[391,269],[269,322],[417,465],[465,464],[464,417],[386,257],[257,258],[258,386],[466,260],[260,388],[388,466],[456,399],[399,419],[419,456],[284,332],[332,333],[333,284],[417,285],[285,8],[8,417],[346,340],[340,261],[261,346],[413,441],[441,285],[285,413],[327,460],[460,328],[328,327],[355,371],[371,329],[329,355],[392,439],[439,438],[438,392],[382,341],[341,256],[256,382],[429,420],[420,360],[360,429],[364,394],[394,379],[379,364],[277,343],[343,437],[437,277],[443,444],[444,283],[283,443],[275,440],[440,363],[363,275],[431,262],[262,369],[369,431],[297,338],[338,337],[337,297],[273,375],[375,321],[321,273],[450,451],[451,349],[349,450],[446,342],[342,467],[467,446],[293,334],[334,282],[282,293],[458,461],[461,462],[462,458],[276,353],[353,383],[383,276],[308,324],[324,325],[325,308],[276,300],[300,293],[293,276],[372,345],[345,447],[447,372],[352,345],[345,340],[340,352],[274,1],[1,19],[19,274],[456,248],[248,281],[281,456],[436,427],[427,425],[425,436],[381,256],[256,252],[252,381],[269,391],[391,393],[393,269],[200,199],[199,428],[428,200],[266,330],[330,329],[329,266],[287,273],[273,422],[422,287],[250,462],[462,328],[328,250],[258,286],[286,384],[384,258],[265,353],[353,342],[342,265],[387,259],[259,257],[257,387],[424,431],[431,430],[430,424],[342,353],[353,276],[276,342],[273,335],[335,424],[424,273],[292,325],[325,307],[307,292],[366,447],[447,345],[345,366],[271,303],[303,302],[302,271],[423,266],[266,371],[371,423],[294,455],[455,460],[460,294],[279,278],[278,294],[294,279],[271,272],[272,304],[304,271],[432,434],[434,427],[427,432],[272,407],[407,408],[408,272],[394,430],[430,431],[431,394],[395,369],[369,400],[400,395],[334,333],[333,299],[299,334],[351,417],[417,168],[168,351],[352,280],[280,411],[411,352],[325,319],[319,320],[320,325],[295,296],[296,336],[336,295],[319,403],[403,404],[404,319],[330,348],[348,349],[349,330],[293,298],[298,333],[333,293],[323,454],[454,447],[447,323],[15,16],[16,315],[315,15],[358,429],[429,279],[279,358],[14,15],[15,316],[316,14],[285,336],[336,9],[9,285],[329,349],[349,350],[350,329],[374,380],[380,252],[252,374],[318,402],[402,403],[403,318],[6,197],[197,419],[419,6],[318,319],[319,325],[325,318],[367,364],[364,365],[365,367],[435,367],[367,397],[397,435],[344,438],[438,439],[439,344],[272,271],[271,311],[311,272],[195,5],[5,281],[281,195],[273,287],[287,291],[291,273],[396,428],[428,199],[199,396],[311,271],[271,268],[268,311],[283,444],[444,445],[445,283],[373,254],[254,339],[339,373],[282,334],[334,296],[296,282],[449,347],[347,346],[346,449],[264,447],[447,454],[454,264],[336,296],[296,299],[299,336],[338,10],[10,151],[151,338],[278,439],[439,455],[455,278],[292,407],[407,415],[415,292],[358,371],[371,355],[355,358],[340,345],[345,372],[372,340],[346,347],[347,280],[280,346],[442,443],[443,282],[282,442],[19,94],[94,370],[370,19],[441,442],[442,295],[295,441],[248,419],[419,197],[197,248],[263,255],[255,359],[359,263],[440,275],[275,274],[274,440],[300,383],[383,368],[368,300],[351,412],[412,465],[465,351],[263,467],[467,466],[466,263],[301,368],[368,389],[389,301],[395,378],[378,379],[379,395],[412,351],[351,419],[419,412],[436,426],[426,322],[322,436],[2,164],[164,393],[393,2],[370,462],[462,461],[461,370],[164,0],[0,267],[267,164],[302,11],[11,12],[12,302],[268,12],[12,13],[13,268],[293,300],[300,301],[301,293],[446,261],[261,340],[340,446],[330,266],[266,425],[425,330],[426,423],[423,391],[391,426],[429,355],[355,437],[437,429],[391,327],[327,326],[326,391],[440,457],[457,438],[438,440],[341,382],[382,362],[362,341],[459,457],[457,461],[461,459],[434,430],[430,394],[394,434],[414,463],[463,362],[362,414],[396,369],[369,262],[262,396],[354,461],[461,457],[457,354],[316,403],[403,402],[402,316],[315,404],[404,403],[403,315],[314,405],[405,404],[404,314],[313,406],[406,405],[405,313],[421,418],[418,406],[406,421],[366,401],[401,361],[361,366],[306,408],[408,407],[407,306],[291,409],[409,408],[408,291],[287,410],[410,409],[409,287],[432,436],[436,410],[410,432],[434,416],[416,411],[411,434],[264,368],[368,383],[383,264],[309,438],[438,457],[457,309],[352,376],[376,401],[401,352],[274,275],[275,4],[4,274],[421,428],[428,262],[262,421],[294,327],[327,358],[358,294],[433,416],[416,367],[367,433],[289,455],[455,439],[439,289],[462,370],[370,326],[326,462],[2,326],[326,370],[370,2],[305,460],[460,455],[455,305],[254,449],[449,448],[448,254],[255,261],[261,446],[446,255],[253,450],[450,449],[449,253],[252,451],[451,450],[450,252],[256,452],[452,451],[451,256],[341,453],[453,452],[452,341],[413,464],[464,463],[463,413],[441,413],[413,414],[414,441],[258,442],[442,441],[441,258],[257,443],[443,442],[442,257],[259,444],[444,443],[443,259],[260,445],[445,444],[444,260],[467,342],[342,445],[445,467],[459,458],[458,250],[250,459],[289,392],[392,290],[290,289],[290,328],[328,460],[460,290],[376,433],[433,435],[435,376],[250,290],[290,392],[392,250],[411,416],[416,433],[433,411],[341,463],[463,464],[464,341],[453,464],[464,465],[465,453],[357,465],[465,412],[412,357],[343,412],[412,399],[399,343],[360,363],[363,440],[440,360],[437,399],[399,456],[456,437],[420,456],[456,363],[363,420],[401,435],[435,288],[288,401],[372,383],[383,353],[353,372],[339,255],[255,249],[249,339],[448,261],[261,255],[255,448],[133,243],[243,190],[190,133],[133,155],[155,112],[112,133],[33,246],[246,247],[247,33],[33,130],[130,25],[25,33],[398,384],[384,286],[286,398],[362,398],[398,414],[414,362],[362,463],[463,341],[341,362],[263,359],[359,467],[467,263],[263,249],[249,255],[255,263],[466,467],[467,260],[260,466],[75,60],[60,166],[166,75],[238,239],[239,79],[79,238],[162,127],[127,139],[139,162],[72,11],[11,37],[37,72],[121,232],[232,120],[120,121],[73,72],[72,39],[39,73],[114,128],[128,47],[47,114],[233,232],[232,128],[128,233],[103,104],[104,67],[67,103],[152,175],[175,148],[148,152],[119,118],[118,101],[101,119],[74,73],[73,40],[40,74],[107,9],[9,108],[108,107],[49,48],[48,131],[131,49],[32,194],[194,211],[211,32],[184,74],[74,185],[185,184],[191,80],[80,183],[183,191],[185,40],[40,186],[186,185],[119,230],[230,118],[118,119],[210,202],[202,214],[214,210],[84,83],[83,17],[17,84],[77,76],[76,146],[146,77],[161,160],[160,30],[30,161],[190,56],[56,173],[173,190],[182,106],[106,194],[194,182],[138,135],[135,192],[192,138],[129,203],[203,98],[98,129],[54,21],[21,68],[68,54],[5,51],[51,4],[4,5],[145,144],[144,23],[23,145],[90,77],[77,91],[91,90],[207,205],[205,187],[187,207],[83,201],[201,18],[18,83],[181,91],[91,182],[182,181],[180,90],[90,181],[181,180],[16,85],[85,17],[17,16],[205,206],[206,36],[36,205],[176,148],[148,140],[140,176],[165,92],[92,39],[39,165],[245,193],[193,244],[244,245],[27,159],[159,28],[28,27],[30,247],[247,161],[161,30],[174,236],[236,196],[196,174],[103,54],[54,104],[104,103],[55,193],[193,8],[8,55],[111,117],[117,31],[31,111],[221,189],[189,55],[55,221],[240,98],[98,99],[99,240],[142,126],[126,100],[100,142],[219,166],[166,218],[218,219],[112,155],[155,26],[26,112],[198,209],[209,131],[131,198],[169,135],[135,150],[150,169],[114,47],[47,217],[217,114],[224,223],[223,53],[53,224],[220,45],[45,134],[134,220],[32,211],[211,140],[140,32],[109,67],[67,108],[108,109],[146,43],[43,91],[91,146],[231,230],[230,120],[120,231],[113,226],[226,247],[247,113],[105,63],[63,52],[52,105],[241,238],[238,242],[242,241],[124,46],[46,156],[156,124],[95,78],[78,96],[96,95],[70,46],[46,63],[63,70],[116,143],[143,227],[227,116],[116,123],[123,111],[111,116],[1,44],[44,19],[19,1],[3,236],[236,51],[51,3],[207,216],[216,205],[205,207],[26,154],[154,22],[22,26],[165,39],[39,167],[167,165],[199,200],[200,208],[208,199],[101,36],[36,100],[100,101],[43,57],[57,202],[202,43],[242,20],[20,99],[99,242],[56,28],[28,157],[157,56],[124,35],[35,113],[113,124],[29,160],[160,27],[27,29],[211,204],[204,210],[210,211],[124,113],[113,46],[46,124],[106,43],[43,204],[204,106],[96,62],[62,77],[77,96],[227,137],[137,116],[116,227],[73,41],[41,72],[72,73],[36,203],[203,142],[142,36],[235,64],[64,240],[240,235],[48,49],[49,64],[64,48],[42,41],[41,74],[74,42],[214,212],[212,207],[207,214],[183,42],[42,184],[184,183],[210,169],[169,211],[211,210],[140,170],[170,176],[176,140],[104,105],[105,69],[69,104],[193,122],[122,168],[168,193],[50,123],[123,187],[187,50],[89,96],[96,90],[90,89],[66,65],[65,107],[107,66],[179,89],[89,180],[180,179],[119,101],[101,120],[120,119],[68,63],[63,104],[104,68],[234,93],[93,227],[227,234],[16,15],[15,85],[85,16],[209,129],[129,49],[49,209],[15,14],[14,86],[86,15],[107,55],[55,9],[9,107],[120,100],[100,121],[121,120],[153,145],[145,22],[22,153],[178,88],[88,179],[179,178],[197,6],[6,196],[196,197],[89,88],[88,96],[96,89],[135,138],[138,136],[136,135],[138,215],[215,172],[172,138],[218,115],[115,219],[219,218],[41,42],[42,81],[81,41],[5,195],[195,51],[51,5],[57,43],[43,61],[61,57],[208,171],[171,199],[199,208],[41,81],[81,38],[38,41],[224,53],[53,225],[225,224],[24,144],[144,110],[110,24],[105,52],[52,66],[66,105],[118,229],[229,117],[117,118],[227,34],[34,234],[234,227],[66,107],[107,69],[69,66],[10,109],[109,151],[151,10],[219,48],[48,235],[235,219],[183,62],[62,191],[191,183],[142,129],[129,126],[126,142],[116,111],[111,143],[143,116],[118,117],[117,50],[50,118],[223,222],[222,52],[52,223],[94,19],[19,141],[141,94],[222,221],[221,65],[65,222],[196,3],[3,197],[197,196],[45,220],[220,44],[44,45],[156,70],[70,139],[139,156],[188,122],[122,245],[245,188],[139,71],[71,162],[162,139],[149,170],[170,150],[150,149],[122,188],[188,196],[196,122],[206,216],[216,92],[92,206],[164,2],[2,167],[167,164],[242,141],[141,241],[241,242],[0,164],[164,37],[37,0],[11,72],[72,12],[12,11],[12,38],[38,13],[13,12],[70,63],[63,71],[71,70],[31,226],[226,111],[111,31],[36,101],[101,205],[205,36],[203,206],[206,165],[165,203],[126,209],[209,217],[217,126],[98,165],[165,97],[97,98],[237,220],[220,218],[218,237],[237,239],[239,241],[241,237],[210,214],[214,169],[169,210],[140,171],[171,32],[32,140],[241,125],[125,237],[237,241],[179,86],[86,178],[178,179],[180,85],[85,179],[179,180],[181,84],[84,180],[180,181],[182,83],[83,181],[181,182],[194,201],[201,182],[182,194],[177,137],[137,132],[132,177],[184,76],[76,183],[183,184],[185,61],[61,184],[184,185],[186,57],[57,185],[185,186],[216,212],[212,186],[186,216],[192,214],[214,187],[187,192],[139,34],[34,156],[156,139],[218,79],[79,237],[237,218],[147,123],[123,177],[177,147],[45,44],[44,4],[4,45],[208,201],[201,32],[32,208],[98,64],[64,129],[129,98],[192,213],[213,138],[138,192],[235,59],[59,219],[219,235],[141,242],[242,97],[97,141],[97,2],[2,141],[141,97],[240,75],[75,235],[235,240],[229,24],[24,228],[228,229],[31,25],[25,226],[226,31],[230,23],[23,229],[229,230],[231,22],[22,230],[230,231],[232,26],[26,231],[231,232],[233,112],[112,232],[232,233],[244,189],[189,243],[243,244],[189,221],[221,190],[190,189],[222,28],[28,221],[221,222],[223,27],[27,222],[222,223],[224,29],[29,223],[223,224],[225,30],[30,224],[224,225],[113,247],[247,225],[225,113],[99,60],[60,240],[240,99],[213,147],[147,215],[215,213],[60,20],[20,166],[166,60],[192,187],[187,213],[213,192],[243,112],[112,244],[244,243],[244,233],[233,245],[245,244],[245,128],[128,188],[188,245],[188,114],[114,174],[174,188],[134,131],[131,220],[220,134],[174,217],[217,236],[236,174],[236,198],[198,134],[134,236],[215,177],[177,58],[58,215],[156,143],[143,124],[124,156],[25,110],[110,7],[7,25],[31,228],[228,25],[25,31],[264,356],[356,368],[368,264],[0,11],[11,267],[267,0],[451,452],[452,349],[349,451],[267,302],[302,269],[269,267],[350,357],[357,277],[277,350],[350,452],[452,357],[357,350],[299,333],[333,297],[297,299],[396,175],[175,377],[377,396],[280,347],[347,330],[330,280],[269,303],[303,270],[270,269],[151,9],[9,337],[337,151],[344,278],[278,360],[360,344],[424,418],[418,431],[431,424],[270,304],[304,409],[409,270],[272,310],[310,407],[407,272],[322,270],[270,410],[410,322],[449,450],[450,347],[347,449],[432,422],[422,434],[434,432],[18,313],[313,17],[17,18],[291,306],[306,375],[375,291],[259,387],[387,260],[260,259],[424,335],[335,418],[418,424],[434,364],[364,416],[416,434],[391,423],[423,327],[327,391],[301,251],[251,298],[298,301],[275,281],[281,4],[4,275],[254,373],[373,253],[253,254],[375,307],[307,321],[321,375],[280,425],[425,411],[411,280],[200,421],[421,18],[18,200],[335,321],[321,406],[406,335],[321,320],[320,405],[405,321],[314,315],[315,17],[17,314],[423,426],[426,266],[266,423],[396,377],[377,369],[369,396],[270,322],[322,269],[269,270],[413,417],[417,464],[464,413],[385,386],[386,258],[258,385],[248,456],[456,419],[419,248],[298,284],[284,333],[333,298],[168,417],[417,8],[8,168],[448,346],[346,261],[261,448],[417,413],[413,285],[285,417],[326,327],[327,328],[328,326],[277,355],[355,329],[329,277],[309,392],[392,438],[438,309],[381,382],[382,256],[256,381],[279,429],[429,360],[360,279],[365,364],[364,379],[379,365],[355,277],[277,437],[437,355],[282,443],[443,283],[283,282],[281,275],[275,363],[363,281],[395,431],[431,369],[369,395],[299,297],[297,337],[337,299],[335,273],[273,321],[321,335],[348,450],[450,349],[349,348],[359,446],[446,467],[467,359],[283,293],[293,282],[282,283],[250,458],[458,462],[462,250],[300,276],[276,383],[383,300],[292,308],[308,325],[325,292],[283,276],[276,293],[293,283],[264,372],[372,447],[447,264],[346,352],[352,340],[340,346],[354,274],[274,19],[19,354],[363,456],[456,281],[281,363],[426,436],[436,425],[425,426],[380,381],[381,252],[252,380],[267,269],[269,393],[393,267],[421,200],[200,428],[428,421],[371,266],[266,329],[329,371],[432,287],[287,422],[422,432],[290,250],[250,328],[328,290],[385,258],[258,384],[384,385],[446,265],[265,342],[342,446],[386,387],[387,257],[257,386],[422,424],[424,430],[430,422],[445,342],[342,276],[276,445],[422,273],[273,424],[424,422],[306,292],[292,307],[307,306],[352,366],[366,345],[345,352],[268,271],[271,302],[302,268],[358,423],[423,371],[371,358],[327,294],[294,460],[460,327],[331,279],[279,294],[294,331],[303,271],[271,304],[304,303],[436,432],[432,427],[427,436],[304,272],[272,408],[408,304],[395,394],[394,431],[431,395],[378,395],[395,400],[400,378],[296,334],[334,299],[299,296],[6,351],[351,168],[168,6],[376,352],[352,411],[411,376],[307,325],[325,320],[320,307],[285,295],[295,336],[336,285],[320,319],[319,404],[404,320],[329,330],[330,349],[349,329],[334,293],[293,333],[333,334],[366,323],[323,447],[447,366],[316,15],[15,315],[315,316],[331,358],[358,279],[279,331],[317,14],[14,316],[316,317],[8,285],[285,9],[9,8],[277,329],[329,350],[350,277],[253,374],[374,252],[252,253],[319,318],[318,403],[403,319],[351,6],[6,419],[419,351],[324,318],[318,325],[325,324],[397,367],[367,365],[365,397],[288,435],[435,397],[397,288],[278,344],[344,439],[439,278],[310,272],[272,311],[311,310],[248,195],[195,281],[281,248],[375,273],[273,291],[291,375],[175,396],[396,199],[199,175],[312,311],[311,268],[268,312],[276,283],[283,445],[445,276],[390,373],[373,339],[339,390],[295,282],[282,296],[296,295],[448,449],[449,346],[346,448],[356,264],[264,454],[454,356],[337,336],[336,299],[299,337],[337,338],[338,151],[151,337],[294,278],[278,455],[455,294],[308,292],[292,415],[415,308],[429,358],[358,355],[355,429],[265,340],[340,372],[372,265],[352,346],[346,280],[280,352],[295,442],[442,282],[282,295],[354,19],[19,370],[370,354],[285,441],[441,295],[295,285],[195,248],[248,197],[197,195],[457,440],[440,274],[274,457],[301,300],[300,368],[368,301],[417,351],[351,465],[465,417],[251,301],[301,389],[389,251],[394,395],[395,379],[379,394],[399,412],[412,419],[419,399],[410,436],[436,322],[322,410],[326,2],[2,393],[393,326],[354,370],[370,461],[461,354],[393,164],[164,267],[267,393],[268,302],[302,12],[12,268],[312,268],[268,13],[13,312],[298,293],[293,301],[301,298],[265,446],[446,340],[340,265],[280,330],[330,425],[425,280],[322,426],[426,391],[391,322],[420,429],[429,437],[437,420],[393,391],[391,326],[326,393],[344,440],[440,438],[438,344],[458,459],[459,461],[461,458],[364,434],[434,394],[394,364],[428,396],[396,262],[262,428],[274,354],[354,457],[457,274],[317,316],[316,402],[402,317],[316,315],[315,403],[403,316],[315,314],[314,404],[404,315],[314,313],[313,405],[405,314],[313,421],[421,406],[406,313],[323,366],[366,361],[361,323],[292,306],[306,407],[407,292],[306,291],[291,408],[408,306],[291,287],[287,409],[409,291],[287,432],[432,410],[410,287],[427,434],[434,411],[411,427],[372,264],[264,383],[383,372],[459,309],[309,457],[457,459],[366,352],[352,401],[401,366],[1,274],[274,4],[4,1],[418,421],[421,262],[262,418],[331,294],[294,358],[358,331],[435,433],[433,367],[367,435],[392,289],[289,439],[439,392],[328,462],[462,326],[326,328],[94,2],[2,370],[370,94],[289,305],[305,455],[455,289],[339,254],[254,448],[448,339],[359,255],[255,446],[446,359],[254,253],[253,449],[449,254],[253,252],[252,450],[450,253],[252,256],[256,451],[451,252],[256,341],[341,452],[452,256],[414,413],[413,463],[463,414],[286,441],[441,414],[414,286],[286,258],[258,441],[441,286],[258,257],[257,442],[442,258],[257,259],[259,443],[443,257],[259,260],[260,444],[444,259],[260,467],[467,445],[445,260],[309,459],[459,250],[250,309],[305,289],[289,290],[290,305],[305,290],[290,460],[460,305],[401,376],[376,435],[435,401],[309,250],[250,392],[392,309],[376,411],[411,433],[433,376],[453,341],[341,464],[464,453],[357,453],[453,465],[465,357],[343,357],[357,412],[412,343],[437,343],[343,399],[399,437],[344,360],[360,440],[440,344],[420,437],[437,456],[456,420],[360,420],[420,363],[363,360],[361,401],[401,288],[288,361],[265,372],[372,353],[353,265],[390,339],[339,249],[249,390],[339,448],[448,255],[255,339]]),w("HAND_CONNECTIONS",[[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[0,17],[17,18],[18,19],[19,20]]),w("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),w("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,P:9,V:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,O:25,U:26,L:27,R:28,N:29,T:30,M:31,S:32})}).call(this)},EUkQ:function(t,e){function n(t){return t&&t.constructor&&"function"==typeof t.constructor.isBuffer&&t.constructor.isBuffer(t)}function r(t){return t}function i(t,e){const i=(e=e||{}).delimiter||".",s=e.maxDepth,o=e.transformKey||r,a={};return function t(r,l,c){c=c||1,Object.keys(r).forEach(function(u){const h=r[u],d=e.safe&&Array.isArray(h),p=Object.prototype.toString.call(h),f=n(h),m="[object Object]"===p||"[object Array]"===p,g=l?l+i+o(u):o(u);if(!d&&!f&&m&&Object.keys(h).length&&(!e.maxDepth||c<s))return t(h,g,c+1);a[g]=h})}(t),a}t.exports=i,i.flatten=i,i.unflatten=function t(e,s){const o=(s=s||{}).delimiter||".",a=s.overwrite||!1,l=s.transformKey||r,c={};if(n(e)||"[object Object]"!==Object.prototype.toString.call(e))return e;function u(t){const e=Number(t);return isNaN(e)||-1!==t.indexOf(".")||s.object?t:e}return e=Object.keys(e).reduce(function(t,n){const r=Object.prototype.toString.call(e[n]);return"[object Object]"!==r&&"[object Array]"!==r||function(t){const e=Object.prototype.toString.call(t);return!t||("[object Array]"===e?!t.length:"[object Object]"===e?!Object.keys(t).length:void 0)}(e[n])?(t[n]=e[n],t):function(t,e,n){return Object.keys(n).reduce(function(e,r){return e[t+o+r]=n[r],e},e)}(n,t,i(e[n],s))},{}),Object.keys(e).forEach(function(n){const r=n.split(o).map(l);let i=u(r.shift()),h=u(r[0]),d=c;for(;void 0!==h;){if("__proto__"===i)return;const t=Object.prototype.toString.call(d[i]),e="[object Object]"===t||"[object Array]"===t;if(!a&&!e&&void 0!==d[i])return;(a&&!e||!a&&null==d[i])&&(d[i]="number"!=typeof h||s.object?{}:[]),d=d[i],r.length>0&&(i=u(r.shift()),h=u(r[0]))}d[i]=t(e[n],s)}),c}},EhIR:function(t,e,n){(function(t){var r;!function(t,i,s){function o(t){var e,n=this,r=(e=4022871197,function(t){t=t.toString();for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)});n.next=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(t),n.s0<0&&(n.s0+=1),n.s1-=r(t),n.s1<0&&(n.s1+=1),n.s2-=r(t),n.s2<0&&(n.s2+=1),r=null}function a(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function l(t,e){var n=new o(t),r=e&&e.state,i=n.next;return i.int32=function(){return 4294967296*n.next()|0},i.double=function(){return i()+11102230246251565e-32*(2097152*i()|0)},i.quick=i,r&&("object"==typeof r&&a(r,n),i.state=function(){return a(n,{})}),i}i&&i.exports?i.exports=l:n("B9Yq")&&n("PDX0")?void 0===(r=(function(){return l}).call(e,n,e,i))||(i.exports=r):this.alea=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},MZFn:function(t,e,n){var r;t.exports=((r=function(){function t(t){return i.appendChild(t.dom),t}function e(t){for(var e=0;e<i.children.length;e++)i.children[e].style.display=e===t?"block":"none";n=t}var n=0,i=document.createElement("div");i.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",i.addEventListener("click",function(t){t.preventDefault(),e(++n%i.children.length)},!1);var s=(performance||Date).now(),o=s,a=0,l=t(new r.Panel("FPS","#0ff","#002")),c=t(new r.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var u=t(new r.Panel("MB","#f08","#201"));return e(0),{REVISION:16,dom:i,addPanel:t,showPanel:e,begin:function(){s=(performance||Date).now()},end:function(){a++;var t=(performance||Date).now();if(c.update(t-s,200),t>o+1e3&&(l.update(1e3*a/(t-o),100),o=t,a=0,u)){var e=performance.memory;u.update(e.usedJSHeapSize/1048576,e.jsHeapSizeLimit/1048576)}return t},update:function(){s=this.end()},domElement:i,setMode:e}}).Panel=function(t,e,n){var r=1/0,i=0,s=Math.round,o=s(window.devicePixelRatio||1),a=80*o,l=48*o,c=3*o,u=2*o,h=3*o,d=15*o,p=74*o,f=30*o,m=document.createElement("canvas");m.width=a,m.height=l,m.style.cssText="width:80px;height:48px";var g=m.getContext("2d");return g.font="bold "+9*o+"px Helvetica,Arial,sans-serif",g.textBaseline="top",g.fillStyle=n,g.fillRect(0,0,a,l),g.fillStyle=e,g.fillText(t,c,u),g.fillRect(h,d,p,f),g.fillStyle=n,g.globalAlpha=.9,g.fillRect(h,d,p,f),{dom:m,update:function(l,y){r=Math.min(r,l),i=Math.max(i,l),g.fillStyle=n,g.globalAlpha=1,g.fillRect(0,0,a,d),g.fillStyle=e,g.fillText(s(l)+" "+t+" ("+s(r)+"-"+s(i)+")",c,u),g.drawImage(m,h+o,d,p-o,f,h,d,p-o,f),g.fillRect(h+p-o,d,o,f),g.fillStyle=n,g.globalAlpha=.9,g.fillRect(h+p-o,d,o,s((1-l/y)*f))}}},r)},PDX0:function(t,e){(function(e){t.exports=e}).call(this,{})},YSVl:function(t,e,n){var r=n("EhIR"),i=n("uDiL"),s=n("pJ6O"),o=n("yuCN"),a=n("euyF"),l=n("ie1u"),c=n("pJ3+");c.alea=r,c.xor128=i,c.xorwow=s,c.xorshift7=o,c.xor4096=a,c.tychei=l,t.exports=c},YuTi:function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children||(t.children=[]),Object.defineProperty(t,"loaded",{enumerable:!0,get:function(){return t.l}}),Object.defineProperty(t,"id",{enumerable:!0,get:function(){return t.i}}),t.webpackPolyfill=1),t}},aOSE:function(t,e){(function(){"use strict";function t(t){var e=0;return function(){return e<t.length?{done:!1,value:t[e++]}:{done:!0}}}function e(e){var n="undefined"!=typeof Symbol&&Symbol.iterator&&e[Symbol.iterator];return n?n.call(e):{next:t(e)}}var n="function"==typeof Object.defineProperties?Object.defineProperty:function(t,e,n){return t==Array.prototype||t==Object.prototype||(t[e]=n.value),t},r=function(t){t=["object"==typeof globalThis&&globalThis,t,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof global&&global];for(var e=0;e<t.length;++e){var n=t[e];if(n&&n.Math==Math)return n}throw Error("Cannot find global object")}(this);function i(t,e){if(e)t:{var i=r;t=t.split(".");for(var s=0;s<t.length-1;s++){var o=t[s];if(!(o in i))break t;i=i[o]}(e=e(s=i[t=t[t.length-1]]))!=s&&null!=e&&n(i,t,{configurable:!0,writable:!0,value:e})}}var s="function"==typeof Object.assign?Object.assign:function(t,e){for(var n=1;n<arguments.length;n++){var r=arguments[n];if(r)for(var i in r)Object.prototype.hasOwnProperty.call(r,i)&&(t[i]=r[i])}return t};function o(t){return t||Array.prototype.fill}i("Object.assign",function(t){return t||s}),i("Array.prototype.fill",function(t){return t||function(t,e,n){var r=this.length||0;for(0>e&&(e=Math.max(0,r+e)),(null==n||n>r)&&(n=r),0>(n=Number(n))&&(n=Math.max(0,r+n)),e=Number(e||0);e<n;e++)this[e]=t;return this}}),i("Int8Array.prototype.fill",o),i("Uint8Array.prototype.fill",o),i("Uint8ClampedArray.prototype.fill",o),i("Int16Array.prototype.fill",o),i("Uint16Array.prototype.fill",o),i("Int32Array.prototype.fill",o),i("Uint32Array.prototype.fill",o),i("Float32Array.prototype.fill",o),i("Float64Array.prototype.fill",o);var a=this||self;function l(t,e){t=t.split(".");var n,r=a;t[0]in r||void 0===r.execScript||r.execScript("var "+t[0]);for(;t.length&&(n=t.shift());)t.length||void 0===e?r=r[n]&&r[n]!==Object.prototype[n]?r[n]:r[n]={}:r[n]=e}var c={color:"white",lineWidth:4,radius:6};function u(t){return t=t||{},Object.assign(Object.assign(Object.assign({},c),{fillColor:t.color}),t)}function h(t,e){return e&&t instanceof Function?t(e):t}function d(t,e,n){return Math.max(Math.min(e,n),Math.min(Math.max(e,n),t))}l("clamp",d),l("drawLandmarks",function(t,n,r){if(n){r=u(r),t.save();for(var i=t.canvas,s=(n=e(n)).next();!s.done;s=n.next())if(void 0!==(s=s.value)&&!(void 0!==s.visibility&&.5>s.visibility)){t.fillStyle=h(r.fillColor,s),t.strokeStyle=h(r.color,s),t.lineWidth=h(r.lineWidth,s);var o=new Path2D;o.arc(s.x*i.width,s.y*i.height,h(r.radius,s),0,2*Math.PI),t.fill(o),t.stroke(o)}t.restore()}}),l("drawConnectors",function(t,n,r,i){if(n&&r){i=u(i),t.save();var s=t.canvas;t.beginPath();for(var o=(r=e(r)).next();!o.done;o=r.next()){var a=o.value;o=n[a[0]],a=n[a[1]],o&&a&&(t.strokeStyle=h(i.color,o),t.lineWidth=h(i.lineWidth,o),t.moveTo(o.x*s.width,o.y*s.height),t.lineTo(a.x*s.width,a.y*s.height))}t.stroke(),t.restore()}}),l("drawRectangle",function(t,e,n){n=u(n),t.save();var r=t.canvas;t.beginPath(),t.lineWidth=h(n.lineWidth),t.strokeStyle=h(n.color),t.fillStyle=h(n.fillColor),t.translate(e.xCenter*r.width,e.yCenter*r.height),t.rotate(e.rotation*Math.PI/180),t.rect(-e.width/2*r.width,-e.height/2*r.height,e.width*r.width,e.height*r.height),t.translate(-e.xCenter*r.width,-e.yCenter*r.height),t.stroke(),t.fill(),t.restore()}),l("lerp",function(t,e,n,r,i){return d(r*(1-(t-e)/(n-e))+i*(1-(n-t)/(n-e)),r,i)})}).call(this)},euyF:function(t,e,n){(function(t){var r;!function(t,i,s){function o(t){var e=this;e.next=function(){var t,n,r=e.w,i=e.X,s=e.i;return e.w=r=r+1640531527|0,n=i[s+34&127],t=i[s=s+1&127],n^=n<<13,t^=t<<17,n=i[s]=(n^=n>>>15)^(t^=t>>>12),e.i=s,n+(r^r>>>16)|0},function(t,e){var n,r,i,s,o,a=[],l=128;for(e===(0|e)?(r=e,e=null):(e+="\0",r=0,l=Math.max(l,e.length)),i=0,s=-32;s<l;++s)e&&(r^=e.charCodeAt((s+32)%e.length)),0===s&&(o=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(i=0==(n=a[127&s]^=r+(o=o+1640531527|0))?i+1:0);for(i>=128&&(a[127&(e&&e.length||0)]=-1),i=127,s=512;s>0;--s)r=a[i+34&127],n=a[i=i+1&127],r^=r<<13,n^=n<<17,a[i]=(r^=r>>>15)^(n^=n>>>12);t.w=o,t.X=a,t.i=i}(e,t)}function a(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function l(t,e){null==t&&(t=+new Date);var n=new o(t),r=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,r&&(r.X&&a(r,n),i.state=function(){return a(n,{})}),i}i&&i.exports?i.exports=l:n("B9Yq")&&n("PDX0")?void 0===(r=(function(){return l}).call(e,n,e,i))||(i.exports=r):this.xor4096=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},ie1u:function(t,e,n){(function(t){var r;!function(t,i,s){function o(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,r=e.d,i=e.a;return t=t<<25^t>>>7^n,n=n-r|0,r=r<<24^r>>>8^i,i=i-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-r|0,e.d=r<<16^n>>>16^i,e.a=i-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var r=0;r<n.length+20;r++)e.b^=0|n.charCodeAt(r),e.next()}function a(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function l(t,e){var n=new o(t),r=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&a(r,n),i.state=function(){return a(n,{})}),i}i&&i.exports?i.exports=l:n("B9Yq")&&n("PDX0")?void 0===(r=(function(){return l}).call(e,n,e,i))||(i.exports=r):this.tychei=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},"pJ3+":function(t,e,n){var r;!function(i,s){var o,a=this,l=256,c=s.pow(l,6),u=s.pow(2,52),h=2*u,d=255;function p(t,e,n){var r=[],d=y(g((e=1==e?{entropy:!0}:e||{}).entropy?[t,v(i)]:null==t?function(){try{var t;return o&&(t=o.randomBytes)?t=t(l):(t=new Uint8Array(l),(a.crypto||a.msCrypto).getRandomValues(t)),v(t)}catch(r){var e=a.navigator,n=e&&e.plugins;return[+new Date,a,n,a.screen,v(i)]}}():t,3),r),p=new f(r),b=function(){for(var t=p.g(6),e=c,n=0;t<u;)t=(t+n)*l,e*=l,n=p.g(1);for(;t>=h;)t/=2,e/=2,n>>>=1;return(t+n)/e};return b.int32=function(){return 0|p.g(4)},b.quick=function(){return p.g(4)/4294967296},b.double=b,y(v(p.S),i),(e.pass||n||function(t,e,n,r){return r&&(r.S&&m(r,p),t.state=function(){return m(p,{})}),n?(s.random=t,e):t})(b,d,"global"in e?e.global:this==s,e.state)}function f(t){var e,n=t.length,r=this,i=0,s=r.i=r.j=0,o=r.S=[];for(n||(t=[n++]);i<l;)o[i]=i++;for(i=0;i<l;i++)o[i]=o[s=d&s+t[i%n]+(e=o[i])],o[s]=e;(r.g=function(t){for(var e,n=0,i=r.i,s=r.j,o=r.S;t--;)e=o[i=d&i+1],n=n*l+o[d&(o[i]=o[s=d&s+e])+(o[s]=e)];return r.i=i,r.j=s,n})(l)}function m(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function g(t,e){var n,r=[],i=typeof t;if(e&&"object"==i)for(n in t)try{r.push(g(t[n],e-1))}catch(s){}return r.length?r:"string"==i?t:t+"\0"}function y(t,e){for(var n,r=t+"",i=0;i<r.length;)e[d&i]=d&(n^=19*e[d&i])+r.charCodeAt(i++);return v(e)}function v(t){return String.fromCharCode.apply(0,t)}if(s.seedrandom=p,y(s.random(),i),t.exports){t.exports=p;try{o=n(3)}catch(b){}}else void 0===(r=(function(){return p}).call(e,n,e,t))||(t.exports=r)}([],Math)},pJ6O:function(t,e,n){(function(t){var r;!function(t,i,s){function o(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),r==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function a(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function l(t,e){var n=new o(t),r=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&a(r,n),i.state=function(){return a(n,{})}),i}i&&i.exports?i.exports=l:n("B9Yq")&&n("PDX0")?void 0===(r=(function(){return l}).call(e,n,e,i))||(i.exports=r):this.xorwow=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},qkWt:function(t,e,n){t.exports=function(t){var e={};function n(r){if(e[r])return e[r].exports;var i=e[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=t,n.c=e,n.d=function(t,e,r){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)n.d(r,i,(function(e){return t[e]}).bind(null,i));return r},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=8)}([function(t,e,n){var r,i;void 0===(i="function"==typeof(r={af:function(t,e){return e?"other":1==t?"one":"other"},ak:function(t,e){return e?"other":0==t||1==t?"one":"other"},am:function(t,e){return e?"other":t>=0&&t<=1?"one":"other"},ar:function(t,e){var n=String(t).split("."),r=Number(n[0])==t&&n[0].slice(-2);return e?"other":0==t?"zero":1==t?"one":2==t?"two":r>=3&&r<=10?"few":r>=11&&r<=99?"many":"other"},ars:function(t,e){var n=String(t).split("."),r=Number(n[0])==t&&n[0].slice(-2);return e?"other":0==t?"zero":1==t?"one":2==t?"two":r>=3&&r<=10?"few":r>=11&&r<=99?"many":"other"},as:function(t,e){return e?1==t||5==t||7==t||8==t||9==t||10==t?"one":2==t||3==t?"two":4==t?"few":6==t?"many":"other":t>=0&&t<=1?"one":"other"},asa:function(t,e){return e?"other":1==t?"one":"other"},ast:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},az:function(t,e){var n=String(t).split(".")[0],r=n.slice(-1),i=n.slice(-2),s=n.slice(-3);return e?1==r||2==r||5==r||7==r||8==r||20==i||50==i||70==i||80==i?"one":3==r||4==r||100==s||200==s||300==s||400==s||500==s||600==s||700==s||800==s||900==s?"few":0==n||6==r||40==i||60==i||90==i?"many":"other":1==t?"one":"other"},be:function(t,e){var n=String(t).split("."),r=Number(n[0])==t,i=r&&n[0].slice(-1),s=r&&n[0].slice(-2);return e?2!=i&&3!=i||12==s||13==s?"other":"few":1==i&&11!=s?"one":i>=2&&i<=4&&(s<12||s>14)?"few":r&&0==i||i>=5&&i<=9||s>=11&&s<=14?"many":"other"},bem:function(t,e){return e?"other":1==t?"one":"other"},bez:function(t,e){return e?"other":1==t?"one":"other"},bg:function(t,e){return e?"other":1==t?"one":"other"},bh:function(t,e){return e?"other":0==t||1==t?"one":"other"},bm:function(t,e){return"other"},bn:function(t,e){return e?1==t||5==t||7==t||8==t||9==t||10==t?"one":2==t||3==t?"two":4==t?"few":6==t?"many":"other":t>=0&&t<=1?"one":"other"},bo:function(t,e){return"other"},br:function(t,e){var n=String(t).split("."),r=Number(n[0])==t,i=r&&n[0].slice(-1),s=r&&n[0].slice(-2),o=r&&n[0].slice(-6);return e?"other":1==i&&11!=s&&71!=s&&91!=s?"one":2==i&&12!=s&&72!=s&&92!=s?"two":(3==i||4==i||9==i)&&(s<10||s>19)&&(s<70||s>79)&&(s<90||s>99)?"few":0!=t&&r&&0==o?"many":"other"},brx:function(t,e){return e?"other":1==t?"one":"other"},bs:function(t,e){var n=String(t).split("."),r=n[0],i=n[1]||"",s=!n[1],o=r.slice(-1),a=r.slice(-2),l=i.slice(-1),c=i.slice(-2);return e?"other":s&&1==o&&11!=a||1==l&&11!=c?"one":s&&o>=2&&o<=4&&(a<12||a>14)||l>=2&&l<=4&&(c<12||c>14)?"few":"other"},ca:function(t,e){var n=String(t).split(".");return e?1==t||3==t?"one":2==t?"two":4==t?"few":"other":1!=t||n[1]?"other":"one"},ce:function(t,e){return e?"other":1==t?"one":"other"},cgg:function(t,e){return e?"other":1==t?"one":"other"},chr:function(t,e){return e?"other":1==t?"one":"other"},ckb:function(t,e){return e?"other":1==t?"one":"other"},cs:function(t,e){var n=String(t).split("."),r=n[0],i=!n[1];return e?"other":1==t&&i?"one":r>=2&&r<=4&&i?"few":i?"other":"many"},cy:function(t,e){return e?0==t||7==t||8==t||9==t?"zero":1==t?"one":2==t?"two":3==t||4==t?"few":5==t||6==t?"many":"other":0==t?"zero":1==t?"one":2==t?"two":3==t?"few":6==t?"many":"other"},da:function(t,e){var n=String(t).split("."),r=n[0],i=Number(n[0])==t;return e||1!=t&&(i||0!=r&&1!=r)?"other":"one"},de:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},dsb:function(t,e){var n=String(t).split("."),r=n[1]||"",i=!n[1],s=n[0].slice(-2),o=r.slice(-2);return e?"other":i&&1==s||1==o?"one":i&&2==s||2==o?"two":i&&(3==s||4==s)||3==o||4==o?"few":"other"},dv:function(t,e){return e?"other":1==t?"one":"other"},dz:function(t,e){return"other"},ee:function(t,e){return e?"other":1==t?"one":"other"},el:function(t,e){return e?"other":1==t?"one":"other"},en:function(t,e){var n=String(t).split("."),r=!n[1],i=Number(n[0])==t,s=i&&n[0].slice(-1),o=i&&n[0].slice(-2);return e?1==s&&11!=o?"one":2==s&&12!=o?"two":3==s&&13!=o?"few":"other":1==t&&r?"one":"other"},eo:function(t,e){return e?"other":1==t?"one":"other"},es:function(t,e){return e?"other":1==t?"one":"other"},et:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},eu:function(t,e){return e?"other":1==t?"one":"other"},fa:function(t,e){return e?"other":t>=0&&t<=1?"one":"other"},ff:function(t,e){return e?"other":t>=0&&t<2?"one":"other"},fi:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},fil:function(t,e){var n=String(t).split("."),r=n[0],i=n[1]||"",s=!n[1],o=r.slice(-1),a=i.slice(-1);return e?1==t?"one":"other":s&&(1==r||2==r||3==r)||s&&4!=o&&6!=o&&9!=o||!s&&4!=a&&6!=a&&9!=a?"one":"other"},fo:function(t,e){return e?"other":1==t?"one":"other"},fr:function(t,e){return e?1==t?"one":"other":t>=0&&t<2?"one":"other"},fur:function(t,e){return e?"other":1==t?"one":"other"},fy:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},ga:function(t,e){var n=String(t).split("."),r=Number(n[0])==t;return e?1==t?"one":"other":1==t?"one":2==t?"two":r&&t>=3&&t<=6?"few":r&&t>=7&&t<=10?"many":"other"},gd:function(t,e){var n=String(t).split("."),r=Number(n[0])==t;return e?1==t||11==t?"one":2==t||12==t?"two":3==t||13==t?"few":"other":1==t||11==t?"one":2==t||12==t?"two":r&&t>=3&&t<=10||r&&t>=13&&t<=19?"few":"other"},gl:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},gsw:function(t,e){return e?"other":1==t?"one":"other"},gu:function(t,e){return e?1==t?"one":2==t||3==t?"two":4==t?"few":6==t?"many":"other":t>=0&&t<=1?"one":"other"},guw:function(t,e){return e?"other":0==t||1==t?"one":"other"},gv:function(t,e){var n=String(t).split("."),r=n[0],i=!n[1],s=r.slice(-1),o=r.slice(-2);return e?"other":i&&1==s?"one":i&&2==s?"two":!i||0!=o&&20!=o&&40!=o&&60!=o&&80!=o?i?"other":"many":"few"},ha:function(t,e){return e?"other":1==t?"one":"other"},haw:function(t,e){return e?"other":1==t?"one":"other"},he:function(t,e){var n=String(t).split("."),r=n[0],i=!n[1],s=Number(n[0])==t,o=s&&n[0].slice(-1);return e?"other":1==t&&i?"one":2==r&&i?"two":i&&(t<0||t>10)&&s&&0==o?"many":"other"},hi:function(t,e){return e?1==t?"one":2==t||3==t?"two":4==t?"few":6==t?"many":"other":t>=0&&t<=1?"one":"other"},hr:function(t,e){var n=String(t).split("."),r=n[0],i=n[1]||"",s=!n[1],o=r.slice(-1),a=r.slice(-2),l=i.slice(-1),c=i.slice(-2);return e?"other":s&&1==o&&11!=a||1==l&&11!=c?"one":s&&o>=2&&o<=4&&(a<12||a>14)||l>=2&&l<=4&&(c<12||c>14)?"few":"other"},hsb:function(t,e){var n=String(t).split("."),r=n[1]||"",i=!n[1],s=n[0].slice(-2),o=r.slice(-2);return e?"other":i&&1==s||1==o?"one":i&&2==s||2==o?"two":i&&(3==s||4==s)||3==o||4==o?"few":"other"},hu:function(t,e){return e?1==t||5==t?"one":"other":1==t?"one":"other"},hy:function(t,e){return e?1==t?"one":"other":t>=0&&t<2?"one":"other"},ia:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},id:function(t,e){return"other"},ig:function(t,e){return"other"},ii:function(t,e){return"other"},in:function(t,e){return"other"},io:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},is:function(t,e){var n=String(t).split("."),r=n[0],i=Number(n[0])==t,s=r.slice(-1),o=r.slice(-2);return e?"other":i&&1==s&&11!=o||!i?"one":"other"},it:function(t,e){var n=String(t).split(".");return e?11==t||8==t||80==t||800==t?"many":"other":1!=t||n[1]?"other":"one"},iu:function(t,e){return e?"other":1==t?"one":2==t?"two":"other"},iw:function(t,e){var n=String(t).split("."),r=n[0],i=!n[1],s=Number(n[0])==t,o=s&&n[0].slice(-1);return e?"other":1==t&&i?"one":2==r&&i?"two":i&&(t<0||t>10)&&s&&0==o?"many":"other"},ja:function(t,e){return"other"},jbo:function(t,e){return"other"},jgo:function(t,e){return e?"other":1==t?"one":"other"},ji:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},jmc:function(t,e){return e?"other":1==t?"one":"other"},jv:function(t,e){return"other"},jw:function(t,e){return"other"},ka:function(t,e){var n=String(t).split(".")[0],r=n.slice(-2);return e?1==n?"one":0==n||r>=2&&r<=20||40==r||60==r||80==r?"many":"other":1==t?"one":"other"},kab:function(t,e){return e?"other":t>=0&&t<2?"one":"other"},kaj:function(t,e){return e?"other":1==t?"one":"other"},kcg:function(t,e){return e?"other":1==t?"one":"other"},kde:function(t,e){return"other"},kea:function(t,e){return"other"},kk:function(t,e){var n=String(t).split("."),r=Number(n[0])==t,i=r&&n[0].slice(-1);return e?6==i||9==i||r&&0==i&&0!=t?"many":"other":1==t?"one":"other"},kkj:function(t,e){return e?"other":1==t?"one":"other"},kl:function(t,e){return e?"other":1==t?"one":"other"},km:function(t,e){return"other"},kn:function(t,e){return e?"other":t>=0&&t<=1?"one":"other"},ko:function(t,e){return"other"},ks:function(t,e){return e?"other":1==t?"one":"other"},ksb:function(t,e){return e?"other":1==t?"one":"other"},ksh:function(t,e){return e?"other":0==t?"zero":1==t?"one":"other"},ku:function(t,e){return e?"other":1==t?"one":"other"},kw:function(t,e){return e?"other":1==t?"one":2==t?"two":"other"},ky:function(t,e){return e?"other":1==t?"one":"other"},lag:function(t,e){var n=String(t).split(".")[0];return e?"other":0==t?"zero":0!=n&&1!=n||0==t?"other":"one"},lb:function(t,e){return e?"other":1==t?"one":"other"},lg:function(t,e){return e?"other":1==t?"one":"other"},lkt:function(t,e){return"other"},ln:function(t,e){return e?"other":0==t||1==t?"one":"other"},lo:function(t,e){return e&&1==t?"one":"other"},lt:function(t,e){var n=String(t).split("."),r=n[1]||"",i=Number(n[0])==t,s=i&&n[0].slice(-1),o=i&&n[0].slice(-2);return e?"other":1==s&&(o<11||o>19)?"one":s>=2&&s<=9&&(o<11||o>19)?"few":0!=r?"many":"other"},lv:function(t,e){var n=String(t).split("."),r=n[1]||"",i=r.length,s=Number(n[0])==t,o=s&&n[0].slice(-1),a=s&&n[0].slice(-2),l=r.slice(-2),c=r.slice(-1);return e?"other":s&&0==o||a>=11&&a<=19||2==i&&l>=11&&l<=19?"zero":1==o&&11!=a||2==i&&1==c&&11!=l||2!=i&&1==c?"one":"other"},mas:function(t,e){return e?"other":1==t?"one":"other"},mg:function(t,e){return e?"other":0==t||1==t?"one":"other"},mgo:function(t,e){return e?"other":1==t?"one":"other"},mk:function(t,e){var n=String(t).split("."),r=n[0],i=n[1]||"",s=!n[1],o=r.slice(-1),a=r.slice(-2),l=i.slice(-1),c=i.slice(-2);return e?1==o&&11!=a?"one":2==o&&12!=a?"two":7!=o&&8!=o||17==a||18==a?"other":"many":s&&1==o&&11!=a||1==l&&11!=c?"one":"other"},ml:function(t,e){return e?"other":1==t?"one":"other"},mn:function(t,e){return e?"other":1==t?"one":"other"},mo:function(t,e){var n=String(t).split("."),r=!n[1],i=Number(n[0])==t&&n[0].slice(-2);return e?1==t?"one":"other":1==t&&r?"one":!r||0==t||1!=t&&i>=1&&i<=19?"few":"other"},mr:function(t,e){return e?1==t?"one":2==t||3==t?"two":4==t?"few":"other":t>=0&&t<=1?"one":"other"},ms:function(t,e){return e&&1==t?"one":"other"},mt:function(t,e){var n=String(t).split("."),r=Number(n[0])==t&&n[0].slice(-2);return e?"other":1==t?"one":0==t||r>=2&&r<=10?"few":r>=11&&r<=19?"many":"other"},my:function(t,e){return"other"},nah:function(t,e){return e?"other":1==t?"one":"other"},naq:function(t,e){return e?"other":1==t?"one":2==t?"two":"other"},nb:function(t,e){return e?"other":1==t?"one":"other"},nd:function(t,e){return e?"other":1==t?"one":"other"},ne:function(t,e){var n=String(t).split("."),r=Number(n[0])==t;return e?r&&t>=1&&t<=4?"one":"other":1==t?"one":"other"},nl:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},nn:function(t,e){return e?"other":1==t?"one":"other"},nnh:function(t,e){return e?"other":1==t?"one":"other"},no:function(t,e){return e?"other":1==t?"one":"other"},nqo:function(t,e){return"other"},nr:function(t,e){return e?"other":1==t?"one":"other"},nso:function(t,e){return e?"other":0==t||1==t?"one":"other"},ny:function(t,e){return e?"other":1==t?"one":"other"},nyn:function(t,e){return e?"other":1==t?"one":"other"},om:function(t,e){return e?"other":1==t?"one":"other"},or:function(t,e){var n=String(t).split("."),r=Number(n[0])==t;return e?1==t||5==t||r&&t>=7&&t<=9?"one":2==t||3==t?"two":4==t?"few":6==t?"many":"other":1==t?"one":"other"},os:function(t,e){return e?"other":1==t?"one":"other"},pa:function(t,e){return e?"other":0==t||1==t?"one":"other"},pap:function(t,e){return e?"other":1==t?"one":"other"},pl:function(t,e){var n=String(t).split("."),r=n[0],i=!n[1],s=r.slice(-1),o=r.slice(-2);return e?"other":1==t&&i?"one":i&&s>=2&&s<=4&&(o<12||o>14)?"few":i&&1!=r&&(0==s||1==s)||i&&s>=5&&s<=9||i&&o>=12&&o<=14?"many":"other"},prg:function(t,e){var n=String(t).split("."),r=n[1]||"",i=r.length,s=Number(n[0])==t,o=s&&n[0].slice(-1),a=s&&n[0].slice(-2),l=r.slice(-2),c=r.slice(-1);return e?"other":s&&0==o||a>=11&&a<=19||2==i&&l>=11&&l<=19?"zero":1==o&&11!=a||2==i&&1==c&&11!=l||2!=i&&1==c?"one":"other"},ps:function(t,e){return e?"other":1==t?"one":"other"},pt:function(t,e){var n=String(t).split(".")[0];return e?"other":0==n||1==n?"one":"other"},"pt-PT":function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},rm:function(t,e){return e?"other":1==t?"one":"other"},ro:function(t,e){var n=String(t).split("."),r=!n[1],i=Number(n[0])==t&&n[0].slice(-2);return e?1==t?"one":"other":1==t&&r?"one":!r||0==t||1!=t&&i>=1&&i<=19?"few":"other"},rof:function(t,e){return e?"other":1==t?"one":"other"},root:function(t,e){return"other"},ru:function(t,e){var n=String(t).split("."),r=n[0],i=!n[1],s=r.slice(-1),o=r.slice(-2);return e?"other":i&&1==s&&11!=o?"one":i&&s>=2&&s<=4&&(o<12||o>14)?"few":i&&0==s||i&&s>=5&&s<=9||i&&o>=11&&o<=14?"many":"other"},rwk:function(t,e){return e?"other":1==t?"one":"other"},sah:function(t,e){return"other"},saq:function(t,e){return e?"other":1==t?"one":"other"},sc:function(t,e){var n=String(t).split(".");return e?11==t||8==t||80==t||800==t?"many":"other":1!=t||n[1]?"other":"one"},scn:function(t,e){var n=String(t).split(".");return e?11==t||8==t||80==t||800==t?"many":"other":1!=t||n[1]?"other":"one"},sd:function(t,e){return e?"other":1==t?"one":"other"},sdh:function(t,e){return e?"other":1==t?"one":"other"},se:function(t,e){return e?"other":1==t?"one":2==t?"two":"other"},seh:function(t,e){return e?"other":1==t?"one":"other"},ses:function(t,e){return"other"},sg:function(t,e){return"other"},sh:function(t,e){var n=String(t).split("."),r=n[0],i=n[1]||"",s=!n[1],o=r.slice(-1),a=r.slice(-2),l=i.slice(-1),c=i.slice(-2);return e?"other":s&&1==o&&11!=a||1==l&&11!=c?"one":s&&o>=2&&o<=4&&(a<12||a>14)||l>=2&&l<=4&&(c<12||c>14)?"few":"other"},shi:function(t,e){var n=String(t).split("."),r=Number(n[0])==t;return e?"other":t>=0&&t<=1?"one":r&&t>=2&&t<=10?"few":"other"},si:function(t,e){var n=String(t).split(".");return e?"other":0==t||1==t||0==n[0]&&1==(n[1]||"")?"one":"other"},sk:function(t,e){var n=String(t).split("."),r=n[0],i=!n[1];return e?"other":1==t&&i?"one":r>=2&&r<=4&&i?"few":i?"other":"many"},sl:function(t,e){var n=String(t).split("."),r=!n[1],i=n[0].slice(-2);return e?"other":r&&1==i?"one":r&&2==i?"two":r&&(3==i||4==i)||!r?"few":"other"},sma:function(t,e){return e?"other":1==t?"one":2==t?"two":"other"},smi:function(t,e){return e?"other":1==t?"one":2==t?"two":"other"},smj:function(t,e){return e?"other":1==t?"one":2==t?"two":"other"},smn:function(t,e){return e?"other":1==t?"one":2==t?"two":"other"},sms:function(t,e){return e?"other":1==t?"one":2==t?"two":"other"},sn:function(t,e){return e?"other":1==t?"one":"other"},so:function(t,e){return e?"other":1==t?"one":"other"},sq:function(t,e){var n=String(t).split("."),r=Number(n[0])==t,i=r&&n[0].slice(-1),s=r&&n[0].slice(-2);return e?1==t?"one":4==i&&14!=s?"many":"other":1==t?"one":"other"},sr:function(t,e){var n=String(t).split("."),r=n[0],i=n[1]||"",s=!n[1],o=r.slice(-1),a=r.slice(-2),l=i.slice(-1),c=i.slice(-2);return e?"other":s&&1==o&&11!=a||1==l&&11!=c?"one":s&&o>=2&&o<=4&&(a<12||a>14)||l>=2&&l<=4&&(c<12||c>14)?"few":"other"},ss:function(t,e){return e?"other":1==t?"one":"other"},ssy:function(t,e){return e?"other":1==t?"one":"other"},st:function(t,e){return e?"other":1==t?"one":"other"},sv:function(t,e){var n=String(t).split("."),r=!n[1],i=Number(n[0])==t,s=i&&n[0].slice(-1),o=i&&n[0].slice(-2);return e?1!=s&&2!=s||11==o||12==o?"other":"one":1==t&&r?"one":"other"},sw:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},syr:function(t,e){return e?"other":1==t?"one":"other"},ta:function(t,e){return e?"other":1==t?"one":"other"},te:function(t,e){return e?"other":1==t?"one":"other"},teo:function(t,e){return e?"other":1==t?"one":"other"},th:function(t,e){return"other"},ti:function(t,e){return e?"other":0==t||1==t?"one":"other"},tig:function(t,e){return e?"other":1==t?"one":"other"},tk:function(t,e){var n=String(t).split("."),r=Number(n[0])==t&&n[0].slice(-1);return e?6==r||9==r||10==t?"few":"other":1==t?"one":"other"},tl:function(t,e){var n=String(t).split("."),r=n[0],i=n[1]||"",s=!n[1],o=r.slice(-1),a=i.slice(-1);return e?1==t?"one":"other":s&&(1==r||2==r||3==r)||s&&4!=o&&6!=o&&9!=o||!s&&4!=a&&6!=a&&9!=a?"one":"other"},tn:function(t,e){return e?"other":1==t?"one":"other"},to:function(t,e){return"other"},tr:function(t,e){return e?"other":1==t?"one":"other"},ts:function(t,e){return e?"other":1==t?"one":"other"},tzm:function(t,e){var n=String(t).split("."),r=Number(n[0])==t;return e?"other":0==t||1==t||r&&t>=11&&t<=99?"one":"other"},ug:function(t,e){return e?"other":1==t?"one":"other"},uk:function(t,e){var n=String(t).split("."),r=n[0],i=!n[1],s=Number(n[0])==t,o=s&&n[0].slice(-1),a=s&&n[0].slice(-2),l=r.slice(-1),c=r.slice(-2);return e?3==o&&13!=a?"few":"other":i&&1==l&&11!=c?"one":i&&l>=2&&l<=4&&(c<12||c>14)?"few":i&&0==l||i&&l>=5&&l<=9||i&&c>=11&&c<=14?"many":"other"},ur:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},uz:function(t,e){return e?"other":1==t?"one":"other"},ve:function(t,e){return e?"other":1==t?"one":"other"},vi:function(t,e){return e&&1==t?"one":"other"},vo:function(t,e){return e?"other":1==t?"one":"other"},vun:function(t,e){return e?"other":1==t?"one":"other"},wa:function(t,e){return e?"other":0==t||1==t?"one":"other"},wae:function(t,e){return e?"other":1==t?"one":"other"},wo:function(t,e){return"other"},xh:function(t,e){return e?"other":1==t?"one":"other"},xog:function(t,e){return e?"other":1==t?"one":"other"},yi:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},yo:function(t,e){return"other"},yue:function(t,e){return"other"},zh:function(t,e){return"other"},zu:function(t,e){return e?"other":t>=0&&t<=1?"one":"other"}})?r.call(e,n,e,t):r)||(t.exports=i)},function(t,e,n){t.exports={date:n(4),duration:n(5),number:n(6),time:n(7)}},function(t,e,n){"use strict";function r(t,e,n,i){this.message=t,this.expected=e,this.found=n,this.location=i,this.name="SyntaxError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,r)}!function(t,e){function n(){this.constructor=t}n.prototype=e.prototype,t.prototype=new n}(r,Error),r.buildMessage=function(t,e){var n={literal:function(t){return'"'+i(t.text)+'"'},class:function(t){var e,n="";for(e=0;e<t.parts.length;e++)n+=t.parts[e]instanceof Array?s(t.parts[e][0])+"-"+s(t.parts[e][1]):s(t.parts[e]);return"["+(t.inverted?"^":"")+n+"]"},any:function(t){return"any character"},end:function(t){return"end of input"},other:function(t){return t.description}};function r(t){return t.charCodeAt(0).toString(16).toUpperCase()}function i(t){return t.replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,function(t){return"\\x0"+r(t)}).replace(/[\x10-\x1F\x7F-\x9F]/g,function(t){return"\\x"+r(t)})}function s(t){return t.replace(/\\/g,"\\\\").replace(/\]/g,"\\]").replace(/\^/g,"\\^").replace(/-/g,"\\-").replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,function(t){return"\\x0"+r(t)}).replace(/[\x10-\x1F\x7F-\x9F]/g,function(t){return"\\x"+r(t)})}return"Expected "+function(t){var e,r,i,s=new Array(t.length);for(e=0;e<t.length;e++)s[e]=n[(i=t[e]).type](i);if(s.sort(),s.length>0){for(e=1,r=1;e<s.length;e++)s[e-1]!==s[e]&&(s[r]=s[e],r++);s.length=r}switch(s.length){case 1:return s[0];case 2:return s[0]+" or "+s[1];default:return s.slice(0,-1).join(", ")+", or "+s[s.length-1]}}(t)+" but "+function(t){return t?'"'+i(t)+'"':"end of input"}(e)+" found."},t.exports={SyntaxError:r,parse:function(t,e){e=void 0!==e?e:{};var n,i={},s={start:Tt},o=Tt,a=xt("#",!1),l=function(){return $t[0]},c=function(t){return t.join("")},u="{",h=xt("{",!1),d="}",p=xt("}",!1),f=",",m=xt(",",!1),g="select",y=xt("select",!1),v=function(t,n){return e.strict&&$t.unshift(!1),n},b=function(t,n){return e.strict&&$t.shift(),{type:"select",arg:t,cases:n}},_="plural",x=xt("plural",!1),w="selectordinal",S=xt("selectordinal",!1),E=function(t,n,r,i){var s=("selectordinal"===n?e.ordinal:e.cardinal)||["zero","one","two","few","many","other"];return s&&s.length&&i.forEach(function(e){if(isNaN(e.key)&&s.indexOf(e.key)<0)throw new Error("Invalid key `"+e.key+"` for argument `"+t+"`. Valid "+n+" keys for this locale are `"+s.join("`, `")+"`, and explicit keys like `=0`.")}),$t.shift(),{type:n,arg:t,offset:r||0,cases:i}},C=St("identifier"),T=/^[^\t-\r \x85\u200E\u200F\u2028\u2029!-\/:-@[-\^`{-~\xA1-\xA7\xA9\xAB\xAC\xAE\xB0\xB1\xB6\xBB\xBF\xD7\xF7\u2010-\u2027\u2030-\u203E\u2041-\u2053\u2055-\u205E\u2190-\u245F\u2500-\u2775\u2794-\u2BFF\u2E00-\u2E7F\u3001-\u3003\u3008-\u3020\u3030\uFD3E\uFD3F\uFE45\uFE46]/,A=wt([["\t","\r"]," ","\x85","\u200e","\u200f","\u2028","\u2029",["!","/"],[":","@"],["[","^"],"`",["{","~"],["\xa1","\xa7"],"\xa9","\xab","\xac","\xae","\xb0","\xb1","\xb6","\xbb","\xbf","\xd7","\xf7",["\u2010","\u2027"],["\u2030","\u203e"],["\u2041","\u2053"],["\u2055","\u205e"],["\u2190","\u245f"],["\u2500","\u2775"],["\u2794","\u2bff"],["\u2e00","\u2e7f"],["\u3001","\u3003"],["\u3008","\u3020"],"\u3030","\ufd3e","\ufd3f","\ufe45","\ufe46"],!0,!1),M=function(t,e){return{key:t,tokens:e}},k=St("plural offset"),R="offset",I=xt("offset",!1),N=xt(":",!1),O=xt("=",!1),D="number",L=xt("number",!1),F="date",P=xt("date",!1),$="time",B=xt("time",!1),z="spellout",V=xt("spellout",!1),U="ordinal",H=xt("ordinal",!1),W="duration",j=xt("duration",!1),G=function(t){if(e.strict||/^\d/.test(t))return!1;switch(t.toLowerCase()){case"select":case"plural":case"selectordinal":return!1;default:return!0}},q=function(t){return!e.strict},X=St("a valid (strict) function parameter"),K=/^[^'{}]/,Y=wt(["'","{","}"],!0,!1),Z="'",J=xt("'",!1),Q=St("doubled apostrophe"),tt=xt("''",!1),et=/^[^']/,nt=wt(["'"],!0,!1),rt=xt("'{",!1),it=xt("'}",!1),st=St("escaped string"),ot=xt("'#",!1),at=St("plain char"),lt=/^[^{}#\0-\x08\x0E-\x1F\x7F]/,ct=wt(["{","}","#",["\0","\b"],["\x0e","\x1f"],"\x7f"],!0,!1),ut=St("integer"),ht=/^[0-9]/,dt=wt([["0","9"]],!1,!1),pt=St("white space"),ft=/^[\t-\r \x85\u200E\u200F\u2028\u2029]/,mt=wt([["\t","\r"]," ","\x85","\u200e","\u200f","\u2028","\u2029"],!1,!1),gt=0,yt=[{line:1,column:1}],vt=0,bt=[],_t=0;if("startRule"in e){if(!(e.startRule in s))throw new Error("Can't start parsing from rule \""+e.startRule+'".');o=s[e.startRule]}function xt(t,e){return{type:"literal",text:t,ignoreCase:e}}function wt(t,e,n){return{type:"class",parts:t,inverted:e,ignoreCase:n}}function St(t){return{type:"other",description:t}}function Et(e){var n,r=yt[e];if(r)return r;for(n=e-1;!yt[n];)n--;for(r={line:(r=yt[n]).line,column:r.column};n<e;)10===t.charCodeAt(n)?(r.line++,r.column=1):r.column++,n++;return yt[e]=r,r}function Ct(t){gt<vt||(gt>vt&&(vt=gt,bt=[]),bt.push(t))}function Tt(){var t,e;for(t=[],e=At();e!==i;)t.push(e),e=At();return t}function At(){var e,n,r;if((e=function(){var e,n,r,s;return e=gt,123===t.charCodeAt(gt)?(n=u,gt++):(n=i,0===_t&&Ct(h)),n!==i&&Pt()!==i&&(r=Mt())!==i&&Pt()!==i?(125===t.charCodeAt(gt)?(s=d,gt++):(s=i,0===_t&&Ct(p)),s!==i?e=n=function(t){return{type:"argument",arg:t}}(r):(gt=e,e=i)):(gt=e,e=i),e}())===i&&(e=function(){var e,n,r,s,o,a,l,c,_;if(e=gt,123===t.charCodeAt(gt)?(n=u,gt++):(n=i,0===_t&&Ct(h)),n!==i)if(Pt()!==i)if((r=Mt())!==i)if(Pt()!==i)if(44===t.charCodeAt(gt)?(s=f,gt++):(s=i,0===_t&&Ct(m)),s!==i)if(Pt()!==i)if(t.substr(gt,6)===g?(o=g,gt+=6):(o=i,0===_t&&Ct(y)),o!==i&&(o=v(0,o)),o!==i)if((o=Pt())!==i)if(44===t.charCodeAt(gt)?(a=f,gt++):(a=i,0===_t&&Ct(m)),a!==i)if(Pt()!==i){if(l=[],(c=kt())!==i)for(;c!==i;)l.push(c),c=kt();else l=i;l!==i&&(c=Pt())!==i?(125===t.charCodeAt(gt)?(_=d,gt++):(_=i,0===_t&&Ct(p)),_!==i?e=n=b(r,l):(gt=e,e=i)):(gt=e,e=i)}else gt=e,e=i;else gt=e,e=i;else gt=e,e=i;else gt=e,e=i;else gt=e,e=i;else gt=e,e=i;else gt=e,e=i;else gt=e,e=i;else gt=e,e=i;else gt=e,e=i;return e}())===i&&(e=function(){var e,n,r,s,o,a,l,c,g,y,v;if(e=gt,123===t.charCodeAt(gt)?(n=u,gt++):(n=i,0===_t&&Ct(h)),n!==i)if(Pt()!==i)if((r=Mt())!==i)if(Pt()!==i)if(44===t.charCodeAt(gt)?(s=f,gt++):(s=i,0===_t&&Ct(m)),s!==i)if(Pt()!==i)if(t.substr(gt,6)===_?(a=_,gt+=6):(a=i,0===_t&&Ct(x)),a===i&&(t.substr(gt,13)===w?(a=w,gt+=13):(a=i,0===_t&&Ct(S))),a!==i&&(a=function(t,e){return $t.unshift(!0),e}(0,a)),(o=a)!==i)if((a=Pt())!==i)if(44===t.charCodeAt(gt)?(l=f,gt++):(l=i,0===_t&&Ct(m)),l!==i)if(Pt()!==i)if((c=function(){var e,n,r,s;return _t++,e=gt,Pt()!==i?(t.substr(gt,6)===R?(n=R,gt+=6):(n=i,0===_t&&Ct(I)),n!==i&&Pt()!==i?(58===t.charCodeAt(gt)?(r=":",gt++):(r=i,0===_t&&Ct(N)),r!==i&&Pt()!==i&&(s=Ft())!==i&&Pt()!==i?e=s:(gt=e,e=i)):(gt=e,e=i)):(gt=e,e=i),_t--,e===i&&0===_t&&Ct(k),e}())===i&&(c=null),c!==i){if(g=[],(y=Rt())!==i)for(;y!==i;)g.push(y),y=Rt();else g=i;g!==i&&(y=Pt())!==i?(125===t.charCodeAt(gt)?(v=d,gt++):(v=i,0===_t&&Ct(p)),v!==i?e=n=E(r,o,c,g):(gt=e,e=i)):(gt=e,e=i)}else gt=e,e=i;else gt=e,e=i;else gt=e,e=i;else gt=e,e=i;else gt=e,e=i;else gt=e,e=i;else gt=e,e=i;else gt=e,e=i;else gt=e,e=i;else gt=e,e=i;else gt=e,e=i;return e}())===i&&(e=function(){var e,n,r,s,o,a,l;return e=gt,123===t.charCodeAt(gt)?(n=u,gt++):(n=i,0===_t&&Ct(h)),n!==i&&Pt()!==i&&(r=Mt())!==i&&Pt()!==i?(44===t.charCodeAt(gt)?(s=f,gt++):(s=i,0===_t&&Ct(m)),s!==i&&Pt()!==i&&(o=function(){var e,n,r,s,o;return t.substr(gt,6)===D?(e=D,gt+=6):(e=i,0===_t&&Ct(L)),e===i&&(t.substr(gt,4)===F?(e=F,gt+=4):(e=i,0===_t&&Ct(P)),e===i&&(t.substr(gt,4)===$?(e=$,gt+=4):(e=i,0===_t&&Ct(B)),e===i&&(t.substr(gt,8)===z?(e=z,gt+=8):(e=i,0===_t&&Ct(V)),e===i&&(t.substr(gt,7)===U?(e=U,gt+=7):(e=i,0===_t&&Ct(H)),e===i&&(t.substr(gt,8)===W?(e=W,gt+=8):(e=i,0===_t&&Ct(j)),e===i&&(e=gt,n=gt,_t++,t.substr(gt,6)===g?(r=g,gt+=6):(r=i,0===_t&&Ct(y)),_t--,r===i?n=void 0:(gt=n,n=i),n!==i?(r=gt,_t++,t.substr(gt,6)===_?(s=_,gt+=6):(s=i,0===_t&&Ct(x)),_t--,s===i?r=void 0:(gt=r,r=i),r!==i?(s=gt,_t++,t.substr(gt,13)===w?(o=w,gt+=13):(o=i,0===_t&&Ct(S)),_t--,o===i?s=void 0:(gt=s,s=i),s!==i&&(o=Mt())!==i&&(G(o)?void 0:i)!==i?e=n=o:(gt=e,e=i)):(gt=e,e=i)):(gt=e,e=i))))))),e}())!==i&&Pt()!==i?((a=function(){var e,n,r,s;if(e=gt,Pt()!==i)if(44===t.charCodeAt(gt)?(n=f,gt++):(n=i,0===_t&&Ct(m)),n!==i){for(r=[],s=At();s!==i;)r.push(s),s=At();r!==i&&(s=(s=q())?void 0:i)!==i?e=function(t){return{tokens:t}}(r):(gt=e,e=i)}else gt=e,e=i;else gt=e,e=i;if(e===i)if(e=gt,Pt()!==i)if(44===t.charCodeAt(gt)?(n=f,gt++):(n=i,0===_t&&Ct(m)),n!==i){for(r=[],s=Nt();s!==i;)r.push(s),s=Nt();r!==i?e=function(t){return{tokens:[t.join("")]}}(r):(gt=e,e=i)}else gt=e,e=i;else gt=e,e=i;return e}())===i&&(a=null),a!==i?(125===t.charCodeAt(gt)?(l=d,gt++):(l=i,0===_t&&Ct(p)),l!==i?e=n=function(t,e,n){return{type:"function",arg:t,key:e,param:n}}(r,o,a):(gt=e,e=i)):(gt=e,e=i)):(gt=e,e=i)):(gt=e,e=i),e}())===i&&(e=gt,35===t.charCodeAt(gt)?(n="#",gt++):(n=i,0===_t&&Ct(a)),n!==i&&(r=(r=l())?void 0:i)!==i?e=n={type:"octothorpe"}:(gt=e,e=i),e===i)){if(e=gt,n=[],(r=Lt())!==i)for(;r!==i;)n.push(r),r=Lt();else n=i;n!==i&&(n=c(n)),e=n}return e}function Mt(){var e,n,r;if(_t++,e=gt,n=[],T.test(t.charAt(gt))?(r=t.charAt(gt),gt++):(r=i,0===_t&&Ct(A)),r!==i)for(;r!==i;)n.push(r),T.test(t.charAt(gt))?(r=t.charAt(gt),gt++):(r=i,0===_t&&Ct(A));else n=i;return e=n!==i?t.substring(e,gt):n,_t--,e===i&&(n=i,0===_t&&Ct(C)),e}function kt(){var t,e,n;return t=gt,Pt()!==i&&(e=Mt())!==i&&Pt()!==i&&(n=It())!==i?t=M(e,n):(gt=t,t=i),t}function Rt(){var e,n,r;return e=gt,Pt()!==i&&(n=function(){var e,n,r;return(e=Mt())===i&&(e=gt,61===t.charCodeAt(gt)?(n="=",gt++):(n=i,0===_t&&Ct(O)),n!==i&&(r=Ft())!==i?e=n=r:(gt=e,e=i)),e}())!==i&&Pt()!==i&&(r=It())!==i?e=M(n,r):(gt=e,e=i),e}function It(){var e,n,r,s,o,a;if(e=gt,123===t.charCodeAt(gt)?(n=u,gt++):(n=i,0===_t&&Ct(h)),n!==i)if(r=gt,(s=Pt())!==i?(o=gt,_t++,123===t.charCodeAt(gt)?(a=u,gt++):(a=i,0===_t&&Ct(h)),_t--,a!==i?(gt=o,o=void 0):o=i,o!==i?r=s=[s,o]:(gt=r,r=i)):(gt=r,r=i),r===i&&(r=null),r!==i){for(s=[],o=At();o!==i;)s.push(o),o=At();s!==i&&(o=Pt())!==i?(125===t.charCodeAt(gt)?(a=d,gt++):(a=i,0===_t&&Ct(p)),a!==i?e=n=s:(gt=e,e=i)):(gt=e,e=i)}else gt=e,e=i;else gt=e,e=i;return e}function Nt(){var e,n,r,s;if(_t++,e=gt,n=[],K.test(t.charAt(gt))?(r=t.charAt(gt),gt++):(r=i,0===_t&&Ct(Y)),r!==i)for(;r!==i;)n.push(r),K.test(t.charAt(gt))?(r=t.charAt(gt),gt++):(r=i,0===_t&&Ct(Y));else n=i;if(n!==i&&(n=function(t){return t.join("")}(n)),(e=n)===i&&(e=Ot())===i&&(e=gt,39===t.charCodeAt(gt)?(n=Z,gt++):(n=i,0===_t&&Ct(J)),n!==i&&(r=Dt())!==i?(39===t.charCodeAt(gt)?(s=Z,gt++):(s=i,0===_t&&Ct(J)),s!==i?e=n=r:(gt=e,e=i)):(gt=e,e=i),e===i))if(e=gt,123===t.charCodeAt(gt)?(n=u,gt++):(n=i,0===_t&&Ct(h)),n!==i){for(r=[],s=Nt();s!==i;)r.push(s),s=Nt();r!==i?(125===t.charCodeAt(gt)?(s=d,gt++):(s=i,0===_t&&Ct(p)),s!==i?e=n=function(t){return"{"+t.join("")+"}"}(r):(gt=e,e=i)):(gt=e,e=i)}else gt=e,e=i;return _t--,e===i&&(n=i,0===_t&&Ct(X)),e}function Ot(){var e,n;return _t++,"''"===t.substr(gt,2)?(n="''",gt+=2):(n=i,0===_t&&Ct(tt)),n!==i&&(n="'"),_t--,(e=n)===i&&(n=i,0===_t&&Ct(Q)),e}function Dt(){var e,n,r;if((e=Ot())===i){if(e=gt,n=[],et.test(t.charAt(gt))?(r=t.charAt(gt),gt++):(r=i,0===_t&&Ct(nt)),r!==i)for(;r!==i;)n.push(r),et.test(t.charAt(gt))?(r=t.charAt(gt),gt++):(r=i,0===_t&&Ct(nt));else n=i;n!==i&&(n=c(n)),e=n}return e}function Lt(){var e,n;return(e=Ot())===i&&(e=function(){var e,n,r,s,o,a;if(_t++,(e=function(){var e,n,r,s;if(e=gt,"'{"===t.substr(gt,2)?(n="'{",gt+=2):(n=i,0===_t&&Ct(rt)),n!==i){for(r=[],s=Dt();s!==i;)r.push(s),s=Dt();r!==i?(39===t.charCodeAt(gt)?(s=Z,gt++):(s=i,0===_t&&Ct(J)),s!==i?e=n=function(t){return"{"+t.join("")}(r):(gt=e,e=i)):(gt=e,e=i)}else gt=e,e=i;if(e===i)if(e=gt,"'}"===t.substr(gt,2)?(n="'}",gt+=2):(n=i,0===_t&&Ct(it)),n!==i){for(r=[],s=Dt();s!==i;)r.push(s),s=Dt();r!==i?(39===t.charCodeAt(gt)?(s=Z,gt++):(s=i,0===_t&&Ct(J)),s!==i?e=n=function(t){return"}"+t.join("")}(r):(gt=e,e=i)):(gt=e,e=i)}else gt=e,e=i;return e}())===i){if(e=gt,n=gt,r=gt,"'#"===t.substr(gt,2)?(s="'#",gt+=2):(s=i,0===_t&&Ct(ot)),s!==i){for(o=[],a=Dt();a!==i;)o.push(a),a=Dt();o!==i?(39===t.charCodeAt(gt)?(a=Z,gt++):(a=i,0===_t&&Ct(J)),a!==i?r=s=function(t){return"#"+t.join("")}(o):(gt=r,r=i)):(gt=r,r=i)}else gt=r,r=i;r!==i&&(s=(s=l())?void 0:i)!==i?n=r=[r,s]:(gt=n,n=i),n!==i&&(n=function(t){return t[0]}(n)),(e=n)===i&&(39===t.charCodeAt(gt)?(e=Z,gt++):(e=i,0===_t&&Ct(J)))}return _t--,e===i&&(n=i,0===_t&&Ct(st)),e}())===i&&(e=gt,35===t.charCodeAt(gt)?(n="#",gt++):(n=i,0===_t&&Ct(a)),n!==i&&($t[0]?i:void 0)!==i?e=n=n:(gt=e,e=i),e===i&&(e=function(){var e;return _t++,lt.test(t.charAt(gt))?(e=t.charAt(gt),gt++):(e=i,0===_t&&Ct(ct)),_t--,e===i&&0===_t&&Ct(at),e}())),e}function Ft(){var e,n,r;if(_t++,e=gt,n=[],ht.test(t.charAt(gt))?(r=t.charAt(gt),gt++):(r=i,0===_t&&Ct(dt)),r!==i)for(;r!==i;)n.push(r),ht.test(t.charAt(gt))?(r=t.charAt(gt),gt++):(r=i,0===_t&&Ct(dt));else n=i;return e=n!==i?t.substring(e,gt):n,_t--,e===i&&(n=i,0===_t&&Ct(ut)),e}function Pt(){var e,n,r;for(_t++,e=gt,n=[],ft.test(t.charAt(gt))?(r=t.charAt(gt),gt++):(r=i,0===_t&&Ct(mt));r!==i;)n.push(r),ft.test(t.charAt(gt))?(r=t.charAt(gt),gt++):(r=i,0===_t&&Ct(mt));return e=n!==i?t.substring(e,gt):n,_t--,e===i&&(n=i,0===_t&&Ct(pt)),e}var $t=[!1];if((n=o())!==i&&gt===t.length)return n;throw n!==i&&gt<t.length&&Ct({type:"end"}),function(t,e,n){return new r(r.buildMessage(t,e),t,e,n)}(bt,vt<t.length?t.charAt(vt):null,function(t,e){var n=Et(t),r=Et(e);return{start:{offset:t,line:n.line,column:n.column},end:{offset:e,line:r.line,column:r.column}}}(vt,vt<t.length?vt+1:vt))}}},function(t,e,n){var r,i,s=[{cardinal:["other"],ordinal:["other"]},{cardinal:["one","other"],ordinal:["other"]},{cardinal:["one","other"],ordinal:["one","other"]},{cardinal:["one","two","other"],ordinal:["other"]}];void 0===(i="function"==typeof(r={af:s[1],ak:s[1],am:s[1],ar:{cardinal:["zero","one","two","few","many","other"],ordinal:["other"]},ars:{cardinal:["zero","one","two","few","many","other"],ordinal:["other"]},as:{cardinal:["one","other"],ordinal:["one","two","few","many","other"]},asa:s[1],ast:s[1],az:{cardinal:["one","other"],ordinal:["one","few","many","other"]},be:{cardinal:["one","few","many","other"],ordinal:["few","other"]},bem:s[1],bez:s[1],bg:s[1],bh:s[1],bm:s[0],bn:{cardinal:["one","other"],ordinal:["one","two","few","many","other"]},bo:s[0],br:{cardinal:["one","two","few","many","other"],ordinal:["other"]},brx:s[1],bs:{cardinal:["one","few","other"],ordinal:["other"]},ca:{cardinal:["one","other"],ordinal:["one","two","few","other"]},ce:s[1],cgg:s[1],chr:s[1],ckb:s[1],cs:{cardinal:["one","few","many","other"],ordinal:["other"]},cy:{cardinal:["zero","one","two","few","many","other"],ordinal:["zero","one","two","few","many","other"]},da:s[1],de:s[1],dsb:{cardinal:["one","two","few","other"],ordinal:["other"]},dv:s[1],dz:s[0],ee:s[1],el:s[1],en:{cardinal:["one","other"],ordinal:["one","two","few","other"]},eo:s[1],es:s[1],et:s[1],eu:s[1],fa:s[1],ff:s[1],fi:s[1],fil:s[2],fo:s[1],fr:s[2],fur:s[1],fy:s[1],ga:{cardinal:["one","two","few","many","other"],ordinal:["one","other"]},gd:{cardinal:["one","two","few","other"],ordinal:["one","two","few","other"]},gl:s[1],gsw:s[1],gu:{cardinal:["one","other"],ordinal:["one","two","few","many","other"]},guw:s[1],gv:{cardinal:["one","two","few","many","other"],ordinal:["other"]},ha:s[1],haw:s[1],he:{cardinal:["one","two","many","other"],ordinal:["other"]},hi:{cardinal:["one","other"],ordinal:["one","two","few","many","other"]},hr:{cardinal:["one","few","other"],ordinal:["other"]},hsb:{cardinal:["one","two","few","other"],ordinal:["other"]},hu:s[2],hy:s[2],ia:s[1],id:s[0],ig:s[0],ii:s[0],in:s[0],io:s[1],is:s[1],it:{cardinal:["one","other"],ordinal:["many","other"]},iu:s[3],iw:{cardinal:["one","two","many","other"],ordinal:["other"]},ja:s[0],jbo:s[0],jgo:s[1],ji:s[1],jmc:s[1],jv:s[0],jw:s[0],ka:{cardinal:["one","other"],ordinal:["one","many","other"]},kab:s[1],kaj:s[1],kcg:s[1],kde:s[0],kea:s[0],kk:{cardinal:["one","other"],ordinal:["many","other"]},kkj:s[1],kl:s[1],km:s[0],kn:s[1],ko:s[0],ks:s[1],ksb:s[1],ksh:{cardinal:["zero","one","other"],ordinal:["other"]},ku:s[1],kw:s[3],ky:s[1],lag:{cardinal:["zero","one","other"],ordinal:["other"]},lb:s[1],lg:s[1],lkt:s[0],ln:s[1],lo:{cardinal:["other"],ordinal:["one","other"]},lt:{cardinal:["one","few","many","other"],ordinal:["other"]},lv:{cardinal:["zero","one","other"],ordinal:["other"]},mas:s[1],mg:s[1],mgo:s[1],mk:{cardinal:["one","other"],ordinal:["one","two","many","other"]},ml:s[1],mn:s[1],mo:{cardinal:["one","few","other"],ordinal:["one","other"]},mr:{cardinal:["one","other"],ordinal:["one","two","few","other"]},ms:{cardinal:["other"],ordinal:["one","other"]},mt:{cardinal:["one","few","many","other"],ordinal:["other"]},my:s[0],nah:s[1],naq:s[3],nb:s[1],nd:s[1],ne:s[2],nl:s[1],nn:s[1],nnh:s[1],no:s[1],nqo:s[0],nr:s[1],nso:s[1],ny:s[1],nyn:s[1],om:s[1],or:{cardinal:["one","other"],ordinal:["one","two","few","many","other"]},os:s[1],pa:s[1],pap:s[1],pl:{cardinal:["one","few","many","other"],ordinal:["other"]},prg:{cardinal:["zero","one","other"],ordinal:["other"]},ps:s[1],pt:s[1],"pt-PT":s[1],rm:s[1],ro:{cardinal:["one","few","other"],ordinal:["one","other"]},rof:s[1],root:s[0],ru:{cardinal:["one","few","many","other"],ordinal:["other"]},rwk:s[1],sah:s[0],saq:s[1],sc:{cardinal:["one","other"],ordinal:["many","other"]},scn:{cardinal:["one","other"],ordinal:["many","other"]},sd:s[1],sdh:s[1],se:s[3],seh:s[1],ses:s[0],sg:s[0],sh:{cardinal:["one","few","other"],ordinal:["other"]},shi:{cardinal:["one","few","other"],ordinal:["other"]},si:s[1],sk:{cardinal:["one","few","many","other"],ordinal:["other"]},sl:{cardinal:["one","two","few","other"],ordinal:["other"]},sma:s[3],smi:s[3],smj:s[3],smn:s[3],sms:s[3],sn:s[1],so:s[1],sq:{cardinal:["one","other"],ordinal:["one","many","other"]},sr:{cardinal:["one","few","other"],ordinal:["other"]},ss:s[1],ssy:s[1],st:s[1],sv:s[2],sw:s[1],syr:s[1],ta:s[1],te:s[1],teo:s[1],th:s[0],ti:s[1],tig:s[1],tk:{cardinal:["one","other"],ordinal:["few","other"]},tl:s[2],tn:s[1],to:s[0],tr:s[1],ts:s[1],tzm:s[1],ug:s[1],uk:{cardinal:["one","few","many","other"],ordinal:["few","other"]},ur:s[1],uz:s[1],ve:s[1],vi:{cardinal:["other"],ordinal:["one","other"]},vo:s[1],vun:s[1],wa:s[1],wae:s[1],wo:s[0],xh:s[1],xog:s[1],yi:s[1],yo:s[0],yue:s[0],zh:s[0],zu:s[1]})?r.call(e,n,e,t):r)||(t.exports=i)},function(t,e){function n(t,e,n){var r={day:"numeric",month:"short",year:"numeric"};switch(n){case"full":r.weekday="long";case"long":r.month="long";break;case"short":r.month="numeric"}return new Date(t).toLocaleDateString(e,r)}t.exports=function(){return n}},function(t,e){function n(t){if(!isFinite(t))return String(t);var e="";t<0?(e="-",t=Math.abs(t)):t=Number(t);var n=t%60,r=[Math.round(n)===n?n:n.toFixed(3)];return t<60?r.unshift(0):(t=Math.round((t-r[0])/60),r.unshift(t%60),t>=60&&(t=Math.round((t-r[0])/60),r.unshift(t))),e+r.shift()+":"+r.map(function(t){return t<10?"0"+String(t):String(t)}).join(":")}t.exports=function(){return n}},function(t,e){t.exports=function(t){var e=(function(t,e,n){var r=n&&n.split(":")||[],i={integer:{maximumFractionDigits:0},percent:{style:"percent"},currency:{style:"currency",currency:r[1]&&r[1].trim()||CURRENCY,minimumFractionDigits:2,maximumFractionDigits:2}};return new Intl.NumberFormat(e,i[r[0]]||{}).format(t)}).toString().replace("CURRENCY",JSON.stringify(t.currency||"USD")).match(/\(([^)]*)\)[^{]*{([\s\S]*)}/);return new Function(e[1],e[2])}},function(t,e){function n(t,e,n){var r={second:"numeric",minute:"numeric",hour:"numeric"};switch(n){case"full":case"long":r.timeZoneName="short";break;case"short":delete r.second}return new Date(t).toLocaleTimeString(e,r)}t.exports=function(){return n}},function(t,e,n){"use strict";n.r(e);var r=n(1),i=n.n(r),s=n(2),o={break:!0,continue:!0,delete:!0,else:!0,for:!0,function:!0,if:!0,in:!0,new:!0,return:!0,this:!0,typeof:!0,var:!0,void:!0,while:!0,with:!0,case:!0,catch:!0,default:!0,do:!0,finally:!0,instanceof:!0,switch:!0,throw:!0,try:!0},a={debugger:!0,class:!0,enum:!0,extends:!0,super:!0,const:!0,export:!0,import:!0,null:!0,true:!0,false:!0,implements:!0,let:!0,private:!0,public:!0,yield:!0,interface:!0,package:!0,protected:!0,static:!0};function l(t,e){if(/^[A-Z_$][0-9A-Z_$]*$/i.test(t)&&!o[t])return e?"".concat(e,".").concat(t):t;var n=JSON.stringify(t);return e?e+"[".concat(n,"]"):n}function c(t){var e=t.trim().replace(/\W+/g,"_");return o[e]||a[e]||/^\d/.test(e)?"_"+e:e}var u=new RegExp("^"+["ar","ckb","fa","he","ks($|[^bfh])","lrc","mzn","pa-Arab","ps","ug","ur","uz-Arab","yi"].join("|^"));function h(t){return(h="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}var d=function(){function t(e){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.mf=e,this.lc=null,this.locales={},this.runtime={},this.formatters={}}var e;return(e=[{key:"compile",value:function(t,e,n){var r=this;if("object"!=h(t)){this.lc=e;var i=n[e]||{cardinal:[],ordinal:[]};i.strict=!!this.mf.options.strictNumberSign;var o=Object(s.parse)(t,i).map(function(t){return r.token(t)});return"function(d) { return ".concat(o.join(" + ")||'""',"; }")}var a={};for(var l in t){var c=n.hasOwnProperty(l)?l:e;a[l]=this.compile(t[l],c,n)}return a}},{key:"cases",value:function(t,e){var n=this,r="select"===t.type||!this.mf.hasCustomPluralFuncs,i=t.cases.map(function(t){var i=t.key;"other"===i&&(r=!1);var s=t.tokens.map(function(t){return n.token(t,e)});return l(i)+": "+(s.join(" + ")||'""')});if(r)throw new Error("No 'other' form found in "+JSON.stringify(t));return"{ ".concat(i.join(", ")," }")}},{key:"token",value:function(t,e){var n,r=this;if("string"==typeof t)return JSON.stringify(t);var i,s,o,a=[l(t.arg,"d")];switch(t.type){case"argument":return this.mf.options.biDiSupport?(i=a[0],s=u.test(this.lc),o=JSON.stringify(s?"\u200f":"\u200e"),"".concat(o," + ").concat(i," + ").concat(o)):a[0];case"select":n="select",e&&this.mf.options.strictNumberSign&&(e=null),a.push(this.cases(t,e)),this.runtime.select=!0;break;case"selectordinal":n="plural",a.push(0,c(this.lc),this.cases(t,t),1),this.locales[this.lc]=!0,this.runtime.plural=!0;break;case"plural":n="plural",a.push(t.offset||0,c(this.lc),this.cases(t,t)),this.locales[this.lc]=!0,this.runtime.plural=!0;break;case"function":if(!(t.key in this.mf.fmt)&&t.key in this.mf.constructor.formatters&&(this.mf.fmt[t.key]=(0,this.mf.constructor.formatters[t.key])(this.mf)),!this.mf.fmt[t.key])throw new Error("Formatting function ".concat(JSON.stringify(t.key)," not found!"));if(a.push(JSON.stringify(this.lc)),t.param){e&&this.mf.options.strictNumberSign&&(e=null);var h=t.param.tokens.map(function(t){return r.token(t,e)});a.push("("+(h.join(" + ")||'""')+").trim()")}n=l(t.key,"fmt"),this.formatters[t.key]=!0;break;case"octothorpe":if(!e)return'"#"';n="number",a=[l(e.arg,"d"),JSON.stringify(e.arg)],e.offset&&a.push(e.offset),this.runtime.number=!0}if(!n)throw new Error("Parser error for token "+JSON.stringify(t));return"".concat(n,"(").concat(a.join(", "),")")}}])&&function(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}(t.prototype,e),t}(),p=n(3),f=n.n(p),m=n(0),g=n.n(m);function y(t,e,n){var r=function(){return e.apply(this,arguments)};if(r.toString=function(){return e.toString()},n){var i=f.a[t]||{};r.cardinal=i.cardinal,r.ordinal=i.ordinal}else r.cardinal=[],r.ordinal=[];return r}function v(t,e){for(var n=e.pluralKeyChecks,r=String(t);r;r=r.replace(/[-_]?[^-_]*$/,"")){var i=g.a[r];if(i)return y(r,i,n)}throw new Error("Localisation function not found for locale "+JSON.stringify(t))}function b(t){return(b="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}var _=function(){function t(e){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.plural=function(t,e,n,r,i){if({}.hasOwnProperty.call(r,t))return r[t];e&&(t-=e);var s=n(t,i);return s in r?r[s]:r.other},this.select=function(t,e){return{}.hasOwnProperty.call(e,t)?e[t]:e.other},this.mf=e,this.setStrictNumber(e.options.strictNumberSign)}var e;return(e=[{key:"setStrictNumber",value:function(e){this.number=e?t.strictNumber:t.defaultNumber}},{key:"toString",value:function(t,e){for(var n={},r=Object.keys(e.locales),i=0;i<r.length;++i){var s=r[i];n[c(s)]=t[s]}for(var o=Object.keys(e.runtime),a=0;a<o.length;++a){var u=o[a];n[u]=this[u]}var h=Object.keys(e.formatters);if(h.length>0){n.fmt={};for(var d=0;d<h.length;++d){var p=h[d];n.fmt[p]=this.mf.fmt[p]}}return function t(e,n){if("object"!=b(e)){var r=e.toString().replace(/^(function )\w*/,"$1"),i=/([ \t]*)\S.*$/.exec(r);return i?r.replace(new RegExp("^"+i[1],"mg"),""):r}var s=[];for(var o in e){var a=t(e[o],n+1);s.push(0===n?"var ".concat(o," = ").concat(a,";\n"):"".concat(l(o),": ").concat(a))}if(0===n)return s.join("");if(0===s.length)return"{}";for(var c="  ";--n;)c+="  ";var u=s.join(",\n").replace(/^/gm,c);return"{\n".concat(u,"\n}")}(n,0)}}])&&function(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}(t.prototype,e),t}();function x(t){return(x="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function w(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function S(t,e,n){return e&&w(t.prototype,e),n&&w(t,n),t}_.defaultNumber=function(t,e,n){if(!n)return t;if(isNaN(t))throw new Error("Can't apply offset:"+n+" to argument `"+e+"` with non-numerical value "+JSON.stringify(t)+".");return t-n},_.strictNumber=function(t,e,n){if(isNaN(t))throw new Error("Argument `"+e+"` has non-numerical value "+JSON.stringify(t)+".");return t-(n||0)},n.d(e,"default",function(){return E});var E=function(){function t(e,n){var r=this;if(function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.options=Object.assign({biDiSupport:!1,customFormatters:null,pluralKeyChecks:!0,strictNumberSign:!1},n),this.pluralFuncs={},"string"==typeof e)this.pluralFuncs[e]=v(e,this.options),this.defaultLocale=e;else if(Array.isArray(e))e.forEach(function(t){r.pluralFuncs[t]=v(t,r.options)}),this.defaultLocale=e[0];else{if(e)for(var i=Object.keys(e),s=0;s<i.length;++s){var o=i[s];if("function"!=typeof e[o]){var a="Expected function value for locale "+String(o);throw new Error(a)}this.pluralFuncs[o]=e[o],this.defaultLocale||(this.defaultLocale=o)}this.defaultLocale?this.hasCustomPluralFuncs=!0:(this.defaultLocale=t.defaultLocale,this.hasCustomPluralFuncs=!1)}this.fmt=Object.assign({},this.options.customFormatters),this.runtime=new _(this)}return S(t,null,[{key:"escape",value:function(t,e){var n=e?/[#{}]/g:/[{}]/g;return String(t).replace(n,"'$&'")}}]),S(t,[{key:"addFormatters",value:function(t){for(var e=Object.keys(t),n=0;n<e.length;++n){var r=e[n];this.fmt[r]=t[r]}return this}},{key:"disablePluralKeyChecks",value:function(){for(var t in this.options.pluralKeyChecks=!1,this.pluralFuncs){var e=this.pluralFuncs[t];e&&(e.cardinal=[],e.ordinal=[])}return this}},{key:"setBiDiSupport",value:function(t){return this.options.biDiSupport=!!t||void 0===t,this}},{key:"setStrictNumberSign",value:function(t){return this.options.strictNumberSign=!!t||void 0===t,this.runtime.setStrictNumber(this.options.strictNumberSign),this}},{key:"compile",value:function(t,e){var n={};if(0===Object.keys(this.pluralFuncs).length)if(e){var r=v(e,this.options);if(!r){var i=JSON.stringify(e);throw new Error("Locale ".concat(i," not found!"))}n[e]=r}else e=this.defaultLocale,n=function(t){for(var e=t.pluralKeyChecks,n={},r=Object.keys(g.a),i=0;i<r.length;++i){var s=r[i];n[s]=y(s,g.a[s],e)}return n}(this.options);else if(e){var s=this.pluralFuncs[e];if(!s){var o=JSON.stringify(e),a=JSON.stringify(this.pluralFuncs);throw new Error("Locale ".concat(o," not found in ").concat(a,"!"))}n[e]=s}else e=this.defaultLocale,n=this.pluralFuncs;var u=new d(this),h=u.compile(t,e,n);if("object"!=x(t)){var p=new Function("number, plural, select, fmt",c(e),"return "+h),f=this.runtime;return p(f.number,f.plural,f.select,this.fmt,n[e])}var m=this.runtime.toString(n,u)+"\n",b=function t(e,n){if(n||(n=0),"object"!=x(e))return e;for(var r="",i=0;i<n;++i)r+="  ";var s=[];for(var o in e){var a=t(e[o],n+1);s.push("\n".concat(r,"  ").concat(l(o),": ").concat(a))}return"{".concat(s.join(","),"\n").concat(r,"}")}(h),_=new Function(m+"return "+b)();if(_.hasOwnProperty("toString"))throw new Error("The top-level message key `toString` is reserved");return _.toString=function(t){return t&&"export default"!==t?t.indexOf(".")>-1?m+t+" = "+b:m+["(function (root, G) {",'  if (typeof define === "function" && define.amd) { define(G); }','  else if (typeof exports === "object") { module.exports = G; }',"  else { "+l(t,"root")+" = G; }","})(this, "+b+");"].join("\n"):m+"export default "+b},_}}]),t}();E.defaultLocale="en",E.formatters=i.a}]).default},uDiL:function(t,e,n){(function(t){var r;!function(t,i,s){function o(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),e.next()}function a(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function l(t,e){var n=new o(t),r=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&a(r,n),i.state=function(){return a(n,{})}),i}i&&i.exports?i.exports=l:n("B9Yq")&&n("PDX0")?void 0===(r=(function(){return l}).call(e,n,e,i))||(i.exports=r):this.xor128=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},yuCN:function(t,e,n){(function(t){var r;!function(t,i,s){function o(t){var e=this;e.next=function(){var t,n,r=e.x,i=e.i;return t=r[i],n=(t^=t>>>7)^t<<24,n^=(t=r[i+1&7])^t>>>10,n^=(t=r[i+3&7])^t>>>3,n^=(t=r[i+4&7])^t<<7,t=r[i+7&7],r[i]=n^=(t^=t<<13)^t<<9,e.i=i+1&7,n},function(t,e){var n,r=[];if(e===(0|e))r[0]=e;else for(e=""+e,n=0;n<e.length;++n)r[7&n]=r[7&n]<<15^e.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n&&(r[7]=-1),t.x=r,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function a(t,e){return e.x=t.x.slice(),e.i=t.i,e}function l(t,e){null==t&&(t=+new Date);var n=new o(t),r=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,r&&(r.x&&a(r,n),i.state=function(){return a(n,{})}),i}i&&i.exports?i.exports=l:n("B9Yq")&&n("PDX0")?void 0===(r=(function(){return l}).call(e,n,e,i))||(i.exports=r):this.xorshift7=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},zUnb:function(t,e,n){"use strict";n.r(e);var r={};n.r(r),n.d(r,"shuffle",function(){return FF}),n.d(r,"clamp",function(){return PF}),n.d(r,"nearestLargerEven",function(){return $F}),n.d(r,"sum",function(){return BF}),n.d(r,"randUniform",function(){return zF}),n.d(r,"distSquared",function(){return VF}),n.d(r,"assert",function(){return UF}),n.d(r,"assertShapesMatch",function(){return HF}),n.d(r,"assertNonNull",function(){return WF}),n.d(r,"flatten",function(){return jF}),n.d(r,"sizeFromShape",function(){return GF}),n.d(r,"isScalarShape",function(){return qF}),n.d(r,"arraysEqual",function(){return XF}),n.d(r,"isInt",function(){return KF}),n.d(r,"tanh",function(){return YF}),n.d(r,"sizeToSquarishShape",function(){return ZF}),n.d(r,"createShuffledIndices",function(){return JF}),n.d(r,"rightPad",function(){return QF}),n.d(r,"repeatedTry",function(){return tP}),n.d(r,"inferFromImplicitShape",function(){return eP}),n.d(r,"parseAxisParam",function(){return nP}),n.d(r,"squeezeShape",function(){return rP}),n.d(r,"getTypedArrayFromDType",function(){return iP}),n.d(r,"getArrayFromDType",function(){return sP}),n.d(r,"checkConversionForErrors",function(){return oP}),n.d(r,"isValidDtype",function(){return aP}),n.d(r,"hasEncodingLoss",function(){return lP}),n.d(r,"isTypedArray",function(){return cP}),n.d(r,"bytesPerElement",function(){return uP}),n.d(r,"bytesFromStringArray",function(){return hP}),n.d(r,"isString",function(){return dP}),n.d(r,"isBoolean",function(){return pP}),n.d(r,"isNumber",function(){return fP}),n.d(r,"inferDtype",function(){return mP}),n.d(r,"isFunction",function(){return gP}),n.d(r,"nearestDivisor",function(){return yP}),n.d(r,"computeStrides",function(){return vP}),n.d(r,"toTypedArray",function(){return bP}),n.d(r,"toNestedArray",function(){return xP}),n.d(r,"makeOnesTypedArray",function(){return wP}),n.d(r,"makeZerosTypedArray",function(){return SP}),n.d(r,"makeZerosNestedTypedArray",function(){return EP}),n.d(r,"now",function(){return CP}),n.d(r,"assertNonNegativeIntegerDimensions",function(){return TP}),n.d(r,"fetch",function(){return AP}),n.d(r,"encodeString",function(){return MP}),n.d(r,"decodeString",function(){return kP}),n.d(r,"locToIndex",function(){return RP}),n.d(r,"indexToLoc",function(){return IP});var i={};n.r(i),n.d(i,"makeTypesMatch",function(){return QP}),n.d(i,"assertTypesMatch",function(){return t$}),n.d(i,"isTensorInList",function(){return e$}),n.d(i,"getTensorsInContainer",function(){return n$});var s={};n.r(s),n.d(s,"isMobile",function(){return l$}),n.d(s,"isBrowser",function(){return c$});var o={};n.r(o),n.d(o,"assertParamsValid",function(){return bB}),n.d(o,"maskToAxes",function(){return _B}),n.d(o,"computeOutShape",function(){return xB}),n.d(o,"stridesWithElidedDims",function(){return wB}),n.d(o,"startIndicesWithElidedDims",function(){return CB}),n.d(o,"stopIndicesWithElidedDims",function(){return TB}),n.d(o,"stridesForAxis",function(){return AB}),n.d(o,"startForAxis",function(){return MB}),n.d(o,"stopForAxis",function(){return kB}),n.d(o,"isSliceContinous",function(){return RB}),n.d(o,"computeFlatOffset",function(){return IB}),n.d(o,"parseSliceParams",function(){return NB});var a={};n.r(a),n.d(a,"segOpComputeOptimalWindowSize",function(){return Dz}),n.d(a,"computeOutShape",function(){return Lz}),n.d(a,"collectGatherOpShapeInfo",function(){return Fz});var l={};n.r(l),n.d(l,"conv2d",function(){return wH}),n.d(l,"depthwiseConv2d",function(){return CH}),n.d(l,"matMul",function(){return TH});var c={};n.r(c),n.d(c,"abs",function(){return v$}),n.d(c,"acos",function(){return b$}),n.d(c,"acosh",function(){return _$}),n.d(c,"add",function(){return x$}),n.d(c,"addN",function(){return w$}),n.d(c,"all",function(){return O$}),n.d(c,"any",function(){return D$}),n.d(c,"argMax",function(){return L$}),n.d(c,"argMin",function(){return F$}),n.d(c,"asin",function(){return P$}),n.d(c,"asinh",function(){return $$}),n.d(c,"atan",function(){return B$}),n.d(c,"atan2",function(){return z$}),n.d(c,"atanh",function(){return V$}),n.d(c,"avgPool",function(){return nB}),n.d(c,"avgPool3d",function(){return uB}),n.d(c,"basicLSTMCell",function(){return LB}),n.d(c,"batchToSpaceND",function(){return FB}),n.d(c,"batchNorm",function(){return $B}),n.d(c,"batchNorm2d",function(){return BB}),n.d(c,"batchNorm3d",function(){return zB}),n.d(c,"batchNorm4d",function(){return VB}),n.d(c,"broadcastTo",function(){return HB}),n.d(c,"buffer",function(){return WB}),n.d(c,"cast",function(){return U$}),n.d(c,"ceil",function(){return jB}),n.d(c,"clipByValue",function(){return GB}),n.d(c,"clone",function(){return UB}),n.d(c,"complex",function(){return qB}),n.d(c,"concat",function(){return mB}),n.d(c,"concat1d",function(){return XB}),n.d(c,"concat2d",function(){return KB}),n.d(c,"concat3d",function(){return YB}),n.d(c,"concat4d",function(){return ZB}),n.d(c,"conv1d",function(){return QB}),n.d(c,"conv2d",function(){return JB}),n.d(c,"conv2dTranspose",function(){return ez}),n.d(c,"conv3d",function(){return nz}),n.d(c,"conv3dTranspose",function(){return iz}),n.d(c,"cos",function(){return sz}),n.d(c,"cosh",function(){return oz}),n.d(c,"cumsum",function(){return az}),n.d(c,"depthToSpace",function(){return lz}),n.d(c,"depthwiseConv2d",function(){return cz}),n.d(c,"diag",function(){return uz}),n.d(c,"dilation2d",function(){return hz}),n.d(c,"div",function(){return pz}),n.d(c,"divNoNan",function(){return _z}),n.d(c,"dot",function(){return xz}),n.d(c,"elu",function(){return wz}),n.d(c,"equal",function(){return yz}),n.d(c,"erf",function(){return Sz}),n.d(c,"exp",function(){return Ez}),n.d(c,"expandDims",function(){return Cz}),n.d(c,"expm1",function(){return Tz}),n.d(c,"eye",function(){return Mz}),n.d(c,"fft",function(){return kz}),n.d(c,"fill",function(){return Rz}),n.d(c,"floor",function(){return Iz}),n.d(c,"floorDiv",function(){return dz}),n.d(c,"gather",function(){return Pz}),n.d(c,"greater",function(){return $z}),n.d(c,"greaterEqual",function(){return Bz}),n.d(c,"ifft",function(){return zz}),n.d(c,"imag",function(){return Vz}),n.d(c,"irfft",function(){return jz}),n.d(c,"isFinite",function(){return Gz}),n.d(c,"isInf",function(){return qz}),n.d(c,"isNaN",function(){return Xz}),n.d(c,"leakyRelu",function(){return Yz}),n.d(c,"less",function(){return Zz}),n.d(c,"lessEqual",function(){return Jz}),n.d(c,"linspace",function(){return Qz}),n.d(c,"localResponseNormalization",function(){return tV}),n.d(c,"log",function(){return eV}),n.d(c,"log1p",function(){return nV}),n.d(c,"logSigmoid",function(){return oV}),n.d(c,"logSoftmax",function(){return uV}),n.d(c,"logSumExp",function(){return hV}),n.d(c,"logicalAnd",function(){return dV}),n.d(c,"logicalNot",function(){return pV}),n.d(c,"logicalOr",function(){return fV}),n.d(c,"logicalXor",function(){return mV}),n.d(c,"matMul",function(){return gB}),n.d(c,"max",function(){return aV}),n.d(c,"maxPool",function(){return gV}),n.d(c,"maxPool3d",function(){return yV}),n.d(c,"maxPoolWithArgmax",function(){return vV}),n.d(c,"maximum",function(){return Kz}),n.d(c,"mean",function(){return xV}),n.d(c,"min",function(){return wV}),n.d(c,"minimum",function(){return SV}),n.d(c,"mod",function(){return EV}),n.d(c,"moments",function(){return TV}),n.d(c,"mul",function(){return yB}),n.d(c,"multiRNNCell",function(){return AV}),n.d(c,"multinomial",function(){return MV}),n.d(c,"neg",function(){return iV}),n.d(c,"notEqual",function(){return kV}),n.d(c,"oneHot",function(){return RV}),n.d(c,"ones",function(){return _V}),n.d(c,"onesLike",function(){return IV}),n.d(c,"outerProduct",function(){return NV}),n.d(c,"pad",function(){return OV}),n.d(c,"pad1d",function(){return DV}),n.d(c,"pad2d",function(){return LV}),n.d(c,"pad3d",function(){return FV}),n.d(c,"pad4d",function(){return PV}),n.d(c,"pool",function(){return BV}),n.d(c,"pow",function(){return zV}),n.d(c,"prelu",function(){return VV}),n.d(c,"print",function(){return UV}),n.d(c,"prod",function(){return HV}),n.d(c,"rand",function(){return WV}),n.d(c,"randomGamma",function(){return KV}),n.d(c,"randomNormal",function(){return YV}),n.d(c,"randomUniform",function(){return ZV}),n.d(c,"range",function(){return QV}),n.d(c,"real",function(){return Uz}),n.d(c,"reciprocal",function(){return tU}),n.d(c,"relu",function(){return eU}),n.d(c,"relu6",function(){return nU}),n.d(c,"reshape",function(){return I$}),n.d(c,"reverse",function(){return Hz}),n.d(c,"reverse1d",function(){return rU}),n.d(c,"reverse2d",function(){return iU}),n.d(c,"reverse3d",function(){return sU}),n.d(c,"reverse4d",function(){return oU}),n.d(c,"rfft",function(){return cU}),n.d(c,"round",function(){return uU}),n.d(c,"rsqrt",function(){return hU}),n.d(c,"scalar",function(){return Wz}),n.d(c,"selu",function(){return dU}),n.d(c,"separableConv2d",function(){return pU}),n.d(c,"setdiff1dAsync",function(){return fU}),n.d(c,"sigmoid",function(){return vB}),n.d(c,"sign",function(){return mU}),n.d(c,"sin",function(){return gU}),n.d(c,"sinh",function(){return yU}),n.d(c,"slice",function(){return OB}),n.d(c,"slice1d",function(){return vU}),n.d(c,"slice2d",function(){return bU}),n.d(c,"slice3d",function(){return _U}),n.d(c,"slice4d",function(){return xU}),n.d(c,"softmax",function(){return wU}),n.d(c,"softplus",function(){return sV}),n.d(c,"spaceToBatchND",function(){return $V}),n.d(c,"split",function(){return lU}),n.d(c,"sqrt",function(){return SU}),n.d(c,"square",function(){return CV}),n.d(c,"squaredDifference",function(){return EU}),n.d(c,"squeeze",function(){return CU}),n.d(c,"stack",function(){return TU}),n.d(c,"step",function(){return AU}),n.d(c,"stridedSlice",function(){return MU}),n.d(c,"sub",function(){return lV}),n.d(c,"sum",function(){return cV}),n.d(c,"tan",function(){return kU}),n.d(c,"tanh",function(){return DB}),n.d(c,"tensor",function(){return fB}),n.d(c,"tensor1d",function(){return JV}),n.d(c,"tensor2d",function(){return RU}),n.d(c,"tensor3d",function(){return IU}),n.d(c,"tensor4d",function(){return NU}),n.d(c,"tensor5d",function(){return OU}),n.d(c,"tensor6d",function(){return DU}),n.d(c,"tile",function(){return Az}),n.d(c,"topk",function(){return LU}),n.d(c,"truncatedNormal",function(){return FU}),n.d(c,"unsortedSegmentSum",function(){return PU}),n.d(c,"unstack",function(){return $U}),n.d(c,"variable",function(){return BU}),n.d(c,"where",function(){return vz}),n.d(c,"whereAsync",function(){return VU}),n.d(c,"zeros",function(){return bV}),n.d(c,"zerosLike",function(){return bz}),n.d(c,"booleanMaskAsync",function(){return UU}),n.d(c,"equalStrict",function(){return HU}),n.d(c,"greaterEqualStrict",function(){return WU}),n.d(c,"greaterStrict",function(){return jU}),n.d(c,"lessEqualStrict",function(){return GU}),n.d(c,"lessStrict",function(){return qU}),n.d(c,"notEqualStrict",function(){return XU}),n.d(c,"addStrict",function(){return KU}),n.d(c,"divStrict",function(){return YU}),n.d(c,"maximumStrict",function(){return ZU}),n.d(c,"minimumStrict",function(){return JU}),n.d(c,"modStrict",function(){return QU}),n.d(c,"mulStrict",function(){return tH}),n.d(c,"powStrict",function(){return eH}),n.d(c,"squaredDifferenceStrict",function(){return nH}),n.d(c,"subStrict",function(){return rH}),n.d(c,"transpose",function(){return N$}),n.d(c,"norm",function(){return sH}),n.d(c,"movingAverage",function(){return oH}),n.d(c,"scatterND",function(){return uH}),n.d(c,"sparseToDense",function(){return hH}),n.d(c,"gatherND",function(){return dH}),n.d(c,"dropout",function(){return pH}),n.d(c,"enclosingPowerOfTwo",function(){return fH}),n.d(c,"cosineWindow",function(){return mH}),n.d(c,"inTopKAsync",function(){return gH}),n.d(c,"op",function(){return y$}),n.d(c,"image",function(){return hW}),n.d(c,"linalg",function(){return dW}),n.d(c,"losses",function(){return pW}),n.d(c,"spectral",function(){return cW}),n.d(c,"fused",function(){return l}),n.d(c,"signal",function(){return uW});var u={};n.r(u),n.d(u,"copyModel",function(){return LW}),n.d(u,"listModels",function(){return OW}),n.d(u,"moveModel",function(){return FW}),n.d(u,"removeModel",function(){return DW}),n.d(u,"browserFiles",function(){return oj}),n.d(u,"browserHTTPRequest",function(){return mj}),n.d(u,"concatenateArrayBuffers",function(){return _W}),n.d(u,"decodeWeights",function(){return gW}),n.d(u,"encodeWeights",function(){return mW}),n.d(u,"fromMemory",function(){return vj}),n.d(u,"getLoadHandlers",function(){return MW}),n.d(u,"getModelArtifactsInfoForJSON",function(){return wW}),n.d(u,"getSaveHandlers",function(){return AW}),n.d(u,"http",function(){return fj}),n.d(u,"isHTTPScheme",function(){return dj}),n.d(u,"loadWeights",function(){return cj}),n.d(u,"registerLoadRouter",function(){return TW}),n.d(u,"registerSaveRouter",function(){return CW}),n.d(u,"weightsLoaderFactory",function(){return uj}),n.d(u,"withSaveHandler",function(){return bj});var h={};n.r(h),n.d(h,"toPixels",function(){return xj}),n.d(h,"fromPixels",function(){return wj});var d={};n.r(d),n.d(d,"Serializable",function(){return Sj}),n.d(d,"SerializationMap",function(){return Ej}),n.d(d,"registerClass",function(){return Cj});var p={};n.r(p),n.d(p,"axesAreInnerMostDims",function(){return S$}),n.d(p,"combineLocations",function(){return E$}),n.d(p,"computeOutAndReduceShapes",function(){return C$}),n.d(p,"expandShapeToKeepDim",function(){return T$}),n.d(p,"assertAxesAreInnerMostDims",function(){return A$}),n.d(p,"getAxesPermutation",function(){return M$}),n.d(p,"getUndoAxesPermutation",function(){return k$}),n.d(p,"getInnerMostAxes",function(){return R$}),n.d(p,"getBroadcastDims",function(){return fz}),n.d(p,"getReductionAxes",function(){return mz}),n.d(p,"assertAndGetBroadcastShape",function(){return gz}),n.d(p,"assertParamsConsistent",function(){return hB}),n.d(p,"computeOutShape",function(){return dB}),n.d(p,"computeDilation2DInfo",function(){return H$}),n.d(p,"computePool2DInfo",function(){return W$}),n.d(p,"computePool3DInfo",function(){return j$}),n.d(p,"computeConv2DInfo",function(){return G$}),n.d(p,"computeConv3DInfo",function(){return q$}),n.d(p,"computeDefaultPad",function(){return X$}),n.d(p,"tupleValuesAreOne",function(){return Q$}),n.d(p,"eitherStridesOrDilationsAreOne",function(){return tB}),n.d(p,"convertConv2DDataFormat",function(){return eB}),n.d(p,"getFusedDyActivation",function(){return vH}),n.d(p,"getFusedBiasGradient",function(){return bH}),n.d(p,"applyActivation",function(){return _H}),n.d(p,"shouldFuse",function(){return xH}),n.d(p,"PARALLELIZE_THRESHOLD",function(){return Nz}),n.d(p,"computeOptimalWindowSize",function(){return Oz}),n.d(p,"upcastType",function(){return ZP}),n.d(p,"getImageCenter",function(){return $j}),n.d(p,"getReshaped",function(){return Bj}),n.d(p,"getPermuted",function(){return zj}),n.d(p,"getReshapedPermuted",function(){return Vj}),n.d(p,"getSliceBeginCoords",function(){return Uj}),n.d(p,"getSliceSize",function(){return Hj}),n.d(p,"prepareAndValidate",function(){return Wj}),n.d(p,"validateUpdateShape",function(){return aH}),n.d(p,"validateInput",function(){return lH}),n.d(p,"calculateShapes",function(){return cH}),n.d(p,"SELU_SCALEALPHA",function(){return jj}),n.d(p,"SELU_SCALE",function(){return Gj}),n.d(p,"ERF_P",function(){return qj}),n.d(p,"ERF_A1",function(){return Xj}),n.d(p,"ERF_A2",function(){return Kj}),n.d(p,"ERF_A3",function(){return Yj}),n.d(p,"ERF_A4",function(){return Zj}),n.d(p,"ERF_A5",function(){return Jj}),n.d(p,"warn",function(){return Qj}),n.d(p,"log",function(){return tG}),n.d(p,"mergeRealAndImagArrays",function(){return eG}),n.d(p,"splitRealAndImagArrays",function(){return nG}),n.d(p,"complexWithEvenIndex",function(){return rG}),n.d(p,"complexWithOddIndex",function(){return iG}),n.d(p,"getComplexWithIndex",function(){return sG}),n.d(p,"assignToTypedArray",function(){return oG}),n.d(p,"exponents",function(){return aG}),n.d(p,"exponent",function(){return lG}),n.d(p,"prepareSplitSize",function(){return aU}),n.d(p,"segment_util",function(){return a}),n.d(p,"castTensor",function(){return cG}),n.d(p,"reshapeTensor",function(){return uG}),n.d(p,"linspaceImpl",function(){return hG});var f={};n.r(f),n.d(f,"nonMaxSuppressionV3Impl",function(){return $H}),n.d(f,"nonMaxSuppressionV4Impl",function(){return BH}),n.d(f,"nonMaxSuppressionV5Impl",function(){return zH}),n.d(f,"split",function(){return dG}),n.d(f,"tile",function(){return pG}),n.d(f,"topkImpl",function(){return fG}),n.d(f,"whereImpl",function(){return zU});var m={};n.r(m),n.d(m,"json",function(){return zJ});var g={};n.r(g),n.d(g,"json",function(){return VJ});var y={};n.r(y),n.d(y,"json",function(){return UJ});var v={};n.r(v),n.d(v,"json",function(){return HJ});var b={};n.r(b),n.d(b,"json",function(){return WJ});var _={};n.r(_),n.d(_,"json",function(){return jJ});var x={};n.r(x),n.d(x,"json",function(){return GJ});var w={};n.r(w),n.d(w,"json",function(){return qJ});var S={};n.r(S),n.d(S,"json",function(){return XJ});var E={};n.r(E),n.d(E,"json",function(){return KJ});var C={};n.r(C),n.d(C,"json",function(){return YJ});var T={};n.r(T),n.d(T,"json",function(){return ZJ});var A={};n.r(A),n.d(A,"json",function(){return JJ});var M={};n.r(M),n.d(M,"json",function(){return QJ});var k={};n.r(k),n.d(k,"json",function(){return tQ});var R={};n.r(R),n.d(R,"json",function(){return eQ});var I={};function N(t){return"function"==typeof t}n.r(I),n.d(I,"maxImpl",function(){return KQ}),n.d(I,"transposeImpl",function(){return YQ});let O=!1;const D={Promise:void 0,set useDeprecatedSynchronousErrorHandling(t){if(t){const t=new Error;console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n"+t.stack)}else O&&console.log("RxJS: Back to a better error behavior. Thank you. <3");O=t},get useDeprecatedSynchronousErrorHandling(){return O}};function L(t){setTimeout(()=>{throw t},0)}const F={closed:!0,next(t){},error(t){if(D.useDeprecatedSynchronousErrorHandling)throw t;L(t)},complete(){}},P=(()=>Array.isArray||(t=>t&&"number"==typeof t.length))();function $(t){return null!==t&&"object"==typeof t}const B=(()=>{function t(t){return Error.call(this),this.message=t?`${t.length} errors occurred during unsubscription:\n${t.map((t,e)=>`${e+1}) ${t.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=t,this}return t.prototype=Object.create(Error.prototype),t})();let z=(()=>{class t{constructor(t){this.closed=!1,this._parentOrParents=null,this._subscriptions=null,t&&(this._ctorUnsubscribe=!0,this._unsubscribe=t)}unsubscribe(){let e;if(this.closed)return;let{_parentOrParents:n,_ctorUnsubscribe:r,_unsubscribe:i,_subscriptions:s}=this;if(this.closed=!0,this._parentOrParents=null,this._subscriptions=null,n instanceof t)n.remove(this);else if(null!==n)for(let t=0;t<n.length;++t)n[t].remove(this);if(N(i)){r&&(this._unsubscribe=void 0);try{i.call(this)}catch(o){e=o instanceof B?V(o.errors):[o]}}if(P(s)){let t=-1,n=s.length;for(;++t<n;){const n=s[t];if($(n))try{n.unsubscribe()}catch(o){e=e||[],o instanceof B?e=e.concat(V(o.errors)):e.push(o)}}}if(e)throw new B(e)}add(e){let n=e;if(!e)return t.EMPTY;switch(typeof e){case"function":n=new t(e);case"object":if(n===this||n.closed||"function"!=typeof n.unsubscribe)return n;if(this.closed)return n.unsubscribe(),n;if(!(n instanceof t)){const e=n;n=new t,n._subscriptions=[e]}break;default:throw new Error("unrecognized teardown "+e+" added to Subscription.")}let{_parentOrParents:r}=n;if(null===r)n._parentOrParents=this;else if(r instanceof t){if(r===this)return n;n._parentOrParents=[r,this]}else{if(-1!==r.indexOf(this))return n;r.push(this)}const i=this._subscriptions;return null===i?this._subscriptions=[n]:i.push(n),n}remove(t){const e=this._subscriptions;if(e){const n=e.indexOf(t);-1!==n&&e.splice(n,1)}}}return t.EMPTY=function(t){return t.closed=!0,t}(new t),t})();function V(t){return t.reduce((t,e)=>t.concat(e instanceof B?e.errors:e),[])}const U=(()=>"function"==typeof Symbol?Symbol("rxSubscriber"):"@@rxSubscriber_"+Math.random())();class H extends z{constructor(t,e,n){switch(super(),this.syncErrorValue=null,this.syncErrorThrown=!1,this.syncErrorThrowable=!1,this.isStopped=!1,arguments.length){case 0:this.destination=F;break;case 1:if(!t){this.destination=F;break}if("object"==typeof t){t instanceof H?(this.syncErrorThrowable=t.syncErrorThrowable,this.destination=t,t.add(this)):(this.syncErrorThrowable=!0,this.destination=new W(this,t));break}default:this.syncErrorThrowable=!0,this.destination=new W(this,t,e,n)}}[U](){return this}static create(t,e,n){const r=new H(t,e,n);return r.syncErrorThrowable=!1,r}next(t){this.isStopped||this._next(t)}error(t){this.isStopped||(this.isStopped=!0,this._error(t))}complete(){this.isStopped||(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe())}_next(t){this.destination.next(t)}_error(t){this.destination.error(t),this.unsubscribe()}_complete(){this.destination.complete(),this.unsubscribe()}_unsubscribeAndRecycle(){const{_parentOrParents:t}=this;return this._parentOrParents=null,this.unsubscribe(),this.closed=!1,this.isStopped=!1,this._parentOrParents=t,this}}class W extends H{constructor(t,e,n,r){let i;super(),this._parentSubscriber=t;let s=this;N(e)?i=e:e&&(i=e.next,n=e.error,r=e.complete,e!==F&&(s=Object.create(e),N(s.unsubscribe)&&this.add(s.unsubscribe.bind(s)),s.unsubscribe=this.unsubscribe.bind(this))),this._context=s,this._next=i,this._error=n,this._complete=r}next(t){if(!this.isStopped&&this._next){const{_parentSubscriber:e}=this;D.useDeprecatedSynchronousErrorHandling&&e.syncErrorThrowable?this.__tryOrSetError(e,this._next,t)&&this.unsubscribe():this.__tryOrUnsub(this._next,t)}}error(t){if(!this.isStopped){const{_parentSubscriber:e}=this,{useDeprecatedSynchronousErrorHandling:n}=D;if(this._error)n&&e.syncErrorThrowable?(this.__tryOrSetError(e,this._error,t),this.unsubscribe()):(this.__tryOrUnsub(this._error,t),this.unsubscribe());else if(e.syncErrorThrowable)n?(e.syncErrorValue=t,e.syncErrorThrown=!0):L(t),this.unsubscribe();else{if(this.unsubscribe(),n)throw t;L(t)}}}complete(){if(!this.isStopped){const{_parentSubscriber:t}=this;if(this._complete){const e=()=>this._complete.call(this._context);D.useDeprecatedSynchronousErrorHandling&&t.syncErrorThrowable?(this.__tryOrSetError(t,e),this.unsubscribe()):(this.__tryOrUnsub(e),this.unsubscribe())}else this.unsubscribe()}}__tryOrUnsub(t,e){try{t.call(this._context,e)}catch(n){if(this.unsubscribe(),D.useDeprecatedSynchronousErrorHandling)throw n;L(n)}}__tryOrSetError(t,e,n){if(!D.useDeprecatedSynchronousErrorHandling)throw new Error("bad call");try{e.call(this._context,n)}catch(r){return D.useDeprecatedSynchronousErrorHandling?(t.syncErrorValue=r,t.syncErrorThrown=!0,!0):(L(r),!0)}return!1}_unsubscribe(){const{_parentSubscriber:t}=this;this._context=null,this._parentSubscriber=null,t.unsubscribe()}}const j=(()=>"function"==typeof Symbol&&Symbol.observable||"@@observable")();function G(t){return t}let q=(()=>{class t{constructor(t){this._isScalar=!1,t&&(this._subscribe=t)}lift(e){const n=new t;return n.source=this,n.operator=e,n}subscribe(t,e,n){const{operator:r}=this,i=function(t,e,n){if(t){if(t instanceof H)return t;if(t[U])return t[U]()}return t||e||n?new H(t,e,n):new H(F)}(t,e,n);if(i.add(r?r.call(i,this.source):this.source||D.useDeprecatedSynchronousErrorHandling&&!i.syncErrorThrowable?this._subscribe(i):this._trySubscribe(i)),D.useDeprecatedSynchronousErrorHandling&&i.syncErrorThrowable&&(i.syncErrorThrowable=!1,i.syncErrorThrown))throw i.syncErrorValue;return i}_trySubscribe(t){try{return this._subscribe(t)}catch(e){D.useDeprecatedSynchronousErrorHandling&&(t.syncErrorThrown=!0,t.syncErrorValue=e),function(t){for(;t;){const{closed:e,destination:n,isStopped:r}=t;if(e||r)return!1;t=n&&n instanceof H?n:null}return!0}(t)?t.error(e):console.warn(e)}}forEach(t,e){return new(e=X(e))((e,n)=>{let r;r=this.subscribe(e=>{try{t(e)}catch(i){n(i),r&&r.unsubscribe()}},n,e)})}_subscribe(t){const{source:e}=this;return e&&e.subscribe(t)}[j](){return this}pipe(...t){return 0===t.length?this:(0===(e=t).length?G:1===e.length?e[0]:function(t){return e.reduce((t,e)=>e(t),t)})(this);var e}toPromise(t){return new(t=X(t))((t,e)=>{let n;this.subscribe(t=>n=t,t=>e(t),()=>t(n))})}}return t.create=e=>new t(e),t})();function X(t){if(t||(t=D.Promise||Promise),!t)throw new Error("no Promise impl found");return t}const K=(()=>{function t(){return Error.call(this),this.message="object unsubscribed",this.name="ObjectUnsubscribedError",this}return t.prototype=Object.create(Error.prototype),t})();class Y extends z{constructor(t,e){super(),this.subject=t,this.subscriber=e,this.closed=!1}unsubscribe(){if(this.closed)return;this.closed=!0;const t=this.subject,e=t.observers;if(this.subject=null,!e||0===e.length||t.isStopped||t.closed)return;const n=e.indexOf(this.subscriber);-1!==n&&e.splice(n,1)}}class Z extends H{constructor(t){super(t),this.destination=t}}let J=(()=>{class t extends q{constructor(){super(),this.observers=[],this.closed=!1,this.isStopped=!1,this.hasError=!1,this.thrownError=null}[U](){return new Z(this)}lift(t){const e=new Q(this,this);return e.operator=t,e}next(t){if(this.closed)throw new K;if(!this.isStopped){const{observers:e}=this,n=e.length,r=e.slice();for(let i=0;i<n;i++)r[i].next(t)}}error(t){if(this.closed)throw new K;this.hasError=!0,this.thrownError=t,this.isStopped=!0;const{observers:e}=this,n=e.length,r=e.slice();for(let i=0;i<n;i++)r[i].error(t);this.observers.length=0}complete(){if(this.closed)throw new K;this.isStopped=!0;const{observers:t}=this,e=t.length,n=t.slice();for(let r=0;r<e;r++)n[r].complete();this.observers.length=0}unsubscribe(){this.isStopped=!0,this.closed=!0,this.observers=null}_trySubscribe(t){if(this.closed)throw new K;return super._trySubscribe(t)}_subscribe(t){if(this.closed)throw new K;return this.hasError?(t.error(this.thrownError),z.EMPTY):this.isStopped?(t.complete(),z.EMPTY):(this.observers.push(t),new Y(this,t))}asObservable(){const t=new q;return t.source=this,t}}return t.create=(t,e)=>new Q(t,e),t})();class Q extends J{constructor(t,e){super(),this.destination=t,this.source=e}next(t){const{destination:e}=this;e&&e.next&&e.next(t)}error(t){const{destination:e}=this;e&&e.error&&this.destination.error(t)}complete(){const{destination:t}=this;t&&t.complete&&this.destination.complete()}_subscribe(t){const{source:e}=this;return e?this.source.subscribe(t):z.EMPTY}}function tt(t){return t&&"function"==typeof t.schedule}function et(t,e){return function(n){if("function"!=typeof t)throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");return n.lift(new nt(t,e))}}class nt{constructor(t,e){this.project=t,this.thisArg=e}call(t,e){return e.subscribe(new rt(t,this.project,this.thisArg))}}class rt extends H{constructor(t,e,n){super(t),this.project=e,this.count=0,this.thisArg=n||this}_next(t){let e;try{e=this.project.call(this.thisArg,t,this.count++)}catch(n){return void this.destination.error(n)}this.destination.next(e)}}const it=t=>e=>{for(let n=0,r=t.length;n<r&&!e.closed;n++)e.next(t[n]);e.complete()};function st(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}const ot=st(),at=t=>t&&"number"==typeof t.length&&"function"!=typeof t;function lt(t){return!!t&&"function"!=typeof t.subscribe&&"function"==typeof t.then}const ct=t=>{if(t&&"function"==typeof t[j])return r=t,t=>{const e=r[j]();if("function"!=typeof e.subscribe)throw new TypeError("Provided object does not correctly implement Symbol.observable");return e.subscribe(t)};if(at(t))return it(t);if(lt(t))return n=t,t=>(n.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,L),t);if(t&&"function"==typeof t[ot])return e=t,t=>{const n=e[ot]();for(;;){let e;try{e=n.next()}catch(r){return t.error(r),t}if(e.done){t.complete();break}if(t.next(e.value),t.closed)break}return"function"==typeof n.return&&t.add(()=>{n.return&&n.return()}),t};{const e=$(t)?"an invalid object":`'${t}'`;throw new TypeError(`You provided ${e} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`)}var e,n,r};function ut(t,e){return new q(n=>{const r=new z;let i=0;return r.add(e.schedule(function(){i!==t.length?(n.next(t[i++]),n.closed||r.add(this.schedule())):n.complete()})),r})}function ht(t,e){return e?function(t,e){if(null!=t){if(function(t){return t&&"function"==typeof t[j]}(t))return function(t,e){return new q(n=>{const r=new z;return r.add(e.schedule(()=>{const i=t[j]();r.add(i.subscribe({next(t){r.add(e.schedule(()=>n.next(t)))},error(t){r.add(e.schedule(()=>n.error(t)))},complete(){r.add(e.schedule(()=>n.complete()))}}))})),r})}(t,e);if(lt(t))return function(t,e){return new q(n=>{const r=new z;return r.add(e.schedule(()=>t.then(t=>{r.add(e.schedule(()=>{n.next(t),r.add(e.schedule(()=>n.complete()))}))},t=>{r.add(e.schedule(()=>n.error(t)))}))),r})}(t,e);if(at(t))return ut(t,e);if(function(t){return t&&"function"==typeof t[ot]}(t)||"string"==typeof t)return function(t,e){if(!t)throw new Error("Iterable cannot be null");return new q(n=>{const r=new z;let i;return r.add(()=>{i&&"function"==typeof i.return&&i.return()}),r.add(e.schedule(()=>{i=t[ot](),r.add(e.schedule(function(){if(n.closed)return;let t,e;try{const n=i.next();t=n.value,e=n.done}catch(r){return void n.error(r)}e?n.complete():(n.next(t),this.schedule())}))})),r})}(t,e)}throw new TypeError((null!==t&&typeof t||t)+" is not observable")}(t,e):t instanceof q?t:new q(ct(t))}class dt extends H{constructor(t){super(),this.parent=t}_next(t){this.parent.notifyNext(t)}_error(t){this.parent.notifyError(t),this.unsubscribe()}_complete(){this.parent.notifyComplete(),this.unsubscribe()}}class pt extends H{notifyNext(t){this.destination.next(t)}notifyError(t){this.destination.error(t)}notifyComplete(){this.destination.complete()}}function ft(t,e){if(!e.closed)return t instanceof q?t.subscribe(e):ct(t)(e)}function mt(t,e,n=Number.POSITIVE_INFINITY){return"function"==typeof e?r=>r.pipe(mt((n,r)=>ht(t(n,r)).pipe(et((t,i)=>e(n,t,r,i))),n)):("number"==typeof e&&(n=e),e=>e.lift(new gt(t,n)))}class gt{constructor(t,e=Number.POSITIVE_INFINITY){this.project=t,this.concurrent=e}call(t,e){return e.subscribe(new yt(t,this.project,this.concurrent))}}class yt extends pt{constructor(t,e,n=Number.POSITIVE_INFINITY){super(t),this.project=e,this.concurrent=n,this.hasCompleted=!1,this.buffer=[],this.active=0,this.index=0}_next(t){this.active<this.concurrent?this._tryNext(t):this.buffer.push(t)}_tryNext(t){let e;const n=this.index++;try{e=this.project(t,n)}catch(r){return void this.destination.error(r)}this.active++,this._innerSub(e)}_innerSub(t){const e=new dt(this),n=this.destination;n.add(e);const r=ft(t,e);r!==e&&n.add(r)}_complete(){this.hasCompleted=!0,0===this.active&&0===this.buffer.length&&this.destination.complete(),this.unsubscribe()}notifyNext(t){this.destination.next(t)}notifyComplete(){const t=this.buffer;this.active--,t.length>0?this._next(t.shift()):0===this.active&&this.hasCompleted&&this.destination.complete()}}function vt(t=Number.POSITIVE_INFINITY){return mt(G,t)}function bt(t,e){return e?ut(t,e):new q(it(t))}function _t(...t){let e=Number.POSITIVE_INFINITY,n=null,r=t[t.length-1];return tt(r)?(n=t.pop(),t.length>1&&"number"==typeof t[t.length-1]&&(e=t.pop())):"number"==typeof r&&(e=t.pop()),null===n&&1===t.length&&t[0]instanceof q?t[0]:vt(e)(bt(t,n))}function xt(){return function(t){return t.lift(new wt(t))}}class wt{constructor(t){this.connectable=t}call(t,e){const{connectable:n}=this;n._refCount++;const r=new St(t,n),i=e.subscribe(r);return r.closed||(r.connection=n.connect()),i}}class St extends H{constructor(t,e){super(t),this.connectable=e}_unsubscribe(){const{connectable:t}=this;if(!t)return void(this.connection=null);this.connectable=null;const e=t._refCount;if(e<=0)return void(this.connection=null);if(t._refCount=e-1,e>1)return void(this.connection=null);const{connection:n}=this,r=t._connection;this.connection=null,!r||n&&r!==n||r.unsubscribe()}}class Et extends q{constructor(t,e){super(),this.source=t,this.subjectFactory=e,this._refCount=0,this._isComplete=!1}_subscribe(t){return this.getSubject().subscribe(t)}getSubject(){const t=this._subject;return t&&!t.isStopped||(this._subject=this.subjectFactory()),this._subject}connect(){let t=this._connection;return t||(this._isComplete=!1,t=this._connection=new z,t.add(this.source.subscribe(new Tt(this.getSubject(),this))),t.closed&&(this._connection=null,t=z.EMPTY)),t}refCount(){return xt()(this)}}const Ct=(()=>{const t=Et.prototype;return{operator:{value:null},_refCount:{value:0,writable:!0},_subject:{value:null,writable:!0},_connection:{value:null,writable:!0},_subscribe:{value:t._subscribe},_isComplete:{value:t._isComplete,writable:!0},getSubject:{value:t.getSubject},connect:{value:t.connect},refCount:{value:t.refCount}}})();class Tt extends Z{constructor(t,e){super(t),this.connectable=e}_error(t){this._unsubscribe(),super._error(t)}_complete(){this.connectable._isComplete=!0,this._unsubscribe(),super._complete()}_unsubscribe(){const t=this.connectable;if(t){this.connectable=null;const e=t._connection;t._refCount=0,t._subject=null,t._connection=null,e&&e.unsubscribe()}}}function At(){return new J}function Mt(){return t=>{return xt()((e=At,function(t){let n;n="function"==typeof e?e:function(){return e};const r=Object.create(t,Ct);return r.source=t,r.subjectFactory=n,r})(t));var e}}function kt(t){for(let e in t)if(t[e]===kt)return e;throw Error("Could not find renamed property on target object.")}function Rt(t,e){for(const n in e)e.hasOwnProperty(n)&&!t.hasOwnProperty(n)&&(t[n]=e[n])}function It(t){if("string"==typeof t)return t;if(Array.isArray(t))return"["+t.map(It).join(", ")+"]";if(null==t)return""+t;if(t.overriddenName)return`${t.overriddenName}`;if(t.name)return`${t.name}`;const e=t.toString();if(null==e)return""+e;const n=e.indexOf("\n");return-1===n?e:e.substring(0,n)}function Nt(t,e){return null==t||""===t?null===e?"":e:null==e||""===e?t:t+" "+e}const Ot=kt({__forward_ref__:kt});function Dt(t){return t.__forward_ref__=Dt,t.toString=function(){return It(this())},t}function Lt(t){return Ft(t)?t():t}function Ft(t){return"function"==typeof t&&t.hasOwnProperty(Ot)&&t.__forward_ref__===Dt}function Pt(t){return{token:t.token,providedIn:t.providedIn||null,factory:t.factory,value:void 0}}const $t=Pt;function Bt(t){return{factory:t.factory,providers:t.providers||[],imports:t.imports||[]}}function zt(t){return Vt(t,Ht)||Vt(t,jt)}function Vt(t,e){return t.hasOwnProperty(e)?t[e]:null}function Ut(t){return t&&(t.hasOwnProperty(Wt)||t.hasOwnProperty(Gt))?t[Wt]:null}const Ht=kt({"\u0275prov":kt}),Wt=kt({"\u0275inj":kt}),jt=kt({ngInjectableDef:kt}),Gt=kt({ngInjectorDef:kt});var qt=function(t){return t[t.Default=0]="Default",t[t.Host=1]="Host",t[t.Self=2]="Self",t[t.SkipSelf=4]="SkipSelf",t[t.Optional=8]="Optional",t}({});let Xt;function Kt(t){const e=Xt;return Xt=t,e}function Yt(t,e,n){const r=zt(t);if(r&&"root"==r.providedIn)return void 0===r.value?r.value=r.factory():r.value;if(n&qt.Optional)return null;if(void 0!==e)return e;throw new Error(`Injector: NOT_FOUND [${It(t)}]`)}function Zt(t){return{toString:t}.toString()}var Jt=function(t){return t[t.OnPush=0]="OnPush",t[t.Default=1]="Default",t}({}),Qt=function(t){return t[t.Emulated=0]="Emulated",t[t.None=2]="None",t[t.ShadowDom=3]="ShadowDom",t}({});const te="undefined"!=typeof globalThis&&globalThis,ee="undefined"!=typeof window&&window,ne="undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self,re="undefined"!=typeof global&&global,ie=te||re||ee||ne,se={},oe=[],ae=kt({"\u0275cmp":kt}),le=kt({"\u0275dir":kt}),ce=kt({"\u0275pipe":kt}),ue=kt({"\u0275mod":kt}),he=kt({"\u0275loc":kt}),de=kt({"\u0275fac":kt}),pe=kt({__NG_ELEMENT_ID__:kt});let fe=0;function me(t){return Zt(()=>{const e={},n={type:t.type,providersResolver:null,decls:t.decls,vars:t.vars,factory:null,template:t.template||null,consts:t.consts||null,ngContentSelectors:t.ngContentSelectors,hostBindings:t.hostBindings||null,hostVars:t.hostVars||0,hostAttrs:t.hostAttrs||null,contentQueries:t.contentQueries||null,declaredInputs:e,inputs:null,outputs:null,exportAs:t.exportAs||null,onPush:t.changeDetection===Jt.OnPush,directiveDefs:null,pipeDefs:null,selectors:t.selectors||oe,viewQuery:t.viewQuery||null,features:t.features||null,data:t.data||{},encapsulation:t.encapsulation||Qt.Emulated,id:"c",styles:t.styles||oe,_:null,setInput:null,schemas:t.schemas||null,tView:null},r=t.directives,i=t.features,s=t.pipes;return n.id+=fe++,n.inputs=_e(t.inputs,e),n.outputs=_e(t.outputs),i&&i.forEach(t=>t(n)),n.directiveDefs=r?()=>("function"==typeof r?r():r).map(ge):null,n.pipeDefs=s?()=>("function"==typeof s?s():s).map(ye):null,n})}function ge(t){return Se(t)||function(t){return t[le]||null}(t)}function ye(t){return function(t){return t[ce]||null}(t)}const ve={};function be(t){const e={type:t.type,bootstrap:t.bootstrap||oe,declarations:t.declarations||oe,imports:t.imports||oe,exports:t.exports||oe,transitiveCompileScopes:null,schemas:t.schemas||null,id:t.id||null};return null!=t.id&&Zt(()=>{ve[t.id]=t.type}),e}function _e(t,e){if(null==t)return se;const n={};for(const r in t)if(t.hasOwnProperty(r)){let i=t[r],s=i;Array.isArray(i)&&(s=i[1],i=i[0]),n[i]=r,e&&(e[i]=s)}return n}const xe=me;function we(t){return{type:t.type,name:t.name,factory:null,pure:!1!==t.pure,onDestroy:t.type.prototype.ngOnDestroy||null}}function Se(t){return t[ae]||null}function Ee(t,e){const n=t[ue]||null;if(!n&&!0===e)throw new Error(`Type ${It(t)} does not have '\u0275mod' property.`);return n}const Ce=20,Te=10;function Ae(t){return Array.isArray(t)&&"object"==typeof t[1]}function Me(t){return Array.isArray(t)&&!0===t[1]}function ke(t){return 0!=(8&t.flags)}function Re(t){return 2==(2&t.flags)}function Ie(t){return 1==(1&t.flags)}function Ne(t){return null!==t.template}function Oe(t,e){return t.hasOwnProperty(de)?t[de]:null}class De extends Error{constructor(t,e){super(function(t,e){return`${t?`NG0${t}: `:""}${e}`}(t,e)),this.code=t}}function Le(t){return"string"==typeof t?t:null==t?"":String(t)}function Fe(t){return"function"==typeof t?t.name||t.toString():"object"==typeof t&&null!=t&&"function"==typeof t.type?t.type.name||t.type.toString():Le(t)}function Pe(t,e){const n=e?` in ${e}`:"";throw new De("201",`No provider for ${Fe(t)} found${n}`)}class $e{constructor(t,e,n){this.previousValue=t,this.currentValue=e,this.firstChange=n}isFirstChange(){return this.firstChange}}function Be(){return ze}function ze(t){return t.type.prototype.ngOnChanges&&(t.setInput=Ue),Ve}function Ve(){const t=He(this),e=null==t?void 0:t.current;if(e){const n=t.previous;if(n===se)t.previous=e;else for(let t in e)n[t]=e[t];t.current=null,this.ngOnChanges(e)}}function Ue(t,e,n,r){const i=He(t)||function(t,e){return t.__ngSimpleChanges__=e}(t,{previous:se,current:null}),s=i.current||(i.current={}),o=i.previous,a=this.declaredInputs[n],l=o[a];s[a]=new $e(l&&l.currentValue,e,o===se),t[r]=e}function He(t){return t.__ngSimpleChanges__||null}Be.ngInherit=!0;const We="http://www.w3.org/2000/svg";let je;function Ge(){return void 0!==je?je:"undefined"!=typeof document?document:void 0}function qe(t){return!!t.listen}const Xe={createRenderer:(t,e)=>Ge()};function Ke(t){for(;Array.isArray(t);)t=t[0];return t}function Ye(t,e){return Ke(e[t])}function Ze(t,e){return Ke(e[t.index])}function Je(t,e){return t.data[e]}function Qe(t,e){const n=e[t];return Ae(n)?n:n[0]}function tn(t){const e=function(t){return t.__ngContext__||null}(t);return e?Array.isArray(e)?e:e.lView:null}function en(t){return 4==(4&t[2])}function nn(t){return 128==(128&t[2])}function rn(t,e){return null==e?null:t[e]}function sn(t){t[18]=0}function on(t,e){t[5]+=e;let n=t,r=t[3];for(;null!==r&&(1===e&&1===n[5]||-1===e&&0===n[5]);)r[5]+=e,n=r,r=r[3]}const an={lFrame:Rn(null),bindingsEnabled:!0,isInCheckNoChangesMode:!1};function ln(){return an.bindingsEnabled}function cn(){return an.lFrame.lView}function un(){return an.lFrame.tView}function hn(t){an.lFrame.contextLView=t}function dn(){let t=pn();for(;null!==t&&64===t.type;)t=t.parent;return t}function pn(){return an.lFrame.currentTNode}function fn(t,e){const n=an.lFrame;n.currentTNode=t,n.isParent=e}function mn(){return an.lFrame.isParent}function gn(){an.lFrame.isParent=!1}function yn(){return an.isInCheckNoChangesMode}function vn(t){an.isInCheckNoChangesMode=t}function bn(){return an.lFrame.bindingIndex++}function _n(t){const e=an.lFrame,n=e.bindingIndex;return e.bindingIndex=e.bindingIndex+t,n}function xn(t,e){const n=an.lFrame;n.bindingIndex=n.bindingRootIndex=t,wn(e)}function wn(t){an.lFrame.currentDirectiveIndex=t}function Sn(t){const e=an.lFrame.currentDirectiveIndex;return-1===e?null:t[e]}function En(){return an.lFrame.currentQueryIndex}function Cn(t){an.lFrame.currentQueryIndex=t}function Tn(t){const e=t[1];return 2===e.type?e.declTNode:1===e.type?t[6]:null}function An(t,e,n){if(n&qt.SkipSelf){let r=e,i=t;for(;r=r.parent,!(null!==r||n&qt.Host||(r=Tn(i),null===r)||(i=i[15],10&r.type)););if(null===r)return!1;e=r,t=i}const r=an.lFrame=kn();return r.currentTNode=e,r.lView=t,!0}function Mn(t){const e=kn(),n=t[1];an.lFrame=e,e.currentTNode=n.firstChild,e.lView=t,e.tView=n,e.contextLView=t,e.bindingIndex=n.bindingStartIndex,e.inI18n=!1}function kn(){const t=an.lFrame,e=null===t?null:t.child;return null===e?Rn(t):e}function Rn(t){const e={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:t,child:null,inI18n:!1};return null!==t&&(t.child=e),e}function In(){const t=an.lFrame;return an.lFrame=t.parent,t.currentTNode=null,t.lView=null,t}const Nn=In;function On(){const t=In();t.isParent=!0,t.tView=null,t.selectedIndex=-1,t.contextLView=null,t.elementDepthCount=0,t.currentDirectiveIndex=-1,t.currentNamespace=null,t.bindingRootIndex=-1,t.bindingIndex=-1,t.currentQueryIndex=0}function Dn(){return an.lFrame.selectedIndex}function Ln(t){an.lFrame.selectedIndex=t}function Fn(){const t=an.lFrame;return Je(t.tView,t.selectedIndex)}function Pn(){an.lFrame.currentNamespace=We}function $n(t,e){for(let n=e.directiveStart,r=e.directiveEnd;n<r;n++){const e=t.data[n].type.prototype,{ngAfterContentInit:r,ngAfterContentChecked:i,ngAfterViewInit:s,ngAfterViewChecked:o,ngOnDestroy:a}=e;r&&(t.contentHooks||(t.contentHooks=[])).push(-n,r),i&&((t.contentHooks||(t.contentHooks=[])).push(n,i),(t.contentCheckHooks||(t.contentCheckHooks=[])).push(n,i)),s&&(t.viewHooks||(t.viewHooks=[])).push(-n,s),o&&((t.viewHooks||(t.viewHooks=[])).push(n,o),(t.viewCheckHooks||(t.viewCheckHooks=[])).push(n,o)),null!=a&&(t.destroyHooks||(t.destroyHooks=[])).push(n,a)}}function Bn(t,e,n){Un(t,e,3,n)}function zn(t,e,n,r){(3&t[2])===n&&Un(t,e,n,r)}function Vn(t,e){let n=t[2];(3&n)===e&&(n&=2047,n+=1,t[2]=n)}function Un(t,e,n,r){const i=null!=r?r:-1,s=e.length-1;let o=0;for(let a=void 0!==r?65535&t[18]:0;a<s;a++)if("number"==typeof e[a+1]){if(o=e[a],null!=r&&o>=r)break}else e[a]<0&&(t[18]+=65536),(o<i||-1==i)&&(Hn(t,n,e,a),t[18]=(4294901760&t[18])+a+2),a++}function Hn(t,e,n,r){const i=n[r]<0,s=n[r+1],o=t[i?-n[r]:n[r]];i?t[2]>>11<t[18]>>16&&(3&t[2])===e&&(t[2]+=2048,s.call(o)):s.call(o)}const Wn=-1;class jn{constructor(t,e,n){this.factory=t,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=n}}function Gn(t,e,n){const r=qe(t);let i=0;for(;i<n.length;){const s=n[i];if("number"==typeof s){if(0!==s)break;i++;const o=n[i++],a=n[i++],l=n[i++];r?t.setAttribute(e,a,l,o):e.setAttributeNS(o,a,l)}else{const o=s,a=n[++i];Xn(o)?r&&t.setProperty(e,o,a):r?t.setAttribute(e,o,a):e.setAttribute(o,a),i++}}return i}function qn(t){return 3===t||4===t||6===t}function Xn(t){return 64===t.charCodeAt(0)}function Kn(t,e){if(null===e||0===e.length);else if(null===t||0===t.length)t=e.slice();else{let n=-1;for(let r=0;r<e.length;r++){const i=e[r];"number"==typeof i?n=i:0===n||Yn(t,n,i,null,-1===n||2===n?e[++r]:null)}}return t}function Yn(t,e,n,r,i){let s=0,o=t.length;if(-1===e)o=-1;else for(;s<t.length;){const n=t[s++];if("number"==typeof n){if(n===e){o=-1;break}if(n>e){o=s-1;break}}}for(;s<t.length;){const e=t[s];if("number"==typeof e)break;if(e===n){if(null===r)return void(null!==i&&(t[s+1]=i));if(r===t[s+1])return void(t[s+2]=i)}s++,null!==r&&s++,null!==i&&s++}-1!==o&&(t.splice(o,0,e),s=o+1),t.splice(s++,0,n),null!==r&&t.splice(s++,0,r),null!==i&&t.splice(s++,0,i)}function Zn(t){return t!==Wn}function Jn(t){return 32767&t}function Qn(t,e){let n=t>>16,r=e;for(;n>0;)r=r[15],n--;return r}let tr=!0;function er(t){const e=tr;return tr=t,e}let nr=0;function rr(t,e){const n=sr(t,e);if(-1!==n)return n;const r=e[1];r.firstCreatePass&&(t.injectorIndex=e.length,ir(r.data,t),ir(e,null),ir(r.blueprint,null));const i=or(t,e),s=t.injectorIndex;if(Zn(i)){const t=Jn(i),n=Qn(i,e),r=n[1].data;for(let i=0;i<8;i++)e[s+i]=n[t+i]|r[t+i]}return e[s+8]=i,s}function ir(t,e){t.push(0,0,0,0,0,0,0,0,e)}function sr(t,e){return-1===t.injectorIndex||t.parent&&t.parent.injectorIndex===t.injectorIndex||null===e[t.injectorIndex+8]?-1:t.injectorIndex}function or(t,e){if(t.parent&&-1!==t.parent.injectorIndex)return t.parent.injectorIndex;let n=0,r=null,i=e;for(;null!==i;){const t=i[1],e=t.type;if(r=2===e?t.declTNode:1===e?i[6]:null,null===r)return Wn;if(n++,i=i[15],-1!==r.injectorIndex)return r.injectorIndex|n<<16}return Wn}function ar(t,e,n){!function(t,e,n){let r;"string"==typeof n?r=n.charCodeAt(0)||0:n.hasOwnProperty(pe)&&(r=n[pe]),null==r&&(r=n[pe]=nr++);const i=255&r;e.data[t+(i>>5)]|=1<<i}(t,e,n)}function lr(t,e,n){if(n&qt.Optional)return t;Pe(e,"NodeInjector")}function cr(t,e,n,r){if(n&qt.Optional&&void 0===r&&(r=null),0==(n&(qt.Self|qt.Host))){const i=t[9],s=Kt(void 0);try{return i?i.get(e,r,n&qt.Optional):Yt(e,r,n&qt.Optional)}finally{Kt(s)}}return lr(r,e,n)}function ur(t,e,n,r=qt.Default,i){if(null!==t){const s=function(t){if("string"==typeof t)return t.charCodeAt(0)||0;const e=t.hasOwnProperty(pe)?t[pe]:void 0;return"number"==typeof e?e>=0?255&e:dr:e}(n);if("function"==typeof s){if(!An(e,t,r))return r&qt.Host?lr(i,n,r):cr(e,n,r,i);try{const t=s();if(null!=t||r&qt.Optional)return t;Pe(n)}finally{Nn()}}else if("number"==typeof s){let i=null,o=sr(t,e),a=Wn,l=r&qt.Host?e[16][6]:null;for((-1===o||r&qt.SkipSelf)&&(a=-1===o?or(t,e):e[o+8],a!==Wn&&yr(r,!1)?(i=e[1],o=Jn(a),e=Qn(a,e)):o=-1);-1!==o;){const t=e[1];if(gr(s,o,t.data)){const t=pr(o,e,n,i,r,l);if(t!==hr)return t}a=e[o+8],a!==Wn&&yr(r,e[1].data[o+8]===l)&&gr(s,o,e)?(i=t,o=Jn(a),e=Qn(a,e)):o=-1}}}return cr(e,n,r,i)}const hr={};function dr(){return new vr(dn(),cn())}function pr(t,e,n,r,i,s){const o=e[1],a=o.data[t+8],l=fr(a,o,n,null==r?Re(a)&&tr:r!=o&&0!=(3&a.type),i&qt.Host&&s===a);return null!==l?mr(e,o,l,a):hr}function fr(t,e,n,r,i){const s=t.providerIndexes,o=e.data,a=1048575&s,l=t.directiveStart,c=s>>20,u=i?a+c:t.directiveEnd;for(let h=r?a:a+c;h<u;h++){const t=o[h];if(h<l&&n===t||h>=l&&t.type===n)return h}if(i){const t=o[l];if(t&&Ne(t)&&t.type===n)return l}return null}function mr(t,e,n,r){let i=t[n];const s=e.data;if(i instanceof jn){const o=i;o.resolving&&function(t,e){throw new De("200",`Circular dependency in DI detected for ${t}`)}(Fe(s[n]));const a=er(o.canSeeViewProviders);o.resolving=!0;const l=o.injectImpl?Kt(o.injectImpl):null;An(t,r,qt.Default);try{i=t[n]=o.factory(void 0,s,t,r),e.firstCreatePass&&n>=r.directiveStart&&function(t,e,n){const{ngOnChanges:r,ngOnInit:i,ngDoCheck:s}=e.type.prototype;if(r){const r=ze(e);(n.preOrderHooks||(n.preOrderHooks=[])).push(t,r),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(t,r)}i&&(n.preOrderHooks||(n.preOrderHooks=[])).push(0-t,i),s&&((n.preOrderHooks||(n.preOrderHooks=[])).push(t,s),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(t,s))}(n,s[n],e)}finally{null!==l&&Kt(l),er(a),o.resolving=!1,Nn()}}return i}function gr(t,e,n){return!!(n[e+(t>>5)]&1<<t)}function yr(t,e){return!(t&qt.Self||t&qt.Host&&e)}class vr{constructor(t,e){this._tNode=t,this._lView=e}get(t,e){return ur(this._tNode,this._lView,t,void 0,e)}}function br(t){const e=t;if(Ft(t))return()=>{const t=br(Lt(e));return t?t():null};let n=Oe(e);if(null===n){const t=Ut(e);n=t&&t.factory}return n||null}function _r(t){return Zt(()=>{const e=t.prototype.constructor,n=e[de]||br(e),r=Object.prototype;let i=Object.getPrototypeOf(t.prototype).constructor;for(;i&&i!==r;){const t=i[de]||br(i);if(t&&t!==n)return t;i=Object.getPrototypeOf(i)}return t=>new t})}function xr(t){return function(t,e){if("class"===e)return t.classes;if("style"===e)return t.styles;const n=t.attrs;if(n){const t=n.length;let r=0;for(;r<t;){const i=n[r];if(qn(i))break;if(0===i)r+=2;else if("number"==typeof i)for(r++;r<t&&"string"==typeof n[r];)r++;else{if(i===e)return n[r+1];r+=2}}}return null}(dn(),t)}const wr="__parameters__";function Sr(t,e,n){return Zt(()=>{const r=function(t){return function(...e){if(t){const n=t(...e);for(const t in n)this[t]=n[t]}}}(e);function i(...t){if(this instanceof i)return r.apply(this,t),this;const e=new i(...t);return n.annotation=e,n;function n(t,n,r){const i=t.hasOwnProperty(wr)?t[wr]:Object.defineProperty(t,wr,{value:[]})[wr];for(;i.length<=r;)i.push(null);return(i[r]=i[r]||[]).push(e),t}}return n&&(i.prototype=Object.create(n.prototype)),i.prototype.ngMetadataName=t,i.annotationCls=i,i})}class Er{constructor(t,e){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=Pt({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}toString(){return`InjectionToken ${this._desc}`}}function Cr(t,e){void 0===e&&(e=t);for(let n=0;n<t.length;n++){let r=t[n];Array.isArray(r)?(e===t&&(e=t.slice(0,n)),Cr(r,e)):e!==t&&e.push(r)}return e}function Tr(t,e){t.forEach(t=>Array.isArray(t)?Tr(t,e):e(t))}function Ar(t,e,n){e>=t.length?t.push(n):t.splice(e,0,n)}function Mr(t,e){return e>=t.length-1?t.pop():t.splice(e,1)[0]}function kr(t,e){const n=[];for(let r=0;r<t;r++)n.push(e);return n}function Rr(t,e,n){let r=Nr(t,e);return r>=0?t[1|r]=n:(r=~r,function(t,e,n,r){let i=t.length;if(i==e)t.push(n,r);else if(1===i)t.push(r,t[0]),t[0]=n;else{for(i--,t.push(t[i-1],t[i]);i>e;)t[i]=t[i-2],i--;t[e]=n,t[e+1]=r}}(t,r,e,n)),r}function Ir(t,e){const n=Nr(t,e);if(n>=0)return t[1|n]}function Nr(t,e){return function(t,e,n){let r=0,i=t.length>>1;for(;i!==r;){const n=r+(i-r>>1),s=t[n<<1];if(e===s)return n<<1;s>e?i=n:r=n+1}return~(i<<1)}(t,e)}const Or={},Dr=/\n/gm,Lr="__source",Fr=kt({provide:String,useValue:kt});let Pr;function $r(t){const e=Pr;return Pr=t,e}function Br(t,e=qt.Default){if(void 0===Pr)throw new Error("inject() must be called from an injection context");return null===Pr?Yt(t,void 0,e):Pr.get(t,e&qt.Optional?null:void 0,e)}function zr(t,e=qt.Default){return(Xt||Br)(Lt(t),e)}const Vr=zr;function Ur(t){const e=[];for(let n=0;n<t.length;n++){const r=Lt(t[n]);if(Array.isArray(r)){if(0===r.length)throw new Error("Arguments array must have arguments.");let t,n=qt.Default;for(let e=0;e<r.length;e++){const i=r[e],s=i.__NG_DI_FLAG__;"number"==typeof s?-1===s?t=i.token:n|=s:t=i}e.push(zr(t,n))}else e.push(zr(r))}return e}function Hr(t,e){return t.__NG_DI_FLAG__=e,t.prototype.__NG_DI_FLAG__=e,t}const Wr=Hr(Sr("Inject",t=>({token:t})),-1),jr=Hr(Sr("Optional"),8),Gr=Hr(Sr("SkipSelf"),4);let qr,Xr;function Kr(t){var e;return(null===(e=function(){if(void 0===qr&&(qr=null,ie.trustedTypes))try{qr=ie.trustedTypes.createPolicy("angular",{createHTML:t=>t,createScript:t=>t,createScriptURL:t=>t})}catch(e){}return qr}())||void 0===e?void 0:e.createHTML(t))||t}function Yr(t){var e;return(null===(e=function(){if(void 0===Xr&&(Xr=null,ie.trustedTypes))try{Xr=ie.trustedTypes.createPolicy("angular#unsafe-bypass",{createHTML:t=>t,createScript:t=>t,createScriptURL:t=>t})}catch(e){}return Xr}())||void 0===e?void 0:e.createHTML(t))||t}class Zr{constructor(t){this.changingThisBreaksApplicationSecurity=t}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`}}class Jr extends Zr{getTypeName(){return"HTML"}}class Qr extends Zr{getTypeName(){return"Style"}}class ti extends Zr{getTypeName(){return"Script"}}class ei extends Zr{getTypeName(){return"URL"}}class ni extends Zr{getTypeName(){return"ResourceURL"}}function ri(t){return t instanceof Zr?t.changingThisBreaksApplicationSecurity:t}function ii(t,e){const n=si(t);if(null!=n&&n!==e){if("ResourceURL"===n&&"URL"===e)return!0;throw new Error(`Required a safe ${e}, got a ${n} (see https://g.co/ng/security#xss)`)}return n===e}function si(t){return t instanceof Zr&&t.getTypeName()||null}class oi{constructor(t){this.inertDocumentHelper=t}getInertBodyElement(t){t="<body><remove></remove>"+t;try{const e=(new window.DOMParser).parseFromString(Kr(t),"text/html").body;return null===e?this.inertDocumentHelper.getInertBodyElement(t):(e.removeChild(e.firstChild),e)}catch(e){return null}}}class ai{constructor(t){if(this.defaultDoc=t,this.inertDocument=this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"),null==this.inertDocument.body){const t=this.inertDocument.createElement("html");this.inertDocument.appendChild(t);const e=this.inertDocument.createElement("body");t.appendChild(e)}}getInertBodyElement(t){const e=this.inertDocument.createElement("template");if("content"in e)return e.innerHTML=Kr(t),e;const n=this.inertDocument.createElement("body");return n.innerHTML=Kr(t),this.defaultDoc.documentMode&&this.stripCustomNsAttrs(n),n}stripCustomNsAttrs(t){const e=t.attributes;for(let r=e.length-1;0<r;r--){const n=e.item(r).name;"xmlns:ns1"!==n&&0!==n.indexOf("ns1:")||t.removeAttribute(n)}let n=t.firstChild;for(;n;)n.nodeType===Node.ELEMENT_NODE&&this.stripCustomNsAttrs(n),n=n.nextSibling}}const li=/^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi,ci=/^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;function ui(t){return(t=String(t)).match(li)||t.match(ci)?t:"unsafe:"+t}function hi(t){const e={};for(const n of t.split(","))e[n]=!0;return e}function di(...t){const e={};for(const n of t)for(const t in n)n.hasOwnProperty(t)&&(e[t]=!0);return e}const pi=hi("area,br,col,hr,img,wbr"),fi=hi("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),mi=hi("rp,rt"),gi=di(mi,fi),yi=di(pi,di(fi,hi("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")),di(mi,hi("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")),gi),vi=hi("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),bi=hi("srcset"),_i=di(vi,bi,hi("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"),hi("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")),xi=hi("script,style,template");class wi{constructor(){this.sanitizedSomething=!1,this.buf=[]}sanitizeChildren(t){let e=t.firstChild,n=!0;for(;e;)if(e.nodeType===Node.ELEMENT_NODE?n=this.startElement(e):e.nodeType===Node.TEXT_NODE?this.chars(e.nodeValue):this.sanitizedSomething=!0,n&&e.firstChild)e=e.firstChild;else for(;e;){e.nodeType===Node.ELEMENT_NODE&&this.endElement(e);let t=this.checkClobberedElement(e,e.nextSibling);if(t){e=t;break}e=this.checkClobberedElement(e,e.parentNode)}return this.buf.join("")}startElement(t){const e=t.nodeName.toLowerCase();if(!yi.hasOwnProperty(e))return this.sanitizedSomething=!0,!xi.hasOwnProperty(e);this.buf.push("<"),this.buf.push(e);const n=t.attributes;for(let i=0;i<n.length;i++){const t=n.item(i),e=t.name,s=e.toLowerCase();if(!_i.hasOwnProperty(s)){this.sanitizedSomething=!0;continue}let o=t.value;vi[s]&&(o=ui(o)),bi[s]&&(r=o,o=(r=String(r)).split(",").map(t=>ui(t.trim())).join(", ")),this.buf.push(" ",e,'="',Ci(o),'"')}var r;return this.buf.push(">"),!0}endElement(t){const e=t.nodeName.toLowerCase();yi.hasOwnProperty(e)&&!pi.hasOwnProperty(e)&&(this.buf.push("</"),this.buf.push(e),this.buf.push(">"))}chars(t){this.buf.push(Ci(t))}checkClobberedElement(t,e){if(e&&(t.compareDocumentPosition(e)&Node.DOCUMENT_POSITION_CONTAINED_BY)===Node.DOCUMENT_POSITION_CONTAINED_BY)throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`);return e}}const Si=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,Ei=/([^\#-~ |!])/g;function Ci(t){return t.replace(/&/g,"&amp;").replace(Si,function(t){return"&#"+(1024*(t.charCodeAt(0)-55296)+(t.charCodeAt(1)-56320)+65536)+";"}).replace(Ei,function(t){return"&#"+t.charCodeAt(0)+";"}).replace(/</g,"&lt;").replace(/>/g,"&gt;")}let Ti;function Ai(t,e){let n=null;try{Ti=Ti||function(t){const e=new ai(t);return function(){try{return!!(new window.DOMParser).parseFromString(Kr(""),"text/html")}catch(t){return!1}}()?new oi(e):e}(t);let r=e?String(e):"";n=Ti.getInertBodyElement(r);let i=5,s=r;do{if(0===i)throw new Error("Failed to sanitize html because the input is unstable");i--,r=s,s=n.innerHTML,n=Ti.getInertBodyElement(r)}while(r!==s);return Kr((new wi).sanitizeChildren(Mi(n)||n))}finally{if(n){const t=Mi(n)||n;for(;t.firstChild;)t.removeChild(t.firstChild)}}}function Mi(t){return"content"in t&&function(t){return t.nodeType===Node.ELEMENT_NODE&&"TEMPLATE"===t.nodeName}(t)?t.content:null}var ki=function(t){return t[t.NONE=0]="NONE",t[t.HTML=1]="HTML",t[t.STYLE=2]="STYLE",t[t.SCRIPT=3]="SCRIPT",t[t.URL=4]="URL",t[t.RESOURCE_URL=5]="RESOURCE_URL",t}({});function Ri(t){const e=function(){const t=cn();return t&&t[12]}();return e?Yr(e.sanitize(ki.HTML,t)||""):ii(t,"HTML")?Yr(ri(t)):Ai(Ge(),Le(t))}function Ii(t){return t.ngDebugContext}function Ni(t){return t.ngOriginalError}function Oi(t,...e){t.error(...e)}class Di{constructor(){this._console=console}handleError(t){const e=this._findOriginalError(t),n=this._findContext(t),r=function(t){return t.ngErrorLogger||Oi}(t);r(this._console,"ERROR",t),e&&r(this._console,"ORIGINAL ERROR",e),n&&r(this._console,"ERROR CONTEXT",n)}_findContext(t){return t?Ii(t)?Ii(t):this._findContext(Ni(t)):null}_findOriginalError(t){let e=Ni(t);for(;e&&Ni(e);)e=Ni(e);return e}}function Li(t,e){t.__ngContext__=e}const Fi=(()=>("undefined"!=typeof requestAnimationFrame&&requestAnimationFrame||setTimeout).bind(ie))();function Pi(t){return{name:"body",target:t.ownerDocument.body}}function $i(t){return t instanceof Function?t():t}var Bi=function(t){return t[t.Important=1]="Important",t[t.DashCase=2]="DashCase",t}({});function zi(t,e){return(void 0)(t,e)}function Vi(t){const e=t[3];return Me(e)?e[3]:e}function Ui(t){return Wi(t[13])}function Hi(t){return Wi(t[4])}function Wi(t){for(;null!==t&&!Me(t);)t=t[4];return t}function ji(t,e,n,r,i){if(null!=r){let s,o=!1;Me(r)?s=r:Ae(r)&&(o=!0,r=r[0]);const a=Ke(r);0===t&&null!==n?null==i?Qi(e,n,a):Ji(e,n,a,i||null,!0):1===t&&null!==n?Ji(e,n,a,i||null,!0):2===t?function(t,e,n){const r=es(t,e);r&&function(t,e,n,r){qe(t)?t.removeChild(e,n,r):e.removeChild(n)}(t,r,e,n)}(e,a,o):3===t&&e.destroyNode(a),null!=s&&function(t,e,n,r,i){const s=n[7];s!==Ke(n)&&ji(e,t,r,s,i);for(let o=Te;o<n.length;o++){const i=n[o];cs(i[1],i,t,e,r,s)}}(e,t,s,n,i)}}function Gi(t,e,n){return qe(t)?t.createElement(e,n):null===n?t.createElement(e):t.createElementNS(n,e)}function qi(t,e){const n=t[9],r=n.indexOf(e),i=e[3];1024&e[2]&&(e[2]&=-1025,on(i,-1)),n.splice(r,1)}function Xi(t,e){if(t.length<=Te)return;const n=Te+e,r=t[n];if(r){const s=r[17];null!==s&&s!==t&&qi(s,r),e>0&&(t[n-1][4]=r[4]);const o=Mr(t,Te+e);cs(r[1],i=r,i[11],2,null,null),i[0]=null,i[6]=null;const a=o[19];null!==a&&a.detachView(o[1]),r[3]=null,r[4]=null,r[2]&=-129}var i;return r}function Ki(t,e){if(!(256&e[2])){const n=e[11];qe(n)&&n.destroyNode&&cs(t,e,n,3,null,null),function(t){let e=t[13];if(!e)return Yi(t[1],t);for(;e;){let n=null;if(Ae(e))n=e[13];else{const t=e[10];t&&(n=t)}if(!n){for(;e&&!e[4]&&e!==t;)Ae(e)&&Yi(e[1],e),e=e[3];null===e&&(e=t),Ae(e)&&Yi(e[1],e),n=e&&e[4]}e=n}}(e)}}function Yi(t,e){if(!(256&e[2])){e[2]&=-129,e[2]|=256,function(t,e){let n;if(null!=t&&null!=(n=t.destroyHooks))for(let r=0;r<n.length;r+=2){const t=e[n[r]];if(!(t instanceof jn)){const e=n[r+1];if(Array.isArray(e))for(let n=0;n<e.length;n+=2)e[n+1].call(t[e[n]]);else e.call(t)}}}(t,e),function(t,e){const n=t.cleanup,r=e[7];let i=-1;if(null!==n)for(let s=0;s<n.length-1;s+=2)if("string"==typeof n[s]){const t=n[s+1],o="function"==typeof t?t(e):Ke(e[t]),a=r[i=n[s+2]],l=n[s+3];"boolean"==typeof l?o.removeEventListener(n[s],a,l):l>=0?r[i=l]():r[i=-l].unsubscribe(),s+=2}else{const t=r[i=n[s+1]];n[s].call(t)}if(null!==r){for(let t=i+1;t<r.length;t++)(0,r[t])();e[7]=null}}(t,e),1===e[1].type&&qe(e[11])&&e[11].destroy();const n=e[17];if(null!==n&&Me(e[3])){n!==e[3]&&qi(n,e);const r=e[19];null!==r&&r.detachView(t)}}}function Zi(t,e,n){return function(t,e,n){let r=e;for(;null!==r&&40&r.type;)r=(e=r).parent;if(null===r)return n[0];if(2&r.flags){const e=t.data[r.directiveStart].encapsulation;if(e===Qt.None||e===Qt.Emulated)return null}return Ze(r,n)}(t,e.parent,n)}function Ji(t,e,n,r,i){qe(t)?t.insertBefore(e,n,r,i):e.insertBefore(n,r,i)}function Qi(t,e,n){qe(t)?t.appendChild(e,n):e.appendChild(n)}function ts(t,e,n,r,i){null!==r?Ji(t,e,n,r,i):Qi(t,e,n)}function es(t,e){return qe(t)?t.parentNode(e):e.parentNode}function ns(t,e,n){return rs(t,e,n)}let rs=function(t,e,n){return 40&t.type?Ze(t,n):null};function is(t,e,n,r){const i=Zi(t,r,e),s=e[11],o=ns(r.parent||e[6],r,e);if(null!=i)if(Array.isArray(n))for(let a=0;a<n.length;a++)ts(s,i,n[a],o,!1);else ts(s,i,n,o,!1)}function ss(t,e){if(null!==e){const n=e.type;if(3&n)return Ze(e,t);if(4&n)return as(-1,t[e.index]);if(8&n){const n=e.child;if(null!==n)return ss(t,n);{const n=t[e.index];return Me(n)?as(-1,n):Ke(n)}}if(32&n)return zi(e,t)()||Ke(t[e.index]);{const n=os(t,e);return null!==n?Array.isArray(n)?n[0]:ss(Vi(t[16]),n):ss(t,e.next)}}return null}function os(t,e){return null!==e?t[16][6].projection[e.projection]:null}function as(t,e){const n=Te+t+1;if(n<e.length){const t=e[n],r=t[1].firstChild;if(null!==r)return ss(t,r)}return e[7]}function ls(t,e,n,r,i,s,o){for(;null!=n;){const a=r[n.index],l=n.type;if(o&&0===e&&(a&&Li(Ke(a),r),n.flags|=4),64!=(64&n.flags))if(8&l)ls(t,e,n.child,r,i,s,!1),ji(e,t,i,a,s);else if(32&l){const o=zi(n,r);let l;for(;l=o();)ji(e,t,i,l,s);ji(e,t,i,a,s)}else 16&l?us(t,e,r,n,i,s):ji(e,t,i,a,s);n=o?n.projectionNext:n.next}}function cs(t,e,n,r,i,s){ls(n,r,t.firstChild,e,i,s,!1)}function us(t,e,n,r,i,s){const o=n[16],a=o[6].projection[r.projection];if(Array.isArray(a))for(let l=0;l<a.length;l++)ji(e,t,i,a[l],s);else ls(t,e,a,o[3],i,s,!0)}function hs(t,e,n){qe(t)?t.setAttribute(e,"style",n):e.style.cssText=n}function ds(t,e,n){qe(t)?""===n?t.removeAttribute(e,"class"):t.setAttribute(e,"class",n):e.className=n}function ps(t,e,n){let r=t.length;for(;;){const i=t.indexOf(e,n);if(-1===i)return i;if(0===i||t.charCodeAt(i-1)<=32){const n=e.length;if(i+n===r||t.charCodeAt(i+n)<=32)return i}n=i+1}}const fs="ng-template";function ms(t,e,n){let r=0;for(;r<t.length;){let i=t[r++];if(n&&"class"===i){if(i=t[r],-1!==ps(i.toLowerCase(),e,0))return!0}else if(1===i){for(;r<t.length&&"string"==typeof(i=t[r++]);)if(i.toLowerCase()===e)return!0;return!1}}return!1}function gs(t){return 4===t.type&&t.value!==fs}function ys(t,e,n){return e===(4!==t.type||n?t.value:fs)}function vs(t,e,n){let r=4;const i=t.attrs||[],s=function(t){for(let e=0;e<t.length;e++)if(qn(t[e]))return e;return t.length}(i);let o=!1;for(let a=0;a<e.length;a++){const l=e[a];if("number"!=typeof l){if(!o)if(4&r){if(r=2|1&r,""!==l&&!ys(t,l,n)||""===l&&1===e.length){if(bs(r))return!1;o=!0}}else{const c=8&r?l:e[++a];if(8&r&&null!==t.attrs){if(!ms(t.attrs,c,n)){if(bs(r))return!1;o=!0}continue}const u=_s(8&r?"class":l,i,gs(t),n);if(-1===u){if(bs(r))return!1;o=!0;continue}if(""!==c){let t;t=u>s?"":i[u+1].toLowerCase();const e=8&r?t:null;if(e&&-1!==ps(e,c,0)||2&r&&c!==t){if(bs(r))return!1;o=!0}}}}else{if(!o&&!bs(r)&&!bs(l))return!1;if(o&&bs(l))continue;o=!1,r=l|1&r}}return bs(r)||o}function bs(t){return 0==(1&t)}function _s(t,e,n,r){if(null===e)return-1;let i=0;if(r||!n){let n=!1;for(;i<e.length;){const r=e[i];if(r===t)return i;if(3===r||6===r)n=!0;else{if(1===r||2===r){let t=e[++i];for(;"string"==typeof t;)t=e[++i];continue}if(4===r)break;if(0===r){i+=4;continue}}i+=n?1:2}return-1}return function(t,e){let n=t.indexOf(4);if(n>-1)for(n++;n<t.length;){const r=t[n];if("number"==typeof r)return-1;if(r===e)return n;n++}return-1}(e,t)}function xs(t,e,n=!1){for(let r=0;r<e.length;r++)if(vs(t,e[r],n))return!0;return!1}function ws(t,e){t:for(let n=0;n<e.length;n++){const r=e[n];if(t.length===r.length){for(let e=0;e<t.length;e++)if(t[e]!==r[e])continue t;return!0}}return!1}function Ss(t,e){return t?":not("+e.trim()+")":e}function Es(t){let e=t[0],n=1,r=2,i="",s=!1;for(;n<t.length;){let o=t[n];if("string"==typeof o)if(2&r){const e=t[++n];i+="["+o+(e.length>0?'="'+e+'"':"")+"]"}else 8&r?i+="."+o:4&r&&(i+=" "+o);else""===i||bs(o)||(e+=Ss(s,i),i=""),r=o,s=s||!bs(r);n++}return""!==i&&(e+=Ss(s,i)),e}const Cs={};function Ts(t){As(un(),cn(),Dn()+t,yn())}function As(t,e,n,r){if(!r)if(3==(3&e[2])){const r=t.preOrderCheckHooks;null!==r&&Bn(e,r,n)}else{const r=t.preOrderHooks;null!==r&&zn(e,r,0,n)}Ln(n)}function Ms(t,e){return t<<17|e<<2}function ks(t){return t>>17&32767}function Rs(t){return 2|t}function Is(t){return(131068&t)>>2}function Ns(t,e){return-131069&t|e<<2}function Os(t){return 1|t}function Ds(t,e){const n=t.contentQueries;if(null!==n)for(let r=0;r<n.length;r+=2){const i=n[r],s=n[r+1];if(-1!==s){const n=t.data[s];Cn(i),n.contentQueries(2,e[s],s)}}}function Ls(t,e,n,r,i,s,o,a,l,c){const u=e.blueprint.slice();return u[0]=i,u[2]=140|r,sn(u),u[3]=u[15]=t,u[8]=n,u[10]=o||t&&t[10],u[11]=a||t&&t[11],u[12]=l||t&&t[12]||null,u[9]=c||t&&t[9]||null,u[6]=s,u[16]=2==e.type?t[16]:u,u}function Fs(t,e,n,r,i){let s=t.data[e];if(null===s)s=function(t,e,n,r,i){const s=pn(),o=mn(),a=t.data[e]=function(t,e,n,r,i,s){return{type:n,index:r,insertBeforeIndex:null,injectorIndex:e?e.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,propertyBindings:null,flags:0,providerIndexes:0,value:i,attrs:s,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:e,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,o?s:s&&s.parent,n,e,r,i);return null===t.firstChild&&(t.firstChild=a),null!==s&&(o?null==s.child&&null!==a.parent&&(s.child=a):null===s.next&&(s.next=a)),a}(t,e,n,r,i),an.lFrame.inI18n&&(s.flags|=64);else if(64&s.type){s.type=n,s.value=r,s.attrs=i;const t=function(){const t=an.lFrame,e=t.currentTNode;return t.isParent?e:e.parent}();s.injectorIndex=null===t?-1:t.injectorIndex}return fn(s,!0),s}function Ps(t,e,n,r){if(0===n)return-1;const i=e.length;for(let s=0;s<n;s++)e.push(r),t.blueprint.push(r),t.data.push(null);return i}function $s(t,e,n){Mn(e);try{const r=t.viewQuery;null!==r&&mo(1,r,n);const i=t.template;null!==i&&Vs(t,e,i,1,n),t.firstCreatePass&&(t.firstCreatePass=!1),t.staticContentQueries&&Ds(t,e),t.staticViewQueries&&mo(2,t.viewQuery,n);const s=t.components;null!==s&&function(t,e){for(let n=0;n<e.length;n++)co(t,e[n])}(e,s)}catch(r){throw t.firstCreatePass&&(t.incompleteFirstPass=!0),r}finally{e[2]&=-5,On()}}function Bs(t,e,n,r){const i=e[2];if(256==(256&i))return;Mn(e);const s=yn();try{sn(e),an.lFrame.bindingIndex=t.bindingStartIndex,null!==n&&Vs(t,e,n,2,r);const o=3==(3&i);if(!s)if(o){const n=t.preOrderCheckHooks;null!==n&&Bn(e,n,null)}else{const n=t.preOrderHooks;null!==n&&zn(e,n,0,null),Vn(e,0)}if(function(t){for(let e=Ui(t);null!==e;e=Hi(e)){if(!e[2])continue;const t=e[9];for(let e=0;e<t.length;e++){const n=t[e],r=n[3];0==(1024&n[2])&&on(r,1),n[2]|=1024}}}(e),function(t){for(let e=Ui(t);null!==e;e=Hi(e))for(let t=Te;t<e.length;t++){const n=e[t],r=n[1];nn(n)&&Bs(r,n,r.template,n[8])}}(e),null!==t.contentQueries&&Ds(t,e),!s)if(o){const n=t.contentCheckHooks;null!==n&&Bn(e,n)}else{const n=t.contentHooks;null!==n&&zn(e,n,1),Vn(e,1)}!function(t,e){const n=t.hostBindingOpCodes;if(null!==n)try{for(let t=0;t<n.length;t++){const r=n[t];if(r<0)Ln(~r);else{const i=r,s=n[++t],o=n[++t];xn(s,i),o(2,e[i])}}}finally{Ln(-1)}}(t,e);const a=t.components;null!==a&&function(t,e){for(let n=0;n<e.length;n++)ao(t,e[n])}(e,a);const l=t.viewQuery;if(null!==l&&mo(2,l,r),!s)if(o){const n=t.viewCheckHooks;null!==n&&Bn(e,n)}else{const n=t.viewHooks;null!==n&&zn(e,n,2),Vn(e,2)}!0===t.firstUpdatePass&&(t.firstUpdatePass=!1),s||(e[2]&=-73),1024&e[2]&&(e[2]&=-1025,on(e[3],-1))}finally{On()}}function zs(t,e,n,r){const i=e[10],s=!yn(),o=en(e);try{s&&!o&&i.begin&&i.begin(),o&&$s(t,e,r),Bs(t,e,n,r)}finally{s&&!o&&i.end&&i.end()}}function Vs(t,e,n,r,i){const s=Dn();try{Ln(-1),2&r&&e.length>Ce&&As(t,e,Ce,yn()),n(r,i)}finally{Ln(s)}}function Us(t,e,n){if(ke(e)){const r=e.directiveEnd;for(let i=e.directiveStart;i<r;i++){const e=t.data[i];e.contentQueries&&e.contentQueries(1,n[i],i)}}}function Hs(t,e,n){ln()&&(function(t,e,n,r){const i=n.directiveStart,s=n.directiveEnd;t.firstCreatePass||rr(n,e),Li(r,e);const o=n.initialInputs;for(let a=i;a<s;a++){const r=t.data[a],s=Ne(r);s&&ro(e,n,r);const l=mr(e,t,a,n);Li(l,e),null!==o&&io(0,a-i,l,r,0,o),s&&(Qe(n.index,e)[8]=l)}}(t,e,n,Ze(n,e)),128==(128&n.flags)&&function(t,e,n){const r=n.directiveStart,i=n.directiveEnd,s=n.index,o=an.lFrame.currentDirectiveIndex;try{Ln(s);for(let n=r;n<i;n++){const r=t.data[n],i=e[n];wn(n),null===r.hostBindings&&0===r.hostVars&&null===r.hostAttrs||Js(r,i)}}finally{Ln(-1),wn(o)}}(t,e,n))}function Ws(t,e,n=Ze){const r=e.localNames;if(null!==r){let i=e.index+1;for(let s=0;s<r.length;s+=2){const o=r[s+1],a=-1===o?n(e,t):t[o];t[i++]=a}}}function js(t){const e=t.tView;return null===e||e.incompleteFirstPass?t.tView=Gs(1,null,t.template,t.decls,t.vars,t.directiveDefs,t.pipeDefs,t.viewQuery,t.schemas,t.consts):e}function Gs(t,e,n,r,i,s,o,a,l,c){const u=Ce+r,h=u+i,d=function(t,e){const n=[];for(let r=0;r<e;r++)n.push(r<t?null:Cs);return n}(u,h),p="function"==typeof c?c():c;return d[1]={type:t,blueprint:d,template:n,queries:null,viewQuery:a,declTNode:e,data:d.slice().fill(null,u),bindingStartIndex:u,expandoStartIndex:h,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof s?s():s,pipeRegistry:"function"==typeof o?o():o,firstChild:null,schemas:l,consts:p,incompleteFirstPass:!1}}function qs(t,e,n,r){const i=yo(e);null===n?i.push(r):(i.push(n),t.firstCreatePass&&vo(t).push(r,i.length-1))}function Xs(t,e,n){for(let r in t)if(t.hasOwnProperty(r)){const i=t[r];(n=null===n?{}:n).hasOwnProperty(r)?n[r].push(e,i):n[r]=[e,i]}return n}function Ks(t,e,n,r,i,s,o,a){const l=Ze(e,n);let c,u=e.inputs;var h;!a&&null!=u&&(c=u[r])?(xo(t,n,c,r,i),Re(e)&&function(t,e){const n=Qe(e,t);16&n[2]||(n[2]|=64)}(n,e.index)):3&e.type&&(r="class"===(h=r)?"className":"for"===h?"htmlFor":"formaction"===h?"formAction":"innerHtml"===h?"innerHTML":"readonly"===h?"readOnly":"tabindex"===h?"tabIndex":h,i=null!=o?o(i,e.value||"",r):i,qe(s)?s.setProperty(l,r,i):Xn(r)||(l.setProperty?l.setProperty(r,i):l[r]=i))}function Ys(t,e,n,r){let i=!1;if(ln()){const s=function(t,e,n){const r=t.directiveRegistry;let i=null;if(r)for(let s=0;s<r.length;s++){const o=r[s];xs(n,o.selectors,!1)&&(i||(i=[]),ar(rr(n,e),t,o.type),Ne(o)?(Qs(t,n),i.unshift(o)):i.push(o))}return i}(t,e,n),o=null===r?null:{"":-1};if(null!==s){i=!0,eo(n,t.data.length,s.length);for(let t=0;t<s.length;t++){const e=s[t];e.providersResolver&&e.providersResolver(e)}let r=!1,a=!1,l=Ps(t,e,s.length,null);for(let i=0;i<s.length;i++){const c=s[i];n.mergedAttrs=Kn(n.mergedAttrs,c.hostAttrs),no(t,n,e,l,c),to(l,c,o),null!==c.contentQueries&&(n.flags|=8),null===c.hostBindings&&null===c.hostAttrs&&0===c.hostVars||(n.flags|=128);const u=c.type.prototype;!r&&(u.ngOnChanges||u.ngOnInit||u.ngDoCheck)&&((t.preOrderHooks||(t.preOrderHooks=[])).push(n.index),r=!0),a||!u.ngOnChanges&&!u.ngDoCheck||((t.preOrderCheckHooks||(t.preOrderCheckHooks=[])).push(n.index),a=!0),l++}!function(t,e){const n=e.directiveEnd,r=t.data,i=e.attrs,s=[];let o=null,a=null;for(let l=e.directiveStart;l<n;l++){const t=r[l],n=t.inputs,c=null===i||gs(e)?null:so(n,i);s.push(c),o=Xs(n,l,o),a=Xs(t.outputs,l,a)}null!==o&&(o.hasOwnProperty("class")&&(e.flags|=16),o.hasOwnProperty("style")&&(e.flags|=32)),e.initialInputs=s,e.inputs=o,e.outputs=a}(t,n)}o&&function(t,e,n){if(e){const r=t.localNames=[];for(let t=0;t<e.length;t+=2){const i=n[e[t+1]];if(null==i)throw new De("301",`Export of name '${e[t+1]}' not found!`);r.push(e[t],i)}}}(n,r,o)}return n.mergedAttrs=Kn(n.mergedAttrs,n.attrs),i}function Zs(t,e,n,r,i,s){const o=s.hostBindings;if(o){let n=t.hostBindingOpCodes;null===n&&(n=t.hostBindingOpCodes=[]);const s=~e.index;(function(t){let e=t.length;for(;e>0;){const n=t[--e];if("number"==typeof n&&n<0)return n}return 0})(n)!=s&&n.push(s),n.push(r,i,o)}}function Js(t,e){null!==t.hostBindings&&t.hostBindings(1,e)}function Qs(t,e){e.flags|=2,(t.components||(t.components=[])).push(e.index)}function to(t,e,n){if(n){if(e.exportAs)for(let r=0;r<e.exportAs.length;r++)n[e.exportAs[r]]=t;Ne(e)&&(n[""]=t)}}function eo(t,e,n){t.flags|=1,t.directiveStart=e,t.directiveEnd=e+n,t.providerIndexes=e}function no(t,e,n,r,i){t.data[r]=i;const s=i.factory||(i.factory=Oe(i.type)),o=new jn(s,Ne(i),null);t.blueprint[r]=o,n[r]=o,Zs(t,e,0,r,Ps(t,n,i.hostVars,Cs),i)}function ro(t,e,n){const r=Ze(e,t),i=js(n),s=t[10],o=uo(t,Ls(t,i,null,n.onPush?64:16,r,e,s,s.createRenderer(r,n),null,null));t[e.index]=o}function io(t,e,n,r,i,s){const o=s[e];if(null!==o){const t=r.setInput;for(let e=0;e<o.length;){const i=o[e++],s=o[e++],a=o[e++];null!==t?r.setInput(n,a,i,s):n[s]=a}}}function so(t,e){let n=null,r=0;for(;r<e.length;){const i=e[r];if(0!==i)if(5!==i){if("number"==typeof i)break;t.hasOwnProperty(i)&&(null===n&&(n=[]),n.push(i,t[i],e[r+1])),r+=2}else r+=2;else r+=4}return n}function oo(t,e,n,r){return new Array(t,!0,!1,e,null,0,r,n,null,null)}function ao(t,e){const n=Qe(e,t);if(nn(n)){const t=n[1];80&n[2]?Bs(t,n,t.template,n[8]):n[5]>0&&lo(n)}}function lo(t){for(let n=Ui(t);null!==n;n=Hi(n))for(let t=Te;t<n.length;t++){const e=n[t];if(1024&e[2]){const t=e[1];Bs(t,e,t.template,e[8])}else e[5]>0&&lo(e)}const e=t[1].components;if(null!==e)for(let n=0;n<e.length;n++){const r=Qe(e[n],t);nn(r)&&r[5]>0&&lo(r)}}function co(t,e){const n=Qe(e,t),r=n[1];!function(t,e){for(let n=e.length;n<t.blueprint.length;n++)e.push(t.blueprint[n])}(r,n),$s(r,n,n[8])}function uo(t,e){return t[13]?t[14][4]=e:t[13]=e,t[14]=e,e}function ho(t){for(;t;){t[2]|=64;const e=Vi(t);if(0!=(512&t[2])&&!e)return t;t=e}return null}function po(t,e,n){const r=e[10];r.begin&&r.begin();try{Bs(t,e,t.template,n)}catch(i){throw _o(e,i),i}finally{r.end&&r.end()}}function fo(t){!function(t){for(let e=0;e<t.components.length;e++){const n=t.components[e],r=tn(n),i=r[1];zs(i,r,i.template,n)}}(t[8])}function mo(t,e,n){Cn(0),e(t,n)}const go=(()=>Promise.resolve(null))();function yo(t){return t[7]||(t[7]=[])}function vo(t){return t.cleanup||(t.cleanup=[])}function bo(t,e,n){return(null===t||Ne(t))&&(n=function(t){for(;Array.isArray(t);){if("object"==typeof t[1])return t;t=t[0]}return null}(n[e.index])),n[11]}function _o(t,e){const n=t[9],r=n?n.get(Di,null):null;r&&r.handleError(e)}function xo(t,e,n,r,i){for(let s=0;s<n.length;){const o=n[s++],a=n[s++],l=e[o],c=t.data[o];null!==c.setInput?c.setInput(l,i,r,a):l[a]=i}}function wo(t,e,n){let r=n?t.styles:null,i=n?t.classes:null,s=0;if(null!==e)for(let o=0;o<e.length;o++){const t=e[o];"number"==typeof t?s=t:1==s?i=Nt(i,t):2==s&&(r=Nt(r,t+": "+e[++o]+";"))}n?t.styles=r:t.stylesWithoutHost=r,n?t.classes=i:t.classesWithoutHost=i}const So=new Er("INJECTOR",-1);class Eo{get(t,e=Or){if(e===Or){const e=new Error(`NullInjectorError: No provider for ${It(t)}!`);throw e.name="NullInjectorError",e}return e}}const Co=new Er("Set Injector scope."),To={},Ao={},Mo=[];let ko;function Ro(){return void 0===ko&&(ko=new Eo),ko}function Io(t,e=null,n=null,r){return new No(t,n,e||Ro(),r)}class No{constructor(t,e,n,r=null){this.parent=n,this.records=new Map,this.injectorDefTypes=new Set,this.onDestroy=new Set,this._destroyed=!1;const i=[];e&&Tr(e,n=>this.processProvider(n,t,e)),Tr([t],t=>this.processInjectorType(t,[],i)),this.records.set(So,Lo(void 0,this));const s=this.records.get(Co);this.scope=null!=s?s.value:null,this.source=r||("object"==typeof t?null:It(t))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{this.onDestroy.forEach(t=>t.ngOnDestroy())}finally{this.records.clear(),this.onDestroy.clear(),this.injectorDefTypes.clear()}}get(t,e=Or,n=qt.Default){this.assertNotDestroyed();const r=$r(this);try{if(!(n&qt.SkipSelf)){let e=this.records.get(t);if(void 0===e){const n=("function"==typeof(i=t)||"object"==typeof i&&i instanceof Er)&&zt(t);e=n&&this.injectableDefInScope(n)?Lo(Oo(t),To):null,this.records.set(t,e)}if(null!=e)return this.hydrate(t,e)}return(n&qt.Self?Ro():this.parent).get(t,e=n&qt.Optional&&e===Or?null:e)}catch(s){if("NullInjectorError"===s.name){if((s.ngTempTokenPath=s.ngTempTokenPath||[]).unshift(It(t)),r)throw s;return function(t,e,n,r){const i=t.ngTempTokenPath;throw e[Lr]&&i.unshift(e[Lr]),t.message=function(t,e,n,r=null){t=t&&"\n"===t.charAt(0)&&"\u0275"==t.charAt(1)?t.substr(2):t;let i=It(e);if(Array.isArray(e))i=e.map(It).join(" -> ");else if("object"==typeof e){let t=[];for(let n in e)if(e.hasOwnProperty(n)){let r=e[n];t.push(n+":"+("string"==typeof r?JSON.stringify(r):It(r)))}i=`{${t.join(", ")}}`}return`${n}${r?"("+r+")":""}[${i}]: ${t.replace(Dr,"\n  ")}`}("\n"+t.message,i,n,r),t.ngTokenPath=i,t.ngTempTokenPath=null,t}(s,t,"R3InjectorError",this.source)}throw s}finally{$r(r)}var i}_resolveInjectorDefTypes(){this.injectorDefTypes.forEach(t=>this.get(t))}toString(){const t=[];return this.records.forEach((e,n)=>t.push(It(n))),`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Error("Injector has already been destroyed.")}processInjectorType(t,e,n){if(!(t=Lt(t)))return!1;let r=Ut(t);const i=null==r&&t.ngModule||void 0,s=void 0===i?t:i,o=-1!==n.indexOf(s);if(void 0!==i&&(r=Ut(i)),null==r)return!1;if(null!=r.imports&&!o){let t;n.push(s);try{Tr(r.imports,r=>{this.processInjectorType(r,e,n)&&(void 0===t&&(t=[]),t.push(r))})}finally{}if(void 0!==t)for(let e=0;e<t.length;e++){const{ngModule:n,providers:r}=t[e];Tr(r,t=>this.processProvider(t,n,r||Mo))}}this.injectorDefTypes.add(s),this.records.set(s,Lo(r.factory,To));const a=r.providers;if(null!=a&&!o){const e=t;Tr(a,t=>this.processProvider(t,e,a))}return void 0!==i&&void 0!==t.providers}processProvider(t,e,n){let r=Po(t=Lt(t))?t:Lt(t&&t.provide);const i=function(t,e,n){return Fo(t)?Lo(void 0,t.useValue):Lo(Do(t),To)}(t);if(Po(t)||!0!==t.multi)this.records.get(r);else{let e=this.records.get(r);e||(e=Lo(void 0,To,!0),e.factory=()=>Ur(e.multi),this.records.set(r,e)),r=t,e.multi.push(t)}this.records.set(r,i)}hydrate(t,e){var n;return e.value===To&&(e.value=Ao,e.value=e.factory()),"object"==typeof e.value&&e.value&&null!==(n=e.value)&&"object"==typeof n&&"function"==typeof n.ngOnDestroy&&this.onDestroy.add(e.value),e.value}injectableDefInScope(t){return!!t.providedIn&&("string"==typeof t.providedIn?"any"===t.providedIn||t.providedIn===this.scope:this.injectorDefTypes.has(t.providedIn))}}function Oo(t){const e=zt(t),n=null!==e?e.factory:Oe(t);if(null!==n)return n;const r=Ut(t);if(null!==r)return r.factory;if(t instanceof Er)throw new Error(`Token ${It(t)} is missing a \u0275prov definition.`);if(t instanceof Function)return function(t){const e=t.length;if(e>0){const n=kr(e,"?");throw new Error(`Can't resolve all parameters for ${It(t)}: (${n.join(", ")}).`)}const n=function(t){const e=t&&(t[Ht]||t[jt]);if(e){const n=function(t){if(t.hasOwnProperty("name"))return t.name;const e=(""+t).match(/^function\s*([^\s(]+)/);return null===e?"":e[1]}(t);return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`),e}return null}(t);return null!==n?()=>n.factory(t):()=>new t}(t);throw new Error("unreachable")}function Do(t,e,n){let r;if(Po(t)){const e=Lt(t);return Oe(e)||Oo(e)}if(Fo(t))r=()=>Lt(t.useValue);else if((i=t)&&i.useFactory)r=()=>t.useFactory(...Ur(t.deps||[]));else if(function(t){return!(!t||!t.useExisting)}(t))r=()=>zr(Lt(t.useExisting));else{const e=Lt(t&&(t.useClass||t.provide));if(!function(t){return!!t.deps}(t))return Oe(e)||Oo(e);r=()=>new e(...Ur(t.deps))}var i;return r}function Lo(t,e,n=!1){return{factory:t,value:e,multi:n?[]:void 0}}function Fo(t){return null!==t&&"object"==typeof t&&Fr in t}function Po(t){return"function"==typeof t}const $o=function(t,e,n){return function(t,e=null,n=null,r){const i=Io(t,e,n,r);return i._resolveInjectorDefTypes(),i}({name:n},e,t,n)};let Bo=(()=>{class t{static create(t,e){return Array.isArray(t)?$o(t,e,""):$o(t.providers,t.parent,t.name||"")}}return t.THROW_IF_NOT_FOUND=Or,t.NULL=new Eo,t.\u0275prov=Pt({token:t,providedIn:"any",factory:()=>zr(So)}),t.__NG_ELEMENT_ID__=-1,t})();function zo(t,e){$n(tn(t)[1],dn())}function Vo(t){let e=Object.getPrototypeOf(t.type.prototype).constructor,n=!0;const r=[t];for(;e;){let i;if(Ne(t))i=e.\u0275cmp||e.\u0275dir;else{if(e.\u0275cmp)throw new Error("Directives cannot inherit Components");i=e.\u0275dir}if(i){if(n){r.push(i);const e=t;e.inputs=Uo(t.inputs),e.declaredInputs=Uo(t.declaredInputs),e.outputs=Uo(t.outputs);const n=i.hostBindings;n&&jo(t,n);const s=i.viewQuery,o=i.contentQueries;if(s&&Ho(t,s),o&&Wo(t,o),Rt(t.inputs,i.inputs),Rt(t.declaredInputs,i.declaredInputs),Rt(t.outputs,i.outputs),Ne(i)&&i.data.animation){const e=t.data;e.animation=(e.animation||[]).concat(i.data.animation)}}const e=i.features;if(e)for(let r=0;r<e.length;r++){const i=e[r];i&&i.ngInherit&&i(t),i===Vo&&(n=!1)}}e=Object.getPrototypeOf(e)}!function(t){let e=0,n=null;for(let r=t.length-1;r>=0;r--){const i=t[r];i.hostVars=e+=i.hostVars,i.hostAttrs=Kn(i.hostAttrs,n=Kn(n,i.hostAttrs))}}(r)}function Uo(t){return t===se?{}:t===oe?[]:t}function Ho(t,e){const n=t.viewQuery;t.viewQuery=n?(t,r)=>{e(t,r),n(t,r)}:e}function Wo(t,e){const n=t.contentQueries;t.contentQueries=n?(t,r,i)=>{e(t,r,i),n(t,r,i)}:e}function jo(t,e){const n=t.hostBindings;t.hostBindings=n?(t,r)=>{e(t,r),n(t,r)}:e}let Go=null;function qo(){if(!Go){const t=ie.Symbol;if(t&&t.iterator)Go=t.iterator;else{const t=Object.getOwnPropertyNames(Map.prototype);for(let e=0;e<t.length;++e){const n=t[e];"entries"!==n&&"size"!==n&&Map.prototype[n]===Map.prototype.entries&&(Go=n)}}}return Go}class Xo{constructor(t){this.wrapped=t}static wrap(t){return new Xo(t)}static unwrap(t){return Xo.isWrapped(t)?t.wrapped:t}static isWrapped(t){return t instanceof Xo}}function Ko(t){return!!Yo(t)&&(Array.isArray(t)||!(t instanceof Map)&&qo()in t)}function Yo(t){return null!==t&&("function"==typeof t||"object"==typeof t)}function Zo(t,e,n){return!Object.is(t[e],n)&&(t[e]=n,!0)}function Jo(t,e,n,r){const i=cn();return Zo(i,bn(),e)&&(un(),function(t,e,n,r,i,s){const o=Ze(t,e);!function(t,e,n,r,i,s,o){if(null==s)qe(t)?t.removeAttribute(e,i,n):e.removeAttribute(i);else{const a=null==o?Le(s):o(s,r||"",i);qe(t)?t.setAttribute(e,i,a,n):n?e.setAttributeNS(n,i,a):e.setAttribute(i,a)}}(e[11],o,s,t.value,n,r,i)}(Fn(),i,t,e,n,r)),Jo}function Qo(t,e,n,r,i,s,o,a){const l=cn(),c=un(),u=t+Ce,h=c.firstCreatePass?function(t,e,n,r,i,s,o,a,l){const c=e.consts,u=Fs(e,t,4,o||null,rn(c,a));Ys(e,n,u,rn(c,l)),$n(e,u);const h=u.tViews=Gs(2,u,r,i,s,e.directiveRegistry,e.pipeRegistry,null,e.schemas,c);return null!==e.queries&&(e.queries.template(e,u),h.queries=e.queries.embeddedTView(u)),u}(u,c,l,e,n,r,i,s,o):c.data[u];fn(h,!1);const d=l[11].createComment("");is(c,l,d,h),Li(d,l),uo(l,l[u]=oo(d,l,d,h)),Ie(h)&&Hs(c,l,h),null!=o&&Ws(l,h,a)}function ta(t,e=qt.Default){const n=cn();return null===n?zr(t,e):ur(dn(),n,Lt(t),e)}function ea(t,e,n){const r=cn();return Zo(r,bn(),e)&&Ks(un(),Fn(),r,t,e,r[11],n,!1),ea}function na(t,e,n,r,i){const s=i?"class":"style";xo(t,n,e.inputs[s],s,r)}function ra(t,e,n,r){const i=cn(),s=un(),o=Ce+t,a=i[11],l=i[o]=Gi(a,e,an.lFrame.currentNamespace),c=s.firstCreatePass?function(t,e,n,r,i,s,o){const a=e.consts,l=Fs(e,t,2,i,rn(a,s));return Ys(e,n,l,rn(a,o)),null!==l.attrs&&wo(l,l.attrs,!1),null!==l.mergedAttrs&&wo(l,l.mergedAttrs,!0),null!==e.queries&&e.queries.elementStart(e,l),l}(o,s,i,0,e,n,r):s.data[o];fn(c,!0);const u=c.mergedAttrs;null!==u&&Gn(a,l,u);const h=c.classes;null!==h&&ds(a,l,h);const d=c.styles;null!==d&&hs(a,l,d),64!=(64&c.flags)&&is(s,i,l,c),0===an.lFrame.elementDepthCount&&Li(l,i),an.lFrame.elementDepthCount++,Ie(c)&&(Hs(s,i,c),Us(s,c,i)),null!==r&&Ws(i,c)}function ia(){let t=dn();mn()?gn():(t=t.parent,fn(t,!1));const e=t;an.lFrame.elementDepthCount--;const n=un();n.firstCreatePass&&($n(n,t),ke(t)&&n.queries.elementEnd(t)),null!=e.classesWithoutHost&&function(t){return 0!=(16&t.flags)}(e)&&na(n,e,cn(),e.classesWithoutHost,!0),null!=e.stylesWithoutHost&&function(t){return 0!=(32&t.flags)}(e)&&na(n,e,cn(),e.stylesWithoutHost,!1)}function sa(t,e,n,r){ra(t,e,n,r),ia()}function oa(t,e,n){const r=cn(),i=un(),s=t+Ce,o=i.firstCreatePass?function(t,e,n,r,i){const s=e.consts,o=rn(s,r),a=Fs(e,t,8,"ng-container",o);return null!==o&&wo(a,o,!0),Ys(e,n,a,rn(s,i)),null!==e.queries&&e.queries.elementStart(e,a),a}(s,i,r,e,n):i.data[s];fn(o,!0);const a=r[s]=r[11].createComment("");is(i,r,a,o),Li(a,r),Ie(o)&&(Hs(i,r,o),Us(i,o,r)),null!=n&&Ws(r,o)}function aa(){let t=dn();const e=un();mn()?gn():(t=t.parent,fn(t,!1)),e.firstCreatePass&&($n(e,t),ke(t)&&e.queries.elementEnd(t))}function la(){return cn()}function ca(t){return!!t&&"function"==typeof t.then}function ua(t){return!!t&&"function"==typeof t.subscribe}const ha=ua;function da(t,e,n=!1,r){const i=cn(),s=un(),o=dn();return fa(s,i,i[11],o,t,e,n,r),da}function pa(t,e,n=!1,r){const i=dn(),s=cn(),o=un();return fa(o,s,bo(Sn(o.data),i,s),i,t,e,n,r),pa}function fa(t,e,n,r,i,s,o=!1,a){const l=Ie(r),c=t.firstCreatePass&&vo(t),u=yo(e);let h=!0;if(3&r.type){const d=Ze(r,e),p=a?a(d):se,f=p.target||d,m=u.length,g=a?t=>a(Ke(t[r.index])).target:r.index;if(qe(n)){let o=null;if(!a&&l&&(o=function(t,e,n,r){const i=t.cleanup;if(null!=i)for(let s=0;s<i.length-1;s+=2){const t=i[s];if(t===n&&i[s+1]===r){const t=e[7],n=i[s+2];return t.length>n?t[n]:null}"string"==typeof t&&(s+=2)}return null}(t,e,i,r.index)),null!==o)(o.__ngLastListenerFn__||o).__ngNextListenerFn__=s,o.__ngLastListenerFn__=s,h=!1;else{s=ga(r,e,s,!1);const t=n.listen(p.name||f,i,s);u.push(s,t),c&&c.push(i,g,m,m+1)}}else s=ga(r,e,s,!0),f.addEventListener(i,s,o),u.push(s),c&&c.push(i,g,m,o)}else s=ga(r,e,s,!1);const d=r.outputs;let p;if(h&&null!==d&&(p=d[i])){const t=p.length;if(t)for(let n=0;n<t;n+=2){const t=e[p[n]][p[n+1]].subscribe(s),o=u.length;u.push(s,t),c&&c.push(i,r.index,o,-(o+1))}}}function ma(t,e,n){try{return!1!==e(n)}catch(r){return _o(t,r),!1}}function ga(t,e,n,r){return function i(s){if(s===Function)return n;const o=2&t.flags?Qe(t.index,e):e;0==(32&e[2])&&ho(o);let a=ma(e,n,s),l=i.__ngNextListenerFn__;for(;l;)a=ma(e,l,s)&&a,l=l.__ngNextListenerFn__;return r&&!1===a&&(s.preventDefault(),s.returnValue=!1),a}}function ya(t=1){return function(t){return(an.lFrame.contextLView=function(t,e){for(;t>0;)e=e[15],t--;return e}(t,an.lFrame.contextLView))[8]}(t)}function va(t,e){let n=null;const r=function(t){const e=t.attrs;if(null!=e){const t=e.indexOf(5);if(0==(1&t))return e[t+1]}return null}(t);for(let i=0;i<e.length;i++){const s=e[i];if("*"!==s){if(null===r?xs(t,s,!0):ws(r,s))return i}else n=i}return n}function ba(t){const e=cn()[16][6];if(!e.projection){const n=e.projection=kr(t?t.length:1,null),r=n.slice();let i=e.child;for(;null!==i;){const e=t?va(i,t):0;null!==e&&(r[e]?r[e].projectionNext=i:n[e]=i,r[e]=i),i=i.next}}}function _a(t,e=0,n){const r=cn(),i=un(),s=Fs(i,Ce+t,16,null,n||null);null===s.projection&&(s.projection=e),gn(),64!=(64&s.flags)&&function(t,e,n){us(e[11],0,e,n,Zi(t,n,e),ns(n.parent||e[6],n,e))}(i,r,s)}const xa=[];function wa(t,e,n,r,i){const s=t[n+1],o=null===e;let a=r?ks(s):Is(s),l=!1;for(;0!==a&&(!1===l||o);){const n=t[a+1];Sa(t[a],e)&&(l=!0,t[a+1]=r?Os(n):Rs(n)),a=r?ks(n):Is(n)}l&&(t[n+1]=r?Rs(s):Os(s))}function Sa(t,e){return null===t||null==e||(Array.isArray(t)?t[1]:t)===e||!(!Array.isArray(t)||"string"!=typeof e)&&Nr(t,e)>=0}const Ea={textEnd:0,key:0,keyEnd:0,value:0,valueEnd:0};function Ca(t){return t.substring(Ea.key,Ea.keyEnd)}function Ta(t,e){const n=Ea.textEnd;return n===e?-1:(e=Ea.keyEnd=function(t,e,n){for(;e<n&&t.charCodeAt(e)>32;)e++;return e}(t,Ea.key=e,n),Aa(t,e,n))}function Aa(t,e,n){for(;e<n&&t.charCodeAt(e)<=32;)e++;return e}function Ma(t,e,n){return Ia(t,e,n,!1),Ma}function ka(t,e){return Ia(t,e,null,!0),ka}function Ra(t,e){for(let n=function(t){return function(t){Ea.key=0,Ea.keyEnd=0,Ea.value=0,Ea.valueEnd=0,Ea.textEnd=t.length}(t),Ta(t,Aa(t,0,Ea.textEnd))}(e);n>=0;n=Ta(e,n))Rr(t,Ca(e),!0)}function Ia(t,e,n,r){const i=cn(),s=un(),o=_n(2);s.firstUpdatePass&&Oa(s,t,o,r),e!==Cs&&Zo(i,o,e)&&Fa(s,s.data[Dn()],i,i[11],t,i[o+1]=function(t,e){return null==t||("string"==typeof e?t+=e:"object"==typeof t&&(t=It(ri(t)))),t}(e,n),r,o)}function Na(t,e){return e>=t.expandoStartIndex}function Oa(t,e,n,r){const i=t.data;if(null===i[n+1]){const s=i[Dn()],o=Na(t,n);Ba(s,r)&&null===e&&!o&&(e=!1),e=function(t,e,n,r){const i=Sn(t);let s=r?e.residualClasses:e.residualStyles;if(null===i)0===(r?e.classBindings:e.styleBindings)&&(n=La(n=Da(null,t,e,n,r),e.attrs,r),s=null);else{const o=e.directiveStylingLast;if(-1===o||t[o]!==i)if(n=Da(i,t,e,n,r),null===s){let n=function(t,e,n){const r=n?e.classBindings:e.styleBindings;if(0!==Is(r))return t[ks(r)]}(t,e,r);void 0!==n&&Array.isArray(n)&&(n=Da(null,t,e,n[1],r),n=La(n,e.attrs,r),function(t,e,n,r){t[ks(n?e.classBindings:e.styleBindings)]=r}(t,e,r,n))}else s=function(t,e,n){let r;const i=e.directiveEnd;for(let s=1+e.directiveStylingLast;s<i;s++)r=La(r,t[s].hostAttrs,n);return La(r,e.attrs,n)}(t,e,r)}return void 0!==s&&(r?e.residualClasses=s:e.residualStyles=s),n}(i,s,e,r),function(t,e,n,r,i,s){let o=s?e.classBindings:e.styleBindings,a=ks(o),l=Is(o);t[r]=n;let c,u=!1;if(Array.isArray(n)){const t=n;c=t[1],(null===c||Nr(t,c)>0)&&(u=!0)}else c=n;if(i)if(0!==l){const e=ks(t[a+1]);t[r+1]=Ms(e,a),0!==e&&(t[e+1]=Ns(t[e+1],r)),t[a+1]=131071&t[a+1]|r<<17}else t[r+1]=Ms(a,0),0!==a&&(t[a+1]=Ns(t[a+1],r)),a=r;else t[r+1]=Ms(l,0),0===a?a=r:t[l+1]=Ns(t[l+1],r),l=r;u&&(t[r+1]=Rs(t[r+1])),wa(t,c,r,!0),wa(t,c,r,!1),function(t,e,n,r,i){const s=i?t.residualClasses:t.residualStyles;null!=s&&"string"==typeof e&&Nr(s,e)>=0&&(n[r+1]=Os(n[r+1]))}(e,c,t,r,s),o=Ms(a,l),s?e.classBindings=o:e.styleBindings=o}(i,s,e,n,o,r)}}function Da(t,e,n,r,i){let s=null;const o=n.directiveEnd;let a=n.directiveStylingLast;for(-1===a?a=n.directiveStart:a++;a<o&&(s=e[a],r=La(r,s.hostAttrs,i),s!==t);)a++;return null!==t&&(n.directiveStylingLast=a),r}function La(t,e,n){const r=n?1:2;let i=-1;if(null!==e)for(let s=0;s<e.length;s++){const o=e[s];"number"==typeof o?i=o:i===r&&(Array.isArray(t)||(t=void 0===t?[]:["",t]),Rr(t,o,!!n||e[++s]))}return void 0===t?null:t}function Fa(t,e,n,r,i,s,o,a){if(!(3&e.type))return;const l=t.data,c=l[a+1];$a(1==(1&c)?Pa(l,e,n,i,Is(c),o):void 0)||($a(s)||2==(2&c)&&(s=Pa(l,null,n,i,a,o)),function(t,e,n,r,i){const s=qe(t);if(e)i?s?t.addClass(n,r):n.classList.add(r):s?t.removeClass(n,r):n.classList.remove(r);else{let e=-1===r.indexOf("-")?void 0:Bi.DashCase;if(null==i)s?t.removeStyle(n,r,e):n.style.removeProperty(r);else{const o="string"==typeof i&&i.endsWith("!important");o&&(i=i.slice(0,-10),e|=Bi.Important),s?t.setStyle(n,r,i,e):n.style.setProperty(r,i,o?"important":"")}}}(r,o,Ye(Dn(),n),i,s))}function Pa(t,e,n,r,i,s){const o=null===e;let a;for(;i>0;){const e=t[i],s=Array.isArray(e),l=s?e[1]:e,c=null===l;let u=n[i+1];u===Cs&&(u=c?xa:void 0);let h=c?Ir(u,r):l===r?u:void 0;if(s&&!$a(h)&&(h=Ir(e,r)),$a(h)&&(a=h,o))return a;const d=t[i+1];i=o?ks(d):Is(d)}if(null!==e){let t=s?e.residualClasses:e.residualStyles;null!=t&&(a=Ir(t,r))}return a}function $a(t){return void 0!==t}function Ba(t,e){return 0!=(t.flags&(e?16:32))}function za(t,e=""){const n=cn(),r=un(),i=t+Ce,s=r.firstCreatePass?Fs(r,i,1,e,null):r.data[i],o=n[i]=function(t,e){return qe(t)?t.createText(e):t.createTextNode(e)}(n[11],e);is(r,n,o,s),fn(s,!1)}function Va(t){return Ua("",t,""),Va}function Ua(t,e,n){const r=cn(),i=function(t,e,n,r){return Zo(t,bn(),n)?e+Le(n)+r:Cs}(r,t,e,n);return i!==Cs&&function(t,e,n){const r=Ye(e,t);!function(t,e,n){qe(t)?t.setValue(e,n):e.textContent=n}(t[11],r,n)}(r,Dn(),i),Ua}function Ha(t,e,n){const r=cn();if(Zo(r,bn(),e)){const i=un(),s=Fn();Ks(i,s,r,t,e,bo(Sn(i.data),s,r),n,!0)}return Ha}const Wa=void 0;var ja=["en",[["a","p"],["AM","PM"],Wa],[["AM","PM"],Wa,Wa],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],Wa,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],Wa,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",Wa,"{1} 'at' {0}",Wa],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function(t){let e=Math.floor(Math.abs(t)),n=t.toString().replace(/^[^.]*\.?/,"").length;return 1===e&&0===n?1:5}];let Ga={};function qa(t){return t in Ga||(Ga[t]=ie.ng&&ie.ng.common&&ie.ng.common.locales&&ie.ng.common.locales[t]),Ga[t]}var Xa=function(t){return t[t.LocaleId=0]="LocaleId",t[t.DayPeriodsFormat=1]="DayPeriodsFormat",t[t.DayPeriodsStandalone=2]="DayPeriodsStandalone",t[t.DaysFormat=3]="DaysFormat",t[t.DaysStandalone=4]="DaysStandalone",t[t.MonthsFormat=5]="MonthsFormat",t[t.MonthsStandalone=6]="MonthsStandalone",t[t.Eras=7]="Eras",t[t.FirstDayOfWeek=8]="FirstDayOfWeek",t[t.WeekendRange=9]="WeekendRange",t[t.DateFormat=10]="DateFormat",t[t.TimeFormat=11]="TimeFormat",t[t.DateTimeFormat=12]="DateTimeFormat",t[t.NumberSymbols=13]="NumberSymbols",t[t.NumberFormats=14]="NumberFormats",t[t.CurrencyCode=15]="CurrencyCode",t[t.CurrencySymbol=16]="CurrencySymbol",t[t.CurrencyName=17]="CurrencyName",t[t.Currencies=18]="Currencies",t[t.Directionality=19]="Directionality",t[t.PluralCase=20]="PluralCase",t[t.ExtraData=21]="ExtraData",t}({});const Ka="en-US";let Ya=Ka;function Za(t){var e,n;n="Expected localeId to be defined",null==(e=t)&&function(t,e,n,r){throw new Error(`ASSERTION ERROR: ${t} [Expected=> null != ${e} <=Actual]`)}(n,e),"string"==typeof t&&(Ya=t.toLowerCase().replace(/_/g,"-"))}function Ja(t,e,n,r,i){if(t=Lt(t),Array.isArray(t))for(let s=0;s<t.length;s++)Ja(t[s],e,n,r,i);else{const s=un(),o=cn();let a=Po(t)?t:Lt(t.provide),l=Do(t);const c=dn(),u=1048575&c.providerIndexes,h=c.directiveStart,d=c.providerIndexes>>20;if(Po(t)||!t.multi){const r=new jn(l,i,ta),p=el(a,e,i?u:u+d,h);-1===p?(ar(rr(c,o),s,a),Qa(s,t,e.length),e.push(a),c.directiveStart++,c.directiveEnd++,i&&(c.providerIndexes+=1048576),n.push(r),o.push(r)):(n[p]=r,o[p]=r)}else{const p=el(a,e,u+d,h),f=el(a,e,u,u+d),m=p>=0&&n[p],g=f>=0&&n[f];if(i&&!g||!i&&!m){ar(rr(c,o),s,a);const u=function(t,e,n,r,i){const s=new jn(t,n,ta);return s.multi=[],s.index=e,s.componentProviders=0,tl(s,i,r&&!n),s}(i?rl:nl,n.length,i,r,l);!i&&g&&(n[f].providerFactory=u),Qa(s,t,e.length,0),e.push(a),c.directiveStart++,c.directiveEnd++,i&&(c.providerIndexes+=1048576),n.push(u),o.push(u)}else Qa(s,t,p>-1?p:f,tl(n[i?f:p],l,!i&&r));!i&&r&&g&&n[f].componentProviders++}}}function Qa(t,e,n,r){const i=Po(e);if(i||e.useClass){const s=(e.useClass||e).prototype.ngOnDestroy;if(s){const o=t.destroyHooks||(t.destroyHooks=[]);if(!i&&e.multi){const t=o.indexOf(n);-1===t?o.push(n,[r,s]):o[t+1].push(r,s)}else o.push(n,s)}}}function tl(t,e,n){return n&&t.componentProviders++,t.multi.push(e)-1}function el(t,e,n,r){for(let i=n;i<r;i++)if(e[i]===t)return i;return-1}function nl(t,e,n,r){return il(this.multi,[])}function rl(t,e,n,r){const i=this.multi;let s;if(this.providerFactory){const t=this.providerFactory.componentProviders,e=mr(n,n[1],this.providerFactory.index,r);s=e.slice(0,t),il(i,s);for(let n=t;n<e.length;n++)s.push(e[n])}else s=[],il(i,s);return s}function il(t,e){for(let n=0;n<t.length;n++)e.push((0,t[n])());return e}function sl(t,e=[]){return n=>{n.providersResolver=(n,r)=>function(t,e,n){const r=un();if(r.firstCreatePass){const i=Ne(t);Ja(n,r.data,r.blueprint,i,!0),Ja(e,r.data,r.blueprint,i,!1)}}(n,r?r(t):t,e)}}class ol{}class al{resolveComponentFactory(t){throw function(t){const e=Error(`No component factory found for ${It(t)}. Did you add it to @NgModule.entryComponents?`);return e.ngComponent=t,e}(t)}}let ll=(()=>{class t{}return t.NULL=new al,t})();function cl(...t){}function ul(t,e){return new dl(Ze(t,e))}const hl=function(){return ul(dn(),cn())};let dl=(()=>{class t{constructor(t){this.nativeElement=t}}return t.__NG_ELEMENT_ID__=hl,t})();function pl(t){return t instanceof dl?t.nativeElement:t}class fl{}let ml=(()=>{class t{}return t.__NG_ELEMENT_ID__=()=>gl(),t})();const gl=function(){const t=cn(),e=Qe(dn().index,t);return function(t){return t[11]}(Ae(e)?e:t)};let yl=(()=>{class t{}return t.\u0275prov=Pt({token:t,providedIn:"root",factory:()=>null}),t})();class vl{constructor(t){this.full=t,this.major=t.split(".")[0],this.minor=t.split(".")[1],this.patch=t.split(".").slice(2).join(".")}}const bl=new vl("11.2.1");class _l{constructor(){}supports(t){return Ko(t)}create(t){return new wl(t)}}const xl=(t,e)=>e;class wl{constructor(t){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=t||xl}forEachItem(t){let e;for(e=this._itHead;null!==e;e=e._next)t(e)}forEachOperation(t){let e=this._itHead,n=this._removalsHead,r=0,i=null;for(;e||n;){const s=!n||e&&e.currentIndex<Tl(n,r,i)?e:n,o=Tl(s,r,i),a=s.currentIndex;if(s===n)r--,n=n._nextRemoved;else if(e=e._next,null==s.previousIndex)r++;else{i||(i=[]);const t=o-r,e=a-r;if(t!=e){for(let n=0;n<t;n++){const r=n<i.length?i[n]:i[n]=0,s=r+n;e<=s&&s<t&&(i[n]=r+1)}i[s.previousIndex]=e-t}}o!==a&&t(s,o,a)}}forEachPreviousItem(t){let e;for(e=this._previousItHead;null!==e;e=e._nextPrevious)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachMovedItem(t){let e;for(e=this._movesHead;null!==e;e=e._nextMoved)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}forEachIdentityChange(t){let e;for(e=this._identityChangesHead;null!==e;e=e._nextIdentityChange)t(e)}diff(t){if(null==t&&(t=[]),!Ko(t))throw new Error(`Error trying to diff '${It(t)}'. Only arrays and iterables are allowed`);return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e,n,r,i=this._itHead,s=!1;if(Array.isArray(t)){this.length=t.length;for(let e=0;e<this.length;e++)n=t[e],r=this._trackByFn(e,n),null!==i&&Object.is(i.trackById,r)?(s&&(i=this._verifyReinsertion(i,n,r,e)),Object.is(i.item,n)||this._addIdentityChange(i,n)):(i=this._mismatch(i,n,r,e),s=!0),i=i._next}else e=0,function(t,e){if(Array.isArray(t))for(let n=0;n<t.length;n++)e(t[n]);else{const n=t[qo()]();let r;for(;!(r=n.next()).done;)e(r.value)}}(t,t=>{r=this._trackByFn(e,t),null!==i&&Object.is(i.trackById,r)?(s&&(i=this._verifyReinsertion(i,t,r,e)),Object.is(i.item,t)||this._addIdentityChange(i,t)):(i=this._mismatch(i,t,r,e),s=!0),i=i._next,e++}),this.length=e;return this._truncate(i),this.collection=t,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let t;for(t=this._previousItHead=this._itHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._additionsHead;null!==t;t=t._nextAdded)t.previousIndex=t.currentIndex;for(this._additionsHead=this._additionsTail=null,t=this._movesHead;null!==t;t=t._nextMoved)t.previousIndex=t.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(t,e,n,r){let i;return null===t?i=this._itTail:(i=t._prev,this._remove(t)),null!==(t=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._reinsertAfter(t,i,r)):null!==(t=null===this._linkedRecords?null:this._linkedRecords.get(n,r))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._moveAfter(t,i,r)):t=this._addAfter(new Sl(e,n),i,r),t}_verifyReinsertion(t,e,n,r){let i=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null);return null!==i?t=this._reinsertAfter(i,t._prev,r):t.currentIndex!=r&&(t.currentIndex=r,this._addToMoves(t,r)),t}_truncate(t){for(;null!==t;){const e=t._next;this._addToRemovals(this._unlink(t)),t=e}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(t,e,n){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(t);const r=t._prevRemoved,i=t._nextRemoved;return null===r?this._removalsHead=i:r._nextRemoved=i,null===i?this._removalsTail=r:i._prevRemoved=r,this._insertAfter(t,e,n),this._addToMoves(t,n),t}_moveAfter(t,e,n){return this._unlink(t),this._insertAfter(t,e,n),this._addToMoves(t,n),t}_addAfter(t,e,n){return this._insertAfter(t,e,n),this._additionsTail=null===this._additionsTail?this._additionsHead=t:this._additionsTail._nextAdded=t,t}_insertAfter(t,e,n){const r=null===e?this._itHead:e._next;return t._next=r,t._prev=e,null===r?this._itTail=t:r._prev=t,null===e?this._itHead=t:e._next=t,null===this._linkedRecords&&(this._linkedRecords=new Cl),this._linkedRecords.put(t),t.currentIndex=n,t}_remove(t){return this._addToRemovals(this._unlink(t))}_unlink(t){null!==this._linkedRecords&&this._linkedRecords.remove(t);const e=t._prev,n=t._next;return null===e?this._itHead=n:e._next=n,null===n?this._itTail=e:n._prev=e,t}_addToMoves(t,e){return t.previousIndex===e||(this._movesTail=null===this._movesTail?this._movesHead=t:this._movesTail._nextMoved=t),t}_addToRemovals(t){return null===this._unlinkedRecords&&(this._unlinkedRecords=new Cl),this._unlinkedRecords.put(t),t.currentIndex=null,t._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=t,t._prevRemoved=null):(t._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=t),t}_addIdentityChange(t,e){return t.item=e,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=t:this._identityChangesTail._nextIdentityChange=t,t}}class Sl{constructor(t,e){this.item=t,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class El{constructor(){this._head=null,this._tail=null}add(t){null===this._head?(this._head=this._tail=t,t._nextDup=null,t._prevDup=null):(this._tail._nextDup=t,t._prevDup=this._tail,t._nextDup=null,this._tail=t)}get(t,e){let n;for(n=this._head;null!==n;n=n._nextDup)if((null===e||e<=n.currentIndex)&&Object.is(n.trackById,t))return n;return null}remove(t){const e=t._prevDup,n=t._nextDup;return null===e?this._head=n:e._nextDup=n,null===n?this._tail=e:n._prevDup=e,null===this._head}}class Cl{constructor(){this.map=new Map}put(t){const e=t.trackById;let n=this.map.get(e);n||(n=new El,this.map.set(e,n)),n.add(t)}get(t,e){const n=this.map.get(t);return n?n.get(t,e):null}remove(t){const e=t.trackById;return this.map.get(e).remove(t)&&this.map.delete(e),t}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function Tl(t,e,n){const r=t.previousIndex;if(null===r)return r;let i=0;return n&&r<n.length&&(i=n[r]),r+e+i}class Al{constructor(){}supports(t){return t instanceof Map||Yo(t)}create(){return new Ml}}class Ml{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(t){let e;for(e=this._mapHead;null!==e;e=e._next)t(e)}forEachPreviousItem(t){let e;for(e=this._previousMapHead;null!==e;e=e._nextPrevious)t(e)}forEachChangedItem(t){let e;for(e=this._changesHead;null!==e;e=e._nextChanged)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}diff(t){if(t){if(!(t instanceof Map||Yo(t)))throw new Error(`Error trying to diff '${It(t)}'. Only maps and objects are allowed`)}else t=new Map;return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e=this._mapHead;if(this._appendAfter=null,this._forEach(t,(t,n)=>{if(e&&e.key===n)this._maybeAddToChanges(e,t),this._appendAfter=e,e=e._next;else{const r=this._getOrCreateRecordForKey(n,t);e=this._insertBeforeOrAppend(e,r)}}),e){e._prev&&(e._prev._next=null),this._removalsHead=e;for(let t=e;null!==t;t=t._nextRemoved)t===this._mapHead&&(this._mapHead=null),this._records.delete(t.key),t._nextRemoved=t._next,t.previousValue=t.currentValue,t.currentValue=null,t._prev=null,t._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(t,e){if(t){const n=t._prev;return e._next=t,e._prev=n,t._prev=e,n&&(n._next=e),t===this._mapHead&&(this._mapHead=e),this._appendAfter=t,t}return this._appendAfter?(this._appendAfter._next=e,e._prev=this._appendAfter):this._mapHead=e,this._appendAfter=e,null}_getOrCreateRecordForKey(t,e){if(this._records.has(t)){const n=this._records.get(t);this._maybeAddToChanges(n,e);const r=n._prev,i=n._next;return r&&(r._next=i),i&&(i._prev=r),n._next=null,n._prev=null,n}const n=new kl(t);return this._records.set(t,n),n.currentValue=e,this._addToAdditions(n),n}_reset(){if(this.isDirty){let t;for(this._previousMapHead=this._mapHead,t=this._previousMapHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._changesHead;null!==t;t=t._nextChanged)t.previousValue=t.currentValue;for(t=this._additionsHead;null!=t;t=t._nextAdded)t.previousValue=t.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(t,e){Object.is(e,t.currentValue)||(t.previousValue=t.currentValue,t.currentValue=e,this._addToChanges(t))}_addToAdditions(t){null===this._additionsHead?this._additionsHead=this._additionsTail=t:(this._additionsTail._nextAdded=t,this._additionsTail=t)}_addToChanges(t){null===this._changesHead?this._changesHead=this._changesTail=t:(this._changesTail._nextChanged=t,this._changesTail=t)}_forEach(t,e){t instanceof Map?t.forEach(e):Object.keys(t).forEach(n=>e(t[n],n))}}class kl{constructor(t){this.key=t,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function Rl(){return new Il([new _l])}let Il=(()=>{class t{constructor(t){this.factories=t}static create(e,n){if(null!=n){const t=n.factories.slice();e=e.concat(t)}return new t(e)}static extend(e){return{provide:t,useFactory:n=>t.create(e,n||Rl()),deps:[[t,new Gr,new jr]]}}find(t){const e=this.factories.find(e=>e.supports(t));if(null!=e)return e;throw new Error(`Cannot find a differ supporting object '${t}' of type '${n=t,n.name||typeof n}'`);var n}}return t.\u0275prov=Pt({token:t,providedIn:"root",factory:Rl}),t})();function Nl(){return new Ol([new Al])}let Ol=(()=>{class t{constructor(t){this.factories=t}static create(e,n){if(n){const t=n.factories.slice();e=e.concat(t)}return new t(e)}static extend(e){return{provide:t,useFactory:n=>t.create(e,n||Nl()),deps:[[t,new Gr,new jr]]}}find(t){const e=this.factories.find(e=>e.supports(t));if(e)return e;throw new Error(`Cannot find a differ supporting object '${t}'`)}}return t.\u0275prov=Pt({token:t,providedIn:"root",factory:Nl}),t})();function Dl(t,e,n,r,i=!1){for(;null!==n;){const s=e[n.index];if(null!==s&&r.push(Ke(s)),Me(s))for(let t=Te;t<s.length;t++){const e=s[t],n=e[1].firstChild;null!==n&&Dl(e[1],e,n,r)}const o=n.type;if(8&o)Dl(t,e,n.child,r);else if(32&o){const t=zi(n,e);let i;for(;i=t();)r.push(i)}else if(16&o){const t=os(e,n);if(Array.isArray(t))r.push(...t);else{const n=Vi(e[16]);Dl(n[1],n,t,r,!0)}}n=i?n.projectionNext:n.next}return r}class Ll{constructor(t,e){this._lView=t,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const t=this._lView,e=t[1];return Dl(e,t,e.firstChild,[])}get context(){return this._lView[8]}get destroyed(){return 256==(256&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const t=this._lView[3];if(Me(t)){const e=t[8],n=e?e.indexOf(this):-1;n>-1&&(Xi(t,n),Mr(e,n))}this._attachedToViewContainer=!1}Ki(this._lView[1],this._lView)}onDestroy(t){qs(this._lView[1],this._lView,null,t)}markForCheck(){ho(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-129}reattach(){this._lView[2]|=128}detectChanges(){po(this._lView[1],this._lView,this.context)}checkNoChanges(){!function(t,e,n){vn(!0);try{po(t,e,n)}finally{vn(!1)}}(this._lView[1],this._lView,this.context)}attachToViewContainerRef(){if(this._appRef)throw new Error("This view is already attached directly to the ApplicationRef!");this._attachedToViewContainer=!0}detachFromAppRef(){var t;this._appRef=null,cs(this._lView[1],t=this._lView,t[11],2,null,null)}attachToAppRef(t){if(this._attachedToViewContainer)throw new Error("This view is already attached to a ViewContainer!");this._appRef=t}}class Fl extends Ll{constructor(t){super(t),this._view=t}detectChanges(){fo(this._view)}checkNoChanges(){!function(t){vn(!0);try{fo(t)}finally{vn(!1)}}(this._view)}get context(){return null}}const Pl=Bl;let $l=(()=>{class t{}return t.__NG_ELEMENT_ID__=Pl,t.__ChangeDetectorRef__=!0,t})();function Bl(t=!1){return function(t,e,n){if(!n&&Re(t)){const n=Qe(t.index,e);return new Ll(n,n)}return 47&t.type?new Ll(e[16],e):null}(dn(),cn(),t)}const zl=[new Al],Vl=new Il([new _l]),Ul=new Ol(zl),Hl=function(){return ql(dn(),cn())};let Wl=(()=>{class t{}return t.__NG_ELEMENT_ID__=Hl,t})();const jl=Wl,Gl=class extends jl{constructor(t,e,n){super(),this._declarationLView=t,this._declarationTContainer=e,this.elementRef=n}createEmbeddedView(t){const e=this._declarationTContainer.tViews,n=Ls(this._declarationLView,e,t,16,null,e.declTNode,null,null,null,null);n[17]=this._declarationLView[this._declarationTContainer.index];const r=this._declarationLView[19];return null!==r&&(n[19]=r.createEmbeddedView(e)),$s(e,n,t),new Ll(n)}};function ql(t,e){return 4&t.type?new Gl(e,t,ul(t,e)):null}class Xl{}const Kl=function(){return ec(dn(),cn())};let Yl=(()=>{class t{}return t.__NG_ELEMENT_ID__=Kl,t})();const Zl=Yl,Jl=class extends Zl{constructor(t,e,n){super(),this._lContainer=t,this._hostTNode=e,this._hostLView=n}get element(){return ul(this._hostTNode,this._hostLView)}get injector(){return new vr(this._hostTNode,this._hostLView)}get parentInjector(){const t=or(this._hostTNode,this._hostLView);if(Zn(t)){const e=Qn(t,this._hostLView),n=Jn(t);return new vr(e[1].data[n+8],e)}return new vr(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){const e=Ql(this._lContainer);return null!==e&&e[t]||null}get length(){return this._lContainer.length-Te}createEmbeddedView(t,e,n){const r=t.createEmbeddedView(e||{});return this.insert(r,n),r}createComponent(t,e,n,r,i){const s=n||this.parentInjector;if(!i&&null==t.ngModule&&s){const t=s.get(Xl,null);t&&(i=t)}const o=t.create(s,r,void 0,i);return this.insert(o.hostView,e),o}insert(t,e){const n=t._lView,r=n[1];if(Me(n[3])){const e=this.indexOf(t);if(-1!==e)this.detach(e);else{const e=n[3],r=new Jl(e,e[6],e[3]);r.detach(r.indexOf(t))}}const i=this._adjustIndex(e),s=this._lContainer;!function(t,e,n,r){const i=Te+r,s=n.length;r>0&&(n[i-1][4]=e),r<s-Te?(e[4]=n[i],Ar(n,Te+r,e)):(n.push(e),e[4]=null),e[3]=n;const o=e[17];null!==o&&n!==o&&function(t,e){const n=t[9];e[16]!==e[3][3][16]&&(t[2]=!0),null===n?t[9]=[e]:n.push(e)}(o,e);const a=e[19];null!==a&&a.insertView(t),e[2]|=128}(r,n,s,i);const o=as(i,s),a=n[11],l=es(a,s[7]);return null!==l&&function(t,e,n,r,i,s){r[0]=i,r[6]=e,cs(t,r,n,1,i,s)}(r,s[6],a,n,l,o),t.attachToViewContainerRef(),Ar(tc(s),i,t),t}move(t,e){return this.insert(t,e)}indexOf(t){const e=Ql(this._lContainer);return null!==e?e.indexOf(t):-1}remove(t){const e=this._adjustIndex(t,-1),n=Xi(this._lContainer,e);n&&(Mr(tc(this._lContainer),e),Ki(n[1],n))}detach(t){const e=this._adjustIndex(t,-1),n=Xi(this._lContainer,e);return n&&null!=Mr(tc(this._lContainer),e)?new Ll(n):null}_adjustIndex(t,e=0){return null==t?this.length+e:t}};function Ql(t){return t[8]}function tc(t){return t[8]||(t[8]=[])}function ec(t,e){let n;const r=e[t.index];if(Me(r))n=r;else{let i;if(8&t.type)i=Ke(r);else{const n=e[11];i=n.createComment("");const r=Ze(t,e);Ji(n,es(n,r),i,function(t,e){return qe(t)?t.nextSibling(e):e.nextSibling}(n,r),!1)}e[t.index]=n=oo(r,e,i,t),uo(e,n)}return new Jl(n,t,e)}const nc={};class rc extends ll{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){const e=Se(t);return new oc(e,this.ngModule)}}function ic(t){const e=[];for(let n in t)t.hasOwnProperty(n)&&e.push({propName:t[n],templateName:n});return e}const sc=new Er("SCHEDULER_TOKEN",{providedIn:"root",factory:()=>Fi});class oc extends ol{constructor(t,e){super(),this.componentDef=t,this.ngModule=e,this.componentType=t.type,this.selector=t.selectors.map(Es).join(","),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!e}get inputs(){return ic(this.componentDef.inputs)}get outputs(){return ic(this.componentDef.outputs)}create(t,e,n,r){const i=(r=r||this.ngModule)?function(t,e){return{get:(n,r,i)=>{const s=t.get(n,nc,i);return s!==nc||r===nc?s:e.get(n,r,i)}}}(t,r.injector):t,s=i.get(fl,Xe),o=i.get(yl,null),a=s.createRenderer(null,this.componentDef),l=this.componentDef.selectors[0][0]||"div",c=n?function(t,e,n){if(qe(t))return t.selectRootElement(e,n===Qt.ShadowDom);let r="string"==typeof e?t.querySelector(e):e;return r.textContent="",r}(a,n,this.componentDef.encapsulation):Gi(s.createRenderer(null,this.componentDef),l,function(t){const e=t.toLowerCase();return"svg"===e?We:"math"===e?"http://www.w3.org/1998/MathML/":null}(l)),u=this.componentDef.onPush?576:528,h={components:[],scheduler:Fi,clean:go,playerHandler:null,flags:0},d=Gs(0,null,null,1,0,null,null,null,null,null),p=Ls(null,d,h,u,null,null,s,a,o,i);let f,m;Mn(p);try{const t=function(t,e,n,r,i,s){const o=n[1];n[20]=t;const a=Fs(o,20,2,"#host",null),l=a.mergedAttrs=e.hostAttrs;null!==l&&(wo(a,l,!0),null!==t&&(Gn(i,t,l),null!==a.classes&&ds(i,t,a.classes),null!==a.styles&&hs(i,t,a.styles)));const c=r.createRenderer(t,e),u=Ls(n,js(e),null,e.onPush?64:16,n[20],a,r,c,null,null);return o.firstCreatePass&&(ar(rr(a,n),o,e.type),Qs(o,a),eo(a,n.length,1)),uo(n,u),n[20]=u}(c,this.componentDef,p,s,a);if(c)if(n)Gn(a,c,["ng-version",bl.full]);else{const{attrs:t,classes:e}=function(t){const e=[],n=[];let r=1,i=2;for(;r<t.length;){let s=t[r];if("string"==typeof s)2===i?""!==s&&e.push(s,t[++r]):8===i&&n.push(s);else{if(!bs(i))break;i=s}r++}return{attrs:e,classes:n}}(this.componentDef.selectors[0]);t&&Gn(a,c,t),e&&e.length>0&&ds(a,c,e.join(" "))}if(m=Je(d,Ce),void 0!==e){const t=m.projection=[];for(let n=0;n<this.ngContentSelectors.length;n++){const r=e[n];t.push(null!=r?Array.from(r):null)}}f=function(t,e,n,r,i){const s=n[1],o=function(t,e,n){const r=dn();t.firstCreatePass&&(n.providersResolver&&n.providersResolver(n),no(t,r,e,Ps(t,e,1,null),n));const i=mr(e,t,r.directiveStart,r);Li(i,e);const s=Ze(r,e);return s&&Li(s,e),i}(s,n,e);if(r.components.push(o),t[8]=o,i&&i.forEach(t=>t(o,e)),e.contentQueries){const t=dn();e.contentQueries(1,o,t.directiveStart)}const a=dn();return!s.firstCreatePass||null===e.hostBindings&&null===e.hostAttrs||(Ln(a.index),Zs(n[1],a,0,a.directiveStart,a.directiveEnd,e),Js(e,o)),o}(t,this.componentDef,p,h,[zo]),$s(d,p,null)}finally{On()}return new ac(this.componentType,f,ul(m,p),p,m)}}class ac extends class{}{constructor(t,e,n,r,i){super(),this.location=n,this._rootLView=r,this._tNode=i,this.instance=e,this.hostView=this.changeDetectorRef=new Fl(r),this.componentType=t}get injector(){return new vr(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}}const lc=new Map;class cc extends Xl{constructor(t,e){super(),this._parent=e,this._bootstrapComponents=[],this.injector=this,this.destroyCbs=[],this.componentFactoryResolver=new rc(this);const n=Ee(t),r=t[he]||null;r&&Za(r),this._bootstrapComponents=$i(n.bootstrap),this._r3Injector=Io(t,e,[{provide:Xl,useValue:this},{provide:ll,useValue:this.componentFactoryResolver}],It(t)),this._r3Injector._resolveInjectorDefTypes(),this.instance=this.get(t)}get(t,e=Bo.THROW_IF_NOT_FOUND,n=qt.Default){return t===Bo||t===Xl||t===So?this:this._r3Injector.get(t,e,n)}destroy(){const t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(t=>t()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}}class uc extends class{}{constructor(t){super(),this.moduleType=t,null!==Ee(t)&&function(t){const e=new Set;!function t(n){const r=Ee(n,!0),i=r.id;null!==i&&(function(t,e,n){if(e&&e!==n)throw new Error(`Duplicate module registered for ${t} - ${It(e)} vs ${It(e.name)}`)}(i,lc.get(i),n),lc.set(i,n));const s=$i(r.imports);for(const o of s)e.has(o)||(e.add(o),t(o))}(t)}(t)}create(t){return new cc(this.moduleType,t)}}function hc(t,e){const n=un();let r;const i=t+Ce;n.firstCreatePass?(r=function(t,e){if(e)for(let n=e.length-1;n>=0;n--){const r=e[n];if(t===r.name)return r}throw new De("302",`The pipe '${t}' could not be found!`)}(e,n.pipeRegistry),n.data[i]=r,r.onDestroy&&(n.destroyHooks||(n.destroyHooks=[])).push(i,r.onDestroy)):r=n.data[i];const s=r.factory||(r.factory=Oe(r.type)),o=Kt(ta);try{const t=er(!1),e=s();return er(t),function(t,e,n,r){n>=t.data.length&&(t.data[n]=null,t.blueprint[n]=null),e[n]=r}(n,cn(),i,e),e}finally{Kt(o)}}function dc(t,e,n){const r=t+Ce,i=cn(),s=function(t,e){return t[e]}(i,r);return function(t,e){return Xo.isWrapped(e)&&(e=Xo.unwrap(e),t[an.lFrame.bindingIndex]=Cs),e}(i,function(t,e){return t[1].data[e].pure}(i,r)?function(t,e,n,r,i,s){const o=e+n;return Zo(t,o,i)?function(t,e,n){return t[e]=n}(t,o+1,s?r.call(s,i):r(i)):function(t,e){const n=t[e];return n===Cs?void 0:n}(t,o+1)}(i,function(){const t=an.lFrame;let e=t.bindingRootIndex;return-1===e&&(e=t.bindingRootIndex=t.tView.bindingStartIndex),e}(),e,s.transform,n,s):s.transform(n))}const pc=class extends J{constructor(t=!1){super(),this.__isAsync=t}emit(t){super.next(t)}subscribe(t,e,n){let r,i=t=>null,s=()=>null;t&&"object"==typeof t?(r=this.__isAsync?e=>{setTimeout(()=>t.next(e))}:e=>{t.next(e)},t.error&&(i=this.__isAsync?e=>{setTimeout(()=>t.error(e))}:e=>{t.error(e)}),t.complete&&(s=this.__isAsync?()=>{setTimeout(()=>t.complete())}:()=>{t.complete()})):(r=this.__isAsync?e=>{setTimeout(()=>t(e))}:e=>{t(e)},e&&(i=this.__isAsync?t=>{setTimeout(()=>e(t))}:t=>{e(t)}),n&&(s=this.__isAsync?()=>{setTimeout(()=>n())}:()=>{n()}));const o=super.subscribe(r,i,s);return t instanceof z&&t.add(o),o}};function fc(){return this._results[qo()]()}class mc{constructor(t=!1){this._emitDistinctChangesOnly=t,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=qo(),n=mc.prototype;n[e]||(n[e]=fc)}get changes(){return this._changes||(this._changes=new pc)}get(t){return this._results[t]}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,e){return this._results.reduce(t,e)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t,e){const n=this;n.dirty=!1;const r=Cr(t);(this._changesDetected=!function(t,e,n){if(t.length!==e.length)return!1;for(let r=0;r<t.length;r++){let i=t[r],s=e[r];if(n&&(i=n(i),s=n(s)),s!==i)return!1}return!0}(n._results,r,e))&&(n._results=r,n.length=r.length,n.last=r[this.length-1],n.first=r[0])}notifyOnChanges(){!this._changes||!this._changesDetected&&this._emitDistinctChangesOnly||this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}class gc{constructor(t){this.queryList=t,this.matches=null}clone(){return new gc(this.queryList)}setDirty(){this.queryList.setDirty()}}class yc{constructor(t=[]){this.queries=t}createEmbeddedView(t){const e=t.queries;if(null!==e){const n=null!==t.contentQueries?t.contentQueries[0]:e.length,r=[];for(let t=0;t<n;t++){const n=e.getByIndex(t);r.push(this.queries[n.indexInDeclarationView].clone())}return new yc(r)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let e=0;e<this.queries.length;e++)null!==Ic(t,e).matches&&this.queries[e].setDirty()}}class vc{constructor(t,e,n=null){this.predicate=t,this.flags=e,this.read=n}}class bc{constructor(t=[]){this.queries=t}elementStart(t,e){for(let n=0;n<this.queries.length;n++)this.queries[n].elementStart(t,e)}elementEnd(t){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(t)}embeddedTView(t){let e=null;for(let n=0;n<this.length;n++){const r=null!==e?e.length:0,i=this.getByIndex(n).embeddedTView(t,r);i&&(i.indexInDeclarationView=n,null!==e?e.push(i):e=[i])}return null!==e?new bc(e):null}template(t,e){for(let n=0;n<this.queries.length;n++)this.queries[n].template(t,e)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}}class _c{constructor(t,e=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(t,e){this.isApplyingToNode(e)&&this.matchTNode(t,e)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,e){this.elementStart(t,e)}embeddedTView(t,e){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,e),new _c(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let n=t.parent;for(;null!==n&&8&n.type&&n.index!==e;)n=n.parent;return e===(null!==n?n.index:-1)}return this._appliesToNextNode}matchTNode(t,e){const n=this.metadata.predicate;if(Array.isArray(n))for(let r=0;r<n.length;r++){const i=n[r];this.matchTNodeWithReadOption(t,e,xc(e,i)),this.matchTNodeWithReadOption(t,e,fr(e,t,i,!1,!1))}else n===Wl?4&e.type&&this.matchTNodeWithReadOption(t,e,-1):this.matchTNodeWithReadOption(t,e,fr(e,t,n,!1,!1))}matchTNodeWithReadOption(t,e,n){if(null!==n){const r=this.metadata.read;if(null!==r)if(r===dl||r===Yl||r===Wl&&4&e.type)this.addMatch(e.index,-2);else{const n=fr(e,t,r,!1,!1);null!==n&&this.addMatch(e.index,n)}else this.addMatch(e.index,n)}}addMatch(t,e){null===this.matches?this.matches=[t,e]:this.matches.push(t,e)}}function xc(t,e){const n=t.localNames;if(null!==n)for(let r=0;r<n.length;r+=2)if(n[r]===e)return n[r+1];return null}function wc(t,e,n,r){return-1===n?function(t,e){return 11&t.type?ul(t,e):4&t.type?ql(t,e):null}(e,t):-2===n?function(t,e,n){return n===dl?ul(e,t):n===Wl?ql(e,t):n===Yl?ec(e,t):void 0}(t,e,r):mr(t,t[1],n,e)}function Sc(t,e,n,r){const i=e[19].queries[r];if(null===i.matches){const r=t.data,s=n.matches,o=[];for(let t=0;t<s.length;t+=2){const i=s[t];o.push(i<0?null:wc(e,r[i],s[t+1],n.metadata.read))}i.matches=o}return i.matches}function Ec(t,e,n,r){const i=t.queries.getByIndex(n),s=i.matches;if(null!==s){const o=Sc(t,e,i,n);for(let t=0;t<s.length;t+=2){const n=s[t];if(n>0)r.push(o[t/2]);else{const i=s[t+1],o=e[-n];for(let t=Te;t<o.length;t++){const e=o[t];e[17]===e[3]&&Ec(e[1],e,i,r)}if(null!==o[9]){const t=o[9];for(let e=0;e<t.length;e++){const n=t[e];Ec(n[1],n,i,r)}}}}}return r}function Cc(t){const e=cn(),n=un(),r=En();Cn(r+1);const i=Ic(n,r);if(t.dirty&&en(e)===(2==(2&i.metadata.flags))){if(null===i.matches)t.reset([]);else{const s=i.crossesNgTemplate?Ec(n,e,r,[]):Sc(n,e,i,r);t.reset(s,pl),t.notifyOnChanges()}return!0}return!1}function Tc(t,e,n){const r=un();r.firstCreatePass&&(Rc(r,new vc(t,e,n),-1),2==(2&e)&&(r.staticViewQueries=!0)),kc(r,cn(),e)}function Ac(t,e,n,r){const i=un();if(i.firstCreatePass){const s=dn();Rc(i,new vc(e,n,r),s.index),function(t,e){const n=t.contentQueries||(t.contentQueries=[]);e!==(n.length?n[n.length-1]:-1)&&n.push(t.queries.length-1,e)}(i,t),2==(2&n)&&(i.staticContentQueries=!0)}kc(i,cn(),n)}function Mc(){return t=cn(),e=En(),t[19].queries[e].queryList;var t,e}function kc(t,e,n){const r=new mc(4==(4&n));qs(t,e,r,r.destroy),null===e[19]&&(e[19]=new yc),e[19].queries.push(new gc(r))}function Rc(t,e,n){null===t.queries&&(t.queries=new bc),t.queries.track(new _c(e,n))}function Ic(t,e){return t.queries.getByIndex(e)}function Nc(t=qt.Default){const e=Bl(!0);if(null!=e||t&qt.Optional)return e;Pe("ChangeDetectorRef")}const Oc=new Er("Application Initializer");let Dc=(()=>{class t{constructor(t){this.appInits=t,this.resolve=cl,this.reject=cl,this.initialized=!1,this.done=!1,this.donePromise=new Promise((t,e)=>{this.resolve=t,this.reject=e})}runInitializers(){if(this.initialized)return;const t=[],e=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let n=0;n<this.appInits.length;n++){const e=this.appInits[n]();ca(e)&&t.push(e)}Promise.all(t).then(()=>{e()}).catch(t=>{this.reject(t)}),0===t.length&&e(),this.initialized=!0}}return t.\u0275fac=function(e){return new(e||t)(zr(Oc,8))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();const Lc=new Er("AppId"),Fc={provide:Lc,useFactory:function(){return`${Pc()}${Pc()}${Pc()}`},deps:[]};function Pc(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const $c=new Er("Platform Initializer"),Bc=new Er("Platform ID"),zc=new Er("appBootstrapListener");let Vc=(()=>{class t{log(t){console.log(t)}warn(t){console.warn(t)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();const Uc=new Er("LocaleId"),Hc=new Er("DefaultCurrencyCode");class Wc{constructor(t,e){this.ngModuleFactory=t,this.componentFactories=e}}const jc=function(t){return new uc(t)},Gc=jc,qc=function(t){return Promise.resolve(jc(t))},Xc=function(t){const e=jc(t),n=$i(Ee(t).declarations).reduce((t,e)=>{const n=Se(e);return n&&t.push(new oc(n)),t},[]);return new Wc(e,n)},Kc=Xc,Yc=function(t){return Promise.resolve(Xc(t))};let Zc=(()=>{class t{constructor(){this.compileModuleSync=Gc,this.compileModuleAsync=qc,this.compileModuleAndAllComponentsSync=Kc,this.compileModuleAndAllComponentsAsync=Yc}clearCache(){}clearCacheFor(t){}getModuleId(t){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();const Jc=new Er("compilerOptions"),Qc=(()=>Promise.resolve(0))();function tu(t){"undefined"==typeof Zone?Qc.then(()=>{t&&t.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",t)}class eu{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:n=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new pc(!1),this.onMicrotaskEmpty=new pc(!1),this.onStable=new pc(!1),this.onError=new pc(!1),"undefined"==typeof Zone)throw new Error("In this configuration Angular requires Zone.js");Zone.assertZonePatched();const r=this;r._nesting=0,r._outer=r._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(r._inner=r._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(r._inner=r._inner.fork(Zone.longStackTraceZoneSpec)),r.shouldCoalesceEventChangeDetection=!n&&e,r.shouldCoalesceRunChangeDetection=n,r.lastRequestAnimationFrameId=-1,r.nativeRequestAnimationFrame=function(){let t=ie.requestAnimationFrame,e=ie.cancelAnimationFrame;if("undefined"!=typeof Zone&&t&&e){const n=t[Zone.__symbol__("OriginalDelegate")];n&&(t=n);const r=e[Zone.__symbol__("OriginalDelegate")];r&&(e=r)}return{nativeRequestAnimationFrame:t,nativeCancelAnimationFrame:e}}().nativeRequestAnimationFrame,function(t){const e=()=>{!function(t){-1===t.lastRequestAnimationFrameId&&(t.lastRequestAnimationFrameId=t.nativeRequestAnimationFrame.call(ie,()=>{t.fakeTopEventTask||(t.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{t.lastRequestAnimationFrameId=-1,iu(t),ru(t)},void 0,()=>{},()=>{})),t.fakeTopEventTask.invoke()}),iu(t))}(t)};t._inner=t._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(n,r,i,s,o,a)=>{try{return su(t),n.invokeTask(i,s,o,a)}finally{(t.shouldCoalesceEventChangeDetection&&"eventTask"===s.type||t.shouldCoalesceRunChangeDetection)&&e(),ou(t)}},onInvoke:(n,r,i,s,o,a,l)=>{try{return su(t),n.invoke(i,s,o,a,l)}finally{t.shouldCoalesceRunChangeDetection&&e(),ou(t)}},onHasTask:(e,n,r,i)=>{e.hasTask(r,i),n===r&&("microTask"==i.change?(t._hasPendingMicrotasks=i.microTask,iu(t),ru(t)):"macroTask"==i.change&&(t.hasPendingMacrotasks=i.macroTask))},onHandleError:(e,n,r,i)=>(e.handleError(r,i),t.runOutsideAngular(()=>t.onError.emit(i)),!1)})}(r)}static isInAngularZone(){return!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!eu.isInAngularZone())throw new Error("Expected to be in Angular Zone, but it is not!")}static assertNotInAngularZone(){if(eu.isInAngularZone())throw new Error("Expected to not be in Angular Zone, but it is!")}run(t,e,n){return this._inner.run(t,e,n)}runTask(t,e,n,r){const i=this._inner,s=i.scheduleEventTask("NgZoneEvent: "+r,t,nu,cl,cl);try{return i.runTask(s,e,n)}finally{i.cancelTask(s)}}runGuarded(t,e,n){return this._inner.runGuarded(t,e,n)}runOutsideAngular(t){return this._outer.run(t)}}const nu={};function ru(t){if(0==t._nesting&&!t.hasPendingMicrotasks&&!t.isStable)try{t._nesting++,t.onMicrotaskEmpty.emit(null)}finally{if(t._nesting--,!t.hasPendingMicrotasks)try{t.runOutsideAngular(()=>t.onStable.emit(null))}finally{t.isStable=!0}}}function iu(t){t.hasPendingMicrotasks=!!(t._hasPendingMicrotasks||(t.shouldCoalesceEventChangeDetection||t.shouldCoalesceRunChangeDetection)&&-1!==t.lastRequestAnimationFrameId)}function su(t){t._nesting++,t.isStable&&(t.isStable=!1,t.onUnstable.emit(null))}function ou(t){t._nesting--,ru(t)}class au{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new pc,this.onMicrotaskEmpty=new pc,this.onStable=new pc,this.onError=new pc}run(t,e,n){return t.apply(e,n)}runGuarded(t,e,n){return t.apply(e,n)}runOutsideAngular(t){return t()}runTask(t,e,n,r){return t.apply(e,n)}}let lu=(()=>{class t{constructor(t){this._ngZone=t,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,this._watchAngularEvents(),t.run(()=>{this.taskTrackingZone="undefined"==typeof Zone?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{eu.assertNotInAngularZone(),tu(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())tu(()=>{for(;0!==this._callbacks.length;){let t=this._callbacks.pop();clearTimeout(t.timeoutId),t.doneCb(this._didWork)}this._didWork=!1});else{let t=this.getPendingTasks();this._callbacks=this._callbacks.filter(e=>!e.updateCb||!e.updateCb(t)||(clearTimeout(e.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(t=>({source:t.source,creationLocation:t.creationLocation,data:t.data})):[]}addCallback(t,e,n){let r=-1;e&&e>0&&(r=setTimeout(()=>{this._callbacks=this._callbacks.filter(t=>t.timeoutId!==r),t(this._didWork,this.getPendingTasks())},e)),this._callbacks.push({doneCb:t,timeoutId:r,updateCb:n})}whenStable(t,e,n){if(n&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?');this.addCallback(t,e,n),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}findProviders(t,e,n){return[]}}return t.\u0275fac=function(e){return new(e||t)(zr(eu))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})(),cu=(()=>{class t{constructor(){this._applications=new Map,du.addToWindow(this)}registerApplication(t,e){this._applications.set(t,e)}unregisterApplication(t){this._applications.delete(t)}unregisterAllApplications(){this._applications.clear()}getTestability(t){return this._applications.get(t)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(t,e=!0){return du.findTestabilityInTree(this,t,e)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();class uu{addToWindow(t){}findTestabilityInTree(t,e,n){return null}}let hu,du=new uu,pu=!0,fu=!1;function mu(){return fu=!0,pu}const gu=new Er("AllowMultipleToken");function yu(t,e,n=[]){const r=`Platform: ${e}`,i=new Er(r);return(e=[])=>{let s=vu();if(!s||s.injector.get(gu,!1))if(t)t(n.concat(e).concat({provide:i,useValue:!0}));else{const t=n.concat(e).concat({provide:i,useValue:!0},{provide:Co,useValue:"platform"});!function(t){if(hu&&!hu.destroyed&&!hu.injector.get(gu,!1))throw new Error("There can be only one platform. Destroy the previous one to create a new one.");hu=t.get(bu);const e=t.get($c,null);e&&e.forEach(t=>t())}(Bo.create({providers:t,name:r}))}return function(t){const e=vu();if(!e)throw new Error("No platform exists!");if(!e.injector.get(t,null))throw new Error("A platform with a different configuration has been created. Please destroy it first.");return e}(i)}}function vu(){return hu&&!hu.destroyed?hu:null}let bu=(()=>{class t{constructor(t){this._injector=t,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(t,e){const n=function(t,e){let n;return n="noop"===t?new au:("zone.js"===t?void 0:t)||new eu({enableLongStackTrace:mu(),shouldCoalesceEventChangeDetection:!!(null==e?void 0:e.ngZoneEventCoalescing),shouldCoalesceRunChangeDetection:!!(null==e?void 0:e.ngZoneRunCoalescing)}),n}(e?e.ngZone:void 0,{ngZoneEventCoalescing:e&&e.ngZoneEventCoalescing||!1,ngZoneRunCoalescing:e&&e.ngZoneRunCoalescing||!1}),r=[{provide:eu,useValue:n}];return n.run(()=>{const e=Bo.create({providers:r,parent:this.injector,name:t.moduleType.name}),i=t.create(e),s=i.injector.get(Di,null);if(!s)throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?");return n.runOutsideAngular(()=>{const t=n.onError.subscribe({next:t=>{s.handleError(t)}});i.onDestroy(()=>{wu(this._modules,i),t.unsubscribe()})}),function(t,e,n){try{const r=n();return ca(r)?r.catch(n=>{throw e.runOutsideAngular(()=>t.handleError(n)),n}):r}catch(r){throw e.runOutsideAngular(()=>t.handleError(r)),r}}(s,n,()=>{const t=i.injector.get(Dc);return t.runInitializers(),t.donePromise.then(()=>(Za(i.injector.get(Uc,Ka)||Ka),this._moduleDoBootstrap(i),i))})})}bootstrapModule(t,e=[]){const n=_u({},e);return function(t,e,n){const r=new uc(n);return Promise.resolve(r)}(0,0,t).then(t=>this.bootstrapModuleFactory(t,n))}_moduleDoBootstrap(t){const e=t.injector.get(xu);if(t._bootstrapComponents.length>0)t._bootstrapComponents.forEach(t=>e.bootstrap(t));else{if(!t.instance.ngDoBootstrap)throw new Error(`The module ${It(t.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);t.instance.ngDoBootstrap(e)}this._modules.push(t)}onDestroy(t){this._destroyListeners.push(t)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Error("The platform has already been destroyed!");this._modules.slice().forEach(t=>t.destroy()),this._destroyListeners.forEach(t=>t()),this._destroyed=!0}get destroyed(){return this._destroyed}}return t.\u0275fac=function(e){return new(e||t)(zr(Bo))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();function _u(t,e){return Array.isArray(e)?e.reduce(_u,t):Object.assign(Object.assign({},t),e)}let xu=(()=>{class t{constructor(t,e,n,r,i,s){this._zone=t,this._console=e,this._injector=n,this._exceptionHandler=r,this._componentFactoryResolver=i,this._initStatus=s,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const o=new q(t=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{t.next(this._stable),t.complete()})}),a=new q(t=>{let e;this._zone.runOutsideAngular(()=>{e=this._zone.onStable.subscribe(()=>{eu.assertNotInAngularZone(),tu(()=>{this._stable||this._zone.hasPendingMacrotasks||this._zone.hasPendingMicrotasks||(this._stable=!0,t.next(!0))})})});const n=this._zone.onUnstable.subscribe(()=>{eu.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{t.next(!1)}))});return()=>{e.unsubscribe(),n.unsubscribe()}});this.isStable=_t(o,a.pipe(Mt()))}bootstrap(t,e){if(!this._initStatus.done)throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.");let n;n=t instanceof ol?t:this._componentFactoryResolver.resolveComponentFactory(t),this.componentTypes.push(n.componentType);const r=n.isBoundToModule?void 0:this._injector.get(Xl),i=n.create(Bo.NULL,[],e||n.selector,r),s=i.location.nativeElement,o=i.injector.get(lu,null),a=o&&i.injector.get(cu);return o&&a&&a.registerApplication(s,o),i.onDestroy(()=>{this.detachView(i.hostView),wu(this.components,i),a&&a.unregisterApplication(s)}),this._loadComponent(i),mu()&&this._console.log("Angular is running in development mode. Call enableProdMode() to enable production mode."),i}tick(){if(this._runningTick)throw new Error("ApplicationRef.tick is called recursively");try{this._runningTick=!0;for(let t of this._views)t.detectChanges()}catch(t){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(t))}finally{this._runningTick=!1}}attachView(t){const e=t;this._views.push(e),e.attachToAppRef(this)}detachView(t){const e=t;wu(this._views,e),e.detachFromAppRef()}_loadComponent(t){this.attachView(t.hostView),this.tick(),this.components.push(t),this._injector.get(zc,[]).concat(this._bootstrapListeners).forEach(e=>e(t))}ngOnDestroy(){this._views.slice().forEach(t=>t.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}get viewCount(){return this._views.length}}return t.\u0275fac=function(e){return new(e||t)(zr(eu),zr(Vc),zr(Bo),zr(Di),zr(ll),zr(Dc))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();function wu(t,e){const n=t.indexOf(e);n>-1&&t.splice(n,1)}const Su=yu(null,"core",[{provide:Bc,useValue:"unknown"},{provide:bu,deps:[Bo]},{provide:cu,deps:[]},{provide:Vc,deps:[]}]),Eu=[{provide:xu,useClass:xu,deps:[eu,Vc,Bo,Di,ll,Dc]},{provide:sc,deps:[eu],useFactory:function(t){let e=[];return t.onStable.subscribe(()=>{for(;e.length;)e.pop()()}),function(t){e.push(t)}}},{provide:Dc,useClass:Dc,deps:[[new jr,Oc]]},{provide:Zc,useClass:Zc,deps:[]},Fc,{provide:Il,useFactory:function(){return Vl},deps:[]},{provide:Ol,useFactory:function(){return Ul},deps:[]},{provide:Uc,useFactory:function(t){return Za(t=t||"undefined"!=typeof $localize&&$localize.locale||Ka),t},deps:[[new Wr(Uc),new jr,new Gr]]},{provide:Hc,useValue:"USD"}];let Cu=(()=>{class t{constructor(t){}}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)(zr(xu))},providers:Eu}),t})(),Tu=null;function Au(){return Tu}const Mu=new Er("DocumentToken");let ku=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({factory:Ru,token:t,providedIn:"platform"}),t})();function Ru(){return zr(Iu)}let Iu=(()=>{class t extends ku{constructor(t){super(),this._doc=t,this._init()}_init(){this.location=Au().getLocation(),this._history=Au().getHistory()}getBaseHrefFromDOM(){return Au().getBaseHref(this._doc)}onPopState(t){Au().getGlobalEventTarget(this._doc,"window").addEventListener("popstate",t,!1)}onHashChange(t){Au().getGlobalEventTarget(this._doc,"window").addEventListener("hashchange",t,!1)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(t){this.location.pathname=t}pushState(t,e,n){Nu()?this._history.pushState(t,e,n):this.location.hash=n}replaceState(t,e,n){Nu()?this._history.replaceState(t,e,n):this.location.hash=n}forward(){this._history.forward()}back(){this._history.back()}getState(){return this._history.state}}return t.\u0275fac=function(e){return new(e||t)(zr(Mu))},t.\u0275prov=Pt({factory:Ou,token:t,providedIn:"platform"}),t})();function Nu(){return!!window.history.pushState}function Ou(){return new Iu(zr(Mu))}function Du(t,e){if(0==t.length)return e;if(0==e.length)return t;let n=0;return t.endsWith("/")&&n++,e.startsWith("/")&&n++,2==n?t+e.substring(1):1==n?t+e:t+"/"+e}function Lu(t){const e=t.match(/#|\?|$/),n=e&&e.index||t.length;return t.slice(0,n-("/"===t[n-1]?1:0))+t.slice(n)}function Fu(t){return t&&"?"!==t[0]?"?"+t:t}let Pu=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({factory:$u,token:t,providedIn:"root"}),t})();function $u(t){const e=zr(Mu).location;return new zu(zr(ku),e&&e.origin||"")}const Bu=new Er("appBaseHref");let zu=(()=>{class t extends Pu{constructor(t,e){if(super(),this._platformLocation=t,null==e&&(e=this._platformLocation.getBaseHrefFromDOM()),null==e)throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");this._baseHref=e}onPopState(t){this._platformLocation.onPopState(t),this._platformLocation.onHashChange(t)}getBaseHref(){return this._baseHref}prepareExternalUrl(t){return Du(this._baseHref,t)}path(t=!1){const e=this._platformLocation.pathname+Fu(this._platformLocation.search),n=this._platformLocation.hash;return n&&t?`${e}${n}`:e}pushState(t,e,n,r){const i=this.prepareExternalUrl(n+Fu(r));this._platformLocation.pushState(t,e,i)}replaceState(t,e,n,r){const i=this.prepareExternalUrl(n+Fu(r));this._platformLocation.replaceState(t,e,i)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}}return t.\u0275fac=function(e){return new(e||t)(zr(ku),zr(Bu,8))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})(),Vu=(()=>{class t{constructor(t,e){this._subject=new pc,this._urlChangeListeners=[],this._platformStrategy=t;const n=this._platformStrategy.getBaseHref();this._platformLocation=e,this._baseHref=Lu(Hu(n)),this._platformStrategy.onPopState(t=>{this._subject.emit({url:this.path(!0),pop:!0,state:t.state,type:t.type})})}path(t=!1){return this.normalize(this._platformStrategy.path(t))}getState(){return this._platformLocation.getState()}isCurrentPathEqualTo(t,e=""){return this.path()==this.normalize(t+Fu(e))}normalize(e){return t.stripTrailingSlash(function(t,e){return t&&e.startsWith(t)?e.substring(t.length):e}(this._baseHref,Hu(e)))}prepareExternalUrl(t){return t&&"/"!==t[0]&&(t="/"+t),this._platformStrategy.prepareExternalUrl(t)}go(t,e="",n=null){this._platformStrategy.pushState(n,"",t,e),this._notifyUrlChangeListeners(this.prepareExternalUrl(t+Fu(e)),n)}replaceState(t,e="",n=null){this._platformStrategy.replaceState(n,"",t,e),this._notifyUrlChangeListeners(this.prepareExternalUrl(t+Fu(e)),n)}forward(){this._platformStrategy.forward()}back(){this._platformStrategy.back()}onUrlChange(t){this._urlChangeListeners.push(t),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(t=>{this._notifyUrlChangeListeners(t.url,t.state)}))}_notifyUrlChangeListeners(t="",e){this._urlChangeListeners.forEach(n=>n(t,e))}subscribe(t,e,n){return this._subject.subscribe({next:t,error:e,complete:n})}}return t.\u0275fac=function(e){return new(e||t)(zr(Pu),zr(ku))},t.normalizeQueryParams=Fu,t.joinWithSlash=Du,t.stripTrailingSlash=Lu,t.\u0275prov=Pt({factory:Uu,token:t,providedIn:"root"}),t})();function Uu(){return new Vu(zr(Pu),zr(ku))}function Hu(t){return t.replace(/\/index.html$/,"")}var Wu=function(t){return t[t.Zero=0]="Zero",t[t.One=1]="One",t[t.Two=2]="Two",t[t.Few=3]="Few",t[t.Many=4]="Many",t[t.Other=5]="Other",t}({});class ju{}let Gu=(()=>{class t extends ju{constructor(t){super(),this.locale=t}getPluralCategory(t,e){switch(function(t){return function(t){const e=function(t){return t.toLowerCase().replace(/_/g,"-")}(t);let n=qa(e);if(n)return n;const r=e.split("-")[0];if(n=qa(r),n)return n;if("en"===r)return ja;throw new Error(`Missing locale data for the locale "${t}".`)}(t)[Xa.PluralCase]}(e||this.locale)(t)){case Wu.Zero:return"zero";case Wu.One:return"one";case Wu.Two:return"two";case Wu.Few:return"few";case Wu.Many:return"many";default:return"other"}}}return t.\u0275fac=function(e){return new(e||t)(zr(Uc))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();function qu(t,e){e=encodeURIComponent(e);for(const n of t.split(";")){const t=n.indexOf("="),[r,i]=-1==t?[n,""]:[n.slice(0,t),n.slice(t+1)];if(r.trim()===e)return decodeURIComponent(i)}return null}let Xu=(()=>{class t{constructor(t,e,n,r){this._iterableDiffers=t,this._keyValueDiffers=e,this._ngEl=n,this._renderer=r,this._iterableDiffer=null,this._keyValueDiffer=null,this._initialClasses=[],this._rawClass=null}set klass(t){this._removeClasses(this._initialClasses),this._initialClasses="string"==typeof t?t.split(/\s+/):[],this._applyClasses(this._initialClasses),this._applyClasses(this._rawClass)}set ngClass(t){this._removeClasses(this._rawClass),this._applyClasses(this._initialClasses),this._iterableDiffer=null,this._keyValueDiffer=null,this._rawClass="string"==typeof t?t.split(/\s+/):t,this._rawClass&&(Ko(this._rawClass)?this._iterableDiffer=this._iterableDiffers.find(this._rawClass).create():this._keyValueDiffer=this._keyValueDiffers.find(this._rawClass).create())}ngDoCheck(){if(this._iterableDiffer){const t=this._iterableDiffer.diff(this._rawClass);t&&this._applyIterableChanges(t)}else if(this._keyValueDiffer){const t=this._keyValueDiffer.diff(this._rawClass);t&&this._applyKeyValueChanges(t)}}_applyKeyValueChanges(t){t.forEachAddedItem(t=>this._toggleClass(t.key,t.currentValue)),t.forEachChangedItem(t=>this._toggleClass(t.key,t.currentValue)),t.forEachRemovedItem(t=>{t.previousValue&&this._toggleClass(t.key,!1)})}_applyIterableChanges(t){t.forEachAddedItem(t=>{if("string"!=typeof t.item)throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${It(t.item)}`);this._toggleClass(t.item,!0)}),t.forEachRemovedItem(t=>this._toggleClass(t.item,!1))}_applyClasses(t){t&&(Array.isArray(t)||t instanceof Set?t.forEach(t=>this._toggleClass(t,!0)):Object.keys(t).forEach(e=>this._toggleClass(e,!!t[e])))}_removeClasses(t){t&&(Array.isArray(t)||t instanceof Set?t.forEach(t=>this._toggleClass(t,!1)):Object.keys(t).forEach(t=>this._toggleClass(t,!1)))}_toggleClass(t,e){(t=t.trim())&&t.split(/\s+/g).forEach(t=>{e?this._renderer.addClass(this._ngEl.nativeElement,t):this._renderer.removeClass(this._ngEl.nativeElement,t)})}}return t.\u0275fac=function(e){return new(e||t)(ta(Il),ta(Ol),ta(dl),ta(ml))},t.\u0275dir=xe({type:t,selectors:[["","ngClass",""]],inputs:{klass:["class","klass"],ngClass:"ngClass"}}),t})();class Ku{constructor(t,e,n,r){this.$implicit=t,this.ngForOf=e,this.index=n,this.count=r}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let Yu=(()=>{class t{constructor(t,e,n){this._viewContainer=t,this._template=e,this._differs=n,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForOf(t){this._ngForOf=t,this._ngForOfDirty=!0}set ngForTrackBy(t){this._trackByFn=t}get ngForTrackBy(){return this._trackByFn}set ngForTemplate(t){t&&(this._template=t)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const n=this._ngForOf;if(!this._differ&&n)try{this._differ=this._differs.find(n).create(this.ngForTrackBy)}catch(e){throw new Error(`Cannot find a differ supporting object '${n}' of type '${t=n,t.name||typeof t}'. NgFor only supports binding to Iterables such as Arrays.`)}}var t;if(this._differ){const t=this._differ.diff(this._ngForOf);t&&this._applyChanges(t)}}_applyChanges(t){const e=[];t.forEachOperation((t,n,r)=>{if(null==t.previousIndex){const n=this._viewContainer.createEmbeddedView(this._template,new Ku(null,this._ngForOf,-1,-1),null===r?void 0:r),i=new Zu(t,n);e.push(i)}else if(null==r)this._viewContainer.remove(null===n?void 0:n);else if(null!==n){const i=this._viewContainer.get(n);this._viewContainer.move(i,r);const s=new Zu(t,i);e.push(s)}});for(let n=0;n<e.length;n++)this._perViewChange(e[n].view,e[n].record);for(let n=0,r=this._viewContainer.length;n<r;n++){const t=this._viewContainer.get(n);t.context.index=n,t.context.count=r,t.context.ngForOf=this._ngForOf}t.forEachIdentityChange(t=>{this._viewContainer.get(t.currentIndex).context.$implicit=t.item})}_perViewChange(t,e){t.context.$implicit=e.item}static ngTemplateContextGuard(t,e){return!0}}return t.\u0275fac=function(e){return new(e||t)(ta(Yl),ta(Wl),ta(Il))},t.\u0275dir=xe({type:t,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"}}),t})();class Zu{constructor(t,e){this.record=t,this.view=e}}let Ju=(()=>{class t{constructor(t,e){this._viewContainer=t,this._context=new Qu,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=e}set ngIf(t){this._context.$implicit=this._context.ngIf=t,this._updateView()}set ngIfThen(t){th("ngIfThen",t),this._thenTemplateRef=t,this._thenViewRef=null,this._updateView()}set ngIfElse(t){th("ngIfElse",t),this._elseTemplateRef=t,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(t,e){return!0}}return t.\u0275fac=function(e){return new(e||t)(ta(Yl),ta(Wl))},t.\u0275dir=xe({type:t,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"}}),t})();class Qu{constructor(){this.$implicit=null,this.ngIf=null}}function th(t,e){if(e&&!e.createEmbeddedView)throw new Error(`${t} must be a TemplateRef, but received '${It(e)}'.`)}class eh{constructor(t,e){this._viewContainerRef=t,this._templateRef=e,this._created=!1}create(){this._created=!0,this._viewContainerRef.createEmbeddedView(this._templateRef)}destroy(){this._created=!1,this._viewContainerRef.clear()}enforceState(t){t&&!this._created?this.create():!t&&this._created&&this.destroy()}}let nh=(()=>{class t{constructor(){this._defaultUsed=!1,this._caseCount=0,this._lastCaseCheckIndex=0,this._lastCasesMatched=!1}set ngSwitch(t){this._ngSwitch=t,0===this._caseCount&&this._updateDefaultCases(!0)}_addCase(){return this._caseCount++}_addDefault(t){this._defaultViews||(this._defaultViews=[]),this._defaultViews.push(t)}_matchCase(t){const e=t==this._ngSwitch;return this._lastCasesMatched=this._lastCasesMatched||e,this._lastCaseCheckIndex++,this._lastCaseCheckIndex===this._caseCount&&(this._updateDefaultCases(!this._lastCasesMatched),this._lastCaseCheckIndex=0,this._lastCasesMatched=!1),e}_updateDefaultCases(t){if(this._defaultViews&&t!==this._defaultUsed){this._defaultUsed=t;for(let e=0;e<this._defaultViews.length;e++)this._defaultViews[e].enforceState(t)}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=xe({type:t,selectors:[["","ngSwitch",""]],inputs:{ngSwitch:"ngSwitch"}}),t})(),rh=(()=>{class t{constructor(t,e,n){this.ngSwitch=n,n._addCase(),this._view=new eh(t,e)}ngDoCheck(){this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase))}}return t.\u0275fac=function(e){return new(e||t)(ta(Yl),ta(Wl),ta(nh,1))},t.\u0275dir=xe({type:t,selectors:[["","ngSwitchCase",""]],inputs:{ngSwitchCase:"ngSwitchCase"}}),t})();class ih{createSubscription(t,e){return t.subscribe({next:e,error:t=>{throw t}})}dispose(t){t.unsubscribe()}onDestroy(t){t.unsubscribe()}}class sh{createSubscription(t,e){return t.then(e,t=>{throw t})}dispose(t){}onDestroy(t){}}const oh=new sh,ah=new ih;let lh=(()=>{class t{constructor(t){this._ref=t,this._latestValue=null,this._subscription=null,this._obj=null,this._strategy=null}ngOnDestroy(){this._subscription&&this._dispose()}transform(t){return this._obj?t!==this._obj?(this._dispose(),this.transform(t)):this._latestValue:(t&&this._subscribe(t),this._latestValue)}_subscribe(t){this._obj=t,this._strategy=this._selectStrategy(t),this._subscription=this._strategy.createSubscription(t,e=>this._updateLatestValue(t,e))}_selectStrategy(e){if(ca(e))return oh;if(ua(e))return ah;throw Error(`InvalidPipeArgument: '${e}' for pipe '${It(t)}'`)}_dispose(){this._strategy.dispose(this._subscription),this._latestValue=null,this._subscription=null,this._obj=null}_updateLatestValue(t,e){t===this._obj&&(this._latestValue=e,this._ref.markForCheck())}}return t.\u0275fac=function(e){return new(e||t)(Nc())},t.\u0275pipe=we({name:"async",type:t,pure:!1}),t})(),ch=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},providers:[{provide:ju,useClass:Gu}]}),t})();class uh extends class extends class{}{constructor(){super()}supportsDOMEvents(){return!0}}{static makeCurrent(){var t;t=new uh,Tu||(Tu=t)}getProperty(t,e){return t[e]}log(t){window.console&&window.console.log&&window.console.log(t)}logGroup(t){window.console&&window.console.group&&window.console.group(t)}logGroupEnd(){window.console&&window.console.groupEnd&&window.console.groupEnd()}onAndCancel(t,e,n){return t.addEventListener(e,n,!1),()=>{t.removeEventListener(e,n,!1)}}dispatchEvent(t,e){t.dispatchEvent(e)}remove(t){return t.parentNode&&t.parentNode.removeChild(t),t}getValue(t){return t.value}createElement(t,e){return(e=e||this.getDefaultDocument()).createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,e){return"window"===e?window:"document"===e?t:"body"===e?t.body:null}getHistory(){return window.history}getLocation(){return window.location}getBaseHref(t){const e=dh||(dh=document.querySelector("base"),dh)?dh.getAttribute("href"):null;return null==e?null:(n=e,hh||(hh=document.createElement("a")),hh.setAttribute("href",n),"/"===hh.pathname.charAt(0)?hh.pathname:"/"+hh.pathname);var n}resetBaseElement(){dh=null}getUserAgent(){return window.navigator.userAgent}performanceNow(){return window.performance&&window.performance.now?window.performance.now():(new Date).getTime()}supportsCookies(){return!0}getCookie(t){return qu(document.cookie,t)}}let hh,dh=null;const ph=new Er("TRANSITION_ID"),fh=[{provide:Oc,useFactory:function(t,e,n){return()=>{n.get(Dc).donePromise.then(()=>{const n=Au();Array.prototype.slice.apply(e.querySelectorAll("style[ng-transition]")).filter(e=>e.getAttribute("ng-transition")===t).forEach(t=>n.remove(t))})}},deps:[ph,Mu,Bo],multi:!0}];class mh{static init(){var t;t=new mh,du=t}addToWindow(t){ie.getAngularTestability=(e,n=!0)=>{const r=t.findTestabilityInTree(e,n);if(null==r)throw new Error("Could not find testability for element.");return r},ie.getAllAngularTestabilities=()=>t.getAllTestabilities(),ie.getAllAngularRootElements=()=>t.getAllRootElements(),ie.frameworkStabilizers||(ie.frameworkStabilizers=[]),ie.frameworkStabilizers.push(t=>{const e=ie.getAllAngularTestabilities();let n=e.length,r=!1;const i=function(e){r=r||e,n--,0==n&&t(r)};e.forEach(function(t){t.whenStable(i)})})}findTestabilityInTree(t,e,n){if(null==e)return null;const r=t.getTestability(e);return null!=r?r:n?Au().isShadowRoot(e)?this.findTestabilityInTree(t,e.host,!0):this.findTestabilityInTree(t,e.parentElement,!0):null}}const gh=new Er("EventManagerPlugins");let yh=(()=>{class t{constructor(t,e){this._zone=e,this._eventNameToPlugin=new Map,t.forEach(t=>t.manager=this),this._plugins=t.slice().reverse()}addEventListener(t,e,n){return this._findPluginFor(e).addEventListener(t,e,n)}addGlobalEventListener(t,e,n){return this._findPluginFor(e).addGlobalEventListener(t,e,n)}getZone(){return this._zone}_findPluginFor(t){const e=this._eventNameToPlugin.get(t);if(e)return e;const n=this._plugins;for(let r=0;r<n.length;r++){const e=n[r];if(e.supports(t))return this._eventNameToPlugin.set(t,e),e}throw new Error(`No event manager plugin found for event ${t}`)}}return t.\u0275fac=function(e){return new(e||t)(zr(gh),zr(eu))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();class vh{constructor(t){this._doc=t}addGlobalEventListener(t,e,n){const r=Au().getGlobalEventTarget(this._doc,t);if(!r)throw new Error(`Unsupported event target ${r} for event ${e}`);return this.addEventListener(r,e,n)}}let bh=(()=>{class t{constructor(){this._stylesSet=new Set}addStyles(t){const e=new Set;t.forEach(t=>{this._stylesSet.has(t)||(this._stylesSet.add(t),e.add(t))}),this.onStylesAdded(e)}onStylesAdded(t){}getAllStyles(){return Array.from(this._stylesSet)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})(),_h=(()=>{class t extends bh{constructor(t){super(),this._doc=t,this._hostNodes=new Set,this._styleNodes=new Set,this._hostNodes.add(t.head)}_addStylesToHost(t,e){t.forEach(t=>{const n=this._doc.createElement("style");n.textContent=t,this._styleNodes.add(e.appendChild(n))})}addHost(t){this._addStylesToHost(this._stylesSet,t),this._hostNodes.add(t)}removeHost(t){this._hostNodes.delete(t)}onStylesAdded(t){this._hostNodes.forEach(e=>this._addStylesToHost(t,e))}ngOnDestroy(){this._styleNodes.forEach(t=>Au().remove(t))}}return t.\u0275fac=function(e){return new(e||t)(zr(Mu))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();const xh={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"},wh=/%COMP%/g;function Sh(t,e,n){for(let r=0;r<e.length;r++){let i=e[r];Array.isArray(i)?Sh(t,i,n):(i=i.replace(wh,t),n.push(i))}return n}function Eh(t){return e=>{if("__ngUnwrap__"===e)return t;!1===t(e)&&(e.preventDefault(),e.returnValue=!1)}}let Ch=(()=>{class t{constructor(t,e,n){this.eventManager=t,this.sharedStylesHost=e,this.appId=n,this.rendererByCompId=new Map,this.defaultRenderer=new Th(t)}createRenderer(t,e){if(!t||!e)return this.defaultRenderer;switch(e.encapsulation){case Qt.Emulated:{let n=this.rendererByCompId.get(e.id);return n||(n=new Ah(this.eventManager,this.sharedStylesHost,e,this.appId),this.rendererByCompId.set(e.id,n)),n.applyToHost(t),n}case 1:case Qt.ShadowDom:return new Mh(this.eventManager,this.sharedStylesHost,t,e);default:if(!this.rendererByCompId.has(e.id)){const t=Sh(e.id,e.styles,[]);this.sharedStylesHost.addStyles(t),this.rendererByCompId.set(e.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return t.\u0275fac=function(e){return new(e||t)(zr(yh),zr(_h),zr(Lc))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();class Th{constructor(t){this.eventManager=t,this.data=Object.create(null)}destroy(){}createElement(t,e){return e?document.createElementNS(xh[e]||e,t):document.createElement(t)}createComment(t){return document.createComment(t)}createText(t){return document.createTextNode(t)}appendChild(t,e){t.appendChild(e)}insertBefore(t,e,n){t&&t.insertBefore(e,n)}removeChild(t,e){t&&t.removeChild(e)}selectRootElement(t,e){let n="string"==typeof t?document.querySelector(t):t;if(!n)throw new Error(`The selector "${t}" did not match any elements`);return e||(n.textContent=""),n}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,e,n,r){if(r){e=r+":"+e;const i=xh[r];i?t.setAttributeNS(i,e,n):t.setAttribute(e,n)}else t.setAttribute(e,n)}removeAttribute(t,e,n){if(n){const r=xh[n];r?t.removeAttributeNS(r,e):t.removeAttribute(`${n}:${e}`)}else t.removeAttribute(e)}addClass(t,e){t.classList.add(e)}removeClass(t,e){t.classList.remove(e)}setStyle(t,e,n,r){r&(Bi.DashCase|Bi.Important)?t.style.setProperty(e,n,r&Bi.Important?"important":""):t.style[e]=n}removeStyle(t,e,n){n&Bi.DashCase?t.style.removeProperty(e):t.style[e]=""}setProperty(t,e,n){t[e]=n}setValue(t,e){t.nodeValue=e}listen(t,e,n){return"string"==typeof t?this.eventManager.addGlobalEventListener(t,e,Eh(n)):this.eventManager.addEventListener(t,e,Eh(n))}}class Ah extends Th{constructor(t,e,n,r){super(t),this.component=n;const i=Sh(r+"-"+n.id,n.styles,[]);e.addStyles(i),this.contentAttr="_ngcontent-%COMP%".replace(wh,r+"-"+n.id),this.hostAttr="_nghost-%COMP%".replace(wh,r+"-"+n.id)}applyToHost(t){super.setAttribute(t,this.hostAttr,"")}createElement(t,e){const n=super.createElement(t,e);return super.setAttribute(n,this.contentAttr,""),n}}class Mh extends Th{constructor(t,e,n,r){super(t),this.sharedStylesHost=e,this.hostEl=n,this.shadowRoot=n.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const i=Sh(r.id,r.styles,[]);for(let s=0;s<i.length;s++){const t=document.createElement("style");t.textContent=i[s],this.shadowRoot.appendChild(t)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(t,e){return super.appendChild(this.nodeOrShadowRoot(t),e)}insertBefore(t,e,n){return super.insertBefore(this.nodeOrShadowRoot(t),e,n)}removeChild(t,e){return super.removeChild(this.nodeOrShadowRoot(t),e)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}}let kh=(()=>{class t extends vh{constructor(t){super(t)}supports(t){return!0}addEventListener(t,e,n){return t.addEventListener(e,n,!1),()=>this.removeEventListener(t,e,n)}removeEventListener(t,e,n){return t.removeEventListener(e,n)}}return t.\u0275fac=function(e){return new(e||t)(zr(Mu))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();const Rh=["alt","control","meta","shift"],Ih={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},Nh={A:"1",B:"2",C:"3",D:"4",E:"5",F:"6",G:"7",H:"8",I:"9",J:"*",K:"+",M:"-",N:".",O:"/","`":"0","\x90":"NumLock"},Oh={alt:t=>t.altKey,control:t=>t.ctrlKey,meta:t=>t.metaKey,shift:t=>t.shiftKey};let Dh=(()=>{class t extends vh{constructor(t){super(t)}supports(e){return null!=t.parseEventName(e)}addEventListener(e,n,r){const i=t.parseEventName(n),s=t.eventCallback(i.fullKey,r,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>Au().onAndCancel(e,i.domEventName,s))}static parseEventName(e){const n=e.toLowerCase().split("."),r=n.shift();if(0===n.length||"keydown"!==r&&"keyup"!==r)return null;const i=t._normalizeKey(n.pop());let s="";if(Rh.forEach(t=>{const e=n.indexOf(t);e>-1&&(n.splice(e,1),s+=t+".")}),s+=i,0!=n.length||0===i.length)return null;const o={};return o.domEventName=r,o.fullKey=s,o}static getEventFullKey(t){let e="",n=function(t){let e=t.key;if(null==e){if(e=t.keyIdentifier,null==e)return"Unidentified";e.startsWith("U+")&&(e=String.fromCharCode(parseInt(e.substring(2),16)),3===t.location&&Nh.hasOwnProperty(e)&&(e=Nh[e]))}return Ih[e]||e}(t);return n=n.toLowerCase()," "===n?n="space":"."===n&&(n="dot"),Rh.forEach(r=>{r!=n&&(0,Oh[r])(t)&&(e+=r+".")}),e+=n,e}static eventCallback(e,n,r){return i=>{t.getEventFullKey(i)===e&&r.runGuarded(()=>n(i))}}static _normalizeKey(t){switch(t){case"esc":return"escape";default:return t}}}return t.\u0275fac=function(e){return new(e||t)(zr(Mu))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})(),Lh=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({factory:function(){return zr(Fh)},token:t,providedIn:"root"}),t})(),Fh=(()=>{class t extends Lh{constructor(t){super(),this._doc=t}sanitize(t,e){if(null==e)return null;switch(t){case ki.NONE:return e;case ki.HTML:return ii(e,"HTML")?ri(e):Ai(this._doc,String(e)).toString();case ki.STYLE:return ii(e,"Style")?ri(e):e;case ki.SCRIPT:if(ii(e,"Script"))return ri(e);throw new Error("unsafe value used in a script context");case ki.URL:return si(e),ii(e,"URL")?ri(e):ui(String(e));case ki.RESOURCE_URL:if(ii(e,"ResourceURL"))return ri(e);throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)");default:throw new Error(`Unexpected SecurityContext ${t} (see https://g.co/ng/security#xss)`)}}bypassSecurityTrustHtml(t){return new Jr(t)}bypassSecurityTrustStyle(t){return new Qr(t)}bypassSecurityTrustScript(t){return new ti(t)}bypassSecurityTrustUrl(t){return new ei(t)}bypassSecurityTrustResourceUrl(t){return new ni(t)}}return t.\u0275fac=function(e){return new(e||t)(zr(Mu))},t.\u0275prov=Pt({factory:function(){return t=zr(So),new Fh(t.get(Mu));var t},token:t,providedIn:"root"}),t})();const Ph=yu(Su,"browser",[{provide:Bc,useValue:"browser"},{provide:$c,useValue:function(){uh.makeCurrent(),mh.init()},multi:!0},{provide:Mu,useFactory:function(){return function(t){je=t}(document),document},deps:[]}]),$h=[[],{provide:Co,useValue:"root"},{provide:Di,useFactory:function(){return new Di},deps:[]},{provide:gh,useClass:kh,multi:!0,deps:[Mu,eu,Bc]},{provide:gh,useClass:Dh,multi:!0,deps:[Mu]},[],{provide:Ch,useClass:Ch,deps:[yh,_h,Lc]},{provide:fl,useExisting:Ch},{provide:bh,useExisting:_h},{provide:_h,useClass:_h,deps:[Mu]},{provide:lu,useClass:lu,deps:[eu]},{provide:yh,useClass:yh,deps:[gh,eu]},[]];let Bh=(()=>{class t{constructor(t){if(t)throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.")}static withServerTransition(e){return{ngModule:t,providers:[{provide:Lc,useValue:e.appId},{provide:ph,useExisting:Lc},fh]}}}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)(zr(t,12))},providers:$h,imports:[ch,Cu]}),t})();function zh(t,e,n,r){var i,s=arguments.length,o=s<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(t,e,n,r);else for(var a=t.length-1;a>=0;a--)(i=t[a])&&(o=(s<3?i(o):s>3?i(e,n,o):i(e,n))||o);return s>3&&o&&Object.defineProperty(e,n,o),o}function Vh(t,e,n,r){return new(n||(n=Promise))(function(i,s){function o(t){try{l(r.next(t))}catch(e){s(e)}}function a(t){try{l(r.throw(t))}catch(e){s(e)}}function l(t){var e;t.done?i(t.value):(e=t.value,e instanceof n?e:new n(function(t){t(e)})).then(o,a)}l((r=r.apply(t,e||[])).next())})}"undefined"!=typeof window&&window;class Uh extends z{constructor(t,e){super()}schedule(t,e=0){return this}}class Hh extends Uh{constructor(t,e){super(t,e),this.scheduler=t,this.work=e,this.pending=!1}schedule(t,e=0){if(this.closed)return this;this.state=t;const n=this.id,r=this.scheduler;return null!=n&&(this.id=this.recycleAsyncId(r,n,e)),this.pending=!0,this.delay=e,this.id=this.id||this.requestAsyncId(r,this.id,e),this}requestAsyncId(t,e,n=0){return setInterval(t.flush.bind(t,this),n)}recycleAsyncId(t,e,n=0){if(null!==n&&this.delay===n&&!1===this.pending)return e;clearInterval(e)}execute(t,e){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;const n=this._execute(t,e);if(n)return n;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(t,e){let n,r=!1;try{this.work(t)}catch(i){r=!0,n=!!i&&i||new Error(i)}if(r)return this.unsubscribe(),n}_unsubscribe(){const t=this.id,e=this.scheduler,n=e.actions,r=n.indexOf(this);this.work=null,this.state=null,this.pending=!1,this.scheduler=null,-1!==r&&n.splice(r,1),null!=t&&(this.id=this.recycleAsyncId(e,t,null)),this.delay=null}}class Wh extends Hh{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}schedule(t,e=0){return e>0?super.schedule(t,e):(this.delay=e,this.state=t,this.scheduler.flush(this),this)}execute(t,e){return e>0||this.closed?super.execute(t,e):this._execute(t,e)}requestAsyncId(t,e,n=0){return null!==n&&n>0||null===n&&this.delay>0?super.requestAsyncId(t,e,n):t.flush(this)}}let jh=(()=>{class t{constructor(e,n=t.now){this.SchedulerAction=e,this.now=n}schedule(t,e=0,n){return new this.SchedulerAction(this,t).schedule(n,e)}}return t.now=()=>Date.now(),t})();class Gh extends jh{constructor(t,e=jh.now){super(t,()=>Gh.delegate&&Gh.delegate!==this?Gh.delegate.now():e()),this.actions=[],this.active=!1,this.scheduled=void 0}schedule(t,e=0,n){return Gh.delegate&&Gh.delegate!==this?Gh.delegate.schedule(t,e,n):super.schedule(t,e,n)}flush(t){const{actions:e}=this;if(this.active)return void e.push(t);let n;this.active=!0;do{if(n=t.execute(t.state,t.delay))break}while(t=e.shift());if(this.active=!1,n){for(;t=e.shift();)t.unsubscribe();throw n}}}class qh extends Gh{}const Xh=new qh(Wh),Kh=new q(t=>t.complete());function Yh(t){return t?function(t){return new q(e=>t.schedule(()=>e.complete()))}(t):Kh}function Zh(...t){let e=t[t.length-1];return tt(e)?(t.pop(),ut(t,e)):bt(t)}function Jh(t,e){return new q(e?n=>e.schedule(Qh,0,{error:t,subscriber:n}):e=>e.error(t))}function Qh({error:t,subscriber:e}){e.error(t)}let td=(()=>{class t{constructor(t,e,n){this.kind=t,this.value=e,this.error=n,this.hasValue="N"===t}observe(t){switch(this.kind){case"N":return t.next&&t.next(this.value);case"E":return t.error&&t.error(this.error);case"C":return t.complete&&t.complete()}}do(t,e,n){switch(this.kind){case"N":return t&&t(this.value);case"E":return e&&e(this.error);case"C":return n&&n()}}accept(t,e,n){return t&&"function"==typeof t.next?this.observe(t):this.do(t,e,n)}toObservable(){switch(this.kind){case"N":return Zh(this.value);case"E":return Jh(this.error);case"C":return Yh()}throw new Error("unexpected notification kind value")}static createNext(e){return void 0!==e?new t("N",e):t.undefinedValueNotification}static createError(e){return new t("E",void 0,e)}static createComplete(){return t.completeNotification}}return t.completeNotification=new t("C"),t.undefinedValueNotification=new t("N",void 0),t})();class ed extends H{constructor(t,e,n=0){super(t),this.scheduler=e,this.delay=n}static dispatch(t){const{notification:e,destination:n}=t;e.observe(n),this.unsubscribe()}scheduleMessage(t){this.destination.add(this.scheduler.schedule(ed.dispatch,this.delay,new nd(t,this.destination)))}_next(t){this.scheduleMessage(td.createNext(t))}_error(t){this.scheduleMessage(td.createError(t)),this.unsubscribe()}_complete(){this.scheduleMessage(td.createComplete()),this.unsubscribe()}}class nd{constructor(t,e){this.notification=t,this.destination=e}}class rd extends J{constructor(t=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,n){super(),this.scheduler=n,this._events=[],this._infiniteTimeWindow=!1,this._bufferSize=t<1?1:t,this._windowTime=e<1?1:e,e===Number.POSITIVE_INFINITY?(this._infiniteTimeWindow=!0,this.next=this.nextInfiniteTimeWindow):this.next=this.nextTimeWindow}nextInfiniteTimeWindow(t){if(!this.isStopped){const e=this._events;e.push(t),e.length>this._bufferSize&&e.shift()}super.next(t)}nextTimeWindow(t){this.isStopped||(this._events.push(new id(this._getNow(),t)),this._trimBufferThenGetEvents()),super.next(t)}_subscribe(t){const e=this._infiniteTimeWindow,n=e?this._events:this._trimBufferThenGetEvents(),r=this.scheduler,i=n.length;let s;if(this.closed)throw new K;if(this.isStopped||this.hasError?s=z.EMPTY:(this.observers.push(t),s=new Y(this,t)),r&&t.add(t=new ed(t,r)),e)for(let o=0;o<i&&!t.closed;o++)t.next(n[o]);else for(let o=0;o<i&&!t.closed;o++)t.next(n[o].value);return this.hasError?t.error(this.thrownError):this.isStopped&&t.complete(),s}_getNow(){return(this.scheduler||Xh).now()}_trimBufferThenGetEvents(){const t=this._getNow(),e=this._bufferSize,n=this._windowTime,r=this._events,i=r.length;let s=0;for(;s<i&&!(t-r[s].time<n);)s++;return i>e&&(s=Math.max(s,i-e)),s>0&&r.splice(0,s),r}}class id{constructor(t,e){this.time=t,this.value=e}}function sd(t,e){return t===e}function od(t,e,n){if(null===e||null===n||e.length!==n.length)return!1;const r=e.length;for(let i=0;i<r;i++)if(!t(e[i],n[i]))return!1;return!0}function ad(t,e=sd){let n=null,r=null;function i(){return od(e,n,arguments)||(r=t.apply(null,arguments)),n=arguments,r}return i.reset=function(){n=null,r=null},i}const ld=ad(function(){const t=vu();if(!t)return!1;const e=t.injector.get(Jc,null);return!!e&&e.some(t=>(t&&t.providers||[]).some(t=>t&&t.provide&&"MockNgModuleResolver"===t.provide.name||!1))});let cd=(()=>{class t{constructor(){this.bootstrap$=new rd(1)}get appBootstrapped$(){return this.bootstrap$.asObservable()}bootstrap(){this.bootstrap$.next(!0),this.bootstrap$.complete()}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();const ud=new Er("INITIAL_STATE_TOKEN");let hd=(()=>{class t{static set(t){this.value=t}static pop(){const t=this.value;return this.value={},t}}return t.value={},t})();const dd=new Er("Internals.StateContextFactory"),pd=new Er("Internals.StateFactory");class fd extends J{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){const e=super._subscribe(t);return e&&!e.closed&&t.next(this._value),e}getValue(){if(this.hasError)throw this.thrownError;if(this.closed)throw new K;return this._value}next(t){super.next(this._value=t)}}function md(...t){if(1===t.length){const e=t[0];if(P(e))return gd(e,null);if($(e)&&Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);return gd(t.map(t=>e[t]),t)}}if("function"==typeof t[t.length-1]){const e=t.pop();return gd(t=1===t.length&&P(t[0])?t[0]:t,null).pipe(et(t=>e(...t)))}return gd(t,null)}function gd(t,e){return new q(n=>{const r=t.length;if(0===r)return void n.complete();const i=new Array(r);let s=0,o=0;for(let a=0;a<r;a++){const l=ht(t[a]);let c=!1;n.add(l.subscribe({next:t=>{c||(c=!0,o++),i[a]=t},error:t=>n.error(t),complete:()=>{s++,s!==r&&c||(o===r&&n.next(e?e.reduce((t,e,n)=>(t[e]=i[n],t),{}):i),n.complete())}}))}})}function yd(t,e){return function(n){return n.lift(new vd(t,e))}}class vd{constructor(t,e){this.predicate=t,this.thisArg=e}call(t,e){return e.subscribe(new bd(t,this.predicate,this.thisArg))}}class bd extends H{constructor(t,e,n){super(t),this.predicate=e,this.thisArg=n,this.count=0}_next(t){let e;try{e=this.predicate.call(this.thisArg,t,this.count++)}catch(n){return void this.destination.error(n)}e&&this.destination.next(t)}}function _d(t,e,n){let r;return r=t&&"object"==typeof t?t:{bufferSize:t,windowTime:e,refCount:!1,scheduler:n},t=>t.lift(function({bufferSize:t=Number.POSITIVE_INFINITY,windowTime:e=Number.POSITIVE_INFINITY,refCount:n,scheduler:r}){let i,s,o=0,a=!1,l=!1;return function(c){let u;o++,!i||a?(a=!1,i=new rd(t,e,r),u=i.subscribe(this),s=c.subscribe({next(t){i.next(t)},error(t){a=!0,i.error(t)},complete(){l=!0,s=void 0,i.complete()}})):u=i.subscribe(this),this.add(()=>{o--,u.unsubscribe(),s&&!l&&n&&0===o&&(s.unsubscribe(),s=void 0,i=void 0)})}}(r))}const xd=(()=>{function t(){return Error.call(this),this.message="argument out of range",this.name="ArgumentOutOfRangeError",this}return t.prototype=Object.create(Error.prototype),t})();function wd(t){return e=>0===t?Yh():e.lift(new Sd(t))}class Sd{constructor(t){if(this.total=t,this.total<0)throw new xd}call(t,e){return e.subscribe(new Ed(t,this.total))}}class Ed extends H{constructor(t,e){super(t),this.total=e,this.count=0}_next(t){const e=this.total,n=++this.count;n<=e&&(this.destination.next(t),n===e&&(this.destination.complete(),this.unsubscribe()))}}function Cd(t,e){return e?n=>n.pipe(Cd((n,r)=>ht(t(n,r)).pipe(et((t,i)=>e(n,t,r,i))))):e=>e.lift(new Td(t))}class Td{constructor(t){this.project=t}call(t,e){return e.subscribe(new Ad(t,this.project))}}class Ad extends pt{constructor(t,e){super(t),this.project=e,this.hasSubscription=!1,this.hasCompleted=!1,this.index=0}_next(t){this.hasSubscription||this.tryNext(t)}tryNext(t){let e;const n=this.index++;try{e=this.project(t,n)}catch(r){return void this.destination.error(r)}this.hasSubscription=!0,this._innerSub(e)}_innerSub(t){const e=new dt(this),n=this.destination;n.add(e);const r=ft(t,e);r!==e&&n.add(r)}_complete(){this.hasCompleted=!0,this.hasSubscription||this.destination.complete(),this.unsubscribe()}notifyNext(t){this.destination.next(t)}notifyError(t){this.destination.error(t)}notifyComplete(){this.hasSubscription=!1,this.hasCompleted&&this.destination.complete()}}function Md(t=null){return e=>e.lift(new kd(t))}class kd{constructor(t){this.defaultValue=t}call(t,e){return e.subscribe(new Rd(t,this.defaultValue))}}class Rd extends H{constructor(t,e){super(t),this.defaultValue=e,this.isEmpty=!0}_next(t){this.isEmpty=!1,this.destination.next(t)}_complete(){this.isEmpty&&this.destination.next(this.defaultValue),this.destination.complete()}}function Id(t){return function(e){const n=new Nd(t),r=e.lift(n);return n.caught=r}}class Nd{constructor(t){this.selector=t}call(t,e){return e.subscribe(new Od(t,this.selector,this.caught))}}class Od extends pt{constructor(t,e,n){super(t),this.selector=e,this.caught=n}error(t){if(!this.isStopped){let n;try{n=this.selector(t,this.caught)}catch(e){return void super.error(e)}this._unsubscribeAndRecycle();const r=new dt(this);this.add(r);const i=ft(n,r);i!==r&&this.add(i)}}}function Dd(t){return e=>e.lift(new Ld(t))}class Ld{constructor(t){this.notifier=t}call(t,e){const n=new Fd(t),r=ft(this.notifier,new dt(n));return r&&!n.seenValue?(n.add(r),e.subscribe(n)):n}}class Fd extends pt{constructor(t){super(t),this.seenValue=!1}notifyNext(){this.seenValue=!0,this.complete()}notifyComplete(){}}function Pd(){}function $d(t,e,n){return function(r){return r.lift(new Bd(t,e,n))}}class Bd{constructor(t,e,n){this.nextOrObserver=t,this.error=e,this.complete=n}call(t,e){return e.subscribe(new zd(t,this.nextOrObserver,this.error,this.complete))}}class zd extends H{constructor(t,e,n,r){super(t),this._tapNext=Pd,this._tapError=Pd,this._tapComplete=Pd,this._tapError=n||Pd,this._tapComplete=r||Pd,N(e)?(this._context=this,this._tapNext=e):e&&(this._context=e,this._tapNext=e.next||Pd,this._tapError=e.error||Pd,this._tapComplete=e.complete||Pd)}_next(t){try{this._tapNext.call(this._context,t)}catch(e){return void this.destination.error(e)}this.destination.next(t)}_error(t){try{this._tapError.call(this._context,t)}catch(t){return void this.destination.error(t)}this.destination.error(t)}_complete(){try{this._tapComplete.call(this._context)}catch(t){return void this.destination.error(t)}return this.destination.complete()}}function Vd(t,e){return n=>n.lift(new Ud(t,e))}class Ud{constructor(t,e){this.compare=t,this.keySelector=e}call(t,e){return e.subscribe(new Hd(t,this.compare,this.keySelector))}}class Hd extends H{constructor(t,e,n){super(t),this.keySelector=n,this.hasKey=!1,"function"==typeof e&&(this.compare=e)}compare(t,e){return t===e}_next(t){let e;try{const{keySelector:n}=this;e=n?n(t):t}catch(r){return this.destination.error(r)}let n=!1;if(this.hasKey)try{const{compare:t}=this;n=t(this.key,e)}catch(r){return this.destination.error(r)}else this.hasKey=!0;n||(this.key=e,this.destination.next(t))}}const Wd={STATE_NAME:t=>`${t} is not a valid state name. It needs to be a valid object property name.`,STATE_NAME_PROPERTY:()=>"States must register a 'name' property",STATE_UNIQUE:(t,e,n)=>`State name '${t}' from ${e} already exists in ${n}`,STATE_DECORATOR:()=>"States must be decorated with @State() decorator",INCORRECT_PRODUCTION:()=>"Angular is running in production mode but NGXS is still running in the development mode!\nPlease set developmentMode to false on the NgxsModule options when in production mode.\nNgxsModule.forRoot(states, { developmentMode: !environment.production })",INCORRECT_DEVELOPMENT:()=>"RECOMMENDATION: Set developmentMode to true on the NgxsModule when Angular is running in development mode.\nNgxsModule.forRoot(states, { developmentMode: !environment.production })",SELECT_FACTORY_NOT_CONNECTED:()=>"You have forgotten to import the NGXS module!",ACTION_DECORATOR:()=>"@Action() decorator cannot be used with static methods",SELECTOR_DECORATOR:()=>"Selectors only work on methods",ZONE_WARNING:()=>"Your application was bootstrapped with nooped zone and your execution strategy requires an actual NgZone!\nPlease set the value of the executionStrategy property to NoopNgxsExecutionStrategy.\nNgxsModule.forRoot(states, { executionStrategy: NoopNgxsExecutionStrategy })",PATCHING_ARRAY:()=>"Patching arrays is not supported.",PATCHING_PRIMITIVE:()=>"Patching primitives is not supported.",UNDECORATED_STATE_IN_IVY:t=>`'${t}' class should be decorated with @Injectable() right after the @State() decorator`};let jd=(()=>{class t{constructor(t,e){this._ngZone=t,this._platformId=e,this.verifyZoneIsNotNooped(this._ngZone)}enter(t){return"server"===this._platformId?this.runInsideAngular(t):this.runOutsideAngular(t)}leave(t){return this.runInsideAngular(t)}runInsideAngular(t){return eu.isInAngularZone()?t():this._ngZone.run(t)}runOutsideAngular(t){return eu.isInAngularZone()?this._ngZone.runOutsideAngular(t):t()}verifyZoneIsNotNooped(t){t instanceof eu||console.warn(Wd.ZONE_WARNING())}}return t.\u0275fac=function(e){return new(e||t)(zr(eu),zr(Bc))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();const Gd=new Er("ROOT_STATE_TOKEN"),qd=new Er("FEATURE_STATE_TOKEN"),Xd=new Er("NGXS_PLUGINS"),Kd=new Er("NG_TEST_MODE"),Yd=new Er("NG_DEV_MODE"),Zd="NGXS_META";let Jd=(()=>{class t{constructor(){this.defaultsState={},this.selectorOptions={injectContainerState:!0,suppressErrors:!0},this.compatibility={strictContentSecurityPolicy:!1},this.executionStrategy=jd}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();class Qd{constructor(t,e,n){this.previousValue=t,this.currentValue=e,this.firstChange=n}}const tp=new Er("NGXS_EXECUTION_STRATEGY");function ep(t){return t.constructor&&t.constructor.type?t.constructor.type:t.type}const np=(t,e,n)=>{t=Object.assign({},t);const r=e.split("."),i=r.length-1;return r.reduce((t,e,r)=>(t[e]=r===i?n:Array.isArray(t[e])?t[e].slice():Object.assign({},t[e]),t&&t[e]),t),t},rp=(t,e)=>e.split(".").reduce((t,e)=>t&&t[e],t);function ip(t){if(!t.hasOwnProperty(Zd)){const e={name:null,actions:{},defaults:{},path:null,makeRootSelector:t=>t.getStateGetter(e.name),children:[]};Object.defineProperty(t,Zd,{value:e})}return sp(t)}function sp(t){return t.NGXS_META}function op(t,e){return e&&e.compatibility&&e.compatibility.strictContentSecurityPolicy?function(t){const e=t.slice();return t=>e.reduce((t,e)=>t&&t[e],t)}(t):function(t){const e=t;let n="store."+e[0],r=0;const i=e.length;let s=n;for(;++r<i;)s=s+" && "+(n=n+"."+e[r]);return new Function("store","return "+s+";")}(t)}function ap(t,e){const n=rp(e.currentAppState,t.path),r=rp(e.newAppState,t.path);return new Qd(n,r,!t.isInitialised)}function lp(...t){return function(t,e,n=cp){const r=t.reduce((t,e)=>(t[ep(e)]=!0,t),{}),i=e&&function(t){return t.reduce((t,e)=>(t[e]=!0,t),{})}(e);return function(t){return t.pipe(function(t,e){return yd(n=>{const r=ep(n.action);return t[r]&&(!e||e[n.status])})}(r,i),n())}}(t,["DISPATCHED"])}function cp(){return et(t=>t.action)}function up(t){return e=>new q(n=>e.subscribe({next(e){t.leave(()=>n.next(e))},error(e){t.leave(()=>n.error(e))},complete(){t.leave(()=>n.complete())}}))}let hp=(()=>{class t{constructor(t){this._executionStrategy=t}enter(t){return this._executionStrategy.enter(t)}leave(t){return this._executionStrategy.leave(t)}}return t.\u0275fac=function(e){return new(e||t)(zr(tp))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();class dp extends J{constructor(){super(...arguments),this._itemQueue=[],this._busyPushingNext=!1}next(t){if(this._busyPushingNext)this._itemQueue.unshift(t);else{for(this._busyPushingNext=!0,super.next(t);this._itemQueue.length>0;){const t=this._itemQueue.pop();super.next(t)}this._busyPushingNext=!1}}}let pp=(()=>{class t extends dp{}return t.\u0275fac=function(e){return fp(e||t)},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();const fp=_r(pp);let mp=(()=>{class t extends q{constructor(t,e){super(n=>{const r=t.pipe(up(e)).subscribe({next:t=>n.next(t),error:t=>n.error(t),complete:()=>n.complete()});n.add(r)})}}return t.\u0275fac=function(e){return new(e||t)(zr(pp),zr(hp))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();const gp=t=>(...e)=>t.shift()(...e,(...e)=>gp(t)(...e));let yp=(()=>{class t extends fd{constructor(){super({})}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})(),vp=(()=>{class t{constructor(t,e){this._parentManager=t,this._pluginHandlers=e,this.plugins=[],this.registerHandlers()}get rootPlugins(){return this._parentManager&&this._parentManager.plugins||this.plugins}registerHandlers(){const t=this.getPluginHandlers();this.rootPlugins.push(...t)}getPluginHandlers(){return(this._pluginHandlers||[]).map(t=>t.handle?t.handle.bind(t):t)}}return t.\u0275fac=function(e){return new(e||t)(zr(t,12),zr(Xd,8))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})(),bp=(()=>{class t extends J{}return t.\u0275fac=function(e){return _p(e||t)},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();const _p=_r(bp);let xp=(()=>{class t{constructor(t,e,n,r,i,s){this._errorHandler=t,this._actions=e,this._actionResults=n,this._pluginManager=r,this._stateStream=i,this._ngxsExecutionStrategy=s}dispatch(t){const e=this._ngxsExecutionStrategy.enter(()=>this.dispatchByEvents(t));return e.subscribe({error:t=>this._ngxsExecutionStrategy.leave(()=>{try{this._errorHandler.handleError(t)}catch(e){}})}),e.pipe(up(this._ngxsExecutionStrategy))}dispatchByEvents(t){return Array.isArray(t)?0===t.length?Zh(this._stateStream.getValue()):md(t.map(t=>this.dispatchSingle(t))):this.dispatchSingle(t)}dispatchSingle(t){if(!ep(t))return Jh(new Error(`This action doesn't have a type property: ${t.constructor.name}`));const e=this._stateStream.getValue();return gp([...this._pluginManager.plugins,(t,n)=>{t!==e&&this._stateStream.next(t);const r=this.getActionResultStream(n);return r.subscribe(t=>this._actions.next(t)),this._actions.next({action:n,status:"DISPATCHED"}),this.createDispatchObservable(r)}])(e,t).pipe(_d())}getActionResultStream(t){return this._actionResults.pipe(yd(e=>e.action===t&&"DISPATCHED"!==e.status),wd(1),_d())}createDispatchObservable(t){return t.pipe(Cd(t=>{switch(t.status){case"SUCCESSFUL":return Zh(this._stateStream.getValue());case"ERRORED":return Jh(t.error);default:return Kh}})).pipe(_d())}}return t.\u0275fac=function(e){return new(e||t)(zr(Di),zr(pp),zr(bp),zr(vp),zr(yp),zr(hp))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();const wp=t=>{Object.freeze(t);const e="function"==typeof t,n=Object.prototype.hasOwnProperty;return Object.getOwnPropertyNames(t).forEach(function(r){!n.call(t,r)||e&&("caller"===r||"callee"===r||"arguments"===r)||null===t[r]||"object"!=typeof t[r]&&"function"!=typeof t[r]||Object.isFrozen(t[r])||wp(t[r])}),t};let Sp=(()=>{class t{constructor(t,e){this.isDevMode=t,this.isTestMode=e}}return t.\u0275fac=function(e){return new(e||t)(zr(Yd),zr(Kd))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})(),Ep=(()=>{class t{constructor(t,e){this._host=t,this._config=e}get isIncorrectProduction(){return!this._host.isDevMode()&&this._config.developmentMode}get isIncorrectDevelopment(){return this._host.isDevMode()&&!this._config.developmentMode}verifyDevMode(){this._host.isTestMode()||(this.isIncorrectProduction?console.warn(Wd.INCORRECT_PRODUCTION()):this.isIncorrectDevelopment&&console.warn(Wd.INCORRECT_DEVELOPMENT()))}}return t.\u0275fac=function(e){return new(e||t)(zr(Sp),zr(Jd))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})(),Cp=(()=>{class t{constructor(t,e,n,r){this._stateStream=t,this._dispatcher=e,this._config=n,r.verifyDevMode()}getRootStateOperations(){const t={getState:()=>this._stateStream.getValue(),setState:t=>this._stateStream.next(t),dispatch:t=>this._dispatcher.dispatch(t)};return this._config.developmentMode?this.ensureStateAndActionsAreImmutable(t):t}ensureStateAndActionsAreImmutable(t){return{getState:()=>t.getState(),setState:e=>{const n=wp(e);return t.setState(n)},dispatch:e=>t.dispatch(e)}}setStateToTheCurrentWithNew(t){const e=this.getRootStateOperations(),n=e.getState();e.setState(Object.assign({},n,t.defaults))}}return t.\u0275fac=function(e){return new(e||t)(zr(yp),zr(xp),zr(Jd),zr(Ep))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})(),Tp=(()=>{class t{constructor(t){this._internalStateOperations=t}createStateContext(t){const e=this._internalStateOperations.getRootStateOperations();function n(e){return rp(e,t.path)}function r(n,r){const i=np(n,t.path,r),s=t.instance;if(s.ngxsOnChanges){const e=ap(t,{currentAppState:n,newAppState:i});s.ngxsOnChanges(e)}return e.setState(i),i}function i(t,e){return r(t,e(n(t)))}return{getState:()=>n(e.getState()),patchState:t=>i(e.getState(),function(t){return e=>{if(Array.isArray(t))throw new Error(Wd.PATCHING_ARRAY());if("object"!=typeof t)throw new Error(Wd.PATCHING_PRIMITIVE());const n=Object.assign({},e);for(const r in t)n[r]=t[r];return n}}(t)),setState(t){const n=e.getState();return"function"==typeof t?i(n,t):r(n,t)},dispatch:t=>e.dispatch(t)}}}return t.\u0275fac=function(e){return new(e||t)(zr(Cp))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})(),Ap=(()=>{class t{static stateNameErrorMessage(t){return Wd.STATE_NAME(t)}static checkCorrectStateName(t){if(!t)throw new Error(Wd.STATE_NAME_PROPERTY());if(!this.stateNameRegex.test(t))throw new Error(this.stateNameErrorMessage(t))}static checkStateNameIsUnique(t,e){const n=this.getValidStateMeta(t).name,r=e[n];if(r&&r!==t)throw new Error(Wd.STATE_UNIQUE(n,t.name,r.name));return n}static getValidStateMeta(t){const e=sp(t);if(!e)throw new Error(Wd.STATE_DECORATOR());return e}}return t.stateNameRegex=new RegExp("^[a-zA-Z0-9_]+$"),t})(),Mp=(()=>{class t{constructor(t,e,n,r,i,s,o){this._injector=t,this._config=e,this._parentFactory=n,this._actions=r,this._actionResults=i,this._stateContextFactory=s,this._initialState=o,this._connected=!1,this._states=[],this._statesByName={},this._statePaths={},this.getRuntimeSelectorContext=ad(()=>{const t=this;return this._parentFactory?this._parentFactory.getRuntimeSelectorContext():{getStateGetter(e){const n=t.statePaths[e];return n?op(n.split("."),t._config):()=>{}},getSelectorOptions:e=>Object.assign({},t._config.selectorOptions,e||{})}})}get states(){return this._parentFactory?this._parentFactory.states:this._states}get statesByName(){return this._parentFactory?this._parentFactory.statesByName:this._statesByName}get statePaths(){return this._parentFactory?this._parentFactory.statePaths:this._statePaths}static cloneDefaults(t){let e={};var n;return e=Array.isArray(t)?t.slice():"object"==typeof(n=t)&&null!==n||"function"==typeof n?Object.assign({},t):void 0===t?{}:t,e}static checkStatesAreValid(t){t.forEach(Ap.getValidStateMeta)}add(e){t.checkStatesAreValid(e);const{newStates:n}=this.addToStatesMap(e);if(!n.length)return[];const r=function(t){const e=e=>{const n=t.find(t=>t===e);if(!n)throw new Error(`Child state not found: ${e}. \r\nYou may have forgotten to add states to module`);return n.NGXS_META.name};return t.reduce((t,n)=>{const{name:r,children:i}=n.NGXS_META;return t[r]=(i||[]).map(e),t},{})}(n),i=function(t){const e=[],n={},r=(i,s=[])=>{Array.isArray(s)||(s=[]),s.push(i),n[i]=!0,t[i].forEach(t=>{if(s.indexOf(t)>=0)throw new Error(`Circular dependency '${t}' is required by '${i}': ${s.join(" -> ")}`);n[t]||r(t,s.slice(0))}),e.indexOf(i)<0&&e.push(i)};return Object.keys(t).forEach(t=>r(t)),e.reverse()}(r),s=function(t,e={}){const n=(t,e)=>{for(const r in t)if(t.hasOwnProperty(r)&&t[r].indexOf(e)>=0){const e=n(t,r);return null!==e?`${e}.${r}`:r}return null};for(const r in t)if(t.hasOwnProperty(r)){const i=n(t,r);e[r]=i?`${i}.${r}`:r}return e}(r),o=n.reduce((t,e)=>(t[e.NGXS_META.name]=e,t),{}),a=[];for(const l of i){const e=o[l],n=s[l],r=e.NGXS_META;this.addRuntimeInfoToMeta(r,n);const i={name:l,path:n,isInitialised:!1,actions:r.actions,instance:this._injector.get(e),defaults:t.cloneDefaults(r.defaults)};this.hasBeenMountedAndBootstrapped(l,n)||a.push(i),this.states.push(i)}return a}addAndReturnDefaults(t){const e=this.add(t||[]);return{defaults:e.reduce((t,e)=>np(t,e.path,e.defaults),{}),states:e}}connectActionHandlers(){this._connected||(this._actions.pipe(yd(t=>"DISPATCHED"===t.status),mt(({action:t})=>this.invokeActions(this._actions,t).pipe(et(()=>({action:t,status:"SUCCESSFUL"})),Md({action:t,status:"CANCELED"}),Id(e=>Zh({action:t,status:"ERRORED",error:e}))))).subscribe(t=>this._actionResults.next(t)),this._connected=!0)}invokeActions(t,e){const n=ep(e),r=[];for(const s of this.states){const o=s.actions[n];if(o)for(const n of o){const o=this._stateContextFactory.createStateContext(s);try{let i=s.instance[n.fn](o,e);i instanceof Promise&&(i=ht(i)),i instanceof q?(i=i.pipe(Md({})),n.options.cancelUncompleted&&(i=i.pipe(Dd(t.pipe(lp(e)))))):i=Zh({}).pipe(_d()),r.push(i)}catch(i){r.push(Jh(i))}}}return r.length||r.push(Zh({})),md(r)}addToStatesMap(t){const e=[],n=this.statesByName;for(const r of t){const t=Ap.checkStateNameIsUnique(r,n);!n[t]&&(e.push(r),n[t]=r)}return{newStates:e}}addRuntimeInfoToMeta(t,e){this.statePaths[t.name]=e,t.path=e}hasBeenMountedAndBootstrapped(t,e){const n=void 0!==rp(this._initialState,e);return this.statesByName[t]&&n}}return t.\u0275fac=function(e){return new(e||t)(zr(Bo),zr(Jd),zr(t,12),zr(pp),zr(bp),zr(Tp),zr(ud,8))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})(),kp=(()=>{class t{constructor(t,e,n){this.internalStateOperations=t,this.stateContextFactory=e,this.bootstrapper=n}ngxsBootstrap(t,e){this.internalStateOperations.getRootStateOperations().dispatch(t).pipe(yd(()=>!!e),$d(()=>this.invokeInit(e.states)),mt(()=>this.bootstrapper.appBootstrapped$),yd(t=>!!t)).subscribe(()=>this.invokeBootstrap(e.states))}invokeInit(t){for(const e of t){const t=e.instance;if(t.ngxsOnChanges){const n=ap(e,{currentAppState:{},newAppState:this.internalStateOperations.getRootStateOperations().getState()});t.ngxsOnChanges(n)}t.ngxsOnInit&&t.ngxsOnInit(this.getStateContext(e)),e.isInitialised=!0}}invokeBootstrap(t){for(const e of t){const t=e.instance;t.ngxsAfterBootstrap&&t.ngxsAfterBootstrap(this.getStateContext(e))}}getStateContext(t){return this.stateContextFactory.createStateContext(t)}}return t.\u0275fac=function(e){return new(e||t)(zr(Cp),zr(Tp),zr(cd))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})(),Rp=(()=>{class t{constructor(t,e,n,r,i,s){this._stateStream=t,this._internalStateOperations=e,this._config=n,this._internalExecutionStrategy=r,this._stateFactory=i,this.initStateStream(s)}dispatch(t){return this._internalStateOperations.getRootStateOperations().dispatch(t)}select(t){const e=this.getStoreBoundSelectorFn(t);return this._stateStream.pipe(et(e),Id(t=>{const{suppressErrors:e}=this._config.selectorOptions;return t instanceof TypeError&&e?Zh(void 0):Jh(t)}),Vd(),up(this._internalExecutionStrategy))}selectOnce(t){return this.select(t).pipe(wd(1))}selectSnapshot(t){return this.getStoreBoundSelectorFn(t)(this._stateStream.getValue())}subscribe(t){return this._stateStream.pipe(up(this._internalExecutionStrategy)).subscribe(t)}snapshot(){return this._internalStateOperations.getRootStateOperations().getState()}reset(t){return this._internalStateOperations.getRootStateOperations().setState(t)}getStoreBoundSelectorFn(t){return function(t){const e=t.NGXS_SELECTOR_META||sp(t);return e&&e.makeRootSelector||(()=>t)}(t)(this._stateFactory.getRuntimeSelectorContext())}initStateStream(t){const e=this._stateStream.value;if(!e||0===Object.keys(e).length){const e=Object.keys(this._config.defaultsState).length>0?Object.assign({},this._config.defaultsState,t):t;this._stateStream.next(e)}}}return t.\u0275fac=function(e){return new(e||t)(zr(yp),zr(Cp),zr(Jd),zr(hp),zr(Mp),zr(ud,8))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})(),Ip=(()=>{class t{constructor(e,n){t.store=e,t.config=n}}return t.\u0275fac=function(e){return new(e||t)(zr(Rp),zr(Jd))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t.store=null,t.config=null,t})();class Np{static get type(){return"@@INIT"}}class Op{constructor(t){this.addedStates=t}static get type(){return"@@UPDATE_STATE"}}const Dp=new rd(1);let Lp,Fp=(()=>{class t{constructor(t,e,n,r,i=[],s){!function(){try{const t=window.ng,e=!(t.probe&&t.coreTokens)&&mu();Dp.next(e)}catch(t){Dp.next(!1)}finally{Dp.complete()}}();const o=t.addAndReturnDefaults(i);e.setStateToTheCurrentWithNew(o),t.connectActionHandlers(),s.ngxsBootstrap(new Np,o)}}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)(zr(Mp),zr(Cp),zr(Rp),zr(Ip),zr(Gd,8),zr(kp))}}),t})(),Pp=(()=>{class t{constructor(e,n,r,i=[],s){const o=t.flattenStates(i),a=r.addAndReturnDefaults(o);a.states.length&&(n.setStateToTheCurrentWithNew(a),s.ngxsBootstrap(new Op(a.defaults),a))}static flattenStates(t=[]){return t.reduce((t,e)=>t.concat(e),[])}}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)(zr(Rp),zr(Cp),zr(Mp),zr(qd,8),zr(kp))}}),t})(),$p=(()=>{class t{static forRoot(e=[],n={}){return{ngModule:Fp,providers:[Mp,Tp,mp,pp,cd,Ep,Sp,kp,xp,bp,Cp,hp,Rp,yp,Ip,vp,...e,...t.ngxsTokenProviders(e,n)]}}static forFeature(t=[]){return{ngModule:Pp,providers:[Mp,vp,...t,{provide:qd,multi:!0,useValue:t}]}}static ngxsTokenProviders(e,n){return[{provide:Kd,useValue:ld},{provide:Yd,useValue:mu},{provide:tp,useClass:n.executionStrategy||jd},{provide:Gd,useValue:e},{provide:t.ROOT_OPTIONS,useValue:n},{provide:Jd,useFactory:t.ngxsConfigFactory,deps:[t.ROOT_OPTIONS]},{provide:zc,useFactory:t.appBootstrapListenerFactory,multi:!0,deps:[cd]},{provide:ud,useFactory:t.getInitialState},{provide:dd,useExisting:Tp},{provide:pd,useExisting:Mp}]}static ngxsConfigFactory(t){return Object.assign(new Jd,t)}static appBootstrapListenerFactory(t){return()=>t.bootstrap()}static getInitialState(){return hd.pop()}}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)}}),t.ROOT_OPTIONS=new Er("ROOT_OPTIONS"),t})();function Bp(t,e){return(n,r)=>{if(n.hasOwnProperty("prototype"))throw new Error(Wd.ACTION_DECORATOR());const i=ip(n.constructor);Array.isArray(t)||(t=[t]);for(const s of t){const t=s.type;i.actions[t]||(i.actions[t]=[]),i.actions[t].push({fn:r,options:e||{},type:t})}}}function zp(t){return e=>{!function(t){Dp.subscribe(e=>{e&&(t.\u0275prov||console.warn(Wd.UNDECORATED_STATE_IN_IVY(t.name)))})}(e);const n=e,r=ip(n),i=Object.getPrototypeOf(n),s=function(e){return Object.assign({},e.NGXS_OPTIONS_META||{},t)}(i);!function(t){const{meta:e,inheritedStateClass:n,optionsWithInheritance:r}=t,{children:i,defaults:s,name:o}=r,a="string"==typeof o?o:o&&o.getName()||null;Ap.checkCorrectStateName(a),n.hasOwnProperty(Zd)&&(e.actions=Object.assign({},e.actions,(n.NGXS_META||{}).actions)),e.children=i,e.defaults=s,e.name=a}({meta:r,inheritedStateClass:i,optionsWithInheritance:s}),n.NGXS_OPTIONS_META=s}}function Vp(t,...e){return function(n,r){const i=r.toString(),s=`__${i}__selector`,o=function(t,e,n=[]){return"string"==typeof(e=e||function(t){const e=t.length-1;return 36===t.charCodeAt(e)?t.slice(0,e):t}(t))?op(n.length?[e,...n]:e.split("."),Ip.config):e}(i,t,e);Object.defineProperties(n,{[s]:{writable:!0,enumerable:!1,configurable:!0},[i]:{enumerable:!0,configurable:!0,get(){return this[s]||(this[s]=function(t){if(!Ip.store)throw new Error(Wd.SELECT_FACTORY_NOT_CONNECTED());return Ip.store.select(t)}(o))}}})}}try{Lp="undefined"!=typeof Intl&&Intl.v8BreakIterator}catch(V3){Lp=!1}let Up,Hp,Wp,jp=(()=>{class t{constructor(t){this._platformId=t,this.isBrowser=this._platformId?"browser"===this._platformId:"object"==typeof document&&!!document,this.EDGE=this.isBrowser&&/(edge)/i.test(navigator.userAgent),this.TRIDENT=this.isBrowser&&/(msie|trident)/i.test(navigator.userAgent),this.BLINK=this.isBrowser&&!(!window.chrome&&!Lp)&&"undefined"!=typeof CSS&&!this.EDGE&&!this.TRIDENT,this.WEBKIT=this.isBrowser&&/AppleWebKit/i.test(navigator.userAgent)&&!this.BLINK&&!this.EDGE&&!this.TRIDENT,this.IOS=this.isBrowser&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!("MSStream"in window),this.FIREFOX=this.isBrowser&&/(firefox|minefield)/i.test(navigator.userAgent),this.ANDROID=this.isBrowser&&/android/i.test(navigator.userAgent)&&!this.TRIDENT,this.SAFARI=this.isBrowser&&/safari/i.test(navigator.userAgent)&&this.WEBKIT}}return t.\u0275fac=function(e){return new(e||t)(zr(Bc))},t.\u0275prov=Pt({factory:function(){return new t(zr(Bc))},token:t,providedIn:"root"}),t})(),Gp=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)}}),t})();function qp(t){return function(){if(null==Up&&"undefined"!=typeof window)try{window.addEventListener("test",null,Object.defineProperty({},"passive",{get:()=>Up=!0}))}finally{Up=Up||!1}return Up}()?t:!!t.capture}function Xp(){if("object"!=typeof document||!document)return 0;if(null==Hp){const t=document.createElement("div"),e=t.style;t.dir="rtl",e.width="1px",e.overflow="auto",e.visibility="hidden",e.pointerEvents="none",e.position="absolute";const n=document.createElement("div"),r=n.style;r.width="2px",r.height="1px",t.appendChild(n),document.body.appendChild(t),Hp=0,0===t.scrollLeft&&(t.scrollLeft=1,Hp=0===t.scrollLeft?1:2),t.parentNode.removeChild(t)}return Hp}function Kp(t){if(function(){if(null==Wp){const t="undefined"!=typeof document?document.head:null;Wp=!(!t||!t.createShadowRoot&&!t.attachShadow)}return Wp}()){const e=t.getRootNode?t.getRootNode():null;if("undefined"!=typeof ShadowRoot&&ShadowRoot&&e instanceof ShadowRoot)return e}return null}function Yp(t,...e){return e.length?e.some(e=>t[e]):t.altKey||t.shiftKey||t.ctrlKey||t.metaKey}const Zp=new Gh(Hh);function Jp(t,e=Zp){return n=>n.lift(new Qp(t,e))}class Qp{constructor(t,e){this.dueTime=t,this.scheduler=e}call(t,e){return e.subscribe(new tf(t,this.dueTime,this.scheduler))}}class tf extends H{constructor(t,e,n){super(t),this.dueTime=e,this.scheduler=n,this.debouncedSubscription=null,this.lastValue=null,this.hasValue=!1}_next(t){this.clearDebounce(),this.lastValue=t,this.hasValue=!0,this.add(this.debouncedSubscription=this.scheduler.schedule(ef,this.dueTime,this))}_complete(){this.debouncedNext(),this.destination.complete()}debouncedNext(){if(this.clearDebounce(),this.hasValue){const{lastValue:t}=this;this.lastValue=null,this.hasValue=!1,this.destination.next(t)}}clearDebounce(){const t=this.debouncedSubscription;null!==t&&(this.remove(t),t.unsubscribe(),this.debouncedSubscription=null)}}function ef(t){t.debouncedNext()}function nf(t){return null!=t&&"false"!=`${t}`}function rf(t,e=0){return function(t){return!isNaN(parseFloat(t))&&!isNaN(Number(t))}(t)?Number(t):e}function sf(t){return Array.isArray(t)?t:[t]}function of(t){return null==t?"":"string"==typeof t?t:`${t}px`}function af(t){return t instanceof dl?t.nativeElement:t}let lf=(()=>{class t{create(t){return"undefined"==typeof MutationObserver?null:new MutationObserver(t)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({factory:function(){return new t},token:t,providedIn:"root"}),t})(),cf=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},providers:[lf]}),t})();function uf(t,e){return(t.getAttribute(e)||"").match(/\S+/g)||[]}const hf="cdk-describedby-message-container",df="cdk-describedby-host";let pf=0;const ff=new Map;let mf=null,gf=(()=>{class t{constructor(t,e){this._platform=e,this._document=t}describe(t,e){this._canBeDescribed(t,e)&&("string"!=typeof e?(this._setMessageId(e),ff.set(e,{messageElement:e,referenceCount:0})):ff.has(e)||this._createMessageElement(e),this._isElementDescribedByMessage(t,e)||this._addMessageReference(t,e))}removeDescription(t,e){if(e&&this._isElementNode(t)){if(this._isElementDescribedByMessage(t,e)&&this._removeMessageReference(t,e),"string"==typeof e){const t=ff.get(e);t&&0===t.referenceCount&&this._deleteMessageElement(e)}mf&&0===mf.childNodes.length&&this._deleteMessagesContainer()}}ngOnDestroy(){const t=this._document.querySelectorAll("[cdk-describedby-host]");for(let e=0;e<t.length;e++)this._removeCdkDescribedByReferenceIds(t[e]),t[e].removeAttribute(df);mf&&this._deleteMessagesContainer(),ff.clear()}_createMessageElement(t){const e=this._document.createElement("div");this._setMessageId(e),e.textContent=t,this._createMessagesContainer(),mf.appendChild(e),ff.set(t,{messageElement:e,referenceCount:0})}_setMessageId(t){t.id||(t.id="cdk-describedby-message-"+pf++)}_deleteMessageElement(t){const e=ff.get(t),n=e&&e.messageElement;mf&&n&&mf.removeChild(n),ff.delete(t)}_createMessagesContainer(){if(!mf){const t=!this._platform||!this._platform.EDGE&&!this._platform.TRIDENT,e=this._document.getElementById(hf);e&&e.parentNode.removeChild(e),mf=this._document.createElement("div"),mf.id=hf,mf.classList.add("cdk-visually-hidden"),mf.setAttribute("aria-hidden",t+""),this._document.body.appendChild(mf)}}_deleteMessagesContainer(){mf&&mf.parentNode&&(mf.parentNode.removeChild(mf),mf=null)}_removeCdkDescribedByReferenceIds(t){const e=uf(t,"aria-describedby").filter(t=>0!=t.indexOf("cdk-describedby-message"));t.setAttribute("aria-describedby",e.join(" "))}_addMessageReference(t,e){const n=ff.get(e);!function(t,e,n){const r=uf(t,e);r.some(t=>t.trim()==n.trim())||(r.push(n.trim()),t.setAttribute(e,r.join(" ")))}(t,"aria-describedby",n.messageElement.id),t.setAttribute(df,""),n.referenceCount++}_removeMessageReference(t,e){const n=ff.get(e);n.referenceCount--,function(t,e,n){const r=uf(t,e).filter(t=>t!=n.trim());r.length?t.setAttribute(e,r.join(" ")):t.removeAttribute(e)}(t,"aria-describedby",n.messageElement.id),t.removeAttribute(df)}_isElementDescribedByMessage(t,e){const n=uf(t,"aria-describedby"),r=ff.get(e),i=r&&r.messageElement.id;return!!i&&-1!=n.indexOf(i)}_canBeDescribed(t,e){if(!this._isElementNode(t))return!1;if(e&&"object"==typeof e)return!0;const n=null==e?"":`${e}`.trim(),r=t.getAttribute("aria-label");return!(!n||r&&r.trim()===n)}_isElementNode(t){return t.nodeType===this._document.ELEMENT_NODE}}return t.\u0275fac=function(e){return new(e||t)(zr(Mu),zr(jp))},t.\u0275prov=Pt({factory:function(){return new t(zr(Mu),zr(jp))},token:t,providedIn:"root"}),t})();class yf extends class{constructor(t){this._items=t,this._activeItemIndex=-1,this._activeItem=null,this._wrap=!1,this._letterKeyStream=new J,this._typeaheadSubscription=z.EMPTY,this._vertical=!0,this._allowedModifierKeys=[],this._homeAndEnd=!1,this._skipPredicateFn=t=>t.disabled,this._pressedLetters=[],this.tabOut=new J,this.change=new J,t instanceof mc&&t.changes.subscribe(t=>{if(this._activeItem){const e=t.toArray().indexOf(this._activeItem);e>-1&&e!==this._activeItemIndex&&(this._activeItemIndex=e)}})}skipPredicate(t){return this._skipPredicateFn=t,this}withWrap(t=!0){return this._wrap=t,this}withVerticalOrientation(t=!0){return this._vertical=t,this}withHorizontalOrientation(t){return this._horizontal=t,this}withAllowedModifierKeys(t){return this._allowedModifierKeys=t,this}withTypeAhead(t=200){if(this._items.length&&this._items.some(t=>"function"!=typeof t.getLabel))throw Error("ListKeyManager items in typeahead mode must implement the `getLabel` method.");return this._typeaheadSubscription.unsubscribe(),this._typeaheadSubscription=this._letterKeyStream.pipe($d(t=>this._pressedLetters.push(t)),Jp(t),yd(()=>this._pressedLetters.length>0),et(()=>this._pressedLetters.join(""))).subscribe(t=>{const e=this._getItemsArray();for(let n=1;n<e.length+1;n++){const r=(this._activeItemIndex+n)%e.length,i=e[r];if(!this._skipPredicateFn(i)&&0===i.getLabel().toUpperCase().trim().indexOf(t)){this.setActiveItem(r);break}}this._pressedLetters=[]}),this}withHomeAndEnd(){return this._homeAndEnd=!0,this}setActiveItem(t){const e=this._activeItem;this.updateActiveItem(t),this._activeItem!==e&&this.change.next(this._activeItemIndex)}onKeydown(t){const e=t.keyCode,n=["altKey","ctrlKey","metaKey","shiftKey"].every(e=>!t[e]||this._allowedModifierKeys.indexOf(e)>-1);switch(e){case 9:return void this.tabOut.next();case 40:if(this._vertical&&n){this.setNextItemActive();break}return;case 38:if(this._vertical&&n){this.setPreviousItemActive();break}return;case 39:if(this._horizontal&&n){"rtl"===this._horizontal?this.setPreviousItemActive():this.setNextItemActive();break}return;case 37:if(this._horizontal&&n){"rtl"===this._horizontal?this.setNextItemActive():this.setPreviousItemActive();break}return;case 36:if(this._homeAndEnd&&n){this.setFirstItemActive();break}return;case 35:if(this._homeAndEnd&&n){this.setLastItemActive();break}return;default:return void((n||Yp(t,"shiftKey"))&&(t.key&&1===t.key.length?this._letterKeyStream.next(t.key.toLocaleUpperCase()):(e>=65&&e<=90||e>=48&&e<=57)&&this._letterKeyStream.next(String.fromCharCode(e))))}this._pressedLetters=[],t.preventDefault()}get activeItemIndex(){return this._activeItemIndex}get activeItem(){return this._activeItem}isTyping(){return this._pressedLetters.length>0}setFirstItemActive(){this._setActiveItemByIndex(0,1)}setLastItemActive(){this._setActiveItemByIndex(this._items.length-1,-1)}setNextItemActive(){this._activeItemIndex<0?this.setFirstItemActive():this._setActiveItemByDelta(1)}setPreviousItemActive(){this._activeItemIndex<0&&this._wrap?this.setLastItemActive():this._setActiveItemByDelta(-1)}updateActiveItem(t){const e=this._getItemsArray(),n="number"==typeof t?t:e.indexOf(t),r=e[n];this._activeItem=null==r?null:r,this._activeItemIndex=n}_setActiveItemByDelta(t){this._wrap?this._setActiveInWrapMode(t):this._setActiveInDefaultMode(t)}_setActiveInWrapMode(t){const e=this._getItemsArray();for(let n=1;n<=e.length;n++){const r=(this._activeItemIndex+t*n+e.length)%e.length;if(!this._skipPredicateFn(e[r]))return void this.setActiveItem(r)}}_setActiveInDefaultMode(t){this._setActiveItemByIndex(this._activeItemIndex+t,t)}_setActiveItemByIndex(t,e){const n=this._getItemsArray();if(n[t]){for(;this._skipPredicateFn(n[t]);)if(!n[t+=e])return;this.setActiveItem(t)}}_getItemsArray(){return this._items instanceof mc?this._items.toArray():this._items}}{constructor(){super(...arguments),this._origin="program"}setFocusOrigin(t){return this._origin=t,this}setActiveItem(t){super.setActiveItem(t),this.activeItem&&this.activeItem.focus(this._origin)}}let vf=(()=>{class t{constructor(t){this._platform=t}isDisabled(t){return t.hasAttribute("disabled")}isVisible(t){return function(t){return!!(t.offsetWidth||t.offsetHeight||"function"==typeof t.getClientRects&&t.getClientRects().length)}(t)&&"visible"===getComputedStyle(t).visibility}isTabbable(t){if(!this._platform.isBrowser)return!1;const e=function(t){try{return t.frameElement}catch(V3){return null}}((n=t).ownerDocument&&n.ownerDocument.defaultView||window);var n;if(e){if(-1===_f(e))return!1;if(!this.isVisible(e))return!1}let r=t.nodeName.toLowerCase(),i=_f(t);return t.hasAttribute("contenteditable")?-1!==i:"iframe"!==r&&"object"!==r&&!(this._platform.WEBKIT&&this._platform.IOS&&!function(t){let e=t.nodeName.toLowerCase(),n="input"===e&&t.type;return"text"===n||"password"===n||"select"===e||"textarea"===e}(t))&&("audio"===r?!!t.hasAttribute("controls")&&-1!==i:"video"===r?-1!==i&&(null!==i||this._platform.FIREFOX||t.hasAttribute("controls")):t.tabIndex>=0)}isFocusable(t,e){return function(t){return!function(t){return function(t){return"input"==t.nodeName.toLowerCase()}(t)&&"hidden"==t.type}(t)&&(function(t){let e=t.nodeName.toLowerCase();return"input"===e||"select"===e||"button"===e||"textarea"===e}(t)||function(t){return function(t){return"a"==t.nodeName.toLowerCase()}(t)&&t.hasAttribute("href")}(t)||t.hasAttribute("contenteditable")||bf(t))}(t)&&!this.isDisabled(t)&&((null==e?void 0:e.ignoreVisibility)||this.isVisible(t))}}return t.\u0275fac=function(e){return new(e||t)(zr(jp))},t.\u0275prov=Pt({factory:function(){return new t(zr(jp))},token:t,providedIn:"root"}),t})();function bf(t){if(!t.hasAttribute("tabindex")||void 0===t.tabIndex)return!1;let e=t.getAttribute("tabindex");return"-32768"!=e&&!(!e||isNaN(parseInt(e,10)))}function _f(t){if(!bf(t))return null;const e=parseInt(t.getAttribute("tabindex")||"",10);return isNaN(e)?-1:e}class xf{constructor(t,e,n,r,i=!1){this._element=t,this._checker=e,this._ngZone=n,this._document=r,this._hasAttached=!1,this.startAnchorListener=()=>this.focusLastTabbableElement(),this.endAnchorListener=()=>this.focusFirstTabbableElement(),this._enabled=!0,i||this.attachAnchors()}get enabled(){return this._enabled}set enabled(t){this._enabled=t,this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}destroy(){const t=this._startAnchor,e=this._endAnchor;t&&(t.removeEventListener("focus",this.startAnchorListener),t.parentNode&&t.parentNode.removeChild(t)),e&&(e.removeEventListener("focus",this.endAnchorListener),e.parentNode&&e.parentNode.removeChild(e)),this._startAnchor=this._endAnchor=null,this._hasAttached=!1}attachAnchors(){return!!this._hasAttached||(this._ngZone.runOutsideAngular(()=>{this._startAnchor||(this._startAnchor=this._createAnchor(),this._startAnchor.addEventListener("focus",this.startAnchorListener)),this._endAnchor||(this._endAnchor=this._createAnchor(),this._endAnchor.addEventListener("focus",this.endAnchorListener))}),this._element.parentNode&&(this._element.parentNode.insertBefore(this._startAnchor,this._element),this._element.parentNode.insertBefore(this._endAnchor,this._element.nextSibling),this._hasAttached=!0),this._hasAttached)}focusInitialElementWhenReady(){return new Promise(t=>{this._executeOnStable(()=>t(this.focusInitialElement()))})}focusFirstTabbableElementWhenReady(){return new Promise(t=>{this._executeOnStable(()=>t(this.focusFirstTabbableElement()))})}focusLastTabbableElementWhenReady(){return new Promise(t=>{this._executeOnStable(()=>t(this.focusLastTabbableElement()))})}_getRegionBoundary(t){let e=this._element.querySelectorAll(`[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`);for(let n=0;n<e.length;n++)e[n].hasAttribute(`cdk-focus-${t}`)?console.warn(`Found use of deprecated attribute 'cdk-focus-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`,e[n]):e[n].hasAttribute(`cdk-focus-region-${t}`)&&console.warn(`Found use of deprecated attribute 'cdk-focus-region-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`,e[n]);return"start"==t?e.length?e[0]:this._getFirstTabbableElement(this._element):e.length?e[e.length-1]:this._getLastTabbableElement(this._element)}focusInitialElement(){const t=this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]");return t?(t.hasAttribute("cdk-focus-initial")&&console.warn("Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0",t),mu()&&!this._checker.isFocusable(t)&&console.warn("Element matching '[cdkFocusInitial]' is not focusable.",t),t.focus(),!0):this.focusFirstTabbableElement()}focusFirstTabbableElement(){const t=this._getRegionBoundary("start");return t&&t.focus(),!!t}focusLastTabbableElement(){const t=this._getRegionBoundary("end");return t&&t.focus(),!!t}hasAttached(){return this._hasAttached}_getFirstTabbableElement(t){if(this._checker.isFocusable(t)&&this._checker.isTabbable(t))return t;let e=t.children||t.childNodes;for(let n=0;n<e.length;n++){let t=e[n].nodeType===this._document.ELEMENT_NODE?this._getFirstTabbableElement(e[n]):null;if(t)return t}return null}_getLastTabbableElement(t){if(this._checker.isFocusable(t)&&this._checker.isTabbable(t))return t;let e=t.children||t.childNodes;for(let n=e.length-1;n>=0;n--){let t=e[n].nodeType===this._document.ELEMENT_NODE?this._getLastTabbableElement(e[n]):null;if(t)return t}return null}_createAnchor(){const t=this._document.createElement("div");return this._toggleAnchorTabIndex(this._enabled,t),t.classList.add("cdk-visually-hidden"),t.classList.add("cdk-focus-trap-anchor"),t.setAttribute("aria-hidden","true"),t}_toggleAnchorTabIndex(t,e){t?e.setAttribute("tabindex","0"):e.removeAttribute("tabindex")}toggleAnchors(t){this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}_executeOnStable(t){this._ngZone.isStable?t():this._ngZone.onStable.asObservable().pipe(wd(1)).subscribe(t)}}let wf=(()=>{class t{constructor(t,e,n){this._checker=t,this._ngZone=e,this._document=n}create(t,e=!1){return new xf(t,this._checker,this._ngZone,this._document,e)}}return t.\u0275fac=function(e){return new(e||t)(zr(vf),zr(eu),zr(Mu))},t.\u0275prov=Pt({factory:function(){return new t(zr(vf),zr(eu),zr(Mu))},token:t,providedIn:"root"}),t})();"undefined"!=typeof Element&&Element;const Sf=new Er("liveAnnouncerElement",{providedIn:"root",factory:function(){return null}}),Ef=new Er("LIVE_ANNOUNCER_DEFAULT_OPTIONS");let Cf=(()=>{class t{constructor(t,e,n,r){this._ngZone=e,this._defaultOptions=r,this._document=n,this._liveElement=t||this._createLiveElement()}announce(t,...e){const n=this._defaultOptions;let r,i;return 1===e.length&&"number"==typeof e[0]?i=e[0]:[r,i]=e,this.clear(),clearTimeout(this._previousTimeout),r||(r=n&&n.politeness?n.politeness:"polite"),null==i&&n&&(i=n.duration),this._liveElement.setAttribute("aria-live",r),this._ngZone.runOutsideAngular(()=>new Promise(e=>{clearTimeout(this._previousTimeout),this._previousTimeout=setTimeout(()=>{this._liveElement.textContent=t,e(),"number"==typeof i&&(this._previousTimeout=setTimeout(()=>this.clear(),i))},100)}))}clear(){this._liveElement&&(this._liveElement.textContent="")}ngOnDestroy(){clearTimeout(this._previousTimeout),this._liveElement&&this._liveElement.parentNode&&(this._liveElement.parentNode.removeChild(this._liveElement),this._liveElement=null)}_createLiveElement(){const t="cdk-live-announcer-element",e=this._document.getElementsByClassName(t),n=this._document.createElement("div");for(let r=0;r<e.length;r++)e[r].parentNode.removeChild(e[r]);return n.classList.add(t),n.classList.add("cdk-visually-hidden"),n.setAttribute("aria-atomic","true"),n.setAttribute("aria-live","polite"),this._document.body.appendChild(n),n}}return t.\u0275fac=function(e){return new(e||t)(zr(Sf,8),zr(eu),zr(Mu),zr(Ef,8))},t.\u0275prov=Pt({factory:function(){return new t(zr(Sf,8),zr(eu),zr(Mu),zr(Ef,8))},token:t,providedIn:"root"}),t})();function Tf(t){return 0===t.buttons}const Af=new Er("cdk-focus-monitor-default-options"),Mf=qp({passive:!0,capture:!0});let kf=(()=>{class t{constructor(t,e,n,r){this._ngZone=t,this._platform=e,this._origin=null,this._windowFocused=!1,this._elementInfo=new Map,this._monitoredElementCount=0,this._rootNodeFocusListenerCount=new Map,this._documentKeydownListener=()=>{this._lastTouchTarget=null,this._setOriginForCurrentEventQueue("keyboard")},this._documentMousedownListener=t=>{if(!this._lastTouchTarget){const e=Tf(t)?"keyboard":"mouse";this._setOriginForCurrentEventQueue(e)}},this._documentTouchstartListener=t=>{null!=this._touchTimeoutId&&clearTimeout(this._touchTimeoutId),this._lastTouchTarget=Rf(t),this._touchTimeoutId=setTimeout(()=>this._lastTouchTarget=null,650)},this._windowFocusListener=()=>{this._windowFocused=!0,this._windowFocusTimeoutId=setTimeout(()=>this._windowFocused=!1)},this._rootNodeFocusAndBlurListener=t=>{const e=Rf(t),n="focus"===t.type?this._onFocus:this._onBlur;for(let r=e;r;r=r.parentElement)n.call(this,t,r)},this._document=n,this._detectionMode=(null==r?void 0:r.detectionMode)||0}monitor(t,e=!1){if(!this._platform.isBrowser)return Zh(null);const n=af(t),r=Kp(n)||this._getDocument(),i=this._elementInfo.get(n);if(i)return e&&(i.checkChildren=!0),i.subject.asObservable();const s={checkChildren:e,subject:new J,rootNode:r};return this._elementInfo.set(n,s),this._registerGlobalListeners(s),s.subject.asObservable()}stopMonitoring(t){const e=af(t),n=this._elementInfo.get(e);n&&(n.subject.complete(),this._setClasses(e),this._elementInfo.delete(e),this._removeGlobalListeners(n))}focusVia(t,e,n){const r=af(t);this._setOriginForCurrentEventQueue(e),"function"==typeof r.focus&&r.focus(n)}ngOnDestroy(){this._elementInfo.forEach((t,e)=>this.stopMonitoring(e))}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_toggleClass(t,e,n){n?t.classList.add(e):t.classList.remove(e)}_getFocusOrigin(t){return this._origin?this._origin:this._windowFocused&&this._lastFocusOrigin?this._lastFocusOrigin:this._wasCausedByTouch(t)?"touch":"program"}_setClasses(t,e){this._toggleClass(t,"cdk-focused",!!e),this._toggleClass(t,"cdk-touch-focused","touch"===e),this._toggleClass(t,"cdk-keyboard-focused","keyboard"===e),this._toggleClass(t,"cdk-mouse-focused","mouse"===e),this._toggleClass(t,"cdk-program-focused","program"===e)}_setOriginForCurrentEventQueue(t){this._ngZone.runOutsideAngular(()=>{this._origin=t,0===this._detectionMode&&(this._originTimeoutId=setTimeout(()=>this._origin=null,1))})}_wasCausedByTouch(t){const e=Rf(t);return this._lastTouchTarget instanceof Node&&e instanceof Node&&(e===this._lastTouchTarget||e.contains(this._lastTouchTarget))}_onFocus(t,e){const n=this._elementInfo.get(e);if(!n||!n.checkChildren&&e!==Rf(t))return;const r=this._getFocusOrigin(t);this._setClasses(e,r),this._emitOrigin(n.subject,r),this._lastFocusOrigin=r}_onBlur(t,e){const n=this._elementInfo.get(e);!n||n.checkChildren&&t.relatedTarget instanceof Node&&e.contains(t.relatedTarget)||(this._setClasses(e),this._emitOrigin(n.subject,null))}_emitOrigin(t,e){this._ngZone.run(()=>t.next(e))}_registerGlobalListeners(t){if(!this._platform.isBrowser)return;const e=t.rootNode,n=this._rootNodeFocusListenerCount.get(e)||0;n||this._ngZone.runOutsideAngular(()=>{e.addEventListener("focus",this._rootNodeFocusAndBlurListener,Mf),e.addEventListener("blur",this._rootNodeFocusAndBlurListener,Mf)}),this._rootNodeFocusListenerCount.set(e,n+1),1==++this._monitoredElementCount&&this._ngZone.runOutsideAngular(()=>{const t=this._getDocument(),e=this._getWindow();t.addEventListener("keydown",this._documentKeydownListener,Mf),t.addEventListener("mousedown",this._documentMousedownListener,Mf),t.addEventListener("touchstart",this._documentTouchstartListener,Mf),e.addEventListener("focus",this._windowFocusListener)})}_removeGlobalListeners(t){const e=t.rootNode;if(this._rootNodeFocusListenerCount.has(e)){const t=this._rootNodeFocusListenerCount.get(e);t>1?this._rootNodeFocusListenerCount.set(e,t-1):(e.removeEventListener("focus",this._rootNodeFocusAndBlurListener,Mf),e.removeEventListener("blur",this._rootNodeFocusAndBlurListener,Mf),this._rootNodeFocusListenerCount.delete(e))}if(!--this._monitoredElementCount){const t=this._getDocument(),e=this._getWindow();t.removeEventListener("keydown",this._documentKeydownListener,Mf),t.removeEventListener("mousedown",this._documentMousedownListener,Mf),t.removeEventListener("touchstart",this._documentTouchstartListener,Mf),e.removeEventListener("focus",this._windowFocusListener),clearTimeout(this._windowFocusTimeoutId),clearTimeout(this._touchTimeoutId),clearTimeout(this._originTimeoutId)}}}return t.\u0275fac=function(e){return new(e||t)(zr(eu),zr(jp),zr(Mu,8),zr(Af,8))},t.\u0275prov=Pt({factory:function(){return new t(zr(eu),zr(jp),zr(Mu,8),zr(Af,8))},token:t,providedIn:"root"}),t})();function Rf(t){return t.composedPath?t.composedPath()[0]:t.target}const If="cdk-high-contrast-black-on-white",Nf="cdk-high-contrast-white-on-black",Of="cdk-high-contrast-active";let Df=(()=>{class t{constructor(t,e){this._platform=t,this._document=e}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const t=this._document.createElement("div");t.style.backgroundColor="rgb(1,2,3)",t.style.position="absolute",this._document.body.appendChild(t);const e=this._document.defaultView||window,n=e&&e.getComputedStyle?e.getComputedStyle(t):null,r=(n&&n.backgroundColor||"").replace(/ /g,"");switch(this._document.body.removeChild(t),r){case"rgb(0,0,0)":return 2;case"rgb(255,255,255)":return 1}return 0}_applyBodyHighContrastModeCssClasses(){if(this._platform.isBrowser&&this._document.body){const t=this._document.body.classList;t.remove(Of),t.remove(If),t.remove(Nf);const e=this.getHighContrastMode();1===e?(t.add(Of),t.add(If)):2===e&&(t.add(Of),t.add(Nf))}}}return t.\u0275fac=function(e){return new(e||t)(zr(jp),zr(Mu))},t.\u0275prov=Pt({factory:function(){return new t(zr(jp),zr(Mu))},token:t,providedIn:"root"}),t})(),Lf=(()=>{class t{constructor(t){t._applyBodyHighContrastModeCssClasses()}}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)(zr(Df))},imports:[[Gp,cf]]}),t})();const Ff=new Er("cdk-dir-doc",{providedIn:"root",factory:function(){return Vr(Mu)}});let Pf=(()=>{class t{constructor(t){if(this.value="ltr",this.change=new pc,t){const e=t.documentElement?t.documentElement.dir:null,n=(t.body?t.body.dir:null)||e;this.value="ltr"===n||"rtl"===n?n:"ltr"}}ngOnDestroy(){this.change.complete()}}return t.\u0275fac=function(e){return new(e||t)(zr(Ff,8))},t.\u0275prov=Pt({factory:function(){return new t(zr(Ff,8))},token:t,providedIn:"root"}),t})(),$f=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)}}),t})();const Bf=new vl("10.1.3");function zf(...t){return vt(1)(Zh(...t))}function Vf(...t){const e=t[t.length-1];return tt(e)?(t.pop(),n=>zf(t,n,e)):e=>zf(t,e)}class Uf{}const Hf="*";function Wf(t,e){return{type:7,name:t,definitions:e,options:{}}}function jf(t,e=null){return{type:4,styles:e,timings:t}}function Gf(t,e=null){return{type:2,steps:t,options:e}}function qf(t){return{type:6,styles:t,offset:null}}function Xf(t,e,n){return{type:0,name:t,styles:e,options:n}}function Kf(t){return{type:5,steps:t}}function Yf(t,e,n=null){return{type:1,expr:t,animation:e,options:n}}function Zf(t){Promise.resolve(null).then(t)}class Jf{constructor(t=0,e=0){this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._started=!1,this._destroyed=!1,this._finished=!1,this._position=0,this.parentPlayer=null,this.totalTime=t+e}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}init(){}play(){this.hasStarted()||(this._onStart(),this.triggerMicrotask()),this._started=!0}triggerMicrotask(){Zf(()=>this._onFinish())}_onStart(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}pause(){}restart(){}finish(){this._onFinish()}destroy(){this._destroyed||(this._destroyed=!0,this.hasStarted()||this._onStart(),this.finish(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){}setPosition(t){this._position=this.totalTime?t*this.totalTime:1}getPosition(){return this.totalTime?this._position/this.totalTime:1}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}}class Qf{constructor(t){this._onDoneFns=[],this._onStartFns=[],this._finished=!1,this._started=!1,this._destroyed=!1,this._onDestroyFns=[],this.parentPlayer=null,this.totalTime=0,this.players=t;let e=0,n=0,r=0;const i=this.players.length;0==i?Zf(()=>this._onFinish()):this.players.forEach(t=>{t.onDone(()=>{++e==i&&this._onFinish()}),t.onDestroy(()=>{++n==i&&this._onDestroy()}),t.onStart(()=>{++r==i&&this._onStart()})}),this.totalTime=this.players.reduce((t,e)=>Math.max(t,e.totalTime),0)}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this.players.forEach(t=>t.init())}onStart(t){this._onStartFns.push(t)}_onStart(){this.hasStarted()||(this._started=!0,this._onStartFns.forEach(t=>t()),this._onStartFns=[])}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}play(){this.parentPlayer||this.init(),this._onStart(),this.players.forEach(t=>t.play())}pause(){this.players.forEach(t=>t.pause())}restart(){this.players.forEach(t=>t.restart())}finish(){this._onFinish(),this.players.forEach(t=>t.finish())}destroy(){this._onDestroy()}_onDestroy(){this._destroyed||(this._destroyed=!0,this._onFinish(),this.players.forEach(t=>t.destroy()),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this.players.forEach(t=>t.reset()),this._destroyed=!1,this._finished=!1,this._started=!1}setPosition(t){const e=t*this.totalTime;this.players.forEach(t=>{const n=t.totalTime?Math.min(1,e/t.totalTime):1;t.setPosition(n)})}getPosition(){const t=this.players.reduce((t,e)=>null===t||e.totalTime>t.totalTime?e:t,null);return null!=t?t.getPosition():0}beforeDestroy(){this.players.forEach(t=>{t.beforeDestroy&&t.beforeDestroy()})}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}}function tm(){return"undefined"!=typeof process&&"[object process]"==={}.toString.call(process)}function em(t){switch(t.length){case 0:return new Jf;case 1:return t[0];default:return new Qf(t)}}function nm(t,e,n,r,i={},s={}){const o=[],a=[];let l=-1,c=null;if(r.forEach(t=>{const n=t.offset,r=n==l,u=r&&c||{};Object.keys(t).forEach(n=>{let r=n,a=t[n];if("offset"!==n)switch(r=e.normalizePropertyName(r,o),a){case"!":a=i[n];break;case Hf:a=s[n];break;default:a=e.normalizeStyleValue(n,r,a,o)}u[r]=a}),r||a.push(u),c=u,l=n}),o.length){const t="\n - ";throw new Error(`Unable to animate due to the following errors:${t}${o.join(t)}`)}return a}function rm(t,e,n,r){switch(e){case"start":t.onStart(()=>r(n&&im(n,"start",t)));break;case"done":t.onDone(()=>r(n&&im(n,"done",t)));break;case"destroy":t.onDestroy(()=>r(n&&im(n,"destroy",t)))}}function im(t,e,n){const r=n.totalTime,i=sm(t.element,t.triggerName,t.fromState,t.toState,e||t.phaseName,null==r?t.totalTime:r,!!n.disabled),s=t._data;return null!=s&&(i._data=s),i}function sm(t,e,n,r,i="",s=0,o){return{element:t,triggerName:e,fromState:n,toState:r,phaseName:i,totalTime:s,disabled:!!o}}function om(t,e,n){let r;return t instanceof Map?(r=t.get(e),r||t.set(e,r=n)):(r=t[e],r||(r=t[e]=n)),r}function am(t){const e=t.indexOf(":");return[t.substring(1,e),t.substr(e+1)]}let lm=(t,e)=>!1,cm=(t,e)=>!1,um=(t,e,n)=>[];const hm=tm();(hm||"undefined"!=typeof Element)&&(lm=(t,e)=>t.contains(e),cm=(()=>{if(hm||Element.prototype.matches)return(t,e)=>t.matches(e);{const t=Element.prototype,e=t.matchesSelector||t.mozMatchesSelector||t.msMatchesSelector||t.oMatchesSelector||t.webkitMatchesSelector;return e?(t,n)=>e.apply(t,[n]):cm}})(),um=(t,e,n)=>{let r=[];if(n){const n=t.querySelectorAll(e);for(let t=0;t<n.length;t++)r.push(n[t])}else{const n=t.querySelector(e);n&&r.push(n)}return r});let dm=null,pm=!1;function fm(t){dm||(dm=("undefined"!=typeof document?document.body:null)||{},pm=!!dm.style&&"WebkitAppearance"in dm.style);let e=!0;return dm.style&&!function(t){return"ebkit"==t.substring(1,6)}(t)&&(e=t in dm.style,!e&&pm)&&(e="Webkit"+t.charAt(0).toUpperCase()+t.substr(1)in dm.style),e}const mm=cm,gm=lm,ym=um;function vm(t){const e={};return Object.keys(t).forEach(n=>{const r=n.replace(/([a-z])([A-Z])/g,"$1-$2");e[r]=t[n]}),e}let bm=(()=>{class t{validateStyleProperty(t){return fm(t)}matchesElement(t,e){return mm(t,e)}containsElement(t,e){return gm(t,e)}query(t,e,n){return ym(t,e,n)}computeStyle(t,e,n){return n||""}animate(t,e,n,r,i,s=[],o){return new Jf(n,r)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})(),_m=(()=>{class t{}return t.NOOP=new bm,t})();const xm="ng-enter",wm="ng-leave",Sm="ng-trigger",Em=".ng-trigger",Cm="ng-animating",Tm=".ng-animating";function Am(t){if("number"==typeof t)return t;const e=t.match(/^(-?[\.\d]+)(m?s)/);return!e||e.length<2?0:Mm(parseFloat(e[1]),e[2])}function Mm(t,e){switch(e){case"s":return 1e3*t;default:return t}}function km(t,e,n){return t.hasOwnProperty("duration")?t:function(t,e,n){let r,i=0,s="";if("string"==typeof t){const n=t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);if(null===n)return e.push(`The provided timing value "${t}" is invalid.`),{duration:0,delay:0,easing:""};r=Mm(parseFloat(n[1]),n[2]);const o=n[3];null!=o&&(i=Mm(parseFloat(o),n[4]));const a=n[5];a&&(s=a)}else r=t;if(!n){let n=!1,s=e.length;r<0&&(e.push("Duration values below 0 are not allowed for this animation step."),n=!0),i<0&&(e.push("Delay values below 0 are not allowed for this animation step."),n=!0),n&&e.splice(s,0,`The provided timing value "${t}" is invalid.`)}return{duration:r,delay:i,easing:s}}(t,e,n)}function Rm(t,e={}){return Object.keys(t).forEach(n=>{e[n]=t[n]}),e}function Im(t,e,n={}){if(e)for(let r in t)n[r]=t[r];else Rm(t,n);return n}function Nm(t,e,n){return n?e+":"+n+";":""}function Om(t){let e="";for(let n=0;n<t.style.length;n++){const r=t.style.item(n);e+=Nm(0,r,t.style.getPropertyValue(r))}for(const n in t.style)t.style.hasOwnProperty(n)&&!n.startsWith("_")&&(e+=Nm(0,n.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase(),t.style[n]));t.setAttribute("style",e)}function Dm(t,e,n){t.style&&(Object.keys(e).forEach(r=>{const i=Um(r);n&&!n.hasOwnProperty(r)&&(n[r]=t.style[i]),t.style[i]=e[r]}),tm()&&Om(t))}function Lm(t,e){t.style&&(Object.keys(e).forEach(e=>{const n=Um(e);t.style[n]=""}),tm()&&Om(t))}function Fm(t){return Array.isArray(t)?1==t.length?t[0]:Gf(t):t}const Pm=new RegExp("{{\\s*(.+?)\\s*}}","g");function $m(t){let e=[];if("string"==typeof t){let n;for(;n=Pm.exec(t);)e.push(n[1]);Pm.lastIndex=0}return e}function Bm(t,e,n){const r=t.toString(),i=r.replace(Pm,(t,r)=>{let i=e[r];return e.hasOwnProperty(r)||(n.push(`Please provide a value for the animation param ${r}`),i=""),i.toString()});return i==r?t:i}function zm(t){const e=[];let n=t.next();for(;!n.done;)e.push(n.value),n=t.next();return e}const Vm=/-+([a-z0-9])/g;function Um(t){return t.replace(Vm,(...t)=>t[1].toUpperCase())}function Hm(t,e){return 0===t||0===e}function Wm(t,e,n){const r=Object.keys(n);if(r.length&&e.length){let s=e[0],o=[];if(r.forEach(t=>{s.hasOwnProperty(t)||o.push(t),s[t]=n[t]}),o.length)for(var i=1;i<e.length;i++){let n=e[i];o.forEach(function(e){n[e]=Gm(t,e)})}}return e}function jm(t,e,n){switch(e.type){case 7:return t.visitTrigger(e,n);case 0:return t.visitState(e,n);case 1:return t.visitTransition(e,n);case 2:return t.visitSequence(e,n);case 3:return t.visitGroup(e,n);case 4:return t.visitAnimate(e,n);case 5:return t.visitKeyframes(e,n);case 6:return t.visitStyle(e,n);case 8:return t.visitReference(e,n);case 9:return t.visitAnimateChild(e,n);case 10:return t.visitAnimateRef(e,n);case 11:return t.visitQuery(e,n);case 12:return t.visitStagger(e,n);default:throw new Error(`Unable to resolve animation metadata node #${e.type}`)}}function Gm(t,e){return window.getComputedStyle(t)[e]}const qm="*";function Xm(t,e){const n=[];return"string"==typeof t?t.split(/\s*,\s*/).forEach(t=>function(t,e,n){if(":"==t[0]){const r=function(t,e){switch(t){case":enter":return"void => *";case":leave":return"* => void";case":increment":return(t,e)=>parseFloat(e)>parseFloat(t);case":decrement":return(t,e)=>parseFloat(e)<parseFloat(t);default:return e.push(`The transition alias value "${t}" is not supported`),"* => *"}}(t,n);if("function"==typeof r)return void e.push(r);t=r}const r=t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);if(null==r||r.length<4)return n.push(`The provided transition expression "${t}" is not supported`),e;const i=r[1],s=r[2],o=r[3];e.push(Zm(i,o)),"<"!=s[0]||i==qm&&o==qm||e.push(Zm(o,i))}(t,n,e)):n.push(t),n}const Km=new Set(["true","1"]),Ym=new Set(["false","0"]);function Zm(t,e){const n=Km.has(t)||Ym.has(t),r=Km.has(e)||Ym.has(e);return(i,s)=>{let o=t==qm||t==i,a=e==qm||e==s;return!o&&n&&"boolean"==typeof i&&(o=i?Km.has(t):Ym.has(t)),!a&&r&&"boolean"==typeof s&&(a=s?Km.has(e):Ym.has(e)),o&&a}}const Jm=new RegExp("s*:selfs*,?","g");function Qm(t,e,n){return new tg(t).build(e,n)}class tg{constructor(t){this._driver=t}build(t,e){const n=new eg(e);return this._resetContextStyleTimingState(n),jm(this,Fm(t),n)}_resetContextStyleTimingState(t){t.currentQuerySelector="",t.collectedStyles={},t.collectedStyles[""]={},t.currentTime=0}visitTrigger(t,e){let n=e.queryCount=0,r=e.depCount=0;const i=[],s=[];return"@"==t.name.charAt(0)&&e.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"),t.definitions.forEach(t=>{if(this._resetContextStyleTimingState(e),0==t.type){const n=t,r=n.name;r.toString().split(/\s*,\s*/).forEach(t=>{n.name=t,i.push(this.visitState(n,e))}),n.name=r}else if(1==t.type){const i=this.visitTransition(t,e);n+=i.queryCount,r+=i.depCount,s.push(i)}else e.errors.push("only state() and transition() definitions can sit inside of a trigger()")}),{type:7,name:t.name,states:i,transitions:s,queryCount:n,depCount:r,options:null}}visitState(t,e){const n=this.visitStyle(t.styles,e),r=t.options&&t.options.params||null;if(n.containsDynamicStyles){const i=new Set,s=r||{};if(n.styles.forEach(t=>{if(ng(t)){const e=t;Object.keys(e).forEach(t=>{$m(e[t]).forEach(t=>{s.hasOwnProperty(t)||i.add(t)})})}}),i.size){const n=zm(i.values());e.errors.push(`state("${t.name}", ...) must define default values for all the following style substitutions: ${n.join(", ")}`)}}return{type:0,name:t.name,style:n,options:r?{params:r}:null}}visitTransition(t,e){e.queryCount=0,e.depCount=0;const n=jm(this,Fm(t.animation),e);return{type:1,matchers:Xm(t.expr,e.errors),animation:n,queryCount:e.queryCount,depCount:e.depCount,options:rg(t.options)}}visitSequence(t,e){return{type:2,steps:t.steps.map(t=>jm(this,t,e)),options:rg(t.options)}}visitGroup(t,e){const n=e.currentTime;let r=0;const i=t.steps.map(t=>{e.currentTime=n;const i=jm(this,t,e);return r=Math.max(r,e.currentTime),i});return e.currentTime=r,{type:3,steps:i,options:rg(t.options)}}visitAnimate(t,e){const n=function(t,e){let n=null;if(t.hasOwnProperty("duration"))n=t;else if("number"==typeof t)return ig(km(t,e).duration,0,"");const r=t;if(r.split(/\s+/).some(t=>"{"==t.charAt(0)&&"{"==t.charAt(1))){const t=ig(0,0,"");return t.dynamic=!0,t.strValue=r,t}return n=n||km(r,e),ig(n.duration,n.delay,n.easing)}(t.timings,e.errors);let r;e.currentAnimateTimings=n;let i=t.styles?t.styles:qf({});if(5==i.type)r=this.visitKeyframes(i,e);else{let i=t.styles,s=!1;if(!i){s=!0;const t={};n.easing&&(t.easing=n.easing),i=qf(t)}e.currentTime+=n.duration+n.delay;const o=this.visitStyle(i,e);o.isEmptyStep=s,r=o}return e.currentAnimateTimings=null,{type:4,timings:n,style:r,options:null}}visitStyle(t,e){const n=this._makeStyleAst(t,e);return this._validateStyleAst(n,e),n}_makeStyleAst(t,e){const n=[];Array.isArray(t.styles)?t.styles.forEach(t=>{"string"==typeof t?t==Hf?n.push(t):e.errors.push(`The provided style string value ${t} is not allowed.`):n.push(t)}):n.push(t.styles);let r=!1,i=null;return n.forEach(t=>{if(ng(t)){const e=t,n=e.easing;if(n&&(i=n,delete e.easing),!r)for(let t in e)if(e[t].toString().indexOf("{{")>=0){r=!0;break}}}),{type:6,styles:n,easing:i,offset:t.offset,containsDynamicStyles:r,options:null}}_validateStyleAst(t,e){const n=e.currentAnimateTimings;let r=e.currentTime,i=e.currentTime;n&&i>0&&(i-=n.duration+n.delay),t.styles.forEach(t=>{"string"!=typeof t&&Object.keys(t).forEach(n=>{if(!this._driver.validateStyleProperty(n))return void e.errors.push(`The provided animation property "${n}" is not a supported CSS property for animations`);const s=e.collectedStyles[e.currentQuerySelector],o=s[n];let a=!0;o&&(i!=r&&i>=o.startTime&&r<=o.endTime&&(e.errors.push(`The CSS property "${n}" that exists between the times of "${o.startTime}ms" and "${o.endTime}ms" is also being animated in a parallel animation between the times of "${i}ms" and "${r}ms"`),a=!1),i=o.startTime),a&&(s[n]={startTime:i,endTime:r}),e.options&&function(t,e,n){const r=e.params||{},i=$m(t);i.length&&i.forEach(t=>{r.hasOwnProperty(t)||n.push(`Unable to resolve the local animation param ${t} in the given list of values`)})}(t[n],e.options,e.errors)})})}visitKeyframes(t,e){const n={type:5,styles:[],options:null};if(!e.currentAnimateTimings)return e.errors.push("keyframes() must be placed inside of a call to animate()"),n;let r=0;const i=[];let s=!1,o=!1,a=0;const l=t.steps.map(t=>{const n=this._makeStyleAst(t,e);let l=null!=n.offset?n.offset:function(t){if("string"==typeof t)return null;let e=null;if(Array.isArray(t))t.forEach(t=>{if(ng(t)&&t.hasOwnProperty("offset")){const n=t;e=parseFloat(n.offset),delete n.offset}});else if(ng(t)&&t.hasOwnProperty("offset")){const n=t;e=parseFloat(n.offset),delete n.offset}return e}(n.styles),c=0;return null!=l&&(r++,c=n.offset=l),o=o||c<0||c>1,s=s||c<a,a=c,i.push(c),n});o&&e.errors.push("Please ensure that all keyframe offsets are between 0 and 1"),s&&e.errors.push("Please ensure that all keyframe offsets are in order");const c=t.steps.length;let u=0;r>0&&r<c?e.errors.push("Not all style() steps within the declared keyframes() contain offsets"):0==r&&(u=1/(c-1));const h=c-1,d=e.currentTime,p=e.currentAnimateTimings,f=p.duration;return l.forEach((t,r)=>{const s=u>0?r==h?1:u*r:i[r],o=s*f;e.currentTime=d+p.delay+o,p.duration=o,this._validateStyleAst(t,e),t.offset=s,n.styles.push(t)}),n}visitReference(t,e){return{type:8,animation:jm(this,Fm(t.animation),e),options:rg(t.options)}}visitAnimateChild(t,e){return e.depCount++,{type:9,options:rg(t.options)}}visitAnimateRef(t,e){return{type:10,animation:this.visitReference(t.animation,e),options:rg(t.options)}}visitQuery(t,e){const n=e.currentQuerySelector,r=t.options||{};e.queryCount++,e.currentQuery=t;const[i,s]=function(t){const e=!!t.split(/\s*,\s*/).find(t=>":self"==t);return e&&(t=t.replace(Jm,"")),[t=t.replace(/@\*/g,Em).replace(/@\w+/g,t=>".ng-trigger-"+t.substr(1)).replace(/:animating/g,Tm),e]}(t.selector);e.currentQuerySelector=n.length?n+" "+i:i,om(e.collectedStyles,e.currentQuerySelector,{});const o=jm(this,Fm(t.animation),e);return e.currentQuery=null,e.currentQuerySelector=n,{type:11,selector:i,limit:r.limit||0,optional:!!r.optional,includeSelf:s,animation:o,originalSelector:t.selector,options:rg(t.options)}}visitStagger(t,e){e.currentQuery||e.errors.push("stagger() can only be used inside of query()");const n="full"===t.timings?{duration:0,delay:0,easing:"full"}:km(t.timings,e.errors,!0);return{type:12,animation:jm(this,Fm(t.animation),e),timings:n,options:null}}}class eg{constructor(t){this.errors=t,this.queryCount=0,this.depCount=0,this.currentTransition=null,this.currentQuery=null,this.currentQuerySelector=null,this.currentAnimateTimings=null,this.currentTime=0,this.collectedStyles={},this.options=null}}function ng(t){return!Array.isArray(t)&&"object"==typeof t}function rg(t){var e;return t?(t=Rm(t)).params&&(t.params=(e=t.params)?Rm(e):null):t={},t}function ig(t,e,n){return{duration:t,delay:e,easing:n}}function sg(t,e,n,r,i,s,o=null,a=!1){return{type:1,element:t,keyframes:e,preStyleProps:n,postStyleProps:r,duration:i,delay:s,totalTime:i+s,easing:o,subTimeline:a}}class og{constructor(){this._map=new Map}consume(t){let e=this._map.get(t);return e?this._map.delete(t):e=[],e}append(t,e){let n=this._map.get(t);n||this._map.set(t,n=[]),n.push(...e)}has(t){return this._map.has(t)}clear(){this._map.clear()}}const ag=new RegExp(":enter","g"),lg=new RegExp(":leave","g");function cg(t,e,n,r,i,s={},o={},a,l,c=[]){return(new ug).buildKeyframes(t,e,n,r,i,s,o,a,l,c)}class ug{buildKeyframes(t,e,n,r,i,s,o,a,l,c=[]){l=l||new og;const u=new dg(t,e,l,r,i,c,[]);u.options=a,u.currentTimeline.setStyles([s],null,u.errors,a),jm(this,n,u);const h=u.timelines.filter(t=>t.containsAnimation());if(h.length&&Object.keys(o).length){const t=h[h.length-1];t.allowOnlyTimelineStyles()||t.setStyles([o],null,u.errors,a)}return h.length?h.map(t=>t.buildKeyframes()):[sg(e,[],[],[],0,0,"",!1)]}visitTrigger(t,e){}visitState(t,e){}visitTransition(t,e){}visitAnimateChild(t,e){const n=e.subInstructions.consume(e.element);if(n){const r=e.createSubContext(t.options),i=e.currentTimeline.currentTime,s=this._visitSubInstructions(n,r,r.options);i!=s&&e.transformIntoNewTimeline(s)}e.previousNode=t}visitAnimateRef(t,e){const n=e.createSubContext(t.options);n.transformIntoNewTimeline(),this.visitReference(t.animation,n),e.transformIntoNewTimeline(n.currentTimeline.currentTime),e.previousNode=t}_visitSubInstructions(t,e,n){let r=e.currentTimeline.currentTime;const i=null!=n.duration?Am(n.duration):null,s=null!=n.delay?Am(n.delay):null;return 0!==i&&t.forEach(t=>{const n=e.appendInstructionToTimeline(t,i,s);r=Math.max(r,n.duration+n.delay)}),r}visitReference(t,e){e.updateOptions(t.options,!0),jm(this,t.animation,e),e.previousNode=t}visitSequence(t,e){const n=e.subContextCount;let r=e;const i=t.options;if(i&&(i.params||i.delay)&&(r=e.createSubContext(i),r.transformIntoNewTimeline(),null!=i.delay)){6==r.previousNode.type&&(r.currentTimeline.snapshotCurrentStyles(),r.previousNode=hg);const t=Am(i.delay);r.delayNextStep(t)}t.steps.length&&(t.steps.forEach(t=>jm(this,t,r)),r.currentTimeline.applyStylesToKeyframe(),r.subContextCount>n&&r.transformIntoNewTimeline()),e.previousNode=t}visitGroup(t,e){const n=[];let r=e.currentTimeline.currentTime;const i=t.options&&t.options.delay?Am(t.options.delay):0;t.steps.forEach(s=>{const o=e.createSubContext(t.options);i&&o.delayNextStep(i),jm(this,s,o),r=Math.max(r,o.currentTimeline.currentTime),n.push(o.currentTimeline)}),n.forEach(t=>e.currentTimeline.mergeTimelineCollectedStyles(t)),e.transformIntoNewTimeline(r),e.previousNode=t}_visitTiming(t,e){if(t.dynamic){const n=t.strValue;return km(e.params?Bm(n,e.params,e.errors):n,e.errors)}return{duration:t.duration,delay:t.delay,easing:t.easing}}visitAnimate(t,e){const n=e.currentAnimateTimings=this._visitTiming(t.timings,e),r=e.currentTimeline;n.delay&&(e.incrementTime(n.delay),r.snapshotCurrentStyles());const i=t.style;5==i.type?this.visitKeyframes(i,e):(e.incrementTime(n.duration),this.visitStyle(i,e),r.applyStylesToKeyframe()),e.currentAnimateTimings=null,e.previousNode=t}visitStyle(t,e){const n=e.currentTimeline,r=e.currentAnimateTimings;!r&&n.getCurrentStyleProperties().length&&n.forwardFrame();const i=r&&r.easing||t.easing;t.isEmptyStep?n.applyEmptyStep(i):n.setStyles(t.styles,i,e.errors,e.options),e.previousNode=t}visitKeyframes(t,e){const n=e.currentAnimateTimings,r=e.currentTimeline.duration,i=n.duration,s=e.createSubContext().currentTimeline;s.easing=n.easing,t.styles.forEach(t=>{s.forwardTime((t.offset||0)*i),s.setStyles(t.styles,t.easing,e.errors,e.options),s.applyStylesToKeyframe()}),e.currentTimeline.mergeTimelineCollectedStyles(s),e.transformIntoNewTimeline(r+i),e.previousNode=t}visitQuery(t,e){const n=e.currentTimeline.currentTime,r=t.options||{},i=r.delay?Am(r.delay):0;i&&(6===e.previousNode.type||0==n&&e.currentTimeline.getCurrentStyleProperties().length)&&(e.currentTimeline.snapshotCurrentStyles(),e.previousNode=hg);let s=n;const o=e.invokeQuery(t.selector,t.originalSelector,t.limit,t.includeSelf,!!r.optional,e.errors);e.currentQueryTotal=o.length;let a=null;o.forEach((n,r)=>{e.currentQueryIndex=r;const o=e.createSubContext(t.options,n);i&&o.delayNextStep(i),n===e.element&&(a=o.currentTimeline),jm(this,t.animation,o),o.currentTimeline.applyStylesToKeyframe(),s=Math.max(s,o.currentTimeline.currentTime)}),e.currentQueryIndex=0,e.currentQueryTotal=0,e.transformIntoNewTimeline(s),a&&(e.currentTimeline.mergeTimelineCollectedStyles(a),e.currentTimeline.snapshotCurrentStyles()),e.previousNode=t}visitStagger(t,e){const n=e.parentContext,r=e.currentTimeline,i=t.timings,s=Math.abs(i.duration),o=s*(e.currentQueryTotal-1);let a=s*e.currentQueryIndex;switch(i.duration<0?"reverse":i.easing){case"reverse":a=o-a;break;case"full":a=n.currentStaggerTime}const l=e.currentTimeline;a&&l.delayNextStep(a);const c=l.currentTime;jm(this,t.animation,e),e.previousNode=t,n.currentStaggerTime=r.currentTime-c+(r.startTime-n.currentTimeline.startTime)}}const hg={};class dg{constructor(t,e,n,r,i,s,o,a){this._driver=t,this.element=e,this.subInstructions=n,this._enterClassName=r,this._leaveClassName=i,this.errors=s,this.timelines=o,this.parentContext=null,this.currentAnimateTimings=null,this.previousNode=hg,this.subContextCount=0,this.options={},this.currentQueryIndex=0,this.currentQueryTotal=0,this.currentStaggerTime=0,this.currentTimeline=a||new pg(this._driver,e,0),o.push(this.currentTimeline)}get params(){return this.options.params}updateOptions(t,e){if(!t)return;const n=t;let r=this.options;null!=n.duration&&(r.duration=Am(n.duration)),null!=n.delay&&(r.delay=Am(n.delay));const i=n.params;if(i){let t=r.params;t||(t=this.options.params={}),Object.keys(i).forEach(n=>{e&&t.hasOwnProperty(n)||(t[n]=Bm(i[n],t,this.errors))})}}_copyOptions(){const t={};if(this.options){const e=this.options.params;if(e){const n=t.params={};Object.keys(e).forEach(t=>{n[t]=e[t]})}}return t}createSubContext(t=null,e,n){const r=e||this.element,i=new dg(this._driver,r,this.subInstructions,this._enterClassName,this._leaveClassName,this.errors,this.timelines,this.currentTimeline.fork(r,n||0));return i.previousNode=this.previousNode,i.currentAnimateTimings=this.currentAnimateTimings,i.options=this._copyOptions(),i.updateOptions(t),i.currentQueryIndex=this.currentQueryIndex,i.currentQueryTotal=this.currentQueryTotal,i.parentContext=this,this.subContextCount++,i}transformIntoNewTimeline(t){return this.previousNode=hg,this.currentTimeline=this.currentTimeline.fork(this.element,t),this.timelines.push(this.currentTimeline),this.currentTimeline}appendInstructionToTimeline(t,e,n){const r={duration:null!=e?e:t.duration,delay:this.currentTimeline.currentTime+(null!=n?n:0)+t.delay,easing:""},i=new fg(this._driver,t.element,t.keyframes,t.preStyleProps,t.postStyleProps,r,t.stretchStartingKeyframe);return this.timelines.push(i),r}incrementTime(t){this.currentTimeline.forwardTime(this.currentTimeline.duration+t)}delayNextStep(t){t>0&&this.currentTimeline.delayNextStep(t)}invokeQuery(t,e,n,r,i,s){let o=[];if(r&&o.push(this.element),t.length>0){t=(t=t.replace(ag,"."+this._enterClassName)).replace(lg,"."+this._leaveClassName);let e=this._driver.query(this.element,t,1!=n);0!==n&&(e=n<0?e.slice(e.length+n,e.length):e.slice(0,n)),o.push(...e)}return i||0!=o.length||s.push(`\`query("${e}")\` returned zero elements. (Use \`query("${e}", { optional: true })\` if you wish to allow this.)`),o}}class pg{constructor(t,e,n,r){this._driver=t,this.element=e,this.startTime=n,this._elementTimelineStylesLookup=r,this.duration=0,this._previousKeyframe={},this._currentKeyframe={},this._keyframes=new Map,this._styleSummary={},this._pendingStyles={},this._backFill={},this._currentEmptyStepKeyframe=null,this._elementTimelineStylesLookup||(this._elementTimelineStylesLookup=new Map),this._localTimelineStyles=Object.create(this._backFill,{}),this._globalTimelineStyles=this._elementTimelineStylesLookup.get(e),this._globalTimelineStyles||(this._globalTimelineStyles=this._localTimelineStyles,this._elementTimelineStylesLookup.set(e,this._localTimelineStyles)),this._loadKeyframe()}containsAnimation(){switch(this._keyframes.size){case 0:return!1;case 1:return this.getCurrentStyleProperties().length>0;default:return!0}}getCurrentStyleProperties(){return Object.keys(this._currentKeyframe)}get currentTime(){return this.startTime+this.duration}delayNextStep(t){const e=1==this._keyframes.size&&Object.keys(this._pendingStyles).length;this.duration||e?(this.forwardTime(this.currentTime+t),e&&this.snapshotCurrentStyles()):this.startTime+=t}fork(t,e){return this.applyStylesToKeyframe(),new pg(this._driver,t,e||this.currentTime,this._elementTimelineStylesLookup)}_loadKeyframe(){this._currentKeyframe&&(this._previousKeyframe=this._currentKeyframe),this._currentKeyframe=this._keyframes.get(this.duration),this._currentKeyframe||(this._currentKeyframe=Object.create(this._backFill,{}),this._keyframes.set(this.duration,this._currentKeyframe))}forwardFrame(){this.duration+=1,this._loadKeyframe()}forwardTime(t){this.applyStylesToKeyframe(),this.duration=t,this._loadKeyframe()}_updateStyle(t,e){this._localTimelineStyles[t]=e,this._globalTimelineStyles[t]=e,this._styleSummary[t]={time:this.currentTime,value:e}}allowOnlyTimelineStyles(){return this._currentEmptyStepKeyframe!==this._currentKeyframe}applyEmptyStep(t){t&&(this._previousKeyframe.easing=t),Object.keys(this._globalTimelineStyles).forEach(t=>{this._backFill[t]=this._globalTimelineStyles[t]||Hf,this._currentKeyframe[t]=Hf}),this._currentEmptyStepKeyframe=this._currentKeyframe}setStyles(t,e,n,r){e&&(this._previousKeyframe.easing=e);const i=r&&r.params||{},s=function(t,e){const n={};let r;return t.forEach(t=>{"*"===t?(r=r||Object.keys(e),r.forEach(t=>{n[t]=Hf})):Im(t,!1,n)}),n}(t,this._globalTimelineStyles);Object.keys(s).forEach(t=>{const e=Bm(s[t],i,n);this._pendingStyles[t]=e,this._localTimelineStyles.hasOwnProperty(t)||(this._backFill[t]=this._globalTimelineStyles.hasOwnProperty(t)?this._globalTimelineStyles[t]:Hf),this._updateStyle(t,e)})}applyStylesToKeyframe(){const t=this._pendingStyles,e=Object.keys(t);0!=e.length&&(this._pendingStyles={},e.forEach(e=>{this._currentKeyframe[e]=t[e]}),Object.keys(this._localTimelineStyles).forEach(t=>{this._currentKeyframe.hasOwnProperty(t)||(this._currentKeyframe[t]=this._localTimelineStyles[t])}))}snapshotCurrentStyles(){Object.keys(this._localTimelineStyles).forEach(t=>{const e=this._localTimelineStyles[t];this._pendingStyles[t]=e,this._updateStyle(t,e)})}getFinalKeyframe(){return this._keyframes.get(this.duration)}get properties(){const t=[];for(let e in this._currentKeyframe)t.push(e);return t}mergeTimelineCollectedStyles(t){Object.keys(t._styleSummary).forEach(e=>{const n=this._styleSummary[e],r=t._styleSummary[e];(!n||r.time>n.time)&&this._updateStyle(e,r.value)})}buildKeyframes(){this.applyStylesToKeyframe();const t=new Set,e=new Set,n=1===this._keyframes.size&&0===this.duration;let r=[];this._keyframes.forEach((i,s)=>{const o=Im(i,!0);Object.keys(o).forEach(n=>{const r=o[n];"!"==r?t.add(n):r==Hf&&e.add(n)}),n||(o.offset=s/this.duration),r.push(o)});const i=t.size?zm(t.values()):[],s=e.size?zm(e.values()):[];if(n){const t=r[0],e=Rm(t);t.offset=0,e.offset=1,r=[t,e]}return sg(this.element,r,i,s,this.duration,this.startTime,this.easing,!1)}}class fg extends pg{constructor(t,e,n,r,i,s,o=!1){super(t,e,s.delay),this.element=e,this.keyframes=n,this.preStyleProps=r,this.postStyleProps=i,this._stretchStartingKeyframe=o,this.timings={duration:s.duration,delay:s.delay,easing:s.easing}}containsAnimation(){return this.keyframes.length>1}buildKeyframes(){let t=this.keyframes,{delay:e,duration:n,easing:r}=this.timings;if(this._stretchStartingKeyframe&&e){const i=[],s=n+e,o=e/s,a=Im(t[0],!1);a.offset=0,i.push(a);const l=Im(t[0],!1);l.offset=mg(o),i.push(l);const c=t.length-1;for(let r=1;r<=c;r++){let o=Im(t[r],!1);o.offset=mg((e+o.offset*n)/s),i.push(o)}n=s,e=0,r="",t=i}return sg(this.element,t,this.preStyleProps,this.postStyleProps,n,e,r,!0)}}function mg(t,e=3){const n=Math.pow(10,e-1);return Math.round(t*n)/n}class gg{}class yg extends gg{normalizePropertyName(t,e){return Um(t)}normalizeStyleValue(t,e,n,r){let i="";const s=n.toString().trim();if(vg[e]&&0!==n&&"0"!==n)if("number"==typeof n)i="px";else{const e=n.match(/^[+-]?[\d\.]+([a-z]*)$/);e&&0==e[1].length&&r.push(`Please provide a CSS unit value for ${t}:${n}`)}return s+i}}const vg=(()=>function(t){const e={};return t.forEach(t=>e[t]=!0),e}("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))();function bg(t,e,n,r,i,s,o,a,l,c,u,h,d){return{type:0,element:t,triggerName:e,isRemovalTransition:i,fromState:n,fromStyles:s,toState:r,toStyles:o,timelines:a,queriedElements:l,preStyleProps:c,postStyleProps:u,totalTime:h,errors:d}}const _g={};class xg{constructor(t,e,n){this._triggerName=t,this.ast=e,this._stateStyles=n}match(t,e,n,r){return function(t,e,n,r,i){return t.some(t=>t(e,n,r,i))}(this.ast.matchers,t,e,n,r)}buildStyles(t,e,n){const r=this._stateStyles["*"],i=this._stateStyles[t],s=r?r.buildStyles(e,n):{};return i?i.buildStyles(e,n):s}build(t,e,n,r,i,s,o,a,l,c){const u=[],h=this.ast.options&&this.ast.options.params||_g,d=this.buildStyles(n,o&&o.params||_g,u),p=a&&a.params||_g,f=this.buildStyles(r,p,u),m=new Set,g=new Map,y=new Map,v="void"===r,b={params:Object.assign(Object.assign({},h),p)},_=c?[]:cg(t,e,this.ast.animation,i,s,d,f,b,l,u);let x=0;if(_.forEach(t=>{x=Math.max(t.duration+t.delay,x)}),u.length)return bg(e,this._triggerName,n,r,v,d,f,[],[],g,y,x,u);_.forEach(t=>{const n=t.element,r=om(g,n,{});t.preStyleProps.forEach(t=>r[t]=!0);const i=om(y,n,{});t.postStyleProps.forEach(t=>i[t]=!0),n!==e&&m.add(n)});const w=zm(m.values());return bg(e,this._triggerName,n,r,v,d,f,_,w,g,y,x)}}class wg{constructor(t,e){this.styles=t,this.defaultParams=e}buildStyles(t,e){const n={},r=Rm(this.defaultParams);return Object.keys(t).forEach(e=>{const n=t[e];null!=n&&(r[e]=n)}),this.styles.styles.forEach(t=>{if("string"!=typeof t){const i=t;Object.keys(i).forEach(t=>{let s=i[t];s.length>1&&(s=Bm(s,r,e)),n[t]=s})}}),n}}class Sg{constructor(t,e){this.name=t,this.ast=e,this.transitionFactories=[],this.states={},e.states.forEach(t=>{this.states[t.name]=new wg(t.style,t.options&&t.options.params||{})}),Eg(this.states,"true","1"),Eg(this.states,"false","0"),e.transitions.forEach(e=>{this.transitionFactories.push(new xg(t,e,this.states))}),this.fallbackTransition=new xg(t,{type:1,animation:{type:2,steps:[],options:null},matchers:[(t,e)=>!0],options:null,queryCount:0,depCount:0},this.states)}get containsQueries(){return this.ast.queryCount>0}matchTransition(t,e,n,r){return this.transitionFactories.find(i=>i.match(t,e,n,r))||null}matchStyles(t,e,n){return this.fallbackTransition.buildStyles(t,e,n)}}function Eg(t,e,n){t.hasOwnProperty(e)?t.hasOwnProperty(n)||(t[n]=t[e]):t.hasOwnProperty(n)&&(t[e]=t[n])}const Cg=new og;class Tg{constructor(t,e,n){this.bodyNode=t,this._driver=e,this._normalizer=n,this._animations={},this._playersById={},this.players=[]}register(t,e){const n=[],r=Qm(this._driver,e,n);if(n.length)throw new Error(`Unable to build the animation due to the following errors: ${n.join("\n")}`);this._animations[t]=r}_buildPlayer(t,e,n){const r=t.element,i=nm(0,this._normalizer,0,t.keyframes,e,n);return this._driver.animate(r,i,t.duration,t.delay,t.easing,[],!0)}create(t,e,n={}){const r=[],i=this._animations[t];let s;const o=new Map;if(i?(s=cg(this._driver,e,i,xm,wm,{},{},n,Cg,r),s.forEach(t=>{const e=om(o,t.element,{});t.postStyleProps.forEach(t=>e[t]=null)})):(r.push("The requested animation doesn't exist or has already been destroyed"),s=[]),r.length)throw new Error(`Unable to create the animation due to the following errors: ${r.join("\n")}`);o.forEach((t,e)=>{Object.keys(t).forEach(n=>{t[n]=this._driver.computeStyle(e,n,Hf)})});const a=em(s.map(t=>{const e=o.get(t.element);return this._buildPlayer(t,{},e)}));return this._playersById[t]=a,a.onDestroy(()=>this.destroy(t)),this.players.push(a),a}destroy(t){const e=this._getPlayer(t);e.destroy(),delete this._playersById[t];const n=this.players.indexOf(e);n>=0&&this.players.splice(n,1)}_getPlayer(t){const e=this._playersById[t];if(!e)throw new Error(`Unable to find the timeline player referenced by ${t}`);return e}listen(t,e,n,r){const i=sm(e,"","","");return rm(this._getPlayer(t),n,i,r),()=>{}}command(t,e,n,r){if("register"==n)return void this.register(t,r[0]);if("create"==n)return void this.create(t,e,r[0]||{});const i=this._getPlayer(t);switch(n){case"play":i.play();break;case"pause":i.pause();break;case"reset":i.reset();break;case"restart":i.restart();break;case"finish":i.finish();break;case"init":i.init();break;case"setPosition":i.setPosition(parseFloat(r[0]));break;case"destroy":this.destroy(t)}}}const Ag="ng-animate-queued",Mg="ng-animate-disabled",kg=".ng-animate-disabled",Rg=[],Ig={namespaceId:"",setForRemoval:!1,setForMove:!1,hasAnimation:!1,removedBeforeQueried:!1},Ng={namespaceId:"",setForMove:!1,setForRemoval:!1,hasAnimation:!1,removedBeforeQueried:!0};class Og{constructor(t,e=""){this.namespaceId=e;const n=t&&t.hasOwnProperty("value");if(this.value=null!=(r=n?t.value:t)?r:null,n){const e=Rm(t);delete e.value,this.options=e}else this.options={};var r;this.options.params||(this.options.params={})}get params(){return this.options.params}absorbOptions(t){const e=t.params;if(e){const t=this.options.params;Object.keys(e).forEach(n=>{null==t[n]&&(t[n]=e[n])})}}}const Dg="void",Lg=new Og(Dg);class Fg{constructor(t,e,n){this.id=t,this.hostElement=e,this._engine=n,this.players=[],this._triggers={},this._queue=[],this._elementListeners=new Map,this._hostClassName="ng-tns-"+t,Hg(e,this._hostClassName)}listen(t,e,n,r){if(!this._triggers.hasOwnProperty(e))throw new Error(`Unable to listen on the animation trigger event "${n}" because the animation trigger "${e}" doesn't exist!`);if(null==n||0==n.length)throw new Error(`Unable to listen on the animation trigger "${e}" because the provided event is undefined!`);if("start"!=(i=n)&&"done"!=i)throw new Error(`The provided animation trigger event "${n}" for the animation trigger "${e}" is not supported!`);var i;const s=om(this._elementListeners,t,[]),o={name:e,phase:n,callback:r};s.push(o);const a=om(this._engine.statesByElement,t,{});return a.hasOwnProperty(e)||(Hg(t,Sm),Hg(t,"ng-trigger-"+e),a[e]=Lg),()=>{this._engine.afterFlush(()=>{const t=s.indexOf(o);t>=0&&s.splice(t,1),this._triggers[e]||delete a[e]})}}register(t,e){return!this._triggers[t]&&(this._triggers[t]=e,!0)}_getTrigger(t){const e=this._triggers[t];if(!e)throw new Error(`The provided animation trigger "${t}" has not been registered!`);return e}trigger(t,e,n,r=!0){const i=this._getTrigger(e),s=new $g(this.id,e,t);let o=this._engine.statesByElement.get(t);o||(Hg(t,Sm),Hg(t,"ng-trigger-"+e),this._engine.statesByElement.set(t,o={}));let a=o[e];const l=new Og(n,this.id);if(!(n&&n.hasOwnProperty("value"))&&a&&l.absorbOptions(a.options),o[e]=l,a||(a=Lg),l.value!==Dg&&a.value===l.value){if(!function(t,e){const n=Object.keys(t),r=Object.keys(e);if(n.length!=r.length)return!1;for(let i=0;i<n.length;i++){const r=n[i];if(!e.hasOwnProperty(r)||t[r]!==e[r])return!1}return!0}(a.params,l.params)){const e=[],n=i.matchStyles(a.value,a.params,e),r=i.matchStyles(l.value,l.params,e);e.length?this._engine.reportError(e):this._engine.afterFlush(()=>{Lm(t,n),Dm(t,r)})}return}const c=om(this._engine.playersByElement,t,[]);c.forEach(t=>{t.namespaceId==this.id&&t.triggerName==e&&t.queued&&t.destroy()});let u=i.matchTransition(a.value,l.value,t,l.params),h=!1;if(!u){if(!r)return;u=i.fallbackTransition,h=!0}return this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:e,transition:u,fromState:a,toState:l,player:s,isFallbackTransition:h}),h||(Hg(t,Ag),s.onStart(()=>{Wg(t,Ag)})),s.onDone(()=>{let e=this.players.indexOf(s);e>=0&&this.players.splice(e,1);const n=this._engine.playersByElement.get(t);if(n){let t=n.indexOf(s);t>=0&&n.splice(t,1)}}),this.players.push(s),c.push(s),s}deregister(t){delete this._triggers[t],this._engine.statesByElement.forEach((e,n)=>{delete e[t]}),this._elementListeners.forEach((e,n)=>{this._elementListeners.set(n,e.filter(e=>e.name!=t))})}clearElementCache(t){this._engine.statesByElement.delete(t),this._elementListeners.delete(t);const e=this._engine.playersByElement.get(t);e&&(e.forEach(t=>t.destroy()),this._engine.playersByElement.delete(t))}_signalRemovalForInnerTriggers(t,e){const n=this._engine.driver.query(t,Em,!0);n.forEach(t=>{if(t.__ng_removed)return;const n=this._engine.fetchNamespacesByElement(t);n.size?n.forEach(n=>n.triggerLeaveAnimation(t,e,!1,!0)):this.clearElementCache(t)}),this._engine.afterFlushAnimationsDone(()=>n.forEach(t=>this.clearElementCache(t)))}triggerLeaveAnimation(t,e,n,r){const i=this._engine.statesByElement.get(t);if(i){const s=[];if(Object.keys(i).forEach(e=>{if(this._triggers[e]){const n=this.trigger(t,e,Dg,r);n&&s.push(n)}}),s.length)return this._engine.markElementAsRemoved(this.id,t,!0,e),n&&em(s).onDone(()=>this._engine.processLeaveNode(t)),!0}return!1}prepareLeaveAnimationListeners(t){const e=this._elementListeners.get(t),n=this._engine.statesByElement.get(t);if(e&&n){const r=new Set;e.forEach(e=>{const i=e.name;if(r.has(i))return;r.add(i);const s=this._triggers[i].fallbackTransition,o=n[i]||Lg,a=new Og(Dg),l=new $g(this.id,i,t);this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:i,transition:s,fromState:o,toState:a,player:l,isFallbackTransition:!0})})}}removeNode(t,e){const n=this._engine;if(t.childElementCount&&this._signalRemovalForInnerTriggers(t,e),this.triggerLeaveAnimation(t,e,!0))return;let r=!1;if(n.totalAnimations){const e=n.players.length?n.playersByQueriedElement.get(t):[];if(e&&e.length)r=!0;else{let e=t;for(;e=e.parentNode;)if(n.statesByElement.get(e)){r=!0;break}}}if(this.prepareLeaveAnimationListeners(t),r)n.markElementAsRemoved(this.id,t,!1,e);else{const r=t.__ng_removed;r&&r!==Ig||(n.afterFlush(()=>this.clearElementCache(t)),n.destroyInnerAnimations(t),n._onRemovalComplete(t,e))}}insertNode(t,e){Hg(t,this._hostClassName)}drainQueuedTransitions(t){const e=[];return this._queue.forEach(n=>{const r=n.player;if(r.destroyed)return;const i=n.element,s=this._elementListeners.get(i);s&&s.forEach(e=>{if(e.name==n.triggerName){const r=sm(i,n.triggerName,n.fromState.value,n.toState.value);r._data=t,rm(n.player,e.phase,r,e.callback)}}),r.markedForDestroy?this._engine.afterFlush(()=>{r.destroy()}):e.push(n)}),this._queue=[],e.sort((t,e)=>{const n=t.transition.ast.depCount,r=e.transition.ast.depCount;return 0==n||0==r?n-r:this._engine.driver.containsElement(t.element,e.element)?1:-1})}destroy(t){this.players.forEach(t=>t.destroy()),this._signalRemovalForInnerTriggers(this.hostElement,t)}elementContainsData(t){let e=!1;return this._elementListeners.has(t)&&(e=!0),e=!!this._queue.find(e=>e.element===t)||e,e}}class Pg{constructor(t,e,n){this.bodyNode=t,this.driver=e,this._normalizer=n,this.players=[],this.newHostElements=new Map,this.playersByElement=new Map,this.playersByQueriedElement=new Map,this.statesByElement=new Map,this.disabledNodes=new Set,this.totalAnimations=0,this.totalQueuedPlayers=0,this._namespaceLookup={},this._namespaceList=[],this._flushFns=[],this._whenQuietFns=[],this.namespacesByHostElement=new Map,this.collectedEnterElements=[],this.collectedLeaveElements=[],this.onRemovalComplete=(t,e)=>{}}_onRemovalComplete(t,e){this.onRemovalComplete(t,e)}get queuedPlayers(){const t=[];return this._namespaceList.forEach(e=>{e.players.forEach(e=>{e.queued&&t.push(e)})}),t}createNamespace(t,e){const n=new Fg(t,e,this);return e.parentNode?this._balanceNamespaceList(n,e):(this.newHostElements.set(e,n),this.collectEnterElement(e)),this._namespaceLookup[t]=n}_balanceNamespaceList(t,e){const n=this._namespaceList.length-1;if(n>=0){let r=!1;for(let i=n;i>=0;i--)if(this.driver.containsElement(this._namespaceList[i].hostElement,e)){this._namespaceList.splice(i+1,0,t),r=!0;break}r||this._namespaceList.splice(0,0,t)}else this._namespaceList.push(t);return this.namespacesByHostElement.set(e,t),t}register(t,e){let n=this._namespaceLookup[t];return n||(n=this.createNamespace(t,e)),n}registerTrigger(t,e,n){let r=this._namespaceLookup[t];r&&r.register(e,n)&&this.totalAnimations++}destroy(t,e){if(!t)return;const n=this._fetchNamespace(t);this.afterFlush(()=>{this.namespacesByHostElement.delete(n.hostElement),delete this._namespaceLookup[t];const e=this._namespaceList.indexOf(n);e>=0&&this._namespaceList.splice(e,1)}),this.afterFlushAnimationsDone(()=>n.destroy(e))}_fetchNamespace(t){return this._namespaceLookup[t]}fetchNamespacesByElement(t){const e=new Set,n=this.statesByElement.get(t);if(n){const t=Object.keys(n);for(let r=0;r<t.length;r++){const i=n[t[r]].namespaceId;if(i){const t=this._fetchNamespace(i);t&&e.add(t)}}}return e}trigger(t,e,n,r){if(Bg(e)){const i=this._fetchNamespace(t);if(i)return i.trigger(e,n,r),!0}return!1}insertNode(t,e,n,r){if(!Bg(e))return;const i=e.__ng_removed;if(i&&i.setForRemoval){i.setForRemoval=!1,i.setForMove=!0;const t=this.collectedLeaveElements.indexOf(e);t>=0&&this.collectedLeaveElements.splice(t,1)}if(t){const r=this._fetchNamespace(t);r&&r.insertNode(e,n)}r&&this.collectEnterElement(e)}collectEnterElement(t){this.collectedEnterElements.push(t)}markElementAsDisabled(t,e){e?this.disabledNodes.has(t)||(this.disabledNodes.add(t),Hg(t,Mg)):this.disabledNodes.has(t)&&(this.disabledNodes.delete(t),Wg(t,Mg))}removeNode(t,e,n,r){if(Bg(e)){const i=t?this._fetchNamespace(t):null;if(i?i.removeNode(e,r):this.markElementAsRemoved(t,e,!1,r),n){const n=this.namespacesByHostElement.get(e);n&&n.id!==t&&n.removeNode(e,r)}}else this._onRemovalComplete(e,r)}markElementAsRemoved(t,e,n,r){this.collectedLeaveElements.push(e),e.__ng_removed={namespaceId:t,setForRemoval:r,hasAnimation:n,removedBeforeQueried:!1}}listen(t,e,n,r,i){return Bg(e)?this._fetchNamespace(t).listen(e,n,r,i):()=>{}}_buildInstruction(t,e,n,r,i){return t.transition.build(this.driver,t.element,t.fromState.value,t.toState.value,n,r,t.fromState.options,t.toState.options,e,i)}destroyInnerAnimations(t){let e=this.driver.query(t,Em,!0);e.forEach(t=>this.destroyActiveAnimationsForElement(t)),0!=this.playersByQueriedElement.size&&(e=this.driver.query(t,Tm,!0),e.forEach(t=>this.finishActiveQueriedAnimationOnElement(t)))}destroyActiveAnimationsForElement(t){const e=this.playersByElement.get(t);e&&e.forEach(t=>{t.queued?t.markedForDestroy=!0:t.destroy()})}finishActiveQueriedAnimationOnElement(t){const e=this.playersByQueriedElement.get(t);e&&e.forEach(t=>t.finish())}whenRenderingDone(){return new Promise(t=>{if(this.players.length)return em(this.players).onDone(()=>t());t()})}processLeaveNode(t){const e=t.__ng_removed;if(e&&e.setForRemoval){if(t.__ng_removed=Ig,e.namespaceId){this.destroyInnerAnimations(t);const n=this._fetchNamespace(e.namespaceId);n&&n.clearElementCache(t)}this._onRemovalComplete(t,e.setForRemoval)}this.driver.matchesElement(t,kg)&&this.markElementAsDisabled(t,!1),this.driver.query(t,kg,!0).forEach(t=>{this.markElementAsDisabled(t,!1)})}flush(t=-1){let e=[];if(this.newHostElements.size&&(this.newHostElements.forEach((t,e)=>this._balanceNamespaceList(t,e)),this.newHostElements.clear()),this.totalAnimations&&this.collectedEnterElements.length)for(let n=0;n<this.collectedEnterElements.length;n++)Hg(this.collectedEnterElements[n],"ng-star-inserted");if(this._namespaceList.length&&(this.totalQueuedPlayers||this.collectedLeaveElements.length)){const n=[];try{e=this._flushAnimations(n,t)}finally{for(let t=0;t<n.length;t++)n[t]()}}else for(let n=0;n<this.collectedLeaveElements.length;n++)this.processLeaveNode(this.collectedLeaveElements[n]);if(this.totalQueuedPlayers=0,this.collectedEnterElements.length=0,this.collectedLeaveElements.length=0,this._flushFns.forEach(t=>t()),this._flushFns=[],this._whenQuietFns.length){const t=this._whenQuietFns;this._whenQuietFns=[],e.length?em(e).onDone(()=>{t.forEach(t=>t())}):t.forEach(t=>t())}}reportError(t){throw new Error(`Unable to process animations due to the following failed trigger transitions\n ${t.join("\n")}`)}_flushAnimations(t,e){const n=new og,r=[],i=new Map,s=[],o=new Map,a=new Map,l=new Map,c=new Set;this.disabledNodes.forEach(t=>{c.add(t);const e=this.driver.query(t,".ng-animate-queued",!0);for(let n=0;n<e.length;n++)c.add(e[n])});const u=this.bodyNode,h=Array.from(this.statesByElement.keys()),d=Ug(h,this.collectedEnterElements),p=new Map;let f=0;d.forEach((t,e)=>{const n=xm+f++;p.set(e,n),t.forEach(t=>Hg(t,n))});const m=[],g=new Set,y=new Set;for(let R=0;R<this.collectedLeaveElements.length;R++){const t=this.collectedLeaveElements[R],e=t.__ng_removed;e&&e.setForRemoval&&(m.push(t),g.add(t),e.hasAnimation?this.driver.query(t,".ng-star-inserted",!0).forEach(t=>g.add(t)):y.add(t))}const v=new Map,b=Ug(h,Array.from(g));b.forEach((t,e)=>{const n=wm+f++;v.set(e,n),t.forEach(t=>Hg(t,n))}),t.push(()=>{d.forEach((t,e)=>{const n=p.get(e);t.forEach(t=>Wg(t,n))}),b.forEach((t,e)=>{const n=v.get(e);t.forEach(t=>Wg(t,n))}),m.forEach(t=>{this.processLeaveNode(t)})});const _=[],x=[];for(let R=this._namespaceList.length-1;R>=0;R--)this._namespaceList[R].drainQueuedTransitions(e).forEach(t=>{const e=t.player,i=t.element;if(_.push(e),this.collectedEnterElements.length){const t=i.__ng_removed;if(t&&t.setForMove)return void e.destroy()}const c=!u||!this.driver.containsElement(u,i),h=v.get(i),d=p.get(i),f=this._buildInstruction(t,n,d,h,c);if(f.errors&&f.errors.length)x.push(f);else{if(c)return e.onStart(()=>Lm(i,f.fromStyles)),e.onDestroy(()=>Dm(i,f.toStyles)),void r.push(e);if(t.isFallbackTransition)return e.onStart(()=>Lm(i,f.fromStyles)),e.onDestroy(()=>Dm(i,f.toStyles)),void r.push(e);f.timelines.forEach(t=>t.stretchStartingKeyframe=!0),n.append(i,f.timelines),s.push({instruction:f,player:e,element:i}),f.queriedElements.forEach(t=>om(o,t,[]).push(e)),f.preStyleProps.forEach((t,e)=>{const n=Object.keys(t);if(n.length){let t=a.get(e);t||a.set(e,t=new Set),n.forEach(e=>t.add(e))}}),f.postStyleProps.forEach((t,e)=>{const n=Object.keys(t);let r=l.get(e);r||l.set(e,r=new Set),n.forEach(t=>r.add(t))})}});if(x.length){const t=[];x.forEach(e=>{t.push(`@${e.triggerName} has failed due to:\n`),e.errors.forEach(e=>t.push(`- ${e}\n`))}),_.forEach(t=>t.destroy()),this.reportError(t)}const w=new Map,S=new Map;s.forEach(t=>{const e=t.element;n.has(e)&&(S.set(e,e),this._beforeAnimationBuild(t.player.namespaceId,t.instruction,w))}),r.forEach(t=>{const e=t.element;this._getPreviousPlayers(e,!1,t.namespaceId,t.triggerName,null).forEach(t=>{om(w,e,[]).push(t),t.destroy()})});const E=m.filter(t=>qg(t,a,l)),C=new Map;Vg(C,this.driver,y,l,Hf).forEach(t=>{qg(t,a,l)&&E.push(t)});const T=new Map;d.forEach((t,e)=>{Vg(T,this.driver,new Set(t),a,"!")}),E.forEach(t=>{const e=C.get(t),n=T.get(t);C.set(t,Object.assign(Object.assign({},e),n))});const A=[],M=[],k={};s.forEach(t=>{const{element:e,player:s,instruction:o}=t;if(n.has(e)){if(c.has(e))return s.onDestroy(()=>Dm(e,o.toStyles)),s.disabled=!0,s.overrideTotalTime(o.totalTime),void r.push(s);let t=k;if(S.size>1){let n=e;const r=[];for(;n=n.parentNode;){const e=S.get(n);if(e){t=e;break}r.push(n)}r.forEach(e=>S.set(e,t))}const n=this._buildAnimation(s.namespaceId,o,w,i,T,C);if(s.setRealPlayer(n),t===k)A.push(s);else{const e=this.playersByElement.get(t);e&&e.length&&(s.parentPlayer=em(e)),r.push(s)}}else Lm(e,o.fromStyles),s.onDestroy(()=>Dm(e,o.toStyles)),M.push(s),c.has(e)&&r.push(s)}),M.forEach(t=>{const e=i.get(t.element);if(e&&e.length){const n=em(e);t.setRealPlayer(n)}}),r.forEach(t=>{t.parentPlayer?t.syncPlayerEvents(t.parentPlayer):t.destroy()});for(let R=0;R<m.length;R++){const t=m[R],e=t.__ng_removed;if(Wg(t,wm),e&&e.hasAnimation)continue;let n=[];if(o.size){let e=o.get(t);e&&e.length&&n.push(...e);let r=this.driver.query(t,Tm,!0);for(let t=0;t<r.length;t++){let e=o.get(r[t]);e&&e.length&&n.push(...e)}}const r=n.filter(t=>!t.destroyed);r.length?jg(this,t,r):this.processLeaveNode(t)}return m.length=0,A.forEach(t=>{this.players.push(t),t.onDone(()=>{t.destroy();const e=this.players.indexOf(t);this.players.splice(e,1)}),t.play()}),A}elementContainsData(t,e){let n=!1;const r=e.__ng_removed;return r&&r.setForRemoval&&(n=!0),this.playersByElement.has(e)&&(n=!0),this.playersByQueriedElement.has(e)&&(n=!0),this.statesByElement.has(e)&&(n=!0),this._fetchNamespace(t).elementContainsData(e)||n}afterFlush(t){this._flushFns.push(t)}afterFlushAnimationsDone(t){this._whenQuietFns.push(t)}_getPreviousPlayers(t,e,n,r,i){let s=[];if(e){const e=this.playersByQueriedElement.get(t);e&&(s=e)}else{const e=this.playersByElement.get(t);if(e){const t=!i||i==Dg;e.forEach(e=>{e.queued||(t||e.triggerName==r)&&s.push(e)})}}return(n||r)&&(s=s.filter(t=>!(n&&n!=t.namespaceId||r&&r!=t.triggerName))),s}_beforeAnimationBuild(t,e,n){const r=e.element,i=e.isRemovalTransition?void 0:t,s=e.isRemovalTransition?void 0:e.triggerName;for(const o of e.timelines){const t=o.element,a=t!==r,l=om(n,t,[]);this._getPreviousPlayers(t,a,i,s,e.toState).forEach(t=>{const e=t.getRealPlayer();e.beforeDestroy&&e.beforeDestroy(),t.destroy(),l.push(t)})}Lm(r,e.fromStyles)}_buildAnimation(t,e,n,r,i,s){const o=e.triggerName,a=e.element,l=[],c=new Set,u=new Set,h=e.timelines.map(e=>{const h=e.element;c.add(h);const d=h.__ng_removed;if(d&&d.removedBeforeQueried)return new Jf(e.duration,e.delay);const p=h!==a,f=function(t){const e=[];return Gg(t,e),e}((n.get(h)||Rg).map(t=>t.getRealPlayer())).filter(t=>!!t.element&&t.element===h),m=i.get(h),g=s.get(h),y=nm(0,this._normalizer,0,e.keyframes,m,g),v=this._buildPlayer(e,y,f);if(e.subTimeline&&r&&u.add(h),p){const e=new $g(t,o,h);e.setRealPlayer(v),l.push(e)}return v});l.forEach(t=>{om(this.playersByQueriedElement,t.element,[]).push(t),t.onDone(()=>function(t,e,n){let r;if(t instanceof Map){if(r=t.get(e),r){if(r.length){const t=r.indexOf(n);r.splice(t,1)}0==r.length&&t.delete(e)}}else if(r=t[e],r){if(r.length){const t=r.indexOf(n);r.splice(t,1)}0==r.length&&delete t[e]}return r}(this.playersByQueriedElement,t.element,t))}),c.forEach(t=>Hg(t,Cm));const d=em(h);return d.onDestroy(()=>{c.forEach(t=>Wg(t,Cm)),Dm(a,e.toStyles)}),u.forEach(t=>{om(r,t,[]).push(d)}),d}_buildPlayer(t,e,n){return e.length>0?this.driver.animate(t.element,e,t.duration,t.delay,t.easing,n):new Jf(t.duration,t.delay)}}class $g{constructor(t,e,n){this.namespaceId=t,this.triggerName=e,this.element=n,this._player=new Jf,this._containsRealPlayer=!1,this._queuedCallbacks={},this.destroyed=!1,this.markedForDestroy=!1,this.disabled=!1,this.queued=!0,this.totalTime=0}setRealPlayer(t){this._containsRealPlayer||(this._player=t,Object.keys(this._queuedCallbacks).forEach(e=>{this._queuedCallbacks[e].forEach(n=>rm(t,e,void 0,n))}),this._queuedCallbacks={},this._containsRealPlayer=!0,this.overrideTotalTime(t.totalTime),this.queued=!1)}getRealPlayer(){return this._player}overrideTotalTime(t){this.totalTime=t}syncPlayerEvents(t){const e=this._player;e.triggerCallback&&t.onStart(()=>e.triggerCallback("start")),t.onDone(()=>this.finish()),t.onDestroy(()=>this.destroy())}_queueEvent(t,e){om(this._queuedCallbacks,t,[]).push(e)}onDone(t){this.queued&&this._queueEvent("done",t),this._player.onDone(t)}onStart(t){this.queued&&this._queueEvent("start",t),this._player.onStart(t)}onDestroy(t){this.queued&&this._queueEvent("destroy",t),this._player.onDestroy(t)}init(){this._player.init()}hasStarted(){return!this.queued&&this._player.hasStarted()}play(){!this.queued&&this._player.play()}pause(){!this.queued&&this._player.pause()}restart(){!this.queued&&this._player.restart()}finish(){this._player.finish()}destroy(){this.destroyed=!0,this._player.destroy()}reset(){!this.queued&&this._player.reset()}setPosition(t){this.queued||this._player.setPosition(t)}getPosition(){return this.queued?0:this._player.getPosition()}triggerCallback(t){const e=this._player;e.triggerCallback&&e.triggerCallback(t)}}function Bg(t){return t&&1===t.nodeType}function zg(t,e){const n=t.style.display;return t.style.display=null!=e?e:"none",n}function Vg(t,e,n,r,i){const s=[];n.forEach(t=>s.push(zg(t)));const o=[];r.forEach((n,r)=>{const s={};n.forEach(t=>{const n=s[t]=e.computeStyle(r,t,i);n&&0!=n.length||(r.__ng_removed=Ng,o.push(r))}),t.set(r,s)});let a=0;return n.forEach(t=>zg(t,s[a++])),o}function Ug(t,e){const n=new Map;if(t.forEach(t=>n.set(t,[])),0==e.length)return n;const r=new Set(e),i=new Map;function s(t){if(!t)return 1;let e=i.get(t);if(e)return e;const o=t.parentNode;return e=n.has(o)?o:r.has(o)?1:s(o),i.set(t,e),e}return e.forEach(t=>{const e=s(t);1!==e&&n.get(e).push(t)}),n}function Hg(t,e){if(t.classList)t.classList.add(e);else{let n=t.$$classes;n||(n=t.$$classes={}),n[e]=!0}}function Wg(t,e){if(t.classList)t.classList.remove(e);else{let n=t.$$classes;n&&delete n[e]}}function jg(t,e,n){em(n).onDone(()=>t.processLeaveNode(e))}function Gg(t,e){for(let n=0;n<t.length;n++){const r=t[n];r instanceof Qf?Gg(r.players,e):e.push(r)}}function qg(t,e,n){const r=n.get(t);if(!r)return!1;let i=e.get(t);return i?r.forEach(t=>i.add(t)):e.set(t,r),n.delete(t),!0}class Xg{constructor(t,e,n){this.bodyNode=t,this._driver=e,this._triggerCache={},this.onRemovalComplete=(t,e)=>{},this._transitionEngine=new Pg(t,e,n),this._timelineEngine=new Tg(t,e,n),this._transitionEngine.onRemovalComplete=(t,e)=>this.onRemovalComplete(t,e)}registerTrigger(t,e,n,r,i){const s=t+"-"+r;let o=this._triggerCache[s];if(!o){const t=[],e=Qm(this._driver,i,t);if(t.length)throw new Error(`The animation trigger "${r}" has failed to build due to the following errors:\n - ${t.join("\n - ")}`);o=function(t,e){return new Sg(t,e)}(r,e),this._triggerCache[s]=o}this._transitionEngine.registerTrigger(e,r,o)}register(t,e){this._transitionEngine.register(t,e)}destroy(t,e){this._transitionEngine.destroy(t,e)}onInsert(t,e,n,r){this._transitionEngine.insertNode(t,e,n,r)}onRemove(t,e,n,r){this._transitionEngine.removeNode(t,e,r||!1,n)}disableAnimations(t,e){this._transitionEngine.markElementAsDisabled(t,e)}process(t,e,n,r){if("@"==n.charAt(0)){const[t,i]=am(n);this._timelineEngine.command(t,e,i,r)}else this._transitionEngine.trigger(t,e,n,r)}listen(t,e,n,r,i){if("@"==n.charAt(0)){const[t,r]=am(n);return this._timelineEngine.listen(t,e,r,i)}return this._transitionEngine.listen(t,e,n,r,i)}flush(t=-1){this._transitionEngine.flush(t)}get players(){return this._transitionEngine.players.concat(this._timelineEngine.players)}whenRenderingDone(){return this._transitionEngine.whenRenderingDone()}}function Kg(t,e){let n=null,r=null;return Array.isArray(e)&&e.length?(n=Zg(e[0]),e.length>1&&(r=Zg(e[e.length-1]))):e&&(n=Zg(e)),n||r?new Yg(t,n,r):null}let Yg=(()=>{class t{constructor(e,n,r){this._element=e,this._startStyles=n,this._endStyles=r,this._state=0;let i=t.initialStylesByElement.get(e);i||t.initialStylesByElement.set(e,i={}),this._initialStyles=i}start(){this._state<1&&(this._startStyles&&Dm(this._element,this._startStyles,this._initialStyles),this._state=1)}finish(){this.start(),this._state<2&&(Dm(this._element,this._initialStyles),this._endStyles&&(Dm(this._element,this._endStyles),this._endStyles=null),this._state=1)}destroy(){this.finish(),this._state<3&&(t.initialStylesByElement.delete(this._element),this._startStyles&&(Lm(this._element,this._startStyles),this._endStyles=null),this._endStyles&&(Lm(this._element,this._endStyles),this._endStyles=null),Dm(this._element,this._initialStyles),this._state=3)}}return t.initialStylesByElement=new WeakMap,t})();function Zg(t){let e=null;const n=Object.keys(t);for(let r=0;r<n.length;r++){const i=n[r];Jg(i)&&(e=e||{},e[i]=t[i])}return e}function Jg(t){return"display"===t||"position"===t}const Qg="animation",ty="animationend";class ey{constructor(t,e,n,r,i,s,o){this._element=t,this._name=e,this._duration=n,this._delay=r,this._easing=i,this._fillMode=s,this._onDoneFn=o,this._finished=!1,this._destroyed=!1,this._startTime=0,this._position=0,this._eventFn=t=>this._handleCallback(t)}apply(){!function(t,e){const n=ay(t,"").trim();n.length&&(function(t,e){let n=0;for(let r=0;r<t.length;r++)","===t.charAt(r)&&n++}(n),e=`${n}, ${e}`),oy(t,"",e)}(this._element,`${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`),sy(this._element,this._eventFn,!1),this._startTime=Date.now()}pause(){ny(this._element,this._name,"paused")}resume(){ny(this._element,this._name,"running")}setPosition(t){const e=ry(this._element,this._name);this._position=t*this._duration,oy(this._element,"Delay",`-${this._position}ms`,e)}getPosition(){return this._position}_handleCallback(t){const e=t._ngTestManualTimestamp||Date.now(),n=1e3*parseFloat(t.elapsedTime.toFixed(3));t.animationName==this._name&&Math.max(e-this._startTime,0)>=this._delay&&n>=this._duration&&this.finish()}finish(){this._finished||(this._finished=!0,this._onDoneFn(),sy(this._element,this._eventFn,!0))}destroy(){this._destroyed||(this._destroyed=!0,this.finish(),function(t,e){const n=ay(t,"").split(","),r=iy(n,e);r>=0&&(n.splice(r,1),oy(t,"",n.join(",")))}(this._element,this._name))}}function ny(t,e,n){oy(t,"PlayState",n,ry(t,e))}function ry(t,e){const n=ay(t,"");return n.indexOf(",")>0?iy(n.split(","),e):iy([n],e)}function iy(t,e){for(let n=0;n<t.length;n++)if(t[n].indexOf(e)>=0)return n;return-1}function sy(t,e,n){n?t.removeEventListener(ty,e):t.addEventListener(ty,e)}function oy(t,e,n,r){const i=Qg+e;if(null!=r){const e=t.style[i];if(e.length){const t=e.split(",");t[r]=n,n=t.join(",")}}t.style[i]=n}function ay(t,e){return t.style[Qg+e]||""}class ly{constructor(t,e,n,r,i,s,o,a){this.element=t,this.keyframes=e,this.animationName=n,this._duration=r,this._delay=i,this._finalStyles=o,this._specialStyles=a,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._started=!1,this.currentSnapshot={},this._state=0,this.easing=s||"linear",this.totalTime=r+i,this._buildStyler()}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}destroy(){this.init(),this._state>=4||(this._state=4,this._styler.destroy(),this._flushStartFns(),this._flushDoneFns(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}_flushDoneFns(){this._onDoneFns.forEach(t=>t()),this._onDoneFns=[]}_flushStartFns(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}finish(){this.init(),this._state>=3||(this._state=3,this._styler.finish(),this._flushStartFns(),this._specialStyles&&this._specialStyles.finish(),this._flushDoneFns())}setPosition(t){this._styler.setPosition(t)}getPosition(){return this._styler.getPosition()}hasStarted(){return this._state>=2}init(){this._state>=1||(this._state=1,this._styler.apply(),this._delay&&this._styler.pause())}play(){this.init(),this.hasStarted()||(this._flushStartFns(),this._state=2,this._specialStyles&&this._specialStyles.start()),this._styler.resume()}pause(){this.init(),this._styler.pause()}restart(){this.reset(),this.play()}reset(){this._styler.destroy(),this._buildStyler(),this._styler.apply()}_buildStyler(){this._styler=new ey(this.element,this.animationName,this._duration,this._delay,this.easing,"forwards",()=>this.finish())}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}beforeDestroy(){this.init();const t={};if(this.hasStarted()){const e=this._state>=3;Object.keys(this._finalStyles).forEach(n=>{"offset"!=n&&(t[n]=e?this._finalStyles[n]:Gm(this.element,n))})}this.currentSnapshot=t}}class cy extends Jf{constructor(t,e){super(),this.element=t,this._startingStyles={},this.__initialized=!1,this._styles=vm(e)}init(){!this.__initialized&&this._startingStyles&&(this.__initialized=!0,Object.keys(this._styles).forEach(t=>{this._startingStyles[t]=this.element.style[t]}),super.init())}play(){this._startingStyles&&(this.init(),Object.keys(this._styles).forEach(t=>this.element.style.setProperty(t,this._styles[t])),super.play())}destroy(){this._startingStyles&&(Object.keys(this._startingStyles).forEach(t=>{const e=this._startingStyles[t];e?this.element.style.setProperty(t,e):this.element.style.removeProperty(t)}),this._startingStyles=null,super.destroy())}}class uy{constructor(){this._count=0,this._head=document.querySelector("head")}validateStyleProperty(t){return fm(t)}matchesElement(t,e){return mm(t,e)}containsElement(t,e){return gm(t,e)}query(t,e,n){return ym(t,e,n)}computeStyle(t,e,n){return window.getComputedStyle(t)[e]}buildKeyframeElement(t,e,n){n=n.map(t=>vm(t));let r=`@keyframes ${e} {\n`,i="";n.forEach(t=>{i=" ";const e=parseFloat(t.offset);r+=`${i}${100*e}% {\n`,i+=" ",Object.keys(t).forEach(e=>{const n=t[e];switch(e){case"offset":return;case"easing":return void(n&&(r+=`${i}animation-timing-function: ${n};\n`));default:return void(r+=`${i}${e}: ${n};\n`)}}),r+=`${i}}\n`}),r+="}\n";const s=document.createElement("style");return s.textContent=r,s}animate(t,e,n,r,i,s=[],o){const a=s.filter(t=>t instanceof ly),l={};Hm(n,r)&&a.forEach(t=>{let e=t.currentSnapshot;Object.keys(e).forEach(t=>l[t]=e[t])});const c=function(t){let e={};return t&&(Array.isArray(t)?t:[t]).forEach(t=>{Object.keys(t).forEach(n=>{"offset"!=n&&"easing"!=n&&(e[n]=t[n])})}),e}(e=Wm(t,e,l));if(0==n)return new cy(t,c);const u="gen_css_kf_"+this._count++,h=this.buildKeyframeElement(t,u,e);document.querySelector("head").appendChild(h);const d=Kg(t,e),p=new ly(t,e,u,n,r,i,c,d);return p.onDestroy(()=>{var t;(t=h).parentNode.removeChild(t)}),p}}class hy{constructor(t,e,n,r){this.element=t,this.keyframes=e,this.options=n,this._specialStyles=r,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._initialized=!1,this._finished=!1,this._started=!1,this._destroyed=!1,this.time=0,this.parentPlayer=null,this.currentSnapshot={},this._duration=n.duration,this._delay=n.delay||0,this.time=this._duration+this._delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this._buildPlayer(),this._preparePlayerBeforeStart()}_buildPlayer(){if(this._initialized)return;this._initialized=!0;const t=this.keyframes;this.domPlayer=this._triggerWebAnimation(this.element,t,this.options),this._finalKeyframe=t.length?t[t.length-1]:{},this.domPlayer.addEventListener("finish",()=>this._onFinish())}_preparePlayerBeforeStart(){this._delay?this._resetDomPlayerState():this.domPlayer.pause()}_triggerWebAnimation(t,e,n){return t.animate(e,n)}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}play(){this._buildPlayer(),this.hasStarted()||(this._onStartFns.forEach(t=>t()),this._onStartFns=[],this._started=!0,this._specialStyles&&this._specialStyles.start()),this.domPlayer.play()}pause(){this.init(),this.domPlayer.pause()}finish(){this.init(),this._specialStyles&&this._specialStyles.finish(),this._onFinish(),this.domPlayer.finish()}reset(){this._resetDomPlayerState(),this._destroyed=!1,this._finished=!1,this._started=!1}_resetDomPlayerState(){this.domPlayer&&this.domPlayer.cancel()}restart(){this.reset(),this.play()}hasStarted(){return this._started}destroy(){this._destroyed||(this._destroyed=!0,this._resetDomPlayerState(),this._onFinish(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}setPosition(t){this.domPlayer.currentTime=t*this.time}getPosition(){return this.domPlayer.currentTime/this.time}get totalTime(){return this._delay+this._duration}beforeDestroy(){const t={};this.hasStarted()&&Object.keys(this._finalKeyframe).forEach(e=>{"offset"!=e&&(t[e]=this._finished?this._finalKeyframe[e]:Gm(this.element,e))}),this.currentSnapshot=t}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}}class dy{constructor(){this._isNativeImpl=/\{\s*\[native\s+code\]\s*\}/.test(py().toString()),this._cssKeyframesDriver=new uy}validateStyleProperty(t){return fm(t)}matchesElement(t,e){return mm(t,e)}containsElement(t,e){return gm(t,e)}query(t,e,n){return ym(t,e,n)}computeStyle(t,e,n){return window.getComputedStyle(t)[e]}overrideWebAnimationsSupport(t){this._isNativeImpl=t}animate(t,e,n,r,i,s=[],o){if(!o&&!this._isNativeImpl)return this._cssKeyframesDriver.animate(t,e,n,r,i,s);const a={duration:n,delay:r,fill:0==r?"both":"forwards"};i&&(a.easing=i);const l={},c=s.filter(t=>t instanceof hy);Hm(n,r)&&c.forEach(t=>{let e=t.currentSnapshot;Object.keys(e).forEach(t=>l[t]=e[t])});const u=Kg(t,e=Wm(t,e=e.map(t=>Im(t,!1)),l));return new hy(t,e,a,u)}}function py(){return"undefined"!=typeof window&&void 0!==window.document&&Element.prototype.animate||{}}let fy=(()=>{class t extends Uf{constructor(t,e){super(),this._nextAnimationId=0,this._renderer=t.createRenderer(e.body,{id:"0",encapsulation:Qt.None,styles:[],data:{animation:[]}})}build(t){const e=this._nextAnimationId.toString();this._nextAnimationId++;const n=Array.isArray(t)?Gf(t):t;return yy(this._renderer,null,e,"register",[n]),new my(e,this._renderer)}}return t.\u0275fac=function(e){return new(e||t)(zr(fl),zr(Mu))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();class my extends class{}{constructor(t,e){super(),this._id=t,this._renderer=e}create(t,e){return new gy(this._id,t,e||{},this._renderer)}}class gy{constructor(t,e,n,r){this.id=t,this.element=e,this._renderer=r,this.parentPlayer=null,this._started=!1,this.totalTime=0,this._command("create",n)}_listen(t,e){return this._renderer.listen(this.element,`@@${this.id}:${t}`,e)}_command(t,...e){return yy(this._renderer,this.element,this.id,t,e)}onDone(t){this._listen("done",t)}onStart(t){this._listen("start",t)}onDestroy(t){this._listen("destroy",t)}init(){this._command("init")}hasStarted(){return this._started}play(){this._command("play"),this._started=!0}pause(){this._command("pause")}restart(){this._command("restart")}finish(){this._command("finish")}destroy(){this._command("destroy")}reset(){this._command("reset")}setPosition(t){this._command("setPosition",t)}getPosition(){var t,e;return null!==(e=null===(t=this._renderer.engine.players[+this.id])||void 0===t?void 0:t.getPosition())&&void 0!==e?e:0}}function yy(t,e,n,r,i){return t.setProperty(e,`@@${n}:${r}`,i)}const vy="@",by="@.disabled";let _y=(()=>{class t{constructor(t,e,n){this.delegate=t,this.engine=e,this._zone=n,this._currentId=0,this._microtaskId=1,this._animationCallbacksBuffer=[],this._rendererCache=new Map,this._cdRecurDepth=0,this.promise=Promise.resolve(0),e.onRemovalComplete=(t,e)=>{e&&e.parentNode(t)&&e.removeChild(t.parentNode,t)}}createRenderer(t,e){const n=this.delegate.createRenderer(t,e);if(!(t&&e&&e.data&&e.data.animation)){let t=this._rendererCache.get(n);return t||(t=new xy("",n,this.engine),this._rendererCache.set(n,t)),t}const r=e.id,i=e.id+"-"+this._currentId;this._currentId++,this.engine.register(i,t);const s=e=>{Array.isArray(e)?e.forEach(s):this.engine.registerTrigger(r,i,t,e.name,e)};return e.data.animation.forEach(s),new wy(this,i,n,this.engine)}begin(){this._cdRecurDepth++,this.delegate.begin&&this.delegate.begin()}_scheduleCountTask(){this.promise.then(()=>{this._microtaskId++})}scheduleListenerCallback(t,e,n){t>=0&&t<this._microtaskId?this._zone.run(()=>e(n)):(0==this._animationCallbacksBuffer.length&&Promise.resolve(null).then(()=>{this._zone.run(()=>{this._animationCallbacksBuffer.forEach(t=>{const[e,n]=t;e(n)}),this._animationCallbacksBuffer=[]})}),this._animationCallbacksBuffer.push([e,n]))}end(){this._cdRecurDepth--,0==this._cdRecurDepth&&this._zone.runOutsideAngular(()=>{this._scheduleCountTask(),this.engine.flush(this._microtaskId)}),this.delegate.end&&this.delegate.end()}whenRenderingDone(){return this.engine.whenRenderingDone()}}return t.\u0275fac=function(e){return new(e||t)(zr(fl),zr(Xg),zr(eu))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();class xy{constructor(t,e,n){this.namespaceId=t,this.delegate=e,this.engine=n,this.destroyNode=this.delegate.destroyNode?t=>e.destroyNode(t):null}get data(){return this.delegate.data}destroy(){this.engine.destroy(this.namespaceId,this.delegate),this.delegate.destroy()}createElement(t,e){return this.delegate.createElement(t,e)}createComment(t){return this.delegate.createComment(t)}createText(t){return this.delegate.createText(t)}appendChild(t,e){this.delegate.appendChild(t,e),this.engine.onInsert(this.namespaceId,e,t,!1)}insertBefore(t,e,n,r=!0){this.delegate.insertBefore(t,e,n),this.engine.onInsert(this.namespaceId,e,t,r)}removeChild(t,e,n){this.engine.onRemove(this.namespaceId,e,this.delegate,n)}selectRootElement(t,e){return this.delegate.selectRootElement(t,e)}parentNode(t){return this.delegate.parentNode(t)}nextSibling(t){return this.delegate.nextSibling(t)}setAttribute(t,e,n,r){this.delegate.setAttribute(t,e,n,r)}removeAttribute(t,e,n){this.delegate.removeAttribute(t,e,n)}addClass(t,e){this.delegate.addClass(t,e)}removeClass(t,e){this.delegate.removeClass(t,e)}setStyle(t,e,n,r){this.delegate.setStyle(t,e,n,r)}removeStyle(t,e,n){this.delegate.removeStyle(t,e,n)}setProperty(t,e,n){e.charAt(0)==vy&&e==by?this.disableAnimations(t,!!n):this.delegate.setProperty(t,e,n)}setValue(t,e){this.delegate.setValue(t,e)}listen(t,e,n){return this.delegate.listen(t,e,n)}disableAnimations(t,e){this.engine.disableAnimations(t,e)}}class wy extends xy{constructor(t,e,n,r){super(e,n,r),this.factory=t,this.namespaceId=e}setProperty(t,e,n){e.charAt(0)==vy?"."==e.charAt(1)&&e==by?this.disableAnimations(t,n=void 0===n||!!n):this.engine.process(this.namespaceId,t,e.substr(1),n):this.delegate.setProperty(t,e,n)}listen(t,e,n){if(e.charAt(0)==vy){const r=function(t){switch(t){case"body":return document.body;case"document":return document;case"window":return window;default:return t}}(t);let i=e.substr(1),s="";return i.charAt(0)!=vy&&([i,s]=function(t){const e=t.indexOf(".");return[t.substring(0,e),t.substr(e+1)]}(i)),this.engine.listen(this.namespaceId,r,i,s,t=>{this.factory.scheduleListenerCallback(t._data||-1,n,t)})}return this.delegate.listen(t,e,n)}}let Sy=(()=>{class t extends Xg{constructor(t,e,n){super(t.body,e,n)}}return t.\u0275fac=function(e){return new(e||t)(zr(Mu),zr(_m),zr(gg))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();const Ey=new Er("AnimationModuleType"),Cy=[{provide:_m,useFactory:function(){return"function"==typeof py()?new dy:new uy}},{provide:Ey,useValue:"BrowserAnimations"},{provide:Uf,useClass:fy},{provide:gg,useFactory:function(){return new yg}},{provide:Xg,useClass:Sy},{provide:fl,useFactory:function(t,e,n){return new _y(t,e,n)},deps:[Ch,Xg,eu]}];let Ty=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},providers:Cy,imports:[Bh]}),t})();const Ay=new vl("10.1.3"),My=new Er("mat-sanity-checks",{providedIn:"root",factory:function(){return!0}});let ky,Ry=(()=>{class t{constructor(t,e,n){this._hasDoneGlobalChecks=!1,this._document=n,t._applyBodyHighContrastModeCssClasses(),this._sanityChecks=e,this._hasDoneGlobalChecks||(this._checkDoctypeIsDefined(),this._checkThemeIsPresent(),this._checkCdkVersionMatch(),this._hasDoneGlobalChecks=!0)}_getDocument(){const t=this._document||document;return"object"==typeof t&&t?t:null}_getWindow(){const t=this._getDocument(),e=(null==t?void 0:t.defaultView)||window;return"object"==typeof e&&e?e:null}_checksAreEnabled(){return mu()&&!this._isTestEnv()}_isTestEnv(){const t=this._getWindow();return t&&(t.__karma__||t.jasmine)}_checkDoctypeIsDefined(){const t=this._checksAreEnabled()&&(!0===this._sanityChecks||this._sanityChecks.doctype),e=this._getDocument();t&&e&&!e.doctype&&console.warn("Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.")}_checkThemeIsPresent(){const t=!this._checksAreEnabled()||!1===this._sanityChecks||!this._sanityChecks.theme,e=this._getDocument();if(t||!e||!e.body||"function"!=typeof getComputedStyle)return;const n=e.createElement("div");n.classList.add("mat-theme-loaded-marker"),e.body.appendChild(n);const r=getComputedStyle(n);r&&"none"!==r.display&&console.warn("Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming"),e.body.removeChild(n)}_checkCdkVersionMatch(){this._checksAreEnabled()&&(!0===this._sanityChecks||this._sanityChecks.version)&&Ay.full!==Bf.full&&console.warn("The Angular Material version ("+Ay.full+") does not match the Angular CDK version ("+Bf.full+").\nPlease ensure the versions of these two packages exactly match.")}}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)(zr(Df),zr(My,8),zr(Mu,8))},imports:[[$f],$f]}),t})();function Iy(t){return class extends t{constructor(...t){super(...t),this._disabled=!1}get disabled(){return this._disabled}set disabled(t){this._disabled=nf(t)}}}function Ny(t,e){return class extends t{constructor(...t){super(...t),this.color=e}get color(){return this._color}set color(t){const n=t||e;n!==this._color&&(this._color&&this._elementRef.nativeElement.classList.remove(`mat-${this._color}`),n&&this._elementRef.nativeElement.classList.add(`mat-${n}`),this._color=n)}}}function Oy(t){return class extends t{constructor(...t){super(...t),this._disableRipple=!1}get disableRipple(){return this._disableRipple}set disableRipple(t){this._disableRipple=nf(t)}}}try{ky="undefined"!=typeof Intl}catch(V3){ky=!1}let Dy=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=xe({type:t,selectors:[["","mat-line",""],["","matLine",""]],hostAttrs:[1,"mat-line"]}),t})();function Ly(t,e,n){const r=t.nativeElement.classList;n?r.add(e):r.remove(e)}let Fy=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},imports:[[Ry],Ry]}),t})();class Py{constructor(t,e,n){this._renderer=t,this.element=e,this.config=n,this.state=3}fadeOut(){this._renderer.fadeOutRipple(this)}}const $y={enterDuration:450,exitDuration:400},By=qp({passive:!0}),zy=["mousedown","touchstart"],Vy=["mouseup","mouseleave","touchend","touchcancel"];class Uy{constructor(t,e,n,r){this._target=t,this._ngZone=e,this._isPointerDown=!1,this._activeRipples=new Set,this._pointerUpEventsRegistered=!1,r.isBrowser&&(this._containerElement=af(n))}fadeInRipple(t,e,n={}){const r=this._containerRect=this._containerRect||this._containerElement.getBoundingClientRect(),i=Object.assign(Object.assign({},$y),n.animation);n.centered&&(t=r.left+r.width/2,e=r.top+r.height/2);const s=n.radius||function(t,e,n){const r=Math.max(Math.abs(t-n.left),Math.abs(t-n.right)),i=Math.max(Math.abs(e-n.top),Math.abs(e-n.bottom));return Math.sqrt(r*r+i*i)}(t,e,r),o=t-r.left,a=e-r.top,l=i.enterDuration,c=document.createElement("div");c.classList.add("mat-ripple-element"),c.style.left=o-s+"px",c.style.top=a-s+"px",c.style.height=2*s+"px",c.style.width=2*s+"px",null!=n.color&&(c.style.backgroundColor=n.color),c.style.transitionDuration=`${l}ms`,this._containerElement.appendChild(c),window.getComputedStyle(c).getPropertyValue("opacity"),c.style.transform="scale(1)";const u=new Py(this,c,n);return u.state=0,this._activeRipples.add(u),n.persistent||(this._mostRecentTransientRipple=u),this._runTimeoutOutsideZone(()=>{const t=u===this._mostRecentTransientRipple;u.state=1,n.persistent||t&&this._isPointerDown||u.fadeOut()},l),u}fadeOutRipple(t){const e=this._activeRipples.delete(t);if(t===this._mostRecentTransientRipple&&(this._mostRecentTransientRipple=null),this._activeRipples.size||(this._containerRect=null),!e)return;const n=t.element,r=Object.assign(Object.assign({},$y),t.config.animation);n.style.transitionDuration=`${r.exitDuration}ms`,n.style.opacity="0",t.state=2,this._runTimeoutOutsideZone(()=>{t.state=3,n.parentNode.removeChild(n)},r.exitDuration)}fadeOutAll(){this._activeRipples.forEach(t=>t.fadeOut())}setupTriggerEvents(t){const e=af(t);e&&e!==this._triggerElement&&(this._removeTriggerEvents(),this._triggerElement=e,this._registerEvents(zy))}handleEvent(t){"mousedown"===t.type?this._onMousedown(t):"touchstart"===t.type?this._onTouchStart(t):this._onPointerUp(),this._pointerUpEventsRegistered||(this._registerEvents(Vy),this._pointerUpEventsRegistered=!0)}_onMousedown(t){const e=Tf(t),n=this._lastTouchStartEvent&&Date.now()<this._lastTouchStartEvent+800;this._target.rippleDisabled||e||n||(this._isPointerDown=!0,this.fadeInRipple(t.clientX,t.clientY,this._target.rippleConfig))}_onTouchStart(t){if(!this._target.rippleDisabled){this._lastTouchStartEvent=Date.now(),this._isPointerDown=!0;const e=t.changedTouches;for(let t=0;t<e.length;t++)this.fadeInRipple(e[t].clientX,e[t].clientY,this._target.rippleConfig)}}_onPointerUp(){this._isPointerDown&&(this._isPointerDown=!1,this._activeRipples.forEach(t=>{!t.config.persistent&&(1===t.state||t.config.terminateOnPointerUp&&0===t.state)&&t.fadeOut()}))}_runTimeoutOutsideZone(t,e=0){this._ngZone.runOutsideAngular(()=>setTimeout(t,e))}_registerEvents(t){this._ngZone.runOutsideAngular(()=>{t.forEach(t=>{this._triggerElement.addEventListener(t,this,By)})})}_removeTriggerEvents(){this._triggerElement&&(zy.forEach(t=>{this._triggerElement.removeEventListener(t,this,By)}),this._pointerUpEventsRegistered&&Vy.forEach(t=>{this._triggerElement.removeEventListener(t,this,By)}))}}const Hy=new Er("mat-ripple-global-options");let Wy=(()=>{class t{constructor(t,e,n,r,i){this._elementRef=t,this._animationMode=i,this.radius=0,this._disabled=!1,this._isInitialized=!1,this._globalOptions=r||{},this._rippleRenderer=new Uy(this,e,t,n)}get disabled(){return this._disabled}set disabled(t){this._disabled=t,this._setupTriggerEventsIfEnabled()}get trigger(){return this._trigger||this._elementRef.nativeElement}set trigger(t){this._trigger=t,this._setupTriggerEventsIfEnabled()}ngOnInit(){this._isInitialized=!0,this._setupTriggerEventsIfEnabled()}ngOnDestroy(){this._rippleRenderer._removeTriggerEvents()}fadeOutAll(){this._rippleRenderer.fadeOutAll()}get rippleConfig(){return{centered:this.centered,radius:this.radius,color:this.color,animation:Object.assign(Object.assign(Object.assign({},this._globalOptions.animation),"NoopAnimations"===this._animationMode?{enterDuration:0,exitDuration:0}:{}),this.animation),terminateOnPointerUp:this._globalOptions.terminateOnPointerUp}}get rippleDisabled(){return this.disabled||!!this._globalOptions.disabled}_setupTriggerEventsIfEnabled(){!this.disabled&&this._isInitialized&&this._rippleRenderer.setupTriggerEvents(this.trigger)}launch(t,e=0,n){return"number"==typeof t?this._rippleRenderer.fadeInRipple(t,e,Object.assign(Object.assign({},this.rippleConfig),n)):this._rippleRenderer.fadeInRipple(0,0,Object.assign(Object.assign({},this.rippleConfig),t))}}return t.\u0275fac=function(e){return new(e||t)(ta(dl),ta(eu),ta(jp),ta(Hy,8),ta(Ey,8))},t.\u0275dir=xe({type:t,selectors:[["","mat-ripple",""],["","matRipple",""]],hostAttrs:[1,"mat-ripple"],hostVars:2,hostBindings:function(t,e){2&t&&ka("mat-ripple-unbounded",e.unbounded)},inputs:{radius:["matRippleRadius","radius"],disabled:["matRippleDisabled","disabled"],trigger:["matRippleTrigger","trigger"],color:["matRippleColor","color"],unbounded:["matRippleUnbounded","unbounded"],centered:["matRippleCentered","centered"],animation:["matRippleAnimation","animation"]},exportAs:["matRipple"]}),t})(),jy=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},imports:[[Ry,Gp],Ry]}),t})(),Gy=(()=>{class t{constructor(t){this._animationMode=t,this.state="unchecked",this.disabled=!1}}return t.\u0275fac=function(e){return new(e||t)(ta(Ey,8))},t.\u0275cmp=me({type:t,selectors:[["mat-pseudo-checkbox"]],hostAttrs:[1,"mat-pseudo-checkbox"],hostVars:8,hostBindings:function(t,e){2&t&&ka("mat-pseudo-checkbox-indeterminate","indeterminate"===e.state)("mat-pseudo-checkbox-checked","checked"===e.state)("mat-pseudo-checkbox-disabled",e.disabled)("_mat-animation-noopable","NoopAnimations"===e._animationMode)},inputs:{state:"state",disabled:"disabled"},decls:0,vars:0,template:function(t,e){},styles:['.mat-pseudo-checkbox{width:16px;height:16px;border:2px solid;border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1),background-color 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:"";border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox.mat-pseudo-checkbox-indeterminate{border-color:transparent}._mat-animation-noopable.mat-pseudo-checkbox{transition:none;animation:none}._mat-animation-noopable.mat-pseudo-checkbox::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{top:5px;left:1px;width:10px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{top:2.4px;left:1px;width:8px;height:3px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}\n'],encapsulation:2,changeDetection:0}),t})(),qy=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)}}),t})();function Xy(t,e){if(1&t&&(Pn(),sa(0,"circle",3)),2&t){const t=ya();Ma("animation-name","mat-progress-spinner-stroke-rotate-"+t.diameter)("stroke-dashoffset",t._getStrokeDashOffset(),"px")("stroke-dasharray",t._getStrokeCircumference(),"px")("stroke-width",t._getCircleStrokeWidth(),"%"),Jo("r",t._getCircleRadius())}}function Ky(t,e){if(1&t&&(Pn(),sa(0,"circle",3)),2&t){const t=ya();Ma("stroke-dashoffset",t._getStrokeDashOffset(),"px")("stroke-dasharray",t._getStrokeCircumference(),"px")("stroke-width",t._getCircleStrokeWidth(),"%"),Jo("r",t._getCircleRadius())}}function Yy(t,e){if(1&t&&(Pn(),sa(0,"circle",3)),2&t){const t=ya();Ma("animation-name","mat-progress-spinner-stroke-rotate-"+t.diameter)("stroke-dashoffset",t._getStrokeDashOffset(),"px")("stroke-dasharray",t._getStrokeCircumference(),"px")("stroke-width",t._getCircleStrokeWidth(),"%"),Jo("r",t._getCircleRadius())}}function Zy(t,e){if(1&t&&(Pn(),sa(0,"circle",3)),2&t){const t=ya();Ma("stroke-dashoffset",t._getStrokeDashOffset(),"px")("stroke-dasharray",t._getStrokeCircumference(),"px")("stroke-width",t._getCircleStrokeWidth(),"%"),Jo("r",t._getCircleRadius())}}const Jy=".mat-progress-spinner{display:block;position:relative}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.cdk-high-contrast-active .mat-progress-spinner circle{stroke:currentColor}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{animation:mat-progress-spinner-stroke-rotate-fallback 10000ms cubic-bezier(0.87, 0.03, 0.33, 1) infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition-property:stroke}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}@keyframes mat-progress-spinner-stroke-rotate-fallback{0%{transform:rotate(0deg)}25%{transform:rotate(1170deg)}50%{transform:rotate(2340deg)}75%{transform:rotate(3510deg)}100%{transform:rotate(4680deg)}}\n";class Qy{constructor(t){this._elementRef=t}}const tv=Ny(Qy,"primary"),ev=new Er("mat-progress-spinner-default-options",{providedIn:"root",factory:function(){return{diameter:100}}});let nv=(()=>{class t extends tv{constructor(e,n,r,i,s){super(e),this._elementRef=e,this._document=r,this._diameter=100,this._value=0,this._fallbackAnimation=!1,this.mode="determinate";const o=t._diameters;o.has(r.head)||o.set(r.head,new Set([100])),this._fallbackAnimation=n.EDGE||n.TRIDENT,this._noopAnimations="NoopAnimations"===i&&!!s&&!s._forceAnimations,s&&(s.diameter&&(this.diameter=s.diameter),s.strokeWidth&&(this.strokeWidth=s.strokeWidth))}get diameter(){return this._diameter}set diameter(t){this._diameter=rf(t),!this._fallbackAnimation&&this._styleRoot&&this._attachStyleNode()}get strokeWidth(){return this._strokeWidth||this.diameter/10}set strokeWidth(t){this._strokeWidth=rf(t)}get value(){return"determinate"===this.mode?this._value:0}set value(t){this._value=Math.max(0,Math.min(100,rf(t)))}ngOnInit(){const t=this._elementRef.nativeElement;this._styleRoot=Kp(t)||this._document.head,this._attachStyleNode(),t.classList.add(`mat-progress-spinner-indeterminate${this._fallbackAnimation?"-fallback":""}-animation`)}_getCircleRadius(){return(this.diameter-10)/2}_getViewBox(){const t=2*this._getCircleRadius()+this.strokeWidth;return`0 0 ${t} ${t}`}_getStrokeCircumference(){return 2*Math.PI*this._getCircleRadius()}_getStrokeDashOffset(){return"determinate"===this.mode?this._getStrokeCircumference()*(100-this._value)/100:this._fallbackAnimation&&"indeterminate"===this.mode?.2*this._getStrokeCircumference():null}_getCircleStrokeWidth(){return this.strokeWidth/this.diameter*100}_attachStyleNode(){const e=this._styleRoot,n=this._diameter,r=t._diameters;let i=r.get(e);if(!i||!i.has(n)){const t=this._document.createElement("style");t.setAttribute("mat-spinner-animation",n+""),t.textContent=this._getAnimationText(),e.appendChild(t),i||(i=new Set,r.set(e,i)),i.add(n)}}_getAnimationText(){const t=this._getStrokeCircumference();return"\n @keyframes mat-progress-spinner-stroke-rotate-DIAMETER {\n    0%      { stroke-dashoffset: START_VALUE;  transform: rotate(0); }\n    12.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(0); }\n    12.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(72.5deg); }\n    25%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(72.5deg); }\n\n    25.0001%   { stroke-dashoffset: START_VALUE;  transform: rotate(270deg); }\n    37.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(270deg); }\n    37.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(161.5deg); }\n    50%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(161.5deg); }\n\n    50.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(180deg); }\n    62.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(180deg); }\n    62.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(251.5deg); }\n    75%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(251.5deg); }\n\n    75.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(90deg); }\n    87.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(90deg); }\n    87.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(341.5deg); }\n    100%    { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(341.5deg); }\n  }\n".replace(/START_VALUE/g,""+.95*t).replace(/END_VALUE/g,""+.2*t).replace(/DIAMETER/g,`${this.diameter}`)}}return t.\u0275fac=function(e){return new(e||t)(ta(dl),ta(jp),ta(Mu,8),ta(Ey,8),ta(ev))},t.\u0275cmp=me({type:t,selectors:[["mat-progress-spinner"]],hostAttrs:["role","progressbar",1,"mat-progress-spinner"],hostVars:10,hostBindings:function(t,e){2&t&&(Jo("aria-valuemin","determinate"===e.mode?0:null)("aria-valuemax","determinate"===e.mode?100:null)("aria-valuenow","determinate"===e.mode?e.value:null)("mode",e.mode),Ma("width",e.diameter,"px")("height",e.diameter,"px"),ka("_mat-animation-noopable",e._noopAnimations))},inputs:{color:"color",mode:"mode",diameter:"diameter",strokeWidth:"strokeWidth",value:"value"},exportAs:["matProgressSpinner"],features:[Vo],decls:3,vars:8,consts:[["preserveAspectRatio","xMidYMid meet","focusable","false",3,"ngSwitch"],["cx","50%","cy","50%",3,"animation-name","stroke-dashoffset","stroke-dasharray","stroke-width",4,"ngSwitchCase"],["cx","50%","cy","50%",3,"stroke-dashoffset","stroke-dasharray","stroke-width",4,"ngSwitchCase"],["cx","50%","cy","50%"]],template:function(t,e){1&t&&(Pn(),ra(0,"svg",0),Qo(1,Xy,1,9,"circle",1),Qo(2,Ky,1,7,"circle",2),ia()),2&t&&(Ma("width",e.diameter,"px")("height",e.diameter,"px"),ea("ngSwitch","indeterminate"===e.mode),Jo("viewBox",e._getViewBox()),Ts(1),ea("ngSwitchCase",!0),Ts(1),ea("ngSwitchCase",!1))},directives:[nh,rh],styles:[Jy],encapsulation:2,changeDetection:0}),t._diameters=new WeakMap,t})(),rv=(()=>{class t extends nv{constructor(t,e,n,r,i){super(t,e,n,r,i),this.mode="indeterminate"}}return t.\u0275fac=function(e){return new(e||t)(ta(dl),ta(jp),ta(Mu,8),ta(Ey,8),ta(ev))},t.\u0275cmp=me({type:t,selectors:[["mat-spinner"]],hostAttrs:["role","progressbar","mode","indeterminate",1,"mat-spinner","mat-progress-spinner"],hostVars:6,hostBindings:function(t,e){2&t&&(Ma("width",e.diameter,"px")("height",e.diameter,"px"),ka("_mat-animation-noopable",e._noopAnimations))},inputs:{color:"color"},features:[Vo],decls:3,vars:8,consts:[["preserveAspectRatio","xMidYMid meet","focusable","false",3,"ngSwitch"],["cx","50%","cy","50%",3,"animation-name","stroke-dashoffset","stroke-dasharray","stroke-width",4,"ngSwitchCase"],["cx","50%","cy","50%",3,"stroke-dashoffset","stroke-dasharray","stroke-width",4,"ngSwitchCase"],["cx","50%","cy","50%"]],template:function(t,e){1&t&&(Pn(),ra(0,"svg",0),Qo(1,Yy,1,9,"circle",1),Qo(2,Zy,1,7,"circle",2),ia()),2&t&&(Ma("width",e.diameter,"px")("height",e.diameter,"px"),ea("ngSwitch","indeterminate"===e.mode),Jo("viewBox",e._getViewBox()),Ts(1),ea("ngSwitchCase",!0),Ts(1),ea("ngSwitchCase",!1))},directives:[nh,rh],styles:[Jy],encapsulation:2,changeDetection:0}),t})(),iv=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},imports:[[Ry,ch],Ry]}),t})(),sv=(()=>{class t{}return t.type="[App] Start Loading",t})(),ov=(()=>{class t{}return t.type="[App] Stop Loading",t})(),av=(()=>{class t{}return t.type="[App] Reset Error",t})(),lv=(()=>{class t{constructor(t){this.error=t,console.error(t),this.message=t.error&&t.error.message?t.error.message:"string"==typeof t.message?t.message:t}}return t.type="[App] Display Error",t.eventParams=["message"],t})();var cv=n("EUkQ"),uv=n.n(cv);class hv{constructor(t,e){this.count=t,this.source=e}call(t,e){return e.subscribe(new dv(t,this.count,this.source))}}class dv extends H{constructor(t,e,n){super(t),this.count=e,this.source=n}error(t){if(!this.isStopped){const{source:e,count:n}=this;if(0===n)return super.error(t);n>-1&&(this.count=n-1),e.subscribe(this._unsubscribeAndRecycle())}}}function pv(t,e){return"function"==typeof e?n=>n.pipe(pv((n,r)=>ht(t(n,r)).pipe(et((t,i)=>e(n,t,r,i))))):e=>e.lift(new fv(t))}class fv{constructor(t){this.project=t}call(t,e){return e.subscribe(new mv(t,this.project))}}class mv extends pt{constructor(t,e){super(t),this.project=e,this.index=0}_next(t){let e;const n=this.index++;try{e=this.project(t,n)}catch(r){return void this.destination.error(r)}this._innerSub(e)}_innerSub(t){const e=this.innerSubscription;e&&e.unsubscribe();const n=new dt(this),r=this.destination;r.add(n),this.innerSubscription=ft(t,n),this.innerSubscription!==n&&r.add(this.innerSubscription)}_complete(){const{innerSubscription:t}=this;t&&!t.closed||super._complete(),this.unsubscribe()}_unsubscribe(){this.innerSubscription=void 0}notifyComplete(){this.innerSubscription=void 0,this.isStopped&&super._complete()}notifyNext(t){this.destination.next(t)}}class gv extends H{notifyNext(t,e,n,r,i){this.destination.next(e)}notifyError(t,e){this.destination.error(t)}notifyComplete(t){this.destination.complete()}}class yv extends H{constructor(t,e,n){super(),this.parent=t,this.outerValue=e,this.outerIndex=n,this.index=0}_next(t){this.parent.notifyNext(this.outerValue,t,this.outerIndex,this.index++,this)}_error(t){this.parent.notifyError(t,this),this.unsubscribe()}_complete(){this.parent.notifyComplete(this),this.unsubscribe()}}function vv(t,e,n,r,i=new yv(t,n,r)){if(!i.closed)return e instanceof q?e.subscribe(i):ct(e)(i)}const bv={};function _v(...t){let e,n;return tt(t[t.length-1])&&(n=t.pop()),"function"==typeof t[t.length-1]&&(e=t.pop()),1===t.length&&P(t[0])&&(t=t[0]),bt(t,n).lift(new xv(e))}class xv{constructor(t){this.resultSelector=t}call(t,e){return e.subscribe(new wv(t,this.resultSelector))}}class wv extends gv{constructor(t,e){super(t),this.resultSelector=e,this.active=0,this.values=[],this.observables=[]}_next(t){this.values.push(bv),this.observables.push(t)}_complete(){const t=this.observables,e=t.length;if(0===e)this.destination.complete();else{this.active=e,this.toRespond=e;for(let n=0;n<e;n++)this.add(vv(this,t[n],void 0,n))}}notifyComplete(t){0==(this.active-=1)&&this.destination.complete()}notifyNext(t,e,n){const r=this.values,i=this.toRespond?r[n]===bv?--this.toRespond:this.toRespond:0;r[n]=e,0===i&&(this.resultSelector?this._tryResultSelector(r):this.destination.next(r.slice()))}_tryResultSelector(t){let e;try{e=this.resultSelector.apply(this,t)}catch(n){return void this.destination.error(n)}this.destination.next(e)}}class Sv{constructor(t){this.translations=t}getTranslation(t){return Zh(this.translations.get(t)||{})}}const Ev=new Er("TRANSLOCO_LOADER");function Cv(t,e){return t&&t.hasOwnProperty(e)?t[e]:e.split(".").reduce((t,e)=>t&&t[e],t)}function Tv(t,e,n){t=Object.assign({},t);const r=e.split("."),i=r.length-1;return r.reduce((t,e,r)=>(t[e]=r===i?n:Array.isArray(t[e])?t[e].slice():Object.assign({},t[e]),t&&t[e]),t),t}function Av(t){return t?Array.isArray(t)?t.length:kv(t)?Object.keys(t).length:t?t.length:0:0}function Mv(t){return"string"==typeof t}function kv(t){return t&&"object"==typeof t&&!Array.isArray(t)}function Rv(t){return t.replace(/(?:^\w|[A-Z]|\b\w)/g,(t,e)=>0==e?t.toLowerCase():t.toUpperCase()).replace(/\s+|_|-|\//g,"")}function Iv(t){return null==t}function Nv(t){return!1===Iv(t)}function Ov(t){return t&&"string"==typeof t.scope}function Dv(t){return uv()(t,{safe:!0})}const Lv=new Er("TRANSLOCO_CONFIG",{providedIn:"root",factory:()=>({})}),Fv={defaultLang:"en",reRenderOnLangChange:!1,prodMode:!1,failedRetries:2,availableLangs:[],missingHandler:{logMissingKey:!0,useFallbackTranslation:!1,allowEmpty:!1},flatten:{aot:!1},interpolation:["{{","}}"]},Pv=new Er("TRANSLOCO_TRANSPILER");class $v{constructor(t){this.interpolationMatcher=function(t){const[e,n]=t&&t.interpolation?t.interpolation:Fv.interpolation;return new RegExp(`${e}(.*?)${n}`,"g")}(t)}transpile(t,e={},n){return Mv(t)?t.replace(this.interpolationMatcher,(t,r)=>(r=r.trim(),Nv(e[r])?e[r]:Nv(n[r])?this.transpile(n[r],e,n):"")):(kv(t)&&e&&(t=this.handleObject(t,e,n)),t)}handleObject(t,e={},n){let r=t;return Object.keys(e).forEach(t=>{const i=Cv(r,t),s=Cv(e,t),o=this.transpile(i,s,n);r=Tv(r,t,o)}),r}}const Bv=new Er("TRANSLOCO_MISSING_HANDLER");let zv=(()=>{class t{handle(t,e){return e.missingHandler.logMissingKey&&!e.prodMode&&console.warn(`%c Missing translation for '${t}'`,"font-size: 12px; color: red"),t}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();const Vv=new Er("TRANSLOCO_INTERCEPTOR");let Uv=(()=>{class t{preSaveTranslation(t,e){return t}preSaveTranslationKey(t,e,n){return e}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();const Hv=new Er("TRANSLOCO_FALLBACK_STRATEGY");function Wv(t){if(!t)return"";const e=t.split("/");return e.pop(),e.join("/")}function jv(t){return t?t.split("/").pop():""}function Gv(t,e,n="|"){if(Mv(t)){const r=t.split(n),i=r.pop();return i===e?[!0,r.toString()]:[!1,i]}return[!1,""]}function qv(t,e){const[n]=Gv(e,"static");return!1===n&&t.config.reRenderOnLangChange}function Xv(t){return t?t=>t:wd(1)}function Kv(t,e){return(n=t)&&kv(n.loader)?function(t,e){return Object.keys(t).reduce((n,r)=>(n[`${e}/${r}`]=t[r],n),{})}(t.loader,e):null;var n}function Yv(t){return{scope:Wv(t)||null,langName:jv(t),lang:t}}function Zv(t,e,n,r){if(n){if(0==("function"==typeof n[t]))throw`You're using an inline loader but didn't provide a loader for ${t}`;return n[t]().then(t=>t.default?t.default:t)}return e.getTranslation(t,r)}let Jv,Qv=(()=>{class t{constructor(t,e,n,r,i,s){this.loader=t,this.parser=e,this.missingHandler=n,this.interceptor=r,this.userConfig=i,this.fallbackStrategy=s,this.translations=new Map,this.cache=new Map,this.firstFallbackLang=null,this.availableLangs=[],this.isResolvedMissingOnce=!1,this.events=new J,this.events$=this.events.asObservable(),this.failedCounter=0,this.failedLangs=new Set,this.loader||(this.loader=new Sv(this.translations)),Jv=this,this.mergedConfig=function(t,e){return Object.assign({},t,e,{missingHandler:Object.assign({},t.missingHandler,e.missingHandler),flatten:Object.assign({},t.flatten,e.flatten)})}(Fv,i),this.setAvailableLangs(this.mergedConfig.availableLangs),this.setFallbackLangForMissingTranslation(this.mergedConfig),this.setDefaultLang(this.mergedConfig.defaultLang),this.lang=new fd(this.getDefaultLang()),this.langChanges$=this.lang.asObservable(),this.subscription=this.events$.subscribe(t=>{if("translationLoadSuccess"===t.type&&t.wasFailure){const e=jv(t.payload.lang);this.setActiveLang(e)}})}get config(){return this.mergedConfig}getDefaultLang(){return this.defaultLang}setDefaultLang(t){this.defaultLang=t}getActiveLang(){return this.lang.getValue()}setActiveLang(t){return this.lang.next(t),this.parser.onLangChanged&&this.parser.onLangChanged(t),this}setAvailableLangs(t){this.availableLangs=t}getAvailableLangs(){return this.availableLangs}load(t,e={}){if(!1===this.cache.has(t)){let s;const o=this._isLangScoped(t),a=o?Wv(t):null;s=this.useFallbackTranslation(t)?md((n=this.loader,r=e.inlineLoader,i={scope:a},[t,o?`${a}/${this.firstFallbackLang}`:this.firstFallbackLang].map(t=>ht(Zv(t,n,r,i)).pipe(et(e=>({translation:e,lang:t})))))):ht(Zv(t,this.loader,e.inlineLoader,{scope:a}));const l=s.pipe(function(t=-1){return e=>e.lift(new hv(t,e))}(this.config.failedRetries),$d(e=>{Array.isArray(e)?e.forEach(e=>{this.handleSuccess(e.lang,e.translation),e.lang!==t&&this.cache.set(e.lang,Zh({}))}):this.handleSuccess(t,e)}),Id(()=>this.handleFailure(t,e)),_d(1));this.cache.set(t,l)}var n,r,i;return this.cache.get(t)}translate(t,e={},n=this.getActiveLang()){if(!t)return t;const{scope:r,resolveLang:i}=this.resolveLangAndScope(n);if(Array.isArray(t))return t.map(t=>this.translate(r?`${r}.${t}`:t,e,i));t=r?`${r}.${t}`:t;const s=this.getTranslation(i),o=s[t];return o?this.parser.transpile(o,e,s):this._handleMissingKey(t,o,e)}selectTranslate(t,e,n,r=!1){let i=null;const s=(n,i)=>this.load(n,i).pipe(et(()=>r?this.translateObject(t,e,n):this.translate(t,e,n)));if(Iv(n))return this.langChanges$.pipe(pv(t=>s(t)));if(Ov(n)){const t=n;n=t.scope,i=Kv(t,t.scope)}if(this.isLang(n=n)||this.isScopeWithLang(n))return s(n);const o=n;return this.langChanges$.pipe(pv(t=>s(`${o}/${t}`,{inlineLoader:i})))}isScopeWithLang(t){return this.isLang(jv(t))}translateObject(t,e,n=this.getActiveLang()){if(Mv(t)||Array.isArray(t)){if(Array.isArray(t))return t.map(t=>this.translateObject(s?`${s}.${t}`:t,e,i));const{resolveLang:i,scope:s}=this.resolveLangAndScope(n),o=this.getTranslation(i),a=(r=this.getObjectByKey(o,t=s?`${s}.${t}`:t),uv.a.unflatten(r,{safe:!0}));return 0===Av(a)?this.translate(t,e,n):this.parser.transpile(a,e,o)}var r;const i=[];for(const[s,o]of this.getEntries(t))i.push(this.translateObject(s,o,n));return i}selectTranslateObject(t,e,n){if(Mv(t)||Array.isArray(t))return this.selectTranslate(t,e,n,!0);const[[r,i],...s]=this.getEntries(t);return this.selectTranslateObject(r,i,n).pipe(et(t=>{const e=[t];for(const[r,i]of s)e.push(this.translateObject(r,i,n));return e}))}getTranslation(t){if(t){if(this.isLang(t))return this.translations.get(t)||{};{const{scope:e,resolveLang:n}=this.resolveLangAndScope(t),r=this.translations.get(n)||{};return this.getObjectByKey(r,e)}}return this.translations}selectTranslation(t){let e=this.langChanges$;if(t){const n=jv(t)!==t;e=this.isLang(t)||n?Zh(t):this.langChanges$.pipe(et(e=>`${t}/${e}`))}return e.pipe(pv(t=>this.load(t).pipe(et(()=>this.getTranslation(t)))))}setTranslation(t,e=this.getActiveLang(),n={}){const r=Object.assign({},{merge:!0,emitChange:!0},n),i=Wv(e);let s=t;i&&(s=Dv({[this.getMappedScope(i)]:t}));const o=i?jv(e):e,a=Object.assign({},r.merge&&this.getTranslation(o),s),l=this.mergedConfig.flatten.aot?a:Dv(a),c=this.interceptor.preSaveTranslation(l,o);this.translations.set(o,c),r.emitChange&&this.setActiveLang(this.getActiveLang())}setTranslationKey(t,e,n=this.getActiveLang()){const r=this.interceptor.preSaveTranslationKey(t,e,n),i=Object.assign({},this.getTranslation(n),{[t]:r});this.setTranslation(i,n)}setFallbackLangForMissingTranslation({fallbackLang:t}){const e=Array.isArray(t)?t[0]:t;this.useFallbackTranslation(e)&&t&&(this.firstFallbackLang=e)}_handleMissingKey(t,e,n){if(this.config.missingHandler.allowEmpty&&""===e)return"";if(this.useFallbackTranslation()&&!this.isResolvedMissingOnce){this.isResolvedMissingOnce=!0;const e=this.translate(t,n,this.firstFallbackLang);return this.isResolvedMissingOnce=!1,e}return this.missingHandler.handle(t,this.getMissingHandlerData(),n)}_isLangScoped(t){return-1===this.getAvailableLangsIds().indexOf(t)}isLang(t){return-1!==this.getAvailableLangsIds().indexOf(t)}_loadDependencies(t,e){const n=jv(t);return this._isLangScoped(t)&&!this.isLoadedTranslation(n)?_v(this.load(n),this.load(t,{inlineLoader:e})):this.load(t,{inlineLoader:e})}_completeScopeWithLang(t){return this._isLangScoped(t)&&!this.isLang(jv(t))?`${t}/${this.getActiveLang()}`:t}_setScopeAlias(t,e){this.mergedConfig.scopeMapping||(this.mergedConfig.scopeMapping={}),this.mergedConfig.scopeMapping[t]=e}ngOnDestroy(){this.subscription.unsubscribe()}isLoadedTranslation(t){return Av(this.getTranslation(t))}getAvailableLangsIds(){return Mv(this.getAvailableLangs()[0])?this.getAvailableLangs():this.getAvailableLangs().map(t=>t.id)}getMissingHandlerData(){return Object.assign({},this.config,{activeLang:this.getActiveLang(),availableLangs:this.availableLangs,defaultLang:this.defaultLang})}useFallbackTranslation(t){return this.config.missingHandler.useFallbackTranslation&&t!==this.firstFallbackLang}handleSuccess(t,e){this.setTranslation(e,t,{emitChange:!1}),this.failedCounter=0,this.events.next({wasFailure:!!this.failedLangs.size,type:"translationLoadSuccess",payload:Yv(t)}),this.failedLangs.forEach(t=>this.cache.delete(t)),this.failedLangs.clear()}handleFailure(t,e){const n=t.split("/"),r=(e.fallbackLangs||this.fallbackStrategy.getNextLangs(t))[this.failedCounter];if(this.failedLangs.add(t),this.cache.has(r))return this.handleSuccess(r,this.getTranslation(r)),Kh;if(!r||r===n[n.length-1]){let t="Unable to load translation and all the fallback languages";throw n.length>1&&(t+=", did you misspelled the scope name?"),new Error(t)}let i=r;return n.length>1&&(n[n.length-1]=r,i=n.join("/")),this.failedCounter++,this.events.next({type:"translationLoadFailure",payload:Yv(t)}),this.load(i)}getMappedScope(t){const{scopeMapping:e={}}=this.config;return e[t]||Rv(t)}resolveLangAndScope(t){let e,n=t;if(this._isLangScoped(t)){const r=jv(t),i=this.isLang(r);n=i?r:this.getActiveLang(),e=this.getMappedScope(i?Wv(t):t)}return{scope:e,resolveLang:n}}getObjectByKey(t,e){const n={},r=`${e}.`;for(const i in t)i.startsWith(r)&&(n[i.replace(r,"")]=t[i]);return n}getEntries(t){return t instanceof Map?t.entries():Object.entries(t)}}return t.\u0275fac=function(e){return new(e||t)(zr(Ev,8),zr(Pv),zr(Bv),zr(Vv),zr(Lv),zr(Hv))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac,providedIn:"root"}),t.ngInjectableDef=$t({factory:function(){return new t(Vr(Ev,8),Vr(Pv),Vr(Bv),Vr(Vv),Vr(Lv),Vr(Hv))},token:t,providedIn:"root"}),t})(),tb=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=me({type:t,selectors:[["ng-component"]],inputs:{html:"html"},decls:1,vars:1,consts:[[1,"transloco-loader-template",3,"innerHTML"]],template:function(t,e){1&t&&sa(0,"div",0),2&t&&ea("innerHTML",e.html,Ri)},encapsulation:2}),t})();class eb{constructor(t,e){this.view=t,this.vcr=e,this.injector=this.vcr.injector}attachView(){if(this.view instanceof Wl)this.vcr.createEmbeddedView(this.view);else if(Mv(this.view)){const t=this.createComponent(tb);t.instance.html=this.view,t.hostView.detectChanges()}else this.createComponent(this.view)}detachView(){this.vcr.clear()}createComponent(t){const e=this.injector.get(ll).resolveComponentFactory(t);return this.vcr.createComponent(e)}}const nb=new Er("TRANSLOCO_LANG"),rb=new Er("TRANSLOCO_LOADING_TEMPLATE"),ib=new Er("TRANSLOCO_SCOPE");class sb{constructor(){this.initialized=!1}resolve({inline:t,provider:e,active:n}={inline:void 0,provider:void 0,active:void 0}){let r=n;if(this.initialized)return r=n,r;if(e){const[t,n]=Gv(e,"static");r=n}if(t){const[e,n]=Gv(t,"static");r=n}return this.initialized=!0,r}resolveLangBasedOnScope(t){return Wv(t)?jv(t):t}resolveLangPath(t,e){return e?`${e}/${t}`:t}}class ob{constructor(t){this.translocoService=t}resolve({inline:t,provider:e}={inline:void 0,provider:void 0}){if(t)return t;if(e){if(Ov(e)){const{scope:t,alias:n=Rv(t)}=e;return this.translocoService._setScopeAlias(t,n),t}return e}}}let ab=(()=>{class t{constructor(t,e,n,r,i,s,o,a){this.translocoService=t,this.tpl=e,this.providerScope=n,this.providerLang=r,this.providedLoadingTpl=i,this.vcr=s,this.cdr=o,this.host=a,this.translationMemo={},this.params={},this.loaderTplHandler=null,this.initialized=!1,this.langResolver=new sb,this.scopeResolver=new ob(this.translocoService)}ngOnInit(){const t=qv(this.translocoService,this.providerLang||this.inlineLang);this.subscription=this.translocoService.langChanges$.pipe(pv(t=>{const e=this.langResolver.resolve({inline:this.inlineLang,provider:this.providerLang,active:t});return Array.isArray(this.providerScope)?md(this.providerScope.map(t=>this.resolveScope(e,t))):this.resolveScope(e,this.providerScope)}),Xv(t)).subscribe(()=>{this.currentLang=this.langResolver.resolveLangBasedOnScope(this.path),null===this.tpl?this.simpleStrategy():this.structuralStrategy(this.currentLang,this.inlineRead),this.cdr.markForCheck(),this.initialized=!0});const e=this.getLoadingTpl();!this.initialized&&e&&(this.loaderTplHandler=new eb(e,this.vcr),this.loaderTplHandler.attachView())}ngOnChanges(t){Object.keys(t).some(e=>!1===t[e].firstChange)&&this.simpleStrategy()}simpleStrategy(){this.detachLoader(),this.host.nativeElement.innerText=this.translocoService.translate(this.key,this.params,this.currentLang)}structuralStrategy(t,e){this.translationMemo={},this.view?this.view.context.$implicit=this.getTranslateFn(t,e):(this.detachLoader(),this.view=this.vcr.createEmbeddedView(this.tpl,{$implicit:this.getTranslateFn(t,e)}))}getTranslateFn(t,e){return(n,r)=>{const i=e?`${e}.${n}`:n,s=r?`${i}${JSON.stringify(r)}`:i;return this.translationMemo.hasOwnProperty(s)||(this.translationMemo[s]={params:r,value:this.translocoService.translate(i,r,t)}),this.translationMemo[s].value}}getLoadingTpl(){return this.inlineTpl||this.providedLoadingTpl}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}detachLoader(){this.loaderTplHandler&&this.loaderTplHandler.detachView()}resolveScope(t,e){let n=this.scopeResolver.resolve({inline:this.inlineScope,provider:e});this.path=this.langResolver.resolveLangPath(t,n);const r=Kv(e,n);return this.translocoService._loadDependencies(this.path,r)}}return t.\u0275fac=function(e){return new(e||t)(ta(Qv),ta(Wl,8),ta(ib,8),ta(nb,8),ta(rb,8),ta(Yl),ta($l),ta(dl))},t.\u0275dir=xe({type:t,selectors:[["","transloco",""]],inputs:{params:["translocoParams","params"],key:["transloco","key"],inlineScope:["translocoScope","inlineScope"],inlineRead:["translocoRead","inlineRead"],inlineLang:["translocoLang","inlineLang"],inlineTpl:["translocoLoadingTpl","inlineTpl"]},features:[Be]}),t})(),lb=(()=>{class t{constructor(t,e,n,r){this.translocoService=t,this.providerScope=e,this.providerLang=n,this.cdr=r,this.subscription=null,this.lastValue="",this.langResolver=new sb,this.scopeResolver=new ob(this.translocoService),this.listenToLangChange=qv(this.translocoService,this.providerLang)}transform(t,e,n){if(!t)return t;const r=e?`${t}${JSON.stringify(e)}`:t;return r===this.lastKey||(this.lastKey=r,this.subscription&&this.subscription.unsubscribe(),this.subscription=this.translocoService.langChanges$.pipe(pv(t=>{const e=this.langResolver.resolve({inline:n,provider:this.providerLang,active:t});return Array.isArray(this.providerScope)?md(this.providerScope.map(t=>this.resolveScope(e,t))):this.resolveScope(e,this.providerScope)}),Xv(this.listenToLangChange)).subscribe(()=>this.updateValue(t,e))),this.lastValue}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}updateValue(t,e){const n=this.langResolver.resolveLangBasedOnScope(this.path);this.lastValue=this.translocoService.translate(t,e,n),this.cdr.markForCheck()}resolveScope(t,e){let n=this.scopeResolver.resolve({inline:void 0,provider:e});this.path=this.langResolver.resolveLangPath(t,n);const r=Kv(e,n);return this.translocoService._loadDependencies(this.path,r)}}return t.\u0275fac=function(e){return new(e||t)(ta(Qv),ta(ib,8),ta(nb,8),Nc())},t.\u0275pipe=we({name:"transloco",type:t,pure:!1}),t})();const cb=[{provide:Pv,useClass:$v,deps:[Lv]},{provide:Bv,useClass:zv},{provide:Vv,useClass:Uv},{provide:Hv,useClass:class{constructor(t){this.userConfig=t}getNextLangs(t){const e=this.userConfig.fallbackLang;if(!e)throw new Error("When using the default fallback, a fallback language must be provided in the config!");return Array.isArray(e)?e:[e]}},deps:[Lv]}];let ub=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},providers:[cb]}),t})();function hb(t,e,n,r){return N(n)&&(r=n,n=void 0),r?hb(t,e,n).pipe(et(t=>P(t)?r(...t):r(t))):new q(r=>{db(t,e,function(t){r.next(arguments.length>1?Array.prototype.slice.call(arguments):t)},r,n)})}function db(t,e,n,r,i){let s;if(function(t){return t&&"function"==typeof t.addEventListener&&"function"==typeof t.removeEventListener}(t)){const r=t;t.addEventListener(e,n,i),s=()=>r.removeEventListener(e,n,i)}else if(function(t){return t&&"function"==typeof t.on&&"function"==typeof t.off}(t)){const r=t;t.on(e,n),s=()=>r.off(e,n)}else if(function(t){return t&&"function"==typeof t.addListener&&"function"==typeof t.removeListener}(t)){const r=t;t.addListener(e,n),s=()=>r.removeListener(e,n)}else{if(!t||!t.length)throw new TypeError("Invalid event target");for(let s=0,o=t.length;s<o;s++)db(t[s],e,n,r,i)}r.add(s)}class pb{constructor(t){this.durationSelector=t}call(t,e){return e.subscribe(new fb(t,this.durationSelector))}}class fb extends pt{constructor(t,e){super(t),this.durationSelector=e,this.hasValue=!1}_next(t){if(this.value=t,this.hasValue=!0,!this.throttled){let n;try{const{durationSelector:e}=this;n=e(t)}catch(e){return this.destination.error(e)}const r=ft(n,new dt(this));!r||r.closed?this.clearThrottle():this.add(this.throttled=r)}}clearThrottle(){const{value:t,hasValue:e,throttled:n}=this;n&&(this.remove(n),this.throttled=void 0,n.unsubscribe()),e&&(this.value=void 0,this.hasValue=!1,this.destination.next(t))}notifyNext(){this.clearThrottle()}notifyComplete(){this.clearThrottle()}}function mb(t){return!P(t)&&t-parseFloat(t)+1>=0}function gb(t){const{index:e,period:n,subscriber:r}=t;if(r.next(e),!r.closed){if(-1===n)return r.complete();t.index=e+1,this.schedule(t,n)}}function yb(t,e=Zp){return n=()=>function(t=0,e,n){let r=-1;return mb(e)?r=Number(e)<1?1:Number(e):tt(e)&&(n=e),tt(n)||(n=Zp),new q(e=>{const i=mb(t)?t:+t-n.now();return n.schedule(gb,i,{index:0,period:r,subscriber:e})})}(t,e),function(t){return t.lift(new pb(n))};var n}class vb{constructor(t=!1,e,n=!0){this._multiple=t,this._emitChanges=n,this._selection=new Set,this._deselectedToEmit=[],this._selectedToEmit=[],this.changed=new J,e&&e.length&&(t?e.forEach(t=>this._markSelected(t)):this._markSelected(e[0]),this._selectedToEmit.length=0)}get selected(){return this._selected||(this._selected=Array.from(this._selection.values())),this._selected}select(...t){this._verifyValueAssignment(t),t.forEach(t=>this._markSelected(t)),this._emitChangeEvent()}deselect(...t){this._verifyValueAssignment(t),t.forEach(t=>this._unmarkSelected(t)),this._emitChangeEvent()}toggle(t){this.isSelected(t)?this.deselect(t):this.select(t)}clear(){this._unmarkAll(),this._emitChangeEvent()}isSelected(t){return this._selection.has(t)}isEmpty(){return 0===this._selection.size}hasValue(){return!this.isEmpty()}sort(t){this._multiple&&this.selected&&this._selected.sort(t)}isMultipleSelection(){return this._multiple}_emitChangeEvent(){this._selected=null,(this._selectedToEmit.length||this._deselectedToEmit.length)&&(this.changed.next({source:this,added:this._selectedToEmit,removed:this._deselectedToEmit}),this._deselectedToEmit=[],this._selectedToEmit=[])}_markSelected(t){this.isSelected(t)||(this._multiple||this._unmarkAll(),this._selection.add(t),this._emitChanges&&this._selectedToEmit.push(t))}_unmarkSelected(t){this.isSelected(t)&&(this._selection.delete(t),this._emitChanges&&this._deselectedToEmit.push(t))}_unmarkAll(){this.isEmpty()||this._selection.forEach(t=>this._unmarkSelected(t))}_verifyValueAssignment(t){if(t.length>1&&!this._multiple)throw Error("Cannot pass multiple values into SelectionModel with single-value mode.")}}let bb=(()=>{class t{constructor(t,e,n){this._ngZone=t,this._platform=e,this._scrolled=new J,this._globalSubscription=null,this._scrolledCount=0,this.scrollContainers=new Map,this._document=n}register(t){this.scrollContainers.has(t)||this.scrollContainers.set(t,t.elementScrolled().subscribe(()=>this._scrolled.next(t)))}deregister(t){const e=this.scrollContainers.get(t);e&&(e.unsubscribe(),this.scrollContainers.delete(t))}scrolled(t=20){return this._platform.isBrowser?new q(e=>{this._globalSubscription||this._addGlobalListener();const n=t>0?this._scrolled.pipe(yb(t)).subscribe(e):this._scrolled.subscribe(e);return this._scrolledCount++,()=>{n.unsubscribe(),this._scrolledCount--,this._scrolledCount||this._removeGlobalListener()}}):Zh()}ngOnDestroy(){this._removeGlobalListener(),this.scrollContainers.forEach((t,e)=>this.deregister(e)),this._scrolled.complete()}ancestorScrolled(t,e){const n=this.getAncestorScrollContainers(t);return this.scrolled(e).pipe(yd(t=>!t||n.indexOf(t)>-1))}getAncestorScrollContainers(t){const e=[];return this.scrollContainers.forEach((n,r)=>{this._scrollableContainsElement(r,t)&&e.push(r)}),e}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_scrollableContainsElement(t,e){let n=e.nativeElement,r=t.getElementRef().nativeElement;do{if(n==r)return!0}while(n=n.parentElement);return!1}_addGlobalListener(){this._globalSubscription=this._ngZone.runOutsideAngular(()=>hb(this._getWindow().document,"scroll").subscribe(()=>this._scrolled.next()))}_removeGlobalListener(){this._globalSubscription&&(this._globalSubscription.unsubscribe(),this._globalSubscription=null)}}return t.\u0275fac=function(e){return new(e||t)(zr(eu),zr(jp),zr(Mu,8))},t.\u0275prov=Pt({factory:function(){return new t(zr(eu),zr(jp),zr(Mu,8))},token:t,providedIn:"root"}),t})(),_b=(()=>{class t{constructor(t,e,n,r){this.elementRef=t,this.scrollDispatcher=e,this.ngZone=n,this.dir=r,this._destroyed=new J,this._elementScrolled=new q(t=>this.ngZone.runOutsideAngular(()=>hb(this.elementRef.nativeElement,"scroll").pipe(Dd(this._destroyed)).subscribe(t)))}ngOnInit(){this.scrollDispatcher.register(this)}ngOnDestroy(){this.scrollDispatcher.deregister(this),this._destroyed.next(),this._destroyed.complete()}elementScrolled(){return this._elementScrolled}getElementRef(){return this.elementRef}scrollTo(t){const e=this.elementRef.nativeElement,n=this.dir&&"rtl"==this.dir.value;null==t.left&&(t.left=n?t.end:t.start),null==t.right&&(t.right=n?t.start:t.end),null!=t.bottom&&(t.top=e.scrollHeight-e.clientHeight-t.bottom),n&&0!=Xp()?(null!=t.left&&(t.right=e.scrollWidth-e.clientWidth-t.left),2==Xp()?t.left=t.right:1==Xp()&&(t.left=t.right?-t.right:t.right)):null!=t.right&&(t.left=e.scrollWidth-e.clientWidth-t.right),this._applyScrollToOptions(t)}_applyScrollToOptions(t){const e=this.elementRef.nativeElement;"object"==typeof document&&"scrollBehavior"in document.documentElement.style?e.scrollTo(t):(null!=t.top&&(e.scrollTop=t.top),null!=t.left&&(e.scrollLeft=t.left))}measureScrollOffset(t){const e="left",n="right",r=this.elementRef.nativeElement;if("top"==t)return r.scrollTop;if("bottom"==t)return r.scrollHeight-r.clientHeight-r.scrollTop;const i=this.dir&&"rtl"==this.dir.value;return"start"==t?t=i?n:e:"end"==t&&(t=i?e:n),i&&2==Xp()?t==e?r.scrollWidth-r.clientWidth-r.scrollLeft:r.scrollLeft:i&&1==Xp()?t==e?r.scrollLeft+r.scrollWidth-r.clientWidth:-r.scrollLeft:t==e?r.scrollLeft:r.scrollWidth-r.clientWidth-r.scrollLeft}}return t.\u0275fac=function(e){return new(e||t)(ta(dl),ta(bb),ta(eu),ta(Pf,8))},t.\u0275dir=xe({type:t,selectors:[["","cdk-scrollable",""],["","cdkScrollable",""]]}),t})(),xb=(()=>{class t{constructor(t,e,n){this._platform=t,this._change=new J,this._changeListener=t=>{this._change.next(t)},this._document=n,e.runOutsideAngular(()=>{if(t.isBrowser){const t=this._getWindow();t.addEventListener("resize",this._changeListener),t.addEventListener("orientationchange",this._changeListener)}this.change().subscribe(()=>this._updateViewportSize())})}ngOnDestroy(){if(this._platform.isBrowser){const t=this._getWindow();t.removeEventListener("resize",this._changeListener),t.removeEventListener("orientationchange",this._changeListener)}this._change.complete()}getViewportSize(){this._viewportSize||this._updateViewportSize();const t={width:this._viewportSize.width,height:this._viewportSize.height};return this._platform.isBrowser||(this._viewportSize=null),t}getViewportRect(){const t=this.getViewportScrollPosition(),{width:e,height:n}=this.getViewportSize();return{top:t.top,left:t.left,bottom:t.top+n,right:t.left+e,height:n,width:e}}getViewportScrollPosition(){if(!this._platform.isBrowser)return{top:0,left:0};const t=this._getDocument(),e=this._getWindow(),n=t.documentElement,r=n.getBoundingClientRect();return{top:-r.top||t.body.scrollTop||e.scrollY||n.scrollTop||0,left:-r.left||t.body.scrollLeft||e.scrollX||n.scrollLeft||0}}change(t=20){return t>0?this._change.pipe(yb(t)):this._change}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_updateViewportSize(){const t=this._getWindow();this._viewportSize=this._platform.isBrowser?{width:t.innerWidth,height:t.innerHeight}:{width:0,height:0}}}return t.\u0275fac=function(e){return new(e||t)(zr(jp),zr(eu),zr(Mu,8))},t.\u0275prov=Pt({factory:function(){return new t(zr(jp),zr(eu),zr(Mu,8))},token:t,providedIn:"root"}),t})(),wb=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)}}),t})(),Sb=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},imports:[[$f,Gp,wb],$f,wb]}),t})();function Eb(){throw Error("Host already has a portal attached")}class Cb{attach(t){return null==t&&function(){throw Error("Attempting to attach a portal to a null PortalOutlet")}(),t.hasAttached()&&Eb(),this._attachedHost=t,t.attach(this)}detach(){let t=this._attachedHost;null==t?function(){throw Error("Attempting to detach a portal that is not attached to a host")}():(this._attachedHost=null,t.detach())}get isAttached(){return null!=this._attachedHost}setAttachedHost(t){this._attachedHost=t}}class Tb extends Cb{constructor(t,e,n,r){super(),this.component=t,this.viewContainerRef=e,this.injector=n,this.componentFactoryResolver=r}}class Ab extends Cb{constructor(t,e,n){super(),this.templateRef=t,this.viewContainerRef=e,this.context=n}get origin(){return this.templateRef.elementRef}attach(t,e=this.context){return this.context=e,super.attach(t)}detach(){return this.context=void 0,super.detach()}}class Mb extends Cb{constructor(t){super(),this.element=t instanceof dl?t.nativeElement:t}}class kb{constructor(){this._isDisposed=!1,this.attachDomPortal=null}hasAttached(){return!!this._attachedPortal}attach(t){return t||function(){throw Error("Must provide a portal to attach")}(),this.hasAttached()&&Eb(),this._isDisposed&&function(){throw Error("This PortalOutlet has already been disposed")}(),t instanceof Tb?(this._attachedPortal=t,this.attachComponentPortal(t)):t instanceof Ab?(this._attachedPortal=t,this.attachTemplatePortal(t)):this.attachDomPortal&&t instanceof Mb?(this._attachedPortal=t,this.attachDomPortal(t)):void function(){throw Error("Attempting to attach an unknown Portal type. BasePortalOutlet accepts either a ComponentPortal or a TemplatePortal.")}()}detach(){this._attachedPortal&&(this._attachedPortal.setAttachedHost(null),this._attachedPortal=null),this._invokeDisposeFn()}dispose(){this.hasAttached()&&this.detach(),this._invokeDisposeFn(),this._isDisposed=!0}setDisposeFn(t){this._disposeFn=t}_invokeDisposeFn(){this._disposeFn&&(this._disposeFn(),this._disposeFn=null)}}class Rb extends kb{constructor(t,e,n,r,i){super(),this.outletElement=t,this._componentFactoryResolver=e,this._appRef=n,this._defaultInjector=r,this.attachDomPortal=t=>{if(!this._document)throw Error("Cannot attach DOM portal without _document constructor parameter");const e=t.element;if(!e.parentNode)throw Error("DOM portal content must be attached to a parent node.");const n=this._document.createComment("dom-portal");e.parentNode.insertBefore(n,e),this.outletElement.appendChild(e),super.setDisposeFn(()=>{n.parentNode&&n.parentNode.replaceChild(e,n)})},this._document=i}attachComponentPortal(t){const e=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component);let n;return t.viewContainerRef?(n=t.viewContainerRef.createComponent(e,t.viewContainerRef.length,t.injector||t.viewContainerRef.injector),this.setDisposeFn(()=>n.destroy())):(n=e.create(t.injector||this._defaultInjector),this._appRef.attachView(n.hostView),this.setDisposeFn(()=>{this._appRef.detachView(n.hostView),n.destroy()})),this.outletElement.appendChild(this._getComponentRootNode(n)),n}attachTemplatePortal(t){let e=t.viewContainerRef,n=e.createEmbeddedView(t.templateRef,t.context);return n.rootNodes.forEach(t=>this.outletElement.appendChild(t)),n.detectChanges(),this.setDisposeFn(()=>{let t=e.indexOf(n);-1!==t&&e.remove(t)}),n}dispose(){super.dispose(),null!=this.outletElement.parentNode&&this.outletElement.parentNode.removeChild(this.outletElement)}_getComponentRootNode(t){return t.hostView.rootNodes[0]}}let Ib=(()=>{class t extends kb{constructor(t,e,n){super(),this._componentFactoryResolver=t,this._viewContainerRef=e,this._isInitialized=!1,this.attached=new pc,this.attachDomPortal=t=>{if(!this._document)throw Error("Cannot attach DOM portal without _document constructor parameter");const e=t.element;if(!e.parentNode)throw Error("DOM portal content must be attached to a parent node.");const n=this._document.createComment("dom-portal");t.setAttachedHost(this),e.parentNode.insertBefore(n,e),this._getRootNode().appendChild(e),super.setDisposeFn(()=>{n.parentNode&&n.parentNode.replaceChild(e,n)})},this._document=n}get portal(){return this._attachedPortal}set portal(t){(!this.hasAttached()||t||this._isInitialized)&&(this.hasAttached()&&super.detach(),t&&super.attach(t),this._attachedPortal=t)}get attachedRef(){return this._attachedRef}ngOnInit(){this._isInitialized=!0}ngOnDestroy(){super.dispose(),this._attachedPortal=null,this._attachedRef=null}attachComponentPortal(t){t.setAttachedHost(this);const e=null!=t.viewContainerRef?t.viewContainerRef:this._viewContainerRef,n=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component),r=e.createComponent(n,e.length,t.injector||e.injector);return e!==this._viewContainerRef&&this._getRootNode().appendChild(r.hostView.rootNodes[0]),super.setDisposeFn(()=>r.destroy()),this._attachedPortal=t,this._attachedRef=r,this.attached.emit(r),r}attachTemplatePortal(t){t.setAttachedHost(this);const e=this._viewContainerRef.createEmbeddedView(t.templateRef,t.context);return super.setDisposeFn(()=>this._viewContainerRef.clear()),this._attachedPortal=t,this._attachedRef=e,this.attached.emit(e),e}_getRootNode(){const t=this._viewContainerRef.element.nativeElement;return t.nodeType===t.ELEMENT_NODE?t:t.parentNode}}return t.\u0275fac=function(e){return new(e||t)(ta(ll),ta(Yl),ta(Mu))},t.\u0275dir=xe({type:t,selectors:[["","cdkPortalOutlet",""]],inputs:{portal:["cdkPortalOutlet","portal"]},outputs:{attached:"attached"},exportAs:["cdkPortalOutlet"],features:[Vo]}),t})(),Nb=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)}}),t})();class Ob{constructor(t,e){this._parentInjector=t,this._customTokens=e}get(t,e){const n=this._customTokens.get(t);return void 0!==n?n:this._parentInjector.get(t,e)}}class Db{constructor(t,e){this._viewportRuler=t,this._previousHTMLStyles={top:"",left:""},this._isEnabled=!1,this._document=e}attach(){}enable(){if(this._canBeEnabled()){const t=this._document.documentElement;this._previousScrollPosition=this._viewportRuler.getViewportScrollPosition(),this._previousHTMLStyles.left=t.style.left||"",this._previousHTMLStyles.top=t.style.top||"",t.style.left=of(-this._previousScrollPosition.left),t.style.top=of(-this._previousScrollPosition.top),t.classList.add("cdk-global-scrollblock"),this._isEnabled=!0}}disable(){if(this._isEnabled){const t=this._document.documentElement,e=t.style,n=this._document.body.style,r=e.scrollBehavior||"",i=n.scrollBehavior||"";this._isEnabled=!1,e.left=this._previousHTMLStyles.left,e.top=this._previousHTMLStyles.top,t.classList.remove("cdk-global-scrollblock"),e.scrollBehavior=n.scrollBehavior="auto",window.scroll(this._previousScrollPosition.left,this._previousScrollPosition.top),e.scrollBehavior=r,n.scrollBehavior=i}}_canBeEnabled(){if(this._document.documentElement.classList.contains("cdk-global-scrollblock")||this._isEnabled)return!1;const t=this._document.body,e=this._viewportRuler.getViewportSize();return t.scrollHeight>e.height||t.scrollWidth>e.width}}function Lb(){return Error("Scroll strategy has already been attached.")}class Fb{constructor(t,e,n,r){this._scrollDispatcher=t,this._ngZone=e,this._viewportRuler=n,this._config=r,this._scrollSubscription=null,this._detach=()=>{this.disable(),this._overlayRef.hasAttached()&&this._ngZone.run(()=>this._overlayRef.detach())}}attach(t){if(this._overlayRef)throw Lb();this._overlayRef=t}enable(){if(this._scrollSubscription)return;const t=this._scrollDispatcher.scrolled(0);this._config&&this._config.threshold&&this._config.threshold>1?(this._initialScrollPosition=this._viewportRuler.getViewportScrollPosition().top,this._scrollSubscription=t.subscribe(()=>{const t=this._viewportRuler.getViewportScrollPosition().top;Math.abs(t-this._initialScrollPosition)>this._config.threshold?this._detach():this._overlayRef.updatePosition()})):this._scrollSubscription=t.subscribe(this._detach)}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}class Pb{enable(){}disable(){}attach(){}}function $b(t,e){return e.some(e=>t.bottom<e.top||t.top>e.bottom||t.right<e.left||t.left>e.right)}function Bb(t,e){return e.some(e=>t.top<e.top||t.bottom>e.bottom||t.left<e.left||t.right>e.right)}class zb{constructor(t,e,n,r){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=n,this._config=r,this._scrollSubscription=null}attach(t){if(this._overlayRef)throw Lb();this._overlayRef=t}enable(){this._scrollSubscription||(this._scrollSubscription=this._scrollDispatcher.scrolled(this._config?this._config.scrollThrottle:0).subscribe(()=>{if(this._overlayRef.updatePosition(),this._config&&this._config.autoClose){const t=this._overlayRef.overlayElement.getBoundingClientRect(),{width:e,height:n}=this._viewportRuler.getViewportSize();$b(t,[{width:e,height:n,bottom:n,right:e,top:0,left:0}])&&(this.disable(),this._ngZone.run(()=>this._overlayRef.detach()))}}))}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}let Vb=(()=>{class t{constructor(t,e,n,r){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=n,this.noop=()=>new Pb,this.close=t=>new Fb(this._scrollDispatcher,this._ngZone,this._viewportRuler,t),this.block=()=>new Db(this._viewportRuler,this._document),this.reposition=t=>new zb(this._scrollDispatcher,this._viewportRuler,this._ngZone,t),this._document=r}}return t.\u0275fac=function(e){return new(e||t)(zr(bb),zr(xb),zr(eu),zr(Mu))},t.\u0275prov=Pt({factory:function(){return new t(zr(bb),zr(xb),zr(eu),zr(Mu))},token:t,providedIn:"root"}),t})();class Ub{constructor(t){if(this.scrollStrategy=new Pb,this.panelClass="",this.hasBackdrop=!1,this.backdropClass="cdk-overlay-dark-backdrop",this.disposeOnNavigation=!1,this.excludeFromOutsideClick=[],t){const e=Object.keys(t);for(const n of e)void 0!==t[n]&&(this[n]=t[n])}}}class Hb{constructor(t,e,n,r,i){this.offsetX=n,this.offsetY=r,this.panelClass=i,this.originX=t.originX,this.originY=t.originY,this.overlayX=e.overlayX,this.overlayY=e.overlayY}}class Wb{constructor(t,e){this.connectionPair=t,this.scrollableViewProperties=e}}function jb(t,e){if("top"!==e&&"bottom"!==e&&"center"!==e)throw Error(`ConnectedPosition: Invalid ${t} "${e}". Expected "top", "bottom" or "center".`)}function Gb(t,e){if("start"!==e&&"end"!==e&&"center"!==e)throw Error(`ConnectedPosition: Invalid ${t} "${e}". Expected "start", "end" or "center".`)}let qb=(()=>{class t{constructor(t){this._attachedOverlays=[],this._document=t}ngOnDestroy(){this.detach()}add(t){this.remove(t),this._attachedOverlays.push(t)}remove(t){const e=this._attachedOverlays.indexOf(t);e>-1&&this._attachedOverlays.splice(e,1),0===this._attachedOverlays.length&&this.detach()}}return t.\u0275fac=function(e){return new(e||t)(zr(Mu))},t.\u0275prov=Pt({factory:function(){return new t(zr(Mu))},token:t,providedIn:"root"}),t})(),Xb=(()=>{class t extends qb{constructor(t){super(t),this._keydownListener=t=>{const e=this._attachedOverlays;for(let n=e.length-1;n>-1;n--)if(e[n]._keydownEvents.observers.length>0){e[n]._keydownEvents.next(t);break}}}add(t){super.add(t),this._isAttached||(this._document.body.addEventListener("keydown",this._keydownListener),this._isAttached=!0)}detach(){this._isAttached&&(this._document.body.removeEventListener("keydown",this._keydownListener),this._isAttached=!1)}}return t.\u0275fac=function(e){return new(e||t)(zr(Mu))},t.\u0275prov=Pt({factory:function(){return new t(zr(Mu))},token:t,providedIn:"root"}),t})(),Kb=(()=>{class t extends qb{constructor(t,e){super(t),this._platform=e,this._cursorStyleIsSet=!1,this._clickListener=t=>{const e=t.composedPath?t.composedPath()[0]:t.target,n=this._attachedOverlays;for(let r=n.length-1;r>-1;r--){const i=n[r];if(!(i._outsidePointerEvents.observers.length<1)){if([...i.getConfig().excludeFromOutsideClick,i.overlayElement].some(t=>t.contains(e)))break;i._outsidePointerEvents.next(t)}}}}add(t){super.add(t),this._isAttached||(this._document.body.addEventListener("click",this._clickListener,!0),this._platform.IOS&&!this._cursorStyleIsSet&&(this._cursorOriginalValue=this._document.body.style.cursor,this._document.body.style.cursor="pointer",this._cursorStyleIsSet=!0),this._isAttached=!0)}detach(){this._isAttached&&(this._document.body.removeEventListener("click",this._clickListener,!0),this._platform.IOS&&this._cursorStyleIsSet&&(this._document.body.style.cursor=this._cursorOriginalValue,this._cursorStyleIsSet=!1),this._isAttached=!1)}}return t.\u0275fac=function(e){return new(e||t)(zr(Mu),zr(jp))},t.\u0275prov=Pt({factory:function(){return new t(zr(Mu),zr(jp))},token:t,providedIn:"root"}),t})();const Yb=!("undefined"==typeof window||!window||!window.__karma__&&!window.jasmine);let Zb=(()=>{class t{constructor(t,e){this._platform=e,this._document=t}ngOnDestroy(){const t=this._containerElement;t&&t.parentNode&&t.parentNode.removeChild(t)}getContainerElement(){return this._containerElement||this._createContainer(),this._containerElement}_createContainer(){const t=this._platform?this._platform.isBrowser:"undefined"!=typeof window,e="cdk-overlay-container";if(t||Yb){const t=this._document.querySelectorAll(`.${e}[platform="server"], .${e}[platform="test"]`);for(let e=0;e<t.length;e++)t[e].parentNode.removeChild(t[e])}const n=this._document.createElement("div");n.classList.add(e),Yb?n.setAttribute("platform","test"):t||n.setAttribute("platform","server"),this._document.body.appendChild(n),this._containerElement=n}}return t.\u0275fac=function(e){return new(e||t)(zr(Mu),zr(jp))},t.\u0275prov=Pt({factory:function(){return new t(zr(Mu),zr(jp))},token:t,providedIn:"root"}),t})();class Jb{constructor(t,e,n,r,i,s,o,a,l){this._portalOutlet=t,this._host=e,this._pane=n,this._config=r,this._ngZone=i,this._keyboardDispatcher=s,this._document=o,this._location=a,this._outsideClickDispatcher=l,this._backdropElement=null,this._backdropClick=new J,this._attachments=new J,this._detachments=new J,this._locationChanges=z.EMPTY,this._backdropClickHandler=t=>this._backdropClick.next(t),this._keydownEvents=new J,this._outsidePointerEvents=new J,r.scrollStrategy&&(this._scrollStrategy=r.scrollStrategy,this._scrollStrategy.attach(this)),this._positionStrategy=r.positionStrategy}get overlayElement(){return this._pane}get backdropElement(){return this._backdropElement}get hostElement(){return this._host}attach(t){let e=this._portalOutlet.attach(t);return!this._host.parentElement&&this._previousHostParent&&this._previousHostParent.appendChild(this._host),this._positionStrategy&&this._positionStrategy.attach(this),this._updateStackingOrder(),this._updateElementSize(),this._updateElementDirection(),this._scrollStrategy&&this._scrollStrategy.enable(),this._ngZone.onStable.asObservable().pipe(wd(1)).subscribe(()=>{this.hasAttached()&&this.updatePosition()}),this._togglePointerEvents(!0),this._config.hasBackdrop&&this._attachBackdrop(),this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!0),this._attachments.next(),this._keyboardDispatcher.add(this),this._config.disposeOnNavigation&&this._location&&(this._locationChanges=this._location.subscribe(()=>this.dispose())),this._outsideClickDispatcher&&this._outsideClickDispatcher.add(this),e}detach(){if(!this.hasAttached())return;this.detachBackdrop(),this._togglePointerEvents(!1),this._positionStrategy&&this._positionStrategy.detach&&this._positionStrategy.detach(),this._scrollStrategy&&this._scrollStrategy.disable();const t=this._portalOutlet.detach();return this._detachments.next(),this._keyboardDispatcher.remove(this),this._detachContentWhenStable(),this._locationChanges.unsubscribe(),this._outsideClickDispatcher&&this._outsideClickDispatcher.remove(this),t}dispose(){const t=this.hasAttached();this._positionStrategy&&this._positionStrategy.dispose(),this._disposeScrollStrategy(),this.detachBackdrop(),this._locationChanges.unsubscribe(),this._keyboardDispatcher.remove(this),this._portalOutlet.dispose(),this._attachments.complete(),this._backdropClick.complete(),this._keydownEvents.complete(),this._outsidePointerEvents.complete(),this._outsideClickDispatcher&&this._outsideClickDispatcher.remove(this),this._host&&this._host.parentNode&&(this._host.parentNode.removeChild(this._host),this._host=null),this._previousHostParent=this._pane=null,t&&this._detachments.next(),this._detachments.complete()}hasAttached(){return this._portalOutlet.hasAttached()}backdropClick(){return this._backdropClick.asObservable()}attachments(){return this._attachments.asObservable()}detachments(){return this._detachments.asObservable()}keydownEvents(){return this._keydownEvents.asObservable()}outsidePointerEvents(){return this._outsidePointerEvents.asObservable()}getConfig(){return this._config}updatePosition(){this._positionStrategy&&this._positionStrategy.apply()}updatePositionStrategy(t){t!==this._positionStrategy&&(this._positionStrategy&&this._positionStrategy.dispose(),this._positionStrategy=t,this.hasAttached()&&(t.attach(this),this.updatePosition()))}updateSize(t){this._config=Object.assign(Object.assign({},this._config),t),this._updateElementSize()}setDirection(t){this._config=Object.assign(Object.assign({},this._config),{direction:t}),this._updateElementDirection()}addPanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!0)}removePanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!1)}getDirection(){const t=this._config.direction;return t?"string"==typeof t?t:t.value:"ltr"}updateScrollStrategy(t){t!==this._scrollStrategy&&(this._disposeScrollStrategy(),this._scrollStrategy=t,this.hasAttached()&&(t.attach(this),t.enable()))}_updateElementDirection(){this._host.setAttribute("dir",this.getDirection())}_updateElementSize(){if(!this._pane)return;const t=this._pane.style;t.width=of(this._config.width),t.height=of(this._config.height),t.minWidth=of(this._config.minWidth),t.minHeight=of(this._config.minHeight),t.maxWidth=of(this._config.maxWidth),t.maxHeight=of(this._config.maxHeight)}_togglePointerEvents(t){this._pane.style.pointerEvents=t?"auto":"none"}_attachBackdrop(){const t="cdk-overlay-backdrop-showing";this._backdropElement=this._document.createElement("div"),this._backdropElement.classList.add("cdk-overlay-backdrop"),this._config.backdropClass&&this._toggleClasses(this._backdropElement,this._config.backdropClass,!0),this._host.parentElement.insertBefore(this._backdropElement,this._host),this._backdropElement.addEventListener("click",this._backdropClickHandler),"undefined"!=typeof requestAnimationFrame?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>{this._backdropElement&&this._backdropElement.classList.add(t)})}):this._backdropElement.classList.add(t)}_updateStackingOrder(){this._host.nextSibling&&this._host.parentNode.appendChild(this._host)}detachBackdrop(){let t,e=this._backdropElement;if(!e)return;let n=()=>{e&&(e.removeEventListener("click",this._backdropClickHandler),e.removeEventListener("transitionend",n),e.parentNode&&e.parentNode.removeChild(e)),this._backdropElement==e&&(this._backdropElement=null),this._config.backdropClass&&this._toggleClasses(e,this._config.backdropClass,!1),clearTimeout(t)};e.classList.remove("cdk-overlay-backdrop-showing"),this._ngZone.runOutsideAngular(()=>{e.addEventListener("transitionend",n)}),e.style.pointerEvents="none",t=this._ngZone.runOutsideAngular(()=>setTimeout(n,500))}_toggleClasses(t,e,n){const r=t.classList;sf(e).forEach(t=>{t&&(n?r.add(t):r.remove(t))})}_detachContentWhenStable(){this._ngZone.runOutsideAngular(()=>{const t=this._ngZone.onStable.asObservable().pipe(Dd(_t(this._attachments,this._detachments))).subscribe(()=>{this._pane&&this._host&&0!==this._pane.children.length||(this._pane&&this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!1),this._host&&this._host.parentElement&&(this._previousHostParent=this._host.parentElement,this._previousHostParent.removeChild(this._host)),t.unsubscribe())})})}_disposeScrollStrategy(){const t=this._scrollStrategy;t&&(t.disable(),t.detach&&t.detach())}}const Qb="cdk-overlay-connected-position-bounding-box",t_=/([A-Za-z%]+)$/;class e_{constructor(t,e,n,r,i){this._viewportRuler=e,this._document=n,this._platform=r,this._overlayContainer=i,this._lastBoundingBoxSize={width:0,height:0},this._isPushed=!1,this._canPush=!0,this._growAfterOpen=!1,this._hasFlexibleDimensions=!0,this._positionLocked=!1,this._viewportMargin=0,this._scrollables=[],this._preferredPositions=[],this._positionChanges=new J,this._resizeSubscription=z.EMPTY,this._offsetX=0,this._offsetY=0,this._appliedPanelClasses=[],this.positionChanges=this._positionChanges.asObservable(),this.setOrigin(t)}get positions(){return this._preferredPositions}attach(t){if(this._overlayRef&&t!==this._overlayRef)throw Error("This position strategy is already attached to an overlay");this._validatePositions(),t.hostElement.classList.add(Qb),this._overlayRef=t,this._boundingBox=t.hostElement,this._pane=t.overlayElement,this._isDisposed=!1,this._isInitialRender=!0,this._lastPosition=null,this._resizeSubscription.unsubscribe(),this._resizeSubscription=this._viewportRuler.change().subscribe(()=>{this._isInitialRender=!0,this.apply()})}apply(){if(this._isDisposed||!this._platform.isBrowser)return;if(!this._isInitialRender&&this._positionLocked&&this._lastPosition)return void this.reapplyLastPosition();this._clearPanelClasses(),this._resetOverlayElementStyles(),this._resetBoundingBoxStyles(),this._viewportRect=this._getNarrowedViewportRect(),this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect();const t=this._originRect,e=this._overlayRect,n=this._viewportRect,r=[];let i;for(let s of this._preferredPositions){let o=this._getOriginPoint(t,s),a=this._getOverlayPoint(o,e,s),l=this._getOverlayFit(a,e,n,s);if(l.isCompletelyWithinViewport)return this._isPushed=!1,void this._applyPosition(s,o);this._canFitWithFlexibleDimensions(l,a,n)?r.push({position:s,origin:o,overlayRect:e,boundingBoxRect:this._calculateBoundingBoxRect(o,s)}):(!i||i.overlayFit.visibleArea<l.visibleArea)&&(i={overlayFit:l,overlayPoint:a,originPoint:o,position:s,overlayRect:e})}if(r.length){let t=null,e=-1;for(const n of r){const r=n.boundingBoxRect.width*n.boundingBoxRect.height*(n.position.weight||1);r>e&&(e=r,t=n)}return this._isPushed=!1,void this._applyPosition(t.position,t.origin)}if(this._canPush)return this._isPushed=!0,void this._applyPosition(i.position,i.originPoint);this._applyPosition(i.position,i.originPoint)}detach(){this._clearPanelClasses(),this._lastPosition=null,this._previousPushAmount=null,this._resizeSubscription.unsubscribe()}dispose(){this._isDisposed||(this._boundingBox&&n_(this._boundingBox.style,{top:"",left:"",right:"",bottom:"",height:"",width:"",alignItems:"",justifyContent:""}),this._pane&&this._resetOverlayElementStyles(),this._overlayRef&&this._overlayRef.hostElement.classList.remove(Qb),this.detach(),this._positionChanges.complete(),this._overlayRef=this._boundingBox=null,this._isDisposed=!0)}reapplyLastPosition(){if(!this._isDisposed&&(!this._platform||this._platform.isBrowser)){this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._viewportRect=this._getNarrowedViewportRect();const t=this._lastPosition||this._preferredPositions[0],e=this._getOriginPoint(this._originRect,t);this._applyPosition(t,e)}}withScrollableContainers(t){return this._scrollables=t,this}withPositions(t){return this._preferredPositions=t,-1===t.indexOf(this._lastPosition)&&(this._lastPosition=null),this._validatePositions(),this}withViewportMargin(t){return this._viewportMargin=t,this}withFlexibleDimensions(t=!0){return this._hasFlexibleDimensions=t,this}withGrowAfterOpen(t=!0){return this._growAfterOpen=t,this}withPush(t=!0){return this._canPush=t,this}withLockedPosition(t=!0){return this._positionLocked=t,this}setOrigin(t){return this._origin=t,this}withDefaultOffsetX(t){return this._offsetX=t,this}withDefaultOffsetY(t){return this._offsetY=t,this}withTransformOriginOn(t){return this._transformOriginSelector=t,this}_getOriginPoint(t,e){let n,r;if("center"==e.originX)n=t.left+t.width/2;else{const r=this._isRtl()?t.right:t.left,i=this._isRtl()?t.left:t.right;n="start"==e.originX?r:i}return r="center"==e.originY?t.top+t.height/2:"top"==e.originY?t.top:t.bottom,{x:n,y:r}}_getOverlayPoint(t,e,n){let r,i;return r="center"==n.overlayX?-e.width/2:"start"===n.overlayX?this._isRtl()?-e.width:0:this._isRtl()?0:-e.width,i="center"==n.overlayY?-e.height/2:"top"==n.overlayY?0:-e.height,{x:t.x+r,y:t.y+i}}_getOverlayFit(t,e,n,r){let{x:i,y:s}=t,o=this._getOffset(r,"x"),a=this._getOffset(r,"y");o&&(i+=o),a&&(s+=a);let l=0-s,c=s+e.height-n.height,u=this._subtractOverflows(e.width,0-i,i+e.width-n.width),h=this._subtractOverflows(e.height,l,c),d=u*h;return{visibleArea:d,isCompletelyWithinViewport:e.width*e.height===d,fitsInViewportVertically:h===e.height,fitsInViewportHorizontally:u==e.width}}_canFitWithFlexibleDimensions(t,e,n){if(this._hasFlexibleDimensions){const r=n.bottom-e.y,i=n.right-e.x,s=r_(this._overlayRef.getConfig().minHeight),o=r_(this._overlayRef.getConfig().minWidth),a=t.fitsInViewportHorizontally||null!=o&&o<=i;return(t.fitsInViewportVertically||null!=s&&s<=r)&&a}return!1}_pushOverlayOnScreen(t,e,n){if(this._previousPushAmount&&this._positionLocked)return{x:t.x+this._previousPushAmount.x,y:t.y+this._previousPushAmount.y};const r=this._viewportRect,i=Math.max(t.x+e.width-r.width,0),s=Math.max(t.y+e.height-r.height,0),o=Math.max(r.top-n.top-t.y,0),a=Math.max(r.left-n.left-t.x,0);let l=0,c=0;return l=e.width<=r.width?a||-i:t.x<this._viewportMargin?r.left-n.left-t.x:0,c=e.height<=r.height?o||-s:t.y<this._viewportMargin?r.top-n.top-t.y:0,this._previousPushAmount={x:l,y:c},{x:t.x+l,y:t.y+c}}_applyPosition(t,e){if(this._setTransformOrigin(t),this._setOverlayElementStyles(e,t),this._setBoundingBoxStyles(e,t),t.panelClass&&this._addPanelClasses(t.panelClass),this._lastPosition=t,this._positionChanges.observers.length){const e=this._getScrollVisibility(),n=new Wb(t,e);this._positionChanges.next(n)}this._isInitialRender=!1}_setTransformOrigin(t){if(!this._transformOriginSelector)return;const e=this._boundingBox.querySelectorAll(this._transformOriginSelector);let n,r=t.overlayY;n="center"===t.overlayX?"center":this._isRtl()?"start"===t.overlayX?"right":"left":"start"===t.overlayX?"left":"right";for(let i=0;i<e.length;i++)e[i].style.transformOrigin=`${n} ${r}`}_calculateBoundingBoxRect(t,e){const n=this._viewportRect,r=this._isRtl();let i,s,o,a,l,c;if("top"===e.overlayY)s=t.y,i=n.height-s+this._viewportMargin;else if("bottom"===e.overlayY)o=n.height-t.y+2*this._viewportMargin,i=n.height-o+this._viewportMargin;else{const e=Math.min(n.bottom-t.y+n.top,t.y),r=this._lastBoundingBoxSize.height;i=2*e,s=t.y-e,i>r&&!this._isInitialRender&&!this._growAfterOpen&&(s=t.y-r/2)}if("end"===e.overlayX&&!r||"start"===e.overlayX&&r)c=n.width-t.x+this._viewportMargin,a=t.x-this._viewportMargin;else if("start"===e.overlayX&&!r||"end"===e.overlayX&&r)l=t.x,a=n.right-t.x;else{const e=Math.min(n.right-t.x+n.left,t.x),r=this._lastBoundingBoxSize.width;a=2*e,l=t.x-e,a>r&&!this._isInitialRender&&!this._growAfterOpen&&(l=t.x-r/2)}return{top:s,left:l,bottom:o,right:c,width:a,height:i}}_setBoundingBoxStyles(t,e){const n=this._calculateBoundingBoxRect(t,e);this._isInitialRender||this._growAfterOpen||(n.height=Math.min(n.height,this._lastBoundingBoxSize.height),n.width=Math.min(n.width,this._lastBoundingBoxSize.width));const r={};if(this._hasExactPosition())r.top=r.left="0",r.bottom=r.right=r.maxHeight=r.maxWidth="",r.width=r.height="100%";else{const t=this._overlayRef.getConfig().maxHeight,i=this._overlayRef.getConfig().maxWidth;r.height=of(n.height),r.top=of(n.top),r.bottom=of(n.bottom),r.width=of(n.width),r.left=of(n.left),r.right=of(n.right),r.alignItems="center"===e.overlayX?"center":"end"===e.overlayX?"flex-end":"flex-start",r.justifyContent="center"===e.overlayY?"center":"bottom"===e.overlayY?"flex-end":"flex-start",t&&(r.maxHeight=of(t)),i&&(r.maxWidth=of(i))}this._lastBoundingBoxSize=n,n_(this._boundingBox.style,r)}_resetBoundingBoxStyles(){n_(this._boundingBox.style,{top:"0",left:"0",right:"0",bottom:"0",height:"",width:"",alignItems:"",justifyContent:""})}_resetOverlayElementStyles(){n_(this._pane.style,{top:"",left:"",bottom:"",right:"",position:"",transform:""})}_setOverlayElementStyles(t,e){const n={},r=this._hasExactPosition(),i=this._hasFlexibleDimensions,s=this._overlayRef.getConfig();if(r){const r=this._viewportRuler.getViewportScrollPosition();n_(n,this._getExactOverlayY(e,t,r)),n_(n,this._getExactOverlayX(e,t,r))}else n.position="static";let o="",a=this._getOffset(e,"x"),l=this._getOffset(e,"y");a&&(o+=`translateX(${a}px) `),l&&(o+=`translateY(${l}px)`),n.transform=o.trim(),s.maxHeight&&(r?n.maxHeight=of(s.maxHeight):i&&(n.maxHeight="")),s.maxWidth&&(r?n.maxWidth=of(s.maxWidth):i&&(n.maxWidth="")),n_(this._pane.style,n)}_getExactOverlayY(t,e,n){let r={top:"",bottom:""},i=this._getOverlayPoint(e,this._overlayRect,t);this._isPushed&&(i=this._pushOverlayOnScreen(i,this._overlayRect,n));let s=this._overlayContainer.getContainerElement().getBoundingClientRect().top;return i.y-=s,"bottom"===t.overlayY?r.bottom=this._document.documentElement.clientHeight-(i.y+this._overlayRect.height)+"px":r.top=of(i.y),r}_getExactOverlayX(t,e,n){let r,i={left:"",right:""},s=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(s=this._pushOverlayOnScreen(s,this._overlayRect,n)),r=this._isRtl()?"end"===t.overlayX?"left":"right":"end"===t.overlayX?"right":"left","right"===r?i.right=this._document.documentElement.clientWidth-(s.x+this._overlayRect.width)+"px":i.left=of(s.x),i}_getScrollVisibility(){const t=this._getOriginRect(),e=this._pane.getBoundingClientRect(),n=this._scrollables.map(t=>t.getElementRef().nativeElement.getBoundingClientRect());return{isOriginClipped:Bb(t,n),isOriginOutsideView:$b(t,n),isOverlayClipped:Bb(e,n),isOverlayOutsideView:$b(e,n)}}_subtractOverflows(t,...e){return e.reduce((t,e)=>t-Math.max(e,0),t)}_getNarrowedViewportRect(){const t=this._document.documentElement.clientWidth,e=this._document.documentElement.clientHeight,n=this._viewportRuler.getViewportScrollPosition();return{top:n.top+this._viewportMargin,left:n.left+this._viewportMargin,right:n.left+t-this._viewportMargin,bottom:n.top+e-this._viewportMargin,width:t-2*this._viewportMargin,height:e-2*this._viewportMargin}}_isRtl(){return"rtl"===this._overlayRef.getDirection()}_hasExactPosition(){return!this._hasFlexibleDimensions||this._isPushed}_getOffset(t,e){return"x"===e?null==t.offsetX?this._offsetX:t.offsetX:null==t.offsetY?this._offsetY:t.offsetY}_validatePositions(){if(!this._preferredPositions.length)throw Error("FlexibleConnectedPositionStrategy: At least one position is required.");this._preferredPositions.forEach(t=>{Gb("originX",t.originX),jb("originY",t.originY),Gb("overlayX",t.overlayX),jb("overlayY",t.overlayY)})}_addPanelClasses(t){this._pane&&sf(t).forEach(t=>{""!==t&&-1===this._appliedPanelClasses.indexOf(t)&&(this._appliedPanelClasses.push(t),this._pane.classList.add(t))})}_clearPanelClasses(){this._pane&&(this._appliedPanelClasses.forEach(t=>{this._pane.classList.remove(t)}),this._appliedPanelClasses=[])}_getOriginRect(){const t=this._origin;if(t instanceof dl)return t.nativeElement.getBoundingClientRect();if(t instanceof Element)return t.getBoundingClientRect();const e=t.width||0,n=t.height||0;return{top:t.y,bottom:t.y+n,left:t.x,right:t.x+e,height:n,width:e}}}function n_(t,e){for(let n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}function r_(t){if("number"!=typeof t&&null!=t){const[e,n]=t.split(t_);return n&&"px"!==n?null:parseFloat(e)}return t||null}class i_{constructor(t,e,n,r,i,s,o){this._preferredPositions=[],this._positionStrategy=new e_(n,r,i,s,o).withFlexibleDimensions(!1).withPush(!1).withViewportMargin(0),this.withFallbackPosition(t,e)}get onPositionChange(){return this._positionStrategy.positionChanges}get positions(){return this._preferredPositions}attach(t){this._overlayRef=t,this._positionStrategy.attach(t),this._direction&&(t.setDirection(this._direction),this._direction=null)}dispose(){this._positionStrategy.dispose()}detach(){this._positionStrategy.detach()}apply(){this._positionStrategy.apply()}recalculateLastPosition(){this._positionStrategy.reapplyLastPosition()}withScrollableContainers(t){this._positionStrategy.withScrollableContainers(t)}withFallbackPosition(t,e,n,r){const i=new Hb(t,e,n,r);return this._preferredPositions.push(i),this._positionStrategy.withPositions(this._preferredPositions),this}withDirection(t){return this._overlayRef?this._overlayRef.setDirection(t):this._direction=t,this}withOffsetX(t){return this._positionStrategy.withDefaultOffsetX(t),this}withOffsetY(t){return this._positionStrategy.withDefaultOffsetY(t),this}withLockedPosition(t){return this._positionStrategy.withLockedPosition(t),this}withPositions(t){return this._preferredPositions=t.slice(),this._positionStrategy.withPositions(this._preferredPositions),this}setOrigin(t){return this._positionStrategy.setOrigin(t),this}}const s_="cdk-global-overlay-wrapper";class o_{constructor(){this._cssPosition="static",this._topOffset="",this._bottomOffset="",this._leftOffset="",this._rightOffset="",this._alignItems="",this._justifyContent="",this._width="",this._height=""}attach(t){const e=t.getConfig();this._overlayRef=t,this._width&&!e.width&&t.updateSize({width:this._width}),this._height&&!e.height&&t.updateSize({height:this._height}),t.hostElement.classList.add(s_),this._isDisposed=!1}top(t=""){return this._bottomOffset="",this._topOffset=t,this._alignItems="flex-start",this}left(t=""){return this._rightOffset="",this._leftOffset=t,this._justifyContent="flex-start",this}bottom(t=""){return this._topOffset="",this._bottomOffset=t,this._alignItems="flex-end",this}right(t=""){return this._leftOffset="",this._rightOffset=t,this._justifyContent="flex-end",this}width(t=""){return this._overlayRef?this._overlayRef.updateSize({width:t}):this._width=t,this}height(t=""){return this._overlayRef?this._overlayRef.updateSize({height:t}):this._height=t,this}centerHorizontally(t=""){return this.left(t),this._justifyContent="center",this}centerVertically(t=""){return this.top(t),this._alignItems="center",this}apply(){if(!this._overlayRef||!this._overlayRef.hasAttached())return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement.style,n=this._overlayRef.getConfig(),{width:r,height:i,maxWidth:s,maxHeight:o}=n,a=!("100%"!==r&&"100vw"!==r||s&&"100%"!==s&&"100vw"!==s),l=!("100%"!==i&&"100vh"!==i||o&&"100%"!==o&&"100vh"!==o);t.position=this._cssPosition,t.marginLeft=a?"0":this._leftOffset,t.marginTop=l?"0":this._topOffset,t.marginBottom=this._bottomOffset,t.marginRight=this._rightOffset,a?e.justifyContent="flex-start":"center"===this._justifyContent?e.justifyContent="center":"rtl"===this._overlayRef.getConfig().direction?"flex-start"===this._justifyContent?e.justifyContent="flex-end":"flex-end"===this._justifyContent&&(e.justifyContent="flex-start"):e.justifyContent=this._justifyContent,e.alignItems=l?"flex-start":this._alignItems}dispose(){if(this._isDisposed||!this._overlayRef)return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement,n=e.style;e.classList.remove(s_),n.justifyContent=n.alignItems=t.marginTop=t.marginBottom=t.marginLeft=t.marginRight=t.position="",this._overlayRef=null,this._isDisposed=!0}}let a_=(()=>{class t{constructor(t,e,n,r){this._viewportRuler=t,this._document=e,this._platform=n,this._overlayContainer=r}global(){return new o_}connectedTo(t,e,n){return new i_(e,n,t,this._viewportRuler,this._document,this._platform,this._overlayContainer)}flexibleConnectedTo(t){return new e_(t,this._viewportRuler,this._document,this._platform,this._overlayContainer)}}return t.\u0275fac=function(e){return new(e||t)(zr(xb),zr(Mu),zr(jp),zr(Zb))},t.\u0275prov=Pt({factory:function(){return new t(zr(xb),zr(Mu),zr(jp),zr(Zb))},token:t,providedIn:"root"}),t})(),l_=0,c_=(()=>{class t{constructor(t,e,n,r,i,s,o,a,l,c,u){this.scrollStrategies=t,this._overlayContainer=e,this._componentFactoryResolver=n,this._positionBuilder=r,this._keyboardDispatcher=i,this._injector=s,this._ngZone=o,this._document=a,this._directionality=l,this._location=c,this._outsideClickDispatcher=u}create(t){const e=this._createHostElement(),n=this._createPaneElement(e),r=this._createPortalOutlet(n),i=new Ub(t);return i.direction=i.direction||this._directionality.value,new Jb(r,e,n,i,this._ngZone,this._keyboardDispatcher,this._document,this._location,this._outsideClickDispatcher)}position(){return this._positionBuilder}_createPaneElement(t){const e=this._document.createElement("div");return e.id="cdk-overlay-"+l_++,e.classList.add("cdk-overlay-pane"),t.appendChild(e),e}_createHostElement(){const t=this._document.createElement("div");return this._overlayContainer.getContainerElement().appendChild(t),t}_createPortalOutlet(t){return this._appRef||(this._appRef=this._injector.get(xu)),new Rb(t,this._componentFactoryResolver,this._appRef,this._injector,this._document)}}return t.\u0275fac=function(e){return new(e||t)(zr(Vb),zr(Zb),zr(ll),zr(a_),zr(Xb),zr(Bo),zr(eu),zr(Mu),zr(Pf),zr(Vu,8),zr(Kb,8))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();const u_={provide:new Er("cdk-connected-overlay-scroll-strategy"),deps:[c_],useFactory:function(t){return()=>t.scrollStrategies.reposition()}};let h_=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},providers:[c_,u_],imports:[[$f,Nb,Sb],Sb]}),t})();function d_(t,e){}class p_{constructor(){this.role="dialog",this.panelClass="",this.hasBackdrop=!0,this.backdropClass="",this.disableClose=!1,this.width="",this.height="",this.maxWidth="80vw",this.data=null,this.ariaDescribedBy=null,this.ariaLabelledBy=null,this.ariaLabel=null,this.autoFocus=!0,this.restoreFocus=!0,this.closeOnNavigation=!0}}const f_={dialogContainer:Wf("dialogContainer",[Xf("void, exit",qf({opacity:0,transform:"scale(0.7)"})),Xf("enter",qf({transform:"none"})),Yf("* => enter",jf("150ms cubic-bezier(0, 0, 0.2, 1)",qf({transform:"none",opacity:1}))),Yf("* => void, * => exit",jf("75ms cubic-bezier(0.4, 0.0, 0.2, 1)",qf({opacity:0})))])};function m_(){throw Error("Attempting to attach dialog content after content is already attached")}let g_=(()=>{class t extends kb{constructor(t,e,n,r,i,s){super(),this._elementRef=t,this._focusTrapFactory=e,this._changeDetectorRef=n,this._config=i,this._focusMonitor=s,this._elementFocusedBeforeDialogWasOpened=null,this._closeInteractionType=null,this._state="enter",this._animationStateChanged=new pc,this.attachDomPortal=t=>(this._portalOutlet.hasAttached()&&m_(),this._setupFocusTrap(),this._portalOutlet.attachDomPortal(t)),this._ariaLabelledBy=i.ariaLabelledBy||null,this._document=r}attachComponentPortal(t){return this._portalOutlet.hasAttached()&&m_(),this._setupFocusTrap(),this._portalOutlet.attachComponentPortal(t)}attachTemplatePortal(t){return this._portalOutlet.hasAttached()&&m_(),this._setupFocusTrap(),this._portalOutlet.attachTemplatePortal(t)}_recaptureFocus(){this._containsFocus()||(!this._config.autoFocus||!this._focusTrap.focusInitialElement())&&this._elementRef.nativeElement.focus()}_trapFocus(){this._config.autoFocus?this._focusTrap.focusInitialElementWhenReady():this._containsFocus()||this._elementRef.nativeElement.focus()}_restoreFocus(){const t=this._elementFocusedBeforeDialogWasOpened;if(this._config.restoreFocus&&t&&"function"==typeof t.focus){const e=this._document.activeElement,n=this._elementRef.nativeElement;e&&e!==this._document.body&&e!==n&&!n.contains(e)||(this._focusMonitor?(this._focusMonitor.focusVia(t,this._closeInteractionType),this._closeInteractionType=null):t.focus())}this._focusTrap&&this._focusTrap.destroy()}_setupFocusTrap(){this._focusTrap||(this._focusTrap=this._focusTrapFactory.create(this._elementRef.nativeElement)),this._document&&(this._elementFocusedBeforeDialogWasOpened=this._document.activeElement,this._elementRef.nativeElement.focus&&Promise.resolve().then(()=>this._elementRef.nativeElement.focus()))}_containsFocus(){const t=this._elementRef.nativeElement,e=this._document.activeElement;return t===e||t.contains(e)}_onAnimationDone(t){"enter"===t.toState?this._trapFocus():"exit"===t.toState&&this._restoreFocus(),this._animationStateChanged.emit(t)}_onAnimationStart(t){this._animationStateChanged.emit(t)}_startExitAnimation(){this._state="exit",this._changeDetectorRef.markForCheck()}}return t.\u0275fac=function(e){return new(e||t)(ta(dl),ta(wf),ta($l),ta(Mu,8),ta(p_),ta(kf))},t.\u0275cmp=me({type:t,selectors:[["mat-dialog-container"]],viewQuery:function(t,e){if(1&t&&Tc(Ib,3),2&t){let t;Cc(t=Mc())&&(e._portalOutlet=t.first)}},hostAttrs:["tabindex","-1","aria-modal","true",1,"mat-dialog-container"],hostVars:6,hostBindings:function(t,e){1&t&&pa("@dialogContainer.start",function(t){return e._onAnimationStart(t)})("@dialogContainer.done",function(t){return e._onAnimationDone(t)}),2&t&&(Jo("id",e._id)("role",e._config.role)("aria-labelledby",e._config.ariaLabel?null:e._ariaLabelledBy)("aria-label",e._config.ariaLabel)("aria-describedby",e._config.ariaDescribedBy||null),Ha("@dialogContainer",e._state))},features:[Vo],decls:1,vars:0,consts:[["cdkPortalOutlet",""]],template:function(t,e){1&t&&Qo(0,d_,0,0,"ng-template",0)},directives:[Ib],styles:[".mat-dialog-container{display:block;padding:24px;border-radius:4px;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}.cdk-high-contrast-active .mat-dialog-container{outline:solid 1px}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{margin:0 0 20px;display:block}.mat-dialog-actions{padding:8px 0;display:flex;flex-wrap:wrap;min-height:52px;align-items:center;margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}.mat-dialog-actions .mat-button-base+.mat-button-base,.mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}\n"],encapsulation:2,data:{animation:[f_.dialogContainer]}}),t})(),y_=0;class v_{constructor(t,e,n="mat-dialog-"+y_++){this._overlayRef=t,this._containerInstance=e,this.id=n,this.disableClose=this._containerInstance._config.disableClose,this._afterOpened=new J,this._afterClosed=new J,this._beforeClosed=new J,this._state=0,e._id=n,e._animationStateChanged.pipe(yd(t=>"done"===t.phaseName&&"enter"===t.toState),wd(1)).subscribe(()=>{this._afterOpened.next(),this._afterOpened.complete()}),e._animationStateChanged.pipe(yd(t=>"done"===t.phaseName&&"exit"===t.toState),wd(1)).subscribe(()=>{clearTimeout(this._closeFallbackTimeout),this._finishDialogClose()}),t.detachments().subscribe(()=>{this._beforeClosed.next(this._result),this._beforeClosed.complete(),this._afterClosed.next(this._result),this._afterClosed.complete(),this.componentInstance=null,this._overlayRef.dispose()}),t.keydownEvents().pipe(yd(t=>27===t.keyCode&&!this.disableClose&&!Yp(t))).subscribe(t=>{t.preventDefault(),b_(this,"keyboard")}),t.backdropClick().subscribe(()=>{this.disableClose?this._containerInstance._recaptureFocus():b_(this,"mouse")})}close(t){this._result=t,this._containerInstance._animationStateChanged.pipe(yd(t=>"start"===t.phaseName),wd(1)).subscribe(e=>{this._beforeClosed.next(t),this._beforeClosed.complete(),this._overlayRef.detachBackdrop(),this._closeFallbackTimeout=setTimeout(()=>this._finishDialogClose(),e.totalTime+100)}),this._containerInstance._startExitAnimation(),this._state=1}afterOpened(){return this._afterOpened.asObservable()}afterClosed(){return this._afterClosed.asObservable()}beforeClosed(){return this._beforeClosed.asObservable()}backdropClick(){return this._overlayRef.backdropClick()}keydownEvents(){return this._overlayRef.keydownEvents()}updatePosition(t){let e=this._getPositionStrategy();return t&&(t.left||t.right)?t.left?e.left(t.left):e.right(t.right):e.centerHorizontally(),t&&(t.top||t.bottom)?t.top?e.top(t.top):e.bottom(t.bottom):e.centerVertically(),this._overlayRef.updatePosition(),this}updateSize(t="",e=""){return this._getPositionStrategy().width(t).height(e),this._overlayRef.updatePosition(),this}addPanelClass(t){return this._overlayRef.addPanelClass(t),this}removePanelClass(t){return this._overlayRef.removePanelClass(t),this}getState(){return this._state}_finishDialogClose(){this._state=2,this._overlayRef.dispose()}_getPositionStrategy(){return this._overlayRef.getConfig().positionStrategy}}function b_(t,e,n){return void 0!==t._containerInstance&&(t._containerInstance._closeInteractionType=e),t.close(n)}const __=new Er("MatDialogData"),x_=new Er("mat-dialog-default-options"),w_=new Er("mat-dialog-scroll-strategy"),S_={provide:w_,deps:[c_],useFactory:function(t){return()=>t.scrollStrategies.block()}};let E_=(()=>{class t{constructor(t,e,n,r,i,s,o){var a;this._overlay=t,this._injector=e,this._defaultOptions=r,this._parentDialog=s,this._overlayContainer=o,this._openDialogsAtThisLevel=[],this._afterAllClosedAtThisLevel=new J,this._afterOpenedAtThisLevel=new J,this._ariaHiddenElements=new Map,this.afterAllClosed=(a=()=>this.openDialogs.length?this._getAfterAllClosed():this._getAfterAllClosed().pipe(Vf(void 0)),new q(t=>{let e;try{e=a()}catch(n){return void t.error(n)}return(e?ht(e):Yh()).subscribe(t)})),this._scrollStrategy=i}get openDialogs(){return this._parentDialog?this._parentDialog.openDialogs:this._openDialogsAtThisLevel}get afterOpened(){return this._parentDialog?this._parentDialog.afterOpened:this._afterOpenedAtThisLevel}_getAfterAllClosed(){const t=this._parentDialog;return t?t._getAfterAllClosed():this._afterAllClosedAtThisLevel}open(t,e){if((e=function(t,e){return Object.assign(Object.assign({},e),t)}(e,this._defaultOptions||new p_)).id&&this.getDialogById(e.id))throw Error(`Dialog with id "${e.id}" exists already. The dialog id must be unique.`);const n=this._createOverlay(e),r=this._attachDialogContainer(n,e),i=this._attachDialogContent(t,r,n,e);return this.openDialogs.length||this._hideNonDialogContentFromAssistiveTechnology(),this.openDialogs.push(i),i.afterClosed().subscribe(()=>this._removeOpenDialog(i)),this.afterOpened.next(i),i}closeAll(){this._closeDialogs(this.openDialogs)}getDialogById(t){return this.openDialogs.find(e=>e.id===t)}ngOnDestroy(){this._closeDialogs(this._openDialogsAtThisLevel),this._afterAllClosedAtThisLevel.complete(),this._afterOpenedAtThisLevel.complete()}_createOverlay(t){const e=this._getOverlayConfig(t);return this._overlay.create(e)}_getOverlayConfig(t){const e=new Ub({positionStrategy:this._overlay.position().global(),scrollStrategy:t.scrollStrategy||this._scrollStrategy(),panelClass:t.panelClass,hasBackdrop:t.hasBackdrop,direction:t.direction,minWidth:t.minWidth,minHeight:t.minHeight,maxWidth:t.maxWidth,maxHeight:t.maxHeight,disposeOnNavigation:t.closeOnNavigation});return t.backdropClass&&(e.backdropClass=t.backdropClass),e}_attachDialogContainer(t,e){const n=Bo.create({parent:e&&e.viewContainerRef&&e.viewContainerRef.injector||this._injector,providers:[{provide:p_,useValue:e}]}),r=new Tb(g_,e.viewContainerRef,n,e.componentFactoryResolver);return t.attach(r).instance}_attachDialogContent(t,e,n,r){const i=new v_(n,e,r.id);if(t instanceof Wl)e.attachTemplatePortal(new Ab(t,null,{$implicit:r.data,dialogRef:i}));else{const n=this._createInjector(r,i,e),s=e.attachComponentPortal(new Tb(t,r.viewContainerRef,n));i.componentInstance=s.instance}return i.updateSize(r.width,r.height).updatePosition(r.position),i}_createInjector(t,e,n){const r=t&&t.viewContainerRef&&t.viewContainerRef.injector,i=[{provide:g_,useValue:n},{provide:__,useValue:t.data},{provide:v_,useValue:e}];return!t.direction||r&&r.get(Pf,null)||i.push({provide:Pf,useValue:{value:t.direction,change:Zh()}}),Bo.create({parent:r||this._injector,providers:i})}_removeOpenDialog(t){const e=this.openDialogs.indexOf(t);e>-1&&(this.openDialogs.splice(e,1),this.openDialogs.length||(this._ariaHiddenElements.forEach((t,e)=>{t?e.setAttribute("aria-hidden",t):e.removeAttribute("aria-hidden")}),this._ariaHiddenElements.clear(),this._getAfterAllClosed().next()))}_hideNonDialogContentFromAssistiveTechnology(){const t=this._overlayContainer.getContainerElement();if(t.parentElement){const e=t.parentElement.children;for(let n=e.length-1;n>-1;n--){let r=e[n];r===t||"SCRIPT"===r.nodeName||"STYLE"===r.nodeName||r.hasAttribute("aria-live")||(this._ariaHiddenElements.set(r,r.getAttribute("aria-hidden")),r.setAttribute("aria-hidden","true"))}}}_closeDialogs(t){let e=t.length;for(;e--;)t[e].close()}}return t.\u0275fac=function(e){return new(e||t)(zr(c_),zr(Bo),zr(Vu,8),zr(x_,8),zr(w_),zr(t,12),zr(Zb))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})(),C_=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},providers:[E_,S_],imports:[[h_,Nb,Ry],Ry]}),t})();const T_=["mat-button",""],A_=["*"],M_=["mat-button","mat-flat-button","mat-icon-button","mat-raised-button","mat-stroked-button","mat-mini-fab","mat-fab"];class k_{constructor(t){this._elementRef=t}}const R_=Ny(Iy(Oy(k_)));let I_=(()=>{class t extends R_{constructor(t,e,n){super(t),this._focusMonitor=e,this._animationMode=n,this.isRoundButton=this._hasHostAttributes("mat-fab","mat-mini-fab"),this.isIconButton=this._hasHostAttributes("mat-icon-button");for(const r of M_)this._hasHostAttributes(r)&&this._getHostElement().classList.add(r);t.nativeElement.classList.add("mat-button-base"),this.isRoundButton&&(this.color="accent")}ngAfterViewInit(){this._focusMonitor.monitor(this._elementRef,!0)}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef)}focus(t="program",e){this._focusMonitor.focusVia(this._getHostElement(),t,e)}_getHostElement(){return this._elementRef.nativeElement}_isRippleDisabled(){return this.disableRipple||this.disabled}_hasHostAttributes(...t){return t.some(t=>this._getHostElement().hasAttribute(t))}}return t.\u0275fac=function(e){return new(e||t)(ta(dl),ta(kf),ta(Ey,8))},t.\u0275cmp=me({type:t,selectors:[["button","mat-button",""],["button","mat-raised-button",""],["button","mat-icon-button",""],["button","mat-fab",""],["button","mat-mini-fab",""],["button","mat-stroked-button",""],["button","mat-flat-button",""]],viewQuery:function(t,e){if(1&t&&Tc(Wy,1),2&t){let t;Cc(t=Mc())&&(e.ripple=t.first)}},hostAttrs:[1,"mat-focus-indicator"],hostVars:5,hostBindings:function(t,e){2&t&&(Jo("disabled",e.disabled||null),ka("_mat-animation-noopable","NoopAnimations"===e._animationMode)("mat-button-disabled",e.disabled))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color"},exportAs:["matButton"],features:[Vo],attrs:T_,ngContentSelectors:A_,decls:4,vars:5,consts:[[1,"mat-button-wrapper"],["matRipple","",1,"mat-button-ripple",3,"matRippleDisabled","matRippleCentered","matRippleTrigger"],[1,"mat-button-focus-overlay"]],template:function(t,e){1&t&&(ba(),ra(0,"span",0),_a(1),ia(),sa(2,"div",1),sa(3,"div",2)),2&t&&(Ts(2),ka("mat-button-ripple-round",e.isRoundButton||e.isIconButton),ea("matRippleDisabled",e._isRippleDisabled())("matRippleCentered",e.isIconButton)("matRippleTrigger",e._getHostElement()))},directives:[Wy],styles:[".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.cdk-high-contrast-active .mat-button-focus-overlay{background-color:#fff}.cdk-high-contrast-black-on-white .mat-button-focus-overlay{background-color:#000}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:block;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}\n"],encapsulation:2,changeDetection:0}),t})(),N_=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},imports:[[jy,Ry],Ry]}),t})();class O_{constructor(t){this.total=t}call(t,e){return e.subscribe(new D_(t,this.total))}}class D_ extends H{constructor(t,e){super(t),this.total=e,this.count=0}_next(t){++this.count>this.total&&this.destination.next(t)}}const L_=new Set;let F_,P_=(()=>{class t{constructor(t){this._platform=t,this._matchMedia=this._platform.isBrowser&&window.matchMedia?window.matchMedia.bind(window):$_}matchMedia(t){return this._platform.WEBKIT&&function(t){if(!L_.has(t))try{F_||(F_=document.createElement("style"),F_.setAttribute("type","text/css"),document.head.appendChild(F_)),F_.sheet&&(F_.sheet.insertRule(`@media ${t} {.fx-query-test{ }}`,0),L_.add(t))}catch(e){console.error(e)}}(t),this._matchMedia(t)}}return t.\u0275fac=function(e){return new(e||t)(zr(jp))},t.\u0275prov=Pt({factory:function(){return new t(zr(jp))},token:t,providedIn:"root"}),t})();function $_(t){return{matches:"all"===t||""===t,media:t,addListener:()=>{},removeListener:()=>{}}}let B_=(()=>{class t{constructor(t,e){this._mediaMatcher=t,this._zone=e,this._queries=new Map,this._destroySubject=new J}ngOnDestroy(){this._destroySubject.next(),this._destroySubject.complete()}isMatched(t){return z_(sf(t)).some(t=>this._registerQuery(t).mql.matches)}observe(t){let e=_v(z_(sf(t)).map(t=>this._registerQuery(t).observable));return e=zf(e.pipe(wd(1)),e.pipe(t=>t.lift(new O_(1)),Jp(0))),e.pipe(et(t=>{const e={matches:!1,breakpoints:{}};return t.forEach(t=>{e.matches=e.matches||t.matches,e.breakpoints[t.query]=t.matches}),e}))}_registerQuery(t){if(this._queries.has(t))return this._queries.get(t);const e=this._mediaMatcher.matchMedia(t),n={observable:new q(t=>{const n=e=>this._zone.run(()=>t.next(e));return e.addListener(n),()=>{e.removeListener(n)}}).pipe(Vf(e),et(e=>({query:t,matches:e.matches})),Dd(this._destroySubject)),mql:e};return this._queries.set(t,n),n}}return t.\u0275fac=function(e){return new(e||t)(zr(P_),zr(eu))},t.\u0275prov=Pt({factory:function(){return new t(zr(P_),zr(eu))},token:t,providedIn:"root"}),t})();function z_(t){return t.map(t=>t.split(",")).reduce((t,e)=>t.concat(e)).map(t=>t.trim())}function V_(t,e){if(1&t){const t=la();ra(0,"div",1),ra(1,"button",2),da("click",function(){return hn(t),ya().action()}),za(2),ia(),ia()}if(2&t){const t=ya();Ts(2),Va(t.data.action)}}function U_(t,e){}const H_=new Er("MatSnackBarData");class W_{constructor(){this.politeness="assertive",this.announcementMessage="",this.duration=0,this.data=null,this.horizontalPosition="center",this.verticalPosition="bottom"}}const j_=Math.pow(2,31)-1;class G_{constructor(t,e){this._overlayRef=e,this._afterDismissed=new J,this._afterOpened=new J,this._onAction=new J,this._dismissedByAction=!1,this.containerInstance=t,this.onAction().subscribe(()=>this.dismiss()),t._onExit.subscribe(()=>this._finishDismiss())}dismiss(){this._afterDismissed.closed||this.containerInstance.exit(),clearTimeout(this._durationTimeoutId)}dismissWithAction(){this._onAction.closed||(this._dismissedByAction=!0,this._onAction.next(),this._onAction.complete())}closeWithAction(){this.dismissWithAction()}_dismissAfter(t){this._durationTimeoutId=setTimeout(()=>this.dismiss(),Math.min(t,j_))}_open(){this._afterOpened.closed||(this._afterOpened.next(),this._afterOpened.complete())}_finishDismiss(){this._overlayRef.dispose(),this._onAction.closed||this._onAction.complete(),this._afterDismissed.next({dismissedByAction:this._dismissedByAction}),this._afterDismissed.complete(),this._dismissedByAction=!1}afterDismissed(){return this._afterDismissed.asObservable()}afterOpened(){return this.containerInstance._onEnter}onAction(){return this._onAction.asObservable()}}let q_=(()=>{class t{constructor(t,e){this.snackBarRef=t,this.data=e}action(){this.snackBarRef.dismissWithAction()}get hasAction(){return!!this.data.action}}return t.\u0275fac=function(e){return new(e||t)(ta(G_),ta(H_))},t.\u0275cmp=me({type:t,selectors:[["simple-snack-bar"]],hostAttrs:[1,"mat-simple-snackbar"],decls:3,vars:2,consts:[["class","mat-simple-snackbar-action",4,"ngIf"],[1,"mat-simple-snackbar-action"],["mat-button","",3,"click"]],template:function(t,e){1&t&&(ra(0,"span"),za(1),ia(),Qo(2,V_,3,1,"div",0)),2&t&&(Ts(1),Va(e.data.message),Ts(1),ea("ngIf",e.hasAction))},directives:[Ju,I_],styles:[".mat-simple-snackbar{display:flex;justify-content:space-between;align-items:center;line-height:20px;opacity:1}.mat-simple-snackbar-action{flex-shrink:0;margin:-8px -8px -8px 8px}.mat-simple-snackbar-action button{max-height:36px;min-width:0}[dir=rtl] .mat-simple-snackbar-action{margin-left:-8px;margin-right:8px}\n"],encapsulation:2,changeDetection:0}),t})();const X_={snackBarState:Wf("state",[Xf("void, hidden",qf({transform:"scale(0.8)",opacity:0})),Xf("visible",qf({transform:"scale(1)",opacity:1})),Yf("* => visible",jf("150ms cubic-bezier(0, 0, 0.2, 1)")),Yf("* => void, * => hidden",jf("75ms cubic-bezier(0.4, 0.0, 1, 1)",qf({opacity:0})))])};let K_=(()=>{class t extends kb{constructor(t,e,n,r){super(),this._ngZone=t,this._elementRef=e,this._changeDetectorRef=n,this.snackBarConfig=r,this._destroyed=!1,this._onExit=new J,this._onEnter=new J,this._animationState="void",this.attachDomPortal=t=>(this._assertNotAttached(),this._applySnackBarClasses(),this._portalOutlet.attachDomPortal(t)),this._role="assertive"!==r.politeness||r.announcementMessage?"off"===r.politeness?null:"status":"alert"}attachComponentPortal(t){return this._assertNotAttached(),this._applySnackBarClasses(),this._portalOutlet.attachComponentPortal(t)}attachTemplatePortal(t){return this._assertNotAttached(),this._applySnackBarClasses(),this._portalOutlet.attachTemplatePortal(t)}onAnimationEnd(t){const{fromState:e,toState:n}=t;if(("void"===n&&"void"!==e||"hidden"===n)&&this._completeExit(),"visible"===n){const t=this._onEnter;this._ngZone.run(()=>{t.next(),t.complete()})}}enter(){this._destroyed||(this._animationState="visible",this._changeDetectorRef.detectChanges())}exit(){return this._animationState="hidden",this._elementRef.nativeElement.setAttribute("mat-exit",""),this._onExit}ngOnDestroy(){this._destroyed=!0,this._completeExit()}_completeExit(){this._ngZone.onMicrotaskEmpty.asObservable().pipe(wd(1)).subscribe(()=>{this._onExit.next(),this._onExit.complete()})}_applySnackBarClasses(){const t=this._elementRef.nativeElement,e=this.snackBarConfig.panelClass;e&&(Array.isArray(e)?e.forEach(e=>t.classList.add(e)):t.classList.add(e)),"center"===this.snackBarConfig.horizontalPosition&&t.classList.add("mat-snack-bar-center"),"top"===this.snackBarConfig.verticalPosition&&t.classList.add("mat-snack-bar-top")}_assertNotAttached(){if(this._portalOutlet.hasAttached())throw Error("Attempting to attach snack bar content after content is already attached")}}return t.\u0275fac=function(e){return new(e||t)(ta(eu),ta(dl),ta($l),ta(W_))},t.\u0275cmp=me({type:t,selectors:[["snack-bar-container"]],viewQuery:function(t,e){if(1&t&&Tc(Ib,3),2&t){let t;Cc(t=Mc())&&(e._portalOutlet=t.first)}},hostAttrs:[1,"mat-snack-bar-container"],hostVars:2,hostBindings:function(t,e){1&t&&pa("@state.done",function(t){return e.onAnimationEnd(t)}),2&t&&(Jo("role",e._role),Ha("@state",e._animationState))},features:[Vo],decls:1,vars:0,consts:[["cdkPortalOutlet",""]],template:function(t,e){1&t&&Qo(0,U_,0,0,"ng-template",0)},directives:[Ib],styles:[".mat-snack-bar-container{border-radius:4px;box-sizing:border-box;display:block;margin:24px;max-width:33vw;min-width:344px;padding:14px 16px;min-height:48px;transform-origin:center}.cdk-high-contrast-active .mat-snack-bar-container{border:solid 1px}.mat-snack-bar-handset{width:100%}.mat-snack-bar-handset .mat-snack-bar-container{margin:8px;max-width:100%;min-width:0;width:100%}\n"],encapsulation:2,data:{animation:[X_.snackBarState]}}),t})(),Y_=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},imports:[[h_,Nb,ch,N_,Ry],Ry]}),t})();const Z_=new Er("mat-snack-bar-default-options",{providedIn:"root",factory:function(){return new W_}});let J_=(()=>{class t{constructor(t,e,n,r,i,s){this._overlay=t,this._live=e,this._injector=n,this._breakpointObserver=r,this._parentSnackBar=i,this._defaultConfig=s,this._snackBarRefAtThisLevel=null,this.simpleSnackBarComponent=q_,this.snackBarContainerComponent=K_,this.handsetCssClass="mat-snack-bar-handset"}get _openedSnackBarRef(){const t=this._parentSnackBar;return t?t._openedSnackBarRef:this._snackBarRefAtThisLevel}set _openedSnackBarRef(t){this._parentSnackBar?this._parentSnackBar._openedSnackBarRef=t:this._snackBarRefAtThisLevel=t}openFromComponent(t,e){return this._attach(t,e)}openFromTemplate(t,e){return this._attach(t,e)}open(t,e="",n){const r=Object.assign(Object.assign({},this._defaultConfig),n);return r.data={message:t,action:e},r.announcementMessage===t&&(r.announcementMessage=void 0),this.openFromComponent(this.simpleSnackBarComponent,r)}dismiss(){this._openedSnackBarRef&&this._openedSnackBarRef.dismiss()}ngOnDestroy(){this._snackBarRefAtThisLevel&&this._snackBarRefAtThisLevel.dismiss()}_attachSnackBarContainer(t,e){const n=new Ob(e&&e.viewContainerRef&&e.viewContainerRef.injector||this._injector,new WeakMap([[W_,e]])),r=new Tb(this.snackBarContainerComponent,e.viewContainerRef,n),i=t.attach(r);return i.instance.snackBarConfig=e,i.instance}_attach(t,e){const n=Object.assign(Object.assign(Object.assign({},new W_),this._defaultConfig),e),r=this._createOverlay(n),i=this._attachSnackBarContainer(r,n),s=new G_(i,r);if(t instanceof Wl){const e=new Ab(t,null,{$implicit:n.data,snackBarRef:s});s.instance=i.attachTemplatePortal(e)}else{const e=this._createInjector(n,s),r=new Tb(t,void 0,e),o=i.attachComponentPortal(r);s.instance=o.instance}return this._breakpointObserver.observe("(max-width: 599.99px) and (orientation: portrait)").pipe(Dd(r.detachments())).subscribe(t=>{const e=r.overlayElement.classList;t.matches?e.add(this.handsetCssClass):e.remove(this.handsetCssClass)}),this._animateSnackBar(s,n),this._openedSnackBarRef=s,this._openedSnackBarRef}_animateSnackBar(t,e){t.afterDismissed().subscribe(()=>{this._openedSnackBarRef==t&&(this._openedSnackBarRef=null),e.announcementMessage&&this._live.clear()}),this._openedSnackBarRef?(this._openedSnackBarRef.afterDismissed().subscribe(()=>{t.containerInstance.enter()}),this._openedSnackBarRef.dismiss()):t.containerInstance.enter(),e.duration&&e.duration>0&&t.afterOpened().subscribe(()=>t._dismissAfter(e.duration)),e.announcementMessage&&this._live.announce(e.announcementMessage,e.politeness)}_createOverlay(t){const e=new Ub;e.direction=t.direction;let n=this._overlay.position().global();const r="rtl"===t.direction,i="left"===t.horizontalPosition||"start"===t.horizontalPosition&&!r||"end"===t.horizontalPosition&&r,s=!i&&"center"!==t.horizontalPosition;return i?n.left("0"):s?n.right("0"):n.centerHorizontally(),"top"===t.verticalPosition?n.top("0"):n.bottom("0"),e.positionStrategy=n,this._overlay.create(e)}_createInjector(t,e){return new Ob(t&&t.viewContainerRef&&t.viewContainerRef.injector||this._injector,new WeakMap([[G_,e],[H_,t.data]]))}}return t.\u0275fac=function(e){return new(e||t)(zr(c_),zr(Cf),zr(Bo),zr(B_),zr(t,12),zr(Z_))},t.\u0275prov=Pt({factory:function(){return new t(zr(c_),zr(Cf),zr(So),zr(B_),zr(t,12),zr(Z_))},token:t,providedIn:Y_}),t})();const Q_=["*",[["mat-toolbar-row"]]],tx=["*","mat-toolbar-row"];class ex{constructor(t){this._elementRef=t}}const nx=Ny(ex);let rx=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=xe({type:t,selectors:[["mat-toolbar-row"]],hostAttrs:[1,"mat-toolbar-row"],exportAs:["matToolbarRow"]}),t})(),ix=(()=>{class t extends nx{constructor(t,e,n){super(t),this._platform=e,this._document=n}ngAfterViewInit(){mu()&&this._platform.isBrowser&&(this._checkToolbarMixedModes(),this._toolbarRows.changes.subscribe(()=>this._checkToolbarMixedModes()))}_checkToolbarMixedModes(){this._toolbarRows.length&&Array.from(this._elementRef.nativeElement.childNodes).filter(t=>!(t.classList&&t.classList.contains("mat-toolbar-row"))).filter(t=>t.nodeType!==(this._document?this._document.COMMENT_NODE:8)).some(t=>!(!t.textContent||!t.textContent.trim()))&&function(){throw Error("MatToolbar: Attempting to combine different toolbar modes. Either specify multiple `<mat-toolbar-row>` elements explicitly or just place content inside of a `<mat-toolbar>` for a single row.")}()}}return t.\u0275fac=function(e){return new(e||t)(ta(dl),ta(jp),ta(Mu))},t.\u0275cmp=me({type:t,selectors:[["mat-toolbar"]],contentQueries:function(t,e,n){if(1&t&&Ac(n,rx,1),2&t){let t;Cc(t=Mc())&&(e._toolbarRows=t)}},hostAttrs:[1,"mat-toolbar"],hostVars:4,hostBindings:function(t,e){2&t&&ka("mat-toolbar-multiple-rows",e._toolbarRows.length>0)("mat-toolbar-single-row",0===e._toolbarRows.length)},inputs:{color:"color"},exportAs:["matToolbar"],features:[Vo],ngContentSelectors:tx,decls:2,vars:0,template:function(t,e){1&t&&(ba(Q_),_a(0),_a(1,1))},styles:[".cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}\n"],encapsulation:2,changeDetection:0}),t})(),sx=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},imports:[[Ry],Ry]}),t})();class ox{constructor(t){this.callback=t}call(t,e){return e.subscribe(new ax(t,this.callback))}}class ax extends H{constructor(t,e){super(t),this.add(new z(e))}}class lx{}class cx{}class ux{constructor(t){this.normalizedNames=new Map,this.lazyUpdate=null,t?this.lazyInit="string"==typeof t?()=>{this.headers=new Map,t.split("\n").forEach(t=>{const e=t.indexOf(":");if(e>0){const n=t.slice(0,e),r=n.toLowerCase(),i=t.slice(e+1).trim();this.maybeSetNormalizedName(n,r),this.headers.has(r)?this.headers.get(r).push(i):this.headers.set(r,[i])}})}:()=>{this.headers=new Map,Object.keys(t).forEach(e=>{let n=t[e];const r=e.toLowerCase();"string"==typeof n&&(n=[n]),n.length>0&&(this.headers.set(r,n),this.maybeSetNormalizedName(e,r))})}:this.headers=new Map}has(t){return this.init(),this.headers.has(t.toLowerCase())}get(t){this.init();const e=this.headers.get(t.toLowerCase());return e&&e.length>0?e[0]:null}keys(){return this.init(),Array.from(this.normalizedNames.values())}getAll(t){return this.init(),this.headers.get(t.toLowerCase())||null}append(t,e){return this.clone({name:t,value:e,op:"a"})}set(t,e){return this.clone({name:t,value:e,op:"s"})}delete(t,e){return this.clone({name:t,value:e,op:"d"})}maybeSetNormalizedName(t,e){this.normalizedNames.has(e)||this.normalizedNames.set(e,t)}init(){this.lazyInit&&(this.lazyInit instanceof ux?this.copyFrom(this.lazyInit):this.lazyInit(),this.lazyInit=null,this.lazyUpdate&&(this.lazyUpdate.forEach(t=>this.applyUpdate(t)),this.lazyUpdate=null))}copyFrom(t){t.init(),Array.from(t.headers.keys()).forEach(e=>{this.headers.set(e,t.headers.get(e)),this.normalizedNames.set(e,t.normalizedNames.get(e))})}clone(t){const e=new ux;return e.lazyInit=this.lazyInit&&this.lazyInit instanceof ux?this.lazyInit:this,e.lazyUpdate=(this.lazyUpdate||[]).concat([t]),e}applyUpdate(t){const e=t.name.toLowerCase();switch(t.op){case"a":case"s":let n=t.value;if("string"==typeof n&&(n=[n]),0===n.length)return;this.maybeSetNormalizedName(t.name,e);const r=("a"===t.op?this.headers.get(e):void 0)||[];r.push(...n),this.headers.set(e,r);break;case"d":const i=t.value;if(i){let t=this.headers.get(e);if(!t)return;t=t.filter(t=>-1===i.indexOf(t)),0===t.length?(this.headers.delete(e),this.normalizedNames.delete(e)):this.headers.set(e,t)}else this.headers.delete(e),this.normalizedNames.delete(e)}}forEach(t){this.init(),Array.from(this.normalizedNames.keys()).forEach(e=>t(this.normalizedNames.get(e),this.headers.get(e)))}}class hx{encodeKey(t){return dx(t)}encodeValue(t){return dx(t)}decodeKey(t){return decodeURIComponent(t)}decodeValue(t){return decodeURIComponent(t)}}function dx(t){return encodeURIComponent(t).replace(/%40/gi,"@").replace(/%3A/gi,":").replace(/%24/gi,"$").replace(/%2C/gi,",").replace(/%3B/gi,";").replace(/%2B/gi,"+").replace(/%3D/gi,"=").replace(/%3F/gi,"?").replace(/%2F/gi,"/")}class px{constructor(t={}){if(this.updates=null,this.cloneFrom=null,this.encoder=t.encoder||new hx,t.fromString){if(t.fromObject)throw new Error("Cannot specify both fromString and fromObject.");this.map=function(t,e){const n=new Map;return t.length>0&&t.split("&").forEach(t=>{const r=t.indexOf("="),[i,s]=-1==r?[e.decodeKey(t),""]:[e.decodeKey(t.slice(0,r)),e.decodeValue(t.slice(r+1))],o=n.get(i)||[];o.push(s),n.set(i,o)}),n}(t.fromString,this.encoder)}else t.fromObject?(this.map=new Map,Object.keys(t.fromObject).forEach(e=>{const n=t.fromObject[e];this.map.set(e,Array.isArray(n)?n:[n])})):this.map=null}has(t){return this.init(),this.map.has(t)}get(t){this.init();const e=this.map.get(t);return e?e[0]:null}getAll(t){return this.init(),this.map.get(t)||null}keys(){return this.init(),Array.from(this.map.keys())}append(t,e){return this.clone({param:t,value:e,op:"a"})}appendAll(t){const e=[];return Object.keys(t).forEach(n=>{const r=t[n];Array.isArray(r)?r.forEach(t=>{e.push({param:n,value:t,op:"a"})}):e.push({param:n,value:r,op:"a"})}),this.clone(e)}set(t,e){return this.clone({param:t,value:e,op:"s"})}delete(t,e){return this.clone({param:t,value:e,op:"d"})}toString(){return this.init(),this.keys().map(t=>{const e=this.encoder.encodeKey(t);return this.map.get(t).map(t=>e+"="+this.encoder.encodeValue(t)).join("&")}).filter(t=>""!==t).join("&")}clone(t){const e=new px({encoder:this.encoder});return e.cloneFrom=this.cloneFrom||this,e.updates=(this.updates||[]).concat(t),e}init(){null===this.map&&(this.map=new Map),null!==this.cloneFrom&&(this.cloneFrom.init(),this.cloneFrom.keys().forEach(t=>this.map.set(t,this.cloneFrom.map.get(t))),this.updates.forEach(t=>{switch(t.op){case"a":case"s":const e=("a"===t.op?this.map.get(t.param):void 0)||[];e.push(t.value),this.map.set(t.param,e);break;case"d":if(void 0===t.value){this.map.delete(t.param);break}{let e=this.map.get(t.param)||[];const n=e.indexOf(t.value);-1!==n&&e.splice(n,1),e.length>0?this.map.set(t.param,e):this.map.delete(t.param)}}}),this.cloneFrom=this.updates=null)}}function fx(t){return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer}function mx(t){return"undefined"!=typeof Blob&&t instanceof Blob}function gx(t){return"undefined"!=typeof FormData&&t instanceof FormData}class yx{constructor(t,e,n,r){let i;if(this.url=e,this.body=null,this.reportProgress=!1,this.withCredentials=!1,this.responseType="json",this.method=t.toUpperCase(),function(t){switch(t){case"DELETE":case"GET":case"HEAD":case"OPTIONS":case"JSONP":return!1;default:return!0}}(this.method)||r?(this.body=void 0!==n?n:null,i=r):i=n,i&&(this.reportProgress=!!i.reportProgress,this.withCredentials=!!i.withCredentials,i.responseType&&(this.responseType=i.responseType),i.headers&&(this.headers=i.headers),i.params&&(this.params=i.params)),this.headers||(this.headers=new ux),this.params){const t=this.params.toString();if(0===t.length)this.urlWithParams=e;else{const n=e.indexOf("?");this.urlWithParams=e+(-1===n?"?":n<e.length-1?"&":"")+t}}else this.params=new px,this.urlWithParams=e}serializeBody(){return null===this.body?null:fx(this.body)||mx(this.body)||gx(this.body)||"string"==typeof this.body?this.body:this.body instanceof px?this.body.toString():"object"==typeof this.body||"boolean"==typeof this.body||Array.isArray(this.body)?JSON.stringify(this.body):this.body.toString()}detectContentTypeHeader(){return null===this.body||gx(this.body)?null:mx(this.body)?this.body.type||null:fx(this.body)?null:"string"==typeof this.body?"text/plain":this.body instanceof px?"application/x-www-form-urlencoded;charset=UTF-8":"object"==typeof this.body||"number"==typeof this.body||Array.isArray(this.body)?"application/json":null}clone(t={}){const e=t.method||this.method,n=t.url||this.url,r=t.responseType||this.responseType,i=void 0!==t.body?t.body:this.body,s=void 0!==t.withCredentials?t.withCredentials:this.withCredentials,o=void 0!==t.reportProgress?t.reportProgress:this.reportProgress;let a=t.headers||this.headers,l=t.params||this.params;return void 0!==t.setHeaders&&(a=Object.keys(t.setHeaders).reduce((e,n)=>e.set(n,t.setHeaders[n]),a)),t.setParams&&(l=Object.keys(t.setParams).reduce((e,n)=>e.set(n,t.setParams[n]),l)),new yx(e,n,i,{params:l,headers:a,reportProgress:o,responseType:r,withCredentials:s})}}var vx=function(t){return t[t.Sent=0]="Sent",t[t.UploadProgress=1]="UploadProgress",t[t.ResponseHeader=2]="ResponseHeader",t[t.DownloadProgress=3]="DownloadProgress",t[t.Response=4]="Response",t[t.User=5]="User",t}({});class bx{constructor(t,e=200,n="OK"){this.headers=t.headers||new ux,this.status=void 0!==t.status?t.status:e,this.statusText=t.statusText||n,this.url=t.url||null,this.ok=this.status>=200&&this.status<300}}class _x extends bx{constructor(t={}){super(t),this.type=vx.ResponseHeader}clone(t={}){return new _x({headers:t.headers||this.headers,status:void 0!==t.status?t.status:this.status,statusText:t.statusText||this.statusText,url:t.url||this.url||void 0})}}class xx extends bx{constructor(t={}){super(t),this.type=vx.Response,this.body=void 0!==t.body?t.body:null}clone(t={}){return new xx({body:void 0!==t.body?t.body:this.body,headers:t.headers||this.headers,status:void 0!==t.status?t.status:this.status,statusText:t.statusText||this.statusText,url:t.url||this.url||void 0})}}class wx extends bx{constructor(t){super(t,0,"Unknown Error"),this.name="HttpErrorResponse",this.ok=!1,this.message=this.status>=200&&this.status<300?`Http failure during parsing for ${t.url||"(unknown url)"}`:`Http failure response for ${t.url||"(unknown url)"}: ${t.status} ${t.statusText}`,this.error=t.error||null}}function Sx(t,e){return{body:e,headers:t.headers,observe:t.observe,params:t.params,reportProgress:t.reportProgress,responseType:t.responseType,withCredentials:t.withCredentials}}let Ex=(()=>{class t{constructor(t){this.handler=t}request(t,e,n={}){let r;if(t instanceof yx)r=t;else{let i,s;i=n.headers instanceof ux?n.headers:new ux(n.headers),n.params&&(s=n.params instanceof px?n.params:new px({fromObject:n.params})),r=new yx(t,e,void 0!==n.body?n.body:null,{headers:i,params:s,reportProgress:n.reportProgress,responseType:n.responseType||"json",withCredentials:n.withCredentials})}const i=Zh(r).pipe(mt(t=>this.handler.handle(t),void 0,1));if(t instanceof yx||"events"===n.observe)return i;const s=i.pipe(yd(t=>t instanceof xx));switch(n.observe||"body"){case"body":switch(r.responseType){case"arraybuffer":return s.pipe(et(t=>{if(null!==t.body&&!(t.body instanceof ArrayBuffer))throw new Error("Response is not an ArrayBuffer.");return t.body}));case"blob":return s.pipe(et(t=>{if(null!==t.body&&!(t.body instanceof Blob))throw new Error("Response is not a Blob.");return t.body}));case"text":return s.pipe(et(t=>{if(null!==t.body&&"string"!=typeof t.body)throw new Error("Response is not a string.");return t.body}));case"json":default:return s.pipe(et(t=>t.body))}case"response":return s;default:throw new Error(`Unreachable: unhandled observe type ${n.observe}}`)}}delete(t,e={}){return this.request("DELETE",t,e)}get(t,e={}){return this.request("GET",t,e)}head(t,e={}){return this.request("HEAD",t,e)}jsonp(t,e){return this.request("JSONP",t,{params:(new px).append(e,"JSONP_CALLBACK"),observe:"body",responseType:"json"})}options(t,e={}){return this.request("OPTIONS",t,e)}patch(t,e,n={}){return this.request("PATCH",t,Sx(n,e))}post(t,e,n={}){return this.request("POST",t,Sx(n,e))}put(t,e,n={}){return this.request("PUT",t,Sx(n,e))}}return t.\u0275fac=function(e){return new(e||t)(zr(lx))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();class Cx{constructor(t,e){this.next=t,this.interceptor=e}handle(t){return this.interceptor.intercept(t,this.next)}}const Tx=new Er("HTTP_INTERCEPTORS");let Ax=(()=>{class t{intercept(t,e){return e.handle(t)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();const Mx=/^\)\]\}',?\n/;class kx{}let Rx=(()=>{class t{constructor(){}build(){return new XMLHttpRequest}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})(),Ix=(()=>{class t{constructor(t){this.xhrFactory=t}handle(t){if("JSONP"===t.method)throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed.");return new q(e=>{const n=this.xhrFactory.build();if(n.open(t.method,t.urlWithParams),t.withCredentials&&(n.withCredentials=!0),t.headers.forEach((t,e)=>n.setRequestHeader(t,e.join(","))),t.headers.has("Accept")||n.setRequestHeader("Accept","application/json, text/plain, */*"),!t.headers.has("Content-Type")){const e=t.detectContentTypeHeader();null!==e&&n.setRequestHeader("Content-Type",e)}if(t.responseType){const e=t.responseType.toLowerCase();n.responseType="json"!==e?e:"text"}const r=t.serializeBody();let i=null;const s=()=>{if(null!==i)return i;const e=1223===n.status?204:n.status,r=n.statusText||"OK",s=new ux(n.getAllResponseHeaders()),o=function(t){return"responseURL"in t&&t.responseURL?t.responseURL:/^X-Request-URL:/m.test(t.getAllResponseHeaders())?t.getResponseHeader("X-Request-URL"):null}(n)||t.url;return i=new _x({headers:s,status:e,statusText:r,url:o}),i},o=()=>{let{headers:r,status:i,statusText:o,url:a}=s(),l=null;204!==i&&(l=void 0===n.response?n.responseText:n.response),0===i&&(i=l?200:0);let c=i>=200&&i<300;if("json"===t.responseType&&"string"==typeof l){const t=l;l=l.replace(Mx,"");try{l=""!==l?JSON.parse(l):null}catch(u){l=t,c&&(c=!1,l={error:u,text:l})}}c?(e.next(new xx({body:l,headers:r,status:i,statusText:o,url:a||void 0})),e.complete()):e.error(new wx({error:l,headers:r,status:i,statusText:o,url:a||void 0}))},a=t=>{const{url:r}=s(),i=new wx({error:t,status:n.status||0,statusText:n.statusText||"Unknown Error",url:r||void 0});e.error(i)};let l=!1;const c=r=>{l||(e.next(s()),l=!0);let i={type:vx.DownloadProgress,loaded:r.loaded};r.lengthComputable&&(i.total=r.total),"text"===t.responseType&&n.responseText&&(i.partialText=n.responseText),e.next(i)},u=t=>{let n={type:vx.UploadProgress,loaded:t.loaded};t.lengthComputable&&(n.total=t.total),e.next(n)};return n.addEventListener("load",o),n.addEventListener("error",a),n.addEventListener("timeout",a),t.reportProgress&&(n.addEventListener("progress",c),null!==r&&n.upload&&n.upload.addEventListener("progress",u)),n.send(r),e.next({type:vx.Sent}),()=>{n.removeEventListener("error",a),n.removeEventListener("load",o),n.removeEventListener("timeout",a),t.reportProgress&&(n.removeEventListener("progress",c),null!==r&&n.upload&&n.upload.removeEventListener("progress",u)),n.readyState!==n.DONE&&n.abort()}})}}return t.\u0275fac=function(e){return new(e||t)(zr(kx))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})();const Nx=new Er("XSRF_COOKIE_NAME"),Ox=new Er("XSRF_HEADER_NAME");class Dx{}let Lx=(()=>{class t{constructor(t,e,n){this.doc=t,this.platform=e,this.cookieName=n,this.lastCookieString="",this.lastToken=null,this.parseCount=0}getToken(){if("server"===this.platform)return null;const t=this.doc.cookie||"";return t!==this.lastCookieString&&(this.parseCount++,this.lastToken=qu(t,this.cookieName),this.lastCookieString=t),this.lastToken}}return t.\u0275fac=function(e){return new(e||t)(zr(Mu),zr(Bc),zr(Nx))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})(),Fx=(()=>{class t{constructor(t,e){this.tokenService=t,this.headerName=e}intercept(t,e){const n=t.url.toLowerCase();if("GET"===t.method||"HEAD"===t.method||n.startsWith("http://")||n.startsWith("https://"))return e.handle(t);const r=this.tokenService.getToken();return null===r||t.headers.has(this.headerName)||(t=t.clone({headers:t.headers.set(this.headerName,r)})),e.handle(t)}}return t.\u0275fac=function(e){return new(e||t)(zr(Dx),zr(Ox))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})(),Px=(()=>{class t{constructor(t,e){this.backend=t,this.injector=e,this.chain=null}handle(t){if(null===this.chain){const t=this.injector.get(Tx,[]);this.chain=t.reduceRight((t,e)=>new Cx(t,e),this.backend)}return this.chain.handle(t)}}return t.\u0275fac=function(e){return new(e||t)(zr(cx),zr(Bo))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})(),$x=(()=>{class t{static disable(){return{ngModule:t,providers:[{provide:Fx,useClass:Ax}]}}static withOptions(e={}){return{ngModule:t,providers:[e.cookieName?{provide:Nx,useValue:e.cookieName}:[],e.headerName?{provide:Ox,useValue:e.headerName}:[]]}}}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},providers:[Fx,{provide:Tx,useExisting:Fx,multi:!0},{provide:Dx,useClass:Lx},{provide:Nx,useValue:"XSRF-TOKEN"},{provide:Ox,useValue:"X-XSRF-TOKEN"}]}),t})(),Bx=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},providers:[Ex,{provide:lx,useClass:Px},Ix,{provide:cx,useExisting:Ix},Rx,{provide:kx,useExisting:Rx}],imports:[[$x.withOptions({cookieName:"XSRF-TOKEN",headerName:"X-XSRF-TOKEN"})]]}),t})();const zx=["*"];function Vx(t){return Error(`Unable to find icon with the name "${t}"`)}function Ux(t){return Error(`The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${t}".`)}function Hx(t){return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${t}".`)}class Wx{constructor(t,e){this.options=e,t.nodeName?this.svgElement=t:this.url=t}}let jx=(()=>{class t{constructor(t,e,n,r){this._httpClient=t,this._sanitizer=e,this._errorHandler=r,this._svgIconConfigs=new Map,this._iconSetConfigs=new Map,this._cachedIconsByUrl=new Map,this._inProgressUrlFetches=new Map,this._fontCssClassesByAlias=new Map,this._defaultFontSetClass="material-icons",this._document=n}addSvgIcon(t,e,n){return this.addSvgIconInNamespace("",t,e,n)}addSvgIconLiteral(t,e,n){return this.addSvgIconLiteralInNamespace("",t,e,n)}addSvgIconInNamespace(t,e,n,r){return this._addSvgIconConfig(t,e,new Wx(n,r))}addSvgIconLiteralInNamespace(t,e,n,r){const i=this._sanitizer.sanitize(ki.HTML,n);if(!i)throw Hx(n);const s=this._createSvgElementForSingleIcon(i,r);return this._addSvgIconConfig(t,e,new Wx(s,r))}addSvgIconSet(t,e){return this.addSvgIconSetInNamespace("",t,e)}addSvgIconSetLiteral(t,e){return this.addSvgIconSetLiteralInNamespace("",t,e)}addSvgIconSetInNamespace(t,e,n){return this._addSvgIconSetConfig(t,new Wx(e,n))}addSvgIconSetLiteralInNamespace(t,e,n){const r=this._sanitizer.sanitize(ki.HTML,e);if(!r)throw Hx(e);const i=this._svgElementFromString(r);return this._addSvgIconSetConfig(t,new Wx(i,n))}registerFontClassAlias(t,e=t){return this._fontCssClassesByAlias.set(t,e),this}classNameForFontAlias(t){return this._fontCssClassesByAlias.get(t)||t}setDefaultFontSetClass(t){return this._defaultFontSetClass=t,this}getDefaultFontSetClass(){return this._defaultFontSetClass}getSvgIconFromUrl(t){const e=this._sanitizer.sanitize(ki.RESOURCE_URL,t);if(!e)throw Ux(t);const n=this._cachedIconsByUrl.get(e);return n?Zh(Gx(n)):this._loadSvgIconFromConfig(new Wx(t)).pipe($d(t=>this._cachedIconsByUrl.set(e,t)),et(t=>Gx(t)))}getNamedSvgIcon(t,e=""){const n=qx(e,t),r=this._svgIconConfigs.get(n);if(r)return this._getSvgFromConfig(r);const i=this._iconSetConfigs.get(e);return i?this._getSvgFromIconSetConfigs(t,i):Jh(Vx(n))}ngOnDestroy(){this._svgIconConfigs.clear(),this._iconSetConfigs.clear(),this._cachedIconsByUrl.clear()}_getSvgFromConfig(t){return t.svgElement?Zh(Gx(t.svgElement)):this._loadSvgIconFromConfig(t).pipe($d(e=>t.svgElement=e),et(t=>Gx(t)))}_getSvgFromIconSetConfigs(t,e){const n=this._extractIconWithNameFromAnySet(t,e);return n?Zh(n):md(e.filter(t=>!t.svgElement).map(t=>this._loadSvgIconSetFromConfig(t).pipe(Id(e=>{const n=this._sanitizer.sanitize(ki.RESOURCE_URL,t.url);return this._errorHandler.handleError(new Error(`Loading icon set URL: ${n} failed: ${e.message}`)),Zh(null)})))).pipe(et(()=>{const n=this._extractIconWithNameFromAnySet(t,e);if(!n)throw Vx(t);return n}))}_extractIconWithNameFromAnySet(t,e){for(let n=e.length-1;n>=0;n--){const r=e[n];if(r.svgElement){const e=this._extractSvgIconFromSet(r.svgElement,t,r.options);if(e)return e}}return null}_loadSvgIconFromConfig(t){return this._fetchIcon(t).pipe(et(e=>this._createSvgElementForSingleIcon(e,t.options)))}_loadSvgIconSetFromConfig(t){return t.svgElement?Zh(t.svgElement):this._fetchIcon(t).pipe(et(e=>(t.svgElement||(t.svgElement=this._svgElementFromString(e)),t.svgElement)))}_createSvgElementForSingleIcon(t,e){const n=this._svgElementFromString(t);return this._setSvgAttributes(n,e),n}_extractSvgIconFromSet(t,e,n){const r=t.querySelector(`[id="${e}"]`);if(!r)return null;const i=r.cloneNode(!0);if(i.removeAttribute("id"),"svg"===i.nodeName.toLowerCase())return this._setSvgAttributes(i,n);if("symbol"===i.nodeName.toLowerCase())return this._setSvgAttributes(this._toSvgElement(i),n);const s=this._svgElementFromString("<svg></svg>");return s.appendChild(i),this._setSvgAttributes(s,n)}_svgElementFromString(t){const e=this._document.createElement("DIV");e.innerHTML=t;const n=e.querySelector("svg");if(!n)throw Error("<svg> tag not found");return n}_toSvgElement(t){const e=this._svgElementFromString("<svg></svg>"),n=t.attributes;for(let r=0;r<n.length;r++){const{name:t,value:i}=n[r];"id"!==t&&e.setAttribute(t,i)}for(let r=0;r<t.childNodes.length;r++)t.childNodes[r].nodeType===this._document.ELEMENT_NODE&&e.appendChild(t.childNodes[r].cloneNode(!0));return e}_setSvgAttributes(t,e){return t.setAttribute("fit",""),t.setAttribute("height","100%"),t.setAttribute("width","100%"),t.setAttribute("preserveAspectRatio","xMidYMid meet"),t.setAttribute("focusable","false"),e&&e.viewBox&&t.setAttribute("viewBox",e.viewBox),t}_fetchIcon(t){var e;const{url:n,options:r}=t,i=null!==(e=null==r?void 0:r.withCredentials)&&void 0!==e&&e;if(!this._httpClient)throw Error("Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports.");if(null==n)throw Error(`Cannot fetch icon from URL "${n}".`);const s=this._sanitizer.sanitize(ki.RESOURCE_URL,n);if(!s)throw Ux(n);const o=this._inProgressUrlFetches.get(s);if(o)return o;const a=this._httpClient.get(s,{responseType:"text",withCredentials:i}).pipe((l=()=>this._inProgressUrlFetches.delete(s),t=>t.lift(new ox(l))),Mt());var l;return this._inProgressUrlFetches.set(s,a),a}_addSvgIconConfig(t,e,n){return this._svgIconConfigs.set(qx(t,e),n),this}_addSvgIconSetConfig(t,e){const n=this._iconSetConfigs.get(t);return n?n.push(e):this._iconSetConfigs.set(t,[e]),this}}return t.\u0275fac=function(e){return new(e||t)(zr(Ex,8),zr(Lh),zr(Mu,8),zr(Di))},t.\u0275prov=Pt({factory:function(){return new t(zr(Ex,8),zr(Lh),zr(Mu,8),zr(Di))},token:t,providedIn:"root"}),t})();function Gx(t){return t.cloneNode(!0)}function qx(t,e){return t+":"+e}class Xx{constructor(t){this._elementRef=t}}const Kx=Ny(Xx),Yx=new Er("mat-icon-location",{providedIn:"root",factory:function(){const t=Vr(Mu),e=t?t.location:null;return{getPathname:()=>e?e.pathname+e.search:""}}}),Zx=["clip-path","color-profile","src","cursor","fill","filter","marker","marker-start","marker-mid","marker-end","mask","stroke"],Jx=Zx.map(t=>`[${t}]`).join(", "),Qx=/^url\(['"]?#(.*?)['"]?\)$/;let tw=(()=>{class t extends Kx{constructor(t,e,n,r,i){super(t),this._iconRegistry=e,this._location=r,this._errorHandler=i,this._inline=!1,this._currentIconFetch=z.EMPTY,n||t.nativeElement.setAttribute("aria-hidden","true")}get inline(){return this._inline}set inline(t){this._inline=nf(t)}get fontSet(){return this._fontSet}set fontSet(t){this._fontSet=this._cleanupFontValue(t)}get fontIcon(){return this._fontIcon}set fontIcon(t){this._fontIcon=this._cleanupFontValue(t)}_splitIconName(t){if(!t)return["",""];const e=t.split(":");switch(e.length){case 1:return["",e[0]];case 2:return e;default:throw Error(`Invalid icon name: "${t}"`)}}ngOnChanges(t){const e=t.svgIcon;if(e)if(this._currentIconFetch.unsubscribe(),this.svgIcon){const[t,e]=this._splitIconName(this.svgIcon);this._currentIconFetch=this._iconRegistry.getNamedSvgIcon(e,t).pipe(wd(1)).subscribe(t=>this._setSvgElement(t),n=>{this._errorHandler.handleError(new Error(`Error retrieving icon ${t}:${e}! ${n.message}`))})}else e.previousValue&&this._clearSvgElement();this._usingFontIcon()&&this._updateFontIconClasses()}ngOnInit(){this._usingFontIcon()&&this._updateFontIconClasses()}ngAfterViewChecked(){const t=this._elementsWithExternalReferences;if(t&&t.size){const t=this._location.getPathname();t!==this._previousPath&&(this._previousPath=t,this._prependPathToReferences(t))}}ngOnDestroy(){this._currentIconFetch.unsubscribe(),this._elementsWithExternalReferences&&this._elementsWithExternalReferences.clear()}_usingFontIcon(){return!this.svgIcon}_setSvgElement(t){this._clearSvgElement();const e=t.querySelectorAll("style");for(let r=0;r<e.length;r++)e[r].textContent+=" ";const n=this._location.getPathname();this._previousPath=n,this._cacheChildrenWithExternalReferences(t),this._prependPathToReferences(n),this._elementRef.nativeElement.appendChild(t)}_clearSvgElement(){const t=this._elementRef.nativeElement;let e=t.childNodes.length;for(this._elementsWithExternalReferences&&this._elementsWithExternalReferences.clear();e--;){const n=t.childNodes[e];1===n.nodeType&&"svg"!==n.nodeName.toLowerCase()||t.removeChild(n)}}_updateFontIconClasses(){if(!this._usingFontIcon())return;const t=this._elementRef.nativeElement,e=this.fontSet?this._iconRegistry.classNameForFontAlias(this.fontSet):this._iconRegistry.getDefaultFontSetClass();e!=this._previousFontSetClass&&(this._previousFontSetClass&&t.classList.remove(this._previousFontSetClass),e&&t.classList.add(e),this._previousFontSetClass=e),this.fontIcon!=this._previousFontIconClass&&(this._previousFontIconClass&&t.classList.remove(this._previousFontIconClass),this.fontIcon&&t.classList.add(this.fontIcon),this._previousFontIconClass=this.fontIcon)}_cleanupFontValue(t){return"string"==typeof t?t.trim().split(" ")[0]:t}_prependPathToReferences(t){const e=this._elementsWithExternalReferences;e&&e.forEach((e,n)=>{e.forEach(e=>{n.setAttribute(e.name,`url('${t}#${e.value}')`)})})}_cacheChildrenWithExternalReferences(t){const e=t.querySelectorAll(Jx),n=this._elementsWithExternalReferences=this._elementsWithExternalReferences||new Map;for(let r=0;r<e.length;r++)Zx.forEach(t=>{const i=e[r],s=i.getAttribute(t),o=s?s.match(Qx):null;if(o){let e=n.get(i);e||(e=[],n.set(i,e)),e.push({name:t,value:o[1]})}})}}return t.\u0275fac=function(e){return new(e||t)(ta(dl),ta(jx),xr("aria-hidden"),ta(Yx),ta(Di))},t.\u0275cmp=me({type:t,selectors:[["mat-icon"]],hostAttrs:["role","img",1,"mat-icon","notranslate"],hostVars:4,hostBindings:function(t,e){2&t&&ka("mat-icon-inline",e.inline)("mat-icon-no-color","primary"!==e.color&&"accent"!==e.color&&"warn"!==e.color)},inputs:{color:"color",inline:"inline",fontSet:"fontSet",fontIcon:"fontIcon",svgIcon:"svgIcon"},exportAs:["matIcon"],features:[Vo,Be],ngContentSelectors:zx,decls:1,vars:0,template:function(t,e){1&t&&(ba(),_a(0))},styles:[".mat-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\n"],encapsulation:2,changeDetection:0}),t})(),ew=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},imports:[[Ry],Ry]}),t})();function nw(t,e){1&t&&(ra(0,"mat-toolbar"),ra(1,"mat-icon"),za(2,"hearing"),ia(),ra(3,"span"),za(4),hc(5,"transloco"),ia(),ia()),2&t&&(Ts(4),Va(dc(5,1,"header.title")))}let rw=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=me({type:t,selectors:[["app-header"]],decls:1,vars:1,consts:[[4,"transloco","translocoRead"]],template:function(t,e){1&t&&Qo(0,nw,6,3,"mat-toolbar",0),2&t&&ea("translocoRead","header")},directives:[ab,ix,tw],pipes:[lb],styles:[".spacer[_ngcontent-%COMP%]{flex:1 1 auto}.auth-avatar[_ngcontent-%COMP%]{border-radius:100%;cursor:pointer;width:36px;height:36px;overflow:hidden}.auth-avatar[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:focus{outline:0}#sign-in[_ngcontent-%COMP%]{text-transform:uppercase}#auth-details[_ngcontent-%COMP%]{display:flex;margin-top:4px}#auth-details[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]{display:flex;flex-direction:column;text-align:right;margin-right:12px;font-weight:400;padding-top:2px}#auth-details[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{font-size:14px;line-height:16px}#auth-details[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{font-size:13px;line-height:16px;cursor:pointer}"]}),t})();const iw=["*"];function sw(t,e){if(1&t){const t=la();ra(0,"div",2),da("click",function(){return hn(t),ya()._onBackdropClicked()}),ia()}2&t&&ka("mat-drawer-shown",ya()._isShowingBackdrop())}function ow(t,e){1&t&&(ra(0,"mat-drawer-content"),_a(1,2),ia())}const aw=[[["mat-drawer"]],[["mat-drawer-content"]],"*"],lw=["mat-drawer","mat-drawer-content","*"],cw={transformDrawer:Wf("transform",[Xf("open, open-instant",qf({transform:"none",visibility:"visible"})),Xf("void",qf({"box-shadow":"none",visibility:"hidden"})),Yf("void => open-instant",jf("0ms")),Yf("void <=> open, open-instant => void",jf("400ms cubic-bezier(0.25, 0.8, 0.25, 1)"))])};function uw(t){throw Error(`A drawer was already declared for 'position="${t}"'`)}const hw=new Er("MAT_DRAWER_DEFAULT_AUTOSIZE",{providedIn:"root",factory:function(){return!1}}),dw=new Er("MAT_DRAWER_CONTAINER");let pw=(()=>{class t extends _b{constructor(t,e,n,r,i){super(n,r,i),this._changeDetectorRef=t,this._container=e}ngAfterContentInit(){this._container._contentMarginChanges.subscribe(()=>{this._changeDetectorRef.markForCheck()})}}return t.\u0275fac=function(e){return new(e||t)(ta($l),ta(Dt(()=>mw)),ta(dl),ta(bb),ta(eu))},t.\u0275cmp=me({type:t,selectors:[["mat-drawer-content"]],hostAttrs:[1,"mat-drawer-content"],hostVars:4,hostBindings:function(t,e){2&t&&Ma("margin-left",e._container._contentMargins.left,"px")("margin-right",e._container._contentMargins.right,"px")},features:[Vo],ngContentSelectors:iw,decls:1,vars:0,template:function(t,e){1&t&&(ba(),_a(0))},encapsulation:2,changeDetection:0}),t})(),fw=(()=>{class t{constructor(t,e,n,r,i,s,o){this._elementRef=t,this._focusTrapFactory=e,this._focusMonitor=n,this._platform=r,this._ngZone=i,this._doc=s,this._container=o,this._elementFocusedBeforeDrawerWasOpened=null,this._enableAnimations=!1,this._position="start",this._mode="over",this._disableClose=!1,this._opened=!1,this._animationStarted=new J,this._animationEnd=new J,this._animationState="void",this.openedChange=new pc(!0),this._openedStream=this.openedChange.pipe(yd(t=>t),et(()=>{})),this._closedStream=this.openedChange.pipe(yd(t=>!t),et(()=>{})),this._destroyed=new J,this.onPositionChanged=new pc,this._modeChanged=new J,this.openedChange.subscribe(t=>{t?(this._doc&&(this._elementFocusedBeforeDrawerWasOpened=this._doc.activeElement),this._takeFocus()):this._isFocusWithinDrawer()&&this._restoreFocus()}),this._ngZone.runOutsideAngular(()=>{hb(this._elementRef.nativeElement,"keydown").pipe(yd(t=>27===t.keyCode&&!this.disableClose&&!Yp(t)),Dd(this._destroyed)).subscribe(t=>this._ngZone.run(()=>{this.close(),t.stopPropagation(),t.preventDefault()}))}),this._animationEnd.pipe(Vd((t,e)=>t.fromState===e.fromState&&t.toState===e.toState)).subscribe(t=>{const{fromState:e,toState:n}=t;(0===n.indexOf("open")&&"void"===e||"void"===n&&0===e.indexOf("open"))&&this.openedChange.emit(this._opened)})}get position(){return this._position}set position(t){(t="end"===t?"end":"start")!=this._position&&(this._position=t,this.onPositionChanged.emit())}get mode(){return this._mode}set mode(t){this._mode=t,this._updateFocusTrapState(),this._modeChanged.next()}get disableClose(){return this._disableClose}set disableClose(t){this._disableClose=nf(t)}get autoFocus(){const t=this._autoFocus;return null==t?"side"!==this.mode:t}set autoFocus(t){this._autoFocus=nf(t)}get opened(){return this._opened}set opened(t){this.toggle(nf(t))}get openedStart(){return this._animationStarted.pipe(yd(t=>t.fromState!==t.toState&&0===t.toState.indexOf("open")),et(()=>{}))}get closedStart(){return this._animationStarted.pipe(yd(t=>t.fromState!==t.toState&&"void"===t.toState),et(()=>{}))}_takeFocus(){this.autoFocus&&this._focusTrap&&this._focusTrap.focusInitialElementWhenReady().then(t=>{t||"function"!=typeof this._elementRef.nativeElement.focus||this._elementRef.nativeElement.focus()})}_restoreFocus(){this.autoFocus&&(this._elementFocusedBeforeDrawerWasOpened?this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened,this._openedVia):this._elementRef.nativeElement.blur(),this._elementFocusedBeforeDrawerWasOpened=null,this._openedVia=null)}_isFocusWithinDrawer(){var t;const e=null===(t=this._doc)||void 0===t?void 0:t.activeElement;return!!e&&this._elementRef.nativeElement.contains(e)}ngAfterContentInit(){this._focusTrap=this._focusTrapFactory.create(this._elementRef.nativeElement),this._updateFocusTrapState()}ngAfterContentChecked(){this._platform.isBrowser&&(this._enableAnimations=!0)}ngOnDestroy(){this._focusTrap&&this._focusTrap.destroy(),this._animationStarted.complete(),this._animationEnd.complete(),this._modeChanged.complete(),this._destroyed.next(),this._destroyed.complete()}open(t){return this.toggle(!0,t)}close(){return this.toggle(!1)}_closeViaBackdropClick(){return this._setOpen(!1,!0)}toggle(t=!this.opened,e){return this._setOpen(t,!t&&this._isFocusWithinDrawer(),e)}_setOpen(t,e,n="program"){return this._opened=t,t?(this._animationState=this._enableAnimations?"open":"open-instant",this._openedVia=n):(this._animationState="void",e&&this._restoreFocus()),this._updateFocusTrapState(),new Promise(t=>{this.openedChange.pipe(wd(1)).subscribe(e=>t(e?"open":"close"))})}_getWidth(){return this._elementRef.nativeElement&&this._elementRef.nativeElement.offsetWidth||0}_updateFocusTrapState(){this._focusTrap&&(this._focusTrap.enabled=this.opened&&"side"!==this.mode)}_animationStartListener(t){this._animationStarted.next(t)}_animationDoneListener(t){this._animationEnd.next(t)}}return t.\u0275fac=function(e){return new(e||t)(ta(dl),ta(wf),ta(kf),ta(jp),ta(eu),ta(Mu,8),ta(dw,8))},t.\u0275cmp=me({type:t,selectors:[["mat-drawer"]],hostAttrs:["tabIndex","-1",1,"mat-drawer"],hostVars:12,hostBindings:function(t,e){1&t&&pa("@transform.start",function(t){return e._animationStartListener(t)})("@transform.done",function(t){return e._animationDoneListener(t)}),2&t&&(Jo("align",null),Ha("@transform",e._animationState),ka("mat-drawer-end","end"===e.position)("mat-drawer-over","over"===e.mode)("mat-drawer-push","push"===e.mode)("mat-drawer-side","side"===e.mode)("mat-drawer-opened",e.opened))},inputs:{position:"position",mode:"mode",disableClose:"disableClose",autoFocus:"autoFocus",opened:"opened"},outputs:{openedChange:"openedChange",_openedStream:"opened",_closedStream:"closed",onPositionChanged:"positionChanged",openedStart:"openedStart",closedStart:"closedStart"},exportAs:["matDrawer"],ngContentSelectors:iw,decls:2,vars:0,consts:[[1,"mat-drawer-inner-container"]],template:function(t,e){1&t&&(ba(),ra(0,"div",0),_a(1),ia())},encapsulation:2,data:{animation:[cw.transformDrawer]},changeDetection:0}),t})(),mw=(()=>{class t{constructor(t,e,n,r,i,s=!1,o){this._dir=t,this._element=e,this._ngZone=n,this._changeDetectorRef=r,this._animationMode=o,this._drawers=new mc,this.backdropClick=new pc,this._destroyed=new J,this._doCheckSubject=new J,this._contentMargins={left:null,right:null},this._contentMarginChanges=new J,t&&t.change.pipe(Dd(this._destroyed)).subscribe(()=>{this._validateDrawers(),this.updateContentMargins()}),i.change().pipe(Dd(this._destroyed)).subscribe(()=>this.updateContentMargins()),this._autosize=s}get start(){return this._start}get end(){return this._end}get autosize(){return this._autosize}set autosize(t){this._autosize=nf(t)}get hasBackdrop(){return null==this._backdropOverride?!this._start||"side"!==this._start.mode||!this._end||"side"!==this._end.mode:this._backdropOverride}set hasBackdrop(t){this._backdropOverride=null==t?null:nf(t)}get scrollable(){return this._userContent||this._content}ngAfterContentInit(){this._allDrawers.changes.pipe(Vf(this._allDrawers),Dd(this._destroyed)).subscribe(t=>{this._drawers.reset(t.filter(t=>!t._container||t._container===this)),this._drawers.notifyOnChanges()}),this._drawers.changes.pipe(Vf(null)).subscribe(()=>{this._validateDrawers(),this._drawers.forEach(t=>{this._watchDrawerToggle(t),this._watchDrawerPosition(t),this._watchDrawerMode(t)}),(!this._drawers.length||this._isDrawerOpen(this._start)||this._isDrawerOpen(this._end))&&this.updateContentMargins(),this._changeDetectorRef.markForCheck()}),this._ngZone.runOutsideAngular(()=>{this._doCheckSubject.pipe(Jp(10),Dd(this._destroyed)).subscribe(()=>this.updateContentMargins())})}ngOnDestroy(){this._contentMarginChanges.complete(),this._doCheckSubject.complete(),this._drawers.destroy(),this._destroyed.next(),this._destroyed.complete()}open(){this._drawers.forEach(t=>t.open())}close(){this._drawers.forEach(t=>t.close())}updateContentMargins(){let t=0,e=0;if(this._left&&this._left.opened)if("side"==this._left.mode)t+=this._left._getWidth();else if("push"==this._left.mode){const n=this._left._getWidth();t+=n,e-=n}if(this._right&&this._right.opened)if("side"==this._right.mode)e+=this._right._getWidth();else if("push"==this._right.mode){const n=this._right._getWidth();e+=n,t-=n}t=t||null,e=e||null,t===this._contentMargins.left&&e===this._contentMargins.right||(this._contentMargins={left:t,right:e},this._ngZone.run(()=>this._contentMarginChanges.next(this._contentMargins)))}ngDoCheck(){this._autosize&&this._isPushed()&&this._ngZone.runOutsideAngular(()=>this._doCheckSubject.next())}_watchDrawerToggle(t){t._animationStarted.pipe(yd(t=>t.fromState!==t.toState),Dd(this._drawers.changes)).subscribe(t=>{"open-instant"!==t.toState&&"NoopAnimations"!==this._animationMode&&this._element.nativeElement.classList.add("mat-drawer-transition"),this.updateContentMargins(),this._changeDetectorRef.markForCheck()}),"side"!==t.mode&&t.openedChange.pipe(Dd(this._drawers.changes)).subscribe(()=>this._setContainerClass(t.opened))}_watchDrawerPosition(t){t&&t.onPositionChanged.pipe(Dd(this._drawers.changes)).subscribe(()=>{this._ngZone.onMicrotaskEmpty.asObservable().pipe(wd(1)).subscribe(()=>{this._validateDrawers()})})}_watchDrawerMode(t){t&&t._modeChanged.pipe(Dd(_t(this._drawers.changes,this._destroyed))).subscribe(()=>{this.updateContentMargins(),this._changeDetectorRef.markForCheck()})}_setContainerClass(t){const e=this._element.nativeElement.classList,n="mat-drawer-container-has-open";t?e.add(n):e.remove(n)}_validateDrawers(){this._start=this._end=null,this._drawers.forEach(t=>{"end"==t.position?(null!=this._end&&uw("end"),this._end=t):(null!=this._start&&uw("start"),this._start=t)}),this._right=this._left=null,this._dir&&"rtl"===this._dir.value?(this._left=this._end,this._right=this._start):(this._left=this._start,this._right=this._end)}_isPushed(){return this._isDrawerOpen(this._start)&&"over"!=this._start.mode||this._isDrawerOpen(this._end)&&"over"!=this._end.mode}_onBackdropClicked(){this.backdropClick.emit(),this._closeModalDrawersViaBackdrop()}_closeModalDrawersViaBackdrop(){[this._start,this._end].filter(t=>t&&!t.disableClose&&this._canHaveBackdrop(t)).forEach(t=>t._closeViaBackdropClick())}_isShowingBackdrop(){return this._isDrawerOpen(this._start)&&this._canHaveBackdrop(this._start)||this._isDrawerOpen(this._end)&&this._canHaveBackdrop(this._end)}_canHaveBackdrop(t){return"side"!==t.mode||!!this._backdropOverride}_isDrawerOpen(t){return null!=t&&t.opened}}return t.\u0275fac=function(e){return new(e||t)(ta(Pf,8),ta(dl),ta(eu),ta($l),ta(xb),ta(hw),ta(Ey,8))},t.\u0275cmp=me({type:t,selectors:[["mat-drawer-container"]],contentQueries:function(t,e,n){if(1&t&&(Ac(n,pw,1),Ac(n,fw,1)),2&t){let t;Cc(t=Mc())&&(e._content=t.first),Cc(t=Mc())&&(e._allDrawers=t)}},viewQuery:function(t,e){if(1&t&&Tc(pw,1),2&t){let t;Cc(t=Mc())&&(e._userContent=t.first)}},hostAttrs:[1,"mat-drawer-container"],hostVars:2,hostBindings:function(t,e){2&t&&ka("mat-drawer-container-explicit-backdrop",e._backdropOverride)},inputs:{autosize:"autosize",hasBackdrop:"hasBackdrop"},outputs:{backdropClick:"backdropClick"},exportAs:["matDrawerContainer"],features:[sl([{provide:dw,useExisting:t}])],ngContentSelectors:lw,decls:4,vars:2,consts:[["class","mat-drawer-backdrop",3,"mat-drawer-shown","click",4,"ngIf"],[4,"ngIf"],[1,"mat-drawer-backdrop",3,"click"]],template:function(t,e){1&t&&(ba(aw),Qo(0,sw,1,2,"div",0),_a(1),_a(2,1),Qo(3,ow,2,0,"mat-drawer-content",1)),2&t&&(ea("ngIf",e.hasBackdrop),Ts(3),ea("ngIf",!e._content))},directives:[Ju,pw],styles:[".mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}.cdk-high-contrast-active .mat-drawer-backdrop{opacity:.5}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}.cdk-high-contrast-active .mat-drawer,.cdk-high-contrast-active [dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}.cdk-high-contrast-active [dir=rtl] .mat-drawer,.cdk-high-contrast-active .mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer{transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}\n"],encapsulation:2,changeDetection:0}),t})(),gw=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},imports:[[ch,Ry,Gp,wb],wb,Ry]}),t})(),yw=(()=>{class t{constructor(t,e){this.setting=t,this.value=e}}return t.type="[Settings] Set Setting",t})(),vw=(()=>{class t{constructor(){this.ngUnsubscribe=new J}ngOnDestroy(){this.ngUnsubscribe.next(),this.ngUnsubscribe.complete()}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=me({type:t,selectors:[["app-base"]],decls:2,vars:0,template:function(t,e){1&t&&(ra(0,"p"),za(1," base works! "),ia())},encapsulation:2}),t})(),bw=(()=>{class t extends vw{constructor(t){super(),this.store=t}applySetting(t,e){this.store.dispatch(new yw(t,e))}}return zh([Vp(t=>t.settings)],t.prototype,"settingsState$",void 0),t})();const _w=new Er("NgValueAccessor"),xw={provide:_w,useExisting:Dt(()=>ww),multi:!0};let ww=(()=>{class t{constructor(t,e){this._renderer=t,this._elementRef=e,this.onChange=t=>{},this.onTouched=()=>{}}writeValue(t){this._renderer.setProperty(this._elementRef.nativeElement,"checked",t)}registerOnChange(t){this.onChange=t}registerOnTouched(t){this.onTouched=t}setDisabledState(t){this._renderer.setProperty(this._elementRef.nativeElement,"disabled",t)}}return t.\u0275fac=function(e){return new(e||t)(ta(ml),ta(dl))},t.\u0275dir=xe({type:t,selectors:[["input","type","checkbox","formControlName",""],["input","type","checkbox","formControl",""],["input","type","checkbox","ngModel",""]],hostBindings:function(t,e){1&t&&da("change",function(t){return e.onChange(t.target.checked)})("blur",function(){return e.onTouched()})},features:[sl([xw])]}),t})();const Sw={provide:_w,useExisting:Dt(()=>Cw),multi:!0},Ew=new Er("CompositionEventMode");let Cw=(()=>{class t{constructor(t,e,n){this._renderer=t,this._elementRef=e,this._compositionMode=n,this.onChange=t=>{},this.onTouched=()=>{},this._composing=!1,null==this._compositionMode&&(this._compositionMode=!function(){const t=Au()?Au().getUserAgent():"";return/android (\d+)/.test(t.toLowerCase())}())}writeValue(t){this._renderer.setProperty(this._elementRef.nativeElement,"value",null==t?"":t)}registerOnChange(t){this.onChange=t}registerOnTouched(t){this.onTouched=t}setDisabledState(t){this._renderer.setProperty(this._elementRef.nativeElement,"disabled",t)}_handleInput(t){(!this._compositionMode||this._compositionMode&&!this._composing)&&this.onChange(t)}_compositionStart(){this._composing=!0}_compositionEnd(t){this._composing=!1,this._compositionMode&&this.onChange(t)}}return t.\u0275fac=function(e){return new(e||t)(ta(ml),ta(dl),ta(Ew,8))},t.\u0275dir=xe({type:t,selectors:[["input","formControlName","",3,"type","checkbox"],["textarea","formControlName",""],["input","formControl","",3,"type","checkbox"],["textarea","formControl",""],["input","ngModel","",3,"type","checkbox"],["textarea","ngModel",""],["","ngDefaultControl",""]],hostBindings:function(t,e){1&t&&da("input",function(t){return e._handleInput(t.target.value)})("blur",function(){return e.onTouched()})("compositionstart",function(){return e._compositionStart()})("compositionend",function(t){return e._compositionEnd(t.target.value)})},features:[sl([Sw])]}),t})();function Tw(t){return null==t||0===t.length}function Aw(t){return null!=t&&"number"==typeof t.length}const Mw=new Er("NgValidators"),kw=new Er("NgAsyncValidators"),Rw=/^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;class Iw{static min(t){return e=>{if(Tw(e.value)||Tw(t))return null;const n=parseFloat(e.value);return!isNaN(n)&&n<t?{min:{min:t,actual:e.value}}:null}}static max(t){return e=>{if(Tw(e.value)||Tw(t))return null;const n=parseFloat(e.value);return!isNaN(n)&&n>t?{max:{max:t,actual:e.value}}:null}}static required(t){return Tw(t.value)?{required:!0}:null}static requiredTrue(t){return!0===t.value?null:{required:!0}}static email(t){return Tw(t.value)||Rw.test(t.value)?null:{email:!0}}static minLength(t){return e=>Tw(e.value)||!Aw(e.value)?null:e.value.length<t?{minlength:{requiredLength:t,actualLength:e.value.length}}:null}static maxLength(t){return e=>Aw(e.value)&&e.value.length>t?{maxlength:{requiredLength:t,actualLength:e.value.length}}:null}static pattern(t){if(!t)return Iw.nullValidator;let e,n;return"string"==typeof t?(n="","^"!==t.charAt(0)&&(n+="^"),n+=t,"$"!==t.charAt(t.length-1)&&(n+="$"),e=new RegExp(n)):(n=t.toString(),e=t),t=>{if(Tw(t.value))return null;const r=t.value;return e.test(r)?null:{pattern:{requiredPattern:n,actualValue:r}}}}static nullValidator(t){return null}static compose(t){if(!t)return null;const e=t.filter(Nw);return 0==e.length?null:function(t){return Dw(Lw(t,e))}}static composeAsync(t){if(!t)return null;const e=t.filter(Nw);return 0==e.length?null:function(t){return md(Lw(t,e).map(Ow)).pipe(et(Dw))}}}function Nw(t){return null!=t}function Ow(t){const e=ca(t)?ht(t):t;return ha(e),e}function Dw(t){let e={};return t.forEach(t=>{e=null!=t?Object.assign(Object.assign({},e),t):e}),0===Object.keys(e).length?null:e}function Lw(t,e){return e.map(e=>e(t))}function Fw(t){return t.map(t=>function(t){return!t.validate}(t)?t:e=>t.validate(e))}function Pw(t){return null!=t?Iw.compose(Fw(t)):null}function $w(t){return null!=t?Iw.composeAsync(Fw(t)):null}function Bw(t,e){return null===t?[e]:Array.isArray(t)?[...t,e]:[t,e]}let zw=(()=>{class t{constructor(){this._rawValidators=[],this._rawAsyncValidators=[],this._onDestroyCallbacks=[]}get value(){return this.control?this.control.value:null}get valid(){return this.control?this.control.valid:null}get invalid(){return this.control?this.control.invalid:null}get pending(){return this.control?this.control.pending:null}get disabled(){return this.control?this.control.disabled:null}get enabled(){return this.control?this.control.enabled:null}get errors(){return this.control?this.control.errors:null}get pristine(){return this.control?this.control.pristine:null}get dirty(){return this.control?this.control.dirty:null}get touched(){return this.control?this.control.touched:null}get status(){return this.control?this.control.status:null}get untouched(){return this.control?this.control.untouched:null}get statusChanges(){return this.control?this.control.statusChanges:null}get valueChanges(){return this.control?this.control.valueChanges:null}get path(){return null}_setValidators(t){this._rawValidators=t||[],this._composedValidatorFn=Pw(this._rawValidators)}_setAsyncValidators(t){this._rawAsyncValidators=t||[],this._composedAsyncValidatorFn=$w(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn||null}get asyncValidator(){return this._composedAsyncValidatorFn||null}_registerOnDestroy(t){this._onDestroyCallbacks.push(t)}_invokeOnDestroyCallbacks(){this._onDestroyCallbacks.forEach(t=>t()),this._onDestroyCallbacks=[]}reset(t){this.control&&this.control.reset(t)}hasError(t,e){return!!this.control&&this.control.hasError(t,e)}getError(t,e){return this.control?this.control.getError(t,e):null}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=xe({type:t}),t})(),Vw=(()=>{class t extends zw{get formDirective(){return null}get path(){return null}}return t.\u0275fac=function(e){return Uw(e||t)},t.\u0275dir=xe({type:t,features:[Vo]}),t})();const Uw=_r(Vw);class Hw extends zw{constructor(){super(...arguments),this._parent=null,this.name=null,this.valueAccessor=null}}let Ww=(()=>{class t extends class{constructor(t){this._cd=t}is(t){var e,n;return!!(null===(n=null===(e=this._cd)||void 0===e?void 0:e.control)||void 0===n?void 0:n[t])}}{constructor(t){super(t)}}return t.\u0275fac=function(e){return new(e||t)(ta(Hw,2))},t.\u0275dir=xe({type:t,selectors:[["","formControlName",""],["","ngModel",""],["","formControl",""]],hostVars:14,hostBindings:function(t,e){2&t&&ka("ng-untouched",e.is("untouched"))("ng-touched",e.is("touched"))("ng-pristine",e.is("pristine"))("ng-dirty",e.is("dirty"))("ng-valid",e.is("valid"))("ng-invalid",e.is("invalid"))("ng-pending",e.is("pending"))},features:[Vo]}),t})();const jw={provide:_w,useExisting:Dt(()=>Gw),multi:!0};let Gw=(()=>{class t{constructor(t,e){this._renderer=t,this._elementRef=e,this.onChange=t=>{},this.onTouched=()=>{}}writeValue(t){this._renderer.setProperty(this._elementRef.nativeElement,"value",null==t?"":t)}registerOnChange(t){this.onChange=e=>{t(""==e?null:parseFloat(e))}}registerOnTouched(t){this.onTouched=t}setDisabledState(t){this._renderer.setProperty(this._elementRef.nativeElement,"disabled",t)}}return t.\u0275fac=function(e){return new(e||t)(ta(ml),ta(dl))},t.\u0275dir=xe({type:t,selectors:[["input","type","number","formControlName",""],["input","type","number","formControl",""],["input","type","number","ngModel",""]],hostBindings:function(t,e){1&t&&da("input",function(t){return e.onChange(t.target.value)})("blur",function(){return e.onTouched()})},features:[sl([jw])]}),t})();const qw={provide:_w,useExisting:Dt(()=>Kw),multi:!0};let Xw=(()=>{class t{constructor(){this._accessors=[]}add(t,e){this._accessors.push([t,e])}remove(t){for(let e=this._accessors.length-1;e>=0;--e)if(this._accessors[e][1]===t)return void this._accessors.splice(e,1)}select(t){this._accessors.forEach(e=>{this._isSameGroup(e,t)&&e[1]!==t&&e[1].fireUncheck(t.value)})}_isSameGroup(t,e){return!!t[0].control&&t[0]._parent===e._control._parent&&t[1].name===e.name}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})(),Kw=(()=>{class t{constructor(t,e,n,r){this._renderer=t,this._elementRef=e,this._registry=n,this._injector=r,this.onChange=()=>{},this.onTouched=()=>{}}ngOnInit(){this._control=this._injector.get(Hw),this._checkName(),this._registry.add(this._control,this)}ngOnDestroy(){this._registry.remove(this)}writeValue(t){this._state=t===this.value,this._renderer.setProperty(this._elementRef.nativeElement,"checked",this._state)}registerOnChange(t){this._fn=t,this.onChange=()=>{t(this.value),this._registry.select(this)}}fireUncheck(t){this.writeValue(t)}registerOnTouched(t){this.onTouched=t}setDisabledState(t){this._renderer.setProperty(this._elementRef.nativeElement,"disabled",t)}_checkName(){!this.name&&this.formControlName&&(this.name=this.formControlName)}}return t.\u0275fac=function(e){return new(e||t)(ta(ml),ta(dl),ta(Xw),ta(Bo))},t.\u0275dir=xe({type:t,selectors:[["input","type","radio","formControlName",""],["input","type","radio","formControl",""],["input","type","radio","ngModel",""]],hostBindings:function(t,e){1&t&&da("change",function(){return e.onChange()})("blur",function(){return e.onTouched()})},inputs:{name:"name",formControlName:"formControlName",value:"value"},features:[sl([qw])]}),t})();const Yw={provide:_w,useExisting:Dt(()=>Zw),multi:!0};let Zw=(()=>{class t{constructor(t,e){this._renderer=t,this._elementRef=e,this.onChange=t=>{},this.onTouched=()=>{}}writeValue(t){this._renderer.setProperty(this._elementRef.nativeElement,"value",parseFloat(t))}registerOnChange(t){this.onChange=e=>{t(""==e?null:parseFloat(e))}}registerOnTouched(t){this.onTouched=t}setDisabledState(t){this._renderer.setProperty(this._elementRef.nativeElement,"disabled",t)}}return t.\u0275fac=function(e){return new(e||t)(ta(ml),ta(dl))},t.\u0275dir=xe({type:t,selectors:[["input","type","range","formControlName",""],["input","type","range","formControl",""],["input","type","range","ngModel",""]],hostBindings:function(t,e){1&t&&da("change",function(t){return e.onChange(t.target.value)})("input",function(t){return e.onChange(t.target.value)})("blur",function(){return e.onTouched()})},features:[sl([Yw])]}),t})();const Jw={provide:_w,useExisting:Dt(()=>Qw),multi:!0};let Qw=(()=>{class t{constructor(t,e){this._renderer=t,this._elementRef=e,this._optionMap=new Map,this._idCounter=0,this.onChange=t=>{},this.onTouched=()=>{},this._compareWith=Object.is}set compareWith(t){this._compareWith=t}writeValue(t){this.value=t;const e=this._getOptionId(t);null==e&&this._renderer.setProperty(this._elementRef.nativeElement,"selectedIndex",-1);const n=function(t,e){return null==t?`${e}`:(e&&"object"==typeof e&&(e="Object"),`${t}: ${e}`.slice(0,50))}(e,t);this._renderer.setProperty(this._elementRef.nativeElement,"value",n)}registerOnChange(t){this.onChange=e=>{this.value=this._getOptionValue(e),t(this.value)}}registerOnTouched(t){this.onTouched=t}setDisabledState(t){this._renderer.setProperty(this._elementRef.nativeElement,"disabled",t)}_registerOption(){return(this._idCounter++).toString()}_getOptionId(t){for(const e of Array.from(this._optionMap.keys()))if(this._compareWith(this._optionMap.get(e),t))return e;return null}_getOptionValue(t){const e=function(t){return t.split(":")[0]}(t);return this._optionMap.has(e)?this._optionMap.get(e):t}}return t.\u0275fac=function(e){return new(e||t)(ta(ml),ta(dl))},t.\u0275dir=xe({type:t,selectors:[["select","formControlName","",3,"multiple",""],["select","formControl","",3,"multiple",""],["select","ngModel","",3,"multiple",""]],hostBindings:function(t,e){1&t&&da("change",function(t){return e.onChange(t.target.value)})("blur",function(){return e.onTouched()})},inputs:{compareWith:"compareWith"},features:[sl([Jw])]}),t})();const tS={provide:_w,useExisting:Dt(()=>eS),multi:!0};let eS=(()=>{class t{constructor(t,e){this._renderer=t,this._elementRef=e,this._optionMap=new Map,this._idCounter=0,this.onChange=t=>{},this.onTouched=()=>{},this._compareWith=Object.is}set compareWith(t){this._compareWith=t}writeValue(t){let e;if(this.value=t,Array.isArray(t)){const n=t.map(t=>this._getOptionId(t));e=(t,e)=>{t._setSelected(n.indexOf(e.toString())>-1)}}else e=(t,e)=>{t._setSelected(!1)};this._optionMap.forEach(e)}registerOnChange(t){this.onChange=e=>{const n=[];if(void 0!==e.selectedOptions){const t=e.selectedOptions;for(let e=0;e<t.length;e++){const r=t.item(e),i=this._getOptionValue(r.value);n.push(i)}}else{const t=e.options;for(let e=0;e<t.length;e++){const r=t.item(e);if(r.selected){const t=this._getOptionValue(r.value);n.push(t)}}}this.value=n,t(n)}}registerOnTouched(t){this.onTouched=t}setDisabledState(t){this._renderer.setProperty(this._elementRef.nativeElement,"disabled",t)}_registerOption(t){const e=(this._idCounter++).toString();return this._optionMap.set(e,t),e}_getOptionId(t){for(const e of Array.from(this._optionMap.keys()))if(this._compareWith(this._optionMap.get(e)._value,t))return e;return null}_getOptionValue(t){const e=function(t){return t.split(":")[0]}(t);return this._optionMap.has(e)?this._optionMap.get(e)._value:t}}return t.\u0275fac=function(e){return new(e||t)(ta(ml),ta(dl))},t.\u0275dir=xe({type:t,selectors:[["select","multiple","","formControlName",""],["select","multiple","","formControl",""],["select","multiple","","ngModel",""]],hostBindings:function(t,e){1&t&&da("change",function(t){return e.onChange(t.target)})("blur",function(){return e.onTouched()})},inputs:{compareWith:"compareWith"},features:[sl([tS])]}),t})();function nS(t,e){t.forEach(t=>{t.registerOnValidatorChange&&t.registerOnValidatorChange(e)})}function rS(t,e){t._pendingDirty&&t.markAsDirty(),t.setValue(t._pendingValue,{emitModelToViewChange:!1}),e.viewToModelUpdate(t._pendingValue),t._pendingChange=!1}const iS=[ww,Zw,Gw,Qw,eS,Kw];function sS(t,e){const n=t.indexOf(e);n>-1&&t.splice(n,1)}const oS="VALID",aS="INVALID",lS="PENDING",cS="DISABLED";function uS(t){return(fS(t)?t.validators:t)||null}function hS(t){return Array.isArray(t)?Pw(t):t||null}function dS(t,e){return(fS(e)?e.asyncValidators:t)||null}function pS(t){return Array.isArray(t)?$w(t):t||null}function fS(t){return null!=t&&!Array.isArray(t)&&"object"==typeof t}class mS{constructor(t,e){this._hasOwnPendingAsyncValidator=!1,this._onCollectionChange=()=>{},this._parent=null,this.pristine=!0,this.touched=!1,this._onDisabledChange=[],this._rawValidators=t,this._rawAsyncValidators=e,this._composedValidatorFn=hS(this._rawValidators),this._composedAsyncValidatorFn=pS(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn}set validator(t){this._rawValidators=this._composedValidatorFn=t}get asyncValidator(){return this._composedAsyncValidatorFn}set asyncValidator(t){this._rawAsyncValidators=this._composedAsyncValidatorFn=t}get parent(){return this._parent}get valid(){return this.status===oS}get invalid(){return this.status===aS}get pending(){return this.status==lS}get disabled(){return this.status===cS}get enabled(){return this.status!==cS}get dirty(){return!this.pristine}get untouched(){return!this.touched}get updateOn(){return this._updateOn?this._updateOn:this.parent?this.parent.updateOn:"change"}setValidators(t){this._rawValidators=t,this._composedValidatorFn=hS(t)}setAsyncValidators(t){this._rawAsyncValidators=t,this._composedAsyncValidatorFn=pS(t)}clearValidators(){this.validator=null}clearAsyncValidators(){this.asyncValidator=null}markAsTouched(t={}){this.touched=!0,this._parent&&!t.onlySelf&&this._parent.markAsTouched(t)}markAllAsTouched(){this.markAsTouched({onlySelf:!0}),this._forEachChild(t=>t.markAllAsTouched())}markAsUntouched(t={}){this.touched=!1,this._pendingTouched=!1,this._forEachChild(t=>{t.markAsUntouched({onlySelf:!0})}),this._parent&&!t.onlySelf&&this._parent._updateTouched(t)}markAsDirty(t={}){this.pristine=!1,this._parent&&!t.onlySelf&&this._parent.markAsDirty(t)}markAsPristine(t={}){this.pristine=!0,this._pendingDirty=!1,this._forEachChild(t=>{t.markAsPristine({onlySelf:!0})}),this._parent&&!t.onlySelf&&this._parent._updatePristine(t)}markAsPending(t={}){this.status=lS,!1!==t.emitEvent&&this.statusChanges.emit(this.status),this._parent&&!t.onlySelf&&this._parent.markAsPending(t)}disable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status=cS,this.errors=null,this._forEachChild(e=>{e.disable(Object.assign(Object.assign({},t),{onlySelf:!0}))}),this._updateValue(),!1!==t.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._updateAncestors(Object.assign(Object.assign({},t),{skipPristineCheck:e})),this._onDisabledChange.forEach(t=>t(!0))}enable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status=oS,this._forEachChild(e=>{e.enable(Object.assign(Object.assign({},t),{onlySelf:!0}))}),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent}),this._updateAncestors(Object.assign(Object.assign({},t),{skipPristineCheck:e})),this._onDisabledChange.forEach(t=>t(!1))}_updateAncestors(t){this._parent&&!t.onlySelf&&(this._parent.updateValueAndValidity(t),t.skipPristineCheck||this._parent._updatePristine(),this._parent._updateTouched())}setParent(t){this._parent=t}updateValueAndValidity(t={}){this._setInitialStatus(),this._updateValue(),this.enabled&&(this._cancelExistingSubscription(),this.errors=this._runValidator(),this.status=this._calculateStatus(),this.status!==oS&&this.status!==lS||this._runAsyncValidator(t.emitEvent)),!1!==t.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._parent&&!t.onlySelf&&this._parent.updateValueAndValidity(t)}_updateTreeValidity(t={emitEvent:!0}){this._forEachChild(e=>e._updateTreeValidity(t)),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent})}_setInitialStatus(){this.status=this._allControlsDisabled()?cS:oS}_runValidator(){return this.validator?this.validator(this):null}_runAsyncValidator(t){if(this.asyncValidator){this.status=lS,this._hasOwnPendingAsyncValidator=!0;const e=Ow(this.asyncValidator(this));this._asyncValidationSubscription=e.subscribe(e=>{this._hasOwnPendingAsyncValidator=!1,this.setErrors(e,{emitEvent:t})})}}_cancelExistingSubscription(){this._asyncValidationSubscription&&(this._asyncValidationSubscription.unsubscribe(),this._hasOwnPendingAsyncValidator=!1)}setErrors(t,e={}){this.errors=t,this._updateControlsErrors(!1!==e.emitEvent)}get(t){return function(t,e,n){if(null==e)return null;if(Array.isArray(e)||(e=e.split(".")),Array.isArray(e)&&0===e.length)return null;let r=t;return e.forEach(t=>{r=r instanceof yS?r.controls.hasOwnProperty(t)?r.controls[t]:null:r instanceof vS&&r.at(t)||null}),r}(this,t)}getError(t,e){const n=e?this.get(e):this;return n&&n.errors?n.errors[t]:null}hasError(t,e){return!!this.getError(t,e)}get root(){let t=this;for(;t._parent;)t=t._parent;return t}_updateControlsErrors(t){this.status=this._calculateStatus(),t&&this.statusChanges.emit(this.status),this._parent&&this._parent._updateControlsErrors(t)}_initObservables(){this.valueChanges=new pc,this.statusChanges=new pc}_calculateStatus(){return this._allControlsDisabled()?cS:this.errors?aS:this._hasOwnPendingAsyncValidator||this._anyControlsHaveStatus(lS)?lS:this._anyControlsHaveStatus(aS)?aS:oS}_anyControlsHaveStatus(t){return this._anyControls(e=>e.status===t)}_anyControlsDirty(){return this._anyControls(t=>t.dirty)}_anyControlsTouched(){return this._anyControls(t=>t.touched)}_updatePristine(t={}){this.pristine=!this._anyControlsDirty(),this._parent&&!t.onlySelf&&this._parent._updatePristine(t)}_updateTouched(t={}){this.touched=this._anyControlsTouched(),this._parent&&!t.onlySelf&&this._parent._updateTouched(t)}_isBoxedValue(t){return"object"==typeof t&&null!==t&&2===Object.keys(t).length&&"value"in t&&"disabled"in t}_registerOnCollectionChange(t){this._onCollectionChange=t}_setUpdateStrategy(t){fS(t)&&null!=t.updateOn&&(this._updateOn=t.updateOn)}_parentMarkedDirty(t){return!t&&!(!this._parent||!this._parent.dirty)&&!this._parent._anyControlsDirty()}}class gS extends mS{constructor(t=null,e,n){super(uS(e),dS(n,e)),this._onChange=[],this._applyFormState(t),this._setUpdateStrategy(e),this._initObservables(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!n})}setValue(t,e={}){this.value=this._pendingValue=t,this._onChange.length&&!1!==e.emitModelToViewChange&&this._onChange.forEach(t=>t(this.value,!1!==e.emitViewToModelChange)),this.updateValueAndValidity(e)}patchValue(t,e={}){this.setValue(t,e)}reset(t=null,e={}){this._applyFormState(t),this.markAsPristine(e),this.markAsUntouched(e),this.setValue(this.value,e),this._pendingChange=!1}_updateValue(){}_anyControls(t){return!1}_allControlsDisabled(){return this.disabled}registerOnChange(t){this._onChange.push(t)}_unregisterOnChange(t){sS(this._onChange,t)}registerOnDisabledChange(t){this._onDisabledChange.push(t)}_unregisterOnDisabledChange(t){sS(this._onDisabledChange,t)}_forEachChild(t){}_syncPendingControls(){return!("submit"!==this.updateOn||(this._pendingDirty&&this.markAsDirty(),this._pendingTouched&&this.markAsTouched(),!this._pendingChange)||(this.setValue(this._pendingValue,{onlySelf:!0,emitModelToViewChange:!1}),0))}_applyFormState(t){this._isBoxedValue(t)?(this.value=this._pendingValue=t.value,t.disabled?this.disable({onlySelf:!0,emitEvent:!1}):this.enable({onlySelf:!0,emitEvent:!1})):this.value=this._pendingValue=t}}class yS extends mS{constructor(t,e,n){super(uS(e),dS(n,e)),this.controls=t,this._initObservables(),this._setUpdateStrategy(e),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!n})}registerControl(t,e){return this.controls[t]?this.controls[t]:(this.controls[t]=e,e.setParent(this),e._registerOnCollectionChange(this._onCollectionChange),e)}addControl(t,e){this.registerControl(t,e),this.updateValueAndValidity(),this._onCollectionChange()}removeControl(t){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),delete this.controls[t],this.updateValueAndValidity(),this._onCollectionChange()}setControl(t,e){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),delete this.controls[t],e&&this.registerControl(t,e),this.updateValueAndValidity(),this._onCollectionChange()}contains(t){return this.controls.hasOwnProperty(t)&&this.controls[t].enabled}setValue(t,e={}){this._checkAllValuesPresent(t),Object.keys(t).forEach(n=>{this._throwIfControlMissing(n),this.controls[n].setValue(t[n],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e)}patchValue(t,e={}){null!=t&&(Object.keys(t).forEach(n=>{this.controls[n]&&this.controls[n].patchValue(t[n],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e))}reset(t={},e={}){this._forEachChild((n,r)=>{n.reset(t[r],{onlySelf:!0,emitEvent:e.emitEvent})}),this._updatePristine(e),this._updateTouched(e),this.updateValueAndValidity(e)}getRawValue(){return this._reduceChildren({},(t,e,n)=>(t[n]=e instanceof gS?e.value:e.getRawValue(),t))}_syncPendingControls(){let t=this._reduceChildren(!1,(t,e)=>!!e._syncPendingControls()||t);return t&&this.updateValueAndValidity({onlySelf:!0}),t}_throwIfControlMissing(t){if(!Object.keys(this.controls).length)throw new Error("\n        There are no form controls registered with this group yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");if(!this.controls[t])throw new Error(`Cannot find form control with name: ${t}.`)}_forEachChild(t){Object.keys(this.controls).forEach(e=>{const n=this.controls[e];n&&t(n,e)})}_setUpControls(){this._forEachChild(t=>{t.setParent(this),t._registerOnCollectionChange(this._onCollectionChange)})}_updateValue(){this.value=this._reduceValue()}_anyControls(t){for(const e of Object.keys(this.controls)){const n=this.controls[e];if(this.contains(e)&&t(n))return!0}return!1}_reduceValue(){return this._reduceChildren({},(t,e,n)=>((e.enabled||this.disabled)&&(t[n]=e.value),t))}_reduceChildren(t,e){let n=t;return this._forEachChild((t,r)=>{n=e(n,t,r)}),n}_allControlsDisabled(){for(const t of Object.keys(this.controls))if(this.controls[t].enabled)return!1;return Object.keys(this.controls).length>0||this.disabled}_checkAllValuesPresent(t){this._forEachChild((e,n)=>{if(void 0===t[n])throw new Error(`Must supply a value for form control with name: '${n}'.`)})}}class vS extends mS{constructor(t,e,n){super(uS(e),dS(n,e)),this.controls=t,this._initObservables(),this._setUpdateStrategy(e),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!n})}at(t){return this.controls[t]}push(t){this.controls.push(t),this._registerControl(t),this.updateValueAndValidity(),this._onCollectionChange()}insert(t,e){this.controls.splice(t,0,e),this._registerControl(e),this.updateValueAndValidity()}removeAt(t){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),this.controls.splice(t,1),this.updateValueAndValidity()}setControl(t,e){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),this.controls.splice(t,1),e&&(this.controls.splice(t,0,e),this._registerControl(e)),this.updateValueAndValidity(),this._onCollectionChange()}get length(){return this.controls.length}setValue(t,e={}){this._checkAllValuesPresent(t),t.forEach((t,n)=>{this._throwIfControlMissing(n),this.at(n).setValue(t,{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e)}patchValue(t,e={}){null!=t&&(t.forEach((t,n)=>{this.at(n)&&this.at(n).patchValue(t,{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e))}reset(t=[],e={}){this._forEachChild((n,r)=>{n.reset(t[r],{onlySelf:!0,emitEvent:e.emitEvent})}),this._updatePristine(e),this._updateTouched(e),this.updateValueAndValidity(e)}getRawValue(){return this.controls.map(t=>t instanceof gS?t.value:t.getRawValue())}clear(){this.controls.length<1||(this._forEachChild(t=>t._registerOnCollectionChange(()=>{})),this.controls.splice(0),this.updateValueAndValidity())}_syncPendingControls(){let t=this.controls.reduce((t,e)=>!!e._syncPendingControls()||t,!1);return t&&this.updateValueAndValidity({onlySelf:!0}),t}_throwIfControlMissing(t){if(!this.controls.length)throw new Error("\n        There are no form controls registered with this array yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");if(!this.at(t))throw new Error(`Cannot find form control at index ${t}`)}_forEachChild(t){this.controls.forEach((e,n)=>{t(e,n)})}_updateValue(){this.value=this.controls.filter(t=>t.enabled||this.disabled).map(t=>t.value)}_anyControls(t){return this.controls.some(e=>e.enabled&&t(e))}_setUpControls(){this._forEachChild(t=>this._registerControl(t))}_checkAllValuesPresent(t){this._forEachChild((e,n)=>{if(void 0===t[n])throw new Error(`Must supply a value for form control at index: ${n}.`)})}_allControlsDisabled(){for(const t of this.controls)if(t.enabled)return!1;return this.controls.length>0||this.disabled}_registerControl(t){t.setParent(this),t._registerOnCollectionChange(this._onCollectionChange)}}const bS={provide:Hw,useExisting:Dt(()=>xS)},_S=(()=>Promise.resolve(null))();let xS=(()=>{class t extends Hw{constructor(t,e,n,r){super(),this.control=new gS,this._registered=!1,this.update=new pc,this._parent=t,this._setValidators(e),this._setAsyncValidators(n),this.valueAccessor=function(t,e){if(!e)return null;let n,r,i;return Array.isArray(e),e.forEach(t=>{var e;t.constructor===Cw?n=t:(e=t,iS.some(t=>e.constructor===t)?r=t:i=t)}),i||r||n||null}(0,r)}ngOnChanges(t){this._checkForErrors(),this._registered||this._setUpControl(),"isDisabled"in t&&this._updateDisabled(t),function(t,e){if(!t.hasOwnProperty("model"))return!1;const n=t.model;return!!n.isFirstChange()||!Object.is(e,n.currentValue)}(t,this.viewModel)&&(this._updateValue(this.model),this.viewModel=this.model)}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}get path(){return this._parent?[...this._parent.path,this.name]:[this.name]}get formDirective(){return this._parent?this._parent.formDirective:null}viewToModelUpdate(t){this.viewModel=t,this.update.emit(t)}_setUpControl(){this._setUpdateStrategy(),this._isStandalone()?this._setUpStandalone():this.formDirective.addControl(this),this._registered=!0}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.control._updateOn=this.options.updateOn)}_isStandalone(){return!this._parent||!(!this.options||!this.options.standalone)}_setUpStandalone(){var t,e;(function(t,e,n){const r=function(t){return t._rawValidators}(t);null!==e.validator?t.setValidators(Bw(r,e.validator)):"function"==typeof r&&t.setValidators([r]);const i=function(t){return t._rawAsyncValidators}(t);null!==e.asyncValidator?t.setAsyncValidators(Bw(i,e.asyncValidator)):"function"==typeof i&&t.setAsyncValidators([i]);{const n=()=>t.updateValueAndValidity();nS(e._rawValidators,n),nS(e._rawAsyncValidators,n)}})(t=this.control,e=this),e.valueAccessor.writeValue(t.value),function(t,e){e.valueAccessor.registerOnChange(n=>{t._pendingValue=n,t._pendingChange=!0,t._pendingDirty=!0,"change"===t.updateOn&&rS(t,e)})}(t,e),function(t,e){const n=(t,n)=>{e.valueAccessor.writeValue(t),n&&e.viewToModelUpdate(t)};t.registerOnChange(n),e._registerOnDestroy(()=>{t._unregisterOnChange(n)})}(t,e),function(t,e){e.valueAccessor.registerOnTouched(()=>{t._pendingTouched=!0,"blur"===t.updateOn&&t._pendingChange&&rS(t,e),"submit"!==t.updateOn&&t.markAsTouched()})}(t,e),function(t,e){if(e.valueAccessor.setDisabledState){const n=t=>{e.valueAccessor.setDisabledState(t)};t.registerOnDisabledChange(n),e._registerOnDestroy(()=>{t._unregisterOnDisabledChange(n)})}}(t,e),this.control.updateValueAndValidity({emitEvent:!1})}_checkForErrors(){this._isStandalone()||this._checkParentType(),this._checkName()}_checkParentType(){}_checkName(){this.options&&this.options.name&&(this.name=this.options.name),this._isStandalone()}_updateValue(t){_S.then(()=>{this.control.setValue(t,{emitViewToModelChange:!1})})}_updateDisabled(t){const e=t.isDisabled.currentValue,n=""===e||e&&"false"!==e;_S.then(()=>{n&&!this.control.disabled?this.control.disable():!n&&this.control.disabled&&this.control.enable()})}}return t.\u0275fac=function(e){return new(e||t)(ta(Vw,9),ta(Mw,10),ta(kw,10),ta(_w,10))},t.\u0275dir=xe({type:t,selectors:[["","ngModel","",3,"formControlName","",3,"formControl",""]],inputs:{name:"name",isDisabled:["disabled","isDisabled"],model:["ngModel","model"],options:["ngModelOptions","options"]},outputs:{update:"ngModelChange"},exportAs:["ngModel"],features:[sl([bS]),Vo,Be]}),t})(),wS=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)}}),t})(),SS=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},providers:[Xw],imports:[wS]}),t})(),ES=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},imports:[[Ry],Ry]}),t})();const CS=["*"],TS=["text"];function AS(t,e){if(1&t&&sa(0,"mat-pseudo-checkbox",5),2&t){const t=ya();ea("state",t.selected?"checked":"unchecked")("disabled",t.disabled)}}const MS=["*",[["","mat-list-avatar",""],["","mat-list-icon",""],["","matListAvatar",""],["","matListIcon",""]]],kS=["*","[mat-list-avatar], [mat-list-icon], [matListAvatar], [matListIcon]"];let RS=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=xe({type:t,selectors:[["","mat-list-avatar",""],["","matListAvatar",""]],hostAttrs:[1,"mat-list-avatar"]}),t})(),IS=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=xe({type:t,selectors:[["","mat-list-icon",""],["","matListIcon",""]],hostAttrs:[1,"mat-list-icon"]}),t})();class NS{}const OS=Oy(NS);class DS{}const LS=Oy(DS),FS={provide:_w,useExisting:Dt(()=>BS),multi:!0};class PS{constructor(t,e){this.source=t,this.option=e}}let $S=(()=>{class t extends LS{constructor(t,e,n){super(),this._element=t,this._changeDetector=e,this.selectionList=n,this._selected=!1,this._disabled=!1,this._hasFocus=!1,this.checkboxPosition="after",this._inputsInitialized=!1}get color(){return this._color||this.selectionList.color}set color(t){this._color=t}get value(){return this._value}set value(t){this.selected&&t!==this.value&&this._inputsInitialized&&(this.selected=!1),this._value=t}get disabled(){return this._disabled||this.selectionList&&this.selectionList.disabled}set disabled(t){const e=nf(t);e!==this._disabled&&(this._disabled=e,this._changeDetector.markForCheck())}get selected(){return this.selectionList.selectedOptions.isSelected(this)}set selected(t){const e=nf(t);e!==this._selected&&(this._setSelected(e),this.selectionList._reportValueChange())}ngOnInit(){const t=this.selectionList;t._value&&t._value.some(e=>t.compareWith(e,this._value))&&this._setSelected(!0);const e=this._selected;Promise.resolve().then(()=>{(this._selected||e)&&(this.selected=!0,this._changeDetector.markForCheck())}),this._inputsInitialized=!0}ngAfterContentInit(){!function(t,e,n="mat"){t.changes.pipe(Vf(t)).subscribe(({length:t})=>{Ly(e,`${n}-2-line`,!1),Ly(e,`${n}-3-line`,!1),Ly(e,`${n}-multi-line`,!1),2===t||3===t?Ly(e,`${n}-${t}-line`,!0):t>3&&Ly(e,`${n}-multi-line`,!0)})}(this._lines,this._element)}ngOnDestroy(){this.selected&&Promise.resolve().then(()=>{this.selected=!1});const t=this._hasFocus,e=this.selectionList._removeOptionFromList(this);t&&e&&e.focus()}toggle(){this.selected=!this.selected}focus(){this._element.nativeElement.focus()}getLabel(){return this._text&&this._text.nativeElement.textContent||""}_isRippleDisabled(){return this.disabled||this.disableRipple||this.selectionList.disableRipple}_handleClick(){this.disabled||!this.selectionList.multiple&&this.selected||(this.toggle(),this.selectionList._emitChangeEvent(this))}_handleFocus(){this.selectionList._setFocusedOption(this),this._hasFocus=!0}_handleBlur(){this.selectionList._onTouched(),this._hasFocus=!1}_getHostElement(){return this._element.nativeElement}_setSelected(t){return t!==this._selected&&(this._selected=t,t?this.selectionList.selectedOptions.select(this):this.selectionList.selectedOptions.deselect(this),this._changeDetector.markForCheck(),!0)}_markForCheck(){this._changeDetector.markForCheck()}}return t.\u0275fac=function(e){return new(e||t)(ta(dl),ta($l),ta(Dt(()=>BS)))},t.\u0275cmp=me({type:t,selectors:[["mat-list-option"]],contentQueries:function(t,e,n){if(1&t&&(Ac(n,RS,1),Ac(n,IS,1),Ac(n,Dy,1)),2&t){let t;Cc(t=Mc())&&(e._avatar=t.first),Cc(t=Mc())&&(e._icon=t.first),Cc(t=Mc())&&(e._lines=t)}},viewQuery:function(t,e){if(1&t&&Tc(TS,1),2&t){let t;Cc(t=Mc())&&(e._text=t.first)}},hostAttrs:["role","option",1,"mat-list-item","mat-list-option","mat-focus-indicator"],hostVars:15,hostBindings:function(t,e){1&t&&da("focus",function(){return e._handleFocus()})("blur",function(){return e._handleBlur()})("click",function(){return e._handleClick()}),2&t&&(Jo("aria-selected",e.selected)("aria-disabled",e.disabled)("tabindex",-1),ka("mat-list-item-disabled",e.disabled)("mat-list-item-with-avatar",e._avatar||e._icon)("mat-primary","primary"===e.color)("mat-accent","primary"!==e.color&&"warn"!==e.color)("mat-warn","warn"===e.color)("mat-list-single-selected-option",e.selected&&!e.selectionList.multiple))},inputs:{disableRipple:"disableRipple",checkboxPosition:"checkboxPosition",color:"color",value:"value",selected:"selected",disabled:"disabled"},exportAs:["matListOption"],features:[Vo],ngContentSelectors:kS,decls:7,vars:5,consts:[[1,"mat-list-item-content"],["mat-ripple","",1,"mat-list-item-ripple",3,"matRippleTrigger","matRippleDisabled"],[3,"state","disabled",4,"ngIf"],[1,"mat-list-text"],["text",""],[3,"state","disabled"]],template:function(t,e){1&t&&(ba(MS),ra(0,"div",0),sa(1,"div",1),Qo(2,AS,1,2,"mat-pseudo-checkbox",2),ra(3,"div",3,4),_a(5),ia(),_a(6,1),ia()),2&t&&(ka("mat-list-item-content-reverse","after"==e.checkboxPosition),Ts(1),ea("matRippleTrigger",e._getHostElement())("matRippleDisabled",e._isRippleDisabled()),Ts(1),ea("ngIf",e.selectionList.multiple))},directives:[Wy,Ju,Gy],encapsulation:2,changeDetection:0}),t})(),BS=(()=>{class t extends OS{constructor(t,e,n){super(),this._element=t,this._changeDetector=n,this._multiple=!0,this._contentInitialized=!1,this.selectionChange=new pc,this.tabIndex=0,this.color="accent",this.compareWith=(t,e)=>t===e,this._disabled=!1,this.selectedOptions=new vb(this._multiple),this._tabIndex=-1,this._onChange=t=>{},this._destroyed=new J,this._onTouched=()=>{}}get disabled(){return this._disabled}set disabled(t){this._disabled=nf(t),this._markOptionsForCheck()}get multiple(){return this._multiple}set multiple(t){const e=nf(t);if(e!==this._multiple){if(mu()&&this._contentInitialized)throw new Error("Cannot change `multiple` mode of mat-selection-list after initialization.");this._multiple=e,this.selectedOptions=new vb(this._multiple,this.selectedOptions.selected)}}ngAfterContentInit(){this._contentInitialized=!0,this._keyManager=new yf(this.options).withWrap().withTypeAhead().skipPredicate(()=>!1).withAllowedModifierKeys(["shiftKey"]),this._value&&this._setOptionsFromValues(this._value),this._keyManager.tabOut.pipe(Dd(this._destroyed)).subscribe(()=>{this._allowFocusEscape()}),this.options.changes.pipe(Vf(null),Dd(this._destroyed)).subscribe(()=>{this._updateTabIndex()}),this.selectedOptions.changed.pipe(Dd(this._destroyed)).subscribe(t=>{if(t.added)for(let e of t.added)e.selected=!0;if(t.removed)for(let e of t.removed)e.selected=!1})}ngOnChanges(t){const e=t.disableRipple,n=t.color;(e&&!e.firstChange||n&&!n.firstChange)&&this._markOptionsForCheck()}ngOnDestroy(){this._destroyed.next(),this._destroyed.complete(),this._isDestroyed=!0}focus(t){this._element.nativeElement.focus(t)}selectAll(){this._setAllOptionsSelected(!0)}deselectAll(){this._setAllOptionsSelected(!1)}_setFocusedOption(t){this._keyManager.updateActiveItem(t)}_removeOptionFromList(t){const e=this._getOptionIndex(t);return e>-1&&this._keyManager.activeItemIndex===e&&(e>0?this._keyManager.updateActiveItem(e-1):0===e&&this.options.length>1&&this._keyManager.updateActiveItem(Math.min(e+1,this.options.length-1))),this._keyManager.activeItem}_keydown(t){const e=t.keyCode,n=this._keyManager,r=n.activeItemIndex,i=Yp(t);switch(e){case 32:case 13:i||n.isTyping()||(this._toggleFocusedOption(),t.preventDefault());break;case 36:case 35:i||(36===e?n.setFirstItemActive():n.setLastItemActive(),t.preventDefault());break;default:if(65===e&&this.multiple&&Yp(t,"ctrlKey")&&!n.isTyping()){const e=this.options.some(t=>!t.disabled&&!t.selected);this._setAllOptionsSelected(e,!0),t.preventDefault()}else n.onKeydown(t)}this.multiple&&(38===e||40===e)&&t.shiftKey&&n.activeItemIndex!==r&&this._toggleFocusedOption()}_reportValueChange(){if(this.options&&!this._isDestroyed){const t=this._getSelectedOptionValues();this._onChange(t),this._value=t}}_emitChangeEvent(t){this.selectionChange.emit(new PS(this,t))}_onFocus(){const t=this._keyManager.activeItemIndex;t&&-1!==t?this._keyManager.setActiveItem(t):this._keyManager.setFirstItemActive()}writeValue(t){this._value=t,this.options&&this._setOptionsFromValues(t||[])}setDisabledState(t){this.disabled=t}registerOnChange(t){this._onChange=t}registerOnTouched(t){this._onTouched=t}_setOptionsFromValues(t){this.options.forEach(t=>t._setSelected(!1)),t.forEach(t=>{const e=this.options.find(e=>!e.selected&&this.compareWith(e.value,t));e&&e._setSelected(!0)})}_getSelectedOptionValues(){return this.options.filter(t=>t.selected).map(t=>t.value)}_toggleFocusedOption(){let t=this._keyManager.activeItemIndex;if(null!=t&&this._isValidIndex(t)){let e=this.options.toArray()[t];!e||e.disabled||!this._multiple&&e.selected||(e.toggle(),this._emitChangeEvent(e))}}_setAllOptionsSelected(t,e){let n=!1;this.options.forEach(r=>{e&&r.disabled||!r._setSelected(t)||(n=!0)}),n&&this._reportValueChange()}_isValidIndex(t){return t>=0&&t<this.options.length}_getOptionIndex(t){return this.options.toArray().indexOf(t)}_markOptionsForCheck(){this.options&&this.options.forEach(t=>t._markForCheck())}_allowFocusEscape(){this._tabIndex=-1,setTimeout(()=>{this._tabIndex=0,this._changeDetector.markForCheck()})}_updateTabIndex(){this._tabIndex=0===this.options.length?-1:0}}return t.\u0275fac=function(e){return new(e||t)(ta(dl),xr("tabindex"),ta($l))},t.\u0275cmp=me({type:t,selectors:[["mat-selection-list"]],contentQueries:function(t,e,n){if(1&t&&Ac(n,$S,1),2&t){let t;Cc(t=Mc())&&(e.options=t)}},hostAttrs:["role","listbox",1,"mat-selection-list","mat-list-base"],hostVars:3,hostBindings:function(t,e){1&t&&da("focus",function(){return e._onFocus()})("keydown",function(t){return e._keydown(t)}),2&t&&Jo("aria-multiselectable",e.multiple)("aria-disabled",e.disabled.toString())("tabindex",e._tabIndex)},inputs:{disableRipple:"disableRipple",tabIndex:"tabIndex",color:"color",compareWith:"compareWith",disabled:"disabled",multiple:"multiple"},outputs:{selectionChange:"selectionChange"},exportAs:["matSelectionList"],features:[sl([FS]),Vo,Be],ngContentSelectors:CS,decls:1,vars:0,template:function(t,e){1&t&&(ba(),_a(0))},styles:['.mat-subheader{display:flex;box-sizing:border-box;padding:16px;align-items:center}.mat-list-base .mat-subheader{margin:0}.mat-list-base{padding-top:8px;display:block;-webkit-tap-highlight-color:transparent}.mat-list-base .mat-subheader{height:48px;line-height:16px}.mat-list-base .mat-subheader:first-child{margin-top:-8px}.mat-list-base .mat-list-item,.mat-list-base .mat-list-option{display:block;height:48px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base .mat-list-item .mat-list-item-content,.mat-list-base .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base .mat-list-item .mat-list-item-content-reverse,.mat-list-base .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base .mat-list-item .mat-list-item-ripple,.mat-list-base .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar,.mat-list-base .mat-list-option.mat-list-item-with-avatar{height:56px}.mat-list-base .mat-list-item.mat-2-line,.mat-list-base .mat-list-option.mat-2-line{height:72px}.mat-list-base .mat-list-item.mat-3-line,.mat-list-base .mat-list-option.mat-3-line{height:88px}.mat-list-base .mat-list-item.mat-multi-line,.mat-list-base .mat-list-option.mat-multi-line{height:auto}.mat-list-base .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base .mat-list-item .mat-list-text,.mat-list-base .mat-list-option .mat-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base .mat-list-item .mat-list-text>*,.mat-list-base .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-list-base .mat-list-item .mat-list-text:empty,.mat-list-base .mat-list-option .mat-list-text:empty{display:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base .mat-list-item .mat-list-avatar,.mat-list-base .mat-list-option .mat-list-avatar{flex-shrink:0;width:40px;height:40px;border-radius:50%;object-fit:cover}.mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:72px;width:calc(100% - 72px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:72px}.mat-list-base .mat-list-item .mat-list-icon,.mat-list-base .mat-list-option .mat-list-icon{flex-shrink:0;width:24px;height:24px;font-size:24px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:64px;width:calc(100% - 64px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:64px}.mat-list-base .mat-list-item .mat-divider,.mat-list-base .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base .mat-list-item .mat-divider,[dir=rtl] .mat-list-base .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-list-base[dense]{padding-top:4px;display:block}.mat-list-base[dense] .mat-subheader{height:40px;line-height:8px}.mat-list-base[dense] .mat-subheader:first-child{margin-top:-4px}.mat-list-base[dense] .mat-list-item,.mat-list-base[dense] .mat-list-option{display:block;height:40px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-item-content,.mat-list-base[dense] .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base[dense] .mat-list-item .mat-list-item-content-reverse,.mat-list-base[dense] .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base[dense] .mat-list-item .mat-list-item-ripple,.mat-list-base[dense] .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar{height:48px}.mat-list-base[dense] .mat-list-item.mat-2-line,.mat-list-base[dense] .mat-list-option.mat-2-line{height:60px}.mat-list-base[dense] .mat-list-item.mat-3-line,.mat-list-base[dense] .mat-list-option.mat-3-line{height:76px}.mat-list-base[dense] .mat-list-item.mat-multi-line,.mat-list-base[dense] .mat-list-option.mat-multi-line{height:auto}.mat-list-base[dense] .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base[dense] .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base[dense] .mat-list-item .mat-list-text,.mat-list-base[dense] .mat-list-option .mat-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-text>*,.mat-list-base[dense] .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-list-base[dense] .mat-list-item .mat-list-text:empty,.mat-list-base[dense] .mat-list-option .mat-list-text:empty{display:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base[dense] .mat-list-item .mat-list-avatar,.mat-list-base[dense] .mat-list-option .mat-list-avatar{flex-shrink:0;width:36px;height:36px;border-radius:50%;object-fit:cover}.mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:68px;width:calc(100% - 68px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:68px}.mat-list-base[dense] .mat-list-item .mat-list-icon,.mat-list-base[dense] .mat-list-option .mat-list-icon{flex-shrink:0;width:20px;height:20px;font-size:20px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:60px;width:calc(100% - 60px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:60px}.mat-list-base[dense] .mat-list-item .mat-divider,.mat-list-base[dense] .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-divider,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base[dense] .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-nav-list a{text-decoration:none;color:inherit}.mat-nav-list .mat-list-item{cursor:pointer;outline:none}mat-action-list button{background:none;color:inherit;border:none;font:inherit;outline:inherit;-webkit-tap-highlight-color:transparent;text-align:left}[dir=rtl] mat-action-list button{text-align:right}mat-action-list button::-moz-focus-inner{border:0}mat-action-list .mat-list-item{cursor:pointer;outline:inherit}.mat-list-option:not(.mat-list-item-disabled){cursor:pointer;outline:none}.mat-list-item-disabled{pointer-events:none}.cdk-high-contrast-active .mat-list-item-disabled{opacity:.5}.cdk-high-contrast-active :host .mat-list-item-disabled{opacity:.5}.cdk-high-contrast-active .mat-selection-list:focus{outline-style:dotted}.cdk-high-contrast-active .mat-list-option:hover,.cdk-high-contrast-active .mat-list-option:focus,.cdk-high-contrast-active .mat-nav-list .mat-list-item:hover,.cdk-high-contrast-active .mat-nav-list .mat-list-item:focus,.cdk-high-contrast-active mat-action-list .mat-list-item:hover,.cdk-high-contrast-active mat-action-list .mat-list-item:focus{outline:dotted 1px}.cdk-high-contrast-active .mat-list-single-selected-option::after{content:"";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}.cdk-high-contrast-active [dir=rtl] .mat-list-single-selected-option::after{right:auto;left:16px}@media(hover: none){.mat-list-option:not(.mat-list-single-selected-option):not(.mat-list-item-disabled):hover,.mat-nav-list .mat-list-item:not(.mat-list-item-disabled):hover,.mat-action-list .mat-list-item:not(.mat-list-item-disabled):hover{background:none}}\n'],encapsulation:2,changeDetection:0}),t})(),zS=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},imports:[[Fy,jy,Ry,qy,ch],Fy,Ry,qy,ES]}),t})();function VS(t,e){if(1&t&&(ra(0,"mat-list-option",3),za(1),ia()),2&t){const t=e.$implicit,n=ya().$implicit;ea("value",t),Ts(1),Va(n(t))}}function US(t,e){if(1&t){const t=la();ra(0,"mat-selection-list",1),da("ngModelChange",function(e){return hn(t),ya().currentSettings=e})("ngModelChange",function(e){return hn(t),ya().onSettingsChange(e)}),Qo(1,VS,2,2,"mat-list-option",2),ia()}if(2&t){const t=ya();ea("ngModel",t.currentSettings),Ts(1),ea("ngForOf",t.availableSettings)}}let HS=(()=>{class t extends bw{constructor(t){super(t),this.availableSettings=["drawVideo","drawPose","drawSignWriting"],this.lastSettings=[],this.currentSettings=[]}ngOnInit(){this.settingsState$.pipe($d(t=>{this.currentSettings=this.lastSettings=this.availableSettings.filter(e=>t[e])}),Dd(this.ngUnsubscribe)).subscribe()}onSettingsChange(t){this.availableSettings.forEach(e=>{this.lastSettings.includes(e)&&!t.includes(e)?this.applySetting(e,!1):!this.lastSettings.includes(e)&&t.includes(e)&&this.applySetting(e,!0)})}}return t.\u0275fac=function(e){return new(e||t)(ta(Rp))},t.\u0275cmp=me({type:t,selectors:[["app-settings"]],features:[Vo],decls:1,vars:1,consts:[[3,"ngModel","ngModelChange",4,"transloco","translocoRead"],[3,"ngModel","ngModelChange"],[3,"value",4,"ngFor","ngForOf"],[3,"value"]],template:function(t,e){1&t&&Qo(0,US,2,2,"mat-selection-list",0),2&t&&ea("translocoRead","settings")},directives:[ab,BS,Ww,xS,Yu,$S],styles:[""]}),t})();var WS=n("MZFn"),jS=n.n(WS);function GS(t){return new Promise(e=>setTimeout(e,t))}let qS=(()=>{class t{}return t.type="[Pose] Load Pose Model",t})(),XS=(()=>{class t{constructor(t){this.video=t}}return t.type="[Pose] Pose Video Frame",t})(),KS=(()=>{class t{constructor(t){this.pose=t}}return t.type="[Pose] Store Frame Pose",t})();var YS=n("EUiz"),ZS=n("aOSE");const JS=[0,1,2,3,4,5,6,7,8,9,10,15,16,17,18,19,20,21,22];let QS=(()=>{class t{constructor(){}load(){return Vh(this,void 0,void 0,function*(){this.model=new YS.Holistic({locateFile:t=>(console.log("Holistic","loading",t),`https://cdn.jsdelivr.net/npm/@mediapipe/holistic@0.1/${t}`)})})}predict(t){return Vh(this,void 0,void 0,function*(){if(!this.model)return Promise.resolve(null);yield this.model.send({image:t})})}drawBody(t,e){const n=Array.from(t);for(const r of JS)delete n[r];ZS.drawConnectors(e,n,YS.POSE_CONNECTIONS,{color:"#00FF00"}),ZS.drawLandmarks(e,n,{color:"#00FF00",fillColor:"#FF0000"})}drawHand(t,e,n,r,i){ZS.drawConnectors(e,t,YS.HAND_CONNECTIONS,{color:n}),ZS.drawLandmarks(e,t,{color:r,fillColor:i,lineWidth:2,radius:t=>ZS.lerp(t.z,-.15,.1,10,1)})}drawFace(t,e){ZS.drawConnectors(e,t,YS.FACEMESH_TESSELATION,{color:"#C0C0C070",lineWidth:1}),ZS.drawConnectors(e,t,YS.FACEMESH_RIGHT_EYE,{color:"#FF3030"}),ZS.drawConnectors(e,t,YS.FACEMESH_RIGHT_EYEBROW,{color:"#FF3030"}),ZS.drawConnectors(e,t,YS.FACEMESH_LEFT_EYE,{color:"#30FF30"}),ZS.drawConnectors(e,t,YS.FACEMESH_LEFT_EYEBROW,{color:"#30FF30"}),ZS.drawConnectors(e,t,YS.FACEMESH_FACE_OVAL,{color:"#E0E0E0"}),ZS.drawConnectors(e,t,YS.FACEMESH_LIPS,{color:"#E0E0E0"})}drawConnect(t,e){for(const n of t){const t=n[0],r=n[1];if(t&&r){if(t.visibility&&r.visibility&&(t.visibility<.1||r.visibility<.1))continue;e.beginPath(),e.moveTo(t.x*e.canvas.width,t.y*e.canvas.height),e.lineTo(r.x*e.canvas.width,r.y*e.canvas.height),e.stroke()}}}drawElbowHandsConnection(t,e){e.lineWidth=5,t.rightHandLandmarks&&(e.strokeStyle="#00FF00",this.drawConnect([[t.poseLandmarks[YS.POSE_LANDMARKS.RIGHT_ELBOW],t.rightHandLandmarks[0]]],e)),t.leftHandLandmarks&&(e.strokeStyle="#FF0000",this.drawConnect([[t.poseLandmarks[YS.POSE_LANDMARKS.LEFT_ELBOW],t.leftHandLandmarks[0]]],e))}draw(t,e){t.poseLandmarks&&(this.drawBody(t.poseLandmarks,e),this.drawElbowHandsConnection(t,e)),t.leftHandLandmarks&&this.drawHand(t.leftHandLandmarks,e,"#CC0000","#FF0000","#00FF00"),t.rightHandLandmarks&&this.drawHand(t.rightHandLandmarks,e,"#00CC00","#00FF00","#FF0000"),t.faceLandmarks&&this.drawFace(t.faceLandmarks,e),e.restore()}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const tE=100,eE=1e3,nE=1001,rE=1002,iE=1003,sE=1006,oE=1008,aE=1012,lE=1014,cE=1015,uE=1016,hE=1020,dE=1022,pE=1023,fE=1026,mE=1027,gE=2300,yE=2301,vE=2302,bE=2400,_E=2401,xE=2402,wE=3e3,SE=7680,EE=35044,CE=35048,TE="300 es";function AE(){}Object.assign(AE.prototype,{addEventListener:function(t,e){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[t]&&(n[t]=[]),-1===n[t].indexOf(e)&&n[t].push(e)},hasEventListener:function(t,e){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[t]&&-1!==n[t].indexOf(e)},removeEventListener:function(t,e){if(void 0===this._listeners)return;const n=this._listeners[t];if(void 0!==n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}},dispatchEvent:function(t){if(void 0===this._listeners)return;const e=this._listeners[t.type];if(void 0!==e){t.target=this;const n=e.slice(0);for(let e=0,r=n.length;e<r;e++)n[e].call(this,t)}}});const ME=[];for(let H3=0;H3<256;H3++)ME[H3]=(H3<16?"0":"")+H3.toString(16);let kE=1234567;const RE={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,n=4294967295*Math.random()|0,r=4294967295*Math.random()|0;return(ME[255&t]+ME[t>>8&255]+ME[t>>16&255]+ME[t>>24&255]+"-"+ME[255&e]+ME[e>>8&255]+"-"+ME[e>>16&15|64]+ME[e>>24&255]+"-"+ME[63&n|128]+ME[n>>8&255]+"-"+ME[n>>16&255]+ME[n>>24&255]+ME[255&r]+ME[r>>8&255]+ME[r>>16&255]+ME[r>>24&255]).toUpperCase()},clamp:function(t,e,n){return Math.max(e,Math.min(n,t))},euclideanModulo:function(t,e){return(t%e+e)%e},mapLinear:function(t,e,n,r,i){return r+(t-e)*(i-r)/(n-e)},lerp:function(t,e,n){return(1-n)*t+n*e},damp:function(t,e,n,r){return RE.lerp(t,e,1-Math.exp(-n*r))},pingpong:function(t,e=1){return e-Math.abs(RE.euclideanModulo(t,2*e)-e)},smoothstep:function(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*(3-2*t)},smootherstep:function(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*t*(t*(6*t-15)+10)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},seededRandom:function(t){return void 0!==t&&(kE=t%2147483647),kE=16807*kE%2147483647,(kE-1)/2147483646},degToRad:function(t){return t*RE.DEG2RAD},radToDeg:function(t){return t*RE.RAD2DEG},isPowerOfTwo:function(t){return 0==(t&t-1)&&0!==t},ceilPowerOfTwo:function(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))},floorPowerOfTwo:function(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))},setQuaternionFromProperEuler:function(t,e,n,r,i){const s=Math.cos,o=Math.sin,a=s(n/2),l=o(n/2),c=s((e+r)/2),u=o((e+r)/2),h=s((e-r)/2),d=o((e-r)/2),p=s((r-e)/2),f=o((r-e)/2);switch(i){case"XYX":t.set(a*u,l*h,l*d,a*c);break;case"YZY":t.set(l*d,a*u,l*h,a*c);break;case"ZXZ":t.set(l*h,l*d,a*u,a*c);break;case"XZX":t.set(a*u,l*f,l*p,a*c);break;case"YXY":t.set(l*p,a*u,l*f,a*c);break;case"ZYZ":t.set(l*f,l*p,a*u,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}};class IE{constructor(t=0,e=0){Object.defineProperty(this,"isVector2",{value:!0}),this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6],this.y=r[1]*e+r[4]*n+r[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),r=Math.sin(e),i=this.x-t.x,s=this.y-t.y;return this.x=i*n-s*r+t.x,this.y=i*r+s*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}class NE{constructor(){Object.defineProperty(this,"isMatrix3",{value:!0}),this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,r,i,s,o,a,l){const c=this.elements;return c[0]=t,c[1]=r,c[2]=o,c[3]=e,c[4]=i,c[5]=a,c[6]=n,c[7]=s,c[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}clone(){return(new this.constructor).fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,r=e.elements,i=this.elements,s=n[0],o=n[3],a=n[6],l=n[1],c=n[4],u=n[7],h=n[2],d=n[5],p=n[8],f=r[0],m=r[3],g=r[6],y=r[1],v=r[4],b=r[7],_=r[2],x=r[5],w=r[8];return i[0]=s*f+o*y+a*_,i[3]=s*m+o*v+a*x,i[6]=s*g+o*b+a*w,i[1]=l*f+c*y+u*_,i[4]=l*m+c*v+u*x,i[7]=l*g+c*b+u*w,i[2]=h*f+d*y+p*_,i[5]=h*m+d*v+p*x,i[8]=h*g+d*b+p*w,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],r=t[2],i=t[3],s=t[4],o=t[5],a=t[6],l=t[7],c=t[8];return e*s*c-e*o*l-n*i*c+n*o*a+r*i*l-r*s*a}invert(){const t=this.elements,e=t[0],n=t[1],r=t[2],i=t[3],s=t[4],o=t[5],a=t[6],l=t[7],c=t[8],u=c*s-o*l,h=o*a-c*i,d=l*i-s*a,p=e*u+n*h+r*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const f=1/p;return t[0]=u*f,t[1]=(r*l-c*n)*f,t[2]=(o*n-r*s)*f,t[3]=h*f,t[4]=(c*e-r*a)*f,t[5]=(r*i-o*e)*f,t[6]=d*f,t[7]=(n*a-l*e)*f,t[8]=(s*e-n*i)*f,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).copy(this).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,r,i,s,o){const a=Math.cos(i),l=Math.sin(i);return this.set(n*a,n*l,-n*(a*s+l*o)+s+t,-r*l,r*a,-r*(-l*s+a*o)+o+e,0,0,1),this}scale(t,e){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=e,n[4]*=e,n[7]*=e,this}rotate(t){const e=Math.cos(t),n=Math.sin(t),r=this.elements,i=r[0],s=r[3],o=r[6],a=r[1],l=r[4],c=r[7];return r[0]=e*i+n*a,r[3]=e*s+n*l,r[6]=e*o+n*c,r[1]=-n*i+e*a,r[4]=-n*s+e*l,r[7]=-n*o+e*c,this}translate(t,e){const n=this.elements;return n[0]+=t*n[2],n[3]+=t*n[5],n[6]+=t*n[8],n[1]+=e*n[2],n[4]+=e*n[5],n[7]+=e*n[8],this}equals(t){const e=this.elements,n=t.elements;for(let r=0;r<9;r++)if(e[r]!==n[r])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}}let OE;const DE={getDataURL:function(t){if(/^data:/i.test(t.src))return t.src;if("undefined"==typeof HTMLCanvasElement)return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{void 0===OE&&(OE=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),OE.width=t.width,OE.height=t.height;const n=OE.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=OE}return e.width>2048||e.height>2048?e.toDataURL("image/jpeg",.6):e.toDataURL("image/png")}};let LE=0;function FE(t=FE.DEFAULT_IMAGE,e=FE.DEFAULT_MAPPING,n=1001,r=1001,i=1006,s=1008,o=1023,a=1009,l=1,c=3e3){Object.defineProperty(this,"id",{value:LE++}),this.uuid=RE.generateUUID(),this.name="",this.image=t,this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=r,this.magFilter=i,this.minFilter=s,this.anisotropy=l,this.format=o,this.internalFormat=null,this.type=a,this.offset=new IE(0,0),this.repeat=new IE(1,1),this.center=new IE(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new NE,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.version=0,this.onUpdate=null}function PE(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?DE.getDataURL(t):t.data?{data:Array.prototype.slice.call(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}FE.DEFAULT_IMAGE=void 0,FE.DEFAULT_MAPPING=300,FE.prototype=Object.assign(Object.create(AE.prototype),{constructor:FE,isTexture:!0,updateMatrix:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)},clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.name=t.name,this.image=t.image,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this},toJSON:function(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(void 0!==this.image){const r=this.image;if(void 0===r.uuid&&(r.uuid=RE.generateUUID()),!e&&void 0===t.images[r.uuid]){let e;if(Array.isArray(r)){e=[];for(let t=0,n=r.length;t<n;t++)e.push(PE(r[t].isDataTexture?r[t].image:r[t]))}else e=PE(r);t.images[r.uuid]={uuid:r.uuid,url:e}}n.image=r.uuid}return e||(t.textures[this.uuid]=n),n},dispose:function(){this.dispatchEvent({type:"dispose"})},transformUv:function(t){if(300!==this.mapping)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case eE:t.x=t.x-Math.floor(t.x);break;case nE:t.x=t.x<0?0:1;break;case rE:t.x=1===Math.abs(Math.floor(t.x)%2)?Math.ceil(t.x)-t.x:t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case eE:t.y=t.y-Math.floor(t.y);break;case nE:t.y=t.y<0?0:1;break;case rE:t.y=1===Math.abs(Math.floor(t.y)%2)?Math.ceil(t.y)-t.y:t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}}),Object.defineProperty(FE.prototype,"needsUpdate",{set:function(t){!0===t&&this.version++}});class $E{constructor(t=0,e=0,n=0,r=1){Object.defineProperty(this,"isVector4",{value:!0}),this.x=t,this.y=e,this.z=n,this.w=r}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,r){return this.x=t,this.y=e,this.z=n,this.w=r,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,r=this.z,i=this.w,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*r+s[12]*i,this.y=s[1]*e+s[5]*n+s[9]*r+s[13]*i,this.z=s[2]*e+s[6]*n+s[10]*r+s[14]*i,this.w=s[3]*e+s[7]*n+s[11]*r+s[15]*i,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,r,i;const s=.01,o=.1,a=t.elements,l=a[0],c=a[4],u=a[8],h=a[1],d=a[5],p=a[9],f=a[2],m=a[6],g=a[10];if(Math.abs(c-h)<s&&Math.abs(u-f)<s&&Math.abs(p-m)<s){if(Math.abs(c+h)<o&&Math.abs(u+f)<o&&Math.abs(p+m)<o&&Math.abs(l+d+g-3)<o)return this.set(1,0,0,0),this;e=Math.PI;const t=(l+1)/2,a=(d+1)/2,y=(g+1)/2,v=(c+h)/4,b=(u+f)/4,_=(p+m)/4;return t>a&&t>y?t<s?(n=0,r=.707106781,i=.707106781):(n=Math.sqrt(t),r=v/n,i=b/n):a>y?a<s?(n=.707106781,r=0,i=.707106781):(r=Math.sqrt(a),n=v/r,i=_/r):y<s?(n=.707106781,r=.707106781,i=0):(i=Math.sqrt(y),n=b/i,r=_/i),this.set(n,r,i,e),this}let y=Math.sqrt((m-p)*(m-p)+(u-f)*(u-f)+(h-c)*(h-c));return Math.abs(y)<.001&&(y=1),this.x=(m-p)/y,this.y=(u-f)/y,this.z=(h-c)/y,this.w=Math.acos((l+d+g-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}class BE extends AE{constructor(t,e,n){super(),Object.defineProperty(this,"isWebGLRenderTarget",{value:!0}),this.width=t,this.height=e,this.scissor=new $E(0,0,t,e),this.scissorTest=!1,this.viewport=new $E(0,0,t,e),this.texture=new FE(void 0,(n=n||{}).mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.image={},this.texture.image.width=t,this.texture.image.height=e,this.texture.generateMipmaps=void 0!==n.generateMipmaps&&n.generateMipmaps,this.texture.minFilter=void 0!==n.minFilter?n.minFilter:sE,this.depthBuffer=void 0===n.depthBuffer||n.depthBuffer,this.stencilBuffer=void 0!==n.stencilBuffer&&n.stencilBuffer,this.depthTexture=void 0!==n.depthTexture?n.depthTexture:null}setSize(t,e){this.width===t&&this.height===e||(this.width=t,this.height=e,this.texture.image.width=t,this.texture.image.height=e,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return(new this.constructor).copy(this)}copy(t){return this.width=t.width,this.height=t.height,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}class zE{constructor(t=0,e=0,n=0,r=1){Object.defineProperty(this,"isQuaternion",{value:!0}),this._x=t,this._y=e,this._z=n,this._w=r}static slerp(t,e,n,r){return n.copy(t).slerp(e,r)}static slerpFlat(t,e,n,r,i,s,o){let a=n[r+0],l=n[r+1],c=n[r+2],u=n[r+3];const h=i[s+0],d=i[s+1],p=i[s+2],f=i[s+3];if(u!==f||a!==h||l!==d||c!==p){let t=1-o;const e=a*h+l*d+c*p+u*f,n=e>=0?1:-1,r=1-e*e;if(r>Number.EPSILON){const i=Math.sqrt(r),s=Math.atan2(i,e*n);t=Math.sin(t*s)/i,o=Math.sin(o*s)/i}const i=o*n;if(a=a*t+h*i,l=l*t+d*i,c=c*t+p*i,u=u*t+f*i,t===1-o){const t=1/Math.sqrt(a*a+l*l+c*c+u*u);a*=t,l*=t,c*=t,u*=t}}t[e]=a,t[e+1]=l,t[e+2]=c,t[e+3]=u}static multiplyQuaternionsFlat(t,e,n,r,i,s){const o=n[r],a=n[r+1],l=n[r+2],c=n[r+3],u=i[s],h=i[s+1],d=i[s+2],p=i[s+3];return t[e]=o*p+c*u+a*d-l*h,t[e+1]=a*p+c*h+l*u-o*d,t[e+2]=l*p+c*d+o*h-a*u,t[e+3]=c*p-o*u-a*h-l*d,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,r){return this._x=t,this._y=e,this._z=n,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!t||!t.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=t._x,r=t._y,i=t._z,s=t._order,o=Math.cos,a=Math.sin,l=o(n/2),c=o(r/2),u=o(i/2),h=a(n/2),d=a(r/2),p=a(i/2);switch(s){case"XYZ":this._x=h*c*u+l*d*p,this._y=l*d*u-h*c*p,this._z=l*c*p+h*d*u,this._w=l*c*u-h*d*p;break;case"YXZ":this._x=h*c*u+l*d*p,this._y=l*d*u-h*c*p,this._z=l*c*p-h*d*u,this._w=l*c*u+h*d*p;break;case"ZXY":this._x=h*c*u-l*d*p,this._y=l*d*u+h*c*p,this._z=l*c*p+h*d*u,this._w=l*c*u-h*d*p;break;case"ZYX":this._x=h*c*u-l*d*p,this._y=l*d*u+h*c*p,this._z=l*c*p-h*d*u,this._w=l*c*u+h*d*p;break;case"YZX":this._x=h*c*u+l*d*p,this._y=l*d*u+h*c*p,this._z=l*c*p-h*d*u,this._w=l*c*u-h*d*p;break;case"XZY":this._x=h*c*u-l*d*p,this._y=l*d*u-h*c*p,this._z=l*c*p+h*d*u,this._w=l*c*u+h*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return!1!==e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,r=Math.sin(n);return this._x=t.x*r,this._y=t.y*r,this._z=t.z*r,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],r=e[4],i=e[8],s=e[1],o=e[5],a=e[9],l=e[2],c=e[6],u=e[10],h=n+o+u;if(h>0){const t=.5/Math.sqrt(h+1);this._w=.25/t,this._x=(c-a)*t,this._y=(i-l)*t,this._z=(s-r)*t}else if(n>o&&n>u){const t=2*Math.sqrt(1+n-o-u);this._w=(c-a)/t,this._x=.25*t,this._y=(r+s)/t,this._z=(i+l)/t}else if(o>u){const t=2*Math.sqrt(1+o-n-u);this._w=(i-l)/t,this._x=(r+s)/t,this._y=.25*t,this._z=(a+c)/t}else{const t=2*Math.sqrt(1+u-n-o);this._w=(s-r)/t,this._x=(i+l)/t,this._y=(a+c)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<1e-6?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(RE.clamp(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(0===n)return this;const r=Math.min(1,e/n);return this.slerp(t,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return void 0!==e?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,r=t._y,i=t._z,s=t._w,o=e._x,a=e._y,l=e._z,c=e._w;return this._x=n*c+s*o+r*l-i*a,this._y=r*c+s*a+i*o-n*l,this._z=i*c+s*l+n*a-r*o,this._w=s*c-n*o-r*a-i*l,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);const n=this._x,r=this._y,i=this._z,s=this._w;let o=s*t._w+n*t._x+r*t._y+i*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=s,this._x=n,this._y=r,this._z=i,this;const a=1-o*o;if(a<=Number.EPSILON){const t=1-e;return this._w=t*s+e*this._w,this._x=t*n+e*this._x,this._y=t*r+e*this._y,this._z=t*i+e*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(a),c=Math.atan2(l,o),u=Math.sin((1-e)*c)/l,h=Math.sin(e*c)/l;return this._w=s*u+this._w*h,this._x=n*u+this._x*h,this._y=r*u+this._y*h,this._z=i*u+this._z*h,this._onChangeCallback(),this}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}class VE{constructor(t=0,e=0,n=0){Object.defineProperty(this,"isVector3",{value:!0}),this.x=t,this.y=e,this.z=n}set(t,e,n){return void 0===n&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(HE.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(HE.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,r=this.z,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6]*r,this.y=i[1]*e+i[4]*n+i[7]*r,this.z=i[2]*e+i[5]*n+i[8]*r,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,r=this.z,i=t.elements,s=1/(i[3]*e+i[7]*n+i[11]*r+i[15]);return this.x=(i[0]*e+i[4]*n+i[8]*r+i[12])*s,this.y=(i[1]*e+i[5]*n+i[9]*r+i[13])*s,this.z=(i[2]*e+i[6]*n+i[10]*r+i[14])*s,this}applyQuaternion(t){const e=this.x,n=this.y,r=this.z,i=t.x,s=t.y,o=t.z,a=t.w,l=a*e+s*r-o*n,c=a*n+o*e-i*r,u=a*r+i*n-s*e,h=-i*e-s*n-o*r;return this.x=l*a+h*-i+c*-o-u*-s,this.y=c*a+h*-s+u*-i-l*-o,this.z=u*a+h*-o+l*-s-c*-i,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,r=this.z,i=t.elements;return this.x=i[0]*e+i[4]*n+i[8]*r,this.y=i[1]*e+i[5]*n+i[9]*r,this.z=i[2]*e+i[6]*n+i[10]*r,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t,e){return void 0!==e?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,r=t.y,i=t.z,s=e.x,o=e.y,a=e.z;return this.x=r*a-i*o,this.y=i*s-n*a,this.z=n*o-r*s,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return UE.copy(this).projectOnVector(t),this.sub(UE)}reflect(t){return this.sub(UE.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(RE.clamp(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,r=this.z-t.z;return e*e+n*n+r*r}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const r=Math.sin(e)*t;return this.x=r*Math.sin(n),this.y=Math.cos(e)*t,this.z=r*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),r=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=r,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}const UE=new VE,HE=new zE;class WE{constructor(t,e){Object.defineProperty(this,"isBox3",{value:!0}),this.min=void 0!==t?t:new VE(1/0,1/0,1/0),this.max=void 0!==e?e:new VE(-1/0,-1/0,-1/0)}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,n=1/0,r=1/0,i=-1/0,s=-1/0,o=-1/0;for(let a=0,l=t.length;a<l;a+=3){const l=t[a],c=t[a+1],u=t[a+2];l<e&&(e=l),c<n&&(n=c),u<r&&(r=u),l>i&&(i=l),c>s&&(s=c),u>o&&(o=u)}return this.min.set(e,n,r),this.max.set(i,s,o),this}setFromBufferAttribute(t){let e=1/0,n=1/0,r=1/0,i=-1/0,s=-1/0,o=-1/0;for(let a=0,l=t.count;a<l;a++){const l=t.getX(a),c=t.getY(a),u=t.getZ(a);l<e&&(e=l),c<n&&(n=c),u<r&&(r=u),l>i&&(i=l),c>s&&(s=c),u>o&&(o=u)}return this.min.set(e,n,r),this.max.set(i,s,o),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=qE.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t){return this.makeEmpty(),this.expandByObject(t)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return void 0===t&&(console.warn("THREE.Box3: .getCenter() target is now required"),t=new VE),this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return void 0===t&&(console.warn("THREE.Box3: .getSize() target is now required"),t=new VE),this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){t.updateWorldMatrix(!1,!1);const e=t.geometry;void 0!==e&&(null===e.boundingBox&&e.computeBoundingBox(),XE.copy(e.boundingBox),XE.applyMatrix4(t.matrixWorld),this.union(XE));const n=t.children;for(let r=0,i=n.length;r<i;r++)this.expandByObject(n[r]);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return void 0===e&&(console.warn("THREE.Box3: .getParameter() target is now required"),e=new VE),e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,qE),qE.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(eC),nC.subVectors(this.max,eC),KE.subVectors(t.a,eC),YE.subVectors(t.b,eC),ZE.subVectors(t.c,eC),JE.subVectors(YE,KE),QE.subVectors(ZE,YE),tC.subVectors(KE,ZE);let e=[0,-JE.z,JE.y,0,-QE.z,QE.y,0,-tC.z,tC.y,JE.z,0,-JE.x,QE.z,0,-QE.x,tC.z,0,-tC.x,-JE.y,JE.x,0,-QE.y,QE.x,0,-tC.y,tC.x,0];return!!jE(e,KE,YE,ZE,nC)&&(e=[1,0,0,0,1,0,0,0,1],!!jE(e,KE,YE,ZE,nC)&&(rC.crossVectors(JE,QE),e=[rC.x,rC.y,rC.z],jE(e,KE,YE,ZE,nC)))}clampPoint(t,e){return void 0===e&&(console.warn("THREE.Box3: .clampPoint() target is now required"),e=new VE),e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return qE.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return void 0===t&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(t.center),t.radius=.5*this.getSize(qE).length(),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(GE[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),GE[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),GE[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),GE[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),GE[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),GE[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),GE[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),GE[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(GE)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}function jE(t,e,n,r,i){for(let s=0,o=t.length-3;s<=o;s+=3){iC.fromArray(t,s);const o=i.x*Math.abs(iC.x)+i.y*Math.abs(iC.y)+i.z*Math.abs(iC.z),a=e.dot(iC),l=n.dot(iC),c=r.dot(iC);if(Math.max(-Math.max(a,l,c),Math.min(a,l,c))>o)return!1}return!0}const GE=[new VE,new VE,new VE,new VE,new VE,new VE,new VE,new VE],qE=new VE,XE=new WE,KE=new VE,YE=new VE,ZE=new VE,JE=new VE,QE=new VE,tC=new VE,eC=new VE,nC=new VE,rC=new VE,iC=new VE,sC=new WE;class oC{constructor(t,e){this.center=void 0!==t?t:new VE,this.radius=void 0!==e?e:-1}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;void 0!==e?n.copy(e):sC.setFromPoints(t).getCenter(n);let r=0;for(let i=0,s=t.length;i<s;i++)r=Math.max(r,n.distanceToSquared(t[i]));return this.radius=Math.sqrt(r),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return void 0===e&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),e=new VE),e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return void 0===t&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),t=new WE),this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}}const aC=new VE,lC=new VE,cC=new VE,uC=new VE,hC=new VE,dC=new VE,pC=new VE;class fC{constructor(t,e){this.origin=void 0!==t?t:new VE,this.direction=void 0!==e?e:new VE(0,0,-1)}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return void 0===e&&(console.warn("THREE.Ray: .at() target is now required"),e=new VE),e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,aC)),this}closestPointToPoint(t,e){void 0===e&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),e=new VE),e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=aC.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(aC.copy(this.direction).multiplyScalar(e).add(this.origin),aC.distanceToSquared(t))}distanceSqToSegment(t,e,n,r){lC.copy(t).add(e).multiplyScalar(.5),cC.copy(e).sub(t).normalize(),uC.copy(this.origin).sub(lC);const i=.5*t.distanceTo(e),s=-this.direction.dot(cC),o=uC.dot(this.direction),a=-uC.dot(cC),l=uC.lengthSq(),c=Math.abs(1-s*s);let u,h,d,p;if(c>0)if(u=s*a-o,h=s*o-a,p=i*c,u>=0)if(h>=-p)if(h<=p){const t=1/c;u*=t,h*=t,d=u*(u+s*h+2*o)+h*(s*u+h+2*a)+l}else h=i,u=Math.max(0,-(s*h+o)),d=-u*u+h*(h+2*a)+l;else h=-i,u=Math.max(0,-(s*h+o)),d=-u*u+h*(h+2*a)+l;else h<=-p?(u=Math.max(0,-(-s*i+o)),h=u>0?-i:Math.min(Math.max(-i,-a),i),d=-u*u+h*(h+2*a)+l):h<=p?(u=0,h=Math.min(Math.max(-i,-a),i),d=h*(h+2*a)+l):(u=Math.max(0,-(s*i+o)),h=u>0?i:Math.min(Math.max(-i,-a),i),d=-u*u+h*(h+2*a)+l);else h=s>0?-i:i,u=Math.max(0,-(s*h+o)),d=-u*u+h*(h+2*a)+l;return n&&n.copy(this.direction).multiplyScalar(u).add(this.origin),r&&r.copy(cC).multiplyScalar(h).add(lC),d}intersectSphere(t,e){aC.subVectors(t.center,this.origin);const n=aC.dot(this.direction),r=aC.dot(aC)-n*n,i=t.radius*t.radius;if(r>i)return null;const s=Math.sqrt(i-r),o=n-s,a=n+s;return o<0&&a<0?null:this.at(o<0?a:o,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(0===e)return 0===t.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return null===n?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return 0===e||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,r,i,s,o,a;const l=1/this.direction.x,c=1/this.direction.y,u=1/this.direction.z,h=this.origin;return l>=0?(n=(t.min.x-h.x)*l,r=(t.max.x-h.x)*l):(n=(t.max.x-h.x)*l,r=(t.min.x-h.x)*l),c>=0?(i=(t.min.y-h.y)*c,s=(t.max.y-h.y)*c):(i=(t.max.y-h.y)*c,s=(t.min.y-h.y)*c),n>s||i>r?null:((i>n||n!=n)&&(n=i),(s<r||r!=r)&&(r=s),u>=0?(o=(t.min.z-h.z)*u,a=(t.max.z-h.z)*u):(o=(t.max.z-h.z)*u,a=(t.min.z-h.z)*u),n>a||o>r?null:((o>n||n!=n)&&(n=o),(a<r||r!=r)&&(r=a),r<0?null:this.at(n>=0?n:r,e)))}intersectsBox(t){return null!==this.intersectBox(t,aC)}intersectTriangle(t,e,n,r,i){hC.subVectors(e,t),dC.subVectors(n,t),pC.crossVectors(hC,dC);let s,o=this.direction.dot(pC);if(o>0){if(r)return null;s=1}else{if(!(o<0))return null;s=-1,o=-o}uC.subVectors(this.origin,t);const a=s*this.direction.dot(dC.crossVectors(uC,dC));if(a<0)return null;const l=s*this.direction.dot(hC.cross(uC));if(l<0)return null;if(a+l>o)return null;const c=-s*uC.dot(pC);return c<0?null:this.at(c/o,i)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}}class mC{constructor(){Object.defineProperty(this,"isMatrix4",{value:!0}),this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,r,i,s,o,a,l,c,u,h,d,p,f,m){const g=this.elements;return g[0]=t,g[4]=e,g[8]=n,g[12]=r,g[1]=i,g[5]=s,g[9]=o,g[13]=a,g[2]=l,g[6]=c,g[10]=u,g[14]=h,g[3]=d,g[7]=p,g[11]=f,g[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new mC).fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,r=1/gC.setFromMatrixColumn(t,0).length(),i=1/gC.setFromMatrixColumn(t,1).length(),s=1/gC.setFromMatrixColumn(t,2).length();return e[0]=n[0]*r,e[1]=n[1]*r,e[2]=n[2]*r,e[3]=0,e[4]=n[4]*i,e[5]=n[5]*i,e[6]=n[6]*i,e[7]=0,e[8]=n[8]*s,e[9]=n[9]*s,e[10]=n[10]*s,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,n=t.x,r=t.y,i=t.z,s=Math.cos(n),o=Math.sin(n),a=Math.cos(r),l=Math.sin(r),c=Math.cos(i),u=Math.sin(i);if("XYZ"===t.order){const t=s*c,n=s*u,r=o*c,i=o*u;e[0]=a*c,e[4]=-a*u,e[8]=l,e[1]=n+r*l,e[5]=t-i*l,e[9]=-o*a,e[2]=i-t*l,e[6]=r+n*l,e[10]=s*a}else if("YXZ"===t.order){const t=a*c,n=a*u,r=l*c,i=l*u;e[0]=t+i*o,e[4]=r*o-n,e[8]=s*l,e[1]=s*u,e[5]=s*c,e[9]=-o,e[2]=n*o-r,e[6]=i+t*o,e[10]=s*a}else if("ZXY"===t.order){const t=a*c,n=a*u,r=l*c,i=l*u;e[0]=t-i*o,e[4]=-s*u,e[8]=r+n*o,e[1]=n+r*o,e[5]=s*c,e[9]=i-t*o,e[2]=-s*l,e[6]=o,e[10]=s*a}else if("ZYX"===t.order){const t=s*c,n=s*u,r=o*c,i=o*u;e[0]=a*c,e[4]=r*l-n,e[8]=t*l+i,e[1]=a*u,e[5]=i*l+t,e[9]=n*l-r,e[2]=-l,e[6]=o*a,e[10]=s*a}else if("YZX"===t.order){const t=s*a,n=s*l,r=o*a,i=o*l;e[0]=a*c,e[4]=i-t*u,e[8]=r*u+n,e[1]=u,e[5]=s*c,e[9]=-o*c,e[2]=-l*c,e[6]=n*u+r,e[10]=t-i*u}else if("XZY"===t.order){const t=s*a,n=s*l,r=o*a,i=o*l;e[0]=a*c,e[4]=-u,e[8]=l*c,e[1]=t*u+i,e[5]=s*c,e[9]=n*u-r,e[2]=r*u-n,e[6]=o*c,e[10]=i*u+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(vC,t,bC)}lookAt(t,e,n){const r=this.elements;return wC.subVectors(t,e),0===wC.lengthSq()&&(wC.z=1),wC.normalize(),_C.crossVectors(n,wC),0===_C.lengthSq()&&(1===Math.abs(n.z)?wC.x+=1e-4:wC.z+=1e-4,wC.normalize(),_C.crossVectors(n,wC)),_C.normalize(),xC.crossVectors(wC,_C),r[0]=_C.x,r[4]=xC.x,r[8]=wC.x,r[1]=_C.y,r[5]=xC.y,r[9]=wC.y,r[2]=_C.z,r[6]=xC.z,r[10]=wC.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,r=e.elements,i=this.elements,s=n[0],o=n[4],a=n[8],l=n[12],c=n[1],u=n[5],h=n[9],d=n[13],p=n[2],f=n[6],m=n[10],g=n[14],y=n[3],v=n[7],b=n[11],_=n[15],x=r[0],w=r[4],S=r[8],E=r[12],C=r[1],T=r[5],A=r[9],M=r[13],k=r[2],R=r[6],I=r[10],N=r[14],O=r[3],D=r[7],L=r[11],F=r[15];return i[0]=s*x+o*C+a*k+l*O,i[4]=s*w+o*T+a*R+l*D,i[8]=s*S+o*A+a*I+l*L,i[12]=s*E+o*M+a*N+l*F,i[1]=c*x+u*C+h*k+d*O,i[5]=c*w+u*T+h*R+d*D,i[9]=c*S+u*A+h*I+d*L,i[13]=c*E+u*M+h*N+d*F,i[2]=p*x+f*C+m*k+g*O,i[6]=p*w+f*T+m*R+g*D,i[10]=p*S+f*A+m*I+g*L,i[14]=p*E+f*M+m*N+g*F,i[3]=y*x+v*C+b*k+_*O,i[7]=y*w+v*T+b*R+_*D,i[11]=y*S+v*A+b*I+_*L,i[15]=y*E+v*M+b*N+_*F,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],r=t[8],i=t[12],s=t[1],o=t[5],a=t[9],l=t[13],c=t[2],u=t[6],h=t[10],d=t[14];return t[3]*(+i*a*u-r*l*u-i*o*h+n*l*h+r*o*d-n*a*d)+t[7]*(+e*a*d-e*l*h+i*s*h-r*s*d+r*l*c-i*a*c)+t[11]*(+e*l*u-e*o*d-i*s*u+n*s*d+i*o*c-n*l*c)+t[15]*(-r*o*c-e*a*u+e*o*h+r*s*u-n*s*h+n*a*c)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const r=this.elements;return t.isVector3?(r[12]=t.x,r[13]=t.y,r[14]=t.z):(r[12]=t,r[13]=e,r[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],r=t[2],i=t[3],s=t[4],o=t[5],a=t[6],l=t[7],c=t[8],u=t[9],h=t[10],d=t[11],p=t[12],f=t[13],m=t[14],g=t[15],y=u*m*l-f*h*l+f*a*d-o*m*d-u*a*g+o*h*g,v=p*h*l-c*m*l-p*a*d+s*m*d+c*a*g-s*h*g,b=c*f*l-p*u*l+p*o*d-s*f*d-c*o*g+s*u*g,_=p*u*a-c*f*a-p*o*h+s*f*h+c*o*m-s*u*m,x=e*y+n*v+r*b+i*_;if(0===x)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const w=1/x;return t[0]=y*w,t[1]=(f*h*i-u*m*i-f*r*d+n*m*d+u*r*g-n*h*g)*w,t[2]=(o*m*i-f*a*i+f*r*l-n*m*l-o*r*g+n*a*g)*w,t[3]=(u*a*i-o*h*i-u*r*l+n*h*l+o*r*d-n*a*d)*w,t[4]=v*w,t[5]=(c*m*i-p*h*i+p*r*d-e*m*d-c*r*g+e*h*g)*w,t[6]=(p*a*i-s*m*i-p*r*l+e*m*l+s*r*g-e*a*g)*w,t[7]=(s*h*i-c*a*i+c*r*l-e*h*l-s*r*d+e*a*d)*w,t[8]=b*w,t[9]=(p*u*i-c*f*i-p*n*d+e*f*d+c*n*g-e*u*g)*w,t[10]=(s*f*i-p*o*i+p*n*l-e*f*l-s*n*g+e*o*g)*w,t[11]=(c*o*i-s*u*i-c*n*l+e*u*l+s*n*d-e*o*d)*w,t[12]=_*w,t[13]=(c*f*r-p*u*r+p*n*h-e*f*h-c*n*m+e*u*m)*w,t[14]=(p*o*r-s*f*r-p*n*a+e*f*a+s*n*m-e*o*m)*w,t[15]=(s*u*r-c*o*r+c*n*a-e*u*a-s*n*h+e*o*h)*w,this}scale(t){const e=this.elements,n=t.x,r=t.y,i=t.z;return e[0]*=n,e[4]*=r,e[8]*=i,e[1]*=n,e[5]*=r,e[9]*=i,e[2]*=n,e[6]*=r,e[10]*=i,e[3]*=n,e[7]*=r,e[11]*=i,this}getMaxScaleOnAxis(){const t=this.elements;return Math.sqrt(Math.max(t[0]*t[0]+t[1]*t[1]+t[2]*t[2],t[4]*t[4]+t[5]*t[5]+t[6]*t[6],t[8]*t[8]+t[9]*t[9]+t[10]*t[10]))}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),r=Math.sin(e),i=1-n,s=t.x,o=t.y,a=t.z,l=i*s,c=i*o;return this.set(l*s+n,l*o-r*a,l*a+r*o,0,l*o+r*a,c*o+n,c*a-r*s,0,l*a-r*o,c*a+r*s,i*a*a+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n){return this.set(1,e,n,0,t,1,n,0,t,e,1,0,0,0,0,1),this}compose(t,e,n){const r=this.elements,i=e._x,s=e._y,o=e._z,a=e._w,l=i+i,c=s+s,u=o+o,h=i*l,d=i*c,p=i*u,f=s*c,m=s*u,g=o*u,y=a*l,v=a*c,b=a*u,_=n.x,x=n.y,w=n.z;return r[0]=(1-(f+g))*_,r[1]=(d+b)*_,r[2]=(p-v)*_,r[3]=0,r[4]=(d-b)*x,r[5]=(1-(h+g))*x,r[6]=(m+y)*x,r[7]=0,r[8]=(p+v)*w,r[9]=(m-y)*w,r[10]=(1-(h+f))*w,r[11]=0,r[12]=t.x,r[13]=t.y,r[14]=t.z,r[15]=1,this}decompose(t,e,n){const r=this.elements;let i=gC.set(r[0],r[1],r[2]).length();const s=gC.set(r[4],r[5],r[6]).length(),o=gC.set(r[8],r[9],r[10]).length();this.determinant()<0&&(i=-i),t.x=r[12],t.y=r[13],t.z=r[14],yC.copy(this);const a=1/i,l=1/s,c=1/o;return yC.elements[0]*=a,yC.elements[1]*=a,yC.elements[2]*=a,yC.elements[4]*=l,yC.elements[5]*=l,yC.elements[6]*=l,yC.elements[8]*=c,yC.elements[9]*=c,yC.elements[10]*=c,e.setFromRotationMatrix(yC),n.x=i,n.y=s,n.z=o,this}makePerspective(t,e,n,r,i,s){void 0===s&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const o=this.elements,a=2*i/(n-r),l=(e+t)/(e-t),c=(n+r)/(n-r),u=-(s+i)/(s-i),h=-2*s*i/(s-i);return o[0]=2*i/(e-t),o[4]=0,o[8]=l,o[12]=0,o[1]=0,o[5]=a,o[9]=c,o[13]=0,o[2]=0,o[6]=0,o[10]=u,o[14]=h,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(t,e,n,r,i,s){const o=this.elements,a=1/(e-t),l=1/(n-r),c=1/(s-i),u=(e+t)*a,h=(n+r)*l,d=(s+i)*c;return o[0]=2*a,o[4]=0,o[8]=0,o[12]=-u,o[1]=0,o[5]=2*l,o[9]=0,o[13]=-h,o[2]=0,o[6]=0,o[10]=-2*c,o[14]=-d,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let r=0;r<16;r++)if(e[r]!==n[r])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}const gC=new VE,yC=new mC,vC=new VE(0,0,0),bC=new VE(1,1,1),_C=new VE,xC=new VE,wC=new VE;class SC{constructor(t=0,e=0,n=0,r=SC.DefaultOrder){Object.defineProperty(this,"isEuler",{value:!0}),this._x=t,this._y=e,this._z=n,this._order=r}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,r){return this._x=t,this._y=e,this._z=n,this._order=r||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e,n){const r=RE.clamp,i=t.elements,s=i[0],o=i[4],a=i[8],l=i[1],c=i[5],u=i[9],h=i[2],d=i[6],p=i[10];switch(e=e||this._order){case"XYZ":this._y=Math.asin(r(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-u,p),this._z=Math.atan2(-o,s)):(this._x=Math.atan2(d,c),this._z=0);break;case"YXZ":this._x=Math.asin(-r(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(a,p),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-h,s),this._z=0);break;case"ZXY":this._x=Math.asin(r(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-h,p),this._z=Math.atan2(-o,c)):(this._y=0,this._z=Math.atan2(l,s));break;case"ZYX":this._y=Math.asin(-r(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(l,s)):(this._x=0,this._z=Math.atan2(-o,c));break;case"YZX":this._z=Math.asin(r(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,c),this._y=Math.atan2(-h,s)):(this._x=0,this._y=Math.atan2(a,p));break;case"XZY":this._z=Math.asin(-r(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(d,c),this._y=Math.atan2(a,s)):(this._x=Math.atan2(-u,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!1!==n&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return EC.makeRotationFromQuaternion(t),this.setFromRotationMatrix(EC,e,n)}setFromVector3(t,e){return this.set(t.x,t.y,t.z,e||this._order)}reorder(t){return CC.setFromEuler(this),this.setFromQuaternion(CC,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new VE(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}SC.DefaultOrder="XYZ",SC.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];const EC=new mC,CC=new zE;class TC{constructor(){this.mask=1}set(t){this.mask=1<<t|0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return 0!=(this.mask&t.mask)}}let AC=0;const MC=new VE,kC=new zE,RC=new mC,IC=new VE,NC=new VE,OC=new VE,DC=new zE,LC=new VE(1,0,0),FC=new VE(0,1,0),PC=new VE(0,0,1),$C={type:"added"},BC={type:"removed"};function zC(){Object.defineProperty(this,"id",{value:AC++}),this.uuid=RE.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=zC.DefaultUp.clone();const t=new VE,e=new SC,n=new zE,r=new VE(1,1,1);e._onChange(function(){n.setFromEuler(e,!1)}),n._onChange(function(){e.setFromQuaternion(n,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new mC},normalMatrix:{value:new NE}}),this.matrix=new mC,this.matrixWorld=new mC,this.matrixAutoUpdate=zC.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new TC,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}zC.DefaultUp=new VE(0,1,0),zC.DefaultMatrixAutoUpdate=!0,zC.prototype=Object.assign(Object.create(AE.prototype),{constructor:zC,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix4:function(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(t){return this.quaternion.premultiply(t),this},setRotationFromAxisAngle:function(t,e){this.quaternion.setFromAxisAngle(t,e)},setRotationFromEuler:function(t){this.quaternion.setFromEuler(t,!0)},setRotationFromMatrix:function(t){this.quaternion.setFromRotationMatrix(t)},setRotationFromQuaternion:function(t){this.quaternion.copy(t)},rotateOnAxis:function(t,e){return kC.setFromAxisAngle(t,e),this.quaternion.multiply(kC),this},rotateOnWorldAxis:function(t,e){return kC.setFromAxisAngle(t,e),this.quaternion.premultiply(kC),this},rotateX:function(t){return this.rotateOnAxis(LC,t)},rotateY:function(t){return this.rotateOnAxis(FC,t)},rotateZ:function(t){return this.rotateOnAxis(PC,t)},translateOnAxis:function(t,e){return MC.copy(t).applyQuaternion(this.quaternion),this.position.add(MC.multiplyScalar(e)),this},translateX:function(t){return this.translateOnAxis(LC,t)},translateY:function(t){return this.translateOnAxis(FC,t)},translateZ:function(t){return this.translateOnAxis(PC,t)},localToWorld:function(t){return t.applyMatrix4(this.matrixWorld)},worldToLocal:function(t){return t.applyMatrix4(RC.copy(this.matrixWorld).invert())},lookAt:function(t,e,n){t.isVector3?IC.copy(t):IC.set(t,e,n);const r=this.parent;this.updateWorldMatrix(!0,!1),NC.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?RC.lookAt(NC,IC,this.up):RC.lookAt(IC,NC,this.up),this.quaternion.setFromRotationMatrix(RC),r&&(RC.extractRotation(r.matrixWorld),kC.setFromRotationMatrix(RC),this.quaternion.premultiply(kC.invert()))},add:function(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(null!==t.parent&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent($C)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)},remove:function(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(t);return-1!==e&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(BC)),this},clear:function(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(BC)}return this.children.length=0,this},attach:function(t){return this.updateWorldMatrix(!0,!1),RC.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),RC.multiply(t.parent.matrixWorld)),t.applyMatrix4(RC),t.updateWorldMatrix(!1,!1),this.add(t),this},getObjectById:function(t){return this.getObjectByProperty("id",t)},getObjectByName:function(t){return this.getObjectByProperty("name",t)},getObjectByProperty:function(t,e){if(this[t]===e)return this;for(let n=0,r=this.children.length;n<r;n++){const r=this.children[n].getObjectByProperty(t,e);if(void 0!==r)return r}},getWorldPosition:function(t){return void 0===t&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),t=new VE),this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(t){return void 0===t&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),t=new zE),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(NC,t,OC),t},getWorldScale:function(t){return void 0===t&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),t=new VE),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(NC,DC,t),t},getWorldDirection:function(t){void 0===t&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),t=new VE),this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()},raycast:function(){},traverse:function(t){t(this);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].traverse(t)},traverseVisible:function(t){if(!1===this.visible)return;t(this);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].traverseVisible(t)},traverseAncestors:function(t){const e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].updateMatrixWorld(t)},updateWorldMatrix:function(t,e){const n=this.parent;if(!0===t&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===e){const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].updateWorldMatrix(!1,!0)}},toJSON:function(t){const e=void 0===t||"string"==typeof t,n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const r={};function i(e,n){return void 0===e[n.uuid]&&(e[n.uuid]=n.toJSON(t)),n.uuid}if(r.uuid=this.uuid,r.type=this.type,""!==this.name&&(r.name=this.name),!0===this.castShadow&&(r.castShadow=!0),!0===this.receiveShadow&&(r.receiveShadow=!0),!1===this.visible&&(r.visible=!1),!1===this.frustumCulled&&(r.frustumCulled=!1),0!==this.renderOrder&&(r.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON()),this.isMesh||this.isLine||this.isPoints){r.geometry=i(t.geometries,this.geometry);const e=this.geometry.parameters;if(void 0!==e&&void 0!==e.shapes){const n=e.shapes;if(Array.isArray(n))for(let e=0,r=n.length;e<r;e++)i(t.shapes,n[e]);else i(t.shapes,n)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(i(t.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const e=[];for(let n=0,r=this.material.length;n<r;n++)e.push(i(t.materials,this.material[n]));r.material=e}else r.material=i(t.materials,this.material);if(this.children.length>0){r.children=[];for(let e=0;e<this.children.length;e++)r.children.push(this.children[e].toJSON(t).object)}if(this.animations.length>0){r.animations=[];for(let e=0;e<this.animations.length;e++)r.animations.push(i(t.animations,this.animations[e]))}if(e){const e=s(t.geometries),r=s(t.materials),i=s(t.textures),o=s(t.images),a=s(t.shapes),l=s(t.skeletons),c=s(t.animations);e.length>0&&(n.geometries=e),r.length>0&&(n.materials=r),i.length>0&&(n.textures=i),o.length>0&&(n.images=o),a.length>0&&(n.shapes=a),l.length>0&&(n.skeletons=l),c.length>0&&(n.animations=c)}return n.object=r,n;function s(t){const e=[];for(const n in t){const r=t[n];delete r.metadata,e.push(r)}return e}},clone:function(t){return(new this.constructor).copy(this,t)},copy:function(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(let n=0;n<t.children.length;n++)this.add(t.children[n].clone());return this}});const VC=new VE,UC=new VE,HC=new NE;class WC{constructor(t,e){Object.defineProperty(this,"isPlane",{value:!0}),this.normal=void 0!==t?t:new VE(1,0,0),this.constant=void 0!==e?e:0}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,r){return this.normal.set(t,e,n),this.constant=r,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const r=VC.subVectors(n,e).cross(UC.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(r,t),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return void 0===e&&(console.warn("THREE.Plane: .projectPoint() target is now required"),e=new VE),e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){void 0===e&&(console.warn("THREE.Plane: .intersectLine() target is now required"),e=new VE);const n=t.delta(VC),r=this.normal.dot(n);if(0===r)return 0===this.distanceToPoint(t.start)?e.copy(t.start):void 0;const i=-(t.start.dot(this.normal)+this.constant)/r;return i<0||i>1?void 0:e.copy(n).multiplyScalar(i).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return void 0===t&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),t=new VE),t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||HC.getNormalMatrix(t),r=this.coplanarPoint(VC).applyMatrix4(t),i=this.normal.applyMatrix3(n).normalize();return this.constant=-r.dot(i),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}}const jC=new VE,GC=new VE,qC=new VE,XC=new VE,KC=new VE,YC=new VE,ZC=new VE,JC=new VE,QC=new VE,tT=new VE;class eT{constructor(t,e,n){this.a=void 0!==t?t:new VE,this.b=void 0!==e?e:new VE,this.c=void 0!==n?n:new VE}static getNormal(t,e,n,r){void 0===r&&(console.warn("THREE.Triangle: .getNormal() target is now required"),r=new VE),r.subVectors(n,e),jC.subVectors(t,e),r.cross(jC);const i=r.lengthSq();return i>0?r.multiplyScalar(1/Math.sqrt(i)):r.set(0,0,0)}static getBarycoord(t,e,n,r,i){jC.subVectors(r,e),GC.subVectors(n,e),qC.subVectors(t,e);const s=jC.dot(jC),o=jC.dot(GC),a=jC.dot(qC),l=GC.dot(GC),c=GC.dot(qC),u=s*l-o*o;if(void 0===i&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),i=new VE),0===u)return i.set(-2,-1,-1);const h=1/u,d=(l*a-o*c)*h,p=(s*c-o*a)*h;return i.set(1-d-p,p,d)}static containsPoint(t,e,n,r){return this.getBarycoord(t,e,n,r,XC),XC.x>=0&&XC.y>=0&&XC.x+XC.y<=1}static getUV(t,e,n,r,i,s,o,a){return this.getBarycoord(t,e,n,r,XC),a.set(0,0),a.addScaledVector(i,XC.x),a.addScaledVector(s,XC.y),a.addScaledVector(o,XC.z),a}static isFrontFacing(t,e,n,r){return jC.subVectors(n,e),GC.subVectors(t,e),jC.cross(GC).dot(r)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,r){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[r]),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return jC.subVectors(this.c,this.b),GC.subVectors(this.a,this.b),.5*jC.cross(GC).length()}getMidpoint(t){return void 0===t&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),t=new VE),t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return eT.getNormal(this.a,this.b,this.c,t)}getPlane(t){return void 0===t&&(console.warn("THREE.Triangle: .getPlane() target is now required"),t=new WC),t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return eT.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,r,i){return eT.getUV(t,this.a,this.b,this.c,e,n,r,i)}containsPoint(t){return eT.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return eT.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){void 0===e&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),e=new VE);const n=this.a,r=this.b,i=this.c;let s,o;KC.subVectors(r,n),YC.subVectors(i,n),JC.subVectors(t,n);const a=KC.dot(JC),l=YC.dot(JC);if(a<=0&&l<=0)return e.copy(n);QC.subVectors(t,r);const c=KC.dot(QC),u=YC.dot(QC);if(c>=0&&u<=c)return e.copy(r);const h=a*u-c*l;if(h<=0&&a>=0&&c<=0)return s=a/(a-c),e.copy(n).addScaledVector(KC,s);tT.subVectors(t,i);const d=KC.dot(tT),p=YC.dot(tT);if(p>=0&&d<=p)return e.copy(i);const f=d*l-a*p;if(f<=0&&l>=0&&p<=0)return o=l/(l-p),e.copy(n).addScaledVector(YC,o);const m=c*p-d*u;if(m<=0&&u-c>=0&&d-p>=0)return ZC.subVectors(i,r),o=(u-c)/(u-c+(d-p)),e.copy(r).addScaledVector(ZC,o);const g=1/(m+f+h);return s=f*g,o=h*g,e.copy(n).addScaledVector(KC,s).addScaledVector(YC,o)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const nT={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},rT={h:0,s:0,l:0},iT={h:0,s:0,l:0};function sT(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+6*(e-t)*n:n<.5?e:n<2/3?t+6*(e-t)*(2/3-n):t}function oT(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function aT(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}class lT{constructor(t,e,n){return Object.defineProperty(this,"isColor",{value:!0}),void 0===e&&void 0===n?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):"number"==typeof t?this.setHex(t):"string"==typeof t&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,this}setRGB(t,e,n){return this.r=t,this.g=e,this.b=n,this}setHSL(t,e,n){if(t=RE.euclideanModulo(t,1),e=RE.clamp(e,0,1),n=RE.clamp(n,0,1),0===e)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+e):n+e-n*e,i=2*n-r;this.r=sT(i,r,t+1/3),this.g=sT(i,r,t),this.b=sT(i,r,t-1/3)}return this}setStyle(t){function e(e){void 0!==e&&parseFloat(e)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let t;const r=n[2];switch(n[1]){case"rgb":case"rgba":if(t=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return this.r=Math.min(255,parseInt(t[1],10))/255,this.g=Math.min(255,parseInt(t[2],10))/255,this.b=Math.min(255,parseInt(t[3],10))/255,e(t[4]),this;if(t=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return this.r=Math.min(100,parseInt(t[1],10))/100,this.g=Math.min(100,parseInt(t[2],10))/100,this.b=Math.min(100,parseInt(t[3],10))/100,e(t[4]),this;break;case"hsl":case"hsla":if(t=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)){const n=parseFloat(t[1])/360,r=parseInt(t[2],10)/100,i=parseInt(t[3],10)/100;return e(t[4]),this.setHSL(n,r,i)}}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const t=n[1],e=t.length;if(3===e)return this.r=parseInt(t.charAt(0)+t.charAt(0),16)/255,this.g=parseInt(t.charAt(1)+t.charAt(1),16)/255,this.b=parseInt(t.charAt(2)+t.charAt(2),16)/255,this;if(6===e)return this.r=parseInt(t.charAt(0)+t.charAt(1),16)/255,this.g=parseInt(t.charAt(2)+t.charAt(3),16)/255,this.b=parseInt(t.charAt(4)+t.charAt(5),16)/255,this}return t&&t.length>0?this.setColorName(t):this}setColorName(t){const e=nT[t];return void 0!==e?this.setHex(e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copyGammaToLinear(t,e=2){return this.r=Math.pow(t.r,e),this.g=Math.pow(t.g,e),this.b=Math.pow(t.b,e),this}copyLinearToGamma(t,e=2){const n=e>0?1/e:1;return this.r=Math.pow(t.r,n),this.g=Math.pow(t.g,n),this.b=Math.pow(t.b,n),this}convertGammaToLinear(t){return this.copyGammaToLinear(this,t),this}convertLinearToGamma(t){return this.copyLinearToGamma(this,t),this}copySRGBToLinear(t){return this.r=oT(t.r),this.g=oT(t.g),this.b=oT(t.b),this}copyLinearToSRGB(t){return this.r=aT(t.r),this.g=aT(t.g),this.b=aT(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(t){void 0===t&&(console.warn("THREE.Color: .getHSL() target is now required"),t={h:0,s:0,l:0});const e=this.r,n=this.g,r=this.b,i=Math.max(e,n,r),s=Math.min(e,n,r);let o,a;const l=(s+i)/2;if(s===i)o=0,a=0;else{const t=i-s;switch(a=l<=.5?t/(i+s):t/(2-i-s),i){case e:o=(n-r)/t+(n<r?6:0);break;case n:o=(r-e)/t+2;break;case r:o=(e-n)/t+4}o/=6}return t.h=o,t.s=a,t.l=l,t}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(t,e,n){return this.getHSL(rT),rT.h+=t,rT.s+=e,rT.l+=n,this.setHSL(rT.h,rT.s,rT.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(rT),t.getHSL(iT);const n=RE.lerp(rT.h,iT.h,e),r=RE.lerp(rT.s,iT.s,e),i=RE.lerp(rT.l,iT.l,e);return this.setHSL(n,r,i),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),!0===t.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}lT.NAMES=nT,lT.prototype.r=1,lT.prototype.g=1,lT.prototype.b=1;class cT{constructor(t,e,n,r,i,s=0){this.a=t,this.b=e,this.c=n,this.normal=r&&r.isVector3?r:new VE,this.vertexNormals=Array.isArray(r)?r:[],this.color=i&&i.isColor?i:new lT,this.vertexColors=Array.isArray(i)?i:[],this.materialIndex=s}clone(){return(new this.constructor).copy(this)}copy(t){this.a=t.a,this.b=t.b,this.c=t.c,this.normal.copy(t.normal),this.color.copy(t.color),this.materialIndex=t.materialIndex;for(let e=0,n=t.vertexNormals.length;e<n;e++)this.vertexNormals[e]=t.vertexNormals[e].clone();for(let e=0,n=t.vertexColors.length;e<n;e++)this.vertexColors[e]=t.vertexColors[e].clone();return this}}let uT=0;function hT(){Object.defineProperty(this,"id",{value:uT++}),this.uuid=RE.generateUUID(),this.name="",this.type="Material",this.fog=!0,this.blending=1,this.side=0,this.flatShading=!1,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=tE,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=SE,this.stencilZFail=SE,this.stencilZPass=SE,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}function dT(t){hT.call(this),this.type="MeshBasicMaterial",this.color=new lT(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(t)}hT.prototype=Object.assign(Object.create(AE.prototype),{constructor:hT,isMaterial:!0,onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(t){if(void 0!==t)for(const e in t){const n=t[e];if(void 0===n){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if("shading"===e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===n;continue}const r=this[e];void 0!==r?r&&r.isColor?r.set(n):r&&r.isVector3&&n&&n.isVector3?r.copy(n):this[e]=n:console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.")}},toJSON:function(t){const e=void 0===t||"string"==typeof t;e&&(t={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function r(t){const e=[];for(const n in t){const r=t[n];delete r.metadata,e.push(r)}return e}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(n.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,n.reflectivity=this.reflectivity,n.refractionRatio=this.refractionRatio,void 0!==this.combine&&(n.combine=this.combine),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity)),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),void 0!==this.size&&(n.size=this.size),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(n.blending=this.blending),!0===this.flatShading&&(n.flatShading=this.flatShading),0!==this.side&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),!0===this.transparent&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.morphTargets&&(n.morphTargets=!0),!0===this.morphNormals&&(n.morphNormals=!0),!0===this.skinning&&(n.skinning=!0),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),e){const e=r(t.textures),i=r(t.images);e.length>0&&(n.textures=e),i.length>0&&(n.images=i)}return n},clone:function(){return(new this.constructor).copy(this)},copy:function(t){this.name=t.name,this.fog=t.fog,this.blending=t.blending,this.side=t.side,this.flatShading=t.flatShading,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(null!==e){const t=e.length;n=new Array(t);for(let r=0;r!==t;++r)n[r]=e[r].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),Object.defineProperty(hT.prototype,"needsUpdate",{set:function(t){!0===t&&this.version++}}),(dT.prototype=Object.create(hT.prototype)).constructor=dT,dT.prototype.isMeshBasicMaterial=!0,dT.prototype.copy=function(t){return hT.prototype.copy.call(this,t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this};const pT=new VE,fT=new IE;function mT(t,e,n){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=!0===n,this.usage=EE,this.updateRange={offset:0,count:-1},this.version=0}function gT(t,e,n){mT.call(this,new Int8Array(t),e,n)}function yT(t,e,n){mT.call(this,new Uint8Array(t),e,n)}function vT(t,e,n){mT.call(this,new Uint8ClampedArray(t),e,n)}function bT(t,e,n){mT.call(this,new Int16Array(t),e,n)}function _T(t,e,n){mT.call(this,new Uint16Array(t),e,n)}function xT(t,e,n){mT.call(this,new Int32Array(t),e,n)}function wT(t,e,n){mT.call(this,new Uint32Array(t),e,n)}function ST(t,e,n){mT.call(this,new Uint16Array(t),e,n)}function ET(t,e,n){mT.call(this,new Float32Array(t),e,n)}function CT(t,e,n){mT.call(this,new Float64Array(t),e,n)}function TT(t){if(0===t.length)return-1/0;let e=t[0];for(let n=1,r=t.length;n<r;++n)t[n]>e&&(e=t[n]);return e}Object.defineProperty(mT.prototype,"needsUpdate",{set:function(t){!0===t&&this.version++}}),Object.assign(mT.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setUsage:function(t){return this.usage=t,this},copy:function(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this},copyAt:function(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let r=0,i=this.itemSize;r<i;r++)this.array[t+r]=e.array[n+r];return this},copyArray:function(t){return this.array.set(t),this},copyColorsArray:function(t){const e=this.array;let n=0;for(let r=0,i=t.length;r<i;r++){let i=t[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),i=new lT),e[n++]=i.r,e[n++]=i.g,e[n++]=i.b}return this},copyVector2sArray:function(t){const e=this.array;let n=0;for(let r=0,i=t.length;r<i;r++){let i=t[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),i=new IE),e[n++]=i.x,e[n++]=i.y}return this},copyVector3sArray:function(t){const e=this.array;let n=0;for(let r=0,i=t.length;r<i;r++){let i=t[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),i=new VE),e[n++]=i.x,e[n++]=i.y,e[n++]=i.z}return this},copyVector4sArray:function(t){const e=this.array;let n=0;for(let r=0,i=t.length;r<i;r++){let i=t[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),i=new $E),e[n++]=i.x,e[n++]=i.y,e[n++]=i.z,e[n++]=i.w}return this},applyMatrix3:function(t){if(2===this.itemSize)for(let e=0,n=this.count;e<n;e++)fT.fromBufferAttribute(this,e),fT.applyMatrix3(t),this.setXY(e,fT.x,fT.y);else if(3===this.itemSize)for(let e=0,n=this.count;e<n;e++)pT.fromBufferAttribute(this,e),pT.applyMatrix3(t),this.setXYZ(e,pT.x,pT.y,pT.z);return this},applyMatrix4:function(t){for(let e=0,n=this.count;e<n;e++)pT.x=this.getX(e),pT.y=this.getY(e),pT.z=this.getZ(e),pT.applyMatrix4(t),this.setXYZ(e,pT.x,pT.y,pT.z);return this},applyNormalMatrix:function(t){for(let e=0,n=this.count;e<n;e++)pT.x=this.getX(e),pT.y=this.getY(e),pT.z=this.getZ(e),pT.applyNormalMatrix(t),this.setXYZ(e,pT.x,pT.y,pT.z);return this},transformDirection:function(t){for(let e=0,n=this.count;e<n;e++)pT.x=this.getX(e),pT.y=this.getY(e),pT.z=this.getZ(e),pT.transformDirection(t),this.setXYZ(e,pT.x,pT.y,pT.z);return this},set:function(t,e=0){return this.array.set(t,e),this},getX:function(t){return this.array[t*this.itemSize]},setX:function(t,e){return this.array[t*this.itemSize]=e,this},getY:function(t){return this.array[t*this.itemSize+1]},setY:function(t,e){return this.array[t*this.itemSize+1]=e,this},getZ:function(t){return this.array[t*this.itemSize+2]},setZ:function(t,e){return this.array[t*this.itemSize+2]=e,this},getW:function(t){return this.array[t*this.itemSize+3]},setW:function(t,e){return this.array[t*this.itemSize+3]=e,this},setXY:function(t,e,n){return this.array[0+(t*=this.itemSize)]=e,this.array[t+1]=n,this},setXYZ:function(t,e,n,r){return this.array[0+(t*=this.itemSize)]=e,this.array[t+1]=n,this.array[t+2]=r,this},setXYZW:function(t,e,n,r,i){return this.array[0+(t*=this.itemSize)]=e,this.array[t+1]=n,this.array[t+2]=r,this.array[t+3]=i,this},onUpload:function(t){return this.onUploadCallback=t,this},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this)},toJSON:function(){return{itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized}}}),(gT.prototype=Object.create(mT.prototype)).constructor=gT,(yT.prototype=Object.create(mT.prototype)).constructor=yT,(vT.prototype=Object.create(mT.prototype)).constructor=vT,(bT.prototype=Object.create(mT.prototype)).constructor=bT,(_T.prototype=Object.create(mT.prototype)).constructor=_T,(xT.prototype=Object.create(mT.prototype)).constructor=xT,(wT.prototype=Object.create(mT.prototype)).constructor=wT,(ST.prototype=Object.create(mT.prototype)).constructor=ST,ST.prototype.isFloat16BufferAttribute=!0,(ET.prototype=Object.create(mT.prototype)).constructor=ET,(CT.prototype=Object.create(mT.prototype)).constructor=CT;const AT={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:"undefined"!=typeof Uint8ClampedArray?Uint8ClampedArray:Uint8Array,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};function MT(t,e){return new AT[t](e)}let kT=0;const RT=new mC,IT=new zC,NT=new VE,OT=new WE,DT=new WE,LT=new VE;function FT(){Object.defineProperty(this,"id",{value:kT++}),this.uuid=RE.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}FT.prototype=Object.assign(Object.create(AE.prototype),{constructor:FT,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(t){return this.index=Array.isArray(t)?new(TT(t)>65535?wT:_T)(t,1):t,this},getAttribute:function(t){return this.attributes[t]},setAttribute:function(t,e){return this.attributes[t]=e,this},deleteAttribute:function(t){return delete this.attributes[t],this},hasAttribute:function(t){return void 0!==this.attributes[t]},addGroup:function(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})},clearGroups:function(){this.groups=[]},setDrawRange:function(t,e){this.drawRange.start=t,this.drawRange.count=e},applyMatrix4:function(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const e=(new NE).getNormalMatrix(t);n.applyNormalMatrix(e),n.needsUpdate=!0}const r=this.attributes.tangent;return void 0!==r&&(r.transformDirection(t),r.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},rotateX:function(t){return RT.makeRotationX(t),this.applyMatrix4(RT),this},rotateY:function(t){return RT.makeRotationY(t),this.applyMatrix4(RT),this},rotateZ:function(t){return RT.makeRotationZ(t),this.applyMatrix4(RT),this},translate:function(t,e,n){return RT.makeTranslation(t,e,n),this.applyMatrix4(RT),this},scale:function(t,e,n){return RT.makeScale(t,e,n),this.applyMatrix4(RT),this},lookAt:function(t){return IT.lookAt(t),IT.updateMatrix(),this.applyMatrix4(IT.matrix),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(NT).negate(),this.translate(NT.x,NT.y,NT.z),this},setFromPoints:function(t){const e=[];for(let n=0,r=t.length;n<r;n++){const r=t[n];e.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new ET(e,3)),this},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new WE);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new VE(-1/0,-1/0,-1/0),new VE(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let n=0,r=e.length;n<r;n++)OT.setFromBufferAttribute(e[n]),this.morphTargetsRelative?(LT.addVectors(this.boundingBox.min,OT.min),this.boundingBox.expandByPoint(LT),LT.addVectors(this.boundingBox.max,OT.max),this.boundingBox.expandByPoint(LT)):(this.boundingBox.expandByPoint(OT.min),this.boundingBox.expandByPoint(OT.max))}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new oC);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new VE,1/0);if(t){const n=this.boundingSphere.center;if(OT.setFromBufferAttribute(t),e)for(let t=0,i=e.length;t<i;t++)DT.setFromBufferAttribute(e[t]),this.morphTargetsRelative?(LT.addVectors(OT.min,DT.min),OT.expandByPoint(LT),LT.addVectors(OT.max,DT.max),OT.expandByPoint(LT)):(OT.expandByPoint(DT.min),OT.expandByPoint(DT.max));OT.getCenter(n);let r=0;for(let e=0,i=t.count;e<i;e++)LT.fromBufferAttribute(t,e),r=Math.max(r,n.distanceToSquared(LT));if(e)for(let i=0,s=e.length;i<s;i++){const s=e[i],o=this.morphTargetsRelative;for(let e=0,i=s.count;e<i;e++)LT.fromBufferAttribute(s,e),o&&(NT.fromBufferAttribute(t,e),LT.add(NT)),r=Math.max(r,n.distanceToSquared(LT))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}},computeFaceNormals:function(){},computeTangents:function(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=t.array,r=e.position.array,i=e.normal.array,s=e.uv.array,o=r.length/3;void 0===e.tangent&&this.setAttribute("tangent",new mT(new Float32Array(4*o),4));const a=e.tangent.array,l=[],c=[];for(let C=0;C<o;C++)l[C]=new VE,c[C]=new VE;const u=new VE,h=new VE,d=new VE,p=new IE,f=new IE,m=new IE,g=new VE,y=new VE;function v(t,e,n){u.fromArray(r,3*t),h.fromArray(r,3*e),d.fromArray(r,3*n),p.fromArray(s,2*t),f.fromArray(s,2*e),m.fromArray(s,2*n),h.sub(u),d.sub(u),f.sub(p),m.sub(p);const i=1/(f.x*m.y-m.x*f.y);isFinite(i)&&(g.copy(h).multiplyScalar(m.y).addScaledVector(d,-f.y).multiplyScalar(i),y.copy(d).multiplyScalar(f.x).addScaledVector(h,-m.x).multiplyScalar(i),l[t].add(g),l[e].add(g),l[n].add(g),c[t].add(y),c[e].add(y),c[n].add(y))}let b=this.groups;0===b.length&&(b=[{start:0,count:n.length}]);for(let C=0,T=b.length;C<T;++C){const t=b[C],e=t.start;for(let r=e,i=e+t.count;r<i;r+=3)v(n[r+0],n[r+1],n[r+2])}const _=new VE,x=new VE,w=new VE,S=new VE;function E(t){w.fromArray(i,3*t),S.copy(w);const e=l[t];_.copy(e),_.sub(w.multiplyScalar(w.dot(e))).normalize(),x.crossVectors(S,e);const n=x.dot(c[t])<0?-1:1;a[4*t]=_.x,a[4*t+1]=_.y,a[4*t+2]=_.z,a[4*t+3]=n}for(let C=0,T=b.length;C<T;++C){const t=b[C],e=t.start;for(let r=e,i=e+t.count;r<i;r+=3)E(n[r+0]),E(n[r+1]),E(n[r+2])}},computeVertexNormals:function(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let n=this.getAttribute("normal");if(void 0===n)n=new mT(new Float32Array(3*e.count),3),this.setAttribute("normal",n);else for(let t=0,e=n.count;t<e;t++)n.setXYZ(t,0,0,0);const r=new VE,i=new VE,s=new VE,o=new VE,a=new VE,l=new VE,c=new VE,u=new VE;if(t)for(let h=0,d=t.count;h<d;h+=3){const d=t.getX(h+0),p=t.getX(h+1),f=t.getX(h+2);r.fromBufferAttribute(e,d),i.fromBufferAttribute(e,p),s.fromBufferAttribute(e,f),c.subVectors(s,i),u.subVectors(r,i),c.cross(u),o.fromBufferAttribute(n,d),a.fromBufferAttribute(n,p),l.fromBufferAttribute(n,f),o.add(c),a.add(c),l.add(c),n.setXYZ(d,o.x,o.y,o.z),n.setXYZ(p,a.x,a.y,a.z),n.setXYZ(f,l.x,l.y,l.z)}else for(let t=0,h=e.count;t<h;t+=3)r.fromBufferAttribute(e,t+0),i.fromBufferAttribute(e,t+1),s.fromBufferAttribute(e,t+2),c.subVectors(s,i),u.subVectors(r,i),c.cross(u),n.setXYZ(t+0,c.x,c.y,c.z),n.setXYZ(t+1,c.x,c.y,c.z),n.setXYZ(t+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}},merge:function(t,e){if(!t||!t.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);void 0===e&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const r in n){if(void 0===t.attributes[r])continue;const i=n[r].array,s=t.attributes[r],o=s.array,a=s.itemSize*e,l=Math.min(o.length,i.length-a);for(let t=0,e=a;t<l;t++,e++)i[e]=o[t]}return this},normalizeNormals:function(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)LT.fromBufferAttribute(t,e),LT.normalize(),t.setXYZ(e,LT.x,LT.y,LT.z)},toNonIndexed:function(){function t(t,e){const n=t.array,r=t.itemSize,i=t.normalized,s=new n.constructor(e.length*r);let o=0,a=0;for(let l=0,c=e.length;l<c;l++){o=e[l]*r;for(let t=0;t<r;t++)s[a++]=n[o++]}return new mT(s,r,i)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new FT,n=this.index.array,r=this.attributes;for(const o in r){const i=t(r[o],n);e.setAttribute(o,i)}const i=this.morphAttributes;for(const o in i){const r=[],s=i[o];for(let e=0,i=s.length;e<i;e++){const i=t(s[e],n);r.push(i)}e.morphAttributes[o]=r}e.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let o=0,a=s.length;o<a;o++){const t=s[o];e.addGroup(t.start,t.count,t.materialIndex)}return e},toJSON:function(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const n in e)void 0!==e[n]&&(t[n]=e[n]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const a in n){const e=n[a],r=e.toJSON(t.data);""!==e.name&&(r.name=e.name),t.data.attributes[a]=r}const r={};let i=!1;for(const a in this.morphAttributes){const e=this.morphAttributes[a],n=[];for(let r=0,i=e.length;r<i;r++){const i=e[r],s=i.toJSON(t.data);""!==i.name&&(s.name=i.name),n.push(s)}n.length>0&&(r[a]=n,i=!0)}i&&(t.data.morphAttributes=r,t.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(t.data.groups=JSON.parse(JSON.stringify(s)));const o=this.boundingSphere;return null!==o&&(t.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),t},clone:function(){return(new FT).copy(this)},copy:function(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;null!==n&&this.setIndex(n.clone(e));const r=t.attributes;for(const l in r)this.setAttribute(l,r[l].clone(e));const i=t.morphAttributes;for(const l in i){const t=[],n=i[l];for(let r=0,i=n.length;r<i;r++)t.push(n[r].clone(e));this.morphAttributes[l]=t}this.morphTargetsRelative=t.morphTargetsRelative;const s=t.groups;for(let l=0,c=s.length;l<c;l++){const t=s[l];this.addGroup(t.start,t.count,t.materialIndex)}const o=t.boundingBox;null!==o&&(this.boundingBox=o.clone());const a=t.boundingSphere;return null!==a&&(this.boundingSphere=a.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});const PT=new mC,$T=new fC,BT=new oC,zT=new VE,VT=new VE,UT=new VE,HT=new VE,WT=new VE,jT=new VE,GT=new VE,qT=new VE,XT=new VE,KT=new IE,YT=new IE,ZT=new IE,JT=new VE,QT=new VE;function tA(t=new FT,e=new dT){zC.call(this),this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}function eA(t,e,n,r,i,s,o,a,l,c,u,h){zT.fromBufferAttribute(i,c),VT.fromBufferAttribute(i,u),UT.fromBufferAttribute(i,h);const d=t.morphTargetInfluences;if(e.morphTargets&&s&&d){GT.set(0,0,0),qT.set(0,0,0),XT.set(0,0,0);for(let t=0,e=s.length;t<e;t++){const e=d[t],n=s[t];0!==e&&(HT.fromBufferAttribute(n,c),WT.fromBufferAttribute(n,u),jT.fromBufferAttribute(n,h),o?(GT.addScaledVector(HT,e),qT.addScaledVector(WT,e),XT.addScaledVector(jT,e)):(GT.addScaledVector(HT.sub(zT),e),qT.addScaledVector(WT.sub(VT),e),XT.addScaledVector(jT.sub(UT),e)))}zT.add(GT),VT.add(qT),UT.add(XT)}t.isSkinnedMesh&&(t.boneTransform(c,zT),t.boneTransform(u,VT),t.boneTransform(h,UT));const p=function(t,e,n,r,i,s,o,a){let l;if(l=1===e.side?r.intersectTriangle(o,s,i,!0,a):r.intersectTriangle(i,s,o,2!==e.side,a),null===l)return null;QT.copy(a),QT.applyMatrix4(t.matrixWorld);const c=n.ray.origin.distanceTo(QT);return c<n.near||c>n.far?null:{distance:c,point:QT.clone(),object:t}}(t,e,n,r,zT,VT,UT,JT);if(p){a&&(KT.fromBufferAttribute(a,c),YT.fromBufferAttribute(a,u),ZT.fromBufferAttribute(a,h),p.uv=eT.getUV(JT,zT,VT,UT,KT,YT,ZT,new IE)),l&&(KT.fromBufferAttribute(l,c),YT.fromBufferAttribute(l,u),ZT.fromBufferAttribute(l,h),p.uv2=eT.getUV(JT,zT,VT,UT,KT,YT,ZT,new IE));const t=new cT(c,u,h);eT.getNormal(zT,VT,UT,t.normal),p.face=t}return p}tA.prototype=Object.assign(Object.create(zC.prototype),{constructor:tA,isMesh:!0,copy:function(t){return zC.prototype.copy.call(this,t),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this},updateMorphTargets:function(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},raycast:function(t,e){const n=this.geometry,r=this.material,i=this.matrixWorld;if(void 0===r)return;if(null===n.boundingSphere&&n.computeBoundingSphere(),BT.copy(n.boundingSphere),BT.applyMatrix4(i),!1===t.ray.intersectsSphere(BT))return;if(PT.copy(i).invert(),$T.copy(t.ray).applyMatrix4(PT),null!==n.boundingBox&&!1===$T.intersectsBox(n.boundingBox))return;let s;if(n.isBufferGeometry){const i=n.index,o=n.attributes.position,a=n.morphAttributes.position,l=n.morphTargetsRelative,c=n.attributes.uv,u=n.attributes.uv2,h=n.groups,d=n.drawRange;if(null!==i)if(Array.isArray(r))for(let n=0,p=h.length;n<p;n++){const p=h[n],f=r[p.materialIndex];for(let n=Math.max(p.start,d.start),r=Math.min(p.start+p.count,d.start+d.count);n<r;n+=3){const r=i.getX(n),h=i.getX(n+1),d=i.getX(n+2);s=eA(this,f,t,$T,o,a,l,c,u,r,h,d),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=p.materialIndex,e.push(s))}}else for(let n=Math.max(0,d.start),p=Math.min(i.count,d.start+d.count);n<p;n+=3){const h=i.getX(n),d=i.getX(n+1),p=i.getX(n+2);s=eA(this,r,t,$T,o,a,l,c,u,h,d,p),s&&(s.faceIndex=Math.floor(n/3),e.push(s))}else if(void 0!==o)if(Array.isArray(r))for(let n=0,p=h.length;n<p;n++){const i=h[n],p=r[i.materialIndex];for(let n=Math.max(i.start,d.start),r=Math.min(i.start+i.count,d.start+d.count);n<r;n+=3)s=eA(this,p,t,$T,o,a,l,c,u,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=i.materialIndex,e.push(s))}else for(let n=Math.max(0,d.start),p=Math.min(o.count,d.start+d.count);n<p;n+=3)s=eA(this,r,t,$T,o,a,l,c,u,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),e.push(s))}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}});class nA extends FT{constructor(t=1,e=1,n=1,r=1,i=1,s=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:r,heightSegments:i,depthSegments:s};const o=this;r=Math.floor(r),i=Math.floor(i),s=Math.floor(s);const a=[],l=[],c=[],u=[];let h=0,d=0;function p(t,e,n,r,i,s,p,f,m,g,y){const v=s/m,b=p/g,_=s/2,x=p/2,w=f/2,S=m+1,E=g+1;let C=0,T=0;const A=new VE;for(let o=0;o<E;o++){const s=o*b-x;for(let a=0;a<S;a++)A[t]=(a*v-_)*r,A[e]=s*i,A[n]=w,l.push(A.x,A.y,A.z),A[t]=0,A[e]=0,A[n]=f>0?1:-1,c.push(A.x,A.y,A.z),u.push(a/m),u.push(1-o/g),C+=1}for(let o=0;o<g;o++)for(let t=0;t<m;t++){const e=h+t+S*(o+1),n=h+(t+1)+S*(o+1),r=h+(t+1)+S*o;a.push(h+t+S*o,e,r),a.push(e,n,r),T+=6}o.addGroup(d,T,y),d+=T,h+=C}p("z","y","x",-1,-1,n,e,t,s,i,0),p("z","y","x",1,-1,n,e,-t,s,i,1),p("x","z","y",1,1,t,n,e,r,s,2),p("x","z","y",1,-1,t,n,-e,r,s,3),p("x","y","z",1,-1,t,e,n,r,i,4),p("x","y","z",-1,-1,t,e,-n,r,i,5),this.setIndex(a),this.setAttribute("position",new ET(l,3)),this.setAttribute("normal",new ET(c,3)),this.setAttribute("uv",new ET(u,2))}}function rA(t){const e={};for(const n in t){e[n]={};for(const r in t[n]){const i=t[n][r];e[n][r]=i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture)?i.clone():Array.isArray(i)?i.slice():i}}return e}function iA(t){const e={};for(let n=0;n<t.length;n++){const r=rA(t[n]);for(const t in r)e[t]=r[t]}return e}const sA={clone:rA,merge:iA};function oA(t){hT.call(this),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==t&&(void 0!==t.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}function aA(){zC.call(this),this.type="Camera",this.matrixWorldInverse=new mC,this.projectionMatrix=new mC,this.projectionMatrixInverse=new mC}function lA(t=50,e=1,n=.1,r=2e3){aA.call(this),this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=r,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}(oA.prototype=Object.create(hT.prototype)).constructor=oA,oA.prototype.isShaderMaterial=!0,oA.prototype.copy=function(t){return hT.prototype.copy.call(this,t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=rA(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.lights=t.lights,this.clipping=t.clipping,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this},oA.prototype.toJSON=function(t){const e=hT.prototype.toJSON.call(this,t);e.glslVersion=this.glslVersion,e.uniforms={};for(const r in this.uniforms){const n=this.uniforms[r].value;e.uniforms[r]=n&&n.isTexture?{type:"t",value:n.toJSON(t).uuid}:n&&n.isColor?{type:"c",value:n.getHex()}:n&&n.isVector2?{type:"v2",value:n.toArray()}:n&&n.isVector3?{type:"v3",value:n.toArray()}:n&&n.isVector4?{type:"v4",value:n.toArray()}:n&&n.isMatrix3?{type:"m3",value:n.toArray()}:n&&n.isMatrix4?{type:"m4",value:n.toArray()}:{value:n}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const n={};for(const r in this.extensions)!0===this.extensions[r]&&(n[r]=!0);return Object.keys(n).length>0&&(e.extensions=n),e},aA.prototype=Object.assign(Object.create(zC.prototype),{constructor:aA,isCamera:!0,copy:function(t,e){return zC.prototype.copy.call(this,t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this},getWorldDirection:function(t){void 0===t&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),t=new VE),this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()},updateMatrixWorld:function(t){zC.prototype.updateMatrixWorld.call(this,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()},updateWorldMatrix:function(t,e){zC.prototype.updateWorldMatrix.call(this,t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()},clone:function(){return(new this.constructor).copy(this)}}),lA.prototype=Object.assign(Object.create(aA.prototype),{constructor:lA,isPerspectiveCamera:!0,copy:function(t,e){return aA.prototype.copy.call(this,t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=null===t.view?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this},setFocalLength:function(t){const e=.5*this.getFilmHeight()/t;this.fov=2*RE.RAD2DEG*Math.atan(e),this.updateProjectionMatrix()},getFocalLength:function(){const t=Math.tan(.5*RE.DEG2RAD*this.fov);return.5*this.getFilmHeight()/t},getEffectiveFOV:function(){return 2*RE.RAD2DEG*Math.atan(Math.tan(.5*RE.DEG2RAD*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(t,e,n,r,i,s){this.aspect=t/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=r,this.view.width=i,this.view.height=s,this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const t=this.near;let e=t*Math.tan(.5*RE.DEG2RAD*this.fov)/this.zoom,n=2*e,r=this.aspect*n,i=-.5*r;const s=this.view;if(null!==this.view&&this.view.enabled){const t=s.fullWidth,o=s.fullHeight;i+=s.offsetX*r/t,e-=s.offsetY*n/o,r*=s.width/t,n*=s.height/o}const o=this.filmOffset;0!==o&&(i+=t*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(i,i+r,e,e-n,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(t){const e=zC.prototype.toJSON.call(this,t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}});const cA=90;function uA(t,e,n){if(zC.call(this),this.type="CubeCamera",!0!==n.isWebGLCubeRenderTarget)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=n;const r=new lA(cA,1,t,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new VE(1,0,0)),this.add(r);const i=new lA(cA,1,t,e);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new VE(-1,0,0)),this.add(i);const s=new lA(cA,1,t,e);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(new VE(0,1,0)),this.add(s);const o=new lA(cA,1,t,e);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new VE(0,-1,0)),this.add(o);const a=new lA(cA,1,t,e);a.layers=this.layers,a.up.set(0,-1,0),a.lookAt(new VE(0,0,1)),this.add(a);const l=new lA(cA,1,t,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new VE(0,0,-1)),this.add(l),this.update=function(t,e){null===this.parent&&this.updateMatrixWorld();const c=t.xr.enabled,u=t.getRenderTarget();t.xr.enabled=!1;const h=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,r),t.setRenderTarget(n,1),t.render(e,i),t.setRenderTarget(n,2),t.render(e,s),t.setRenderTarget(n,3),t.render(e,o),t.setRenderTarget(n,4),t.render(e,a),n.texture.generateMipmaps=h,t.setRenderTarget(n,5),t.render(e,l),t.setRenderTarget(u),t.xr.enabled=c}}function hA(t,e,n,r,i,s,o,a,l,c){FE.call(this,t=void 0!==t?t:[],e=void 0!==e?e:301,n,r,i,s,o=void 0!==o?o:dE,a,l,c),this.flipY=!1,this._needsFlipEnvMap=!0}(uA.prototype=Object.create(zC.prototype)).constructor=uA,(hA.prototype=Object.create(FE.prototype)).constructor=hA,hA.prototype.isCubeTexture=!0,Object.defineProperty(hA.prototype,"images",{get:function(){return this.image},set:function(t){this.image=t}});class dA extends BE{constructor(t,e,n){Number.isInteger(e)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),e=n),super(t,t,e),Object.defineProperty(this,"isWebGLCubeRenderTarget",{value:!0}),this.texture=new hA(void 0,(e=e||{}).mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.format=pE,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n=new nA(5,5,5),r=new oA({name:"CubemapFromEquirect",uniforms:rA({tEquirect:{value:null}}),vertexShader:"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",side:1,blending:0});r.uniforms.tEquirect.value=e;const i=new tA(n,r),s=e.minFilter;return e.minFilter===oE&&(e.minFilter=sE),new uA(1,10,this).update(t,i),e.minFilter=s,i.geometry.dispose(),i.material.dispose(),this}clear(t,e,n,r){const i=t.getRenderTarget();for(let s=0;s<6;s++)t.setRenderTarget(this,s),t.clear(e,n,r);t.setRenderTarget(i)}}function pA(t,e,n,r,i,s,o,a,l,c,u,h){FE.call(this,null,s,o,a,l,c,r,i,u,h),this.image={data:t||null,width:e||1,height:n||1},this.magFilter=void 0!==l?l:iE,this.minFilter=void 0!==c?c:iE,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}(pA.prototype=Object.create(FE.prototype)).constructor=pA,pA.prototype.isDataTexture=!0;const fA=new oC,mA=new VE;class gA{constructor(t,e,n,r,i,s){this.planes=[void 0!==t?t:new WC,void 0!==e?e:new WC,void 0!==n?n:new WC,void 0!==r?r:new WC,void 0!==i?i:new WC,void 0!==s?s:new WC]}set(t,e,n,r,i,s){const o=this.planes;return o[0].copy(t),o[1].copy(e),o[2].copy(n),o[3].copy(r),o[4].copy(i),o[5].copy(s),this}clone(){return(new this.constructor).copy(this)}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t){const e=this.planes,n=t.elements,r=n[0],i=n[1],s=n[2],o=n[3],a=n[4],l=n[5],c=n[6],u=n[7],h=n[8],d=n[9],p=n[10],f=n[11],m=n[12],g=n[13],y=n[14],v=n[15];return e[0].setComponents(o-r,u-a,f-h,v-m).normalize(),e[1].setComponents(o+r,u+a,f+h,v+m).normalize(),e[2].setComponents(o+i,u+l,f+d,v+g).normalize(),e[3].setComponents(o-i,u-l,f-d,v-g).normalize(),e[4].setComponents(o-s,u-c,f-p,v-y).normalize(),e[5].setComponents(o+s,u+c,f+p,v+y).normalize(),this}intersectsObject(t){const e=t.geometry;return null===e.boundingSphere&&e.computeBoundingSphere(),fA.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(fA)}intersectsSprite(t){return fA.center.set(0,0,0),fA.radius=.7071067811865476,fA.applyMatrix4(t.matrixWorld),this.intersectsSphere(fA)}intersectsSphere(t){const e=this.planes,n=t.center,r=-t.radius;for(let i=0;i<6;i++)if(e[i].distanceToPoint(n)<r)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const r=e[n];if(mA.x=r.normal.x>0?t.max.x:t.min.x,mA.y=r.normal.y>0?t.max.y:t.min.y,mA.z=r.normal.z>0?t.max.z:t.min.z,r.distanceToPoint(mA)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}}function yA(){let t=null,e=!1,n=null,r=null;function i(e,s){n(e,s),r=t.requestAnimationFrame(i)}return{start:function(){!0!==e&&null!==n&&(r=t.requestAnimationFrame(i),e=!0)},stop:function(){t.cancelAnimationFrame(r),e=!1},setAnimationLoop:function(t){n=t},setContext:function(e){t=e}}}function vA(t,e){const n=e.isWebGL2,r=new WeakMap;return{get:function(t){return t.isInterleavedBufferAttribute&&(t=t.data),r.get(t)},remove:function(e){e.isInterleavedBufferAttribute&&(e=e.data);const n=r.get(e);n&&(t.deleteBuffer(n.buffer),r.delete(e))},update:function(e,i){if(e.isGLBufferAttribute){const t=r.get(e);return void((!t||t.version<e.version)&&r.set(e,{buffer:e.buffer,type:e.type,bytesPerElement:e.elementSize,version:e.version}))}e.isInterleavedBufferAttribute&&(e=e.data);const s=r.get(e);void 0===s?r.set(e,function(e,r){const i=e.array,s=e.usage,o=t.createBuffer();t.bindBuffer(r,o),t.bufferData(r,i,s),e.onUploadCallback();let a=5126;return i instanceof Float32Array?a=5126:i instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):i instanceof Uint16Array?e.isFloat16BufferAttribute?n?a=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):a=5123:i instanceof Int16Array?a=5122:i instanceof Uint32Array?a=5125:i instanceof Int32Array?a=5124:i instanceof Int8Array?a=5120:i instanceof Uint8Array&&(a=5121),{buffer:o,type:a,bytesPerElement:i.BYTES_PER_ELEMENT,version:e.version}}(e,i)):s.version<e.version&&(function(e,r,i){const s=r.array,o=r.updateRange;t.bindBuffer(i,e),-1===o.count?t.bufferSubData(i,0,s):(n?t.bufferSubData(i,o.offset*s.BYTES_PER_ELEMENT,s,o.offset,o.count):t.bufferSubData(i,o.offset*s.BYTES_PER_ELEMENT,s.subarray(o.offset,o.offset+o.count)),o.count=-1)}(s.buffer,e,i),s.version=e.version)}}}class bA extends FT{constructor(t=1,e=1,n=1,r=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:r};const i=t/2,s=e/2,o=Math.floor(n),a=Math.floor(r),l=o+1,c=a+1,u=t/o,h=e/a,d=[],p=[],f=[],m=[];for(let g=0;g<c;g++){const t=g*h-s;for(let e=0;e<l;e++)p.push(e*u-i,-t,0),f.push(0,0,1),m.push(e/o),m.push(1-g/a)}for(let g=0;g<a;g++)for(let t=0;t<o;t++){const e=t+l*(g+1),n=t+1+l*(g+1),r=t+1+l*g;d.push(t+l*g,e,r),d.push(e,n,r)}this.setIndex(d),this.setAttribute("position",new ET(p,3)),this.setAttribute("normal",new ET(f,3)),this.setAttribute("uv",new ET(m,2))}}const _A={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",normal_fragment_begin:"#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmissionmap_fragment:"#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",transmissionmap_pars_fragment:"#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",normal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",normal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"},xA={common:{diffuse:{value:new lT(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new NE},uv2Transform:{value:new NE},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new IE(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new lT(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new lT(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new NE}},sprite:{diffuse:{value:new lT(15658734)},opacity:{value:1},center:{value:new IE(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new NE}}},wA={basic:{uniforms:iA([xA.common,xA.specularmap,xA.envmap,xA.aomap,xA.lightmap,xA.fog]),vertexShader:_A.meshbasic_vert,fragmentShader:_A.meshbasic_frag},lambert:{uniforms:iA([xA.common,xA.specularmap,xA.envmap,xA.aomap,xA.lightmap,xA.emissivemap,xA.fog,xA.lights,{emissive:{value:new lT(0)}}]),vertexShader:_A.meshlambert_vert,fragmentShader:_A.meshlambert_frag},phong:{uniforms:iA([xA.common,xA.specularmap,xA.envmap,xA.aomap,xA.lightmap,xA.emissivemap,xA.bumpmap,xA.normalmap,xA.displacementmap,xA.fog,xA.lights,{emissive:{value:new lT(0)},specular:{value:new lT(1118481)},shininess:{value:30}}]),vertexShader:_A.meshphong_vert,fragmentShader:_A.meshphong_frag},standard:{uniforms:iA([xA.common,xA.envmap,xA.aomap,xA.lightmap,xA.emissivemap,xA.bumpmap,xA.normalmap,xA.displacementmap,xA.roughnessmap,xA.metalnessmap,xA.fog,xA.lights,{emissive:{value:new lT(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:_A.meshphysical_vert,fragmentShader:_A.meshphysical_frag},toon:{uniforms:iA([xA.common,xA.aomap,xA.lightmap,xA.emissivemap,xA.bumpmap,xA.normalmap,xA.displacementmap,xA.gradientmap,xA.fog,xA.lights,{emissive:{value:new lT(0)}}]),vertexShader:_A.meshtoon_vert,fragmentShader:_A.meshtoon_frag},matcap:{uniforms:iA([xA.common,xA.bumpmap,xA.normalmap,xA.displacementmap,xA.fog,{matcap:{value:null}}]),vertexShader:_A.meshmatcap_vert,fragmentShader:_A.meshmatcap_frag},points:{uniforms:iA([xA.points,xA.fog]),vertexShader:_A.points_vert,fragmentShader:_A.points_frag},dashed:{uniforms:iA([xA.common,xA.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:_A.linedashed_vert,fragmentShader:_A.linedashed_frag},depth:{uniforms:iA([xA.common,xA.displacementmap]),vertexShader:_A.depth_vert,fragmentShader:_A.depth_frag},normal:{uniforms:iA([xA.common,xA.bumpmap,xA.normalmap,xA.displacementmap,{opacity:{value:1}}]),vertexShader:_A.normal_vert,fragmentShader:_A.normal_frag},sprite:{uniforms:iA([xA.sprite,xA.fog]),vertexShader:_A.sprite_vert,fragmentShader:_A.sprite_frag},background:{uniforms:{uvTransform:{value:new NE},t2D:{value:null}},vertexShader:_A.background_vert,fragmentShader:_A.background_frag},cube:{uniforms:iA([xA.envmap,{opacity:{value:1}}]),vertexShader:_A.cube_vert,fragmentShader:_A.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:_A.equirect_vert,fragmentShader:_A.equirect_frag},distanceRGBA:{uniforms:iA([xA.common,xA.displacementmap,{referencePosition:{value:new VE},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:_A.distanceRGBA_vert,fragmentShader:_A.distanceRGBA_frag},shadow:{uniforms:iA([xA.lights,xA.fog,{color:{value:new lT(0)},opacity:{value:1}}]),vertexShader:_A.shadow_vert,fragmentShader:_A.shadow_frag}};function SA(t,e,n,r,i){const s=new lT(0);let o,a,l=0,c=null,u=0,h=null;function d(t,e){n.buffers.color.setClear(t.r,t.g,t.b,e,i)}return{getClearColor:function(){return s},setClearColor:function(t,e=1){s.set(t),l=e,d(s,l)},getClearAlpha:function(){return l},setClearAlpha:function(t){l=t,d(s,l)},render:function(n,i,p,f){let m=!0===i.isScene?i.background:null;m&&m.isTexture&&(m=e.get(m));const g=t.xr,y=g.getSession&&g.getSession();y&&"additive"===y.environmentBlendMode&&(m=null),null===m?d(s,l):m&&m.isColor&&(d(m,1),f=!0),(t.autoClear||f)&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),m&&(m.isCubeTexture||m.isWebGLCubeRenderTarget||306===m.mapping)?(void 0===a&&(a=new tA(new nA(1,1,1),new oA({name:"BackgroundCubeMaterial",uniforms:rA(wA.cube.uniforms),vertexShader:wA.cube.vertexShader,fragmentShader:wA.cube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),a.geometry.deleteAttribute("uv"),a.onBeforeRender=function(t,e,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(a.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(a)),m.isWebGLCubeRenderTarget&&(m=m.texture),a.material.uniforms.envMap.value=m,a.material.uniforms.flipEnvMap.value=m.isCubeTexture&&m._needsFlipEnvMap?-1:1,c===m&&u===m.version&&h===t.toneMapping||(a.material.needsUpdate=!0,c=m,u=m.version,h=t.toneMapping),n.unshift(a,a.geometry,a.material,0,0,null)):m&&m.isTexture&&(void 0===o&&(o=new tA(new bA(2,2),new oA({name:"BackgroundMaterial",uniforms:rA(wA.background.uniforms),vertexShader:wA.background.vertexShader,fragmentShader:wA.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),Object.defineProperty(o.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(o)),o.material.uniforms.t2D.value=m,!0===m.matrixAutoUpdate&&m.updateMatrix(),o.material.uniforms.uvTransform.value.copy(m.matrix),c===m&&u===m.version&&h===t.toneMapping||(o.material.needsUpdate=!0,c=m,u=m.version,h=t.toneMapping),n.unshift(o,o.geometry,o.material,0,0,null))}}}function EA(t,e,n,r){const i=t.getParameter(34921),s=r.isWebGL2?null:e.get("OES_vertex_array_object"),o=r.isWebGL2||null!==s,a={},l=d(null);let c=l;function u(e){return r.isWebGL2?t.bindVertexArray(e):s.bindVertexArrayOES(e)}function h(e){return r.isWebGL2?t.deleteVertexArray(e):s.deleteVertexArrayOES(e)}function d(t){const e=[],n=[],r=[];for(let s=0;s<i;s++)e[s]=0,n[s]=0,r[s]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:e,enabledAttributes:n,attributeDivisors:r,object:t,attributes:{},index:null}}function p(){const t=c.newAttributes;for(let e=0,n=t.length;e<n;e++)t[e]=0}function f(t){m(t,0)}function m(n,i){const s=c.enabledAttributes,o=c.attributeDivisors;c.newAttributes[n]=1,0===s[n]&&(t.enableVertexAttribArray(n),s[n]=1),o[n]!==i&&((r.isWebGL2?t:e.get("ANGLE_instanced_arrays"))[r.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](n,i),o[n]=i)}function g(){const e=c.newAttributes,n=c.enabledAttributes;for(let r=0,i=n.length;r<i;r++)n[r]!==e[r]&&(t.disableVertexAttribArray(r),n[r]=0)}function y(e,n,i,s,o,a){!0!==r.isWebGL2||5124!==i&&5125!==i?t.vertexAttribPointer(e,n,i,s,o,a):t.vertexAttribIPointer(e,n,i,o,a)}function v(){b(),c!==l&&(c=l,u(c.object))}function b(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:function(i,l,h,v,b){let _=!1;if(o){const e=function(e,n,i){const o=!0===i.wireframe;let l=a[e.id];void 0===l&&(l={},a[e.id]=l);let c=l[n.id];void 0===c&&(c={},l[n.id]=c);let u=c[o];return void 0===u&&(u=d(r.isWebGL2?t.createVertexArray():s.createVertexArrayOES()),c[o]=u),u}(v,h,l);c!==e&&(c=e,u(c.object)),_=function(t,e){const n=c.attributes,r=t.attributes;let i=0;for(const s in r){const t=n[s],e=r[s];if(void 0===t)return!0;if(t.attribute!==e)return!0;if(t.data!==e.data)return!0;i++}return c.attributesNum!==i||c.index!==e}(v,b),_&&function(t,e){const n={},r=t.attributes;let i=0;for(const s in r){const t=r[s],e={};e.attribute=t,t.data&&(e.data=t.data),n[s]=e,i++}c.attributes=n,c.attributesNum=i,c.index=e}(v,b)}else{const t=!0===l.wireframe;c.geometry===v.id&&c.program===h.id&&c.wireframe===t||(c.geometry=v.id,c.program=h.id,c.wireframe=t,_=!0)}!0===i.isInstancedMesh&&(_=!0),null!==b&&n.update(b,34963),_&&(function(i,s,o,a){if(!1===r.isWebGL2&&(i.isInstancedMesh||a.isInstancedBufferGeometry)&&null===e.get("ANGLE_instanced_arrays"))return;p();const l=a.attributes,c=o.getAttributes(),u=s.defaultAttributeValues;for(const e in c){const r=c[e];if(r>=0){const s=l[e];if(void 0!==s){const e=s.normalized,i=s.itemSize,o=n.get(s);if(void 0===o)continue;const l=o.buffer,c=o.type,u=o.bytesPerElement;if(s.isInterleavedBufferAttribute){const n=s.data,o=n.stride,h=s.offset;n&&n.isInstancedInterleavedBuffer?(m(r,n.meshPerAttribute),void 0===a._maxInstanceCount&&(a._maxInstanceCount=n.meshPerAttribute*n.count)):f(r),t.bindBuffer(34962,l),y(r,i,c,e,o*u,h*u)}else s.isInstancedBufferAttribute?(m(r,s.meshPerAttribute),void 0===a._maxInstanceCount&&(a._maxInstanceCount=s.meshPerAttribute*s.count)):f(r),t.bindBuffer(34962,l),y(r,i,c,e,0,0)}else if("instanceMatrix"===e){const e=n.get(i.instanceMatrix);if(void 0===e)continue;const s=e.buffer,o=e.type;m(r+0,1),m(r+1,1),m(r+2,1),m(r+3,1),t.bindBuffer(34962,s),t.vertexAttribPointer(r+0,4,o,!1,64,0),t.vertexAttribPointer(r+1,4,o,!1,64,16),t.vertexAttribPointer(r+2,4,o,!1,64,32),t.vertexAttribPointer(r+3,4,o,!1,64,48)}else if("instanceColor"===e){const e=n.get(i.instanceColor);if(void 0===e)continue;const s=e.buffer,o=e.type;m(r,1),t.bindBuffer(34962,s),t.vertexAttribPointer(r,3,o,!1,12,0)}else if(void 0!==u){const n=u[e];if(void 0!==n)switch(n.length){case 2:t.vertexAttrib2fv(r,n);break;case 3:t.vertexAttrib3fv(r,n);break;case 4:t.vertexAttrib4fv(r,n);break;default:t.vertexAttrib1fv(r,n)}}}}g()}(i,l,h,v),null!==b&&t.bindBuffer(34963,n.get(b).buffer))},reset:v,resetDefaultState:b,dispose:function(){v();for(const t in a){const e=a[t];for(const t in e){const n=e[t];for(const t in n)h(n[t].object),delete n[t];delete e[t]}delete a[t]}},releaseStatesOfGeometry:function(t){if(void 0===a[t.id])return;const e=a[t.id];for(const n in e){const t=e[n];for(const e in t)h(t[e].object),delete t[e];delete e[n]}delete a[t.id]},releaseStatesOfProgram:function(t){for(const e in a){const n=a[e];if(void 0===n[t.id])continue;const r=n[t.id];for(const t in r)h(r[t].object),delete r[t];delete n[t.id]}},initAttributes:p,enableAttribute:f,disableUnusedAttributes:g}}function CA(t,e,n,r){const i=r.isWebGL2;let s;this.setMode=function(t){s=t},this.render=function(e,r){t.drawArrays(s,e,r),n.update(r,s,1)},this.renderInstances=function(r,o,a){if(0===a)return;let l,c;if(i)l=t,c="drawArraysInstanced";else if(l=e.get("ANGLE_instanced_arrays"),c="drawArraysInstancedANGLE",null===l)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");l[c](s,r,o,a),n.update(o,s,a)}}function TA(t,e,n){let r;function i(e){if("highp"===e){if(t.getShaderPrecisionFormat(35633,36338).precision>0&&t.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";e="mediump"}return"mediump"===e&&t.getShaderPrecisionFormat(35633,36337).precision>0&&t.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const s="undefined"!=typeof WebGL2RenderingContext&&t instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&t instanceof WebGL2ComputeRenderingContext;let o=void 0!==n.precision?n.precision:"highp";const a=i(o);a!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",a,"instead."),o=a);const l=!0===n.logarithmicDepthBuffer,c=t.getParameter(34930),u=t.getParameter(35660),h=t.getParameter(3379),d=t.getParameter(34076),p=t.getParameter(34921),f=t.getParameter(36347),m=t.getParameter(36348),g=t.getParameter(36349),y=u>0,v=s||!!e.get("OES_texture_float");return{isWebGL2:s,getMaxAnisotropy:function(){if(void 0!==r)return r;const n=e.get("EXT_texture_filter_anisotropic");return r=null!==n?t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0,r},getMaxPrecision:i,precision:o,logarithmicDepthBuffer:l,maxTextures:c,maxVertexTextures:u,maxTextureSize:h,maxCubemapSize:d,maxAttributes:p,maxVertexUniforms:f,maxVaryings:m,maxFragmentUniforms:g,vertexTextures:y,floatFragmentTextures:v,floatVertexTextures:y&&v,maxSamples:s?t.getParameter(36183):0}}function AA(t){const e=this;let n=null,r=0,i=!1,s=!1;const o=new WC,a=new NE,l={value:null,needsUpdate:!1};function c(){l.value!==n&&(l.value=n,l.needsUpdate=r>0),e.numPlanes=r,e.numIntersection=0}function u(t,n,r,i){const s=null!==t?t.length:0;let c=null;if(0!==s){if(c=l.value,!0!==i||null===c){const e=r+4*s,i=n.matrixWorldInverse;a.getNormalMatrix(i),(null===c||c.length<e)&&(c=new Float32Array(e));for(let n=0,l=r;n!==s;++n,l+=4)o.copy(t[n]).applyMatrix4(i,a),o.normal.toArray(c,l),c[l+3]=o.constant}l.value=c,l.needsUpdate=!0}return e.numPlanes=s,e.numIntersection=0,c}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(t,e,s){const o=0!==t.length||e||0!==r||i;return i=e,n=u(t,s,0),r=t.length,o},this.beginShadows=function(){s=!0,u(null)},this.endShadows=function(){s=!1,c()},this.setState=function(e,o,a){const h=e.clippingPlanes,d=e.clipIntersection,p=e.clipShadows,f=t.get(e);if(!i||null===h||0===h.length||s&&!p)s?u(null):c();else{const t=s?0:r,e=4*t;let i=f.clippingState||null;l.value=i,i=u(h,o,e,a);for(let r=0;r!==e;++r)i[r]=n[r];f.clippingState=i,this.numIntersection=d?this.numPlanes:0,this.numPlanes+=t}}}function MA(t){let e=new WeakMap;function n(t,e){return 303===e?t.mapping=301:304===e&&(t.mapping=302),t}function r(t){const n=t.target;n.removeEventListener("dispose",r);const i=e.get(n);void 0!==i&&(e.delete(n),i.dispose())}return{get:function(i){if(i&&i.isTexture){const s=i.mapping;if(303===s||304===s){if(e.has(i))return n(e.get(i).texture,i.mapping);{const s=i.image;if(s&&s.height>0){const o=t.getRenderList(),a=t.getRenderTarget(),l=new dA(s.height/2);return l.fromEquirectangularTexture(t,i),e.set(i,l),t.setRenderTarget(a),t.setRenderList(o),i.addEventListener("dispose",r),n(l.texture,i.mapping)}return null}}}return i},dispose:function(){e=new WeakMap}}}function kA(t){const e={};function n(n){if(void 0!==e[n])return e[n];let r;switch(n){case"WEBGL_depth_texture":r=t.getExtension("WEBGL_depth_texture")||t.getExtension("MOZ_WEBGL_depth_texture")||t.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=t.getExtension("WEBGL_compressed_texture_s3tc")||t.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=t.getExtension("WEBGL_compressed_texture_pvrtc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=t.getExtension(n)}return e[n]=r,r}return{has:function(t){return null!==n(t)},init:function(t){t.isWebGL2?n("EXT_color_buffer_float"):(n("WEBGL_depth_texture"),n("OES_texture_float"),n("OES_texture_half_float"),n("OES_texture_half_float_linear"),n("OES_standard_derivatives"),n("OES_element_index_uint"),n("OES_vertex_array_object"),n("ANGLE_instanced_arrays")),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float")},get:function(t){const e=n(t);return null===e&&console.warn("THREE.WebGLRenderer: "+t+" extension not supported."),e}}}function RA(t,e,n,r){const i={},s=new WeakMap;function o(t){const a=t.target;null!==a.index&&e.remove(a.index);for(const n in a.attributes)e.remove(a.attributes[n]);a.removeEventListener("dispose",o),delete i[a.id];const l=s.get(a);l&&(e.remove(l),s.delete(a)),r.releaseStatesOfGeometry(a),!0===a.isInstancedBufferGeometry&&delete a._maxInstanceCount,n.memory.geometries--}function a(t){const n=[],r=t.index,i=t.attributes.position;let o=0;if(null!==r){const t=r.array;o=r.version;for(let e=0,r=t.length;e<r;e+=3){const r=t[e+0],i=t[e+1],s=t[e+2];n.push(r,i,i,s,s,r)}}else{o=i.version;for(let t=0,e=i.array.length/3-1;t<e;t+=3){const e=t+0,r=t+1,i=t+2;n.push(e,r,r,i,i,e)}}const a=new(TT(n)>65535?wT:_T)(n,1);a.version=o;const l=s.get(t);l&&e.remove(l),s.set(t,a)}return{get:function(t,e){return!0===i[e.id]||(e.addEventListener("dispose",o),i[e.id]=!0,n.memory.geometries++),e},update:function(t){const n=t.attributes;for(const i in n)e.update(n[i],34962);const r=t.morphAttributes;for(const i in r){const t=r[i];for(let n=0,r=t.length;n<r;n++)e.update(t[n],34962)}},getWireframeAttribute:function(t){const e=s.get(t);if(e){const n=t.index;null!==n&&e.version<n.version&&a(t)}else a(t);return s.get(t)}}}function IA(t,e,n,r){const i=r.isWebGL2;let s,o,a;this.setMode=function(t){s=t},this.setIndex=function(t){o=t.type,a=t.bytesPerElement},this.render=function(e,r){t.drawElements(s,r,o,e*a),n.update(r,s,1)},this.renderInstances=function(r,l,c){if(0===c)return;let u,h;if(i)u=t,h="drawElementsInstanced";else if(u=e.get("ANGLE_instanced_arrays"),h="drawElementsInstancedANGLE",null===u)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");u[h](s,l,o,r*a,c),n.update(l,s,c)}}function NA(t){const e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(t,n,r){switch(e.calls++,n){case 4:e.triangles+=r*(t/3);break;case 1:e.lines+=r*(t/2);break;case 3:e.lines+=r*(t-1);break;case 2:e.lines+=r*t;break;case 0:e.points+=r*t;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",n)}}}}function OA(t,e){return t[0]-e[0]}function DA(t,e){return Math.abs(e[1])-Math.abs(t[1])}function LA(t){const e={},n=new Float32Array(8),r=[];for(let i=0;i<8;i++)r[i]=[i,0];return{update:function(i,s,o,a){const l=i.morphTargetInfluences,c=void 0===l?0:l.length;let u=e[s.id];if(void 0===u){u=[];for(let t=0;t<c;t++)u[t]=[t,0];e[s.id]=u}for(let t=0;t<c;t++){const e=u[t];e[0]=t,e[1]=l[t]}u.sort(DA);for(let t=0;t<8;t++)t<c&&u[t][1]?(r[t][0]=u[t][0],r[t][1]=u[t][1]):(r[t][0]=Number.MAX_SAFE_INTEGER,r[t][1]=0);r.sort(OA);const h=o.morphTargets&&s.morphAttributes.position,d=o.morphNormals&&s.morphAttributes.normal;let p=0;for(let t=0;t<8;t++){const e=r[t],i=e[0],o=e[1];i!==Number.MAX_SAFE_INTEGER&&o?(h&&s.getAttribute("morphTarget"+t)!==h[i]&&s.setAttribute("morphTarget"+t,h[i]),d&&s.getAttribute("morphNormal"+t)!==d[i]&&s.setAttribute("morphNormal"+t,d[i]),n[t]=o,p+=o):(h&&!0===s.hasAttribute("morphTarget"+t)&&s.deleteAttribute("morphTarget"+t),d&&!0===s.hasAttribute("morphNormal"+t)&&s.deleteAttribute("morphNormal"+t),n[t]=0)}const f=s.morphTargetsRelative?1:1-p;a.getUniforms().setValue(t,"morphTargetBaseInfluence",f),a.getUniforms().setValue(t,"morphTargetInfluences",n)}}}function FA(t,e,n,r){let i=new WeakMap;function s(t){const e=t.target;e.removeEventListener("dispose",s),n.remove(e.instanceMatrix),null!==e.instanceColor&&n.remove(e.instanceColor)}return{update:function(t){const o=r.render.frame,a=e.get(t,t.geometry);return i.get(a)!==o&&(e.update(a),i.set(a,o)),t.isInstancedMesh&&(!1===t.hasEventListener("dispose",s)&&t.addEventListener("dispose",s),n.update(t.instanceMatrix,34962),null!==t.instanceColor&&n.update(t.instanceColor,34962)),a},dispose:function(){i=new WeakMap}}}function PA(t=null,e=1,n=1,r=1){FE.call(this,null),this.image={data:t,width:e,height:n,depth:r},this.magFilter=iE,this.minFilter=iE,this.wrapR=nE,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}function $A(t=null,e=1,n=1,r=1){FE.call(this,null),this.image={data:t,width:e,height:n,depth:r},this.magFilter=iE,this.minFilter=iE,this.wrapR=nE,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}wA.physical={uniforms:iA([wA.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new IE(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new lT(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:_A.meshphysical_vert,fragmentShader:_A.meshphysical_frag},(PA.prototype=Object.create(FE.prototype)).constructor=PA,PA.prototype.isDataTexture2DArray=!0,($A.prototype=Object.create(FE.prototype)).constructor=$A,$A.prototype.isDataTexture3D=!0;const BA=new FE,zA=new PA,VA=new $A,UA=new hA,HA=[],WA=[],jA=new Float32Array(16),GA=new Float32Array(9),qA=new Float32Array(4);function XA(t,e,n){const r=t[0];if(r<=0||r>0)return t;const i=e*n;let s=HA[i];if(void 0===s&&(s=new Float32Array(i),HA[i]=s),0!==e){r.toArray(s,0);for(let r=1,i=0;r!==e;++r)i+=n,t[r].toArray(s,i)}return s}function KA(t,e){if(t.length!==e.length)return!1;for(let n=0,r=t.length;n<r;n++)if(t[n]!==e[n])return!1;return!0}function YA(t,e){for(let n=0,r=e.length;n<r;n++)t[n]=e[n]}function ZA(t,e){let n=WA[e];void 0===n&&(n=new Int32Array(e),WA[e]=n);for(let r=0;r!==e;++r)n[r]=t.allocateTextureUnit();return n}function JA(t,e){const n=this.cache;n[0]!==e&&(t.uniform1f(this.addr,e),n[0]=e)}function QA(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2f(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(KA(n,e))return;t.uniform2fv(this.addr,e),YA(n,e)}}function tM(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3f(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else if(void 0!==e.r)n[0]===e.r&&n[1]===e.g&&n[2]===e.b||(t.uniform3f(this.addr,e.r,e.g,e.b),n[0]=e.r,n[1]=e.g,n[2]=e.b);else{if(KA(n,e))return;t.uniform3fv(this.addr,e),YA(n,e)}}function eM(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4f(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(KA(n,e))return;t.uniform4fv(this.addr,e),YA(n,e)}}function nM(t,e){const n=this.cache,r=e.elements;if(void 0===r){if(KA(n,e))return;t.uniformMatrix2fv(this.addr,!1,e),YA(n,e)}else{if(KA(n,r))return;qA.set(r),t.uniformMatrix2fv(this.addr,!1,qA),YA(n,r)}}function rM(t,e){const n=this.cache,r=e.elements;if(void 0===r){if(KA(n,e))return;t.uniformMatrix3fv(this.addr,!1,e),YA(n,e)}else{if(KA(n,r))return;GA.set(r),t.uniformMatrix3fv(this.addr,!1,GA),YA(n,r)}}function iM(t,e){const n=this.cache,r=e.elements;if(void 0===r){if(KA(n,e))return;t.uniformMatrix4fv(this.addr,!1,e),YA(n,e)}else{if(KA(n,r))return;jA.set(r),t.uniformMatrix4fv(this.addr,!1,jA),YA(n,r)}}function sM(t,e,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i),n.safeSetTexture2D(e||BA,i)}function oM(t,e,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i),n.setTexture2DArray(e||zA,i)}function aM(t,e,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i),n.setTexture3D(e||VA,i)}function lM(t,e,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i),n.safeSetTextureCube(e||UA,i)}function cM(t,e){const n=this.cache;n[0]!==e&&(t.uniform1i(this.addr,e),n[0]=e)}function uM(t,e){const n=this.cache;KA(n,e)||(t.uniform2iv(this.addr,e),YA(n,e))}function hM(t,e){const n=this.cache;KA(n,e)||(t.uniform3iv(this.addr,e),YA(n,e))}function dM(t,e){const n=this.cache;KA(n,e)||(t.uniform4iv(this.addr,e),YA(n,e))}function pM(t,e){const n=this.cache;n[0]!==e&&(t.uniform1ui(this.addr,e),n[0]=e)}function fM(t,e){t.uniform1fv(this.addr,e)}function mM(t,e){t.uniform1iv(this.addr,e)}function gM(t,e){t.uniform2iv(this.addr,e)}function yM(t,e){t.uniform3iv(this.addr,e)}function vM(t,e){t.uniform4iv(this.addr,e)}function bM(t,e){const n=XA(e,this.size,2);t.uniform2fv(this.addr,n)}function _M(t,e){const n=XA(e,this.size,3);t.uniform3fv(this.addr,n)}function xM(t,e){const n=XA(e,this.size,4);t.uniform4fv(this.addr,n)}function wM(t,e){const n=XA(e,this.size,4);t.uniformMatrix2fv(this.addr,!1,n)}function SM(t,e){const n=XA(e,this.size,9);t.uniformMatrix3fv(this.addr,!1,n)}function EM(t,e){const n=XA(e,this.size,16);t.uniformMatrix4fv(this.addr,!1,n)}function CM(t,e,n){const r=e.length,i=ZA(n,r);t.uniform1iv(this.addr,i);for(let s=0;s!==r;++s)n.safeSetTexture2D(e[s]||BA,i[s])}function TM(t,e,n){const r=e.length,i=ZA(n,r);t.uniform1iv(this.addr,i);for(let s=0;s!==r;++s)n.safeSetTextureCube(e[s]||UA,i[s])}function AM(t,e,n){this.id=t,this.addr=n,this.cache=[],this.setValue=function(t){switch(t){case 5126:return JA;case 35664:return QA;case 35665:return tM;case 35666:return eM;case 35674:return nM;case 35675:return rM;case 35676:return iM;case 5124:case 35670:return cM;case 35667:case 35671:return uM;case 35668:case 35672:return hM;case 35669:case 35673:return dM;case 5125:return pM;case 35678:case 36198:case 36298:case 36306:case 35682:return sM;case 35679:case 36299:case 36307:return aM;case 35680:case 36300:case 36308:case 36293:return lM;case 36289:case 36303:case 36311:case 36292:return oM}}(e.type)}function MM(t,e,n){this.id=t,this.addr=n,this.cache=[],this.size=e.size,this.setValue=function(t){switch(t){case 5126:return fM;case 35664:return bM;case 35665:return _M;case 35666:return xM;case 35674:return wM;case 35675:return SM;case 35676:return EM;case 5124:case 35670:return mM;case 35667:case 35671:return gM;case 35668:case 35672:return yM;case 35669:case 35673:return vM;case 35678:case 36198:case 36298:case 36306:case 35682:return CM;case 35680:case 36300:case 36308:case 36293:return TM}}(e.type)}function kM(t){this.id=t,this.seq=[],this.map={}}MM.prototype.updateCache=function(t){const e=this.cache;t instanceof Float32Array&&e.length!==t.length&&(this.cache=new Float32Array(t.length)),YA(e,t)},kM.prototype.setValue=function(t,e,n){const r=this.seq;for(let i=0,s=r.length;i!==s;++i){const s=r[i];s.setValue(t,e[s.id],n)}};const RM=/(\w+)(\])?(\[|\.)?/g;function IM(t,e){t.seq.push(e),t.map[e.id]=e}function NM(t,e,n){const r=t.name,i=r.length;for(RM.lastIndex=0;;){const s=RM.exec(r),o=RM.lastIndex;let a=s[1];const l=s[3];if("]"===s[2]&&(a|=0),void 0===l||"["===l&&o+2===i){IM(n,void 0===l?new AM(a,t,e):new MM(a,t,e));break}{let t=n.map[a];void 0===t&&(t=new kM(a),IM(n,t)),n=t}}}function OM(t,e){this.seq=[],this.map={};const n=t.getProgramParameter(e,35718);for(let r=0;r<n;++r){const n=t.getActiveUniform(e,r);NM(n,t.getUniformLocation(e,n.name),this)}}function DM(t,e,n){const r=t.createShader(e);return t.shaderSource(r,n),t.compileShader(r),r}OM.prototype.setValue=function(t,e,n,r){const i=this.map[e];void 0!==i&&i.setValue(t,n,r)},OM.prototype.setOptional=function(t,e,n){const r=e[n];void 0!==r&&this.setValue(t,n,r)},OM.upload=function(t,e,n,r){for(let i=0,s=e.length;i!==s;++i){const s=e[i],o=n[s.id];!1!==o.needsUpdate&&s.setValue(t,o.value,r)}},OM.seqWithValue=function(t,e){const n=[];for(let r=0,i=t.length;r!==i;++r){const i=t[r];i.id in e&&n.push(i)}return n};let LM=0;function FM(t){switch(t){case wE:return["Linear","( value )"];case 3001:return["sRGB","( value )"];case 3002:return["RGBE","( value )"];case 3004:return["RGBM","( value, 7.0 )"];case 3005:return["RGBM","( value, 16.0 )"];case 3006:return["RGBD","( value, 256.0 )"];case 3007:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case 3003:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",t),["Linear","( value )"]}}function PM(t,e,n){const r=t.getShaderParameter(e,35713),i=t.getShaderInfoLog(e).trim();return r&&""===i?"":"THREE.WebGLShader: gl.getShaderInfoLog() "+n+"\n"+i+function(t){const e=t.split("\n");for(let n=0;n<e.length;n++)e[n]=n+1+": "+e[n];return e.join("\n")}(t.getShaderSource(e))}function $M(t,e){const n=FM(e);return"vec4 "+t+"( vec4 value ) { return "+n[0]+"ToLinear"+n[1]+"; }"}function BM(t,e){const n=FM(e);return"vec4 "+t+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function zM(t,e){let n;switch(e){case 1:n="Linear";break;case 2:n="Reinhard";break;case 3:n="OptimizedCineon";break;case 4:n="ACESFilmic";break;case 5:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),n="Linear"}return"vec3 "+t+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function VM(t){return""!==t}function UM(t,e){return t.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function HM(t,e){return t.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const WM=/^[ \t]*#include +<([\w\d./]+)>/gm;function jM(t){return t.replace(WM,GM)}function GM(t,e){const n=_A[e];if(void 0===n)throw new Error("Can not resolve #include <"+e+">");return jM(n)}const qM=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,XM=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function KM(t){return t.replace(XM,ZM).replace(qM,YM)}function YM(t,e,n,r){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),ZM(0,e,n,r)}function ZM(t,e,n,r){let i="";for(let s=parseInt(e);s<parseInt(n);s++)i+=r.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return i}function JM(t){let e="precision "+t.precision+" float;\nprecision "+t.precision+" int;";return"highp"===t.precision?e+="\n#define HIGH_PRECISION":"mediump"===t.precision?e+="\n#define MEDIUM_PRECISION":"lowp"===t.precision&&(e+="\n#define LOW_PRECISION"),e}function QM(t,e,n,r){const i=t.getContext(),s=n.defines;let o=n.vertexShader,a=n.fragmentShader;const l=function(t){let e="SHADOWMAP_TYPE_BASIC";return 1===t.shadowMapType?e="SHADOWMAP_TYPE_PCF":2===t.shadowMapType?e="SHADOWMAP_TYPE_PCF_SOFT":3===t.shadowMapType&&(e="SHADOWMAP_TYPE_VSM"),e}(n),c=function(t){let e="ENVMAP_TYPE_CUBE";if(t.envMap)switch(t.envMapMode){case 301:case 302:e="ENVMAP_TYPE_CUBE";break;case 306:case 307:e="ENVMAP_TYPE_CUBE_UV"}return e}(n),u=function(t){let e="ENVMAP_MODE_REFLECTION";if(t.envMap)switch(t.envMapMode){case 302:case 307:e="ENVMAP_MODE_REFRACTION"}return e}(n),h=function(t){let e="ENVMAP_BLENDING_NONE";if(t.envMap)switch(t.combine){case 0:e="ENVMAP_BLENDING_MULTIPLY";break;case 1:e="ENVMAP_BLENDING_MIX";break;case 2:e="ENVMAP_BLENDING_ADD"}return e}(n),d=t.gammaFactor>0?t.gammaFactor:1,p=n.isWebGL2?"":function(t){return[t.extensionDerivatives||t.envMapCubeUV||t.bumpMap||t.tangentSpaceNormalMap||t.clearcoatNormalMap||t.flatShading||"physical"===t.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(t.extensionFragDepth||t.logarithmicDepthBuffer)&&t.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",t.extensionDrawBuffers&&t.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(t.extensionShaderTextureLOD||t.envMap)&&t.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(VM).join("\n")}(n),f=function(t){const e=[];for(const n in t){const r=t[n];!1!==r&&e.push("#define "+n+" "+r)}return e.join("\n")}(s),m=i.createProgram();let g,y,v=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(g=[f].filter(VM).join("\n"),g.length>0&&(g+="\n"),y=[p,f].filter(VM).join("\n"),y.length>0&&(y+="\n")):(g=[JM(n),"#define SHADER_NAME "+n.shaderName,f,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+d,"#define MAX_BONES "+n.maxBones,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+u:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.useVertexTexture?"#define BONE_TEXTURE":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#ifdef USE_COLOR","\tattribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(VM).join("\n"),y=[p,JM(n),"#define SHADER_NAME "+n.shaderName,f,n.alphaTest?"#define ALPHATEST "+n.alphaTest+(n.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+d,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+c:"",n.envMap?"#define "+u:"",n.envMap?"#define "+h:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.sheen?"#define USE_SHEEN":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==n.toneMapping?"#define TONE_MAPPING":"",0!==n.toneMapping?_A.tonemapping_pars_fragment:"",0!==n.toneMapping?zM("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",_A.encodings_pars_fragment,n.map?$M("mapTexelToLinear",n.mapEncoding):"",n.matcap?$M("matcapTexelToLinear",n.matcapEncoding):"",n.envMap?$M("envMapTexelToLinear",n.envMapEncoding):"",n.emissiveMap?$M("emissiveMapTexelToLinear",n.emissiveMapEncoding):"",n.lightMap?$M("lightMapTexelToLinear",n.lightMapEncoding):"",BM("linearToOutputTexel",n.outputEncoding),n.depthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(VM).join("\n")),o=jM(o),o=UM(o,n),o=HM(o,n),a=jM(a),a=UM(a,n),a=HM(a,n),o=KM(o),a=KM(a),n.isWebGL2&&!0!==n.isRawShaderMaterial&&(v="#version 300 es\n",g=["#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+g,y=["#define varying in",n.glslVersion===TE?"":"out highp vec4 pc_fragColor;",n.glslVersion===TE?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+y);const b=v+y+a,_=DM(i,35633,v+g+o),x=DM(i,35632,b);if(i.attachShader(m,_),i.attachShader(m,x),void 0!==n.index0AttributeName?i.bindAttribLocation(m,0,n.index0AttributeName):!0===n.morphTargets&&i.bindAttribLocation(m,0,"position"),i.linkProgram(m),t.debug.checkShaderErrors){const t=i.getProgramInfoLog(m).trim(),e=i.getShaderInfoLog(_).trim(),n=i.getShaderInfoLog(x).trim();let r=!0,s=!0;if(!1===i.getProgramParameter(m,35714)){r=!1;const e=PM(i,_,"vertex"),n=PM(i,x,"fragment");console.error("THREE.WebGLProgram: shader error: ",i.getError(),"35715",i.getProgramParameter(m,35715),"gl.getProgramInfoLog",t,e,n)}else""!==t?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",t):""!==e&&""!==n||(s=!1);s&&(this.diagnostics={runnable:r,programLog:t,vertexShader:{log:e,prefix:g},fragmentShader:{log:n,prefix:y}})}let w,S;return i.deleteShader(_),i.deleteShader(x),this.getUniforms=function(){return void 0===w&&(w=new OM(i,m)),w},this.getAttributes=function(){return void 0===S&&(S=function(t,e){const n={},r=t.getProgramParameter(e,35721);for(let i=0;i<r;i++){const r=t.getActiveAttrib(e,i).name;n[r]=t.getAttribLocation(e,r)}return n}(i,m)),S},this.destroy=function(){r.releaseStatesOfProgram(this),i.deleteProgram(m),this.program=void 0},this.name=n.shaderName,this.id=LM++,this.cacheKey=e,this.usedTimes=1,this.program=m,this.vertexShader=_,this.fragmentShader=x,this}function tk(t,e,n,r,i,s){const o=[],a=r.isWebGL2,l=r.logarithmicDepthBuffer,c=r.floatVertexTextures,u=r.maxVertexUniforms,h=r.vertexTextures;let d=r.precision;const p={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},f=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function m(t){let e;return t&&t.isTexture?e=t.encoding:t&&t.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),e=t.texture.encoding):e=wE,e}return{getParameters:function(i,o,f,g,y){const v=g.fog,b=e.get(i.envMap||(i.isMeshStandardMaterial?g.environment:null)),_=p[i.type],x=y.isSkinnedMesh?function(t){const e=t.skeleton.bones;if(c)return 1024;{const t=Math.floor((u-20)/4),n=Math.min(t,e.length);return n<e.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+e.length+" bones. This GPU supports "+n+"."),0):n}}(y):0;let w,S;if(null!==i.precision&&(d=r.getMaxPrecision(i.precision),d!==i.precision&&console.warn("THREE.WebGLProgram.getParameters:",i.precision,"not supported, using",d,"instead.")),_){const t=wA[_];w=t.vertexShader,S=t.fragmentShader}else w=i.vertexShader,S=i.fragmentShader;const E=t.getRenderTarget();return{isWebGL2:a,shaderID:_,shaderName:i.type,vertexShader:w,fragmentShader:S,defines:i.defines,isRawShaderMaterial:!0===i.isRawShaderMaterial,glslVersion:i.glslVersion,precision:d,instancing:!0===y.isInstancedMesh,instancingColor:!0===y.isInstancedMesh&&null!==y.instanceColor,supportsVertexTextures:h,outputEncoding:null!==E?m(E.texture):t.outputEncoding,map:!!i.map,mapEncoding:m(i.map),matcap:!!i.matcap,matcapEncoding:m(i.matcap),envMap:!!b,envMapMode:b&&b.mapping,envMapEncoding:m(b),envMapCubeUV:!!b&&(306===b.mapping||307===b.mapping),lightMap:!!i.lightMap,lightMapEncoding:m(i.lightMap),aoMap:!!i.aoMap,emissiveMap:!!i.emissiveMap,emissiveMapEncoding:m(i.emissiveMap),bumpMap:!!i.bumpMap,normalMap:!!i.normalMap,objectSpaceNormalMap:1===i.normalMapType,tangentSpaceNormalMap:0===i.normalMapType,clearcoatMap:!!i.clearcoatMap,clearcoatRoughnessMap:!!i.clearcoatRoughnessMap,clearcoatNormalMap:!!i.clearcoatNormalMap,displacementMap:!!i.displacementMap,roughnessMap:!!i.roughnessMap,metalnessMap:!!i.metalnessMap,specularMap:!!i.specularMap,alphaMap:!!i.alphaMap,gradientMap:!!i.gradientMap,sheen:!!i.sheen,transmissionMap:!!i.transmissionMap,combine:i.combine,vertexTangents:i.normalMap&&i.vertexTangents,vertexColors:i.vertexColors,vertexUvs:!!(i.map||i.bumpMap||i.normalMap||i.specularMap||i.alphaMap||i.emissiveMap||i.roughnessMap||i.metalnessMap||i.clearcoatMap||i.clearcoatRoughnessMap||i.clearcoatNormalMap||i.displacementMap||i.transmissionMap),uvsVertexOnly:!(i.map||i.bumpMap||i.normalMap||i.specularMap||i.alphaMap||i.emissiveMap||i.roughnessMap||i.metalnessMap||i.clearcoatNormalMap||i.transmissionMap||!i.displacementMap),fog:!!v,useFog:i.fog,fogExp2:v&&v.isFogExp2,flatShading:i.flatShading,sizeAttenuation:i.sizeAttenuation,logarithmicDepthBuffer:l,skinning:i.skinning&&x>0,maxBones:x,useVertexTexture:c,morphTargets:i.morphTargets,morphNormals:i.morphNormals,maxMorphTargets:t.maxMorphTargets,maxMorphNormals:t.maxMorphNormals,numDirLights:o.directional.length,numPointLights:o.point.length,numSpotLights:o.spot.length,numRectAreaLights:o.rectArea.length,numHemiLights:o.hemi.length,numDirLightShadows:o.directionalShadowMap.length,numPointLightShadows:o.pointShadowMap.length,numSpotLightShadows:o.spotShadowMap.length,numClippingPlanes:s.numPlanes,numClipIntersection:s.numIntersection,dithering:i.dithering,shadowMapEnabled:t.shadowMap.enabled&&f.length>0,shadowMapType:t.shadowMap.type,toneMapping:i.toneMapped?t.toneMapping:0,physicallyCorrectLights:t.physicallyCorrectLights,premultipliedAlpha:i.premultipliedAlpha,alphaTest:i.alphaTest,doubleSided:2===i.side,flipSided:1===i.side,depthPacking:void 0!==i.depthPacking&&i.depthPacking,index0AttributeName:i.index0AttributeName,extensionDerivatives:i.extensions&&i.extensions.derivatives,extensionFragDepth:i.extensions&&i.extensions.fragDepth,extensionDrawBuffers:i.extensions&&i.extensions.drawBuffers,extensionShaderTextureLOD:i.extensions&&i.extensions.shaderTextureLOD,rendererExtensionFragDepth:a||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:a||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:a||n.has("EXT_shader_texture_lod"),customProgramCacheKey:i.customProgramCacheKey()}},getProgramCacheKey:function(e){const n=[];if(e.shaderID?n.push(e.shaderID):(n.push(e.fragmentShader),n.push(e.vertexShader)),void 0!==e.defines)for(const t in e.defines)n.push(t),n.push(e.defines[t]);if(!1===e.isRawShaderMaterial){for(let t=0;t<f.length;t++)n.push(e[f[t]]);n.push(t.outputEncoding),n.push(t.gammaFactor)}return n.push(e.customProgramCacheKey),n.join()},getUniforms:function(t){const e=p[t.type];let n;return n=e?sA.clone(wA[e].uniforms):t.uniforms,n},acquireProgram:function(e,n){let r;for(let t=0,i=o.length;t<i;t++){const e=o[t];if(e.cacheKey===n){r=e,++r.usedTimes;break}}return void 0===r&&(r=new QM(t,n,e,i),o.push(r)),r},releaseProgram:function(t){if(0==--t.usedTimes){const e=o.indexOf(t);o[e]=o[o.length-1],o.pop(),t.destroy()}},programs:o}}function ek(){let t=new WeakMap;return{get:function(e){let n=t.get(e);return void 0===n&&(n={},t.set(e,n)),n},remove:function(e){t.delete(e)},update:function(e,n,r){t.get(e)[n]=r},dispose:function(){t=new WeakMap}}}function nk(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.program!==e.program?t.program.id-e.program.id:t.material.id!==e.material.id?t.material.id-e.material.id:t.z!==e.z?t.z-e.z:t.id-e.id}function rk(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.id-e.id}function ik(t){const e=[];let n=0;const r=[],i=[],s={id:-1};function o(r,i,o,a,l,c){let u=e[n];const h=t.get(o);return void 0===u?(u={id:r.id,object:r,geometry:i,material:o,program:h.program||s,groupOrder:a,renderOrder:r.renderOrder,z:l,group:c},e[n]=u):(u.id=r.id,u.object=r,u.geometry=i,u.material=o,u.program=h.program||s,u.groupOrder=a,u.renderOrder=r.renderOrder,u.z=l,u.group=c),n++,u}return{opaque:r,transparent:i,init:function(){n=0,r.length=0,i.length=0},push:function(t,e,n,s,a,l){const c=o(t,e,n,s,a,l);(!0===n.transparent?i:r).push(c)},unshift:function(t,e,n,s,a,l){const c=o(t,e,n,s,a,l);(!0===n.transparent?i:r).unshift(c)},finish:function(){for(let t=n,r=e.length;t<r;t++){const n=e[t];if(null===n.id)break;n.id=null,n.object=null,n.geometry=null,n.material=null,n.program=null,n.group=null}},sort:function(t,e){r.length>1&&r.sort(t||nk),i.length>1&&i.sort(e||rk)}}}function sk(t){let e=new WeakMap;return{get:function(n,r){const i=e.get(n);let s;return void 0===i?(s=new ik(t),e.set(n,new WeakMap),e.get(n).set(r,s)):(s=i.get(r),void 0===s&&(s=new ik(t),i.set(r,s))),s},dispose:function(){e=new WeakMap}}}function ok(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":n={direction:new VE,color:new lT};break;case"SpotLight":n={position:new VE,direction:new VE,color:new lT,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new VE,color:new lT,distance:0,decay:0};break;case"HemisphereLight":n={direction:new VE,skyColor:new lT,groundColor:new lT};break;case"RectAreaLight":n={color:new lT,position:new VE,halfWidth:new VE,halfHeight:new VE}}return t[e.id]=n,n}}}let ak=0;function lk(t,e){return(e.castShadow?1:0)-(t.castShadow?1:0)}function ck(t,e){const n=new ok,r=function(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new IE};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new IE,shadowCameraNear:1,shadowCameraFar:1e3}}return t[e.id]=n,n}}}(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let l=0;l<9;l++)i.probe.push(new VE);const s=new VE,o=new mC,a=new mC;return{setup:function(s){let o=0,a=0,l=0;for(let t=0;t<9;t++)i.probe[t].set(0,0,0);let c=0,u=0,h=0,d=0,p=0,f=0,m=0,g=0;s.sort(lk);for(let t=0,e=s.length;t<e;t++){const e=s[t],y=e.color,v=e.intensity,b=e.distance,_=e.shadow&&e.shadow.map?e.shadow.map.texture:null;if(e.isAmbientLight)o+=y.r*v,a+=y.g*v,l+=y.b*v;else if(e.isLightProbe)for(let t=0;t<9;t++)i.probe[t].addScaledVector(e.sh.coefficients[t],v);else if(e.isDirectionalLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity),e.castShadow){const t=e.shadow,n=r.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,i.directionalShadow[c]=n,i.directionalShadowMap[c]=_,i.directionalShadowMatrix[c]=e.shadow.matrix,f++}i.directional[c]=t,c++}else if(e.isSpotLight){const t=n.get(e);if(t.position.setFromMatrixPosition(e.matrixWorld),t.color.copy(y).multiplyScalar(v),t.distance=b,t.coneCos=Math.cos(e.angle),t.penumbraCos=Math.cos(e.angle*(1-e.penumbra)),t.decay=e.decay,e.castShadow){const t=e.shadow,n=r.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,i.spotShadow[h]=n,i.spotShadowMap[h]=_,i.spotShadowMatrix[h]=e.shadow.matrix,g++}i.spot[h]=t,h++}else if(e.isRectAreaLight){const t=n.get(e);t.color.copy(y).multiplyScalar(v),t.halfWidth.set(.5*e.width,0,0),t.halfHeight.set(0,.5*e.height,0),i.rectArea[d]=t,d++}else if(e.isPointLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity),t.distance=e.distance,t.decay=e.decay,e.castShadow){const t=e.shadow,n=r.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,n.shadowCameraNear=t.camera.near,n.shadowCameraFar=t.camera.far,i.pointShadow[u]=n,i.pointShadowMap[u]=_,i.pointShadowMatrix[u]=e.shadow.matrix,m++}i.point[u]=t,u++}else if(e.isHemisphereLight){const t=n.get(e);t.skyColor.copy(e.color).multiplyScalar(v),t.groundColor.copy(e.groundColor).multiplyScalar(v),i.hemi[p]=t,p++}}d>0&&(e.isWebGL2||!0===t.has("OES_texture_float_linear")?(i.rectAreaLTC1=xA.LTC_FLOAT_1,i.rectAreaLTC2=xA.LTC_FLOAT_2):!0===t.has("OES_texture_half_float_linear")?(i.rectAreaLTC1=xA.LTC_HALF_1,i.rectAreaLTC2=xA.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=o,i.ambient[1]=a,i.ambient[2]=l;const y=i.hash;y.directionalLength===c&&y.pointLength===u&&y.spotLength===h&&y.rectAreaLength===d&&y.hemiLength===p&&y.numDirectionalShadows===f&&y.numPointShadows===m&&y.numSpotShadows===g||(i.directional.length=c,i.spot.length=h,i.rectArea.length=d,i.point.length=u,i.hemi.length=p,i.directionalShadow.length=f,i.directionalShadowMap.length=f,i.pointShadow.length=m,i.pointShadowMap.length=m,i.spotShadow.length=g,i.spotShadowMap.length=g,i.directionalShadowMatrix.length=f,i.pointShadowMatrix.length=m,i.spotShadowMatrix.length=g,y.directionalLength=c,y.pointLength=u,y.spotLength=h,y.rectAreaLength=d,y.hemiLength=p,y.numDirectionalShadows=f,y.numPointShadows=m,y.numSpotShadows=g,i.version=ak++)},setupView:function(t,e){let n=0,r=0,l=0,c=0,u=0;const h=e.matrixWorldInverse;for(let d=0,p=t.length;d<p;d++){const e=t[d];if(e.isDirectionalLight){const t=i.directional[n];t.direction.setFromMatrixPosition(e.matrixWorld),s.setFromMatrixPosition(e.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(h),n++}else if(e.isSpotLight){const t=i.spot[l];t.position.setFromMatrixPosition(e.matrixWorld),t.position.applyMatrix4(h),t.direction.setFromMatrixPosition(e.matrixWorld),s.setFromMatrixPosition(e.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(h),l++}else if(e.isRectAreaLight){const t=i.rectArea[c];t.position.setFromMatrixPosition(e.matrixWorld),t.position.applyMatrix4(h),a.identity(),o.copy(e.matrixWorld),o.premultiply(h),a.extractRotation(o),t.halfWidth.set(.5*e.width,0,0),t.halfHeight.set(0,.5*e.height,0),t.halfWidth.applyMatrix4(a),t.halfHeight.applyMatrix4(a),c++}else if(e.isPointLight){const t=i.point[r];t.position.setFromMatrixPosition(e.matrixWorld),t.position.applyMatrix4(h),r++}else if(e.isHemisphereLight){const t=i.hemi[u];t.direction.setFromMatrixPosition(e.matrixWorld),t.direction.transformDirection(h),t.direction.normalize(),u++}}},state:i}}function uk(t,e){const n=new ck(t,e),r=[],i=[];return{init:function(){r.length=0,i.length=0},state:{lightsArray:r,shadowsArray:i,lights:n},setupLights:function(){n.setup(r)},setupLightsView:function(t){n.setupView(r,t)},pushLight:function(t){r.push(t)},pushShadow:function(t){i.push(t)}}}function hk(t,e){let n=new WeakMap;return{get:function(r,i=0){let s;return!1===n.has(r)?(s=new uk(t,e),n.set(r,[]),n.get(r).push(s)):i>=n.get(r).length?(s=new uk(t,e),n.get(r).push(s)):s=n.get(r)[i],s},dispose:function(){n=new WeakMap}}}function dk(t){hT.call(this),this.type="MeshDepthMaterial",this.depthPacking=3200,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(t)}function pk(t){hT.call(this),this.type="MeshDistanceMaterial",this.referencePosition=new VE,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(t)}function fk(t,e,n){let r=new gA;const i=new IE,s=new IE,o=new $E,a=[],l=[],c={},u={0:1,1:0,2:2},h=new oA({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new IE},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),d=h.clone();d.defines.HORIZONTAL_PASS=1;const p=new FT;p.setAttribute("position",new mT(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const f=new tA(p,h),m=this;function g(n,r){const i=e.update(f);h.uniforms.shadow_pass.value=n.map.texture,h.uniforms.resolution.value=n.mapSize,h.uniforms.radius.value=n.radius,t.setRenderTarget(n.mapPass),t.clear(),t.renderBufferDirect(r,null,i,h,f,null),d.uniforms.shadow_pass.value=n.mapPass.texture,d.uniforms.resolution.value=n.mapSize,d.uniforms.radius.value=n.radius,t.setRenderTarget(n.map),t.clear(),t.renderBufferDirect(r,null,i,d,f,null)}function y(t,e,n){const r=t<<0|e<<1|n<<2;let i=a[r];return void 0===i&&(i=new dk({depthPacking:3201,morphTargets:t,skinning:e}),a[r]=i),i}function v(t,e,n){const r=t<<0|e<<1|n<<2;let i=l[r];return void 0===i&&(i=new pk({morphTargets:t,skinning:e}),l[r]=i),i}function b(e,n,r,i,s,o,a){let l=null,h=y,d=e.customDepthMaterial;if(!0===i.isPointLight&&(h=v,d=e.customDistanceMaterial),void 0===d){let t=!1;!0===r.morphTargets&&(t=n.morphAttributes&&n.morphAttributes.position&&n.morphAttributes.position.length>0);let i=!1;!0===e.isSkinnedMesh&&(!0===r.skinning?i=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",e)),l=h(t,i,!0===e.isInstancedMesh)}else l=d;if(t.localClippingEnabled&&!0===r.clipShadows&&0!==r.clippingPlanes.length){const t=l.uuid,e=r.uuid;let n=c[t];void 0===n&&(n={},c[t]=n);let i=n[e];void 0===i&&(i=l.clone(),n[e]=i),l=i}return l.visible=r.visible,l.wireframe=r.wireframe,l.side=3===a?null!==r.shadowSide?r.shadowSide:r.side:null!==r.shadowSide?r.shadowSide:u[r.side],l.clipShadows=r.clipShadows,l.clippingPlanes=r.clippingPlanes,l.clipIntersection=r.clipIntersection,l.wireframeLinewidth=r.wireframeLinewidth,l.linewidth=r.linewidth,!0===i.isPointLight&&!0===l.isMeshDistanceMaterial&&(l.referencePosition.setFromMatrixPosition(i.matrixWorld),l.nearDistance=s,l.farDistance=o),l}function _(n,i,s,o,a){if(!1===n.visible)return;if(n.layers.test(i.layers)&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&3===a)&&(!n.frustumCulled||r.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,n.matrixWorld);const r=e.update(n),i=n.material;if(Array.isArray(i)){const e=r.groups;for(let l=0,c=e.length;l<c;l++){const c=e[l],u=i[c.materialIndex];if(u&&u.visible){const e=b(n,r,u,o,s.near,s.far,a);t.renderBufferDirect(s,null,r,e,n,c)}}}else if(i.visible){const e=b(n,r,i,o,s.near,s.far,a);t.renderBufferDirect(s,null,r,e,n,null)}}const l=n.children;for(let t=0,e=l.length;t<e;t++)_(l[t],i,s,o,a)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function(e,a,l){if(!1===m.enabled)return;if(!1===m.autoUpdate&&!1===m.needsUpdate)return;if(0===e.length)return;const c=t.getRenderTarget(),u=t.getActiveCubeFace(),h=t.getActiveMipmapLevel(),d=t.state;d.setBlending(0),d.buffers.color.setClear(1,1,1,1),d.buffers.depth.setTest(!0),d.setScissorTest(!1);for(let p=0,f=e.length;p<f;p++){const c=e[p],u=c.shadow;if(void 0===u){console.warn("THREE.WebGLShadowMap:",c,"has no shadow.");continue}if(!1===u.autoUpdate&&!1===u.needsUpdate)continue;i.copy(u.mapSize);const h=u.getFrameExtents();if(i.multiply(h),s.copy(u.mapSize),(i.x>n||i.y>n)&&(i.x>n&&(s.x=Math.floor(n/h.x),i.x=s.x*h.x,u.mapSize.x=s.x),i.y>n&&(s.y=Math.floor(n/h.y),i.y=s.y*h.y,u.mapSize.y=s.y)),null===u.map&&!u.isPointLightShadow&&3===this.type){const t={minFilter:sE,magFilter:sE,format:pE};u.map=new BE(i.x,i.y,t),u.map.texture.name=c.name+".shadowMap",u.mapPass=new BE(i.x,i.y,t),u.camera.updateProjectionMatrix()}null===u.map&&(u.map=new BE(i.x,i.y,{minFilter:iE,magFilter:iE,format:pE}),u.map.texture.name=c.name+".shadowMap",u.camera.updateProjectionMatrix()),t.setRenderTarget(u.map),t.clear();const f=u.getViewportCount();for(let t=0;t<f;t++){const e=u.getViewport(t);o.set(s.x*e.x,s.y*e.y,s.x*e.z,s.y*e.w),d.viewport(o),u.updateMatrices(c,t),r=u.getFrustum(),_(a,l,u.camera,c,this.type)}u.isPointLightShadow||3!==this.type||g(u,l),u.needsUpdate=!1}m.needsUpdate=!1,t.setRenderTarget(c,u,h)}}function mk(t,e,n){const r=n.isWebGL2,i=new function(){let e=!1;const n=new $E;let r=null;const i=new $E(0,0,0,0);return{setMask:function(n){r===n||e||(t.colorMask(n,n,n,n),r=n)},setLocked:function(t){e=t},setClear:function(e,r,s,o,a){!0===a&&(e*=o,r*=o,s*=o),n.set(e,r,s,o),!1===i.equals(n)&&(t.clearColor(e,r,s,o),i.copy(n))},reset:function(){e=!1,r=null,i.set(-1,0,0,0)}}},s=new function(){let e=!1,n=null,r=null,i=null;return{setTest:function(t){t?O(2929):D(2929)},setMask:function(r){n===r||e||(t.depthMask(r),n=r)},setFunc:function(e){if(r!==e){if(e)switch(e){case 0:t.depthFunc(512);break;case 1:t.depthFunc(519);break;case 2:t.depthFunc(513);break;case 3:t.depthFunc(515);break;case 4:t.depthFunc(514);break;case 5:t.depthFunc(518);break;case 6:t.depthFunc(516);break;case 7:t.depthFunc(517);break;default:t.depthFunc(515)}else t.depthFunc(515);r=e}},setLocked:function(t){e=t},setClear:function(e){i!==e&&(t.clearDepth(e),i=e)},reset:function(){e=!1,n=null,r=null,i=null}}},o=new function(){let e=!1,n=null,r=null,i=null,s=null,o=null,a=null,l=null,c=null;return{setTest:function(t){e||(t?O(2960):D(2960))},setMask:function(r){n===r||e||(t.stencilMask(r),n=r)},setFunc:function(e,n,o){r===e&&i===n&&s===o||(t.stencilFunc(e,n,o),r=e,i=n,s=o)},setOp:function(e,n,r){o===e&&a===n&&l===r||(t.stencilOp(e,n,r),o=e,a=n,l=r)},setLocked:function(t){e=t},setClear:function(e){c!==e&&(t.clearStencil(e),c=e)},reset:function(){e=!1,n=null,r=null,i=null,s=null,o=null,a=null,l=null,c=null}}};let a={},l=null,c=null,u=null,h=null,d=null,p=null,f=null,m=null,g=null,y=!1,v=null,b=null,_=null,x=null,w=null;const S=t.getParameter(35661);let E=!1,C=0;const T=t.getParameter(7938);-1!==T.indexOf("WebGL")?(C=parseFloat(/^WebGL (\d)/.exec(T)[1]),E=C>=1):-1!==T.indexOf("OpenGL ES")&&(C=parseFloat(/^OpenGL ES (\d)/.exec(T)[1]),E=C>=2);let A=null,M={};const k=new $E,R=new $E;function I(e,n,r){const i=new Uint8Array(4),s=t.createTexture();t.bindTexture(e,s),t.texParameteri(e,10241,9728),t.texParameteri(e,10240,9728);for(let o=0;o<r;o++)t.texImage2D(n+o,0,6408,1,1,0,6408,5121,i);return s}const N={};function O(e){!0!==a[e]&&(t.enable(e),a[e]=!0)}function D(e){!1!==a[e]&&(t.disable(e),a[e]=!1)}N[3553]=I(3553,3553,1),N[34067]=I(34067,34069,6),i.setClear(0,0,0,1),s.setClear(1),o.setClear(0),O(2929),s.setFunc(3),$(!1),B(1),O(2884),P(0);const L={[tE]:32774,101:32778,102:32779};if(r)L[103]=32775,L[104]=32776;else{const t=e.get("EXT_blend_minmax");null!==t&&(L[103]=t.MIN_EXT,L[104]=t.MAX_EXT)}const F={200:0,201:1,202:768,204:770,210:776,208:774,206:772,203:769,205:771,209:775,207:773};function P(e,n,r,i,s,o,a,l){if(0!==e){if(c||(O(3042),c=!0),5===e)s=s||n,o=o||r,a=a||i,n===h&&s===f||(t.blendEquationSeparate(L[n],L[s]),h=n,f=s),r===d&&i===p&&o===m&&a===g||(t.blendFuncSeparate(F[r],F[i],F[o],F[a]),d=r,p=i,m=o,g=a),u=e,y=null;else if(e!==u||l!==y){if(h===tE&&f===tE||(t.blendEquation(32774),h=tE,f=tE),l)switch(e){case 1:t.blendFuncSeparate(1,771,1,771);break;case 2:t.blendFunc(1,1);break;case 3:t.blendFuncSeparate(0,0,769,771);break;case 4:t.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}else switch(e){case 1:t.blendFuncSeparate(770,771,1,771);break;case 2:t.blendFunc(770,1);break;case 3:t.blendFunc(0,769);break;case 4:t.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}d=null,p=null,m=null,g=null,u=e,y=l}}else c&&(D(3042),c=!1)}function $(e){v!==e&&(t.frontFace(e?2304:2305),v=e)}function B(e){0!==e?(O(2884),e!==b&&t.cullFace(1===e?1029:2===e?1028:1032)):D(2884),b=e}function z(e,n,r){e?(O(32823),x===n&&w===r||(t.polygonOffset(n,r),x=n,w=r)):D(32823)}function V(e){void 0===e&&(e=33984+S-1),A!==e&&(t.activeTexture(e),A=e)}return{buffers:{color:i,depth:s,stencil:o},enable:O,disable:D,useProgram:function(e){return l!==e&&(t.useProgram(e),l=e,!0)},setBlending:P,setMaterial:function(t,e){2===t.side?D(2884):O(2884);let n=1===t.side;e&&(n=!n),$(n),1===t.blending&&!1===t.transparent?P(0):P(t.blending,t.blendEquation,t.blendSrc,t.blendDst,t.blendEquationAlpha,t.blendSrcAlpha,t.blendDstAlpha,t.premultipliedAlpha),s.setFunc(t.depthFunc),s.setTest(t.depthTest),s.setMask(t.depthWrite),i.setMask(t.colorWrite);const r=t.stencilWrite;o.setTest(r),r&&(o.setMask(t.stencilWriteMask),o.setFunc(t.stencilFunc,t.stencilRef,t.stencilFuncMask),o.setOp(t.stencilFail,t.stencilZFail,t.stencilZPass)),z(t.polygonOffset,t.polygonOffsetFactor,t.polygonOffsetUnits)},setFlipSided:$,setCullFace:B,setLineWidth:function(e){e!==_&&(E&&t.lineWidth(e),_=e)},setPolygonOffset:z,setScissorTest:function(t){t?O(3089):D(3089)},activeTexture:V,bindTexture:function(e,n){null===A&&V();let r=M[A];void 0===r&&(r={type:void 0,texture:void 0},M[A]=r),r.type===e&&r.texture===n||(t.bindTexture(e,n||N[e]),r.type=e,r.texture=n)},unbindTexture:function(){const e=M[A];void 0!==e&&void 0!==e.type&&(t.bindTexture(e.type,null),e.type=void 0,e.texture=void 0)},compressedTexImage2D:function(){try{t.compressedTexImage2D.apply(t,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage2D:function(){try{t.texImage2D.apply(t,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage3D:function(){try{t.texImage3D.apply(t,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},scissor:function(e){!1===k.equals(e)&&(t.scissor(e.x,e.y,e.z,e.w),k.copy(e))},viewport:function(e){!1===R.equals(e)&&(t.viewport(e.x,e.y,e.z,e.w),R.copy(e))},reset:function(){a={},A=null,M={},l=null,c=null,u=null,h=null,d=null,p=null,f=null,m=null,g=null,y=!1,v=null,b=null,_=null,x=null,w=null,i.reset(),s.reset(),o.reset()}}}function gk(t,e,n,r,i,s,o){const a=i.isWebGL2,l=i.maxTextures,c=i.maxCubemapSize,u=i.maxTextureSize,h=i.maxSamples,d=new WeakMap;let p,f=!1;try{f="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(P){}function m(t,e){return f?new OffscreenCanvas(t,e):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function g(t,e,n,r){let i=1;if((t.width>r||t.height>r)&&(i=r/Math.max(t.width,t.height)),i<1||!0===e){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const r=e?RE.floorPowerOfTwo:Math.floor,s=r(i*t.width),o=r(i*t.height);void 0===p&&(p=m(s,o));const a=n?m(s,o):p;return a.width=s,a.height=o,a.getContext("2d").drawImage(t,0,0,s,o),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+t.width+"x"+t.height+") to ("+s+"x"+o+")."),a}return"data"in t&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+t.width+"x"+t.height+")."),t}return t}function y(t){return RE.isPowerOfTwo(t.width)&&RE.isPowerOfTwo(t.height)}function v(t,e){return t.generateMipmaps&&e&&t.minFilter!==iE&&t.minFilter!==sE}function b(e,n,i,s){t.generateMipmap(e),r.get(n).__maxMipLevel=Math.log(Math.max(i,s))*Math.LOG2E}function _(n,r,i){if(!1===a)return r;if(null!==n){if(void 0!==t[n])return t[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let s=r;return 6403===r&&(5126===i&&(s=33326),5131===i&&(s=33325),5121===i&&(s=33321)),6407===r&&(5126===i&&(s=34837),5131===i&&(s=34843),5121===i&&(s=32849)),6408===r&&(5126===i&&(s=34836),5131===i&&(s=34842),5121===i&&(s=32856)),33325!==s&&33326!==s&&34842!==s&&34836!==s||e.get("EXT_color_buffer_float"),s}function x(t){return t===iE||1004===t||1005===t?9728:9729}function w(e){const n=e.target;n.removeEventListener("dispose",w),function(e){const n=r.get(e);void 0!==n.__webglInit&&(t.deleteTexture(n.__webglTexture),r.remove(e))}(n),n.isVideoTexture&&d.delete(n),o.memory.textures--}function S(e){const n=e.target;n.removeEventListener("dispose",S),function(e){const n=r.get(e),i=r.get(e.texture);if(e){if(void 0!==i.__webglTexture&&t.deleteTexture(i.__webglTexture),e.depthTexture&&e.depthTexture.dispose(),e.isWebGLCubeRenderTarget)for(let e=0;e<6;e++)t.deleteFramebuffer(n.__webglFramebuffer[e]),n.__webglDepthbuffer&&t.deleteRenderbuffer(n.__webglDepthbuffer[e]);else t.deleteFramebuffer(n.__webglFramebuffer),n.__webglDepthbuffer&&t.deleteRenderbuffer(n.__webglDepthbuffer),n.__webglMultisampledFramebuffer&&t.deleteFramebuffer(n.__webglMultisampledFramebuffer),n.__webglColorRenderbuffer&&t.deleteRenderbuffer(n.__webglColorRenderbuffer),n.__webglDepthRenderbuffer&&t.deleteRenderbuffer(n.__webglDepthRenderbuffer);r.remove(e.texture),r.remove(e)}}(n),o.memory.textures--}let E=0;function C(t,e){const i=r.get(t);if(t.isVideoTexture&&function(t){const e=o.render.frame;d.get(t)!==e&&(d.set(t,e),t.update())}(t),t.version>0&&i.__version!==t.version){const n=t.image;if(void 0===n)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else{if(!1!==n.complete)return void I(i,t,e);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.activeTexture(33984+e),n.bindTexture(3553,i.__webglTexture)}function T(e,i){const o=r.get(e);e.version>0&&o.__version!==e.version?function(e,r,i){if(6!==r.image.length)return;R(e,r),n.activeTexture(33984+i),n.bindTexture(34067,e.__webglTexture),t.pixelStorei(37440,r.flipY),t.pixelStorei(37441,r.premultiplyAlpha),t.pixelStorei(3317,r.unpackAlignment);const o=r&&(r.isCompressedTexture||r.image[0].isCompressedTexture),l=r.image[0]&&r.image[0].isDataTexture,u=[];for(let t=0;t<6;t++)u[t]=o||l?l?r.image[t].image:r.image[t]:g(r.image[t],!1,!0,c);const h=u[0],d=y(h)||a,p=s.convert(r.format),f=s.convert(r.type),m=_(r.internalFormat,p,f);let x;if(k(34067,r,d),o){for(let t=0;t<6;t++){x=u[t].mipmaps;for(let e=0;e<x.length;e++){const i=x[e];r.format!==pE&&r.format!==dE?null!==p?n.compressedTexImage2D(34069+t,e,m,i.width,i.height,0,i.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):n.texImage2D(34069+t,e,m,i.width,i.height,0,p,f,i.data)}}e.__maxMipLevel=x.length-1}else{x=r.mipmaps;for(let t=0;t<6;t++)if(l){n.texImage2D(34069+t,0,m,u[t].width,u[t].height,0,p,f,u[t].data);for(let e=0;e<x.length;e++){const r=x[e].image[t].image;n.texImage2D(34069+t,e+1,m,r.width,r.height,0,p,f,r.data)}}else{n.texImage2D(34069+t,0,m,p,f,u[t]);for(let e=0;e<x.length;e++)n.texImage2D(34069+t,e+1,m,p,f,x[e].image[t])}e.__maxMipLevel=x.length}v(r,d)&&b(34067,r,h.width,h.height),e.__version=r.version,r.onUpdate&&r.onUpdate(r)}(o,e,i):(n.activeTexture(33984+i),n.bindTexture(34067,o.__webglTexture))}const A={[eE]:10497,[nE]:33071,[rE]:33648},M={[iE]:9728,1004:9984,1005:9986,[sE]:9729,1007:9985,[oE]:9987};function k(n,s,o){o?(t.texParameteri(n,10242,A[s.wrapS]),t.texParameteri(n,10243,A[s.wrapT]),32879!==n&&35866!==n||t.texParameteri(n,32882,A[s.wrapR]),t.texParameteri(n,10240,M[s.magFilter]),t.texParameteri(n,10241,M[s.minFilter])):(t.texParameteri(n,10242,33071),t.texParameteri(n,10243,33071),32879!==n&&35866!==n||t.texParameteri(n,32882,33071),s.wrapS===nE&&s.wrapT===nE||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),t.texParameteri(n,10240,x(s.magFilter)),t.texParameteri(n,10241,x(s.minFilter)),s.minFilter!==iE&&s.minFilter!==sE&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));const l=e.get("EXT_texture_filter_anisotropic");if(l){if(s.type===cE&&null===e.get("OES_texture_float_linear"))return;if(s.type===uE&&null===(a||e.get("OES_texture_half_float_linear")))return;(s.anisotropy>1||r.get(s).__currentAnisotropy)&&(t.texParameterf(n,l.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(s.anisotropy,i.getMaxAnisotropy())),r.get(s).__currentAnisotropy=s.anisotropy)}}function R(e,n){void 0===e.__webglInit&&(e.__webglInit=!0,n.addEventListener("dispose",w),e.__webglTexture=t.createTexture(),o.memory.textures++)}function I(e,r,i){let o=3553;r.isDataTexture2DArray&&(o=35866),r.isDataTexture3D&&(o=32879),R(e,r),n.activeTexture(33984+i),n.bindTexture(o,e.__webglTexture),t.pixelStorei(37440,r.flipY),t.pixelStorei(37441,r.premultiplyAlpha),t.pixelStorei(3317,r.unpackAlignment);const l=function(t){return!a&&(t.wrapS!==nE||t.wrapT!==nE||t.minFilter!==iE&&t.minFilter!==sE)}(r)&&!1===y(r.image),c=g(r.image,l,!1,u),h=y(c)||a,d=s.convert(r.format);let p,f=s.convert(r.type),m=_(r.internalFormat,d,f);k(o,r,h);const x=r.mipmaps;if(r.isDepthTexture)m=6402,a?m=r.type===cE?36012:r.type===lE?33190:r.type===hE?35056:33189:r.type===cE&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),r.format===fE&&6402===m&&r.type!==aE&&r.type!==lE&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),r.type=aE,f=s.convert(r.type)),r.format===mE&&6402===m&&(m=34041,r.type!==hE&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),r.type=hE,f=s.convert(r.type))),n.texImage2D(3553,0,m,c.width,c.height,0,d,f,null);else if(r.isDataTexture)if(x.length>0&&h){for(let t=0,e=x.length;t<e;t++)p=x[t],n.texImage2D(3553,t,m,p.width,p.height,0,d,f,p.data);r.generateMipmaps=!1,e.__maxMipLevel=x.length-1}else n.texImage2D(3553,0,m,c.width,c.height,0,d,f,c.data),e.__maxMipLevel=0;else if(r.isCompressedTexture){for(let t=0,e=x.length;t<e;t++)p=x[t],r.format!==pE&&r.format!==dE?null!==d?n.compressedTexImage2D(3553,t,m,p.width,p.height,0,p.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):n.texImage2D(3553,t,m,p.width,p.height,0,d,f,p.data);e.__maxMipLevel=x.length-1}else if(r.isDataTexture2DArray)n.texImage3D(35866,0,m,c.width,c.height,c.depth,0,d,f,c.data),e.__maxMipLevel=0;else if(r.isDataTexture3D)n.texImage3D(32879,0,m,c.width,c.height,c.depth,0,d,f,c.data),e.__maxMipLevel=0;else if(x.length>0&&h){for(let t=0,e=x.length;t<e;t++)p=x[t],n.texImage2D(3553,t,m,d,f,p);r.generateMipmaps=!1,e.__maxMipLevel=x.length-1}else n.texImage2D(3553,0,m,d,f,c),e.__maxMipLevel=0;v(r,h)&&b(o,r,c.width,c.height),e.__version=r.version,r.onUpdate&&r.onUpdate(r)}function N(e,i,o,a){const l=s.convert(i.texture.format),c=s.convert(i.texture.type),u=_(i.texture.internalFormat,l,c);n.texImage2D(a,0,u,i.width,i.height,0,l,c,null),t.bindFramebuffer(36160,e),t.framebufferTexture2D(36160,o,a,r.get(i.texture).__webglTexture,0),t.bindFramebuffer(36160,null)}function O(e,n,r){if(t.bindRenderbuffer(36161,e),n.depthBuffer&&!n.stencilBuffer){let i=33189;if(r){const e=n.depthTexture;e&&e.isDepthTexture&&(e.type===cE?i=36012:e.type===lE&&(i=33190));const r=D(n);t.renderbufferStorageMultisample(36161,r,i,n.width,n.height)}else t.renderbufferStorage(36161,i,n.width,n.height);t.framebufferRenderbuffer(36160,36096,36161,e)}else if(n.depthBuffer&&n.stencilBuffer){if(r){const e=D(n);t.renderbufferStorageMultisample(36161,e,35056,n.width,n.height)}else t.renderbufferStorage(36161,34041,n.width,n.height);t.framebufferRenderbuffer(36160,33306,36161,e)}else{const e=s.convert(n.texture.format),i=s.convert(n.texture.type),o=_(n.texture.internalFormat,e,i);if(r){const e=D(n);t.renderbufferStorageMultisample(36161,e,o,n.width,n.height)}else t.renderbufferStorage(36161,o,n.width,n.height)}t.bindRenderbuffer(36161,null)}function D(t){return a&&t.isWebGLMultisampleRenderTarget?Math.min(h,t.samples):0}let L=!1,F=!1;this.allocateTextureUnit=function(){const t=E;return t>=l&&console.warn("THREE.WebGLTextures: Trying to use "+t+" texture units while this GPU supports only "+l),E+=1,t},this.resetTextureUnits=function(){E=0},this.setTexture2D=C,this.setTexture2DArray=function(t,e){const i=r.get(t);t.version>0&&i.__version!==t.version?I(i,t,e):(n.activeTexture(33984+e),n.bindTexture(35866,i.__webglTexture))},this.setTexture3D=function(t,e){const i=r.get(t);t.version>0&&i.__version!==t.version?I(i,t,e):(n.activeTexture(33984+e),n.bindTexture(32879,i.__webglTexture))},this.setTextureCube=T,this.setupRenderTarget=function(e){const i=r.get(e),l=r.get(e.texture);e.addEventListener("dispose",S),l.__webglTexture=t.createTexture(),o.memory.textures++;const c=!0===e.isWebGLCubeRenderTarget,u=!0===e.isWebGLMultisampleRenderTarget,h=y(e)||a;if(!a||e.texture.format!==dE||e.texture.type!==cE&&e.texture.type!==uE||(e.texture.format=pE,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),c){i.__webglFramebuffer=[];for(let e=0;e<6;e++)i.__webglFramebuffer[e]=t.createFramebuffer()}else if(i.__webglFramebuffer=t.createFramebuffer(),u)if(a){i.__webglMultisampledFramebuffer=t.createFramebuffer(),i.__webglColorRenderbuffer=t.createRenderbuffer(),t.bindRenderbuffer(36161,i.__webglColorRenderbuffer);const n=s.convert(e.texture.format),r=s.convert(e.texture.type),o=_(e.texture.internalFormat,n,r),a=D(e);t.renderbufferStorageMultisample(36161,a,o,e.width,e.height),t.bindFramebuffer(36160,i.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(36160,36064,36161,i.__webglColorRenderbuffer),t.bindRenderbuffer(36161,null),e.depthBuffer&&(i.__webglDepthRenderbuffer=t.createRenderbuffer(),O(i.__webglDepthRenderbuffer,e,!0)),t.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(c){n.bindTexture(34067,l.__webglTexture),k(34067,e.texture,h);for(let t=0;t<6;t++)N(i.__webglFramebuffer[t],e,36064,34069+t);v(e.texture,h)&&b(34067,e.texture,e.width,e.height),n.bindTexture(34067,null)}else n.bindTexture(3553,l.__webglTexture),k(3553,e.texture,h),N(i.__webglFramebuffer,e,36064,3553),v(e.texture,h)&&b(3553,e.texture,e.width,e.height),n.bindTexture(3553,null);e.depthBuffer&&function(e){const n=r.get(e),i=!0===e.isWebGLCubeRenderTarget;if(e.depthTexture){if(i)throw new Error("target.depthTexture not supported in Cube render targets");!function(e,n){if(n&&n.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,e),!n.depthTexture||!n.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");r.get(n.depthTexture).__webglTexture&&n.depthTexture.image.width===n.width&&n.depthTexture.image.height===n.height||(n.depthTexture.image.width=n.width,n.depthTexture.image.height=n.height,n.depthTexture.needsUpdate=!0),C(n.depthTexture,0);const i=r.get(n.depthTexture).__webglTexture;if(n.depthTexture.format===fE)t.framebufferTexture2D(36160,36096,3553,i,0);else{if(n.depthTexture.format!==mE)throw new Error("Unknown depthTexture format");t.framebufferTexture2D(36160,33306,3553,i,0)}}(n.__webglFramebuffer,e)}else if(i){n.__webglDepthbuffer=[];for(let r=0;r<6;r++)t.bindFramebuffer(36160,n.__webglFramebuffer[r]),n.__webglDepthbuffer[r]=t.createRenderbuffer(),O(n.__webglDepthbuffer[r],e,!1)}else t.bindFramebuffer(36160,n.__webglFramebuffer),n.__webglDepthbuffer=t.createRenderbuffer(),O(n.__webglDepthbuffer,e,!1);t.bindFramebuffer(36160,null)}(e)},this.updateRenderTargetMipmap=function(t){const e=t.texture;if(v(e,y(t)||a)){const i=t.isWebGLCubeRenderTarget?34067:3553,s=r.get(e).__webglTexture;n.bindTexture(i,s),b(i,e,t.width,t.height),n.bindTexture(i,null)}},this.updateMultisampleRenderTarget=function(e){if(e.isWebGLMultisampleRenderTarget)if(a){const n=r.get(e);t.bindFramebuffer(36008,n.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,n.__webglFramebuffer);const i=e.width,s=e.height;let o=16384;e.depthBuffer&&(o|=256),e.stencilBuffer&&(o|=1024),t.blitFramebuffer(0,0,i,s,0,0,i,s,o,9728),t.bindFramebuffer(36160,n.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")},this.safeSetTexture2D=function(t,e){t&&t.isWebGLRenderTarget&&(!1===L&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),L=!0),t=t.texture),C(t,e)},this.safeSetTextureCube=function(t,e){t&&t.isWebGLCubeRenderTarget&&(!1===F&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),F=!0),t=t.texture),T(t,e)}}function yk(t,e,n){const r=n.isWebGL2;return{convert:function(t){let n;if(1009===t)return 5121;if(1017===t)return 32819;if(1018===t)return 32820;if(1019===t)return 33635;if(1010===t)return 5120;if(1011===t)return 5122;if(t===aE)return 5123;if(1013===t)return 5124;if(t===lE)return 5125;if(t===cE)return 5126;if(t===uE)return r?5131:(n=e.get("OES_texture_half_float"),null!==n?n.HALF_FLOAT_OES:null);if(1021===t)return 6406;if(t===dE)return 6407;if(t===pE)return 6408;if(1024===t)return 6409;if(1025===t)return 6410;if(t===fE)return 6402;if(t===mE)return 34041;if(1028===t)return 6403;if(1029===t)return 36244;if(1030===t)return 33319;if(1031===t)return 33320;if(1032===t)return 36248;if(1033===t)return 36249;if(33776===t||33777===t||33778===t||33779===t){if(n=e.get("WEBGL_compressed_texture_s3tc"),null===n)return null;if(33776===t)return n.COMPRESSED_RGB_S3TC_DXT1_EXT;if(33777===t)return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(33778===t)return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(33779===t)return n.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(35840===t||35841===t||35842===t||35843===t){if(n=e.get("WEBGL_compressed_texture_pvrtc"),null===n)return null;if(35840===t)return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(35841===t)return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(35842===t)return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(35843===t)return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(36196===t)return n=e.get("WEBGL_compressed_texture_etc1"),null!==n?n.COMPRESSED_RGB_ETC1_WEBGL:null;if((37492===t||37496===t)&&(n=e.get("WEBGL_compressed_texture_etc"),null!==n)){if(37492===t)return n.COMPRESSED_RGB8_ETC2;if(37496===t)return n.COMPRESSED_RGBA8_ETC2_EAC}return 37808===t||37809===t||37810===t||37811===t||37812===t||37813===t||37814===t||37815===t||37816===t||37817===t||37818===t||37819===t||37820===t||37821===t||37840===t||37841===t||37842===t||37843===t||37844===t||37845===t||37846===t||37847===t||37848===t||37849===t||37850===t||37851===t||37852===t||37853===t?(n=e.get("WEBGL_compressed_texture_astc"),null!==n?t:null):36492===t?(n=e.get("EXT_texture_compression_bptc"),null!==n?t:null):t===hE?r?34042:(n=e.get("WEBGL_depth_texture"),null!==n?n.UNSIGNED_INT_24_8_WEBGL:null):void 0}}}function vk(t=[]){lA.call(this),this.cameras=t}function bk(){zC.call(this),this.type="Group"}function _k(){this._targetRay=null,this._grip=null,this._hand=null}function xk(t,e){const n=this;let r=null,i=1,s=null,o="local-floor",a=null;const l=[],c=new Map,u=new lA;u.layers.enable(1),u.viewport=new $E;const h=new lA;h.layers.enable(2),h.viewport=new $E;const d=[u,h],p=new vk;p.layers.enable(1),p.layers.enable(2);let f=null,m=null;function g(t){const e=c.get(t.inputSource);e&&e.dispatchEvent({type:t.type,data:t.inputSource})}function y(){c.forEach(function(t,e){t.disconnect(e)}),c.clear(),f=null,m=null,t.setFramebuffer(null),t.setRenderTarget(t.getRenderTarget()),S.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function v(t){const e=r.inputSources;for(let n=0;n<l.length;n++)c.set(e[n],l[n]);for(let n=0;n<t.removed.length;n++){const e=t.removed[n],r=c.get(e);r&&(r.dispatchEvent({type:"disconnected",data:e}),c.delete(e))}for(let n=0;n<t.added.length;n++){const e=t.added[n],r=c.get(e);r&&r.dispatchEvent({type:"connected",data:e})}}this.enabled=!1,this.isPresenting=!1,this.getController=function(t){let e=l[t];return void 0===e&&(e=new _k,l[t]=e),e.getTargetRaySpace()},this.getControllerGrip=function(t){let e=l[t];return void 0===e&&(e=new _k,l[t]=e),e.getGripSpace()},this.getHand=function(t){let e=l[t];return void 0===e&&(e=new _k,l[t]=e),e.getHandSpace()},this.setFramebufferScaleFactor=function(t){i=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(t){o=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return s},this.getSession=function(){return r},this.setSession=async function(t){if(r=t,null!==r){r.addEventListener("select",g),r.addEventListener("selectstart",g),r.addEventListener("selectend",g),r.addEventListener("squeeze",g),r.addEventListener("squeezestart",g),r.addEventListener("squeezeend",g),r.addEventListener("end",y),r.addEventListener("inputsourceschange",v);const t=e.getContextAttributes();!0!==t.xrCompatible&&await e.makeXRCompatible();const a=new XRWebGLLayer(r,e,{antialias:t.antialias,alpha:t.alpha,depth:t.depth,stencil:t.stencil,framebufferScaleFactor:i});r.updateRenderState({baseLayer:a}),s=await r.requestReferenceSpace(o),S.setContext(r),S.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};const b=new VE,_=new VE;function x(t,e){null===e?t.matrixWorld.copy(t.matrix):t.matrixWorld.multiplyMatrices(e.matrixWorld,t.matrix),t.matrixWorldInverse.copy(t.matrixWorld).invert()}this.getCamera=function(t){p.near=h.near=u.near=t.near,p.far=h.far=u.far=t.far,f===p.near&&m===p.far||(r.updateRenderState({depthNear:p.near,depthFar:p.far}),f=p.near,m=p.far);const e=t.parent,n=p.cameras;x(p,e);for(let r=0;r<n.length;r++)x(n[r],e);t.matrixWorld.copy(p.matrixWorld),t.matrix.copy(p.matrix),t.matrix.decompose(t.position,t.quaternion,t.scale);const i=t.children;for(let r=0,s=i.length;r<s;r++)i[r].updateMatrixWorld(!0);return 2===n.length?function(t,e,n){b.setFromMatrixPosition(e.matrixWorld),_.setFromMatrixPosition(n.matrixWorld);const r=b.distanceTo(_),i=e.projectionMatrix.elements,s=n.projectionMatrix.elements,o=i[14]/(i[10]-1),a=i[14]/(i[10]+1),l=(i[9]+1)/i[5],c=(i[9]-1)/i[5],u=(i[8]-1)/i[0],h=(s[8]+1)/s[0],d=o*u,p=o*h,f=r/(-u+h),m=f*-u;e.matrixWorld.decompose(t.position,t.quaternion,t.scale),t.translateX(m),t.translateZ(f),t.matrixWorld.compose(t.position,t.quaternion,t.scale),t.matrixWorldInverse.copy(t.matrixWorld).invert();const g=o+f,y=a+f;t.projectionMatrix.makePerspective(d-m,p+(r-m),l*a/y*g,c*a/y*g,g,y)}(p,u,h):p.projectionMatrix.copy(u.projectionMatrix),p};let w=null;const S=new yA;S.setAnimationLoop(function(e,n){if(a=n.getViewerPose(s),null!==a){const e=a.views,n=r.renderState.baseLayer;t.setFramebuffer(n.framebuffer);let i=!1;e.length!==p.cameras.length&&(p.cameras.length=0,i=!0);for(let t=0;t<e.length;t++){const r=e[t],s=n.getViewport(r),o=d[t];o.matrix.fromArray(r.transform.matrix),o.projectionMatrix.fromArray(r.projectionMatrix),o.viewport.set(s.x,s.y,s.width,s.height),0===t&&p.matrix.copy(o.matrix),!0===i&&p.cameras.push(o)}}const i=r.inputSources;for(let t=0;t<l.length;t++)l[t].update(i[t],n,s);w&&w(e,n)}),this.setAnimationLoop=function(t){w=t},this.dispose=function(){}}function wk(t){function e(e,n){e.opacity.value=n.opacity,n.color&&e.diffuse.value.copy(n.color),n.emissive&&e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),n.map&&(e.map.value=n.map),n.alphaMap&&(e.alphaMap.value=n.alphaMap),n.specularMap&&(e.specularMap.value=n.specularMap);const r=t.get(n).envMap;if(r){e.envMap.value=r,e.flipEnvMap.value=r.isCubeTexture&&r._needsFlipEnvMap?-1:1,e.reflectivity.value=n.reflectivity,e.refractionRatio.value=n.refractionRatio;const i=t.get(r).__maxMipLevel;void 0!==i&&(e.maxMipLevel.value=i)}let i,s;n.lightMap&&(e.lightMap.value=n.lightMap,e.lightMapIntensity.value=n.lightMapIntensity),n.aoMap&&(e.aoMap.value=n.aoMap,e.aoMapIntensity.value=n.aoMapIntensity),n.map?i=n.map:n.specularMap?i=n.specularMap:n.displacementMap?i=n.displacementMap:n.normalMap?i=n.normalMap:n.bumpMap?i=n.bumpMap:n.roughnessMap?i=n.roughnessMap:n.metalnessMap?i=n.metalnessMap:n.alphaMap?i=n.alphaMap:n.emissiveMap?i=n.emissiveMap:n.clearcoatMap?i=n.clearcoatMap:n.clearcoatNormalMap?i=n.clearcoatNormalMap:n.clearcoatRoughnessMap&&(i=n.clearcoatRoughnessMap),void 0!==i&&(i.isWebGLRenderTarget&&(i=i.texture),!0===i.matrixAutoUpdate&&i.updateMatrix(),e.uvTransform.value.copy(i.matrix)),n.aoMap?s=n.aoMap:n.lightMap&&(s=n.lightMap),void 0!==s&&(s.isWebGLRenderTarget&&(s=s.texture),!0===s.matrixAutoUpdate&&s.updateMatrix(),e.uv2Transform.value.copy(s.matrix))}function n(e,n){e.roughness.value=n.roughness,e.metalness.value=n.metalness,n.roughnessMap&&(e.roughnessMap.value=n.roughnessMap),n.metalnessMap&&(e.metalnessMap.value=n.metalnessMap),n.emissiveMap&&(e.emissiveMap.value=n.emissiveMap),n.bumpMap&&(e.bumpMap.value=n.bumpMap,e.bumpScale.value=n.bumpScale,1===n.side&&(e.bumpScale.value*=-1)),n.normalMap&&(e.normalMap.value=n.normalMap,e.normalScale.value.copy(n.normalScale),1===n.side&&e.normalScale.value.negate()),n.displacementMap&&(e.displacementMap.value=n.displacementMap,e.displacementScale.value=n.displacementScale,e.displacementBias.value=n.displacementBias),t.get(n).envMap&&(e.envMapIntensity.value=n.envMapIntensity)}return{refreshFogUniforms:function(t,e){t.fogColor.value.copy(e.color),e.isFog?(t.fogNear.value=e.near,t.fogFar.value=e.far):e.isFogExp2&&(t.fogDensity.value=e.density)},refreshMaterialUniforms:function(t,r,i,s){r.isMeshBasicMaterial?e(t,r):r.isMeshLambertMaterial?(e(t,r),function(t,e){e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap)}(t,r)):r.isMeshToonMaterial?(e(t,r),function(t,e){e.gradientMap&&(t.gradientMap.value=e.gradientMap),e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap),e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1)),e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate()),e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,r)):r.isMeshPhongMaterial?(e(t,r),function(t,e){t.specular.value.copy(e.specular),t.shininess.value=Math.max(e.shininess,1e-4),e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap),e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1)),e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate()),e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,r)):r.isMeshStandardMaterial?(e(t,r),r.isMeshPhysicalMaterial?function(t,e){n(t,e),t.reflectivity.value=e.reflectivity,t.clearcoat.value=e.clearcoat,t.clearcoatRoughness.value=e.clearcoatRoughness,e.sheen&&t.sheen.value.copy(e.sheen),e.clearcoatMap&&(t.clearcoatMap.value=e.clearcoatMap),e.clearcoatRoughnessMap&&(t.clearcoatRoughnessMap.value=e.clearcoatRoughnessMap),e.clearcoatNormalMap&&(t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),t.clearcoatNormalMap.value=e.clearcoatNormalMap,1===e.side&&t.clearcoatNormalScale.value.negate()),t.transmission.value=e.transmission,e.transmissionMap&&(t.transmissionMap.value=e.transmissionMap)}(t,r):n(t,r)):r.isMeshMatcapMaterial?(e(t,r),function(t,e){e.matcap&&(t.matcap.value=e.matcap),e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1)),e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate()),e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,r)):r.isMeshDepthMaterial?(e(t,r),function(t,e){e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,r)):r.isMeshDistanceMaterial?(e(t,r),function(t,e){e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias),t.referencePosition.value.copy(e.referencePosition),t.nearDistance.value=e.nearDistance,t.farDistance.value=e.farDistance}(t,r)):r.isMeshNormalMaterial?(e(t,r),function(t,e){e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1)),e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate()),e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,r)):r.isLineBasicMaterial?(function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity}(t,r),r.isLineDashedMaterial&&function(t,e){t.dashSize.value=e.dashSize,t.totalSize.value=e.dashSize+e.gapSize,t.scale.value=e.scale}(t,r)):r.isPointsMaterial?function(t,e,n,r){let i;t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.size.value=e.size*n,t.scale.value=.5*r,e.map&&(t.map.value=e.map),e.alphaMap&&(t.alphaMap.value=e.alphaMap),e.map?i=e.map:e.alphaMap&&(i=e.alphaMap),void 0!==i&&(!0===i.matrixAutoUpdate&&i.updateMatrix(),t.uvTransform.value.copy(i.matrix))}(t,r,i,s):r.isSpriteMaterial?function(t,e){let n;t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.rotation.value=e.rotation,e.map&&(t.map.value=e.map),e.alphaMap&&(t.alphaMap.value=e.alphaMap),e.map?n=e.map:e.alphaMap&&(n=e.alphaMap),void 0!==n&&(!0===n.matrixAutoUpdate&&n.updateMatrix(),t.uvTransform.value.copy(n.matrix))}(t,r):r.isShadowMaterial?(t.color.value.copy(r.color),t.opacity.value=r.opacity):r.isShaderMaterial&&(r.uniformsNeedUpdate=!1)}}}function Sk(t){const e=void 0!==(t=t||{}).canvas?t.canvas:function(){const t=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return t.style.display="block",t}(),n=void 0!==t.context?t.context:null,r=void 0!==t.alpha&&t.alpha,i=void 0===t.depth||t.depth,s=void 0===t.stencil||t.stencil,o=void 0!==t.antialias&&t.antialias,a=void 0===t.premultipliedAlpha||t.premultipliedAlpha,l=void 0!==t.preserveDrawingBuffer&&t.preserveDrawingBuffer,c=void 0!==t.powerPreference?t.powerPreference:"default",u=void 0!==t.failIfMajorPerformanceCaveat&&t.failIfMajorPerformanceCaveat;let h=null,d=null;const p=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=wE,this.physicallyCorrectLights=!1,this.toneMapping=0,this.toneMappingExposure=1,this.maxMorphTargets=8,this.maxMorphNormals=4;const f=this;let m=!1,g=null,y=0,v=0,b=null,_=null,x=-1,w=null;const S=new $E,E=new $E;let C=null,T=e.width,A=e.height,M=1,k=null,R=null;const I=new $E(0,0,T,A),N=new $E(0,0,T,A);let O=!1;const D=new gA;let L=!1,F=!1;const P=new mC,$=new VE,B={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function z(){return null===b?M:1}let V,U,H,W,j,G,q,X,K,Y,Z,J,Q,tt,et,nt,rt,it,st,ot,at,lt=n;function ct(t,n){for(let r=0;r<t.length;r++){const i=e.getContext(t[r],n);if(null!==i)return i}return null}try{const t={alpha:r,depth:i,stencil:s,antialias:o,premultipliedAlpha:a,preserveDrawingBuffer:l,powerPreference:c,failIfMajorPerformanceCaveat:u};if(e.addEventListener("webglcontextlost",pt,!1),e.addEventListener("webglcontextrestored",ft,!1),null===lt){const e=["webgl2","webgl","experimental-webgl"];if(!0===f.isWebGL1Renderer&&e.shift(),lt=ct(e,t),null===lt)throw ct(e)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===lt.getShaderPrecisionFormat&&(lt.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(Et){throw console.error("THREE.WebGLRenderer: "+Et.message),Et}function ut(){V=new kA(lt),U=new TA(lt,V,t),V.init(U),ot=new yk(lt,V,U),H=new mk(lt,V,U),H.scissor(E.copy(N).multiplyScalar(M).floor()),H.viewport(S.copy(I).multiplyScalar(M).floor()),W=new NA(lt),j=new ek,G=new gk(lt,V,H,j,U,ot,W),q=new MA(f),X=new vA(lt,U),at=new EA(lt,V,X,U),K=new RA(lt,X,W,at),Y=new FA(lt,K,X,W),rt=new LA(lt),et=new AA(j),Z=new tk(f,q,V,U,at,et),J=new wk(j),Q=new sk(j),tt=new hk(V,U),nt=new SA(f,q,H,Y,a),it=new CA(lt,V,W,U),st=new IA(lt,V,W,U),W.programs=Z.programs,f.capabilities=U,f.extensions=V,f.properties=j,f.renderLists=Q,f.state=H,f.info=W}ut();const ht=new xk(f,lt);this.xr=ht;const dt=new fk(f,Y,U.maxTextureSize);function pt(t){t.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),m=!0}function ft(){console.log("THREE.WebGLRenderer: Context Restored."),m=!1,ut()}function mt(t){const e=t.target;e.removeEventListener("dispose",mt),function(t){gt(t),j.remove(t)}(e)}function gt(t){const e=j.get(t).program;void 0!==e&&Z.releaseProgram(e)}this.shadowMap=dt,this.getContext=function(){return lt},this.getContextAttributes=function(){return lt.getContextAttributes()},this.forceContextLoss=function(){const t=V.get("WEBGL_lose_context");t&&t.loseContext()},this.forceContextRestore=function(){const t=V.get("WEBGL_lose_context");t&&t.restoreContext()},this.getPixelRatio=function(){return M},this.setPixelRatio=function(t){void 0!==t&&(M=t,this.setSize(T,A,!1))},this.getSize=function(t){return void 0===t&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),t=new IE),t.set(T,A)},this.setSize=function(t,n,r){ht.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(T=t,A=n,e.width=Math.floor(t*M),e.height=Math.floor(n*M),!1!==r&&(e.style.width=t+"px",e.style.height=n+"px"),this.setViewport(0,0,t,n))},this.getDrawingBufferSize=function(t){return void 0===t&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),t=new IE),t.set(T*M,A*M).floor()},this.setDrawingBufferSize=function(t,n,r){T=t,A=n,M=r,e.width=Math.floor(t*r),e.height=Math.floor(n*r),this.setViewport(0,0,t,n)},this.getCurrentViewport=function(t){return void 0===t&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),t=new $E),t.copy(S)},this.getViewport=function(t){return t.copy(I)},this.setViewport=function(t,e,n,r){t.isVector4?I.set(t.x,t.y,t.z,t.w):I.set(t,e,n,r),H.viewport(S.copy(I).multiplyScalar(M).floor())},this.getScissor=function(t){return t.copy(N)},this.setScissor=function(t,e,n,r){t.isVector4?N.set(t.x,t.y,t.z,t.w):N.set(t,e,n,r),H.scissor(E.copy(N).multiplyScalar(M).floor())},this.getScissorTest=function(){return O},this.setScissorTest=function(t){H.setScissorTest(O=t)},this.setOpaqueSort=function(t){k=t},this.setTransparentSort=function(t){R=t},this.getClearColor=function(t){return void 0===t&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),t=new lT),t.copy(nt.getClearColor())},this.setClearColor=function(){nt.setClearColor.apply(nt,arguments)},this.getClearAlpha=function(){return nt.getClearAlpha()},this.setClearAlpha=function(){nt.setClearAlpha.apply(nt,arguments)},this.clear=function(t,e,n){let r=0;(void 0===t||t)&&(r|=16384),(void 0===e||e)&&(r|=256),(void 0===n||n)&&(r|=1024),lt.clear(r)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",pt,!1),e.removeEventListener("webglcontextrestored",ft,!1),Q.dispose(),tt.dispose(),j.dispose(),q.dispose(),Y.dispose(),at.dispose(),ht.dispose(),vt.stop()},this.renderBufferImmediate=function(t,e){at.initAttributes();const n=j.get(t);t.hasPositions&&!n.position&&(n.position=lt.createBuffer()),t.hasNormals&&!n.normal&&(n.normal=lt.createBuffer()),t.hasUvs&&!n.uv&&(n.uv=lt.createBuffer()),t.hasColors&&!n.color&&(n.color=lt.createBuffer());const r=e.getAttributes();t.hasPositions&&(lt.bindBuffer(34962,n.position),lt.bufferData(34962,t.positionArray,35048),at.enableAttribute(r.position),lt.vertexAttribPointer(r.position,3,5126,!1,0,0)),t.hasNormals&&(lt.bindBuffer(34962,n.normal),lt.bufferData(34962,t.normalArray,35048),at.enableAttribute(r.normal),lt.vertexAttribPointer(r.normal,3,5126,!1,0,0)),t.hasUvs&&(lt.bindBuffer(34962,n.uv),lt.bufferData(34962,t.uvArray,35048),at.enableAttribute(r.uv),lt.vertexAttribPointer(r.uv,2,5126,!1,0,0)),t.hasColors&&(lt.bindBuffer(34962,n.color),lt.bufferData(34962,t.colorArray,35048),at.enableAttribute(r.color),lt.vertexAttribPointer(r.color,3,5126,!1,0,0)),at.disableUnusedAttributes(),lt.drawArrays(4,0,t.count),t.count=0},this.renderBufferDirect=function(t,e,n,r,i,s){null===e&&(e=B);const o=i.isMesh&&i.matrixWorld.determinant()<0,a=St(t,e,r,i);H.setMaterial(r,o);let l=n.index;const c=n.attributes.position;if(null===l){if(void 0===c||0===c.count)return}else if(0===l.count)return;let u,h=1;!0===r.wireframe&&(l=K.getWireframeAttribute(n),h=2),(r.morphTargets||r.morphNormals)&&rt.update(i,n,r,a),at.setup(i,r,a,n,l);let d=it;null!==l&&(u=X.get(l),d=st,d.setIndex(u));const p=null!==l?l.count:c.count,f=n.drawRange.start*h,m=n.drawRange.count*h,g=null!==s?s.start*h:0,y=null!==s?s.count*h:1/0,v=Math.max(f,g),b=Math.min(p,f+m,g+y)-1,_=Math.max(0,b-v+1);if(0!==_){if(i.isMesh)!0===r.wireframe?(H.setLineWidth(r.wireframeLinewidth*z()),d.setMode(1)):d.setMode(4);else if(i.isLine){let t=r.linewidth;void 0===t&&(t=1),H.setLineWidth(t*z()),d.setMode(i.isLineSegments?1:i.isLineLoop?2:3)}else i.isPoints?d.setMode(0):i.isSprite&&d.setMode(4);if(i.isInstancedMesh)d.renderInstances(v,_,i.count);else if(n.isInstancedBufferGeometry){const t=Math.min(n.instanceCount,n._maxInstanceCount);d.renderInstances(v,_,t)}else d.render(v,_)}},this.compile=function(t,e){d=tt.get(t),d.init(),t.traverseVisible(function(t){t.isLight&&t.layers.test(e.layers)&&(d.pushLight(t),t.castShadow&&d.pushShadow(t))}),d.setupLights();const n=new WeakMap;t.traverse(function(e){const r=e.material;if(r)if(Array.isArray(r))for(let i=0;i<r.length;i++){const s=r[i];!1===n.has(s)&&(wt(s,t,e),n.set(s))}else!1===n.has(r)&&(wt(r,t,e),n.set(r))})};let yt=null;const vt=new yA;function bt(t,e,n,r){if(!1===t.visible)return;if(t.layers.test(e.layers))if(t.isGroup)n=t.renderOrder;else if(t.isLOD)!0===t.autoUpdate&&t.update(e);else if(t.isLight)d.pushLight(t),t.castShadow&&d.pushShadow(t);else if(t.isSprite){if(!t.frustumCulled||D.intersectsSprite(t)){r&&$.setFromMatrixPosition(t.matrixWorld).applyMatrix4(P);const e=Y.update(t),i=t.material;i.visible&&h.push(t,e,i,n,$.z,null)}}else if(t.isImmediateRenderObject)r&&$.setFromMatrixPosition(t.matrixWorld).applyMatrix4(P),h.push(t,null,t.material,n,$.z,null);else if((t.isMesh||t.isLine||t.isPoints)&&(t.isSkinnedMesh&&t.skeleton.frame!==W.render.frame&&(t.skeleton.update(),t.skeleton.frame=W.render.frame),!t.frustumCulled||D.intersectsObject(t))){r&&$.setFromMatrixPosition(t.matrixWorld).applyMatrix4(P);const e=Y.update(t),i=t.material;if(Array.isArray(i)){const r=e.groups;for(let s=0,o=r.length;s<o;s++){const o=r[s],a=i[o.materialIndex];a&&a.visible&&h.push(t,e,a,n,$.z,o)}}else i.visible&&h.push(t,e,i,n,$.z,null)}const i=t.children;for(let s=0,o=i.length;s<o;s++)bt(i[s],e,n,r)}function _t(t,e,n){const r=!0===e.isScene?e.overrideMaterial:null;for(let i=0,s=t.length;i<s;i++){const s=t[i],o=s.object,a=s.geometry,l=null===r?s.material:r,c=s.group;if(n.isArrayCamera){const t=n.cameras;for(let n=0,r=t.length;n<r;n++){const r=t[n];o.layers.test(r.layers)&&(H.viewport(S.copy(r.viewport)),d.setupLightsView(r),xt(o,e,r,a,l,c))}}else xt(o,e,n,a,l,c)}}function xt(t,e,n,r,i,s){if(t.onBeforeRender(f,e,n,r,i,s),t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix),t.isImmediateRenderObject){const r=St(n,e,i,t);H.setMaterial(i),at.reset(),function(t,e){t.render(function(t){f.renderBufferImmediate(t,e)})}(t,r)}else f.renderBufferDirect(n,e,r,i,t,s);t.onAfterRender(f,e,n,r,i,s)}function wt(t,e,n){!0!==e.isScene&&(e=B);const r=j.get(t),i=d.state.lights,s=i.state.version,o=Z.getParameters(t,i.state,d.state.shadowsArray,e,n),a=Z.getProgramCacheKey(o);let l=r.program,c=!0;if(r.environment=t.isMeshStandardMaterial?e.environment:null,r.fog=e.fog,r.envMap=q.get(t.envMap||r.environment),void 0===l)t.addEventListener("dispose",mt);else if(l.cacheKey!==a)gt(t);else if(r.lightsStateVersion!==s)c=!1;else{if(void 0!==o.shaderID)return;c=!1}c&&(o.uniforms=Z.getUniforms(t),t.onBeforeCompile(o,f),l=Z.acquireProgram(o,a),r.program=l,r.uniforms=o.uniforms,r.outputEncoding=o.outputEncoding);const u=r.uniforms;(t.isShaderMaterial||t.isRawShaderMaterial)&&!0!==t.clipping||(r.numClippingPlanes=et.numPlanes,r.numIntersection=et.numIntersection,u.clippingPlanes=et.uniform),r.needsLights=function(t){return t.isMeshLambertMaterial||t.isMeshToonMaterial||t.isMeshPhongMaterial||t.isMeshStandardMaterial||t.isShadowMaterial||t.isShaderMaterial&&!0===t.lights}(t),r.lightsStateVersion=s,r.needsLights&&(u.ambientLightColor.value=i.state.ambient,u.lightProbe.value=i.state.probe,u.directionalLights.value=i.state.directional,u.directionalLightShadows.value=i.state.directionalShadow,u.spotLights.value=i.state.spot,u.spotLightShadows.value=i.state.spotShadow,u.rectAreaLights.value=i.state.rectArea,u.ltc_1.value=i.state.rectAreaLTC1,u.ltc_2.value=i.state.rectAreaLTC2,u.pointLights.value=i.state.point,u.pointLightShadows.value=i.state.pointShadow,u.hemisphereLights.value=i.state.hemi,u.directionalShadowMap.value=i.state.directionalShadowMap,u.directionalShadowMatrix.value=i.state.directionalShadowMatrix,u.spotShadowMap.value=i.state.spotShadowMap,u.spotShadowMatrix.value=i.state.spotShadowMatrix,u.pointShadowMap.value=i.state.pointShadowMap,u.pointShadowMatrix.value=i.state.pointShadowMatrix);const h=r.program.getUniforms(),p=OM.seqWithValue(h.seq,u);r.uniformsList=p}function St(t,e,n,r){!0!==e.isScene&&(e=B),G.resetTextureUnits();const i=e.fog,s=n.isMeshStandardMaterial?e.environment:null,o=null===b?f.outputEncoding:b.texture.encoding,a=q.get(n.envMap||s),l=j.get(n),c=d.state.lights;!0!==L||!0!==F&&t===w||et.setState(n,t,t===w&&n.id===x),n.version===l.__version?n.fog&&l.fog!==i||l.environment!==s||l.needsLights&&l.lightsStateVersion!==c.state.version?wt(n,e,r):void 0===l.numClippingPlanes||l.numClippingPlanes===et.numPlanes&&l.numIntersection===et.numIntersection?(l.outputEncoding!==o||l.envMap!==a)&&wt(n,e,r):wt(n,e,r):(wt(n,e,r),l.__version=n.version);let u=!1,h=!1,p=!1;const m=l.program,g=m.getUniforms(),y=l.uniforms;if(H.useProgram(m.program)&&(u=!0,h=!0,p=!0),n.id!==x&&(x=n.id,h=!0),u||w!==t){if(g.setValue(lt,"projectionMatrix",t.projectionMatrix),U.logarithmicDepthBuffer&&g.setValue(lt,"logDepthBufFC",2/(Math.log(t.far+1)/Math.LN2)),w!==t&&(w=t,h=!0,p=!0),n.isShaderMaterial||n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshStandardMaterial||n.envMap){const e=g.map.cameraPosition;void 0!==e&&e.setValue(lt,$.setFromMatrixPosition(t.matrixWorld))}(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial)&&g.setValue(lt,"isOrthographic",!0===t.isOrthographicCamera),(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial||n.isShadowMaterial||n.skinning)&&g.setValue(lt,"viewMatrix",t.matrixWorldInverse)}if(n.skinning){g.setOptional(lt,r,"bindMatrix"),g.setOptional(lt,r,"bindMatrixInverse");const t=r.skeleton;if(t){const e=t.bones;if(U.floatVertexTextures){if(null===t.boneTexture){let n=Math.sqrt(4*e.length);n=RE.ceilPowerOfTwo(n),n=Math.max(n,4);const r=new Float32Array(n*n*4);r.set(t.boneMatrices);const i=new pA(r,n,n,pE,cE);t.boneMatrices=r,t.boneTexture=i,t.boneTextureSize=n}g.setValue(lt,"boneTexture",t.boneTexture,G),g.setValue(lt,"boneTextureSize",t.boneTextureSize)}else g.setOptional(lt,t,"boneMatrices")}}var v,_;return(h||l.receiveShadow!==r.receiveShadow)&&(l.receiveShadow=r.receiveShadow,g.setValue(lt,"receiveShadow",r.receiveShadow)),h&&(g.setValue(lt,"toneMappingExposure",f.toneMappingExposure),l.needsLights&&((v=y).ambientLightColor.needsUpdate=_=p,v.lightProbe.needsUpdate=_,v.directionalLights.needsUpdate=_,v.directionalLightShadows.needsUpdate=_,v.pointLights.needsUpdate=_,v.pointLightShadows.needsUpdate=_,v.spotLights.needsUpdate=_,v.spotLightShadows.needsUpdate=_,v.rectAreaLights.needsUpdate=_,v.hemisphereLights.needsUpdate=_),i&&n.fog&&J.refreshFogUniforms(y,i),J.refreshMaterialUniforms(y,n,M,A),OM.upload(lt,l.uniformsList,y,G)),n.isShaderMaterial&&!0===n.uniformsNeedUpdate&&(OM.upload(lt,l.uniformsList,y,G),n.uniformsNeedUpdate=!1),n.isSpriteMaterial&&g.setValue(lt,"center",r.center),g.setValue(lt,"modelViewMatrix",r.modelViewMatrix),g.setValue(lt,"normalMatrix",r.normalMatrix),g.setValue(lt,"modelMatrix",r.matrixWorld),m}vt.setAnimationLoop(function(t){ht.isPresenting||yt&&yt(t)}),"undefined"!=typeof window&&vt.setContext(window),this.setAnimationLoop=function(t){yt=t,ht.setAnimationLoop(t),null===t?vt.stop():vt.start()},this.render=function(t,e){let n,r;if(void 0!==arguments[2]&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),n=arguments[2]),void 0!==arguments[3]&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),r=arguments[3]),void 0!==e&&!0!==e.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===m)return;at.resetDefaultState(),x=-1,w=null,!0===t.autoUpdate&&t.updateMatrixWorld(),null===e.parent&&e.updateMatrixWorld(),!0===ht.enabled&&!0===ht.isPresenting&&(e=ht.getCamera(e)),!0===t.isScene&&t.onBeforeRender(f,t,e,n||b),d=tt.get(t,p.length),d.init(),p.push(d),P.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),D.setFromProjectionMatrix(P),F=this.localClippingEnabled,L=et.init(this.clippingPlanes,F,e),h=Q.get(t,e),h.init(),bt(t,e,0,f.sortObjects),h.finish(),!0===f.sortObjects&&h.sort(k,R),!0===L&&et.beginShadows();const i=d.state.shadowsArray;dt.render(i,t,e),d.setupLights(),d.setupLightsView(e),!0===L&&et.endShadows(),!0===this.info.autoReset&&this.info.reset(),void 0!==n&&this.setRenderTarget(n),nt.render(h,t,e,r);const s=h.opaque,o=h.transparent;s.length>0&&_t(s,t,e),o.length>0&&_t(o,t,e),!0===t.isScene&&t.onAfterRender(f,t,e),null!==b&&(G.updateRenderTargetMipmap(b),G.updateMultisampleRenderTarget(b)),H.buffers.depth.setTest(!0),H.buffers.depth.setMask(!0),H.buffers.color.setMask(!0),H.setPolygonOffset(!1),p.pop(),d=p.length>0?p[p.length-1]:null,h=null},this.setFramebuffer=function(t){g!==t&&null===b&&lt.bindFramebuffer(36160,t),g=t},this.getActiveCubeFace=function(){return y},this.getActiveMipmapLevel=function(){return v},this.getRenderList=function(){return h},this.setRenderList=function(t){h=t},this.getRenderTarget=function(){return b},this.setRenderTarget=function(t,e=0,n=0){b=t,y=e,v=n,t&&void 0===j.get(t).__webglFramebuffer&&G.setupRenderTarget(t);let r=g,i=!1;if(t){const n=j.get(t).__webglFramebuffer;t.isWebGLCubeRenderTarget?(r=n[e],i=!0):r=t.isWebGLMultisampleRenderTarget?j.get(t).__webglMultisampledFramebuffer:n,S.copy(t.viewport),E.copy(t.scissor),C=t.scissorTest}else S.copy(I).multiplyScalar(M).floor(),E.copy(N).multiplyScalar(M).floor(),C=O;if(_!==r&&(lt.bindFramebuffer(36160,r),_=r),H.viewport(S),H.scissor(E),H.setScissorTest(C),i){const r=j.get(t.texture);lt.framebufferTexture2D(36160,36064,34069+e,r.__webglTexture,n)}},this.readRenderTargetPixels=function(t,e,n,r,i,s,o){if(!t||!t.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let a=j.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==o&&(a=a[o]),a){let o=!1;a!==_&&(lt.bindFramebuffer(36160,a),o=!0);try{const a=t.texture,l=a.format,c=a.type;if(l!==pE&&ot.convert(l)!==lt.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const u=c===uE&&(V.has("EXT_color_buffer_half_float")||U.isWebGL2&&V.has("EXT_color_buffer_float"));if(!(1009===c||ot.convert(c)===lt.getParameter(35738)||c===cE&&(U.isWebGL2||V.has("OES_texture_float")||V.has("WEBGL_color_buffer_float"))||u))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");36053===lt.checkFramebufferStatus(36160)?e>=0&&e<=t.width-r&&n>=0&&n<=t.height-i&&lt.readPixels(e,n,r,i,ot.convert(l),ot.convert(c),s):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{o&&lt.bindFramebuffer(36160,_)}}},this.copyFramebufferToTexture=function(t,e,n=0){const r=Math.pow(2,-n),i=Math.floor(e.image.width*r),s=Math.floor(e.image.height*r),o=ot.convert(e.format);G.setTexture2D(e,0),lt.copyTexImage2D(3553,n,o,t.x,t.y,i,s,0),H.unbindTexture()},this.copyTextureToTexture=function(t,e,n,r=0){const i=e.image.width,s=e.image.height,o=ot.convert(n.format),a=ot.convert(n.type);G.setTexture2D(n,0),lt.pixelStorei(37440,n.flipY),lt.pixelStorei(37441,n.premultiplyAlpha),lt.pixelStorei(3317,n.unpackAlignment),e.isDataTexture?lt.texSubImage2D(3553,r,t.x,t.y,i,s,o,a,e.image.data):e.isCompressedTexture?lt.compressedTexSubImage2D(3553,r,t.x,t.y,e.mipmaps[0].width,e.mipmaps[0].height,o,e.mipmaps[0].data):lt.texSubImage2D(3553,r,t.x,t.y,o,a,e.image),0===r&&n.generateMipmaps&&lt.generateMipmap(3553),H.unbindTexture()},this.initTexture=function(t){G.setTexture2D(t,0),H.unbindTexture()},this.resetState=function(){H.reset(),at.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}function Ek(t){Sk.call(this,t)}function Ck(t,e){this.array=t,this.stride=e,this.count=void 0!==t?t.length/e:0,this.usage=EE,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=RE.generateUUID()}(dk.prototype=Object.create(hT.prototype)).constructor=dk,dk.prototype.isMeshDepthMaterial=!0,dk.prototype.copy=function(t){return hT.prototype.copy.call(this,t),this.depthPacking=t.depthPacking,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this},(pk.prototype=Object.create(hT.prototype)).constructor=pk,pk.prototype.isMeshDistanceMaterial=!0,pk.prototype.copy=function(t){return hT.prototype.copy.call(this,t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this},vk.prototype=Object.assign(Object.create(lA.prototype),{constructor:vk,isArrayCamera:!0}),bk.prototype=Object.assign(Object.create(zC.prototype),{constructor:bk,isGroup:!0}),Object.assign(_k.prototype,{constructor:_k,getHandSpace:function(){return null===this._hand&&(this._hand=new bk,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand},getTargetRaySpace:function(){return null===this._targetRay&&(this._targetRay=new bk,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1),this._targetRay},getGripSpace:function(){return null===this._grip&&(this._grip=new bk,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1),this._grip},dispatchEvent:function(t){return null!==this._targetRay&&this._targetRay.dispatchEvent(t),null!==this._grip&&this._grip.dispatchEvent(t),null!==this._hand&&this._hand.dispatchEvent(t),this},disconnect:function(t){return this.dispatchEvent({type:"disconnected",data:t}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this},update:function(t,e,n){let r=null,i=null,s=null;const o=this._targetRay,a=this._grip,l=this._hand;if(t&&"visible-blurred"!==e.session.visibilityState)if(l&&t.hand){s=!0;for(const s of t.hand.values()){const t=e.getJointPose(s,n);if(void 0===l.joints[s.jointName]){const t=new bk;t.matrixAutoUpdate=!1,t.visible=!1,l.joints[s.jointName]=t,l.add(t)}const r=l.joints[s.jointName];null!==t&&(r.matrix.fromArray(t.transform.matrix),r.matrix.decompose(r.position,r.rotation,r.scale),r.jointRadius=t.radius),r.visible=null!==t}const r=l.joints["index-finger-tip"].position.distanceTo(l.joints["thumb-tip"].position),i=.02,o=.005;l.inputState.pinching&&r>i+o?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!l.inputState.pinching&&r<=i-o&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else null!==o&&(r=e.getPose(t.targetRaySpace,n),null!==r&&(o.matrix.fromArray(r.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale))),null!==a&&t.gripSpace&&(i=e.getPose(t.gripSpace,n),null!==i&&(a.matrix.fromArray(i.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale)));return null!==o&&(o.visible=null!==r),null!==a&&(a.visible=null!==i),null!==l&&(l.visible=null!==s),this}}),Object.assign(xk.prototype,AE.prototype),Ek.prototype=Object.assign(Object.create(Sk.prototype),{constructor:Ek,isWebGL1Renderer:!0}),Object.defineProperty(Ck.prototype,"needsUpdate",{set:function(t){!0===t&&this.version++}}),Object.assign(Ck.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setUsage:function(t){return this.usage=t,this},copy:function(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this},copyAt:function(t,e,n){t*=this.stride,n*=e.stride;for(let r=0,i=this.stride;r<i;r++)this.array[t+r]=e.array[n+r];return this},set:function(t,e=0){return this.array.set(t,e),this},clone:function(t){void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=RE.generateUUID()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new Ck(new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),this.stride);return e.setUsage(this.usage),e},onUpload:function(t){return this.onUploadCallback=t,this},toJSON:function(t){return void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=RE.generateUUID()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}});const Tk=new VE;function Ak(t,e,n,r){this.name="",this.data=t,this.itemSize=e,this.offset=n,this.normalized=!0===r}function Mk(t){hT.call(this),this.type="SpriteMaterial",this.color=new lT(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(t)}let kk;Object.defineProperties(Ak.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}},needsUpdate:{set:function(t){this.data.needsUpdate=t}}}),Object.assign(Ak.prototype,{isInterleavedBufferAttribute:!0,applyMatrix4:function(t){for(let e=0,n=this.data.count;e<n;e++)Tk.x=this.getX(e),Tk.y=this.getY(e),Tk.z=this.getZ(e),Tk.applyMatrix4(t),this.setXYZ(e,Tk.x,Tk.y,Tk.z);return this},setX:function(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this},setY:function(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this},setZ:function(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this},setW:function(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this},getX:function(t){return this.data.array[t*this.data.stride+this.offset]},getY:function(t){return this.data.array[t*this.data.stride+this.offset+1]},getZ:function(t){return this.data.array[t*this.data.stride+this.offset+2]},getW:function(t){return this.data.array[t*this.data.stride+this.offset+3]},setXY:function(t,e,n){return this.data.array[(t=t*this.data.stride+this.offset)+0]=e,this.data.array[t+1]=n,this},setXYZ:function(t,e,n,r){return this.data.array[(t=t*this.data.stride+this.offset)+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=r,this},setXYZW:function(t,e,n,r,i){return this.data.array[(t=t*this.data.stride+this.offset)+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=r,this.data.array[t+3]=i,this},clone:function(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return new mT(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new Ak(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)},toJSON:function(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}),(Mk.prototype=Object.create(hT.prototype)).constructor=Mk,Mk.prototype.isSpriteMaterial=!0,Mk.prototype.copy=function(t){return hT.prototype.copy.call(this,t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this};const Rk=new VE,Ik=new VE,Nk=new VE,Ok=new IE,Dk=new IE,Lk=new mC,Fk=new VE,Pk=new VE,$k=new VE,Bk=new IE,zk=new IE,Vk=new IE;function Uk(t){if(zC.call(this),this.type="Sprite",void 0===kk){kk=new FT;const t=new Ck(new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),5);kk.setIndex([0,1,2,0,2,3]),kk.setAttribute("position",new Ak(t,3,0,!1)),kk.setAttribute("uv",new Ak(t,2,3,!1))}this.geometry=kk,this.material=void 0!==t?t:new Mk,this.center=new IE(.5,.5)}function Hk(t,e,n,r,i,s){Ok.subVectors(t,n).addScalar(.5).multiply(r),void 0!==i?(Dk.x=s*Ok.x-i*Ok.y,Dk.y=i*Ok.x+s*Ok.y):Dk.copy(Ok),t.copy(e),t.x+=Dk.x,t.y+=Dk.y,t.applyMatrix4(Lk)}Uk.prototype=Object.assign(Object.create(zC.prototype),{constructor:Uk,isSprite:!0,raycast:function(t,e){null===t.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Ik.setFromMatrixScale(this.matrixWorld),Lk.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),Nk.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&Ik.multiplyScalar(-Nk.z);const n=this.material.rotation;let r,i;0!==n&&(i=Math.cos(n),r=Math.sin(n));const s=this.center;Hk(Fk.set(-.5,-.5,0),Nk,s,Ik,r,i),Hk(Pk.set(.5,-.5,0),Nk,s,Ik,r,i),Hk($k.set(.5,.5,0),Nk,s,Ik,r,i),Bk.set(0,0),zk.set(1,0),Vk.set(1,1);let o=t.ray.intersectTriangle(Fk,Pk,$k,!1,Rk);if(null===o&&(Hk(Pk.set(-.5,.5,0),Nk,s,Ik,r,i),zk.set(0,1),o=t.ray.intersectTriangle(Fk,$k,Pk,!1,Rk),null===o))return;const a=t.ray.origin.distanceTo(Rk);a<t.near||a>t.far||e.push({distance:a,point:Rk.clone(),uv:eT.getUV(Rk,Fk,Pk,$k,Bk,zk,Vk,new IE),face:null,object:this})},copy:function(t){return zC.prototype.copy.call(this,t),void 0!==t.center&&this.center.copy(t.center),this.material=t.material,this}});const Wk=new VE,jk=new VE;function Gk(){zC.call(this),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}Gk.prototype=Object.assign(Object.create(zC.prototype),{constructor:Gk,isLOD:!0,copy:function(t){zC.prototype.copy.call(this,t,!1);const e=t.levels;for(let n=0,r=e.length;n<r;n++){const t=e[n];this.addLevel(t.object.clone(),t.distance)}return this.autoUpdate=t.autoUpdate,this},addLevel:function(t,e=0){e=Math.abs(e);const n=this.levels;let r;for(r=0;r<n.length&&!(e<n[r].distance);r++);return n.splice(r,0,{distance:e,object:t}),this.add(t),this},getCurrentLevel:function(){return this._currentLevel},getObjectForDistance:function(t){const e=this.levels;if(e.length>0){let n,r;for(n=1,r=e.length;n<r&&!(t<e[n].distance);n++);return e[n-1].object}return null},raycast:function(t,e){if(this.levels.length>0){Wk.setFromMatrixPosition(this.matrixWorld);const n=t.ray.origin.distanceTo(Wk);this.getObjectForDistance(n).raycast(t,e)}},update:function(t){const e=this.levels;if(e.length>1){Wk.setFromMatrixPosition(t.matrixWorld),jk.setFromMatrixPosition(this.matrixWorld);const n=Wk.distanceTo(jk)/t.zoom;let r,i;for(e[0].object.visible=!0,r=1,i=e.length;r<i&&n>=e[r].distance;r++)e[r-1].object.visible=!1,e[r].object.visible=!0;for(this._currentLevel=r-1;r<i;r++)e[r].object.visible=!1}},toJSON:function(t){const e=zC.prototype.toJSON.call(this,t);!1===this.autoUpdate&&(e.object.autoUpdate=!1),e.object.levels=[];const n=this.levels;for(let r=0,i=n.length;r<i;r++){const t=n[r];e.object.levels.push({object:t.object.uuid,distance:t.distance})}return e}});const qk=new VE,Xk=new $E,Kk=new $E,Yk=new VE,Zk=new mC;function Jk(t,e){t&&t.isGeometry&&console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),tA.call(this,t,e),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new mC,this.bindMatrixInverse=new mC}function Qk(){zC.call(this),this.type="Bone"}Jk.prototype=Object.assign(Object.create(tA.prototype),{constructor:Jk,isSkinnedMesh:!0,copy:function(t){return tA.prototype.copy.call(this,t),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this},bind:function(t,e){this.skeleton=t,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){const t=new $E,e=this.geometry.attributes.skinWeight;for(let n=0,r=e.count;n<r;n++){t.x=e.getX(n),t.y=e.getY(n),t.z=e.getZ(n),t.w=e.getW(n);const r=1/t.manhattanLength();r!==1/0?t.multiplyScalar(r):t.set(1,0,0,0),e.setXYZW(n,t.x,t.y,t.z,t.w)}},updateMatrixWorld:function(t){tA.prototype.updateMatrixWorld.call(this,t),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},boneTransform:function(t,e){const n=this.skeleton,r=this.geometry;Xk.fromBufferAttribute(r.attributes.skinIndex,t),Kk.fromBufferAttribute(r.attributes.skinWeight,t),qk.fromBufferAttribute(r.attributes.position,t).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let i=0;i<4;i++){const t=Kk.getComponent(i);if(0!==t){const r=Xk.getComponent(i);Zk.multiplyMatrices(n.bones[r].matrixWorld,n.boneInverses[r]),e.addScaledVector(Yk.copy(qk).applyMatrix4(Zk),t)}}return e.applyMatrix4(this.bindMatrixInverse)}}),Qk.prototype=Object.assign(Object.create(zC.prototype),{constructor:Qk,isBone:!0});const tR=new mC,eR=new mC;function nR(t=[],e=[]){this.uuid=RE.generateUUID(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}Object.assign(nR.prototype,{init:function(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(16*t.length),0===e.length)this.calculateInverses();else if(t.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let t=0,e=this.bones.length;t<e;t++)this.boneInverses.push(new mC)}},calculateInverses:function(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const e=new mC;this.bones[t]&&e.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(e)}},pose:function(){for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&e.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&(e.parent&&e.parent.isBone?(e.matrix.copy(e.parent.matrixWorld).invert(),e.matrix.multiply(e.matrixWorld)):e.matrix.copy(e.matrixWorld),e.matrix.decompose(e.position,e.quaternion,e.scale))}},update:function(){const t=this.bones,e=this.boneInverses,n=this.boneMatrices,r=this.boneTexture;for(let i=0,s=t.length;i<s;i++)tR.multiplyMatrices(t[i]?t[i].matrixWorld:eR,e[i]),tR.toArray(n,16*i);null!==r&&(r.needsUpdate=!0)},clone:function(){return new nR(this.bones,this.boneInverses)},getBoneByName:function(t){for(let e=0,n=this.bones.length;e<n;e++){const n=this.bones[e];if(n.name===t)return n}},dispose:function(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)},fromJSON:function(t,e){this.uuid=t.uuid;for(let n=0,r=t.bones.length;n<r;n++){const r=t.bones[n];let i=e[r];void 0===i&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),i=new Qk),this.bones.push(i),this.boneInverses.push((new mC).fromArray(t.boneInverses[n]))}return this.init(),this},toJSON:function(){const t={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,n=this.boneInverses;for(let r=0,i=e.length;r<i;r++)t.bones.push(e[r].uuid),t.boneInverses.push(n[r].toArray());return t}});const rR=new mC,iR=new mC,sR=[],oR=new tA;function aR(t,e,n){tA.call(this,t,e),this.instanceMatrix=new mT(new Float32Array(16*n),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}function lR(t){hT.call(this),this.type="LineBasicMaterial",this.color=new lT(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(t)}aR.prototype=Object.assign(Object.create(tA.prototype),{constructor:aR,isInstancedMesh:!0,copy:function(t){return tA.prototype.copy.call(this,t),this.instanceMatrix.copy(t.instanceMatrix),null!==t.instanceColor&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this},getColorAt:function(t,e){e.fromArray(this.instanceColor.array,3*t)},getMatrixAt:function(t,e){e.fromArray(this.instanceMatrix.array,16*t)},raycast:function(t,e){const n=this.matrixWorld,r=this.count;if(oR.geometry=this.geometry,oR.material=this.material,void 0!==oR.material)for(let i=0;i<r;i++){this.getMatrixAt(i,rR),iR.multiplyMatrices(n,rR),oR.matrixWorld=iR,oR.raycast(t,sR);for(let t=0,n=sR.length;t<n;t++){const n=sR[t];n.instanceId=i,n.object=this,e.push(n)}sR.length=0}},setColorAt:function(t,e){null===this.instanceColor&&(this.instanceColor=new mT(new Float32Array(3*this.count),3)),e.toArray(this.instanceColor.array,3*t)},setMatrixAt:function(t,e){e.toArray(this.instanceMatrix.array,16*t)},updateMorphTargets:function(){},dispose:function(){this.dispatchEvent({type:"dispose"})}}),(lR.prototype=Object.create(hT.prototype)).constructor=lR,lR.prototype.isLineBasicMaterial=!0,lR.prototype.copy=function(t){return hT.prototype.copy.call(this,t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.morphTargets=t.morphTargets,this};const cR=new VE,uR=new VE,hR=new mC,dR=new fC,pR=new oC;function fR(t=new FT,e=new lR){zC.call(this),this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}fR.prototype=Object.assign(Object.create(zC.prototype),{constructor:fR,isLine:!0,copy:function(t){return zC.prototype.copy.call(this,t),this.material=t.material,this.geometry=t.geometry,this},computeLineDistances:function(){const t=this.geometry;if(t.isBufferGeometry)if(null===t.index){const e=t.attributes.position,n=[0];for(let t=1,r=e.count;t<r;t++)cR.fromBufferAttribute(e,t-1),uR.fromBufferAttribute(e,t),n[t]=n[t-1],n[t]+=cR.distanceTo(uR);t.setAttribute("lineDistance",new ET(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this},raycast:function(t,e){const n=this.geometry,r=this.matrixWorld,i=t.params.Line.threshold;if(null===n.boundingSphere&&n.computeBoundingSphere(),pR.copy(n.boundingSphere),pR.applyMatrix4(r),pR.radius+=i,!1===t.ray.intersectsSphere(pR))return;hR.copy(r).invert(),dR.copy(t.ray).applyMatrix4(hR);const s=i/((this.scale.x+this.scale.y+this.scale.z)/3),o=s*s,a=new VE,l=new VE,c=new VE,u=new VE,h=this.isLineSegments?2:1;if(n.isBufferGeometry){const r=n.index,i=n.attributes.position;if(null!==r){const n=r.array;for(let r=0,s=n.length-1;r<s;r+=h){const s=n[r+1];if(a.fromBufferAttribute(i,n[r]),l.fromBufferAttribute(i,s),dR.distanceSqToSegment(a,l,u,c)>o)continue;u.applyMatrix4(this.matrixWorld);const h=t.ray.origin.distanceTo(u);h<t.near||h>t.far||e.push({distance:h,point:c.clone().applyMatrix4(this.matrixWorld),index:r,face:null,faceIndex:null,object:this})}}else for(let n=0,s=i.count-1;n<s;n+=h){if(a.fromBufferAttribute(i,n),l.fromBufferAttribute(i,n+1),dR.distanceSqToSegment(a,l,u,c)>o)continue;u.applyMatrix4(this.matrixWorld);const r=t.ray.origin.distanceTo(u);r<t.near||r>t.far||e.push({distance:r,point:c.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});const mR=new VE,gR=new VE;function yR(t,e){fR.call(this,t,e),this.type="LineSegments"}function vR(t,e){fR.call(this,t,e),this.type="LineLoop"}function bR(t){hT.call(this),this.type="PointsMaterial",this.color=new lT(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(t)}yR.prototype=Object.assign(Object.create(fR.prototype),{constructor:yR,isLineSegments:!0,computeLineDistances:function(){const t=this.geometry;if(t.isBufferGeometry)if(null===t.index){const e=t.attributes.position,n=[];for(let t=0,r=e.count;t<r;t+=2)mR.fromBufferAttribute(e,t),gR.fromBufferAttribute(e,t+1),n[t]=0===t?0:n[t-1],n[t+1]=n[t]+mR.distanceTo(gR);t.setAttribute("lineDistance",new ET(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}),vR.prototype=Object.assign(Object.create(fR.prototype),{constructor:vR,isLineLoop:!0}),(bR.prototype=Object.create(hT.prototype)).constructor=bR,bR.prototype.isPointsMaterial=!0,bR.prototype.copy=function(t){return hT.prototype.copy.call(this,t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.morphTargets=t.morphTargets,this};const _R=new mC,xR=new fC,wR=new oC,SR=new VE;function ER(t=new FT,e=new bR){zC.call(this),this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}function CR(t,e,n,r,i,s,o){const a=xR.distanceSqToPoint(t);if(a<n){const n=new VE;xR.closestPointToPoint(t,n),n.applyMatrix4(r);const l=i.ray.origin.distanceTo(n);if(l<i.near||l>i.far)return;s.push({distance:l,distanceToRay:Math.sqrt(a),point:n,index:e,face:null,object:o})}}function TR(t,e,n,r,i,s,o,a,l){FE.call(this,t,e,n,r,i,s,o,a,l),this.format=void 0!==o?o:dE,this.minFilter=void 0!==s?s:sE,this.magFilter=void 0!==i?i:sE,this.generateMipmaps=!1;const c=this;"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback(function e(){c.needsUpdate=!0,t.requestVideoFrameCallback(e)})}function AR(t,e,n,r,i,s,o,a,l,c,u,h){FE.call(this,null,s,o,a,l,c,r,i,u,h),this.image={width:e,height:n},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}function MR(t,e,n,r,i,s,o,a,l){FE.call(this,t,e,n,r,i,s,o,a,l),this.needsUpdate=!0}function kR(t,e,n,r,i,s,o,a,l,c){if((c=void 0!==c?c:fE)!==fE&&c!==mE)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===n&&c===fE&&(n=aE),void 0===n&&c===mE&&(n=hE),FE.call(this,null,r,i,s,o,a,c,n,l),this.image={width:t,height:e},this.magFilter=void 0!==o?o:iE,this.minFilter=void 0!==a?a:iE,this.flipY=!1,this.generateMipmaps=!1}function RR(t,e,n,r,i){let s,o;if(i===function(t,e,n,r){let i=0;for(let s=e,o=n-r;s<n;s+=r)i+=(t[o]-t[s])*(t[s+1]+t[o+1]),o=s;return i}(t,e,n,r)>0)for(s=e;s<n;s+=r)o=ZR(s,t[s],t[s+1],o);else for(s=n-r;s>=e;s-=r)o=ZR(s,t[s],t[s+1],o);return o&&jR(o,o.next)&&(JR(o),o=o.next),o}function IR(t,e){if(!t)return t;e||(e=t);let n,r=t;do{if(n=!1,r.steiner||!jR(r,r.next)&&0!==WR(r.prev,r,r.next))r=r.next;else{if(JR(r),r=e=r.prev,r===r.next)break;n=!0}}while(n||r!==e);return e}function NR(t,e,n,r,i,s,o){if(!t)return;!o&&s&&function(t,e,n,r){let i=t;do{null===i.z&&(i.z=zR(i.x,i.y,e,n,r)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next}while(i!==t);i.prevZ.nextZ=null,i.prevZ=null,function(t){let e,n,r,i,s,o,a,l,c=1;do{for(n=t,t=null,s=null,o=0;n;){for(o++,r=n,a=0,e=0;e<c&&(a++,r=r.nextZ,r);e++);for(l=c;a>0||l>0&&r;)0!==a&&(0===l||!r||n.z<=r.z)?(i=n,n=n.nextZ,a--):(i=r,r=r.nextZ,l--),s?s.nextZ=i:t=i,i.prevZ=s,s=i;n=r}s.nextZ=null,c*=2}while(o>1)}(i)}(t,r,i,s);let a,l,c=t;for(;t.prev!==t.next;)if(a=t.prev,l=t.next,s?DR(t,r,i,s):OR(t))e.push(a.i/n),e.push(t.i/n),e.push(l.i/n),JR(t),t=l.next,c=l.next;else if((t=l)===c){o?1===o?NR(t=LR(IR(t),e,n),e,n,r,i,s,2):2===o&&FR(t,e,n,r,i,s):NR(IR(t),e,n,r,i,s,1);break}}function OR(t){const e=t.prev,n=t,r=t.next;if(WR(e,n,r)>=0)return!1;let i=t.next.next;for(;i!==t.prev;){if(UR(e.x,e.y,n.x,n.y,r.x,r.y,i.x,i.y)&&WR(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function DR(t,e,n,r){const i=t.prev,s=t,o=t.next;if(WR(i,s,o)>=0)return!1;const a=i.x>s.x?i.x>o.x?i.x:o.x:s.x>o.x?s.x:o.x,l=i.y>s.y?i.y>o.y?i.y:o.y:s.y>o.y?s.y:o.y,c=zR(i.x<s.x?i.x<o.x?i.x:o.x:s.x<o.x?s.x:o.x,i.y<s.y?i.y<o.y?i.y:o.y:s.y<o.y?s.y:o.y,e,n,r),u=zR(a,l,e,n,r);let h=t.prevZ,d=t.nextZ;for(;h&&h.z>=c&&d&&d.z<=u;){if(h!==t.prev&&h!==t.next&&UR(i.x,i.y,s.x,s.y,o.x,o.y,h.x,h.y)&&WR(h.prev,h,h.next)>=0)return!1;if(h=h.prevZ,d!==t.prev&&d!==t.next&&UR(i.x,i.y,s.x,s.y,o.x,o.y,d.x,d.y)&&WR(d.prev,d,d.next)>=0)return!1;d=d.nextZ}for(;h&&h.z>=c;){if(h!==t.prev&&h!==t.next&&UR(i.x,i.y,s.x,s.y,o.x,o.y,h.x,h.y)&&WR(h.prev,h,h.next)>=0)return!1;h=h.prevZ}for(;d&&d.z<=u;){if(d!==t.prev&&d!==t.next&&UR(i.x,i.y,s.x,s.y,o.x,o.y,d.x,d.y)&&WR(d.prev,d,d.next)>=0)return!1;d=d.nextZ}return!0}function LR(t,e,n){let r=t;do{const i=r.prev,s=r.next.next;!jR(i,s)&&GR(i,r,r.next,s)&&KR(i,s)&&KR(s,i)&&(e.push(i.i/n),e.push(r.i/n),e.push(s.i/n),JR(r),JR(r.next),r=t=s),r=r.next}while(r!==t);return IR(r)}function FR(t,e,n,r,i,s){let o=t;do{let t=o.next.next;for(;t!==o.prev;){if(o.i!==t.i&&HR(o,t)){let a=YR(o,t);return o=IR(o,o.next),a=IR(a,a.next),NR(o,e,n,r,i,s),void NR(a,e,n,r,i,s)}t=t.next}o=o.next}while(o!==t)}function PR(t,e){return t.x-e.x}function $R(t,e){if(e=function(t,e){let n=e;const r=t.x,i=t.y;let s,o=-1/0;do{if(i<=n.y&&i>=n.next.y&&n.next.y!==n.y){const t=n.x+(i-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(t<=r&&t>o){if(o=t,t===r){if(i===n.y)return n;if(i===n.next.y)return n.next}s=n.x<n.next.x?n:n.next}}n=n.next}while(n!==e);if(!s)return null;if(r===o)return s;const a=s,l=s.x,c=s.y;let u,h=1/0;n=s;do{r>=n.x&&n.x>=l&&r!==n.x&&UR(i<c?r:o,i,l,c,i<c?o:r,i,n.x,n.y)&&(u=Math.abs(i-n.y)/(r-n.x),KR(n,t)&&(u<h||u===h&&(n.x>s.x||n.x===s.x&&BR(s,n)))&&(s=n,h=u)),n=n.next}while(n!==a);return s}(t,e)){const n=YR(e,t);IR(e,e.next),IR(n,n.next)}}function BR(t,e){return WR(t.prev,t,e.prev)<0&&WR(e.next,t,t.next)<0}function zR(t,e,n,r,i){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-n)*i)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-r)*i)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function VR(t){let e=t,n=t;do{(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next}while(e!==t);return n}function UR(t,e,n,r,i,s,o,a){return(i-o)*(e-a)-(t-o)*(s-a)>=0&&(t-o)*(r-a)-(n-o)*(e-a)>=0&&(n-o)*(s-a)-(i-o)*(r-a)>=0}function HR(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&GR(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}(t,e)&&(KR(t,e)&&KR(e,t)&&function(t,e){let n=t,r=!1;const i=(t.x+e.x)/2,s=(t.y+e.y)/2;do{n.y>s!=n.next.y>s&&n.next.y!==n.y&&i<(n.next.x-n.x)*(s-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next}while(n!==t);return r}(t,e)&&(WR(t.prev,t,e.prev)||WR(t,e.prev,e))||jR(t,e)&&WR(t.prev,t,t.next)>0&&WR(e.prev,e,e.next)>0)}function WR(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function jR(t,e){return t.x===e.x&&t.y===e.y}function GR(t,e,n,r){const i=XR(WR(t,e,n)),s=XR(WR(t,e,r)),o=XR(WR(n,r,t)),a=XR(WR(n,r,e));return i!==s&&o!==a||!(0!==i||!qR(t,n,e))||!(0!==s||!qR(t,r,e))||!(0!==o||!qR(n,t,r))||!(0!==a||!qR(n,e,r))}function qR(t,e,n){return e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y)}function XR(t){return t>0?1:t<0?-1:0}function KR(t,e){return WR(t.prev,t,t.next)<0?WR(t,e,t.next)>=0&&WR(t,t.prev,e)>=0:WR(t,e,t.prev)<0||WR(t,t.next,e)<0}function YR(t,e){const n=new QR(t.i,t.x,t.y),r=new QR(e.i,e.x,e.y),i=t.next,s=e.prev;return t.next=e,e.prev=t,n.next=i,i.prev=n,r.next=n,n.prev=r,s.next=r,r.prev=s,r}function ZR(t,e,n,r){const i=new QR(t,e,n);return r?(i.next=r.next,i.prev=r,r.next.prev=i,r.next=i):(i.prev=i,i.next=i),i}function JR(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function QR(t,e,n){this.i=t,this.x=e,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}ER.prototype=Object.assign(Object.create(zC.prototype),{constructor:ER,isPoints:!0,copy:function(t){return zC.prototype.copy.call(this,t),this.material=t.material,this.geometry=t.geometry,this},raycast:function(t,e){const n=this.geometry,r=this.matrixWorld,i=t.params.Points.threshold;if(null===n.boundingSphere&&n.computeBoundingSphere(),wR.copy(n.boundingSphere),wR.applyMatrix4(r),wR.radius+=i,!1===t.ray.intersectsSphere(wR))return;_R.copy(r).invert(),xR.copy(t.ray).applyMatrix4(_R);const s=i/((this.scale.x+this.scale.y+this.scale.z)/3),o=s*s;if(n.isBufferGeometry){const i=n.index,s=n.attributes.position;if(null!==i){const n=i.array;for(let i=0,a=n.length;i<a;i++){const a=n[i];SR.fromBufferAttribute(s,a),CR(SR,a,o,r,t,e,this)}}else for(let n=0,a=s.count;n<a;n++)SR.fromBufferAttribute(s,n),CR(SR,n,o,r,t,e,this)}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}),TR.prototype=Object.assign(Object.create(FE.prototype),{constructor:TR,clone:function(){return new this.constructor(this.image).copy(this)},isVideoTexture:!0,update:function(){const t=this.image;0=="requestVideoFrameCallback"in t&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}),(AR.prototype=Object.create(FE.prototype)).constructor=AR,AR.prototype.isCompressedTexture=!0,(MR.prototype=Object.create(FE.prototype)).constructor=MR,MR.prototype.isCanvasTexture=!0,(kR.prototype=Object.create(FE.prototype)).constructor=kR,kR.prototype.isDepthTexture=!0,new VE,new VE,new VE,new eT;const tI={area:function(t){const e=t.length;let n=0;for(let r=e-1,i=0;i<e;r=i++)n+=t[r].x*t[i].y-t[i].x*t[r].y;return.5*n},isClockWise:function(t){return tI.area(t)<0},triangulateShape:function(t,e){const n=[],r=[],i=[];eI(t),nI(n,t);let s=t.length;e.forEach(eI);for(let a=0;a<e.length;a++)r.push(s),s+=e[a].length,nI(n,e[a]);const o=function(t,e,n){n=n||2;const r=e&&e.length,i=r?e[0]*n:t.length;let s=RR(t,0,i,n,!0);const o=[];if(!s||s.next===s.prev)return o;let a,l,c,u,h,d,p;if(r&&(s=function(t,e,n,r){const i=[];let s,o,a,l,c;for(s=0,o=e.length;s<o;s++)a=e[s]*r,l=s<o-1?e[s+1]*r:t.length,c=RR(t,a,l,r,!1),c===c.next&&(c.steiner=!0),i.push(VR(c));for(i.sort(PR),s=0;s<i.length;s++)$R(i[s],n),n=IR(n,n.next);return n}(t,e,s,n)),t.length>80*n){a=c=t[0],l=u=t[1];for(let e=n;e<i;e+=n)h=t[e],d=t[e+1],h<a&&(a=h),d<l&&(l=d),h>c&&(c=h),d>u&&(u=d);p=Math.max(c-a,u-l),p=0!==p?1/p:0}return NR(s,o,n,a,l,p),o}(n,r);for(let a=0;a<o.length;a+=3)i.push(o.slice(a,a+3));return i}};function eI(t){const e=t.length;e>2&&t[e-1].equals(t[0])&&t.pop()}function nI(t,e){for(let n=0;n<e.length;n++)t.push(e[n].x),t.push(e[n].y)}class rI extends FT{constructor(t,e){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const n=this,r=[],i=[];for(let o=0,a=t.length;o<a;o++)s(t[o]);function s(t){const s=[],o=void 0!==e.curveSegments?e.curveSegments:12,a=void 0!==e.steps?e.steps:1;let l=void 0!==e.depth?e.depth:100,c=void 0===e.bevelEnabled||e.bevelEnabled,u=void 0!==e.bevelThickness?e.bevelThickness:6,h=void 0!==e.bevelSize?e.bevelSize:u-2,d=void 0!==e.bevelOffset?e.bevelOffset:0,p=void 0!==e.bevelSegments?e.bevelSegments:3;const f=e.extrudePath,m=void 0!==e.UVGenerator?e.UVGenerator:iI;void 0!==e.amount&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),l=e.amount);let g,y,v,b,_,x=!1;f&&(g=f.getSpacedPoints(a),x=!0,c=!1,y=f.computeFrenetFrames(a,!1),v=new VE,b=new VE,_=new VE),c||(p=0,u=0,h=0,d=0);const w=t.extractPoints(o);let S=w.shape;const E=w.holes;if(!tI.isClockWise(S)){S=S.reverse();for(let t=0,e=E.length;t<e;t++){const e=E[t];tI.isClockWise(e)&&(E[t]=e.reverse())}}const C=tI.triangulateShape(S,E),T=S;for(let e=0,n=E.length;e<n;e++)S=S.concat(E[e]);function A(t,e,n){return e||console.error("THREE.ExtrudeGeometry: vec does not exist"),e.clone().multiplyScalar(n).add(t)}const M=S.length,k=C.length;function R(t,e,n){let r,i,s;const o=t.x-e.x,a=t.y-e.y,l=n.x-t.x,c=n.y-t.y,u=o*o+a*a;if(Math.abs(o*c-a*l)>Number.EPSILON){const h=Math.sqrt(u),d=Math.sqrt(l*l+c*c),p=e.x-a/h,f=e.y+o/h,m=((n.x-c/d-p)*c-(n.y+l/d-f)*l)/(o*c-a*l);r=p+o*m-t.x,i=f+a*m-t.y;const g=r*r+i*i;if(g<=2)return new IE(r,i);s=Math.sqrt(g/2)}else{let t=!1;o>Number.EPSILON?l>Number.EPSILON&&(t=!0):o<-Number.EPSILON?l<-Number.EPSILON&&(t=!0):Math.sign(a)===Math.sign(c)&&(t=!0),t?(r=-a,i=o,s=Math.sqrt(u)):(r=o,i=a,s=Math.sqrt(u/2))}return new IE(r/s,i/s)}const I=[];for(let e=0,n=T.length,r=n-1,i=e+1;e<n;e++,r++,i++)r===n&&(r=0),i===n&&(i=0),I[e]=R(T[e],T[r],T[i]);const N=[];let O,D=I.concat();for(let e=0,n=E.length;e<n;e++){const t=E[e];O=[];for(let e=0,n=t.length,r=n-1,i=e+1;e<n;e++,r++,i++)r===n&&(r=0),i===n&&(i=0),O[e]=R(t[e],t[r],t[i]);N.push(O),D=D.concat(O)}for(let e=0;e<p;e++){const t=e/p,n=u*Math.cos(t*Math.PI/2),r=h*Math.sin(t*Math.PI/2)+d;for(let e=0,i=T.length;e<i;e++){const t=A(T[e],I[e],r);P(t.x,t.y,-n)}for(let e=0,i=E.length;e<i;e++){const t=E[e];O=N[e];for(let e=0,i=t.length;e<i;e++){const i=A(t[e],O[e],r);P(i.x,i.y,-n)}}}const L=h+d;for(let e=0;e<M;e++){const t=c?A(S[e],D[e],L):S[e];x?(b.copy(y.normals[0]).multiplyScalar(t.x),v.copy(y.binormals[0]).multiplyScalar(t.y),_.copy(g[0]).add(b).add(v),P(_.x,_.y,_.z)):P(t.x,t.y,0)}for(let e=1;e<=a;e++)for(let t=0;t<M;t++){const n=c?A(S[t],D[t],L):S[t];x?(b.copy(y.normals[e]).multiplyScalar(n.x),v.copy(y.binormals[e]).multiplyScalar(n.y),_.copy(g[e]).add(b).add(v),P(_.x,_.y,_.z)):P(n.x,n.y,l/a*e)}for(let e=p-1;e>=0;e--){const t=e/p,n=u*Math.cos(t*Math.PI/2),r=h*Math.sin(t*Math.PI/2)+d;for(let e=0,i=T.length;e<i;e++){const t=A(T[e],I[e],r);P(t.x,t.y,l+n)}for(let e=0,i=E.length;e<i;e++){const t=E[e];O=N[e];for(let e=0,i=t.length;e<i;e++){const i=A(t[e],O[e],r);x?P(i.x,i.y+g[a-1].y,g[a-1].x+n):P(i.x,i.y,l+n)}}}function F(t,e){let n=t.length;for(;--n>=0;){const r=n;let i=n-1;i<0&&(i=t.length-1);for(let t=0,n=a+2*p;t<n;t++){const n=M*t,s=M*(t+1);B(e+r+n,e+i+n,e+i+s,e+r+s)}}}function P(t,e,n){s.push(t),s.push(e),s.push(n)}function $(t,e,i){z(t),z(e),z(i);const s=r.length/3,o=m.generateTopUV(n,r,s-3,s-2,s-1);V(o[0]),V(o[1]),V(o[2])}function B(t,e,i,s){z(t),z(e),z(s),z(e),z(i),z(s);const o=r.length/3,a=m.generateSideWallUV(n,r,o-6,o-3,o-2,o-1);V(a[0]),V(a[1]),V(a[3]),V(a[1]),V(a[2]),V(a[3])}function z(t){r.push(s[3*t+0]),r.push(s[3*t+1]),r.push(s[3*t+2])}function V(t){i.push(t.x),i.push(t.y)}!function(){const t=r.length/3;if(c){let t=0,e=M*t;for(let n=0;n<k;n++){const t=C[n];$(t[2]+e,t[1]+e,t[0]+e)}t=a+2*p,e=M*t;for(let n=0;n<k;n++){const t=C[n];$(t[0]+e,t[1]+e,t[2]+e)}}else{for(let t=0;t<k;t++){const e=C[t];$(e[2],e[1],e[0])}for(let t=0;t<k;t++){const e=C[t];$(e[0]+M*a,e[1]+M*a,e[2]+M*a)}}n.addGroup(t,r.length/3-t,0)}(),function(){const t=r.length/3;let e=0;F(T,e),e+=T.length;for(let n=0,r=E.length;n<r;n++){const t=E[n];F(t,e),e+=t.length}n.addGroup(t,r.length/3-t,1)}()}this.setAttribute("position",new ET(r,3)),this.setAttribute("uv",new ET(i,2)),this.computeVertexNormals()}toJSON(){const t=FT.prototype.toJSON.call(this);return function(t,e,n){if(n.shapes=[],Array.isArray(t))for(let r=0,i=t.length;r<i;r++)n.shapes.push(t[r].uuid);else n.shapes.push(t.uuid);return void 0!==e.extrudePath&&(n.options.extrudePath=e.extrudePath.toJSON()),n}(this.parameters.shapes,this.parameters.options,t)}}const iI={generateTopUV:function(t,e,n,r,i){const s=e[3*r],o=e[3*r+1],a=e[3*i],l=e[3*i+1];return[new IE(e[3*n],e[3*n+1]),new IE(s,o),new IE(a,l)]},generateSideWallUV:function(t,e,n,r,i,s){const o=e[3*n],a=e[3*n+1],l=e[3*n+2],c=e[3*r],u=e[3*r+1],h=e[3*r+2],d=e[3*i],p=e[3*i+1],f=e[3*i+2],m=e[3*s],g=e[3*s+1],y=e[3*s+2];return Math.abs(a-u)<.01?[new IE(o,1-l),new IE(c,1-h),new IE(d,1-f),new IE(m,1-y)]:[new IE(a,1-l),new IE(u,1-h),new IE(p,1-f),new IE(g,1-y)]}};function sI(t,e,n){FT.call(this),this.type="ParametricGeometry",this.parameters={func:t,slices:e,stacks:n};const r=[],i=[],s=[],o=[],a=1e-5,l=new VE,c=new VE,u=new VE,h=new VE,d=new VE;t.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");const p=e+1;for(let f=0;f<=n;f++){const r=f/n;for(let n=0;n<=e;n++){const p=n/e;t(p,r,c),i.push(c.x,c.y,c.z),p-a>=0?(t(p-a,r,u),h.subVectors(c,u)):(t(p+a,r,u),h.subVectors(u,c)),r-a>=0?(t(p,r-a,u),d.subVectors(c,u)):(t(p,r+a,u),d.subVectors(u,c)),l.crossVectors(h,d).normalize(),s.push(l.x,l.y,l.z),o.push(p,r)}}for(let f=0;f<n;f++)for(let t=0;t<e;t++){const e=f*p+t+1,n=(f+1)*p+t+1,i=(f+1)*p+t;r.push(f*p+t,e,i),r.push(e,n,i)}this.setIndex(r),this.setAttribute("position",new ET(i,3)),this.setAttribute("normal",new ET(s,3)),this.setAttribute("uv",new ET(o,2))}(sI.prototype=Object.create(FT.prototype)).constructor=sI;class oI extends FT{constructor(t,e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const n=[],r=[],i=[],s=[];let o=0,a=0;if(!1===Array.isArray(t))l(t);else for(let c=0;c<t.length;c++)l(t[c]),this.addGroup(o,a,c),o+=a,a=0;function l(t){const o=r.length/3,l=t.extractPoints(e);let c=l.shape;const u=l.holes;!1===tI.isClockWise(c)&&(c=c.reverse());for(let e=0,n=u.length;e<n;e++){const t=u[e];!0===tI.isClockWise(t)&&(u[e]=t.reverse())}const h=tI.triangulateShape(c,u);for(let e=0,n=u.length;e<n;e++)c=c.concat(u[e]);for(let e=0,n=c.length;e<n;e++){const t=c[e];r.push(t.x,t.y,0),i.push(0,0,1),s.push(t.x,t.y)}for(let e=0,r=h.length;e<r;e++){const t=h[e];n.push(t[0]+o,t[1]+o,t[2]+o),a+=3}}this.setIndex(n),this.setAttribute("position",new ET(r,3)),this.setAttribute("normal",new ET(i,3)),this.setAttribute("uv",new ET(s,2))}toJSON(){const t=FT.prototype.toJSON.call(this);return function(t,e){if(e.shapes=[],Array.isArray(t))for(let n=0,r=t.length;n<r;n++)e.shapes.push(t[n].uuid);else e.shapes.push(t.uuid);return e}(this.parameters.shapes,t)}}function aI(t){hT.call(this),this.type="ShadowMaterial",this.color=new lT(0),this.transparent=!0,this.setValues(t)}function lI(t){oA.call(this,t),this.type="RawShaderMaterial"}function cI(t){hT.call(this),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new lT(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new lT(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new IE(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.vertexTangents=!1,this.setValues(t)}function uI(t){cI.call(this),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new IE(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,Object.defineProperty(this,"ior",{get:function(){return(1+.4*this.reflectivity)/(1-.4*this.reflectivity)},set:function(t){this.reflectivity=RE.clamp(2.5*(t-1)/(t+1),0,1)}}),this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(t)}function hI(t){hT.call(this),this.type="MeshPhongMaterial",this.color=new lT(16777215),this.specular=new lT(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new lT(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new IE(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}function dI(t){hT.call(this),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new lT(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new lT(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new IE(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}function pI(t){hT.call(this),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new IE(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}function fI(t){hT.call(this),this.type="MeshLambertMaterial",this.color=new lT(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new lT(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}function mI(t){hT.call(this),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new lT(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new IE(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}function gI(t){lR.call(this),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}(aI.prototype=Object.create(hT.prototype)).constructor=aI,aI.prototype.isShadowMaterial=!0,aI.prototype.copy=function(t){return hT.prototype.copy.call(this,t),this.color.copy(t.color),this},(lI.prototype=Object.create(oA.prototype)).constructor=lI,lI.prototype.isRawShaderMaterial=!0,(cI.prototype=Object.create(hT.prototype)).constructor=cI,cI.prototype.isMeshStandardMaterial=!0,cI.prototype.copy=function(t){return hT.prototype.copy.call(this,t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this.vertexTangents=t.vertexTangents,this},(uI.prototype=Object.create(cI.prototype)).constructor=uI,uI.prototype.isMeshPhysicalMaterial=!0,uI.prototype.copy=function(t){return cI.prototype.copy.call(this,t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.reflectivity=t.reflectivity,this.sheen=t.sheen?(this.sheen||new lT).copy(t.sheen):null,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this},(hI.prototype=Object.create(hT.prototype)).constructor=hI,hI.prototype.isMeshPhongMaterial=!0,hI.prototype.copy=function(t){return hT.prototype.copy.call(this,t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this},(dI.prototype=Object.create(hT.prototype)).constructor=dI,dI.prototype.isMeshToonMaterial=!0,dI.prototype.copy=function(t){return hT.prototype.copy.call(this,t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this},(pI.prototype=Object.create(hT.prototype)).constructor=pI,pI.prototype.isMeshNormalMaterial=!0,pI.prototype.copy=function(t){return hT.prototype.copy.call(this,t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this},(fI.prototype=Object.create(hT.prototype)).constructor=fI,fI.prototype.isMeshLambertMaterial=!0,fI.prototype.copy=function(t){return hT.prototype.copy.call(this,t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this},(mI.prototype=Object.create(hT.prototype)).constructor=mI,mI.prototype.isMeshMatcapMaterial=!0,mI.prototype.copy=function(t){return hT.prototype.copy.call(this,t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this},(gI.prototype=Object.create(lR.prototype)).constructor=gI,gI.prototype.isLineDashedMaterial=!0,gI.prototype.copy=function(t){return lR.prototype.copy.call(this,t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this};var yI=Object.freeze({__proto__:null,ShadowMaterial:aI,SpriteMaterial:Mk,RawShaderMaterial:lI,ShaderMaterial:oA,PointsMaterial:bR,MeshPhysicalMaterial:uI,MeshStandardMaterial:cI,MeshPhongMaterial:hI,MeshToonMaterial:dI,MeshNormalMaterial:pI,MeshLambertMaterial:fI,MeshDepthMaterial:dk,MeshDistanceMaterial:pk,MeshBasicMaterial:dT,MeshMatcapMaterial:mI,LineDashedMaterial:gI,LineBasicMaterial:lR,Material:hT});const vI={arraySlice:function(t,e,n){return vI.isTypedArray(t)?new t.constructor(t.subarray(e,void 0!==n?n:t.length)):t.slice(e,n)},convertArray:function(t,e,n){return!t||!n&&t.constructor===e?t:"number"==typeof e.BYTES_PER_ELEMENT?new e(t):Array.prototype.slice.call(t)},isTypedArray:function(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)},getKeyframeOrder:function(t){const e=t.length,n=new Array(e);for(let r=0;r!==e;++r)n[r]=r;return n.sort(function(e,n){return t[e]-t[n]}),n},sortedArray:function(t,e,n){const r=t.length,i=new t.constructor(r);for(let s=0,o=0;o!==r;++s){const r=n[s]*e;for(let n=0;n!==e;++n)i[o++]=t[r+n]}return i},flattenJSON:function(t,e,n,r){let i=1,s=t[0];for(;void 0!==s&&void 0===s[r];)s=t[i++];if(void 0===s)return;let o=s[r];if(void 0!==o)if(Array.isArray(o))do{o=s[r],void 0!==o&&(e.push(s.time),n.push.apply(n,o)),s=t[i++]}while(void 0!==s);else if(void 0!==o.toArray)do{o=s[r],void 0!==o&&(e.push(s.time),o.toArray(n,n.length)),s=t[i++]}while(void 0!==s);else do{o=s[r],void 0!==o&&(e.push(s.time),n.push(o)),s=t[i++]}while(void 0!==s)},subclip:function(t,e,n,r,i=30){const s=t.clone();s.name=e;const o=[];for(let l=0;l<s.tracks.length;++l){const t=s.tracks[l],e=t.getValueSize(),a=[],c=[];for(let s=0;s<t.times.length;++s){const o=t.times[s]*i;if(!(o<n||o>=r)){a.push(t.times[s]);for(let n=0;n<e;++n)c.push(t.values[s*e+n])}}0!==a.length&&(t.times=vI.convertArray(a,t.times.constructor),t.values=vI.convertArray(c,t.values.constructor),o.push(t))}s.tracks=o;let a=1/0;for(let l=0;l<s.tracks.length;++l)a>s.tracks[l].times[0]&&(a=s.tracks[l].times[0]);for(let l=0;l<s.tracks.length;++l)s.tracks[l].shift(-1*a);return s.resetDuration(),s},makeClipAdditive:function(t,e=0,n=t,r=30){r<=0&&(r=30);const i=n.tracks.length,s=e/r;for(let o=0;o<i;++o){const e=n.tracks[o],r=e.ValueTypeName;if("bool"===r||"string"===r)continue;const i=t.tracks.find(function(t){return t.name===e.name&&t.ValueTypeName===r});if(void 0===i)continue;let a=0;const l=e.getValueSize();e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(a=l/3);let c=0;const u=i.getValueSize();i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=u/3);const h=e.times.length-1;let d;if(s<=e.times[0])d=vI.arraySlice(e.values,a,l-a);else if(s>=e.times[h]){const t=h*l+a;d=vI.arraySlice(e.values,t,t+l-a)}else{const t=e.createInterpolant(),n=a,r=l-a;t.evaluate(s),d=vI.arraySlice(t.resultBuffer,n,r)}"quaternion"===r&&(new zE).fromArray(d).normalize().conjugate().toArray(d);const p=i.times.length;for(let t=0;t<p;++t){const e=t*u+c;if("quaternion"===r)zE.multiplyQuaternionsFlat(i.values,e,d,0,i.values,e);else{const t=u-2*c;for(let n=0;n<t;++n)i.values[e+n]-=d[n]}}}return t.blendMode=2501,t}};function bI(t,e,n,r){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=void 0!==r?r:new e.constructor(n),this.sampleValues=e,this.valueSize=n}function _I(t,e,n,r){bI.call(this,t,e,n,r),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0}function xI(t,e,n,r){bI.call(this,t,e,n,r)}function wI(t,e,n,r){bI.call(this,t,e,n,r)}function SI(t,e,n,r){if(void 0===t)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===e||0===e.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=vI.convertArray(e,this.TimeBufferType),this.values=vI.convertArray(n,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}function EI(t,e,n){SI.call(this,t,e,n)}function CI(t,e,n,r){SI.call(this,t,e,n,r)}function TI(t,e,n,r){SI.call(this,t,e,n,r)}function AI(t,e,n,r){bI.call(this,t,e,n,r)}function MI(t,e,n,r){SI.call(this,t,e,n,r)}function kI(t,e,n,r){SI.call(this,t,e,n,r)}function RI(t,e,n,r){SI.call(this,t,e,n,r)}function II(t,e=-1,n,r=2500){this.name=t,this.tracks=n,this.duration=e,this.blendMode=r,this.uuid=RE.generateUUID(),this.duration<0&&this.resetDuration()}function NI(t){if(void 0===t.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=function(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return TI;case"vector":case"vector2":case"vector3":case"vector4":return RI;case"color":return CI;case"quaternion":return MI;case"bool":case"boolean":return EI;case"string":return kI}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}(t.type);if(void 0===t.times){const e=[],n=[];vI.flattenJSON(t.keys,e,n,"value"),t.times=e,t.values=n}return void 0!==e.parse?e.parse(t):new e(t.name,t.times,t.values,t.interpolation)}Object.assign(bI.prototype,{evaluate:function(t){const e=this.parameterPositions;let n=this._cachedIndex,r=e[n],i=e[n-1];t:{e:{let s;n:{r:if(!(t<r)){for(let s=n+2;;){if(void 0===r){if(t<i)break r;return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,t,i)}if(n===s)break;if(i=r,r=e[++n],t<r)break e}s=e.length;break n}if(t>=i)break t;{const o=e[1];t<o&&(n=2,i=o);for(let s=n-2;;){if(void 0===i)return this._cachedIndex=0,this.beforeStart_(0,t,r);if(n===s)break;if(r=i,i=e[--n-1],t>=i)break e}s=n,n=0}}for(;n<s;){const r=n+s>>>1;t<e[r]?s=r:n=r+1}if(r=e[n],i=e[n-1],void 0===i)return this._cachedIndex=0,this.beforeStart_(0,t,r);if(void 0===r)return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,i,t)}this._cachedIndex=n,this.intervalChanged_(n,i,r)}return this.interpolate_(n,i,t,r)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(t){const e=this.resultBuffer,n=this.sampleValues,r=this.valueSize,i=t*r;for(let s=0;s!==r;++s)e[s]=n[i+s];return e},interpolate_:function(){throw new Error("call to abstract method")},intervalChanged_:function(){}}),Object.assign(bI.prototype,{beforeStart_:bI.prototype.copySampleValue_,afterEnd_:bI.prototype.copySampleValue_}),_I.prototype=Object.assign(Object.create(bI.prototype),{constructor:_I,DefaultSettings_:{endingStart:bE,endingEnd:bE},intervalChanged_:function(t,e,n){const r=this.parameterPositions;let i=t-2,s=t+1,o=r[i],a=r[s];if(void 0===o)switch(this.getSettings_().endingStart){case _E:i=t,o=2*e-n;break;case xE:i=r.length-2,o=e+r[i]-r[i+1];break;default:i=t,o=n}if(void 0===a)switch(this.getSettings_().endingEnd){case _E:s=t,a=2*n-e;break;case xE:s=1,a=n+r[1]-r[0];break;default:s=t-1,a=e}const l=.5*(n-e),c=this.valueSize;this._weightPrev=l/(e-o),this._weightNext=l/(a-n),this._offsetPrev=i*c,this._offsetNext=s*c},interpolate_:function(t,e,n,r){const i=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=t*o,l=a-o,c=this._offsetPrev,u=this._offsetNext,h=this._weightPrev,d=this._weightNext,p=(n-e)/(r-e),f=p*p,m=f*p,g=-h*m+2*h*f-h*p,y=(1+h)*m+(-1.5-2*h)*f+(-.5+h)*p+1,v=(-1-d)*m+(1.5+d)*f+.5*p,b=d*m-d*f;for(let _=0;_!==o;++_)i[_]=g*s[c+_]+y*s[l+_]+v*s[a+_]+b*s[u+_];return i}}),xI.prototype=Object.assign(Object.create(bI.prototype),{constructor:xI,interpolate_:function(t,e,n,r){const i=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=t*o,l=a-o,c=(n-e)/(r-e),u=1-c;for(let h=0;h!==o;++h)i[h]=s[l+h]*u+s[a+h]*c;return i}}),wI.prototype=Object.assign(Object.create(bI.prototype),{constructor:wI,interpolate_:function(t){return this.copySampleValue_(t-1)}}),Object.assign(SI,{toJSON:function(t){const e=t.constructor;let n;if(void 0!==e.toJSON)n=e.toJSON(t);else{n={name:t.name,times:vI.convertArray(t.times,Array),values:vI.convertArray(t.values,Array)};const e=t.getInterpolation();e!==t.DefaultInterpolation&&(n.interpolation=e)}return n.type=t.ValueTypeName,n}}),Object.assign(SI.prototype,{constructor:SI,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:yE,InterpolantFactoryMethodDiscrete:function(t){return new wI(this.times,this.values,this.getValueSize(),t)},InterpolantFactoryMethodLinear:function(t){return new xI(this.times,this.values,this.getValueSize(),t)},InterpolantFactoryMethodSmooth:function(t){return new _I(this.times,this.values,this.getValueSize(),t)},setInterpolation:function(t){let e;switch(t){case gE:e=this.InterpolantFactoryMethodDiscrete;break;case yE:e=this.InterpolantFactoryMethodLinear;break;case vE:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){const e="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(t===this.DefaultInterpolation)throw new Error(e);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",e),this}return this.createInterpolant=e,this},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return gE;case this.InterpolantFactoryMethodLinear:return yE;case this.InterpolantFactoryMethodSmooth:return vE}},getValueSize:function(){return this.values.length/this.times.length},shift:function(t){if(0!==t){const e=this.times;for(let n=0,r=e.length;n!==r;++n)e[n]+=t}return this},scale:function(t){if(1!==t){const e=this.times;for(let n=0,r=e.length;n!==r;++n)e[n]*=t}return this},trim:function(t,e){const n=this.times,r=n.length;let i=0,s=r-1;for(;i!==r&&n[i]<t;)++i;for(;-1!==s&&n[s]>e;)--s;if(++s,0!==i||s!==r){i>=s&&(s=Math.max(s,1),i=s-1);const t=this.getValueSize();this.times=vI.arraySlice(n,i,s),this.values=vI.arraySlice(this.values,i*t,s*t)}return this},validate:function(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const n=this.times,r=this.values,i=n.length;0===i&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let s=null;for(let o=0;o!==i;o++){const e=n[o];if("number"==typeof e&&isNaN(e)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,e),t=!1;break}if(null!==s&&s>e){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,e,s),t=!1;break}s=e}if(void 0!==r&&vI.isTypedArray(r))for(let o=0,a=r.length;o!==a;++o){const e=r[o];if(isNaN(e)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,e),t=!1;break}}return t},optimize:function(){const t=vI.arraySlice(this.times),e=vI.arraySlice(this.values),n=this.getValueSize(),r=this.getInterpolation()===vE,i=t.length-1;let s=1;for(let o=1;o<i;++o){let i=!1;const a=t[o];if(a!==t[o+1]&&(1!==o||a!==t[0]))if(r)i=!0;else{const t=o*n,r=t-n,s=t+n;for(let o=0;o!==n;++o){const n=e[t+o];if(n!==e[r+o]||n!==e[s+o]){i=!0;break}}}if(i){if(o!==s){t[s]=t[o];const r=o*n,i=s*n;for(let t=0;t!==n;++t)e[i+t]=e[r+t]}++s}}if(i>0){t[s]=t[i];for(let t=i*n,r=s*n,o=0;o!==n;++o)e[r+o]=e[t+o];++s}return s!==t.length?(this.times=vI.arraySlice(t,0,s),this.values=vI.arraySlice(e,0,s*n)):(this.times=t,this.values=e),this},clone:function(){const t=vI.arraySlice(this.times,0),e=vI.arraySlice(this.values,0),n=new(0,this.constructor)(this.name,t,e);return n.createInterpolant=this.createInterpolant,n}}),EI.prototype=Object.assign(Object.create(SI.prototype),{constructor:EI,ValueTypeName:"bool",ValueBufferType:Array,DefaultInterpolation:gE,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),CI.prototype=Object.assign(Object.create(SI.prototype),{constructor:CI,ValueTypeName:"color"}),TI.prototype=Object.assign(Object.create(SI.prototype),{constructor:TI,ValueTypeName:"number"}),AI.prototype=Object.assign(Object.create(bI.prototype),{constructor:AI,interpolate_:function(t,e,n,r){const i=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=(n-e)/(r-e);let l=t*o;for(let c=l+o;l!==c;l+=4)zE.slerpFlat(i,0,s,l-o,s,l,a);return i}}),MI.prototype=Object.assign(Object.create(SI.prototype),{constructor:MI,ValueTypeName:"quaternion",DefaultInterpolation:yE,InterpolantFactoryMethodLinear:function(t){return new AI(this.times,this.values,this.getValueSize(),t)},InterpolantFactoryMethodSmooth:void 0}),kI.prototype=Object.assign(Object.create(SI.prototype),{constructor:kI,ValueTypeName:"string",ValueBufferType:Array,DefaultInterpolation:gE,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),RI.prototype=Object.assign(Object.create(SI.prototype),{constructor:RI,ValueTypeName:"vector"}),Object.assign(II,{parse:function(t){const e=[],n=t.tracks,r=1/(t.fps||1);for(let s=0,o=n.length;s!==o;++s)e.push(NI(n[s]).scale(r));const i=new II(t.name,t.duration,e,t.blendMode);return i.uuid=t.uuid,i},toJSON:function(t){const e=[],n=t.tracks,r={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let i=0,s=n.length;i!==s;++i)e.push(SI.toJSON(n[i]));return r},CreateFromMorphTargetSequence:function(t,e,n,r){const i=e.length,s=[];for(let o=0;o<i;o++){let t=[],a=[];t.push((o+i-1)%i,o,(o+1)%i),a.push(0,1,0);const l=vI.getKeyframeOrder(t);t=vI.sortedArray(t,1,l),a=vI.sortedArray(a,1,l),r||0!==t[0]||(t.push(i),a.push(a[0])),s.push(new TI(".morphTargetInfluences["+e[o].name+"]",t,a).scale(1/n))}return new II(t,-1,s)},findByName:function(t,e){let n=t;if(!Array.isArray(t)){const e=t;n=e.geometry&&e.geometry.animations||e.animations}for(let r=0;r<n.length;r++)if(n[r].name===e)return n[r];return null},CreateClipsFromMorphTargetSequences:function(t,e,n){const r={},i=/^([\w-]*?)([\d]+)$/;for(let o=0,a=t.length;o<a;o++){const e=t[o],n=e.name.match(i);if(n&&n.length>1){const t=n[1];let i=r[t];i||(r[t]=i=[]),i.push(e)}}const s=[];for(const o in r)s.push(II.CreateFromMorphTargetSequence(o,r[o],e,n));return s},parseAnimation:function(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(t,e,n,r,i){if(0!==n.length){const s=[],o=[];vI.flattenJSON(n,s,o,r),0!==s.length&&i.push(new t(e,s,o))}},r=[],i=t.name||"default",s=t.fps||30,o=t.blendMode;let a=t.length||-1;const l=t.hierarchy||[];for(let c=0;c<l.length;c++){const t=l[c].keys;if(t&&0!==t.length)if(t[0].morphTargets){const e={};let n;for(n=0;n<t.length;n++)if(t[n].morphTargets)for(let r=0;r<t[n].morphTargets.length;r++)e[t[n].morphTargets[r]]=-1;for(const i in e){const e=[],s=[];for(let r=0;r!==t[n].morphTargets.length;++r){const r=t[n];e.push(r.time),s.push(r.morphTarget===i?1:0)}r.push(new TI(".morphTargetInfluence["+i+"]",e,s))}a=e.length*(s||1)}else{const i=".bones["+e[c].name+"]";n(RI,i+".position",t,"pos",r),n(MI,i+".quaternion",t,"rot",r),n(RI,i+".scale",t,"scl",r)}}return 0===r.length?null:new II(i,a,r,o)}}),Object.assign(II.prototype,{resetDuration:function(){let t=0;for(let e=0,n=this.tracks.length;e!==n;++e){const n=this.tracks[e];t=Math.max(t,n.times[n.times.length-1])}return this.duration=t,this},trim:function(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this},validate:function(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t},optimize:function(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this},clone:function(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new II(this.name,this.duration,t,this.blendMode)},toJSON:function(){return II.toJSON(this)}});const OI={enabled:!1,files:{},add:function(t,e){!1!==this.enabled&&(this.files[t]=e)},get:function(t){if(!1!==this.enabled)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}},DI=new function(t,e,n){const r=this;let i,s=!1,o=0,a=0;const l=[];this.onStart=void 0,this.onLoad=void 0,this.onProgress=void 0,this.onError=void 0,this.itemStart=function(t){a++,!1===s&&void 0!==r.onStart&&r.onStart(t,o,a),s=!0},this.itemEnd=function(t){o++,void 0!==r.onProgress&&r.onProgress(t,o,a),o===a&&(s=!1,void 0!==r.onLoad&&r.onLoad())},this.itemError=function(t){void 0!==r.onError&&r.onError(t)},this.resolveURL=function(t){return i?i(t):t},this.setURLModifier=function(t){return i=t,this},this.addHandler=function(t,e){return l.push(t,e),this},this.removeHandler=function(t){const e=l.indexOf(t);return-1!==e&&l.splice(e,2),this},this.getHandler=function(t){for(let e=0,n=l.length;e<n;e+=2){const n=l[e],r=l[e+1];if(n.global&&(n.lastIndex=0),n.test(t))return r}return null}};function LI(t){this.manager=void 0!==t?t:DI,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}Object.assign(LI.prototype,{load:function(){},loadAsync:function(t,e){const n=this;return new Promise(function(r,i){n.load(t,r,e,i)})},parse:function(){},setCrossOrigin:function(t){return this.crossOrigin=t,this},setWithCredentials:function(t){return this.withCredentials=t,this},setPath:function(t){return this.path=t,this},setResourcePath:function(t){return this.resourcePath=t,this},setRequestHeader:function(t){return this.requestHeader=t,this}});const FI={};function PI(t){LI.call(this,t)}function $I(t){LI.call(this,t)}function BI(t){LI.call(this,t)}function zI(t){LI.call(this,t)}function VI(t){LI.call(this,t)}function UI(t){LI.call(this,t)}function HI(t){LI.call(this,t)}function WI(){this.type="Curve",this.arcLengthDivisions=200}function jI(t,e,n,r,i,s,o,a){WI.call(this),this.type="EllipseCurve",this.aX=t||0,this.aY=e||0,this.xRadius=n||1,this.yRadius=r||1,this.aStartAngle=i||0,this.aEndAngle=s||2*Math.PI,this.aClockwise=o||!1,this.aRotation=a||0}function GI(t,e,n,r,i,s){jI.call(this,t,e,n,n,r,i,s),this.type="ArcCurve"}function qI(){let t=0,e=0,n=0,r=0;function i(i,s,o,a){t=i,e=o,n=-3*i+3*s-2*o-a,r=2*i-2*s+o+a}return{initCatmullRom:function(t,e,n,r,s){i(e,n,s*(n-t),s*(r-e))},initNonuniformCatmullRom:function(t,e,n,r,s,o,a){let l=(e-t)/s-(n-t)/(s+o)+(n-e)/o,c=(n-e)/o-(r-e)/(o+a)+(r-n)/a;l*=o,c*=o,i(e,n,l,c)},calc:function(i){const s=i*i;return t+e*i+n*s+r*(s*i)}}}PI.prototype=Object.assign(Object.create(LI.prototype),{constructor:PI,load:function(t,e,n,r){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const i=this,s=OI.get(t);if(void 0!==s)return i.manager.itemStart(t),setTimeout(function(){e&&e(s),i.manager.itemEnd(t)},0),s;if(void 0!==FI[t])return void FI[t].push({onLoad:e,onProgress:n,onError:r});const o=t.match(/^data:(.*?)(;base64)?,(.*)$/);let a;if(o){const n=o[1],s=!!o[2];let a=o[3];a=decodeURIComponent(a),s&&(a=atob(a));try{let r;const s=(this.responseType||"").toLowerCase();switch(s){case"arraybuffer":case"blob":const t=new Uint8Array(a.length);for(let n=0;n<a.length;n++)t[n]=a.charCodeAt(n);r="blob"===s?new Blob([t.buffer],{type:n}):t.buffer;break;case"document":const e=new DOMParser;r=e.parseFromString(a,n);break;case"json":r=JSON.parse(a);break;default:r=a}setTimeout(function(){e&&e(r),i.manager.itemEnd(t)},0)}catch(l){setTimeout(function(){r&&r(l),i.manager.itemError(t),i.manager.itemEnd(t)},0)}}else{FI[t]=[],FI[t].push({onLoad:e,onProgress:n,onError:r}),a=new XMLHttpRequest,a.open("GET",t,!0),a.addEventListener("load",function(e){const n=this.response,r=FI[t];if(delete FI[t],200===this.status||0===this.status){0===this.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),OI.add(t,n);for(let t=0,e=r.length;t<e;t++){const e=r[t];e.onLoad&&e.onLoad(n)}i.manager.itemEnd(t)}else{for(let t=0,n=r.length;t<n;t++){const n=r[t];n.onError&&n.onError(e)}i.manager.itemError(t),i.manager.itemEnd(t)}},!1),a.addEventListener("progress",function(e){const n=FI[t];for(let t=0,r=n.length;t<r;t++){const r=n[t];r.onProgress&&r.onProgress(e)}},!1),a.addEventListener("error",function(e){const n=FI[t];delete FI[t];for(let t=0,r=n.length;t<r;t++){const r=n[t];r.onError&&r.onError(e)}i.manager.itemError(t),i.manager.itemEnd(t)},!1),a.addEventListener("abort",function(e){const n=FI[t];delete FI[t];for(let t=0,r=n.length;t<r;t++){const r=n[t];r.onError&&r.onError(e)}i.manager.itemError(t),i.manager.itemEnd(t)},!1),void 0!==this.responseType&&(a.responseType=this.responseType),void 0!==this.withCredentials&&(a.withCredentials=this.withCredentials),a.overrideMimeType&&a.overrideMimeType(void 0!==this.mimeType?this.mimeType:"text/plain");for(const t in this.requestHeader)a.setRequestHeader(t,this.requestHeader[t]);a.send(null)}return i.manager.itemStart(t),a},setResponseType:function(t){return this.responseType=t,this},setMimeType:function(t){return this.mimeType=t,this}}),$I.prototype=Object.assign(Object.create(LI.prototype),{constructor:$I,load:function(t,e,n,r){const i=this,s=new PI(i.manager);s.setPath(i.path),s.setRequestHeader(i.requestHeader),s.setWithCredentials(i.withCredentials),s.load(t,function(n){try{e(i.parse(JSON.parse(n)))}catch(s){r?r(s):console.error(s),i.manager.itemError(t)}},n,r)},parse:function(t){const e=[];for(let n=0;n<t.length;n++){const r=II.parse(t[n]);e.push(r)}return e}}),BI.prototype=Object.assign(Object.create(LI.prototype),{constructor:BI,load:function(t,e,n,r){const i=this,s=[],o=new AR,a=new PI(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(i.withCredentials);let l=0;function c(c){a.load(t[c],function(t){const n=i.parse(t,!0);s[c]={width:n.width,height:n.height,format:n.format,mipmaps:n.mipmaps},l+=1,6===l&&(1===n.mipmapCount&&(o.minFilter=sE),o.image=s,o.format=n.format,o.needsUpdate=!0,e&&e(o))},n,r)}if(Array.isArray(t))for(let u=0,h=t.length;u<h;++u)c(u);else a.load(t,function(t){const n=i.parse(t,!0);if(n.isCubemap){const t=n.mipmaps.length/n.mipmapCount;for(let e=0;e<t;e++){s[e]={mipmaps:[]};for(let t=0;t<n.mipmapCount;t++)s[e].mipmaps.push(n.mipmaps[e*n.mipmapCount+t]),s[e].format=n.format,s[e].width=n.width,s[e].height=n.height}o.image=s}else o.image.width=n.width,o.image.height=n.height,o.mipmaps=n.mipmaps;1===n.mipmapCount&&(o.minFilter=sE),o.format=n.format,o.needsUpdate=!0,e&&e(o)},n,r);return o}}),zI.prototype=Object.assign(Object.create(LI.prototype),{constructor:zI,load:function(t,e,n,r){void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const i=this,s=OI.get(t);if(void 0!==s)return i.manager.itemStart(t),setTimeout(function(){e&&e(s),i.manager.itemEnd(t)},0),s;const o=document.createElementNS("http://www.w3.org/1999/xhtml","img");function a(){o.removeEventListener("load",a,!1),o.removeEventListener("error",l,!1),OI.add(t,this),e&&e(this),i.manager.itemEnd(t)}function l(e){o.removeEventListener("load",a,!1),o.removeEventListener("error",l,!1),r&&r(e),i.manager.itemError(t),i.manager.itemEnd(t)}return o.addEventListener("load",a,!1),o.addEventListener("error",l,!1),"data:"!==t.substr(0,5)&&void 0!==this.crossOrigin&&(o.crossOrigin=this.crossOrigin),i.manager.itemStart(t),o.src=t,o}}),VI.prototype=Object.assign(Object.create(LI.prototype),{constructor:VI,load:function(t,e,n,r){const i=new hA,s=new zI(this.manager);s.setCrossOrigin(this.crossOrigin),s.setPath(this.path);let o=0;function a(n){s.load(t[n],function(t){i.images[n]=t,o++,6===o&&(i.needsUpdate=!0,e&&e(i))},void 0,r)}for(let l=0;l<t.length;++l)a(l);return i}}),UI.prototype=Object.assign(Object.create(LI.prototype),{constructor:UI,load:function(t,e,n,r){const i=this,s=new pA,o=new PI(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(i.withCredentials),o.load(t,function(t){const n=i.parse(t);n&&(void 0!==n.image?s.image=n.image:void 0!==n.data&&(s.image.width=n.width,s.image.height=n.height,s.image.data=n.data),s.wrapS=void 0!==n.wrapS?n.wrapS:nE,s.wrapT=void 0!==n.wrapT?n.wrapT:nE,s.magFilter=void 0!==n.magFilter?n.magFilter:sE,s.minFilter=void 0!==n.minFilter?n.minFilter:sE,s.anisotropy=void 0!==n.anisotropy?n.anisotropy:1,void 0!==n.encoding&&(s.encoding=n.encoding),void 0!==n.flipY&&(s.flipY=n.flipY),void 0!==n.format&&(s.format=n.format),void 0!==n.type&&(s.type=n.type),void 0!==n.mipmaps&&(s.mipmaps=n.mipmaps,s.minFilter=oE),1===n.mipmapCount&&(s.minFilter=sE),s.needsUpdate=!0,e&&e(s,n))},n,r),s}}),HI.prototype=Object.assign(Object.create(LI.prototype),{constructor:HI,load:function(t,e,n,r){const i=new FE,s=new zI(this.manager);return s.setCrossOrigin(this.crossOrigin),s.setPath(this.path),s.load(t,function(n){i.image=n;const r=t.search(/\.jpe?g($|\?)/i)>0||0===t.search(/^data\:image\/jpeg/);i.format=r?dE:pE,i.needsUpdate=!0,void 0!==e&&e(i)},n,r),i}}),Object.assign(WI.prototype,{getPoint:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null},getPointAt:function(t,e){const n=this.getUtoTmapping(t);return this.getPoint(n,e)},getPoints:function(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return e},getSpacedPoints:function(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPointAt(n/t));return e},getLength:function(){const t=this.getLengths();return t[t.length-1]},getLengths:function(t){if(void 0===t&&(t=this.arcLengthDivisions),this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let n,r=this.getPoint(0),i=0;e.push(0);for(let s=1;s<=t;s++)n=this.getPoint(s/t),i+=n.distanceTo(r),e.push(i),r=n;return this.cacheArcLengths=e,e},updateArcLengths:function(){this.needsUpdate=!0,this.getLengths()},getUtoTmapping:function(t,e){const n=this.getLengths();let r=0;const i=n.length;let s;s=e||t*n[i-1];let o,a=0,l=i-1;for(;a<=l;)if(r=Math.floor(a+(l-a)/2),o=n[r]-s,o<0)a=r+1;else{if(!(o>0)){l=r;break}l=r-1}if(r=l,n[r]===s)return r/(i-1);const c=n[r];return(r+(s-c)/(n[r+1]-c))/(i-1)},getTangent:function(t,e){const n=1e-4;let r=t-n,i=t+n;r<0&&(r=0),i>1&&(i=1);const s=this.getPoint(r),o=this.getPoint(i),a=e||(s.isVector2?new IE:new VE);return a.copy(o).sub(s).normalize(),a},getTangentAt:function(t,e){const n=this.getUtoTmapping(t);return this.getTangent(n,e)},computeFrenetFrames:function(t,e){const n=new VE,r=[],i=[],s=[],o=new VE,a=new mC;for(let d=0;d<=t;d++)r[d]=this.getTangentAt(d/t,new VE),r[d].normalize();i[0]=new VE,s[0]=new VE;let l=Number.MAX_VALUE;const c=Math.abs(r[0].x),u=Math.abs(r[0].y),h=Math.abs(r[0].z);c<=l&&(l=c,n.set(1,0,0)),u<=l&&(l=u,n.set(0,1,0)),h<=l&&n.set(0,0,1),o.crossVectors(r[0],n).normalize(),i[0].crossVectors(r[0],o),s[0].crossVectors(r[0],i[0]);for(let d=1;d<=t;d++){if(i[d]=i[d-1].clone(),s[d]=s[d-1].clone(),o.crossVectors(r[d-1],r[d]),o.length()>Number.EPSILON){o.normalize();const t=Math.acos(RE.clamp(r[d-1].dot(r[d]),-1,1));i[d].applyMatrix4(a.makeRotationAxis(o,t))}s[d].crossVectors(r[d],i[d])}if(!0===e){let e=Math.acos(RE.clamp(i[0].dot(i[t]),-1,1));e/=t,r[0].dot(o.crossVectors(i[0],i[t]))>0&&(e=-e);for(let n=1;n<=t;n++)i[n].applyMatrix4(a.makeRotationAxis(r[n],e*n)),s[n].crossVectors(r[n],i[n])}return{tangents:r,normals:i,binormals:s}},clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.arcLengthDivisions=t.arcLengthDivisions,this},toJSON:function(){const t={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t},fromJSON:function(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}),(jI.prototype=Object.create(WI.prototype)).constructor=jI,jI.prototype.isEllipseCurve=!0,jI.prototype.getPoint=function(t,e){const n=e||new IE,r=2*Math.PI;let i=this.aEndAngle-this.aStartAngle;const s=Math.abs(i)<Number.EPSILON;for(;i<0;)i+=r;for(;i>r;)i-=r;i<Number.EPSILON&&(i=s?0:r),!0!==this.aClockwise||s||(i===r?i=-r:i-=r);const o=this.aStartAngle+t*i;let a=this.aX+this.xRadius*Math.cos(o),l=this.aY+this.yRadius*Math.sin(o);if(0!==this.aRotation){const t=Math.cos(this.aRotation),e=Math.sin(this.aRotation),n=a-this.aX,r=l-this.aY;a=n*t-r*e+this.aX,l=n*e+r*t+this.aY}return n.set(a,l)},jI.prototype.copy=function(t){return WI.prototype.copy.call(this,t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this},jI.prototype.toJSON=function(){const t=WI.prototype.toJSON.call(this);return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t},jI.prototype.fromJSON=function(t){return WI.prototype.fromJSON.call(this,t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this},(GI.prototype=Object.create(jI.prototype)).constructor=GI,GI.prototype.isArcCurve=!0;const XI=new VE,KI=new qI,YI=new qI,ZI=new qI;function JI(t=[],e=!1,n="centripetal",r=.5){WI.call(this),this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=n,this.tension=r}function QI(t,e,n,r,i){const s=.5*(r-e),o=.5*(i-n),a=t*t;return(2*n-2*r+s+o)*(t*a)+(-3*n+3*r-2*s-o)*a+s*t+n}function tN(t,e,n,r){return function(t,e){const n=1-t;return n*n*e}(t,e)+function(t,e){return 2*(1-t)*t*e}(t,n)+function(t,e){return t*t*e}(t,r)}function eN(t,e,n,r,i){return function(t,e){const n=1-t;return n*n*n*e}(t,e)+function(t,e){const n=1-t;return 3*n*n*t*e}(t,n)+function(t,e){return 3*(1-t)*t*t*e}(t,r)+function(t,e){return t*t*t*e}(t,i)}function nN(t=new IE,e=new IE,n=new IE,r=new IE){WI.call(this),this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=n,this.v3=r}function rN(t=new VE,e=new VE,n=new VE,r=new VE){WI.call(this),this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=n,this.v3=r}function iN(t=new IE,e=new IE){WI.call(this),this.type="LineCurve",this.v1=t,this.v2=e}function sN(t=new VE,e=new VE){WI.call(this),this.type="LineCurve3",this.v1=t,this.v2=e}function oN(t=new IE,e=new IE,n=new IE){WI.call(this),this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=n}function aN(t=new VE,e=new VE,n=new VE){WI.call(this),this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=n}function lN(t=[]){WI.call(this),this.type="SplineCurve",this.points=t}(JI.prototype=Object.create(WI.prototype)).constructor=JI,JI.prototype.isCatmullRomCurve3=!0,JI.prototype.getPoint=function(t,e=new VE){const n=e,r=this.points,i=r.length,s=(i-(this.closed?0:1))*t;let o,a,l=Math.floor(s),c=s-l;this.closed?l+=l>0?0:(Math.floor(Math.abs(l)/i)+1)*i:0===c&&l===i-1&&(l=i-2,c=1),this.closed||l>0?o=r[(l-1)%i]:(XI.subVectors(r[0],r[1]).add(r[0]),o=XI);const u=r[l%i],h=r[(l+1)%i];if(this.closed||l+2<i?a=r[(l+2)%i]:(XI.subVectors(r[i-1],r[i-2]).add(r[i-1]),a=XI),"centripetal"===this.curveType||"chordal"===this.curveType){const t="chordal"===this.curveType?.5:.25;let e=Math.pow(o.distanceToSquared(u),t),n=Math.pow(u.distanceToSquared(h),t),r=Math.pow(h.distanceToSquared(a),t);n<1e-4&&(n=1),e<1e-4&&(e=n),r<1e-4&&(r=n),KI.initNonuniformCatmullRom(o.x,u.x,h.x,a.x,e,n,r),YI.initNonuniformCatmullRom(o.y,u.y,h.y,a.y,e,n,r),ZI.initNonuniformCatmullRom(o.z,u.z,h.z,a.z,e,n,r)}else"catmullrom"===this.curveType&&(KI.initCatmullRom(o.x,u.x,h.x,a.x,this.tension),YI.initCatmullRom(o.y,u.y,h.y,a.y,this.tension),ZI.initCatmullRom(o.z,u.z,h.z,a.z,this.tension));return n.set(KI.calc(c),YI.calc(c),ZI.calc(c)),n},JI.prototype.copy=function(t){WI.prototype.copy.call(this,t),this.points=[];for(let e=0,n=t.points.length;e<n;e++)this.points.push(t.points[e].clone());return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this},JI.prototype.toJSON=function(){const t=WI.prototype.toJSON.call(this);t.points=[];for(let e=0,n=this.points.length;e<n;e++)t.points.push(this.points[e].toArray());return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t},JI.prototype.fromJSON=function(t){WI.prototype.fromJSON.call(this,t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push((new VE).fromArray(n))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this},(nN.prototype=Object.create(WI.prototype)).constructor=nN,nN.prototype.isCubicBezierCurve=!0,nN.prototype.getPoint=function(t,e=new IE){const n=e,r=this.v0,i=this.v1,s=this.v2,o=this.v3;return n.set(eN(t,r.x,i.x,s.x,o.x),eN(t,r.y,i.y,s.y,o.y)),n},nN.prototype.copy=function(t){return WI.prototype.copy.call(this,t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this},nN.prototype.toJSON=function(){const t=WI.prototype.toJSON.call(this);return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t},nN.prototype.fromJSON=function(t){return WI.prototype.fromJSON.call(this,t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this},(rN.prototype=Object.create(WI.prototype)).constructor=rN,rN.prototype.isCubicBezierCurve3=!0,rN.prototype.getPoint=function(t,e=new VE){const n=e,r=this.v0,i=this.v1,s=this.v2,o=this.v3;return n.set(eN(t,r.x,i.x,s.x,o.x),eN(t,r.y,i.y,s.y,o.y),eN(t,r.z,i.z,s.z,o.z)),n},rN.prototype.copy=function(t){return WI.prototype.copy.call(this,t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this},rN.prototype.toJSON=function(){const t=WI.prototype.toJSON.call(this);return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t},rN.prototype.fromJSON=function(t){return WI.prototype.fromJSON.call(this,t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this},(iN.prototype=Object.create(WI.prototype)).constructor=iN,iN.prototype.isLineCurve=!0,iN.prototype.getPoint=function(t,e=new IE){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n},iN.prototype.getPointAt=function(t,e){return this.getPoint(t,e)},iN.prototype.getTangent=function(t,e){const n=e||new IE;return n.copy(this.v2).sub(this.v1).normalize(),n},iN.prototype.copy=function(t){return WI.prototype.copy.call(this,t),this.v1.copy(t.v1),this.v2.copy(t.v2),this},iN.prototype.toJSON=function(){const t=WI.prototype.toJSON.call(this);return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t},iN.prototype.fromJSON=function(t){return WI.prototype.fromJSON.call(this,t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this},(sN.prototype=Object.create(WI.prototype)).constructor=sN,sN.prototype.isLineCurve3=!0,sN.prototype.getPoint=function(t,e=new VE){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n},sN.prototype.getPointAt=function(t,e){return this.getPoint(t,e)},sN.prototype.copy=function(t){return WI.prototype.copy.call(this,t),this.v1.copy(t.v1),this.v2.copy(t.v2),this},sN.prototype.toJSON=function(){const t=WI.prototype.toJSON.call(this);return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t},sN.prototype.fromJSON=function(t){return WI.prototype.fromJSON.call(this,t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this},(oN.prototype=Object.create(WI.prototype)).constructor=oN,oN.prototype.isQuadraticBezierCurve=!0,oN.prototype.getPoint=function(t,e=new IE){const n=e,r=this.v0,i=this.v1,s=this.v2;return n.set(tN(t,r.x,i.x,s.x),tN(t,r.y,i.y,s.y)),n},oN.prototype.copy=function(t){return WI.prototype.copy.call(this,t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this},oN.prototype.toJSON=function(){const t=WI.prototype.toJSON.call(this);return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t},oN.prototype.fromJSON=function(t){return WI.prototype.fromJSON.call(this,t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this},(aN.prototype=Object.create(WI.prototype)).constructor=aN,aN.prototype.isQuadraticBezierCurve3=!0,aN.prototype.getPoint=function(t,e=new VE){const n=e,r=this.v0,i=this.v1,s=this.v2;return n.set(tN(t,r.x,i.x,s.x),tN(t,r.y,i.y,s.y),tN(t,r.z,i.z,s.z)),n},aN.prototype.copy=function(t){return WI.prototype.copy.call(this,t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this},aN.prototype.toJSON=function(){const t=WI.prototype.toJSON.call(this);return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t},aN.prototype.fromJSON=function(t){return WI.prototype.fromJSON.call(this,t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this},(lN.prototype=Object.create(WI.prototype)).constructor=lN,lN.prototype.isSplineCurve=!0,lN.prototype.getPoint=function(t,e=new IE){const n=e,r=this.points,i=(r.length-1)*t,s=Math.floor(i),o=i-s,a=r[0===s?s:s-1],l=r[s],c=r[s>r.length-2?r.length-1:s+1],u=r[s>r.length-3?r.length-1:s+2];return n.set(QI(o,a.x,l.x,c.x,u.x),QI(o,a.y,l.y,c.y,u.y)),n},lN.prototype.copy=function(t){WI.prototype.copy.call(this,t),this.points=[];for(let e=0,n=t.points.length;e<n;e++)this.points.push(t.points[e].clone());return this},lN.prototype.toJSON=function(){const t=WI.prototype.toJSON.call(this);t.points=[];for(let e=0,n=this.points.length;e<n;e++)t.points.push(this.points[e].toArray());return t},lN.prototype.fromJSON=function(t){WI.prototype.fromJSON.call(this,t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push((new IE).fromArray(n))}return this};var cN=Object.freeze({__proto__:null,ArcCurve:GI,CatmullRomCurve3:JI,CubicBezierCurve:nN,CubicBezierCurve3:rN,EllipseCurve:jI,LineCurve:iN,LineCurve3:sN,QuadraticBezierCurve:oN,QuadraticBezierCurve3:aN,SplineCurve:lN});function uN(){WI.call(this),this.type="CurvePath",this.curves=[],this.autoClose=!1}function hN(t){uN.call(this),this.type="Path",this.currentPoint=new IE,t&&this.setFromPoints(t)}function dN(t){hN.call(this,t),this.uuid=RE.generateUUID(),this.type="Shape",this.holes=[]}function pN(t,e=1){zC.call(this),this.type="Light",this.color=new lT(t),this.intensity=e}function fN(t,e,n){pN.call(this,t,n),this.type="HemisphereLight",this.position.copy(zC.DefaultUp),this.updateMatrix(),this.groundColor=new lT(e)}function mN(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new IE(512,512),this.map=null,this.mapPass=null,this.matrix=new mC,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new gA,this._frameExtents=new IE(1,1),this._viewportCount=1,this._viewports=[new $E(0,0,1,1)]}function gN(){mN.call(this,new lA(50,1,.5,500)),this.focus=1}function yN(t,e,n,r,i,s){pN.call(this,t,e),this.type="SpotLight",this.position.copy(zC.DefaultUp),this.updateMatrix(),this.target=new zC,Object.defineProperty(this,"power",{get:function(){return this.intensity*Math.PI},set:function(t){this.intensity=t/Math.PI}}),this.distance=void 0!==n?n:0,this.angle=void 0!==r?r:Math.PI/3,this.penumbra=void 0!==i?i:0,this.decay=void 0!==s?s:1,this.shadow=new gN}function vN(){mN.call(this,new lA(90,1,.5,500)),this._frameExtents=new IE(4,2),this._viewportCount=6,this._viewports=[new $E(2,1,1,1),new $E(0,1,1,1),new $E(3,1,1,1),new $E(1,1,1,1),new $E(3,0,1,1),new $E(1,0,1,1)],this._cubeDirections=[new VE(1,0,0),new VE(-1,0,0),new VE(0,0,1),new VE(0,0,-1),new VE(0,1,0),new VE(0,-1,0)],this._cubeUps=[new VE(0,1,0),new VE(0,1,0),new VE(0,1,0),new VE(0,1,0),new VE(0,0,1),new VE(0,0,-1)]}function bN(t,e,n,r){pN.call(this,t,e),this.type="PointLight",Object.defineProperty(this,"power",{get:function(){return 4*this.intensity*Math.PI},set:function(t){this.intensity=t/(4*Math.PI)}}),this.distance=void 0!==n?n:0,this.decay=void 0!==r?r:1,this.shadow=new vN}function _N(t=-1,e=1,n=1,r=-1,i=.1,s=2e3){aA.call(this),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=r,this.near=i,this.far=s,this.updateProjectionMatrix()}function xN(){mN.call(this,new _N(-5,5,5,-5,.5,500))}function wN(t,e){pN.call(this,t,e),this.type="DirectionalLight",this.position.copy(zC.DefaultUp),this.updateMatrix(),this.target=new zC,this.shadow=new xN}function SN(t,e){pN.call(this,t,e),this.type="AmbientLight"}function EN(t,e,n,r){pN.call(this,t,e),this.type="RectAreaLight",this.width=void 0!==n?n:10,this.height=void 0!==r?r:10}uN.prototype=Object.assign(Object.create(WI.prototype),{constructor:uN,add:function(t){this.curves.push(t)},closePath:function(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new iN(e,t))},getPoint:function(t){const e=t*this.getLength(),n=this.getCurveLengths();let r=0;for(;r<n.length;){if(n[r]>=e){const t=n[r]-e,i=this.curves[r],s=i.getLength();return i.getPointAt(0===s?0:1-t/s)}r++}return null},getLength:function(){const t=this.getCurveLengths();return t[t.length-1]},updateArcLengths:function(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()},getCurveLengths:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let n=0,r=this.curves.length;n<r;n++)e+=this.curves[n].getLength(),t.push(e);return this.cacheLengths=t,t},getSpacedPoints:function(t=40){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return this.autoClose&&e.push(e[0]),e},getPoints:function(t=12){const e=[];let n;for(let r=0,i=this.curves;r<i.length;r++){const s=i[r],o=s.getPoints(s&&s.isEllipseCurve?2*t:s&&(s.isLineCurve||s.isLineCurve3)?1:s&&s.isSplineCurve?t*s.points.length:t);for(let t=0;t<o.length;t++){const r=o[t];n&&n.equals(r)||(e.push(r),n=r)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e},copy:function(t){WI.prototype.copy.call(this,t),this.curves=[];for(let e=0,n=t.curves.length;e<n;e++)this.curves.push(t.curves[e].clone());return this.autoClose=t.autoClose,this},toJSON:function(){const t=WI.prototype.toJSON.call(this);t.autoClose=this.autoClose,t.curves=[];for(let e=0,n=this.curves.length;e<n;e++)t.curves.push(this.curves[e].toJSON());return t},fromJSON:function(t){WI.prototype.fromJSON.call(this,t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const n=t.curves[e];this.curves.push((new cN[n.type]).fromJSON(n))}return this}}),hN.prototype=Object.assign(Object.create(uN.prototype),{constructor:hN,setFromPoints:function(t){this.moveTo(t[0].x,t[0].y);for(let e=1,n=t.length;e<n;e++)this.lineTo(t[e].x,t[e].y);return this},moveTo:function(t,e){return this.currentPoint.set(t,e),this},lineTo:function(t,e){const n=new iN(this.currentPoint.clone(),new IE(t,e));return this.curves.push(n),this.currentPoint.set(t,e),this},quadraticCurveTo:function(t,e,n,r){const i=new oN(this.currentPoint.clone(),new IE(t,e),new IE(n,r));return this.curves.push(i),this.currentPoint.set(n,r),this},bezierCurveTo:function(t,e,n,r,i,s){const o=new nN(this.currentPoint.clone(),new IE(t,e),new IE(n,r),new IE(i,s));return this.curves.push(o),this.currentPoint.set(i,s),this},splineThru:function(t){const e=new lN([this.currentPoint.clone()].concat(t));return this.curves.push(e),this.currentPoint.copy(t[t.length-1]),this},arc:function(t,e,n,r,i,s){return this.absarc(t+this.currentPoint.x,e+this.currentPoint.y,n,r,i,s),this},absarc:function(t,e,n,r,i,s){return this.absellipse(t,e,n,n,r,i,s),this},ellipse:function(t,e,n,r,i,s,o,a){return this.absellipse(t+this.currentPoint.x,e+this.currentPoint.y,n,r,i,s,o,a),this},absellipse:function(t,e,n,r,i,s,o,a){const l=new jI(t,e,n,r,i,s,o,a);if(this.curves.length>0){const t=l.getPoint(0);t.equals(this.currentPoint)||this.lineTo(t.x,t.y)}this.curves.push(l);const c=l.getPoint(1);return this.currentPoint.copy(c),this},copy:function(t){return uN.prototype.copy.call(this,t),this.currentPoint.copy(t.currentPoint),this},toJSON:function(){const t=uN.prototype.toJSON.call(this);return t.currentPoint=this.currentPoint.toArray(),t},fromJSON:function(t){return uN.prototype.fromJSON.call(this,t),this.currentPoint.fromArray(t.currentPoint),this}}),dN.prototype=Object.assign(Object.create(hN.prototype),{constructor:dN,getPointsHoles:function(t){const e=[];for(let n=0,r=this.holes.length;n<r;n++)e[n]=this.holes[n].getPoints(t);return e},extractPoints:function(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}},copy:function(t){hN.prototype.copy.call(this,t),this.holes=[];for(let e=0,n=t.holes.length;e<n;e++)this.holes.push(t.holes[e].clone());return this},toJSON:function(){const t=hN.prototype.toJSON.call(this);t.uuid=this.uuid,t.holes=[];for(let e=0,n=this.holes.length;e<n;e++)t.holes.push(this.holes[e].toJSON());return t},fromJSON:function(t){hN.prototype.fromJSON.call(this,t),this.uuid=t.uuid,this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const n=t.holes[e];this.holes.push((new hN).fromJSON(n))}return this}}),pN.prototype=Object.assign(Object.create(zC.prototype),{constructor:pN,isLight:!0,copy:function(t){return zC.prototype.copy.call(this,t),this.color.copy(t.color),this.intensity=t.intensity,this},toJSON:function(t){const e=zC.prototype.toJSON.call(this,t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,void 0!==this.groundColor&&(e.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(e.object.distance=this.distance),void 0!==this.angle&&(e.object.angle=this.angle),void 0!==this.decay&&(e.object.decay=this.decay),void 0!==this.penumbra&&(e.object.penumbra=this.penumbra),void 0!==this.shadow&&(e.object.shadow=this.shadow.toJSON()),e}}),fN.prototype=Object.assign(Object.create(pN.prototype),{constructor:fN,isHemisphereLight:!0,copy:function(t){return pN.prototype.copy.call(this,t),this.groundColor.copy(t.groundColor),this}}),Object.assign(mN.prototype,{_projScreenMatrix:new mC,_lightPositionWorld:new VE,_lookTarget:new VE,getViewportCount:function(){return this._viewportCount},getFrustum:function(){return this._frustum},updateMatrices:function(t){const e=this.camera,n=this.matrix,r=this._projScreenMatrix,i=this._lookTarget,s=this._lightPositionWorld;s.setFromMatrixPosition(t.matrixWorld),e.position.copy(s),i.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(i),e.updateMatrixWorld(),r.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(r),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(e.projectionMatrix),n.multiply(e.matrixWorldInverse)},getViewport:function(t){return this._viewports[t]},getFrameExtents:function(){return this._frameExtents},copy:function(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this},clone:function(){return(new this.constructor).copy(this)},toJSON:function(){const t={};return 0!==this.bias&&(t.bias=this.bias),0!==this.normalBias&&(t.normalBias=this.normalBias),1!==this.radius&&(t.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}),gN.prototype=Object.assign(Object.create(mN.prototype),{constructor:gN,isSpotLightShadow:!0,updateMatrices:function(t){const e=this.camera,n=2*RE.RAD2DEG*t.angle*this.focus,r=this.mapSize.width/this.mapSize.height,i=t.distance||e.far;n===e.fov&&r===e.aspect&&i===e.far||(e.fov=n,e.aspect=r,e.far=i,e.updateProjectionMatrix()),mN.prototype.updateMatrices.call(this,t)}}),yN.prototype=Object.assign(Object.create(pN.prototype),{constructor:yN,isSpotLight:!0,copy:function(t){return pN.prototype.copy.call(this,t),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}),vN.prototype=Object.assign(Object.create(mN.prototype),{constructor:vN,isPointLightShadow:!0,updateMatrices:function(t,e=0){const n=this.camera,r=this.matrix,i=this._lightPositionWorld,s=this._lookTarget,o=this._projScreenMatrix;i.setFromMatrixPosition(t.matrixWorld),n.position.copy(i),s.copy(n.position),s.add(this._cubeDirections[e]),n.up.copy(this._cubeUps[e]),n.lookAt(s),n.updateMatrixWorld(),r.makeTranslation(-i.x,-i.y,-i.z),o.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(o)}}),bN.prototype=Object.assign(Object.create(pN.prototype),{constructor:bN,isPointLight:!0,copy:function(t){return pN.prototype.copy.call(this,t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}),_N.prototype=Object.assign(Object.create(aA.prototype),{constructor:_N,isOrthographicCamera:!0,copy:function(t,e){return aA.prototype.copy.call(this,t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=null===t.view?null:Object.assign({},t.view),this},setViewOffset:function(t,e,n,r,i,s){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=r,this.view.width=i,this.view.height=s,this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let i=n-t,s=n+t,o=r+e,a=r-e;if(null!==this.view&&this.view.enabled){const t=(this.right-this.left)/this.view.fullWidth/this.zoom,e=(this.top-this.bottom)/this.view.fullHeight/this.zoom;i+=t*this.view.offsetX,s=i+t*this.view.width,o-=e*this.view.offsetY,a=o-e*this.view.height}this.projectionMatrix.makeOrthographic(i,s,o,a,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(t){const e=zC.prototype.toJSON.call(this,t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}}),xN.prototype=Object.assign(Object.create(mN.prototype),{constructor:xN,isDirectionalLightShadow:!0,updateMatrices:function(t){mN.prototype.updateMatrices.call(this,t)}}),wN.prototype=Object.assign(Object.create(pN.prototype),{constructor:wN,isDirectionalLight:!0,copy:function(t){return pN.prototype.copy.call(this,t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}),SN.prototype=Object.assign(Object.create(pN.prototype),{constructor:SN,isAmbientLight:!0}),EN.prototype=Object.assign(Object.create(pN.prototype),{constructor:EN,isRectAreaLight:!0,copy:function(t){return pN.prototype.copy.call(this,t),this.width=t.width,this.height=t.height,this},toJSON:function(t){const e=pN.prototype.toJSON.call(this,t);return e.object.width=this.width,e.object.height=this.height,e}});class CN{constructor(){Object.defineProperty(this,"isSphericalHarmonics3",{value:!0}),this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new VE)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const n=t.x,r=t.y,i=t.z,s=this.coefficients;return e.copy(s[0]).multiplyScalar(.282095),e.addScaledVector(s[1],.488603*r),e.addScaledVector(s[2],.488603*i),e.addScaledVector(s[3],.488603*n),e.addScaledVector(s[4],n*r*1.092548),e.addScaledVector(s[5],r*i*1.092548),e.addScaledVector(s[6],.315392*(3*i*i-1)),e.addScaledVector(s[7],n*i*1.092548),e.addScaledVector(s[8],.546274*(n*n-r*r)),e}getIrradianceAt(t,e){const n=t.x,r=t.y,i=t.z,s=this.coefficients;return e.copy(s[0]).multiplyScalar(.886227),e.addScaledVector(s[1],1.023328*r),e.addScaledVector(s[2],1.023328*i),e.addScaledVector(s[3],1.023328*n),e.addScaledVector(s[4],.858086*n*r),e.addScaledVector(s[5],.858086*r*i),e.addScaledVector(s[6],.743125*i*i-.247708),e.addScaledVector(s[7],.858086*n*i),e.addScaledVector(s[8],.429043*(n*n-r*r)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(t.coefficients[n],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let n=0;n<9;n++)this.coefficients[n].lerp(t.coefficients[n],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(t,e=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].fromArray(t,e+3*r);return this}toArray(t=[],e=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].toArray(t,e+3*r);return t}static getBasisAt(t,e){const n=t.x,r=t.y,i=t.z;e[0]=.282095,e[1]=.488603*r,e[2]=.488603*i,e[3]=.488603*n,e[4]=1.092548*n*r,e[5]=1.092548*r*i,e[6]=.315392*(3*i*i-1),e[7]=1.092548*n*i,e[8]=.546274*(n*n-r*r)}}function TN(t,e){pN.call(this,void 0,e),this.type="LightProbe",this.sh=void 0!==t?t:new CN}function AN(t){LI.call(this,t),this.textures={}}function MN(){FT.call(this),this.type="InstancedBufferGeometry",this.instanceCount=1/0}function kN(t,e,n,r){"number"==typeof n&&(r=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),mT.call(this,t,e,n),this.meshPerAttribute=r||1}function RN(t){LI.call(this,t)}function IN(t){"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),LI.call(this,t),this.options={premultiplyAlpha:"none"}}function NN(){this.type="ShapePath",this.color=new lT,this.subPaths=[],this.currentPath=null}TN.prototype=Object.assign(Object.create(pN.prototype),{constructor:TN,isLightProbe:!0,copy:function(t){return pN.prototype.copy.call(this,t),this.sh.copy(t.sh),this},fromJSON:function(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this},toJSON:function(t){const e=pN.prototype.toJSON.call(this,t);return e.object.sh=this.sh.toArray(),e}}),AN.prototype=Object.assign(Object.create(LI.prototype),{constructor:AN,load:function(t,e,n,r){const i=this,s=new PI(i.manager);s.setPath(i.path),s.setRequestHeader(i.requestHeader),s.setWithCredentials(i.withCredentials),s.load(t,function(n){try{e(i.parse(JSON.parse(n)))}catch(s){r?r(s):console.error(s),i.manager.itemError(t)}},n,r)},parse:function(t){const e=this.textures;function n(t){return void 0===e[t]&&console.warn("THREE.MaterialLoader: Undefined texture",t),e[t]}const r=new yI[t.type];if(void 0!==t.uuid&&(r.uuid=t.uuid),void 0!==t.name&&(r.name=t.name),void 0!==t.color&&void 0!==r.color&&r.color.setHex(t.color),void 0!==t.roughness&&(r.roughness=t.roughness),void 0!==t.metalness&&(r.metalness=t.metalness),void 0!==t.sheen&&(r.sheen=(new lT).setHex(t.sheen)),void 0!==t.emissive&&void 0!==r.emissive&&r.emissive.setHex(t.emissive),void 0!==t.specular&&void 0!==r.specular&&r.specular.setHex(t.specular),void 0!==t.shininess&&(r.shininess=t.shininess),void 0!==t.clearcoat&&(r.clearcoat=t.clearcoat),void 0!==t.clearcoatRoughness&&(r.clearcoatRoughness=t.clearcoatRoughness),void 0!==t.fog&&(r.fog=t.fog),void 0!==t.flatShading&&(r.flatShading=t.flatShading),void 0!==t.blending&&(r.blending=t.blending),void 0!==t.combine&&(r.combine=t.combine),void 0!==t.side&&(r.side=t.side),void 0!==t.opacity&&(r.opacity=t.opacity),void 0!==t.transparent&&(r.transparent=t.transparent),void 0!==t.alphaTest&&(r.alphaTest=t.alphaTest),void 0!==t.depthTest&&(r.depthTest=t.depthTest),void 0!==t.depthWrite&&(r.depthWrite=t.depthWrite),void 0!==t.colorWrite&&(r.colorWrite=t.colorWrite),void 0!==t.stencilWrite&&(r.stencilWrite=t.stencilWrite),void 0!==t.stencilWriteMask&&(r.stencilWriteMask=t.stencilWriteMask),void 0!==t.stencilFunc&&(r.stencilFunc=t.stencilFunc),void 0!==t.stencilRef&&(r.stencilRef=t.stencilRef),void 0!==t.stencilFuncMask&&(r.stencilFuncMask=t.stencilFuncMask),void 0!==t.stencilFail&&(r.stencilFail=t.stencilFail),void 0!==t.stencilZFail&&(r.stencilZFail=t.stencilZFail),void 0!==t.stencilZPass&&(r.stencilZPass=t.stencilZPass),void 0!==t.wireframe&&(r.wireframe=t.wireframe),void 0!==t.wireframeLinewidth&&(r.wireframeLinewidth=t.wireframeLinewidth),void 0!==t.wireframeLinecap&&(r.wireframeLinecap=t.wireframeLinecap),void 0!==t.wireframeLinejoin&&(r.wireframeLinejoin=t.wireframeLinejoin),void 0!==t.rotation&&(r.rotation=t.rotation),1!==t.linewidth&&(r.linewidth=t.linewidth),void 0!==t.dashSize&&(r.dashSize=t.dashSize),void 0!==t.gapSize&&(r.gapSize=t.gapSize),void 0!==t.scale&&(r.scale=t.scale),void 0!==t.polygonOffset&&(r.polygonOffset=t.polygonOffset),void 0!==t.polygonOffsetFactor&&(r.polygonOffsetFactor=t.polygonOffsetFactor),void 0!==t.polygonOffsetUnits&&(r.polygonOffsetUnits=t.polygonOffsetUnits),void 0!==t.skinning&&(r.skinning=t.skinning),void 0!==t.morphTargets&&(r.morphTargets=t.morphTargets),void 0!==t.morphNormals&&(r.morphNormals=t.morphNormals),void 0!==t.dithering&&(r.dithering=t.dithering),void 0!==t.vertexTangents&&(r.vertexTangents=t.vertexTangents),void 0!==t.visible&&(r.visible=t.visible),void 0!==t.toneMapped&&(r.toneMapped=t.toneMapped),void 0!==t.userData&&(r.userData=t.userData),void 0!==t.vertexColors&&(r.vertexColors="number"==typeof t.vertexColors?t.vertexColors>0:t.vertexColors),void 0!==t.uniforms)for(const i in t.uniforms){const e=t.uniforms[i];switch(r.uniforms[i]={},e.type){case"t":r.uniforms[i].value=n(e.value);break;case"c":r.uniforms[i].value=(new lT).setHex(e.value);break;case"v2":r.uniforms[i].value=(new IE).fromArray(e.value);break;case"v3":r.uniforms[i].value=(new VE).fromArray(e.value);break;case"v4":r.uniforms[i].value=(new $E).fromArray(e.value);break;case"m3":r.uniforms[i].value=(new NE).fromArray(e.value);break;case"m4":r.uniforms[i].value=(new mC).fromArray(e.value);break;default:r.uniforms[i].value=e.value}}if(void 0!==t.defines&&(r.defines=t.defines),void 0!==t.vertexShader&&(r.vertexShader=t.vertexShader),void 0!==t.fragmentShader&&(r.fragmentShader=t.fragmentShader),void 0!==t.extensions)for(const i in t.extensions)r.extensions[i]=t.extensions[i];if(void 0!==t.shading&&(r.flatShading=1===t.shading),void 0!==t.size&&(r.size=t.size),void 0!==t.sizeAttenuation&&(r.sizeAttenuation=t.sizeAttenuation),void 0!==t.map&&(r.map=n(t.map)),void 0!==t.matcap&&(r.matcap=n(t.matcap)),void 0!==t.alphaMap&&(r.alphaMap=n(t.alphaMap)),void 0!==t.bumpMap&&(r.bumpMap=n(t.bumpMap)),void 0!==t.bumpScale&&(r.bumpScale=t.bumpScale),void 0!==t.normalMap&&(r.normalMap=n(t.normalMap)),void 0!==t.normalMapType&&(r.normalMapType=t.normalMapType),void 0!==t.normalScale){let e=t.normalScale;!1===Array.isArray(e)&&(e=[e,e]),r.normalScale=(new IE).fromArray(e)}return void 0!==t.displacementMap&&(r.displacementMap=n(t.displacementMap)),void 0!==t.displacementScale&&(r.displacementScale=t.displacementScale),void 0!==t.displacementBias&&(r.displacementBias=t.displacementBias),void 0!==t.roughnessMap&&(r.roughnessMap=n(t.roughnessMap)),void 0!==t.metalnessMap&&(r.metalnessMap=n(t.metalnessMap)),void 0!==t.emissiveMap&&(r.emissiveMap=n(t.emissiveMap)),void 0!==t.emissiveIntensity&&(r.emissiveIntensity=t.emissiveIntensity),void 0!==t.specularMap&&(r.specularMap=n(t.specularMap)),void 0!==t.envMap&&(r.envMap=n(t.envMap)),void 0!==t.envMapIntensity&&(r.envMapIntensity=t.envMapIntensity),void 0!==t.reflectivity&&(r.reflectivity=t.reflectivity),void 0!==t.refractionRatio&&(r.refractionRatio=t.refractionRatio),void 0!==t.lightMap&&(r.lightMap=n(t.lightMap)),void 0!==t.lightMapIntensity&&(r.lightMapIntensity=t.lightMapIntensity),void 0!==t.aoMap&&(r.aoMap=n(t.aoMap)),void 0!==t.aoMapIntensity&&(r.aoMapIntensity=t.aoMapIntensity),void 0!==t.gradientMap&&(r.gradientMap=n(t.gradientMap)),void 0!==t.clearcoatMap&&(r.clearcoatMap=n(t.clearcoatMap)),void 0!==t.clearcoatRoughnessMap&&(r.clearcoatRoughnessMap=n(t.clearcoatRoughnessMap)),void 0!==t.clearcoatNormalMap&&(r.clearcoatNormalMap=n(t.clearcoatNormalMap)),void 0!==t.clearcoatNormalScale&&(r.clearcoatNormalScale=(new IE).fromArray(t.clearcoatNormalScale)),void 0!==t.transmission&&(r.transmission=t.transmission),void 0!==t.transmissionMap&&(r.transmissionMap=n(t.transmissionMap)),r},setTextures:function(t){return this.textures=t,this}}),MN.prototype=Object.assign(Object.create(FT.prototype),{constructor:MN,isInstancedBufferGeometry:!0,copy:function(t){return FT.prototype.copy.call(this,t),this.instanceCount=t.instanceCount,this},clone:function(){return(new this.constructor).copy(this)},toJSON:function(){const t=FT.prototype.toJSON.call(this);return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}),kN.prototype=Object.assign(Object.create(mT.prototype),{constructor:kN,isInstancedBufferAttribute:!0,copy:function(t){return mT.prototype.copy.call(this,t),this.meshPerAttribute=t.meshPerAttribute,this},toJSON:function(){const t=mT.prototype.toJSON.call(this);return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}),RN.prototype=Object.assign(Object.create(LI.prototype),{constructor:RN,load:function(t,e,n,r){const i=this,s=new PI(i.manager);s.setPath(i.path),s.setRequestHeader(i.requestHeader),s.setWithCredentials(i.withCredentials),s.load(t,function(n){try{e(i.parse(JSON.parse(n)))}catch(s){r?r(s):console.error(s),i.manager.itemError(t)}},n,r)},parse:function(t){const e={},n={};function r(t,r){if(void 0!==e[r])return e[r];const i=t.interleavedBuffers[r],s=function(t,e){if(void 0!==n[e])return n[e];const r=new Uint32Array(t.arrayBuffers[e]).buffer;return n[e]=r,r}(t,i.buffer),o=new Ck(MT(i.type,s),i.stride);return o.uuid=i.uuid,e[r]=o,o}const i=t.isInstancedBufferGeometry?new MN:new FT,s=t.data.index;if(void 0!==s){const t=MT(s.type,s.array);i.setIndex(new mT(t,1))}const o=t.data.attributes;for(const u in o){const e=o[u];let n;if(e.isInterleavedBufferAttribute)n=new Ak(r(t.data,e.data),e.itemSize,e.offset,e.normalized);else{const t=MT(e.type,e.array);n=new(e.isInstancedBufferAttribute?kN:mT)(t,e.itemSize,e.normalized)}void 0!==e.name&&(n.name=e.name),i.setAttribute(u,n)}const a=t.data.morphAttributes;if(a)for(const u in a){const e=a[u],n=[];for(let i=0,s=e.length;i<s;i++){const s=e[i];let o;o=s.isInterleavedBufferAttribute?new Ak(r(t.data,s.data),s.itemSize,s.offset,s.normalized):new mT(MT(s.type,s.array),s.itemSize,s.normalized),void 0!==s.name&&(o.name=s.name),n.push(o)}i.morphAttributes[u]=n}t.data.morphTargetsRelative&&(i.morphTargetsRelative=!0);const l=t.data.groups||t.data.drawcalls||t.data.offsets;if(void 0!==l)for(let u=0,h=l.length;u!==h;++u){const t=l[u];i.addGroup(t.start,t.count,t.materialIndex)}const c=t.data.boundingSphere;if(void 0!==c){const t=new VE;void 0!==c.center&&t.fromArray(c.center),i.boundingSphere=new oC(t,c.radius)}return t.name&&(i.name=t.name),t.userData&&(i.userData=t.userData),i}}),IN.prototype=Object.assign(Object.create(LI.prototype),{constructor:IN,isImageBitmapLoader:!0,setOptions:function(t){return this.options=t,this},load:function(t,e,n,r){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const i=this,s=OI.get(t);if(void 0!==s)return i.manager.itemStart(t),setTimeout(function(){e&&e(s),i.manager.itemEnd(t)},0),s;const o={};o.credentials="anonymous"===this.crossOrigin?"same-origin":"include",fetch(t,o).then(function(t){return t.blob()}).then(function(t){return createImageBitmap(t,i.options)}).then(function(n){OI.add(t,n),e&&e(n),i.manager.itemEnd(t)}).catch(function(e){r&&r(e),i.manager.itemError(t),i.manager.itemEnd(t)}),i.manager.itemStart(t)}}),Object.assign(NN.prototype,{moveTo:function(t,e){return this.currentPath=new hN,this.subPaths.push(this.currentPath),this.currentPath.moveTo(t,e),this},lineTo:function(t,e){return this.currentPath.lineTo(t,e),this},quadraticCurveTo:function(t,e,n,r){return this.currentPath.quadraticCurveTo(t,e,n,r),this},bezierCurveTo:function(t,e,n,r,i,s){return this.currentPath.bezierCurveTo(t,e,n,r,i,s),this},splineThru:function(t){return this.currentPath.splineThru(t),this},toShapes:function(t,e){function n(t){const e=[];for(let n=0,r=t.length;n<r;n++){const r=t[n],i=new dN;i.curves=r.curves,e.push(i)}return e}function r(t,e){const n=e.length;let r=!1;for(let i=n-1,s=0;s<n;i=s++){let n=e[i],o=e[s],a=o.x-n.x,l=o.y-n.y;if(Math.abs(l)>Number.EPSILON){if(l<0&&(n=e[s],a=-a,o=e[i],l=-l),t.y<n.y||t.y>o.y)continue;if(t.y===n.y){if(t.x===n.x)return!0}else{const e=l*(t.x-n.x)-a*(t.y-n.y);if(0===e)return!0;if(e<0)continue;r=!r}}else{if(t.y!==n.y)continue;if(o.x<=t.x&&t.x<=n.x||n.x<=t.x&&t.x<=o.x)return!0}}return r}const i=tI.isClockWise,s=this.subPaths;if(0===s.length)return[];if(!0===e)return n(s);let o,a,l;const c=[];if(1===s.length)return a=s[0],l=new dN,l.curves=a.curves,c.push(l),c;let u=!i(s[0].getPoints());u=t?!u:u;const h=[],d=[];let p,f,m=[],g=0;d[g]=void 0,m[g]=[];for(let y=0,v=s.length;y<v;y++)a=s[y],p=a.getPoints(),o=i(p),o=t?!o:o,o?(!u&&d[g]&&g++,d[g]={s:new dN,p:p},d[g].s.curves=a.curves,u&&g++,m[g]=[]):m[g].push({h:a,p:p[0]});if(!d[0])return n(s);if(d.length>1){let t=!1;const e=[];for(let n=0,r=d.length;n<r;n++)h[n]=[];for(let n=0,i=d.length;n<i;n++){const i=m[n];for(let s=0;s<i.length;s++){const o=i[s];let a=!0;for(let i=0;i<d.length;i++)r(o.p,d[i].p)&&(n!==i&&e.push({froms:n,tos:i,hole:s}),a?(a=!1,h[i].push(o)):t=!0);a&&h[n].push(o)}}e.length>0&&(t||(m=h))}for(let y=0,v=d.length;y<v;y++){l=d[y].s,c.push(l),f=m[y];for(let t=0,e=f.length;t<e;t++)l.holes.push(f[t].h)}return c}});class ON{constructor(t){Object.defineProperty(this,"isFont",{value:!0}),this.type="Font",this.data=t}generateShapes(t,e=100){const n=[],r=function(t,e,n){const r=Array.from?Array.from(t):String(t).split(""),i=e/n.resolution,s=(n.boundingBox.yMax-n.boundingBox.yMin+n.underlineThickness)*i,o=[];let a=0,l=0;for(let c=0;c<r.length;c++){const t=r[c];if("\n"===t)a=0,l-=s;else{const e=DN(t,i,a,l,n);a+=e.offsetX,o.push(e.path)}}return o}(t,e,this.data);for(let i=0,s=r.length;i<s;i++)Array.prototype.push.apply(n,r[i].toShapes());return n}}function DN(t,e,n,r,i){const s=i.glyphs[t]||i.glyphs["?"];if(!s)return void console.error('THREE.Font: character "'+t+'" does not exists in font family '+i.familyName+".");const o=new NN;let a,l,c,u,h,d,p,f;if(s.o){const t=s._cachedOutline||(s._cachedOutline=s.o.split(" "));for(let i=0,s=t.length;i<s;)switch(t[i++]){case"m":a=t[i++]*e+n,l=t[i++]*e+r,o.moveTo(a,l);break;case"l":a=t[i++]*e+n,l=t[i++]*e+r,o.lineTo(a,l);break;case"q":c=t[i++]*e+n,u=t[i++]*e+r,h=t[i++]*e+n,d=t[i++]*e+r,o.quadraticCurveTo(h,d,c,u);break;case"b":c=t[i++]*e+n,u=t[i++]*e+r,h=t[i++]*e+n,d=t[i++]*e+r,p=t[i++]*e+n,f=t[i++]*e+r,o.bezierCurveTo(h,d,p,f,c,u)}}return{offsetX:s.ha*e,path:o}}function LN(t){LI.call(this,t)}let FN;function PN(t){LI.call(this,t)}function $N(t,e,n){TN.call(this,void 0,n);const r=(new lT).set(t),i=(new lT).set(e),s=new VE(r.r,r.g,r.b),o=new VE(i.r,i.g,i.b),a=Math.sqrt(Math.PI),l=a*Math.sqrt(.75);this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a),this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l)}function BN(t,e){TN.call(this,void 0,e);const n=(new lT).set(t);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}LN.prototype=Object.assign(Object.create(LI.prototype),{constructor:LN,load:function(t,e,n,r){const i=this,s=new PI(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(i.withCredentials),s.load(t,function(t){let n;try{n=JSON.parse(t)}catch(s){console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),n=JSON.parse(t.substring(65,t.length-2))}const r=i.parse(n);e&&e(r)},n,r)},parse:function(t){return new ON(t)}}),PN.prototype=Object.assign(Object.create(LI.prototype),{constructor:PN,load:function(t,e,n,r){const i=this,s=new PI(i.manager);s.setResponseType("arraybuffer"),s.setPath(i.path),s.setRequestHeader(i.requestHeader),s.setWithCredentials(i.withCredentials),s.load(t,function(n){try{const t=n.slice(0);(void 0===FN&&(FN=new(window.AudioContext||window.webkitAudioContext)),FN).decodeAudioData(t,function(t){e(t)})}catch(s){r?r(s):console.error(s),i.manager.itemError(t)}},n,r)}}),$N.prototype=Object.assign(Object.create(TN.prototype),{constructor:$N,isHemisphereLightProbe:!0,copy:function(t){return TN.prototype.copy.call(this,t),this},toJSON:function(t){return TN.prototype.toJSON.call(this,t)}}),BN.prototype=Object.assign(Object.create(TN.prototype),{constructor:BN,isAmbientLightProbe:!0,copy:function(t){return TN.prototype.copy.call(this,t),this},toJSON:function(t){return TN.prototype.toJSON.call(this,t)}});const zN=new mC,VN=new mC;function UN(t,e,n){let r,i,s;switch(this.binding=t,this.valueSize=n,e){case"quaternion":r=this._slerp,i=this._slerpAdditive,s=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*n),this._workIndex=5;break;case"string":case"bool":r=this._select,i=this._select,s=this._setAdditiveIdentityOther,this.buffer=new Array(5*n);break;default:r=this._lerp,i=this._lerpAdditive,s=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*n)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=i,this._setIdentity=s,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}Object.assign((function(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new lA,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new lA,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}).prototype,{update:function(t){const e=this._cache;if(e.focus!==t.focus||e.fov!==t.fov||e.aspect!==t.aspect*this.aspect||e.near!==t.near||e.far!==t.far||e.zoom!==t.zoom||e.eyeSep!==this.eyeSep){e.focus=t.focus,e.fov=t.fov,e.aspect=t.aspect*this.aspect,e.near=t.near,e.far=t.far,e.zoom=t.zoom,e.eyeSep=this.eyeSep;const n=t.projectionMatrix.clone(),r=e.eyeSep/2,i=r*e.near/e.focus,s=e.near*Math.tan(RE.DEG2RAD*e.fov*.5)/e.zoom;let o,a;VN.elements[12]=-r,zN.elements[12]=r,o=-s*e.aspect+i,a=s*e.aspect+i,n.elements[0]=2*e.near/(a-o),n.elements[8]=(a+o)/(a-o),this.cameraL.projectionMatrix.copy(n),o=-s*e.aspect-i,a=s*e.aspect-i,n.elements[0]=2*e.near/(a-o),n.elements[8]=(a+o)/(a-o),this.cameraR.projectionMatrix.copy(n)}this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(VN),this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(zN)}}),Object.assign(UN.prototype,{accumulate:function(t,e){const n=this.buffer,r=this.valueSize,i=t*r+r;let s=this.cumulativeWeight;if(0===s){for(let t=0;t!==r;++t)n[i+t]=n[t];s=e}else s+=e,this._mixBufferRegion(n,i,0,e/s,r);this.cumulativeWeight=s},accumulateAdditive:function(t){const e=this.buffer,n=this.valueSize,r=n*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(e,r,0,t,n),this.cumulativeWeightAdditive+=t},apply:function(t){const e=this.valueSize,n=this.buffer,r=t*e+e,i=this.cumulativeWeight,s=this.cumulativeWeightAdditive,o=this.binding;this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,i<1&&this._mixBufferRegion(n,r,e*this._origIndex,1-i,e),s>0&&this._mixBufferRegionAdditive(n,r,this._addIndex*e,1,e);for(let a=e,l=e+e;a!==l;++a)if(n[a]!==n[a+e]){o.setValue(n,r);break}},saveOriginalState:function(){const t=this.buffer,e=this.valueSize,n=e*this._origIndex;this.binding.getValue(t,n);for(let r=e,i=n;r!==i;++r)t[r]=t[n+r%e];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0},restoreOriginalState:function(){this.binding.setValue(this.buffer,3*this.valueSize)},_setAdditiveIdentityNumeric:function(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let n=t;n<e;n++)this.buffer[n]=0},_setAdditiveIdentityQuaternion:function(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1},_setAdditiveIdentityOther:function(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[e+n]=this.buffer[t+n]},_select:function(t,e,n,r,i){if(r>=.5)for(let s=0;s!==i;++s)t[e+s]=t[n+s]},_slerp:function(t,e,n,r){zE.slerpFlat(t,e,t,e,t,n,r)},_slerpAdditive:function(t,e,n,r,i){const s=this._workIndex*i;zE.multiplyQuaternionsFlat(t,s,t,e,t,n),zE.slerpFlat(t,e,t,e,t,s,r)},_lerp:function(t,e,n,r,i){const s=1-r;for(let o=0;o!==i;++o){const i=e+o;t[i]=t[i]*s+t[n+o]*r}},_lerpAdditive:function(t,e,n,r,i){for(let s=0;s!==i;++s){const i=e+s;t[i]=t[i]+t[n+s]*r}}});const HN=new RegExp("[\\[\\]\\.:\\/]","g"),WN="[^\\[\\]\\.:\\/]",jN="[^"+"\\[\\]\\.:\\/".replace("\\.","")+"]",GN=/((?:WC+[\/:])*)/.source.replace("WC",WN),qN=/(WCOD+)?/.source.replace("WCOD",jN),XN=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",WN),KN=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",WN),YN=new RegExp("^"+GN+qN+XN+KN+"$"),ZN=["material","materials","bones"];function JN(t,e,n){const r=n||QN.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,r)}function QN(t,e,n){this.path=e,this.parsedPath=n||QN.parseTrackName(e),this.node=QN.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t}Object.assign(JN.prototype,{getValue:function(t,e){this.bind();const n=this._bindings[this._targetGroup.nCachedObjects_];void 0!==n&&n.getValue(t,e)},setValue:function(t,e){const n=this._bindings;for(let r=this._targetGroup.nCachedObjects_,i=n.length;r!==i;++r)n[r].setValue(t,e)},bind:function(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].bind()},unbind:function(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].unbind()}}),Object.assign(QN,{Composite:JN,create:function(t,e,n){return t&&t.isAnimationObjectGroup?new QN.Composite(t,e,n):new QN(t,e,n)},sanitizeNodeName:function(t){return t.replace(/\s/g,"_").replace(HN,"")},parseTrackName:function(t){const e=YN.exec(t);if(!e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const n={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},r=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==r&&-1!==r){const t=n.nodeName.substring(r+1);-1!==ZN.indexOf(t)&&(n.nodeName=n.nodeName.substring(0,r),n.objectName=t)}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return n},findNode:function(t,e){if(!e||""===e||"."===e||-1===e||e===t.name||e===t.uuid)return t;if(t.skeleton){const n=t.skeleton.getBoneByName(e);if(void 0!==n)return n}if(t.children){const n=function(t){for(let r=0;r<t.length;r++){const i=t[r];if(i.name===e||i.uuid===e)return i;const s=n(i.children);if(s)return s}return null},r=n(t.children);if(r)return r}return null}}),Object.assign(QN.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(t,e){t[e]=this.node[this.propertyName]},function(t,e){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)t[e++]=n[r]},function(t,e){t[e]=this.resolvedProperty[this.propertyIndex]},function(t,e){this.resolvedProperty.toArray(t,e)}],SetterByBindingTypeAndVersioning:[[function(t,e){this.targetObject[this.propertyName]=t[e]},function(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0},function(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,e){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=t[e++]},function(t,e){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=t[e++];this.targetObject.needsUpdate=!0},function(t,e){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,e){this.resolvedProperty[this.propertyIndex]=t[e]},function(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0},function(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,e){this.resolvedProperty.fromArray(t,e)},function(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0},function(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}]],getValue:function(t,e){this.bind(),this.getValue(t,e)},setValue:function(t,e){this.bind(),this.setValue(t,e)},bind:function(){let t=this.node;const e=this.parsedPath,n=e.objectName,r=e.propertyName;let i=e.propertyIndex;if(t||(t=QN.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(n){let r=e.objectIndex;switch(n){case"materials":if(!t.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);t=t.material.materials;break;case"bones":if(!t.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);t=t.skeleton.bones;for(let e=0;e<t.length;e++)if(t[e].name===r){r=e;break}break;default:if(void 0===t[n])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);t=t[n]}if(void 0!==r){if(void 0===t[r])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);t=t[r]}}const s=t[r];if(void 0===s)return void console.error("THREE.PropertyBinding: Trying to update property for track: "+e.nodeName+"."+r+" but it wasn't found.",t);let o=this.Versioning.None;this.targetObject=t,void 0!==t.needsUpdate?o=this.Versioning.NeedsUpdate:void 0!==t.matrixWorldNeedsUpdate&&(o=this.Versioning.MatrixWorldNeedsUpdate);let a=this.BindingType.Direct;if(void 0!==i){if("morphTargetInfluences"===r){if(!t.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!t.geometry.isBufferGeometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);if(!t.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==t.morphTargetDictionary[i]&&(i=t.morphTargetDictionary[i])}a=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=i}else void 0!==s.fromArray&&void 0!==s.toArray?(a=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(a=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=r;this.getValue=this.GetterByBindingType[a],this.setValue=this.SetterByBindingTypeAndVersioning[a][o]},unbind:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}),Object.assign(QN.prototype,{_getValue_unbound:QN.prototype.getValue,_setValue_unbound:QN.prototype.setValue}),Object.assign((function(){this.uuid=RE.generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const t={};this._indicesByUUID=t;for(let n=0,r=arguments.length;n!==r;++n)t[arguments[n].uuid]=n;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const e=this;this.stats={objects:{get total(){return e._objects.length},get inUse(){return this.total-e.nCachedObjects_}},get bindingsPerObject(){return e._bindings.length}}}).prototype,{isAnimationObjectGroup:!0,add:function(){const t=this._objects,e=this._indicesByUUID,n=this._paths,r=this._parsedPaths,i=this._bindings,s=i.length;let o,a=t.length,l=this.nCachedObjects_;for(let c=0,u=arguments.length;c!==u;++c){const u=arguments[c],h=u.uuid;let d=e[h];if(void 0===d){d=a++,e[h]=d,t.push(u);for(let t=0,e=s;t!==e;++t)i[t].push(new QN(u,n[t],r[t]))}else if(d<l){o=t[d];const a=--l,c=t[a];e[c.uuid]=d,t[d]=c,e[h]=a,t[a]=u;for(let t=0,e=s;t!==e;++t){const e=i[t];let s=e[d];e[d]=e[a],void 0===s&&(s=new QN(u,n[t],r[t])),e[a]=s}}else t[d]!==o&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l},remove:function(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,r=n.length;let i=this.nCachedObjects_;for(let s=0,o=arguments.length;s!==o;++s){const o=arguments[s],a=o.uuid,l=e[a];if(void 0!==l&&l>=i){const s=i++,c=t[s];e[c.uuid]=l,t[l]=c,e[a]=s,t[s]=o;for(let t=0,e=r;t!==e;++t){const e=n[t],r=e[l];e[l]=e[s],e[s]=r}}}this.nCachedObjects_=i},uncache:function(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,r=n.length;let i=this.nCachedObjects_,s=t.length;for(let o=0,a=arguments.length;o!==a;++o){const a=arguments[o].uuid,l=e[a];if(void 0!==l)if(delete e[a],l<i){const o=--i,a=t[o],c=--s,u=t[c];e[a.uuid]=l,t[l]=a,e[u.uuid]=o,t[o]=u,t.pop();for(let t=0,e=r;t!==e;++t){const e=n[t],r=e[c];e[l]=e[o],e[o]=r,e.pop()}}else{const i=--s,o=t[i];i>0&&(e[o.uuid]=l),t[l]=o,t.pop();for(let t=0,e=r;t!==e;++t){const e=n[t];e[l]=e[i],e.pop()}}}this.nCachedObjects_=i},subscribe_:function(t,e){const n=this._bindingsIndicesByPath;let r=n[t];const i=this._bindings;if(void 0!==r)return i[r];const s=this._paths,o=this._parsedPaths,a=this._objects,l=this.nCachedObjects_,c=new Array(a.length);r=i.length,n[t]=r,s.push(t),o.push(e),i.push(c);for(let u=l,h=a.length;u!==h;++u)c[u]=new QN(a[u],t,e);return c},unsubscribe_:function(t){const e=this._bindingsIndicesByPath,n=e[t];if(void 0!==n){const r=this._paths,i=this._parsedPaths,s=this._bindings,o=s.length-1,a=s[o];e[t[o]]=n,s[n]=a,s.pop(),i[n]=i[o],i.pop(),r[n]=r[o],r.pop()}}});class tO{constructor(t,e,n=null,r=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=n,this.blendMode=r;const i=e.tracks,s=i.length,o=new Array(s),a={endingStart:bE,endingEnd:bE};for(let l=0;l!==s;++l){const t=i[l].createInterpolant(null);o[l]=t,t.settings=a}this._interpolantSettings=a,this._interpolants=o,this._propertyBindings=new Array(s),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,n){if(t.fadeOut(e),this.fadeIn(e),n){const n=this._clip.duration,r=t._clip.duration,i=n/r;t.warp(1,r/n,e),this.warp(i,1,e)}return this}crossFadeTo(t,e,n){return t.crossFadeFrom(this,e,n)}stopFading(){const t=this._weightInterpolant;return null!==t&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,n){const r=this._mixer,i=r.time,s=this.timeScale;let o=this._timeScaleInterpolant;null===o&&(o=r._lendControlInterpolant(),this._timeScaleInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=i,a[1]=i+n,l[0]=t/s,l[1]=e/s,this}stopWarping(){const t=this._timeScaleInterpolant;return null!==t&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,n,r){if(!this.enabled)return void this._updateWeight(t);const i=this._startTime;if(null!==i){const r=(t-i)*n;if(r<0||0===n)return;this._startTime=null,e=n*r}e*=this._updateTimeScale(t);const s=this._updateTime(e),o=this._updateWeight(t);if(o>0){const t=this._interpolants,e=this._propertyBindings;switch(this.blendMode){case 2501:for(let n=0,r=t.length;n!==r;++n)t[n].evaluate(s),e[n].accumulateAdditive(o);break;case 2500:default:for(let n=0,i=t.length;n!==i;++n)t[n].evaluate(s),e[n].accumulate(r,o)}}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const n=this._weightInterpolant;if(null!==n){const r=n.evaluate(t)[0];e*=r,t>n.parameterPositions[1]&&(this.stopFading(),0===r&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const n=this._timeScaleInterpolant;null!==n&&(e*=n.evaluate(t)[0],t>n.parameterPositions[1]&&(this.stopWarping(),0===e?this.paused=!0:this.timeScale=e))}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,n=this.loop;let r=this.time+t,i=this._loopCount;const s=2202===n;if(0===t)return-1===i?r:s&&1==(1&i)?e-r:r;if(2200===n){-1===i&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(r>=e)r=e;else{if(!(r<0)){this.time=r;break t}r=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(-1===i&&(t>=0?(i=0,this._setEndings(!0,0===this.repetitions,s)):this._setEndings(0===this.repetitions,!0,s)),r>=e||r<0){const n=Math.floor(r/e);r-=e*n,i+=Math.abs(n);const o=this.repetitions-i;if(o<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=t>0?e:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(1===o){const e=t<0;this._setEndings(e,!e,s)}else this._setEndings(!1,!1,s);this._loopCount=i,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:n})}}else this.time=r;if(s&&1==(1&i))return e-r}return r}_setEndings(t,e,n){const r=this._interpolantSettings;n?(r.endingStart=_E,r.endingEnd=_E):(r.endingStart=t?this.zeroSlopeAtStart?_E:bE:xE,r.endingEnd=e?this.zeroSlopeAtEnd?_E:bE:xE)}_scheduleFading(t,e,n){const r=this._mixer,i=r.time;let s=this._weightInterpolant;null===s&&(s=r._lendControlInterpolant(),this._weightInterpolant=s);const o=s.parameterPositions,a=s.sampleValues;return o[0]=i,a[0]=e,o[1]=i+t,a[1]=n,this}}function eO(t){this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}eO.prototype=Object.assign(Object.create(AE.prototype),{constructor:eO,_bindAction:function(t,e){const n=t._localRoot||this._root,r=t._clip.tracks,i=r.length,s=t._propertyBindings,o=t._interpolants,a=n.uuid,l=this._bindingsByRootAndName;let c=l[a];void 0===c&&(c={},l[a]=c);for(let u=0;u!==i;++u){const t=r[u],i=t.name;let l=c[i];if(void 0!==l)s[u]=l;else{if(l=s[u],void 0!==l){null===l._cacheIndex&&(++l.referenceCount,this._addInactiveBinding(l,a,i));continue}l=new UN(QN.create(n,i,e&&e._propertyBindings[u].binding.parsedPath),t.ValueTypeName,t.getValueSize()),++l.referenceCount,this._addInactiveBinding(l,a,i),s[u]=l}o[u].resultBuffer=l.buffer}},_activateAction:function(t){if(!this._isActiveAction(t)){if(null===t._cacheIndex){const e=(t._localRoot||this._root).uuid,n=t._clip.uuid,r=this._actionsByClip[n];this._bindAction(t,r&&r.knownActions[0]),this._addInactiveAction(t,n,e)}const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==n.useCount++&&(this._lendBinding(n),n.saveOriginalState())}this._lendAction(t)}},_deactivateAction:function(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==--n.useCount&&(n.restoreOriginalState(),this._takeBackBinding(n))}this._takeBackAction(t)}},_initMemoryManager:function(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}},_isActiveAction:function(t){const e=t._cacheIndex;return null!==e&&e<this._nActiveActions},_addInactiveAction:function(t,e,n){const r=this._actions,i=this._actionsByClip;let s=i[e];if(void 0===s)s={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,i[e]=s;else{const e=s.knownActions;t._byClipCacheIndex=e.length,e.push(t)}t._cacheIndex=r.length,r.push(t),s.actionByRoot[n]=t},_removeInactiveAction:function(t){const e=this._actions,n=e[e.length-1],r=t._cacheIndex;n._cacheIndex=r,e[r]=n,e.pop(),t._cacheIndex=null;const i=t._clip.uuid,s=this._actionsByClip,o=s[i],a=o.knownActions,l=a[a.length-1],c=t._byClipCacheIndex;l._byClipCacheIndex=c,a[c]=l,a.pop(),t._byClipCacheIndex=null,delete o.actionByRoot[(t._localRoot||this._root).uuid],0===a.length&&delete s[i],this._removeInactiveBindingsForAction(t)},_removeInactiveBindingsForAction:function(t){const e=t._propertyBindings;for(let n=0,r=e.length;n!==r;++n){const t=e[n];0==--t.referenceCount&&this._removeInactiveBinding(t)}},_lendAction:function(t){const e=this._actions,n=t._cacheIndex,r=this._nActiveActions++,i=e[r];t._cacheIndex=r,e[r]=t,i._cacheIndex=n,e[n]=i},_takeBackAction:function(t){const e=this._actions,n=t._cacheIndex,r=--this._nActiveActions,i=e[r];t._cacheIndex=r,e[r]=t,i._cacheIndex=n,e[n]=i},_addInactiveBinding:function(t,e,n){const r=this._bindingsByRootAndName,i=this._bindings;let s=r[e];void 0===s&&(s={},r[e]=s),s[n]=t,t._cacheIndex=i.length,i.push(t)},_removeInactiveBinding:function(t){const e=this._bindings,n=t.binding,r=n.rootNode.uuid,i=n.path,s=this._bindingsByRootAndName,o=s[r],a=e[e.length-1],l=t._cacheIndex;a._cacheIndex=l,e[l]=a,e.pop(),delete o[i],0===Object.keys(o).length&&delete s[r]},_lendBinding:function(t){const e=this._bindings,n=t._cacheIndex,r=this._nActiveBindings++,i=e[r];t._cacheIndex=r,e[r]=t,i._cacheIndex=n,e[n]=i},_takeBackBinding:function(t){const e=this._bindings,n=t._cacheIndex,r=--this._nActiveBindings,i=e[r];t._cacheIndex=r,e[r]=t,i._cacheIndex=n,e[n]=i},_lendControlInterpolant:function(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let n=t[e];return void 0===n&&(n=new xI(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=e,t[e]=n),n},_takeBackControlInterpolant:function(t){const e=this._controlInterpolants,n=t.__cacheIndex,r=--this._nActiveControlInterpolants,i=e[r];t.__cacheIndex=r,e[r]=t,i.__cacheIndex=n,e[n]=i},_controlInterpolantsResultBuffer:new Float32Array(1),clipAction:function(t,e,n){const r=e||this._root,i=r.uuid;let s="string"==typeof t?II.findByName(r,t):t;const o=null!==s?s.uuid:t,a=this._actionsByClip[o];let l=null;if(void 0===n&&(n=null!==s?s.blendMode:2500),void 0!==a){const t=a.actionByRoot[i];if(void 0!==t&&t.blendMode===n)return t;l=a.knownActions[0],null===s&&(s=l._clip)}if(null===s)return null;const c=new tO(this,s,e,n);return this._bindAction(c,l),this._addInactiveAction(c,o,i),c},existingAction:function(t,e){const n=e||this._root,r=n.uuid,i="string"==typeof t?II.findByName(n,t):t,s=this._actionsByClip[i?i.uuid:t];return void 0!==s&&s.actionByRoot[r]||null},stopAllAction:function(){const t=this._actions;for(let e=this._nActiveActions-1;e>=0;--e)t[e].stop();return this},update:function(t){const e=this._actions,n=this._nActiveActions,r=this.time+=t*=this.timeScale,i=Math.sign(t),s=this._accuIndex^=1;for(let l=0;l!==n;++l)e[l]._update(r,t,i,s);const o=this._bindings,a=this._nActiveBindings;for(let l=0;l!==a;++l)o[l].apply(s);return this},setTime:function(t){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(t)},getRoot:function(){return this._root},uncacheClip:function(t){const e=this._actions,n=t.uuid,r=this._actionsByClip,i=r[n];if(void 0!==i){const t=i.knownActions;for(let n=0,r=t.length;n!==r;++n){const r=t[n];this._deactivateAction(r);const i=r._cacheIndex,s=e[e.length-1];r._cacheIndex=null,r._byClipCacheIndex=null,s._cacheIndex=i,e[i]=s,e.pop(),this._removeInactiveBindingsForAction(r)}delete r[n]}},uncacheRoot:function(t){const e=t.uuid,n=this._actionsByClip;for(const i in n){const t=n[i].actionByRoot[e];void 0!==t&&(this._deactivateAction(t),this._removeInactiveAction(t))}const r=this._bindingsByRootAndName[e];if(void 0!==r)for(const i in r){const t=r[i];t.restoreOriginalState(),this._removeInactiveBinding(t)}},uncacheAction:function(t,e){const n=this.existingAction(t,e);null!==n&&(this._deactivateAction(n),this._removeInactiveAction(n))}});class nO{constructor(t){"string"==typeof t&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),t=arguments[1]),this.value=t}clone(){return new nO(void 0===this.value.clone?this.value:this.value.clone())}}function rO(t,e,n){Ck.call(this,t,e),this.meshPerAttribute=n||1}function iO(t,e,n,r,i){this.buffer=t,this.type=e,this.itemSize=n,this.elementSize=r,this.count=i,this.version=0}function sO(t,e,n,r){this.ray=new fC(t,e),this.near=n||0,this.far=r||1/0,this.camera=null,this.layers=new TC,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}},Object.defineProperties(this.params,{PointCloud:{get:function(){return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),this.Points}}})}function oO(t,e){return t.distance-e.distance}function aO(t,e,n,r){if(t.layers.test(e.layers)&&t.raycast(e,n),!0===r){const r=t.children;for(let t=0,i=r.length;t<i;t++)aO(r[t],e,n,!0)}}rO.prototype=Object.assign(Object.create(Ck.prototype),{constructor:rO,isInstancedInterleavedBuffer:!0,copy:function(t){return Ck.prototype.copy.call(this,t),this.meshPerAttribute=t.meshPerAttribute,this},clone:function(t){const e=Ck.prototype.clone.call(this,t);return e.meshPerAttribute=this.meshPerAttribute,e},toJSON:function(t){const e=Ck.prototype.toJSON.call(this,t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}),Object.defineProperty(iO.prototype,"needsUpdate",{set:function(t){!0===t&&this.version++}}),Object.assign(iO.prototype,{isGLBufferAttribute:!0,setBuffer:function(t){return this.buffer=t,this},setType:function(t,e){return this.type=t,this.elementSize=e,this},setItemSize:function(t){return this.itemSize=t,this},setCount:function(t){return this.count=t,this}}),Object.assign(sO.prototype,{set:function(t,e){this.ray.set(t,e)},setFromCamera:function(t,e){e&&e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e&&e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)},intersectObject:function(t,e,n){const r=n||[];return aO(t,this,r,e),r.sort(oO),r},intersectObjects:function(t,e,n){const r=n||[];if(!1===Array.isArray(t))return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),r;for(let i=0,s=t.length;i<s;i++)aO(t[i],this,r,e);return r.sort(oO),r}});const lO=new IE;function cO(t){zC.call(this),this.material=t,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}(cO.prototype=Object.create(zC.prototype)).constructor=cO,cO.prototype.isImmediateRenderObject=!0;const uO=new VE,hO=new mC,dO=new mC;function pO(t){const e=[];t&&t.isBone&&e.push(t);for(let n=0;n<t.children.length;n++)e.push.apply(e,pO(t.children[n]));return e}const fO=new Float32Array(1),mO=(new Int32Array(fO.buffer),Math.pow(2,8),new dT({side:1,depthWrite:!1,depthTest:!1}));function gO(t){console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),JI.call(this,t),this.type="catmullrom"}new tA(new nA,mO),Math.sqrt(5),WI.create=function(t,e){return console.log("THREE.Curve.create() has been deprecated"),t.prototype=Object.create(WI.prototype),t.prototype.constructor=t,t.prototype.getPoint=e,t},Object.assign(hN.prototype,{fromPoints:function(t){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(t)}}),Object.create(JI.prototype),Object.create(JI.prototype),gO.prototype=Object.create(JI.prototype),Object.assign(gO.prototype,{initFromArray:function(){console.error("THREE.Spline: .initFromArray() has been removed.")},getControlPointsArray:function(){console.error("THREE.Spline: .getControlPointsArray() has been removed.")},reparametrizeByArcLength:function(){console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")}}),class extends yR{constructor(t=10,e=10,n=4473924,r=8947848){n=new lT(n),r=new lT(r);const i=e/2,s=t/e,o=t/2,a=[],l=[];for(let u=0,h=0,d=-o;u<=e;u++,d+=s){a.push(-o,0,d,o,0,d),a.push(d,0,-o,d,0,o);const t=u===i?n:r;t.toArray(l,h),h+=3,t.toArray(l,h),h+=3,t.toArray(l,h),h+=3,t.toArray(l,h),h+=3}const c=new FT;c.setAttribute("position",new ET(a,3)),c.setAttribute("color",new ET(l,3)),super(c,new lR({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}}.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},class extends yR{constructor(t){const e=pO(t),n=new FT,r=[],i=[],s=new lT(0,0,1),o=new lT(0,1,0);for(let a=0;a<e.length;a++){const t=e[a];t.parent&&t.parent.isBone&&(r.push(0,0,0),r.push(0,0,0),i.push(s.r,s.g,s.b),i.push(o.r,o.g,o.b))}n.setAttribute("position",new ET(r,3)),n.setAttribute("color",new ET(i,3)),super(n,new lR({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,n=this.geometry,r=n.getAttribute("position");dO.copy(this.root.matrixWorld).invert();for(let i=0,s=0;i<e.length;i++){const t=e[i];t.parent&&t.parent.isBone&&(hO.multiplyMatrices(dO,t.matrixWorld),uO.setFromMatrixPosition(hO),r.setXYZ(s,uO.x,uO.y,uO.z),hO.multiplyMatrices(dO,t.parent.matrixWorld),uO.setFromMatrixPosition(hO),r.setXYZ(s+1,uO.x,uO.y,uO.z),s+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},Object.assign(LI.prototype,{extractUrlBase:function(t){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),function(t){const e=t.lastIndexOf("/");return-1===e?"./":t.substr(0,e+1)}(t)}}),LI.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},Object.assign(class{constructor(t,e){Object.defineProperty(this,"isBox2",{value:!0}),this.min=void 0!==t?t:new IE(1/0,1/0),this.max=void 0!==e?e:new IE(-1/0,-1/0)}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=lO.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return void 0===t&&(console.warn("THREE.Box2: .getCenter() target is now required"),t=new IE),this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return void 0===t&&(console.warn("THREE.Box2: .getSize() target is now required"),t=new IE),this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,e){return void 0===e&&(console.warn("THREE.Box2: .getParameter() target is now required"),e=new IE),e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y)}clampPoint(t,e){return void 0===e&&(console.warn("THREE.Box2: .clampPoint() target is now required"),e=new IE),e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return lO.copy(t).clamp(this.min,this.max).sub(t).length()}intersect(t){return this.min.max(t.min),this.max.min(t.max),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}.prototype,{center:function(t){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(t)},empty:function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(t){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},size:function(t){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(t)}}),Object.assign(WE.prototype,{center:function(t){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(t)},empty:function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(t){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},isIntersectionSphere:function(t){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)},size:function(t){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(t)}}),Object.assign(oC.prototype,{empty:function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()}}),gA.prototype.setFromMatrix=function(t){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(t)},Object.assign(RE,{random16:function(){return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),Math.random()},nearestPowerOfTwo:function(t){return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),RE.floorPowerOfTwo(t)},nextPowerOfTwo:function(t){return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),RE.ceilPowerOfTwo(t)}}),Object.assign(NE.prototype,{flattenToArrayOffset:function(t,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},multiplyVector3:function(t){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),t.applyMatrix3(this)},multiplyVector3Array:function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},applyToBufferAttribute:function(t){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),t.applyMatrix3(this)},applyToVector3Array:function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},getInverse:function(t){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(t).invert()}}),Object.assign(mC.prototype,{extractPosition:function(t){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(t)},flattenToArrayOffset:function(t,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},getPosition:function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),(new VE).setFromMatrixColumn(this,3)},setRotationFromQuaternion:function(t){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(t)},multiplyToArray:function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},multiplyVector3:function(t){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},multiplyVector4:function(t){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},multiplyVector3Array:function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},rotateAxis:function(t){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),t.transformDirection(this)},crossVector:function(t){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},translate:function(){console.error("THREE.Matrix4: .translate() has been removed.")},rotateX:function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},rotateY:function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},rotateZ:function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},rotateByAxis:function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},applyToBufferAttribute:function(t){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},applyToVector3Array:function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},makeFrustum:function(t,e,n,r,i,s){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(t,e,r,n,i,s)},getInverse:function(t){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(t).invert()}}),WC.prototype.isIntersectionLine=function(t){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(t)},Object.assign(zE.prototype,{multiplyVector3:function(t){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),t.applyQuaternion(this)},inverse:function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()}}),Object.assign(fC.prototype,{isIntersectionBox:function(t){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},isIntersectionPlane:function(t){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(t)},isIntersectionSphere:function(t){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)}}),Object.assign(eT.prototype,{area:function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},barycoordFromPoint:function(t,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(t,e)},midpoint:function(t){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(t)},normal:function(t){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(t)},plane:function(t){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(t)}}),Object.assign(eT,{barycoordFromPoint:function(t,e,n,r,i){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),eT.getBarycoord(t,e,n,r,i)},normal:function(t,e,n,r){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),eT.getNormal(t,e,n,r)}}),Object.assign(dN.prototype,{extractAllPoints:function(t){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(t)},extrude:function(t){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new rI(this,t)},makeGeometry:function(t){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new oI(this,t)}}),Object.assign(IE.prototype,{fromAttribute:function(t,e,n){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},distanceToManhattan:function(t){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},lengthManhattan:function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(VE.prototype,{setEulerFromRotationMatrix:function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},setEulerFromQuaternion:function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},getPositionFromMatrix:function(t){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(t)},getScaleFromMatrix:function(t){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(t)},getColumnFromMatrix:function(t,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,t)},applyProjection:function(t){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(t)},fromAttribute:function(t,e,n){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},distanceToManhattan:function(t){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},lengthManhattan:function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign($E.prototype,{fromAttribute:function(t,e,n){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},lengthManhattan:function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(zC.prototype,{getChildByName:function(t){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(t)},renderDepth:function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},translate:function(t,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,t)},getWorldRotation:function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},applyMatrix:function(t){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)}}),Object.defineProperties(zC.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(t){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=t}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),Object.assign(tA.prototype,{setDrawMode:function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}),Object.defineProperties(tA.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),0},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),Object.defineProperties(Gk.prototype,{objects:{get:function(){return console.warn("THREE.LOD: .objects has been renamed to .levels."),this.levels}}}),Object.defineProperty(nR.prototype,"useVertexTexture",{get:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")},set:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")}}),Jk.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},Object.defineProperty(WI.prototype,"__arcLengthDivisions",{get:function(){return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions},set:function(t){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions=t}}),lA.prototype.setLens=function(t,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),void 0!==e&&(this.filmGauge=e),this.setFocalLength(t)},Object.defineProperties(pN.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(t){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=t}},shadowCameraLeft:{set:function(t){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=t}},shadowCameraRight:{set:function(t){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=t}},shadowCameraTop:{set:function(t){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=t}},shadowCameraBottom:{set:function(t){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=t}},shadowCameraNear:{set:function(t){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=t}},shadowCameraFar:{set:function(t){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=t}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(t){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=t}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(t){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=t}},shadowMapHeight:{set:function(t){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=t}}}),Object.defineProperties(mT.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===CE},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(CE)}}}),Object.assign(mT.prototype,{setDynamic:function(t){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===t?CE:EE),this},copyIndicesArray:function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},setArray:function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}}),Object.assign(FT.prototype,{addIndex:function(t){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(t)},addAttribute:function(t,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),e&&e.isBufferAttribute||e&&e.isInterleavedBufferAttribute?"index"===t?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(t,e):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(t,new mT(arguments[1],arguments[2])))},addDrawCall:function(t,e,n){void 0!==n&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(t,e)},clearDrawCalls:function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},computeOffsets:function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},removeAttribute:function(t){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(t)},applyMatrix:function(t){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)}}),Object.defineProperties(FT.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),Object.defineProperties(MN.prototype,{maxInstancedCount:{get:function(){return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount},set:function(t){console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount=t}}}),Object.defineProperties(sO.prototype,{linePrecision:{get:function(){return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold},set:function(t){console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold=t}}}),Object.defineProperties(Ck.prototype,{dynamic:{get:function(){return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.usage===CE},set:function(t){console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.setUsage(t)}}}),Object.assign(Ck.prototype,{setDynamic:function(t){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===t?CE:EE),this},setArray:function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}}),Object.assign(rI.prototype,{getArrays:function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},addShapeList:function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},addShape:function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")}}),Object.assign(class extends zC{constructor(){super(),Object.defineProperty(this,"isScene",{value:!0}),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),null!==t.background&&(this.background=t.background.clone()),null!==t.environment&&(this.environment=t.environment.clone()),null!==t.fog&&(this.fog=t.fog.clone()),null!==t.overrideMaterial&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return null!==this.background&&(e.object.background=this.background.toJSON(t)),null!==this.environment&&(e.object.environment=this.environment.toJSON(t)),null!==this.fog&&(e.object.fog=this.fog.toJSON()),e}}.prototype,{dispose:function(){console.error("THREE.Scene: .dispose() has been removed.")}}),Object.defineProperties(nO.prototype,{dynamic:{set:function(){console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")}},onUpdate:{value:function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this}}}),Object.defineProperties(hT.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new lT}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(t){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===t}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(t){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=t}}}),Object.defineProperties(hI.prototype,{metal:{get:function(){return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),!1},set:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")}}}),Object.defineProperties(uI.prototype,{transparency:{get:function(){return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission},set:function(t){console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission=t}}}),Object.defineProperties(oA.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(t){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=t}}}),Object.assign(Sk.prototype,{clearTarget:function(t,e,n,r){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(t),this.clear(e,n,r)},animate:function(t){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(t)},getCurrentRenderTarget:function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},getMaxAnisotropy:function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},getPrecision:function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},resetGLState:function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},supportsFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},supportsHalfFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},supportsStandardDerivatives:function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},supportsCompressedTextureS3TC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},supportsCompressedTexturePVRTC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},supportsBlendMinMax:function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},supportsVertexTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},supportsInstancedArrays:function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},enableScissorTest:function(t){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(t)},initMaterial:function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},addPrePlugin:function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},addPostPlugin:function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},updateShadowMap:function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},setFaceCulling:function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},allocTextureUnit:function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},setTexture:function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},setTexture2D:function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},setTextureCube:function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},getActiveMipMapLevel:function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()}}),Object.defineProperties(Sk.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=t}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=t}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(t){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=!0===t?3001:wE}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}}),Object.defineProperties(fk.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(BE.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=t}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=t}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=t}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=t}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(t){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=t}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(t){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=t}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(t){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=t}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(t){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=t}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(t){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=t}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(t){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=t}}}),Object.defineProperties(class extends zC{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(!0===this.isPlaying)return void console.warn("THREE.Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(!1!==this.hasPlaybackControl)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),!0===this._connected?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(!1!==this.hasPlaybackControl)return this.playbackRate=t,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(!1!==this.hasPlaybackControl)return this.loop=t,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}.prototype,{load:{value:function(t){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const e=this;return(new PN).load(t,function(t){e.setBuffer(t)}),this}},startTime:{set:function(){console.warn("THREE.Audio: .startTime is now .play( delay ).")}}}),uA.prototype.updateCubeMap=function(t,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(t,e)},uA.prototype.clear=function(t,e,n,r){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(t,e,n,r)},DE.crossOrigin=void 0,DE.loadTexture=function(t,e,n,r){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const i=new HI;i.setCrossOrigin(this.crossOrigin);const s=i.load(t,n,void 0,r);return e&&(s.mapping=e),s},DE.loadTextureCube=function(t,e,n,r){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const i=new VI;i.setCrossOrigin(this.crossOrigin);const s=i.load(t,n,void 0,r);return e&&(s.mapping=e),s},DE.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},DE.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:"125"}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__="125");let yO=(()=>{class t{shoulders(t){const e=t[YS.POSE_LANDMARKS.LEFT_SHOULDER],n=t[YS.POSE_LANDMARKS.RIGHT_SHOULDER];return{center:new IE((e.x+n.x)/2,(e.y+n.y)/2),width:Math.abs(e.x-n.x)}}drawShoulders(t,e){const n=_O.textFontSize("\ud8fa\udce1",t.width,e);_O.drawSWText("\ud8fa\udce1",t.center,n,e)}drawArm(t,e,n,r){e.visibility<.8||(r.strokeStyle="black",r.beginPath(),r.moveTo(t.x*r.canvas.width,t.y*r.canvas.height),r.lineTo(e.x*r.canvas.width,e.y*r.canvas.height),n.visibility>.8&&r.lineTo(n.x*r.canvas.width,n.y*r.canvas.height),r.stroke())}drawArms(t,e){e.lineWidth=t.shoulders.width*e.canvas.width/50;const n=[{x:t.shoulders.center.x+.45*t.shoulders.width,y:t.shoulders.center.y},{x:t.shoulders.center.x-.45*t.shoulders.width,y:t.shoulders.center.y}];this.drawArm(n[0],t.elbows[0],t.wrists[0],e),this.drawArm(n[1],t.elbows[1],t.wrists[1],e)}draw(t,e){t&&(this.drawShoulders(t.shoulders,e),this.drawArms(t,e))}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})(),vO=(()=>{class t{center(t){const e=t[4];return new IE(e.x,e.y)}drawFace(t,e,n){const r=_O.textFontSize(e.shape,.6*t,n);_O.drawSWText(e.shape,e.center,r,n)}draw(t,e){t.face&&this.drawFace(t.body.shoulders.width,t.face,e)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})(),bO=(()=>{class t{bbox(t){return(new WE).setFromPoints(t)}normal(t,e=!1){const n=[t[0],t[5],t[17]];return{center:new VE((n[0].x+n[1].x+n[2].x)/3,(n[0].y+n[1].y+n[2].y)/3,(n[0].z+n[1].z+n[2].z)/3),direction:(new WC).setFromCoplanarPoints(n[0],n[1],n[2]).normal.multiplyScalar(e?-1:1)}}plane(t){const e=t[0],n=t[13];return 1.5*Math.abs(n.y-e.y)>Math.abs(n.z-e.z)?"wall":"floor"}angle(t,e){return(180*Math.atan2(t,e)/Math.PI+360)%360}rotation(t){const e=t[0],n=t[13];let r=this.angle(n.y-e.y,n.x-e.x)+94;return r+=22.5,r=(r+360)%360,Math.floor(r/45)}direction(t,e,n){const r=n?e.direction.x:-e.direction.x;switch(t){case"wall":const t=this.angle(e.direction.z,r);return t>210?"me":t>150?"middle":"you";case"floor":const n=this.angle(e.direction.y,r);return n>0?"me":n>-60?"middle":"you"}}drawBbox(t,e){const n=new VE(e.canvas.width,e.canvas.height,0),r=(new VE).multiplyVectors(t.min,n),i=(new VE).multiplyVectors(t.max,n);e.strokeStyle="#0000FF",e.beginPath(),e.moveTo(r.x,r.y),e.lineTo(r.x,i.y),e.lineTo(i.x,i.y),e.lineTo(i.x,r.y),e.lineTo(r.x,r.y),e.stroke()}drawNormal(t,e){const n=new VE(e.canvas.width,e.canvas.height,e.canvas.width),r=(new VE).multiplyVectors(n,t.direction).normalize().multiplyScalar(100),i=(new VE).multiplyVectors(n,t.center);e.strokeStyle="#FFFF00",e.lineWidth=10,e.beginPath(),e.moveTo(i.x,i.y),e.lineTo(i.x+r.x,i.y+r.y),e.stroke()}drawShape(t,e,n,r){let i=e.shape.codePointAt(0);n||(i+=8),"floor"===e.plane&&(i+=48),i+=n?(8-e.rotation)%8:e.rotation,i+={you:0,middle:16,me:32}[e.direction];const s=String.fromCodePoint(i),o=new IE((e.bbox.min.x+e.bbox.max.x)/2,(e.bbox.min.y+e.bbox.max.y)/2),a=_O.textFontSize("\ud8c8\uddc1",t/3,r);_O.drawSWText(s,o,a,r)}drawHand(t,e,n,r){this.drawShape(t,e,n,r)}draw(t,e){t.leftHand&&this.drawHand(t.body.shoulders.width,t.leftHand,!0,e),t.rightHand&&this.drawHand(t.body.shoulders.width,t.rightHand,!1,e)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})(),_O=(()=>{class t{constructor(t,e,n){this.bodyService=t,this.faceService=e,this.handsService=n}static textFontSize(t,e,n){n.font="100px SignWriting";const r=n.measureText(t);return e*n.canvas.width/r.width*100}static drawSWText(t,e,n,r){r.font=n+"px SignWriting",r.textAlign="center",r.textBaseline="middle",r.fillStyle="black",r.fillText(t,e.x*r.canvas.width,e.y*r.canvas.height)}draw(t,e){this.bodyService.draw(t.body,e),this.faceService.draw(t,e),this.handsService.draw(t,e)}}return t.\u0275fac=function(e){return new(e||t)(zr(yO),zr(vO),zr(bO))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const xO={tooltipState:Wf("state",[Xf("initial, void, hidden",qf({opacity:0,transform:"scale(0)"})),Xf("visible",qf({transform:"scale(1)"})),Yf("* => visible",jf("200ms cubic-bezier(0, 0, 0.2, 1)",Kf([qf({opacity:0,transform:"scale(0)",offset:0}),qf({opacity:.5,transform:"scale(0.99)",offset:.5}),qf({opacity:1,transform:"scale(1)",offset:1})]))),Yf("* => hidden",jf("100ms cubic-bezier(0, 0, 0.2, 1)",qf({opacity:0})))])},wO=qp({passive:!0});function SO(t){return Error(`Tooltip position "${t}" is invalid.`)}const EO=new Er("mat-tooltip-scroll-strategy"),CO={provide:EO,deps:[c_],useFactory:function(t){return()=>t.scrollStrategies.reposition({scrollThrottle:20})}},TO=new Er("mat-tooltip-default-options",{providedIn:"root",factory:function(){return{showDelay:0,hideDelay:0,touchendHideDelay:1500}}});let AO=(()=>{class t{constructor(t,e,n,r,i,s,o,a,l,c,u){this._overlay=t,this._elementRef=e,this._scrollDispatcher=n,this._viewContainerRef=r,this._ngZone=i,this._platform=s,this._ariaDescriber=o,this._focusMonitor=a,this._dir=c,this._defaultOptions=u,this._position="below",this._disabled=!1,this._viewInitialized=!1,this._pointerExitEventsInitialized=!1,this.showDelay=this._defaultOptions.showDelay,this.hideDelay=this._defaultOptions.hideDelay,this.touchGestures="auto",this._message="",this._passiveListeners=[],this._destroyed=new J,this._handleKeydown=t=>{this._isTooltipVisible()&&27===t.keyCode&&!Yp(t)&&(t.preventDefault(),t.stopPropagation(),this._ngZone.run(()=>this.hide(0)))},this._scrollStrategy=l,u&&(u.position&&(this.position=u.position),u.touchGestures&&(this.touchGestures=u.touchGestures)),i.runOutsideAngular(()=>{e.nativeElement.addEventListener("keydown",this._handleKeydown)})}get position(){return this._position}set position(t){t!==this._position&&(this._position=t,this._overlayRef&&(this._updatePosition(),this._tooltipInstance&&this._tooltipInstance.show(0),this._overlayRef.updatePosition()))}get disabled(){return this._disabled}set disabled(t){this._disabled=nf(t),this._disabled?this.hide(0):this._setupPointerEnterEventsIfNeeded()}get message(){return this._message}set message(t){this._ariaDescriber.removeDescription(this._elementRef.nativeElement,this._message),this._message=null!=t?`${t}`.trim():"",!this._message&&this._isTooltipVisible()?this.hide(0):(this._setupPointerEnterEventsIfNeeded(),this._updateTooltipMessage(),this._ngZone.runOutsideAngular(()=>{Promise.resolve().then(()=>{this._ariaDescriber.describe(this._elementRef.nativeElement,this.message)})}))}get tooltipClass(){return this._tooltipClass}set tooltipClass(t){this._tooltipClass=t,this._tooltipInstance&&this._setTooltipClass(this._tooltipClass)}ngAfterViewInit(){this._viewInitialized=!0,this._setupPointerEnterEventsIfNeeded(),this._focusMonitor.monitor(this._elementRef).pipe(Dd(this._destroyed)).subscribe(t=>{t?"keyboard"===t&&this._ngZone.run(()=>this.show()):this._ngZone.run(()=>this.hide(0))})}ngOnDestroy(){const t=this._elementRef.nativeElement;clearTimeout(this._touchstartTimeout),this._overlayRef&&(this._overlayRef.dispose(),this._tooltipInstance=null),t.removeEventListener("keydown",this._handleKeydown),this._passiveListeners.forEach(([e,n])=>{t.removeEventListener(e,n,wO)}),this._passiveListeners.length=0,this._destroyed.next(),this._destroyed.complete(),this._ariaDescriber.removeDescription(t,this.message),this._focusMonitor.stopMonitoring(t)}show(t=this.showDelay){if(this.disabled||!this.message||this._isTooltipVisible()&&!this._tooltipInstance._showTimeoutId&&!this._tooltipInstance._hideTimeoutId)return;const e=this._createOverlay();this._detach(),this._portal=this._portal||new Tb(MO,this._viewContainerRef),this._tooltipInstance=e.attach(this._portal).instance,this._tooltipInstance.afterHidden().pipe(Dd(this._destroyed)).subscribe(()=>this._detach()),this._setTooltipClass(this._tooltipClass),this._updateTooltipMessage(),this._tooltipInstance.show(t)}hide(t=this.hideDelay){this._tooltipInstance&&this._tooltipInstance.hide(t)}toggle(){this._isTooltipVisible()?this.hide():this.show()}_isTooltipVisible(){return!!this._tooltipInstance&&this._tooltipInstance.isVisible()}_createOverlay(){if(this._overlayRef)return this._overlayRef;const t=this._scrollDispatcher.getAncestorScrollContainers(this._elementRef),e=this._overlay.position().flexibleConnectedTo(this._elementRef).withTransformOriginOn(".mat-tooltip").withFlexibleDimensions(!1).withViewportMargin(8).withScrollableContainers(t);return e.positionChanges.pipe(Dd(this._destroyed)).subscribe(t=>{this._tooltipInstance&&t.scrollableViewProperties.isOverlayClipped&&this._tooltipInstance.isVisible()&&this._ngZone.run(()=>this.hide(0))}),this._overlayRef=this._overlay.create({direction:this._dir,positionStrategy:e,panelClass:"mat-tooltip-panel",scrollStrategy:this._scrollStrategy()}),this._updatePosition(),this._overlayRef.detachments().pipe(Dd(this._destroyed)).subscribe(()=>this._detach()),this._overlayRef}_detach(){this._overlayRef&&this._overlayRef.hasAttached()&&this._overlayRef.detach(),this._tooltipInstance=null}_updatePosition(){const t=this._overlayRef.getConfig().positionStrategy,e=this._getOrigin(),n=this._getOverlayPosition();t.withPositions([Object.assign(Object.assign({},e.main),n.main),Object.assign(Object.assign({},e.fallback),n.fallback)])}_getOrigin(){const t=!this._dir||"ltr"==this._dir.value,e=this.position;let n;if("above"==e||"below"==e)n={originX:"center",originY:"above"==e?"top":"bottom"};else if("before"==e||"left"==e&&t||"right"==e&&!t)n={originX:"start",originY:"center"};else{if(!("after"==e||"right"==e&&t||"left"==e&&!t))throw SO(e);n={originX:"end",originY:"center"}}const{x:r,y:i}=this._invertPosition(n.originX,n.originY);return{main:n,fallback:{originX:r,originY:i}}}_getOverlayPosition(){const t=!this._dir||"ltr"==this._dir.value,e=this.position;let n;if("above"==e)n={overlayX:"center",overlayY:"bottom"};else if("below"==e)n={overlayX:"center",overlayY:"top"};else if("before"==e||"left"==e&&t||"right"==e&&!t)n={overlayX:"end",overlayY:"center"};else{if(!("after"==e||"right"==e&&t||"left"==e&&!t))throw SO(e);n={overlayX:"start",overlayY:"center"}}const{x:r,y:i}=this._invertPosition(n.overlayX,n.overlayY);return{main:n,fallback:{overlayX:r,overlayY:i}}}_updateTooltipMessage(){this._tooltipInstance&&(this._tooltipInstance.message=this.message,this._tooltipInstance._markForCheck(),this._ngZone.onMicrotaskEmpty.asObservable().pipe(wd(1),Dd(this._destroyed)).subscribe(()=>{this._tooltipInstance&&this._overlayRef.updatePosition()}))}_setTooltipClass(t){this._tooltipInstance&&(this._tooltipInstance.tooltipClass=t,this._tooltipInstance._markForCheck())}_invertPosition(t,e){return"above"===this.position||"below"===this.position?"top"===e?e="bottom":"bottom"===e&&(e="top"):"end"===t?t="start":"start"===t&&(t="end"),{x:t,y:e}}_setupPointerEnterEventsIfNeeded(){!this._disabled&&this.message&&this._viewInitialized&&!this._passiveListeners.length&&(this._platformSupportsMouseEvents()?this._passiveListeners.push(["mouseenter",()=>{this._setupPointerExitEventsIfNeeded(),this.show()}]):"off"!==this.touchGestures&&(this._disableNativeGesturesIfNecessary(),this._passiveListeners.push(["touchstart",()=>{this._setupPointerExitEventsIfNeeded(),clearTimeout(this._touchstartTimeout),this._touchstartTimeout=setTimeout(()=>this.show(),500)}])),this._addListeners(this._passiveListeners))}_setupPointerExitEventsIfNeeded(){if(this._pointerExitEventsInitialized)return;this._pointerExitEventsInitialized=!0;const t=[];if(this._platformSupportsMouseEvents())t.push(["mouseleave",()=>this.hide()]);else if("off"!==this.touchGestures){this._disableNativeGesturesIfNecessary();const e=()=>{clearTimeout(this._touchstartTimeout),this.hide(this._defaultOptions.touchendHideDelay)};t.push(["touchend",e],["touchcancel",e])}this._addListeners(t),this._passiveListeners.push(...t)}_addListeners(t){t.forEach(([t,e])=>{this._elementRef.nativeElement.addEventListener(t,e,wO)})}_platformSupportsMouseEvents(){return!this._platform.IOS&&!this._platform.ANDROID}_disableNativeGesturesIfNecessary(){const t=this.touchGestures;if("off"!==t){const e=this._elementRef.nativeElement,n=e.style;("on"===t||"INPUT"!==e.nodeName&&"TEXTAREA"!==e.nodeName)&&(n.userSelect=n.msUserSelect=n.webkitUserSelect=n.MozUserSelect="none"),"on"!==t&&e.draggable||(n.webkitUserDrag="none"),n.touchAction="none",n.webkitTapHighlightColor="transparent"}}}return t.\u0275fac=function(e){return new(e||t)(ta(c_),ta(dl),ta(bb),ta(Yl),ta(eu),ta(jp),ta(gf),ta(kf),ta(EO),ta(Pf,8),ta(TO,8))},t.\u0275dir=xe({type:t,selectors:[["","matTooltip",""]],hostAttrs:[1,"mat-tooltip-trigger"],inputs:{showDelay:["matTooltipShowDelay","showDelay"],hideDelay:["matTooltipHideDelay","hideDelay"],touchGestures:["matTooltipTouchGestures","touchGestures"],position:["matTooltipPosition","position"],disabled:["matTooltipDisabled","disabled"],message:["matTooltip","message"],tooltipClass:["matTooltipClass","tooltipClass"]},exportAs:["matTooltip"]}),t})(),MO=(()=>{class t{constructor(t,e){this._changeDetectorRef=t,this._breakpointObserver=e,this._visibility="initial",this._closeOnInteraction=!1,this._onHide=new J,this._isHandset=this._breakpointObserver.observe("(max-width: 599.99px) and (orientation: portrait), (max-width: 959.99px) and (orientation: landscape)")}show(t){this._hideTimeoutId&&(clearTimeout(this._hideTimeoutId),this._hideTimeoutId=null),this._closeOnInteraction=!0,this._showTimeoutId=setTimeout(()=>{this._visibility="visible",this._showTimeoutId=null,this._markForCheck()},t)}hide(t){this._showTimeoutId&&(clearTimeout(this._showTimeoutId),this._showTimeoutId=null),this._hideTimeoutId=setTimeout(()=>{this._visibility="hidden",this._hideTimeoutId=null,this._markForCheck()},t)}afterHidden(){return this._onHide.asObservable()}isVisible(){return"visible"===this._visibility}ngOnDestroy(){this._onHide.complete()}_animationStart(){this._closeOnInteraction=!1}_animationDone(t){const e=t.toState;"hidden"!==e||this.isVisible()||this._onHide.next(),"visible"!==e&&"hidden"!==e||(this._closeOnInteraction=!0)}_handleBodyInteraction(){this._closeOnInteraction&&this.hide(0)}_markForCheck(){this._changeDetectorRef.markForCheck()}}return t.\u0275fac=function(e){return new(e||t)(ta($l),ta(B_))},t.\u0275cmp=me({type:t,selectors:[["mat-tooltip-component"]],hostAttrs:["aria-hidden","true"],hostVars:2,hostBindings:function(t,e){1&t&&da("click",function(){return e._handleBodyInteraction()},!1,Pi),2&t&&Ma("zoom","visible"===e._visibility?1:null)},decls:3,vars:7,consts:[[1,"mat-tooltip",3,"ngClass"]],template:function(t,e){if(1&t&&(ra(0,"div",0),da("@state.start",function(){return e._animationStart()})("@state.done",function(t){return e._animationDone(t)}),hc(1,"async"),za(2),ia()),2&t){let t=null;ka("mat-tooltip-handset",null==(t=dc(1,5,e._isHandset))?null:t.matches),ea("ngClass",e.tooltipClass)("@state",e._visibility),Ts(2),Va(e.message)}},directives:[Xu],pipes:[lh],styles:[".mat-tooltip-panel{pointer-events:none !important}.mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis}.cdk-high-contrast-active .mat-tooltip{outline:solid 1px}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}\n"],encapsulation:2,data:{animation:[xO.tooltipState]},changeDetection:0}),t})(),kO=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},providers:[CO],imports:[[Lf,ch,h_,Ry],Ry,wb]}),t})();function RO(t,e){if(1&t){const t=la();ra(0,"button",5),da("click",function(){return hn(t),ya(3).applySetting("receiveVideo",!1)}),ra(1,"mat-icon"),za(2,"videocam"),ia(),ia()}if(2&t){const t=ya(2).$implicit;ea("matTooltipPosition","above")("matTooltip",t("receiveVideo.on")),Jo("aria-label",t("receiveVideo.on"))}}function IO(t,e){if(1&t){const t=la();ra(0,"button",6),da("click",function(){return hn(t),ya(3).applySetting("receiveVideo",!0)}),ra(1,"mat-icon"),za(2,"videocam_off"),ia(),ia()}if(2&t){const t=ya(2).$implicit;ea("matTooltipPosition","above")("matTooltip",t("receiveVideo.off")),Jo("aria-label",t("receiveVideo.off"))}}function NO(t,e){if(1&t&&(oa(0),oa(1,2),Qo(2,RO,3,3,"button",3),Qo(3,IO,3,3,"button",4),aa(),aa()),2&t){const t=e.ngIf;Ts(1),ea("ngSwitch",t.receiveVideo),Ts(1),ea("ngSwitchCase",!0),Ts(1),ea("ngSwitchCase",!1)}}function OO(t,e){if(1&t&&(oa(0),Qo(1,NO,4,3,"ng-container",1),hc(2,"async"),aa()),2&t){const t=ya();Ts(1),ea("ngIf",dc(2,1,t.settingsState$))}}let DO=(()=>{class t extends bw{constructor(t){super(t)}}return t.\u0275fac=function(e){return new(e||t)(ta(Rp))},t.\u0275cmp=me({type:t,selectors:[["app-video-controls"]],features:[Vo],decls:1,vars:1,consts:[[4,"transloco","translocoRead"],[4,"ngIf"],[3,"ngSwitch"],["class","transparent","mat-fab","",3,"matTooltipPosition","matTooltip","click",4,"ngSwitchCase"],["color","warn","mat-fab","",3,"matTooltipPosition","matTooltip","click",4,"ngSwitchCase"],["mat-fab","",1,"transparent",3,"matTooltipPosition","matTooltip","click"],["color","warn","mat-fab","",3,"matTooltipPosition","matTooltip","click"]],template:function(t,e){1&t&&Qo(0,OO,3,3,"ng-container",0),2&t&&ea("translocoRead","video.controls")},directives:[ab,Ju,nh,rh,I_,AO,tw],pipes:[lh],styles:["button[mat-fab][_ngcontent-%COMP%]{position:absolute;right:16px;bottom:0;margin:0 6px}button[mat-fab].transparent[_ngcontent-%COMP%]{box-shadow:inset 0 0 0 1px #fff;background:transparent}"]}),t})();const LO=["video"],FO=["canvas"],PO=["stats"];function $O(t,e){if(1&t&&(ra(0,"p"),za(1),ia()),2&t){const t=ya().$implicit,e=ya(2).ngIf;Ts(1),Va(t("errors."+e.error))}}function BO(t,e){1&t&&(ra(0,"p"),za(1),hc(2,"transloco"),ia()),2&t&&(Ts(1),Va(dc(2,1,"pose.loading")))}function zO(t,e){if(1&t&&(oa(0),Qo(1,$O,2,1,"p",0),Qo(2,BO,3,3,"p",0),aa()),2&t){const t=ya().ngIf,e=ya().ngIf;Ts(1),ea("ngIf",e.error),Ts(1),ea("ngIf",!e.error&&!t.isLoaded)}}function VO(t,e){if(1&t&&(oa(0),Qo(1,zO,3,2,"ng-container",1),ra(2,"div",2),sa(3,"video",null,3),sa(5,"canvas",4,5),sa(7,"div",null,6),ia(),sa(9,"app-video-controls"),aa()),2&t){const t=e.ngIf,n=ya().ngIf;Ts(1),ea("translocoRead","video"),Ts(1),ea("hidden",n.error||!t.isLoaded)}}function UO(t,e){if(1&t&&(oa(0),Qo(1,VO,10,2,"ng-container",0),hc(2,"async"),aa()),2&t){const t=ya();Ts(1),ea("ngIf",dc(2,1,t.poseState$))}}let HO=(()=>{class t extends vw{constructor(t,e,n){super(),this.store=t,this.poseService=e,this.signWritingService=n,this.aspectRatio="aspect-16-9",this.fpsStats=new jS.a,this.signingStats=new jS.a}ngAfterViewInit(){this.setCamera(),this.setStats(),this.trackPose(),this.canvasCtx=this.canvasEl.nativeElement.getContext("2d"),this.drawChanges(),this.videoEl.nativeElement.addEventListener("loadeddata",this.appLoop.bind(this))}appLoop(){return Vh(this,void 0,void 0,function*(){this.store.snapshot();const t=this.videoEl.nativeElement,e=new XS(this.videoEl.nativeElement);let n=null;for(;4===t.readyState;)t.currentTime>n&&(n=t.currentTime,yield this.store.dispatch(e).toPromise()),yield GS(0)})}setCamera(){const t=this.videoEl.nativeElement;t.addEventListener("loadedmetadata",e=>t.play()),this.videoState$.pipe(et(t=>t.camera),$d(e=>t.srcObject=e),Dd(this.ngUnsubscribe)).subscribe(),this.videoState$.pipe(et(t=>t.cameraSettings),yd(Boolean),$d(({width:t,height:e})=>{this.canvasEl.nativeElement.width=t,this.canvasEl.nativeElement.height=e}),$d(t=>this.aspectRatio="aspect-"+t.aspectRatio),Dd(this.ngUnsubscribe)).subscribe()}trackPose(){this.poseState$.pipe(et(t=>t.pose),yd(Boolean),$d(t=>{this.fpsStats.end(),this.fpsStats.begin()}),Dd(this.ngUnsubscribe)).subscribe()}drawChanges(){const t=this.canvasCtx,e=t.canvas;_v([this.poseState$,this.signWritingState$,this.settingsState$]).pipe(Vd((t,e)=>t[1].timestamp===e[1].timestamp),$d(([n,r,i])=>{n.pose&&(t.clearRect(0,0,e.width,e.height),i.drawVideo?t.drawImage(n.pose.image,0,0,e.width,e.height):(t.fillStyle="white",t.fillRect(0,0,e.width,e.height)),i.drawPose&&this.poseService.draw(n.pose,t),i.drawSignWriting&&this.signWritingService.draw(r,t))}),Dd(this.ngUnsubscribe)).subscribe()}setStats(){this.fpsStats.showPanel(0),this.fpsStats.domElement.style.position="absolute",this.statsEl.nativeElement.appendChild(this.fpsStats.dom);const t=new jS.a.Panel("Signing","#ff8","#221");this.signingStats.dom.innerHTML="",this.signingStats.addPanel(t),this.signingStats.showPanel(0),this.signingStats.domElement.style.position="absolute",this.signingStats.domElement.style.left="80px",this.statsEl.nativeElement.appendChild(this.signingStats.dom),this.setDetectorListener(t)}setDetectorListener(t){this.signingProbability$.pipe($d(e=>t.update(100*e,100)),Dd(this.ngUnsubscribe)).subscribe(),this.settingsState$.pipe(et(t=>t.detectSign),Vd(),$d(t=>{this.signingStats.domElement.style.display=t?"block":"none"}),Dd(this.ngUnsubscribe)).subscribe()}}return t.\u0275fac=function(e){return new(e||t)(ta(Rp),ta(QS),ta(_O))},t.\u0275cmp=me({type:t,selectors:[["app-video"]],viewQuery:function(t,e){if(1&t&&(Tc(LO,1),Tc(FO,1),Tc(PO,1)),2&t){let t;Cc(t=Mc())&&(e.videoEl=t.first),Cc(t=Mc())&&(e.canvasEl=t.first),Cc(t=Mc())&&(e.statsEl=t.first)}},hostVars:2,hostBindings:function(t,e){2&t&&function(t,e,n,r){const i=un(),s=_n(2);i.firstUpdatePass&&Oa(i,null,s,r);const o=cn();if(n!==Cs&&Zo(o,s,n)){const a=i.data[Dn()];if(Ba(a,r)&&!Na(i,s)){let t=a.classesWithoutHost;null!==t&&(n=Nt(t,n||"")),na(i,a,o,n,r)}else!function(t,e,n,r,i,s,o,a){i===Cs&&(i=xa);let l=0,c=0,u=0<i.length?i[0]:null,h=0<s.length?s[0]:null;for(;null!==u||null!==h;){const o=l<i.length?i[l+1]:void 0,d=c<s.length?s[c+1]:void 0;let p,f=null;u===h?(l+=2,c+=2,o!==d&&(f=h,p=d)):null===h||null!==u&&u<h?(l+=2,f=u):(c+=2,f=h,p=d),null!==f&&Fa(t,e,n,r,f,p,!0,a),u=l<i.length?i[l]:null,h=c<s.length?s[c]:null}}(i,a,o,o[11],o[s+1],o[s+1]=function(t,e,n){if(null==n||""===n)return xa;const r=[],i=ri(n);if(Array.isArray(i))for(let s=0;s<i.length;s++)t(r,i[s],!0);else if("object"==typeof i)for(const s in i)i.hasOwnProperty(s)&&t(r,s,i[s]);else"string"==typeof i&&e(r,i);return r}(t,e,n),0,s)}}(Rr,Ra,e.aspectRatio,!0)},features:[Vo],decls:2,vars:3,consts:[[4,"ngIf"],[4,"transloco","translocoRead"],["id","video-container",3,"hidden"],["video",""],["height","100%","width","100%",1,"flip"],["canvas",""],["stats",""]],template:function(t,e){1&t&&(Qo(0,UO,3,3,"ng-container",0),hc(1,"async")),2&t&&ea("ngIf",dc(1,1,e.videoState$))},directives:[Ju,ab,DO],pipes:[lh,lb],styles:["[_nghost-%COMP%]{background:#202124;display:flex;border-radius:8px;position:relative;color:#fff;text-align:center;align-items:center;overflow:hidden;min-height:216px;height:720px;max-height:45vw}.aspect-4-3[_nghost-%COMP%]{min-width:288px;width:960px;max-width:60vw}.aspect-16-9[_nghost-%COMP%]{min-width:384px;width:1280px;max-width:80vw}.aspect-2-1[_nghost-%COMP%]{min-width:432px;width:1440px;max-width:90vw}p[_ngcontent-%COMP%]{margin:auto;font-size:36px}#video-container[_ngcontent-%COMP%]{height:100%}#video-container[_ngcontent-%COMP%]   video[_ngcontent-%COMP%]{display:none}.flip[_ngcontent-%COMP%]{transform:scaleX(-1)}app-video-controls[_ngcontent-%COMP%]{position:absolute;bottom:16px;left:0;right:0}app-video-help[_ngcontent-%COMP%]{position:absolute;top:16px;right:16px}"]}),zh([Vp(t=>t.settings)],t.prototype,"settingsState$",void 0),zh([Vp(t=>t.video)],t.prototype,"videoState$",void 0),zh([Vp(t=>t.pose)],t.prototype,"poseState$",void 0),zh([Vp(t=>t.signWriting)],t.prototype,"signWritingState$",void 0),zh([Vp(t=>t.detector.signingProbability)],t.prototype,"signingProbability$",void 0),t})();const WO=["canvas"];let jO=(()=>{class t{constructor(t,e,n,r){this.transloco=t,this.dialog=e,this.snackBar=n,this.store=r}ngOnInit(){this.manageLoading(),this.manageAppErrors()}manageLoading(){this.isLoading$.pipe(yd(t=>t||Boolean(this.loaderDialog)),$d(t=>{t?this.loaderDialog=this.dialog.open(rv,{panelClass:"app-loader-dialog"}):(this.loaderDialog.close(),delete this.loaderDialog)})).subscribe()}manageAppErrors(){this.error$.pipe(yd(Boolean),$d(t=>{this.store.dispatch(new av),this.snackBar.open(t,null,{panelClass:"mat-warn",duration:1e4})})).subscribe()}}return t.\u0275fac=function(e){return new(e||t)(ta(Qv),ta(E_),ta(J_),ta(Rp))},t.\u0275cmp=me({type:t,selectors:[["app-root"]],viewQuery:function(t,e){if(1&t&&Tc(WO,1),2&t){let t;Cc(t=Mc())&&(e.canvasEl=t.first)}},decls:6,vars:0,consts:[["mode","side","opened",""]],template:function(t,e){1&t&&(sa(0,"app-header"),ra(1,"mat-drawer-container"),ra(2,"mat-drawer",0),sa(3,"app-settings"),ia(),ra(4,"mat-drawer-content"),sa(5,"app-video"),ia(),ia())},directives:[rw,mw,fw,HS,pw,HO],styles:["[_nghost-%COMP%]{display:flex;flex-direction:column}mat-drawer-container[_ngcontent-%COMP%]{height:100%}mat-drawer-content[_ngcontent-%COMP%]{display:flex;height:100%;align-items:center;justify-content:center}"]}),zh([Vp(t=>t.app.isLoading)],t.prototype,"isLoading$",void 0),zh([Vp(t=>t.app.error)],t.prototype,"error$",void 0),zh([Vp(t=>t.audio.error)],t.prototype,"audioError$",void 0),t})();const GO={provide:new Er("mat-menu-scroll-strategy"),deps:[c_],useFactory:function(t){return()=>t.scrollStrategies.reposition()}};let qO=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},providers:[GO],imports:[Ry]}),t})(),XO=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},providers:[GO],imports:[[ch,Ry,jy,h_,qO],wb,Ry,qO]}),t})(),KO=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},imports:[[ch,Ry,cf],Ry]}),t})(),YO=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)}}),t})(),ZO=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},imports:[[jy,Ry,cf,YO],Ry,YO]}),t})(),JO=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)}}),t})(),QO=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},imports:[[JO,jy,Ry,cf],JO,Ry]}),t})();const tD=[sx,N_,ew,C_,Y_,iv,XO,kO,gw,zS,KO,ZO,QO,Ty];let eD=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},imports:[tD,sx,N_,ew,C_,Y_,iv,XO,kO,gw,zS,KO,ZO,QO,Ty]}),t})();const nD={isLoading:!1,error:null};let rD=(()=>{let t=class{startLoading({patchState:t}){t({isLoading:!0})}stopLoading({patchState:t}){t({isLoading:!1})}displayError({patchState:t},{message:e}){t({error:e})}resetError({patchState:t}){t({error:null})}};return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),zh([Bp(sv)],t.prototype,"startLoading",null),zh([Bp(ov)],t.prototype,"stopLoading",null),zh([Bp(lv)],t.prototype,"displayError",null),zh([Bp(av)],t.prototype,"resetError",null),t=zh([zp({name:"app",defaults:nD})],t),t})();const iD={receiveVideo:!0,detectSign:!1,drawVideo:!0,drawPose:!0,drawSignWriting:!0};let sD=(()=>{let t=class{setSetting({patchState:t},{setting:e,value:n}){t({[e]:n})}};return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),zh([Bp(yw)],t.prototype,"setSetting",null),t=zh([zp({name:"settings",defaults:iD})],t),t})(),oD=(()=>{class t{}return t.type="[Video] Start Camera",t})(),aD=(()=>{class t{}return t.type="[Video] Stop Camera",t})(),lD=(()=>{class t{getCamera(t){return Vh(this,void 0,void 0,function*(){try{return yield navigator.mediaDevices.getUserMedia({audio:!1,video:t})}catch(e){throw e.message.includes("Permission denied")?new Error("permissionDenied"):new Error("notConnected")}})}getMicrophone(){return Vh(this,void 0,void 0,function*(){try{return yield navigator.mediaDevices.getUserMedia({audio:!0})}catch(t){throw t.message.includes("Permission denied")?new Error("permissionDenied"):new Error("notConnected")}})}getSpeaker(t){return Vh(this,void 0,void 0,function*(){const e=(yield navigator.mediaDevices.enumerateDevices()).find(e=>"audiooutput"===e.kind&&t.has(e.label));if(!e)throw new Error("missingSpeaker");return e})}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const cD={camera:null,cameraSettings:null,error:null};let uD=(()=>{let t=class{constructor(t){this.navigator=t}ngxsOnInit({dispatch:t}){this.receiveVideo$.pipe($d(e=>{t(e?oD:aD)})).subscribe()}stopCamera({patchState:t,getState:e}){const{camera:n,error:r}=e();n&&n.getTracks().forEach(t=>t.stop()),t(Object.assign(Object.assign({},cD),{error:r||"turnedOff"}))}startCamera(t){return Vh(this,void 0,void 0,function*(){const{patchState:e,dispatch:n}=t;e({error:"starting"}),this.stopCamera(t);const r=()=>n(new yw("receiveVideo",!1));try{const t=yield this.navigator.getCamera({facingMode:"user",width:{min:1280},height:{min:720}});if(!t)throw new Error("notConnected");const n=t.getVideoTracks()[0],i=n.getSettings(),s={aspectRatio:i.aspectRatio>1.9?"2-1":i.aspectRatio<1.5?"4-3":"16-9",frameRate:i.frameRate,width:i.width,height:i.height};n.addEventListener("ended",r),e({camera:t,cameraSettings:s,error:null})}catch(i){e({error:i.message}),r()}})}};return t.\u0275fac=function(e){return new(e||t)(zr(lD))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),zh([Vp(t=>t.settings.receiveVideo)],t.prototype,"receiveVideo$",void 0),zh([Bp(aD)],t.prototype,"stopCamera",null),zh([Bp(oD)],t.prototype,"startCamera",null),t=zh([zp({name:"video",defaults:cD})],t),t})(),hD=(()=>{class t{}return t.type="[Audio] Enable Transmission",t})(),dD=(()=>{class t{}return t.type="[Audio] Disable Transmission",t})();const pD=new Set(["Line 1 (Virtual Audio Cable)","VB-Cable (Virtual)"]),fD={microphone:null,speakerSink:null,error:null};let mD=(()=>{let t=class{constructor(t){this.navigator=t}ngxsOnInit({dispatch:t}){this.transmitAudio$.pipe($d(e=>{t(e?hD:dD)})).subscribe()}disableTransmission({patchState:t,getState:e}){const{microphone:n}=e();n&&n.getTracks().forEach(t=>t.stop()),t(Object.assign(Object.assign({},fD),{error:null}))}enableTransmission(t){return Vh(this,void 0,void 0,function*(){const{patchState:e,dispatch:n}=t;this.disableTransmission(t);const r=()=>n(new yw("transmitAudio",!1));try{const t=yield this.navigator.getMicrophone();t.getAudioTracks()[0].addEventListener("ended",r),e({microphone:t,speakerSink:yield this.getSpeaker(),error:null})}catch(i){e({error:i.message}),r()}})}getSpeaker(t=!0){return Vh(this,void 0,void 0,function*(){try{const t=yield this.navigator.getSpeaker(pD);return{id:t.deviceId,label:t.label}}catch(e){if(t)throw e;return null}})}};return t.\u0275fac=function(e){return new(e||t)(zr(lD))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),zh([Vp(t=>t.settings.transmitAudio)],t.prototype,"transmitAudio$",void 0),zh([Bp(dD)],t.prototype,"disableTransmission",null),zh([Bp(hD)],t.prototype,"enableTransmission",null),t=zh([zp({name:"audio",defaults:fD})],t),t})();const gD={developmentMode:!1,selectorOptions:{suppressErrors:!1,injectContainerState:!1},compatibility:{strictContentSecurityPolicy:!0}};let yD=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},imports:[[$p.forRoot([rD,sD,uD,mD],gD)]]}),t})();var vD=n("qkWt");const bD=new Er("TRANSLOCO_MESSAGE_FORMAT_CONFIG");function _D(t,e){return new vD(t,e)}let xD=(()=>{class t extends $v{constructor(t,e){super(e);const n=t||{locales:void 0},{locales:r}=n,i=function(t,e){var n={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(n[r]=t[r]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(r=Object.getOwnPropertySymbols(t);i<r.length;i++)e.indexOf(r[i])<0&&Object.prototype.propertyIsEnumerable.call(t,r[i])&&(n[r[i]]=t[r[i]])}return n}(n,["locales"]);this.messageConfig=i,this.messageFormat=_D(r,i)}transpile(t,e={},n){if(!t)return t;if(kv(t)&&e)Object.keys(e).forEach(r=>{const i=Cv(t,r),s=Cv(e,r),o=super.transpile(i,s,n),a=this.messageFormat.compile(o);t=Tv(t,r,a(e[r]))});else if(!Array.isArray(t)){const r=super.transpile(t,e,n);return this.messageFormat.compile(r)(e)}return t}onLangChanged(t){this.setLocale(t)}setLocale(t){this.messageFormat=_D(t,this.messageConfig)}}return t.\u0275fac=function(e){return new(e||t)(zr(bD,8),zr(Lv,8))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),t})(),wD=(()=>{class t{constructor(){}static init(e){return{ngModule:t,providers:[{provide:bD,useValue:e},{provide:Pv,useClass:xD}]}}}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)}}),t})();const SD={provide:Ev,useClass:(()=>{class t{constructor(t){this.http=t}getTranslation(t){return this.http.get(`/assets/i18n/${t}.json`)}}return t.\u0275fac=function(e){return new(e||t)(zr(Ex))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})()};let ED=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},providers:[{provide:Lv,useValue:{availableLangs:["en","es"],defaultLang:"en",prodMode:true}},SD],imports:[[Bx,wD.init()],ub]}),t})();const CD=[yD,ED,eD,ch];let TD=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},imports:[CD,yD,ED,eD,ch]}),t})();const AD={isLoaded:!1,pose:null};let MD=(()=>{let t=class{constructor(t,e){this.poseService=t,this.store=e}ngxsOnInit(t){this.store.dispatch(qS)}load({patchState:t}){return Vh(this,void 0,void 0,function*(){t({isLoaded:!1}),yield this.poseService.load(),this.poseService.model.onResults(t=>this.store.dispatch(new KS(t)))})}poseFrame({},{video:t}){return Vh(this,void 0,void 0,function*(){yield this.poseService.predict(t)})}storePose({patchState:t},{pose:e}){t({isLoaded:!0,pose:e})}};return t.\u0275fac=function(e){return new(e||t)(zr(QS),zr(Rp))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),zh([Bp(qS)],t.prototype,"load",null),zh([Bp(XS)],t.prototype,"poseFrame",null),zh([Bp(KS)],t.prototype,"storePose",null),t=zh([zp({name:"pose",defaults:AD})],t),t})(),kD=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},providers:[QS],imports:[[$p.forFeature([MD])]]}),t})(),RD=(()=>{class t{constructor(t,e){this.hand=t,this.landmarks=e}}return t.type="[SignWriting - Hands] Estimate Hand Shape",t})(),ID=(()=>{class t{constructor(t){this.landmarks=t}}return t.type="[SignWriting - Face] Estimate Face Shape",t})(),ND=(()=>{class t{constructor(t){this.pose=t}}return t.type="[SignWriting - Body] Calculate Body Factors",t})();const OD={timestamp:null,body:null,face:null,leftHand:null,rightHand:null};let DD=(()=>{let t=class{constructor(t,e,n){this.bodyService=t,this.faceService=e,this.handsService=n}ngxsOnInit({patchState:t,dispatch:e}){this.pose$.pipe(yd(Boolean),$d(n=>{e([new ND(n),new ID(n.faceLandmarks),new RD("leftHand",n.leftHandLandmarks),new RD("rightHand",n.rightHandLandmarks)]).subscribe(()=>t({timestamp:Date.now()}))})).subscribe()}calculateBody({patchState:t},{pose:e}){return Vh(this,void 0,void 0,function*(){t(e.poseLandmarks?{body:{shoulders:this.bodyService.shoulders(e.poseLandmarks),elbows:[e.poseLandmarks[YS.POSE_LANDMARKS.LEFT_ELBOW],e.poseLandmarks[YS.POSE_LANDMARKS.RIGHT_ELBOW]],wrists:[e.poseLandmarks[YS.POSE_LANDMARKS.LEFT_WRIST],e.poseLandmarks[YS.POSE_LANDMARKS.RIGHT_WRIST]]}}:{body:null})})}estimateFace({patchState:t},{landmarks:e}){return Vh(this,void 0,void 0,function*(){t(e?{face:{center:this.faceService.center(e),shape:"\ud8f1\udf81"}}:{face:null})})}estimateHand({patchState:t},{hand:e,landmarks:n}){return Vh(this,void 0,void 0,function*(){if(!n)return void t({[e]:null});const r="leftHand"===e,i=n.map(t=>new VE(t.x,t.y,t.z)),s=this.handsService.normal(i,r),o=this.handsService.plane(i);t({[e]:{bbox:this.handsService.bbox(i),normal:s,plane:o,rotation:this.handsService.rotation(i),direction:this.handsService.direction(o,s,r),shape:"\ud8c8\udee1"}})})}};return t.\u0275fac=function(e){return new(e||t)(zr(yO),zr(vO),zr(bO))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),zh([Vp(t=>t.pose.pose)],t.prototype,"pose$",void 0),zh([Bp(ND)],t.prototype,"calculateBody",null),zh([Bp(ID)],t.prototype,"estimateFace",null),zh([Bp(RD)],t.prototype,"estimateHand",null),t=zh([zp({name:"signWriting",defaults:OD})],t),t})(),LD=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},providers:[bO,yO,vO],imports:[[$p.forFeature([DD])]]}),t})(),FD=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},providers:[],imports:[[$p.forFeature([sD]),TD,SS]]}),t})(),PD=(()=>{class t{constructor(t){this.pose=t}}return t.type="[Detector] Detect If Signing",t})();class $D{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];console.warn(`Setting feature override from URL ${t}: ${e}.`),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(e instanceof Promise)throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=function(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...n)=>(function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("="))),e}(this.global.location.search);"tfjsflags"in t&&t.tfjsflags.split(",").forEach(t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}(e,n)})}}function BD(){return VD}let zD,VD=null;function UD(){if(null==zD){let t;if("undefined"!=typeof window)t=window;else if("undefined"!=typeof global)t=global;else if("undefined"!=typeof process)t=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}zD=t}return zD}function HD(t,e){const n=function(){const t=UD();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const WD="Acos",jD="Acosh",GD="Add",qD="AddN",XD="ArgMax",KD="ArgMin",YD="Asin",ZD="Asinh",JD="Atan",QD="Atanh",tL="Atan2",eL="AvgPool",nL="AvgPool3D",rL="BatchMatMul",iL="BatchToSpaceND",sL="BroadcastTo",oL="Cast",aL="Ceil",lL="ClipByValue",cL="Concat",uL="Conv2D",hL="Conv2DBackpropInput",dL="Conv3D",pL="Cosh",fL="Cumsum",mL="DepthwiseConv2dNative",gL="Dilation2D",yL="Dilation2DBackpropInput",vL="Dilation2DBackpropFilter",bL="Div",_L="Expm1",xL="FlipLeftRight",wL="Floor",SL="FloorDiv",EL="FusedBatchNorm",CL="GatherV2",TL="GreaterEqual",AL="Identity",ML="IsFinite",kL="IsInf",RL="IsNan",IL="Log1p",NL="LogSoftmax",OL="Max",DL="Maximum",LL="MaxPool",FL="MaxPool3D",PL="MaxPoolWithArgmax",$L="Minimum",BL="Multiply",zL="Negate",VL="NonMaxSuppressionV3",UL="NonMaxSuppressionV4",HL="NonMaxSuppressionV5",WL="OnesLike",jL="OneHot",GL="PadV2",qL="Prelu",XL="Reciprocal",KL="Relu",YL="Reshape",ZL="ResizeNearestNeighbor",JL="ResizeBilinear",QL="Relu6",tF="Reverse",eF="Round",nF="Rsqrt",rF="SelectV2",iF="Selu",sF="Slice",oF="Sinh",aF="Sign",lF="Sigmoid",cF="Softplus",uF="Sqrt",hF="SpaceToBatchND",dF="SplitV",pF="Softmax",fF="SquaredDifference",mF="Square",gF="Tanh",yF="Tile",vF="Transpose",bF="Unpack",_F="UnsortedSegmentSum",xF="ZerosLike",wF="Step",SF="FromPixels",EF="RotateWithOffset",CF="_FusedMatMul",TF="FusedConv2D",AF="FusedDepthwiseConv2D",MF=HD("kernelRegistry",()=>new Map),kF=HD("gradRegistry",()=>new Map);function RF(t,e){const n=LF(t,e);return MF.get(n)}function IF(t){return kF.get(t)}function NF(t){const e=MF.entries(),n=[];for(;;){const{done:r,value:i}=e.next();if(r)break;const[s,o]=i,[a]=s.split("_");a===t&&n.push(o)}return n}function OF(t){const{kernelName:e,backendName:n}=t,r=LF(e,n);MF.has(r)&&console.warn(`The kernel '${e}' for backend '${n}' is already registered`),MF.set(r,t)}function DF(t){const{kernelName:e}=t;kF.has(e)&&BD().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${e}'`),kF.set(e,t)}function LF(t,e){return`${e}_${t}`}function FF(t){let e=t.length,n=0,r=0;for(;e>0;)r=Math.random()*e|0,e--,n=t[e],t[e]=t[r],t[r]=n}function PF(t,e,n){return Math.max(t,Math.min(e,n))}function $F(t){return t%2==0?t:t+1}function BF(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function zF(t,e){const n=Math.random();return e*n+(1-n)*t}function VF(t,e){let n=0;for(let r=0;r<t.length;r++){const i=Number(t[r])-Number(e[r]);n+=i*i}return n}function UF(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function HF(t,e,n=""){UF(XF(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function WF(t){UF(null!=t,()=>"The input to the tensor constructor must be a non-null value.")}function jF(t,e=[],n=!1){if(null==e&&(e=[]),Array.isArray(t)||cP(t)&&!n)for(let r=0;r<t.length;++r)jF(t[r],e,n);else e.push(t);return e}function GF(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function qF(t){return 0===t.length}function XF(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function KF(t){return t%1==0}function YF(t){if(null!=Math.tanh)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{const e=Math.exp(2*t);return(e-1)/(e+1)}}function ZF(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function JF(t){const e=new Uint32Array(t);for(let n=0;n<t;++n)e[n]=n;return FF(e),e}function QF(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function tP(t,e=(t=>0),n){return new Promise((r,i)=>{let s=0;const o=()=>{if(t())return void r();s++;const a=e(s);null!=n&&s>=n?i():setTimeout(o,a)};o()})}function eP(t,e){let n=1,r=-1;for(let s=0;s<t.length;++s)if(t[s]>=0)n*=t[s];else if(-1===t[s]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(t[s]<0)throw Error(`Shapes can not be < 0. Found ${t[s]} at dim ${s}`);if(-1===r){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(0===n)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const i=t.slice();return i[r]=e/n,i}function nP(t,e){const n=e.length;return UF((t=null==t?e.map((t,e)=>e):[].concat(t)).every(t=>t>=-n&&t<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),UF(t.every(t=>KF(t)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(t=>t<0?n+t:t)}function rP(t,e){const n=[],r=[],i=null!=e&&Array.isArray(e)&&0===e.length,s=null==e||i?null:nP(e,t).sort();let o=0;for(let a=0;a<t.length;++a){if(null!=s){if(s[o]===a&&1!==t[a])throw new Error(`Can't squeeze axis ${a} since its dim '${t[a]}' is not 1`);(null==s[o]||s[o]>a)&&1===t[a]&&(n.push(t[a]),r.push(a)),s[o]<=a&&o++}1!==t[a]&&(n.push(t[a]),r.push(a))}return{newShape:n,keptDims:r}}function iP(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else{if("bool"!==t)throw new Error(`Unknown data type ${t}`);n=new Uint8Array(e)}return n}function sP(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error(`Unknown data type ${t}`);n=new Array(e)}return n}function oP(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function aP(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}function lP(t,e){return!("complex64"===e||"float32"===e&&"complex64"!==t||"int32"===e&&"float32"!==t&&"complex64"!==t||"bool"===e&&"bool"===t)}function cP(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function uP(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error(`Unknown dtype ${t}`)}function hP(t){if(null==t)return 0;let e=0;return t.forEach(t=>e+=t.length),e}function dP(t){return"string"==typeof t||t instanceof String}function pP(t){return"boolean"==typeof t}function fP(t){return"number"==typeof t}function mP(t){return Array.isArray(t)?mP(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array?"int32":fP(t)?"float32":dP(t)?"string":pP(t)?"bool":"float32"}function gP(t){return!!(t&&t.constructor&&t.call&&t.apply)}function yP(t,e){for(let n=e;n<t;++n)if(t%n==0)return n;return t}function vP(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function bP(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=jF(t)),BD().getBool("DEBUG")&&oP(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error(`Unknown data type ${e}`)}function _P(t,e,n){const r=new Array;if(1===e.length){const i=e[0];for(let e=0;e<i;e++)r[e]=n[t+e]}else{const i=e[0],s=e.slice(1),o=s.reduce((t,e)=>t*e);for(let e=0;e<i;e++)r[e]=_P(t+e*o,s,n)}return r}function xP(t,e){if(0===t.length)return e[0];const n=t.reduce((t,e)=>t*e);if(0===n)return[];if(n!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}.`);return _P(0,t,e)}function wP(t,e){const n=SP(t,e);for(let r=0;r<n.length;r++)n[r]=1;return n}function SP(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function EP(t,e){const n=t.reduce((t,e)=>t*e,1);if(null==e||"float32"===e)return xP(t,new Float32Array(n));if("int32"===e)return xP(t,new Int32Array(n));if("bool"===e)return xP(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function CP(){return BD().platform.now()}function TP(t){t.forEach(e=>{UF(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function AP(t,e){return BD().platform.fetch(t,e)}function MP(t,e="utf-8"){return e=e||"utf-8",BD().platform.encode(t,e)}function kP(t,e="utf-8"){return e=e||"utf-8",BD().platform.decode(t,e)}function RP(t,e,n){if(0===e)return 0;if(1===e)return t[0];let r=t[t.length-1];for(let i=0;i<t.length-1;++i)r+=n[i]*t[i];return r}function IP(t,e,n){if(0===e)return[];if(1===e)return[t];const r=new Array(e);for(let i=0;i<r.length-1;++i)r[i]=Math.floor(t/n[i]),t-=r[i]*n[i];return r[r.length-1]=t,r}class NP{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new OP)}profileKernel(t,e,n){let r;const i=this.backendTimer.time(()=>{r=n()});return r.map(e=>{e.data().then(n=>{!function(t,e,n){if("float32"!==e)return!1;for(let r=0;r<t.length;r++){const e=t[r];if(isNaN(e)||!isFinite(e))return console.warn(`Found ${e} in the result of '${n}'`),!0}}(n,e.dtype,t)})}),{kernelName:t,outputs:r,inputs:e,timeMs:i.then(t=>t.kernelMs),extraInfo:i.then(t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:r,inputs:i,extraInfo:s}=t;n.forEach(t=>{Promise.all([t.data(),r,s]).then(n=>{this.logger.logKernelProfile(e,t,n[0],n[1],i,n[2])})})}}class OP{logKernelProfile(t,e,n,r,i,s){const o="number"==typeof r?QF(`${r}ms`,9):r.error,a=QF(t,25),l=e.rank,c=e.size,u=QF(e.shape.toString(),14);let h="";for(const d in i){const t=i[d];if(null!=t){const n=t.shape||e.shape,r=n.length;h+=`${d}: ${r}D ${r>0?n:""} `}}console.log(`%c${a}\t%c${o}\t%c${l}D ${u}\t%c${c}\t%c${h}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function DP(t,e,n,r){const i=vP(e),s=function(t,e,n,r){const i=GF(e),s=r[r.length-1],o=new Array(s).fill(0),a=e.length,l="complex64"===n?$P(t):t;if(a>1)for(let c=0;c<i/s;c++){const t=c*s;for(let e=0;e<s;e++)o[e]=Math.max(o[e],LP(l[t+e],0,n).length)}return o}(t,e,n,i),o=e.length,a=PP(t,e,n,i,s),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(t=>"    "+t).join("\n")),l.join("\n")}function LP(t,e,n){let r;return r=Array.isArray(t)?`${parseFloat(t[0].toFixed(7))} + ${parseFloat(t[1].toFixed(7))}j`:dP(t)?`'${t}'`:"bool"===n?FP(t):parseFloat(t.toFixed(7)).toString(),QF(r,e)}function FP(t){return 0===t?"false":"true"}function PP(t,e,n,r,i,s=!0){const o="complex64"===n?2:1,a=e[0],l=e.length;if(0===l)return"complex64"===n?[LP($P(t)[0],0,n)]:"bool"===n?[FP(t[0])]:[t[0].toString()];if(1===l){if(a>20){let e=Array.from(t.slice(0,3*o)),r=Array.from(t.slice((a-3)*o,a*o));return"complex64"===n&&(e=$P(e),r=$P(r)),["["+e.map((t,e)=>LP(t,i[e],n)).join(", ")+", ..., "+r.map((t,e)=>LP(t,i[a-3+e],n)).join(", ")+"]"]}return["["+("complex64"===n?$P(t):Array.from(t)).map((t,e)=>LP(t,i[e],n)).join(", ")+"]"]}const c=e.slice(1),u=r.slice(1),h=r[0]*o,d=[];if(a>20){for(let e=0;e<3;e++){const r=e*h;d.push(...PP(t.slice(r,r+h),c,n,u,i,!1))}d.push("...");for(let e=a-3;e<a;e++){const r=e*h;d.push(...PP(t.slice(r,r+h),c,n,u,i,e===a-1))}}else for(let m=0;m<a;m++){const e=m*h;d.push(...PP(t.slice(e,e+h),c,n,u,i,m===a-1))}const p=2===l?",":"";d[0]="["+d[0]+p;for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=",\n";for(let m=2;m<l;m++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":f),d}function $P(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class BP{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=GF(t),null!=n){const t=n.length;UF(t===this.size,()=>`Length of values '${t}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||sP(e,this.size),this.strides=vP(t)}set(t,...e){0===e.length&&(e=[0]),UF(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const n=this.locToIndex(e);this.values[n]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const r of t){if(r<0||r>=this.shape[e])throw new Error(`Requested out of range element at ${t}.   Buffer shape=${this.shape}`);e++}let n=t[t.length-1];for(let r=0;r<t.length-1;++r)n+=this.strides[r]*t[r];return this.values[n]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return zP().makeTensor(this.values,this.shape,this.dtype)}}let zP=null,VP=null,UP=null;class HP{constructor(t,e,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=GF(t),this.strides=vP(t),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return VP.buffer(this.shape,this.dtype,t)}bufferSync(){return VP.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return xP(this.shape,t)}arraySync(){return xP(this.shape,this.dataSync())}async data(){this.throwIfDisposed();const t=zP().read(this.dataId);if("string"===this.dtype){const e=await t;try{return e.map(t=>kP(t))}catch(V3){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataSync(){this.throwIfDisposed();const t=zP().readSync(this.dataId);if("string"===this.dtype)try{return t.map(t=>kP(t))}catch(V3){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await zP().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(zP().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return VP.print(this,t)}clone(){return this.throwIfDisposed(),VP.clone(this)}toString(t=!1){return DP(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),VP.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),zP().makeVariable(this,t,e,n)}}Object.defineProperty(HP,Symbol.hasInstance,{value:t=>!!t&&null!=t.dataId&&null!=t.shape&&null!=t.dtype});class WP extends HP{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!XF(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);zP().disposeTensor(this),this.dataId=t.dataId,zP().incRef(this,null)}dispose(){zP().disposeVariable(this),this.isDisposedInternal=!0}}var jP,GP,qP,XP,KP;Object.defineProperty(WP,Symbol.hasInstance,{value:t=>t instanceof HP&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(jP||(jP={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(GP||(GP={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(qP||(qP={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(XP||(XP={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(KP||(KP={}));const YP={float32:XP,int32:GP,bool:qP,complex64:KP};function ZP(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return YP[t][e]}function JP(t){return ZP(t,"int32")}function QP(t,e){if(t.dtype===e.dtype)return[t,e];const n=ZP(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function t$(t,e){UF(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function e$(t,e){return e.some(e=>e.id===t.id)}function n$(t){const e=[];return r$(t,e,new Set),e}function r$(t,e,n){if(null==t)return;if(t instanceof HP)return void e.push(t);if(r=t,!Array.isArray(r)&&"object"!=typeof r)return;var r;const i=t;for(const s in i){const t=i[s];n.has(t)||(n.add(t),r$(t,e,n))}}class i${constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class s${constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new i$}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void(await this.setBackend(n))}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(console.warn(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new NP(this.backendInstance),!0}setupRegisteredKernels(){NF(this.backendName).forEach(t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){NF(t).forEach(e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])})}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const n=e.factory();if(Promise.resolve(n)===n){const e=++this.pendingBackendInitId,r=n.then(n=>!(e<this.pendingBackendInitId||(this.registry[t]=n,this.pendingBackendInit=null,0))).catch(n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${t} failed`),console.warn(n.stack||n.message)),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}return this.registry[t]=n,{success:!0,asyncInit:!1}}catch(n){return console.warn(`Initialization of backend ${t} failed`),console.warn(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:r,asyncInit:i}=this.initializeBackend(n);if(i||r)return{name:n,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),r=n.backend,i=this.readSync(e);r.disposeData(e),n.backend=t,t.move(e,i,n.shape,n.dtype),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,r=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun(()=>this.startScope(r),()=>this.endScope(n),()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(r){throw e(),r}}nextTensorId(){return s$.nextTensorId++}nextVariableId(){return s$.nextVariableId++}clone(t){const e=this.makeTensorFromDataId(t.dataId,t.shape,t.dtype);return this.addTapeNode(this.state.activeScope.name,{x:t},[e],t=>({x:()=>{const e="float32";return o$.runKernelFunc(n=>n.cast(t,e),{x:t},null,oL,{dtype:e})}}),[],{}),e}runKernel(t,e,n,r,i){return this.runKernelFunc(null,e,null,t,n,r,i)}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const r=this.backend.numDataIds();let i=0;n.forEach(t=>{i+="complex64"===t.dtype?3:1});const s=r-e-i-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(s>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${s} data ids) after running '${t}'`)}runKernelFunc(t,e,n,r,i,s,o){let a,l=[];const c=this.isTapeOn();null==r&&(r=null!=this.state.activeScope?this.state.activeScope.name:"");const u=this.state.numBytes,h=this.state.numTensors;let d;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const p=RF(r,this.backendName);let f,m;if(null!=p)d=()=>{const t=this.backend.numDataIds();f=p.kernelFunc({inputs:e,attrs:i,backend:this.backend});const n=Array.isArray(f)?f:[f];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(r,t,n);const a=n.map(({dataId:t,shape:e,dtype:n})=>this.makeTensorFromDataId(t,e,n));if(c){let t=this.getTensorsForGradient(r,e,a);if(null==t){null==o&&(o=[]);const e=a.filter((t,e)=>o[e]);t=(s||[]).slice().concat(e)}l=this.saveTensorsForBackwardMode(t)}return a};else{const e=t=>{c&&(l=t.map(t=>this.keep(this.clone(t))))};d=()=>{const n=this.backend.numDataIds();f=this.tidy(()=>t(this.backend,e));const i=Array.isArray(f)?f:[f];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(r,n,i),i}}return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(m=this.profiler.profileKernel(r,e,()=>d()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(m),a=m.outputs):a=d()}),c&&this.addTapeNode(r,e,a,n,l,i),this.state.profiling&&this.state.activeProfile.kernels.push({name:r,bytesAdded:this.state.numBytes-u,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-h,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(e).map(t=>null!=e[t]?e[t].shape:null),outputShapes:a.map(t=>t.shape),kernelTimeMs:m.timeMs,extraInfo:m.extraInfo}),Array.isArray(f)?a:a[0]}saveTensorsForBackwardMode(t){return t.map(t=>this.keep(this.clone(t)))}getTensorsForGradient(t,e,n){const r=IF(t);if(null!=r){const t=r.inputsToSave||[],i=r.outputsToSave||[];let s;r.saveAllInputs?(UF(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),s=Object.keys(e).map(t=>e[t])):s=t.map(t=>e[t]);const o=n.filter((t,e)=>i[e]);return s.concat(o)}return null}makeTensor(t,e,n,r){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");r=r||this.backend;let i=t;"string"===(n=n||"float32")&&dP(t[0])&&(i=t.map(t=>MP(t)));const s=r.write(i,e,n),o=new HP(e,n,s,this.nextTensorId());if(this.incRef(o,r),"string"===n){const t=this.state.tensorInfo.get(s),e=hP(i);this.state.numBytes+=e-t.bytes,t.bytes=e}return o}makeTensorFromDataId(t,e,n,r){const i=new HP(e,n=n||"float32",t,this.nextTensorId());return this.incRef(i,r),i}makeVariable(t,e=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.cast(r));const i=new WP(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[i.name])throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}incRef(t,e){const n=this.state.tensorInfo.has(t.dataId)?this.state.tensorInfo.get(t.dataId).refCount:0;if(this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++,0===n){this.state.numDataBuffers++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*uP(t.dtype)),this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n,refCount:0}),this.state.numBytes+=n}this.state.tensorInfo.get(t.dataId).refCount++,t instanceof WP||this.track(t)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;this.state.numTensors--,"string"===t.dtype&&this.state.numStringTensors--;const e=this.state.tensorInfo.get(t.dataId);e.refCount<=1?("complex64"!==t.dtype&&(this.state.numBytes-=e.bytes),this.state.numDataBuffers--,e.backend.disposeData(t.dataId),this.state.tensorInfo.delete(t.dataId)):this.state.tensorInfo.get(t.dataId).refCount--}disposeVariables(){for(const t in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[t])}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(t=>t.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,r,i,s){const o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:i},a=IF(t);null!=a&&(r=a.gradFunc),null!=r&&(o.gradient=t=>(t=t.map((t,e)=>{if(null==t){const t=n[e],r=SP(t.size,t.dtype);return this.makeTensor(r,t.shape,t.dtype)}return t}),r(t.length>1?t:t[0],i,s))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=n$(t),n=new Set(e.map(t=>t.id));for(let i=0;i<this.state.activeScope.track.length;i++){const t=this.state.activeScope.track[i];t.kept||n.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(t=>{t.kept||t.scopeId!==r.id||this.track(t)})}gradients(t,e,n,r=!1){if(UF(e.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));UF(i instanceof HP,()=>"The result y returned by f() must be a tensor.");const s=function(t,e,n){const r={},i={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<t.length;l++){const n=t[l],s=n.inputs;for(const t in s){const o=s[t];let a=!1;for(let t=0;t<e.length;t++)if(r[o.id]){n.outputs.forEach(t=>r[t.id]=!0),a=!0,i[n.id]=!0;break}if(a)break}}const s={};s[n.id]=!0;const o={};for(let l=t.length-1;l>=0;l--){const e=t[l],n=e.inputs;for(let t=0;t<e.outputs.length;t++)if(s[e.outputs[t].id]){for(const t in n)s[n[t].id]=!0,o[e.id]=!0;break}}const a=[];for(let l=0;l<t.length;l++){const e=t[l];if(i[e.id]&&o[e.id]){const t={};for(const i in e.inputs){const n=e.inputs[i];r[n.id]&&(t[i]=n)}const n=Object.assign({},e);n.inputs=t,n.outputs=e.outputs,a.push(n)}}return a}(this.state.activeTape,e,i);if(!r&&0===s.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const t={};t[i.id]=null==n?function(t){const e=wP(GF(t),"float32");return o$.makeTensor(e,t,"float32")}(i.shape):n,function(t,e,n,r){for(let i=e.length-1;i>=0;i--){const s=e[i],o=[];if(s.outputs.forEach(e=>{const n=t[e.id];o.push(null!=n?n:null)}),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const a=s.gradient(o);for(const e in s.inputs){if(!(e in a))throw new Error(`Cannot backprop through input ${e}. Available gradients found: ${Object.keys(a)}.`);const i=n(()=>a[e]());if("float32"!==i.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${e} must have 'float32' dtype, but has '${i.dtype}'`);const o=s.inputs[e];if(!XF(i.shape,o.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${e}' has shape '${i.shape}', which does not match the shape of the input '${o.shape}'`);if(null==t[o.id])t[o.id]=i;else{const e=t[o.id];t[o.id]=r(e,i),e.dispose()}}}}(t,s,t=>this.tidy(t),a$);const r=e.map(e=>t[e.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(t=>{for(const e of t.saved)e.dispose()}),this.state.activeTape=null),{value:i,grads:r}})}customGrad(t){return UF(gP(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{let n;UF(e.every(t=>t instanceof HP),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const r={};return e.forEach((t,e)=>{r[e]=t}),this.runKernelFunc((r,i)=>(n=t(...e,i),UF(n.value instanceof HP,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),UF(gP(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),r,(t,r)=>{const i=n.gradFunc(t,r),s=Array.isArray(i)?i:[i];UF(s.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),UF(s.every(t=>t instanceof HP),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const o={};return s.forEach((t,e)=>{o[e]=()=>t}),o})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}async time(t){const e=CP(),n=await this.backend.time(t);return n.wallMs=CP()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new i$;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}s$.nextTensorId=0,s$.nextVariableId=0;const o$=function(){const t=UD();if(null==t._tfengine){const e=new $D(t);t._tfengine=new s$(e)}return VD=t._tfengine.ENV,zP=()=>t._tfengine,t._tfengine}();function a$(t,e){return o$.runKernelFunc((n,r)=>{const i=n.add(t,e);return r([t,e]),i},{a:t,b:e},null,GD)}function l$(){if("undefined"!=typeof navigator&&null!=navigator){const t=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function c$(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const u$=BD();let h$;function d$(t,e){let n=t;if(cP(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||cP(n)&&"string"!==e;)r.push(n.length),n=n[0];return Array.isArray(t)&&BD().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&p$(t,r,[]),r}function p$(t,e,n){if(n=n||[],!Array.isArray(t)&&!cP(t))return void UF(0===e.length,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);UF(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),UF(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const r=e.slice(1);for(let i=0;i<t.length;++i)p$(t[i],r,n.concat(i))}function f$(t,e,n,r){if(null!=t&&("numeric"!==t&&t!==e||"numeric"===t&&"string"===e))throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}function m$(t,e,n,r="numeric"){if(t instanceof HP)return f$(r,t.dtype,e,n),t;let i=mP(t);if("string"!==i&&["bool","int32","float32"].indexOf(r)>=0&&(i=r),f$(r,i,e,n),null==t||!cP(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${null==t?"null":t.constructor.name}'`);const s=d$(t,i);cP(t)||Array.isArray(t)||(t=[t]);const o="string"!==i?bP(t,i):jF(t,[],!0);return o$.makeTensor(o,s,i)}function g$(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((t,r)=>m$(t,`${e}[${r}]`,n),r)}function y$(t){const e=Object.keys(t);if(1!==e.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1));const i=(...t)=>{o$.startScope(n);try{const e=r(...t);return e instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o$.endScope(e),e}catch(e){throw o$.endScope(null),e}};return Object.defineProperty(i,"name",{value:n,configurable:!0}),i}u$.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),u$.registerFlag("IS_BROWSER",()=>c$()),u$.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),u$.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),u$.registerFlag("PROD",()=>!1),u$.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>u$.getBool("DEBUG")),u$.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),u$.registerFlag("IS_TEST",()=>!1),BD().get("IS_BROWSER")&&BD().setPlatform("browser",new class{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}}),BD().get("IS_NODE")&&BD().setPlatform("node",new class{constructor(){this.util=n(2),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=BD().global.fetch?BD().global.fetch(t,e):(null==h$&&(h$=n(1)),h$(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}});const v$=y$({abs_:function(t){const e=m$(t,"x","abs");return o$.runKernelFunc((t,n)=>(n([e]),"complex64"===e.dtype?t.complexAbs(e):t.abs(e)),{x:e},null,"Abs")}}),b$=y$({acos_:function(t){const e=m$(t,"x","acos");return o$.runKernelFunc((t,n)=>{const r=t.acos(e);return n([e]),r},{x:e},null,WD)}}),_$=y$({acosh_:function(t){const e=m$(t,"x","acosh");return o$.runKernelFunc((t,n)=>{const r=t.acosh(e);return n([e]),r},{x:e},null,jD)}}),x$=y$({add_:function(t,e){let n=m$(t,"a","add"),r=m$(e,"b","add");return[n,r]=QP(n,r),o$.runKernelFunc((t,e)=>{const i=t.add(n,r);return e([n,r]),i},{a:n,b:r},null,GD)}}),w$=y$({addN_:function(t){UF(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),UF(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const e=t.map((t,e)=>m$(t,`tensors${e}`,"addN")),n=e[0];return e.forEach(t=>{if(t.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(t=>{if(!XF(t.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),o$.runKernelFunc((t,n)=>{const r=t.addN(e);return n(e),r},e,null,qD)}});function S$(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function E$(t,e,n){const r=t.length+e.length,i=[];let s=0,o=0;for(let a=0;a<r;a++)-1===n.indexOf(a)?i.push(t[s++]):i.push(e[o++]);return i}function C$(t,e){const n=[],r=t.length;for(let i=0;i<r;i++)-1===e.indexOf(i)&&n.push(t[i]);return[n,e.map(e=>t[e])]}function T$(t,e){return E$(t,e.map(t=>1),e)}function A$(t,e,n){UF(S$(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function M$(t,e){if(S$(t,e))return null;const n=[];for(let r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach(t=>n.push(t)),n}function k$(t){return t.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function R$(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}const I$=y$({reshape_:function(t,e){const n=m$(t,"x","reshape",null);return e=eP(e,n.size),UF(n.size===GF(e),()=>"new shape and old shape must have the same number of elements."),o$.runKernelFunc((t,r)=>(r([n]),t.reshape(n,e)),{x:n},null,YL,{shape:e})}}),N$=y$({transpose_:function(t,e){const n=m$(t,"x","transpose");return null==e&&(e=n.shape.map((t,e)=>e).reverse()),UF(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`),e.forEach(t=>{UF(t>=0&&t<n.rank,()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${e}`)}),n.rank<=1?n.clone():o$.runKernelFunc(t=>t.transpose(n,e),{x:n},null,vF,{perm:e})}}),O$=y$({all_:function(t,e=null,n=!1){let r=m$(t,"x","all","bool");return o$.runKernelFunc(t=>{const i=nP(e,r.shape);let s=i;const o=M$(s,r.rank);null!=o&&(r=N$(r,o),s=R$(s.length,r.rank));const a=t.all(r,s);if(n){const t=T$(a.shape,i);return I$(a,t)}return a},{x:r},null,"All",{axis:e,keepDims:n})}}),D$=y$({any_:function(t,e=null,n=!1){let r=m$(t,"x","any","bool");return o$.runKernelFunc(t=>{const i=nP(e,r.shape);let s=i;const o=M$(s,r.rank);null!=o&&(r=N$(r,o),s=R$(s.length,r.rank));const a=t.any(r,s);if(n){const t=T$(a.shape,i);return I$(a,t)}return a},{x:r},null,"Any",{axis:e,keepDims:n})}}),L$=y$({argMax_:function(t,e=0){let n=m$(t,"x","argMax");return o$.runKernelFunc((t,r)=>{r([n]);let i=nP(e,n.shape);const s=M$(i,n.rank);return null!=s&&(n=N$(n,s),i=R$(i.length,n.rank)),t.argMax(n,i[0])},{x:n},null,XD,{axis:e})}}),F$=y$({argMin_:function(t,e=0){let n=m$(t,"x","argMin");return o$.runKernelFunc((t,r)=>{r([n]),null==e&&(e=0);let i=nP(e,n.shape);const s=M$(i,n.rank);return null!=s&&(n=N$(n,s),i=R$(i.length,n.rank)),t.argMin(n,i[0])},{x:n},null,KD,{axis:e})}}),P$=y$({asin_:function(t){const e=m$(t,"x","asin");return o$.runKernelFunc((t,n)=>{const r=t.asin(e);return n([e]),r},{x:e},null,YD)}}),$$=y$({asinh_:function(t){const e=m$(t,"x","asinh");return o$.runKernelFunc((t,n)=>{const r=t.asinh(e);return n([e]),r},{x:e},null,ZD)}}),B$=y$({atan_:function(t){const e=m$(t,"x","atan");return o$.runKernelFunc((t,n)=>{const r=t.atan(e);return n([e]),r},{x:e},null,JD)}}),z$=y$({atan2_:function(t,e){let n=m$(t,"a","atan2"),r=m$(e,"b","atan2");return[n,r]=QP(n,r),o$.runKernelFunc((t,e)=>{const i=t.atan2(n,r);return e([n,r]),i},{a:n,b:r},null,tL)}}),V$=y$({atanh_:function(t){const e=m$(t,"x","atanh");return o$.runKernelFunc((t,n)=>{const r=t.atanh(e);return n([e]),r},{x:e},null,QD)}}),U$=y$({cast_:function(t,e){const n=m$(t,"x","cast");if(!aP(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");return o$.runKernelFunc(t=>t.cast(n,e),{x:n},null,oL,{dtype:e})}});function H$(t,e,n,r,i="NHWC",s){return G$(t,[...e,t[3]],n,s,r,null,null,eB(i))}function W$(t,e,n,r,i,s,o="channelsLast"){const[a,l]=K$(e);let c;if("channelsLast"===o)c=[a,l,t[3],t[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);c=[a,l,t[1],t[1]]}return G$(t,c,n,r,i,s,!1,o)}function j$(t,e,n,r,i,s,o="NDHWC"){const[a,l,c]=Y$(e);let u,h;if("NDHWC"===o)h="channelsLast",u=[a,l,c,t[4],t[4]];else{if("NCDHW"!==o)throw new Error(`Unknown dataFormat ${o}`);h="channelsFirst",u=[a,l,c,t[1],t[1]]}return q$(t,u,n,r,i,!1,h,s)}function G$(t,e,n,r,i,s,o=!1,a="channelsLast"){let[l,c,u,h]=[-1,-1,-1,-1];if("channelsLast"===a)[l,c,u,h]=t;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,h,c,u]=t}const[d,p,,f]=e,[m,g]=K$(n),[y,v]=K$(r),b=Z$(d,y),_=Z$(p,v),{padInfo:x,outHeight:w,outWidth:S}=function(t,e,n,r,i,s,o,a,l){let c,u,h;if("number"==typeof t){c={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const i=function(t,e,n,r,i){null==r&&(r=X$(t,e,n));const s=t[1],o=J$((t[0]-e+2*r)/n+1,i);UF(KF(o),()=>`The output # of rows (${o}) must be an integer. Change the stride and/or zero pad parameters`);const a=J$((s-e+2*r)/n+1,i);return UF(KF(a),()=>`The output # of columns (${a}) must be an integer. Change the stride and/or zero pad parameters`),[o,a]}([e,n],s,r,t,a);u=i[0],h=i[1]}else if("same"===t){u=Math.ceil(e/r),h=Math.ceil(n/i);const t=Math.max(0,(u-1)*r+s-e),a=Math.max(0,(h-1)*i+o-n),l=Math.floor(t/2),d=t-l,p=Math.floor(a/2);c={top:l,bottom:d,left:p,right:a-p,type:"SAME"}}else if("valid"===t)c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-s+1)/r),h=Math.ceil((n-o+1)/i);else{if("object"!=typeof t)throw Error(`Unknown padding parameter: ${t}`);{const d="channelsLast"===l?t[1][0]:t[2][0],p="channelsLast"===l?t[1][1]:t[2][1],f="channelsLast"===l?t[2][0]:t[3][0],m="channelsLast"===l?t[2][1]:t[3][1];c={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},u=J$((e-s+d+p)/r+1,a),h=J$((n-o+f+m)/i+1,a)}}return{padInfo:c,outHeight:u,outWidth:h}}(i,c,u,m,g,b,_,s,a),E=o?f*h:f;let C;return"channelsFirst"===a?C=[l,E,w,S]:"channelsLast"===a&&(C=[l,w,S,E]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:u,inChannels:h,outHeight:w,outWidth:S,outChannels:E,padInfo:x,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:b,effectiveFilterWidth:_,dilationHeight:y,dilationWidth:v,inShape:t,outShape:C,filterShape:e}}function q$(t,e,n,r,i,s=!1,o="channelsLast",a){let[l,c,u,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[l,c,u,h,d]=t;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,d,c,u,h]=t}const[p,f,m,,g]=e,[y,v,b]=Y$(n),[_,x,w]=Y$(r),S=Z$(p,_),E=Z$(f,x),C=Z$(m,w),{padInfo:T,outDepth:A,outHeight:M,outWidth:k}=function(t,e,n,r,i,s,o,a,l,c,u){let h,d,p,f;if("number"==typeof t){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const s=function(t,e,n,r,i,s){null==i&&(i=X$(t,e,r));const o=t[1],a=t[2],l=J$((t[0]-e+2*i)/r+1,s);UF(KF(l),()=>`The output # of depths (${l}) must be an integer. Change the stride and/or zero pad parameters`);const c=J$((o-e+2*i)/r+1,s);UF(KF(c),()=>`The output # of rows (${c}) must be an integer. Change the stride and/or zero pad parameters`);const u=J$((a-e+2*i)/r+1,s);return UF(KF(u),()=>`The output # of columns (${u}) must be an integer. Change the stride and/or zero pad parameters`),[l,c,u,1]}([e,n,r,1],a,0,i,t,u);d=s[0],p=s[1],f=s[2]}else if("same"===t){d=Math.ceil(e/i),p=Math.ceil(n/s),f=Math.ceil(r/o);const t=(d-1)*i+a-e,u=(p-1)*s+l-n,m=(f-1)*o+c-r,g=Math.floor(t/2),y=t-g,v=Math.floor(u/2),b=u-v,_=Math.floor(m/2);h={top:v,bottom:b,left:_,right:m-_,front:g,back:y,type:"SAME"}}else{if("valid"!==t)throw Error(`Unknown padding parameter: ${t}`);h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((e-a+1)/i),p=Math.ceil((n-l+1)/s),f=Math.ceil((r-c+1)/o)}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(i,c,u,h,y,v,b,S,E,C,a),R=s?g*d:g;let I;return"channelsFirst"===o?I=[l,R,A,M,k]:"channelsLast"===o&&(I=[l,A,M,k,R]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:u,inWidth:h,inChannels:d,outDepth:A,outHeight:M,outWidth:k,outChannels:R,padInfo:T,strideDepth:y,strideHeight:v,strideWidth:b,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:S,effectiveFilterHeight:E,effectiveFilterWidth:C,dilationDepth:_,dilationHeight:x,dilationWidth:w,inShape:t,outShape:I,filterShape:e}}function X$(t,e,n,r=1){const i=Z$(e,r);return Math.floor((t[0]*(n-1)-n+i)/2)}function K$(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function Y$(t){return"number"==typeof t?[t,t,t]:t}function Z$(t,e){return e<=1?t:t+(t-1)*(e-1)}function J$(t,e){if(!e)return t;switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function Q$(t){const[e,n,r]=K$(t);return 1===e&&1===n&&1===r}function tB(t,e){return Q$(t)||Q$(e)}function eB(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}const nB=y$({avgPool_:function(t,e,n,r,i){const s=m$(t,"x","avgPool","float32");UF(tB(n,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`);let o=s,a=!1;3===s.rank&&(a=!0,o=I$(s,[1,s.shape[0],s.shape[1],s.shape[2]])),UF(4===o.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),null!=i&&UF(KF(r),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`);let l=o$.runKernelFunc((t,s)=>{const a=W$(o.shape,e,n,1,r,i);return s([o]),1===a.filterWidth&&1===a.filterHeight&&XF(a.inShape,a.outShape)?o.clone():t.avgPool(o,a)},{x:o},null,eL,{filterSize:e,strides:n,pad:r,dimRoundingMode:i});return l=U$(l,s.dtype),a?I$(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});function rB(t){BD().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function iB(){return o$}function sB(){return o$.memory()}function oB(t,e){return o$.tidy(t,e)}function aB(t){n$(t).forEach(t=>t.dispose())}function lB(t){return o$.keep(t)}function cB(t,e,n=1){return o$.registerBackend(t,e,n)}UP=rB;const uB=y$({avgPool3d_:function(t,e,n,r,i,s="NDHWC",o){null==o?o=[1,1,1]:rB("dilations is deprecated, this field will be gone in v3.0.0.");const a=m$(t,"x","avgPool3d","float32");let l=a,c=!1;4===a.rank&&(c=!0,l=I$(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),UF(5===l.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${l.rank}.`),UF("NDHWC"===s,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),UF(tB(n,o),()=>`Error in avgPool3d: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),null!=i&&UF(KF(r),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`);let u=o$.runKernelFunc((t,a)=>{null==o&&(o=[1,1,1]);const c=j$(l.shape,e,n,o,r,i,s);return a([l]),t.avgPool3d(l,c)},{x:l},null,nL,{filterSize:e,strides:n,pad:r,dimRoundingMode:i,dataFormat:s,dilations:o});return u=U$(u,l.dtype),c?I$(u,[u.shape[1],u.shape[2],u.shape[3],u.shape[4]]):u}});function hB(t,e){const n=t[0].length;t.forEach((t,e)=>{UF(t.length===n,()=>`Error in concat${n}D: rank of tensors[${e}] must be the same as the rank of the rest (${n})`)}),UF(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=t[0];t.forEach((t,i)=>{for(let s=0;s<n;s++)UF(s===e||t[s]===r[s],()=>`Error in concat${n}D: Shape of tensors[${i}] (${t}) does not match the shape of the rest (${r}) along the non-concatenated axis ${i}.`)})}function dB(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}function pB(t,e,n,r){if(null==r&&(r=mP(t)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!cP(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){TP(e);const t=GF(e),r=GF(n);UF(t===r,()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${r}`);for(let i=0;i<n.length;++i){const t=n[i],r=i!==n.length-1||t!==GF(e.slice(i));UF(n[i]===e[i]||!r,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return cP(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==r?bP(t,r):jF(t,[],!0),o$.makeTensor(t,e,r)}function fB(t,e,n){return pB(t,e,d$(t,n),n)}const mB=y$({concat_:function(t,e=0){UF(t.length>=1,()=>"Pass at least one tensor to concat");let n=g$(t,"tensors","concat");"complex64"===n[0].dtype&&n.forEach(t=>{if("complex64"!==t.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${t.dtype}. `)});const r=nP(e,n[0].shape)[0],i=dB(n.map(t=>t.shape),r);return 0===GF(i)?fB([],i):(n=n.filter(t=>t.size>0),1===n.length?n[0]:(hB(n.map(t=>t.shape),r),o$.runKernelFunc((t,e)=>{const i=t.concat(n,r);return e(n),i},n,null,cL,{axis:e})))}}),gB=y$({matMul_:function(t,e,n=!1,r=!1){let i=m$(t,"a","matMul"),s=m$(e,"b","matMul");[i,s]=QP(i,s),UF(i.rank>=2&&s.rank>=2&&i.rank===s.rank,()=>`Error in matMul: inputs must have the same rank of at least 2, got ranks ${i.rank} and ${s.rank}.`);const o=n?i.shape[i.rank-2]:i.shape[i.rank-1],a=r?s.shape[s.rank-1]:s.shape[s.rank-2],l=n?i.shape[i.rank-1]:i.shape[i.rank-2],c=r?s.shape[s.rank-2]:s.shape[s.rank-1],u=i.shape.slice(0,-2),h=s.shape.slice(0,-2),d=GF(u),p=GF(h);UF(XF(u,h),()=>`Error in matMul: outer dimensions (${u}) and (${h}) of Tensors with shapes ${i.shape} and ${s.shape} must match.`),UF(o===a,()=>`Error in matMul: inner shapes (${o}) and (${a}) of Tensors with shapes ${i.shape} and ${s.shape} and transposeA=${n} and transposeB=${r} must match.`);const f=i.shape.slice(0,-2).concat([l,c]),m=I$(i,n?[d,o,l]:[d,l,o]),g=I$(s,r?[p,c,a]:[p,a,c]),y=o$.runKernelFunc((t,e)=>(e([m,g]),t.batchMatMul(m,g,n,r)),{a:m,b:g},null,rL,{transposeA:n,transposeB:r});return I$(y,f)}}),yB=y$({mul_:function(t,e){let n=m$(t,"a","mul"),r=m$(e,"b","mul");return[n,r]=QP(n,r),o$.runKernelFunc((t,e)=>{const i=t.multiply(n,r);return e([n,r]),i},{a:n,b:r},null,BL)}}),vB=y$({sigmoid_:function(t){const e=m$(t,"x","sigmoid");return o$.runKernelFunc((t,n)=>{const r=t.sigmoid(e);return n([r]),r},{x:e},null,lF)}});function bB(t,e,n){UF(t.rank===e.length,()=>`Error in slice${t.rank}D: Length of begin ${e} must match the rank of the array (${t.rank}).`),UF(t.rank===n.length,()=>`Error in slice${t.rank}D: Length of size ${n} must match the rank of the array (${t.rank}).`);for(let r=0;r<t.rank;++r)UF(e[r]+n[r]<=t.shape[r],()=>`Error in slice${t.rank}D: begin[${r}] + size[${r}] (${e[r]+n[r]}) would overflow input.shape[${r}] (${t.shape[r]})`)}function _B(t){const e=[];let n=0;for(;t>0;)1&t&&e.push(n),t/=2,n++;return e}function xB(t,e,n){const r=[];for(let i=0;i<t.length;i++)r[i]=Math.ceil((e[i]-t[i])/n[i]);return r}function wB(t,e,n,r){const i=[...t];for(let s=i.length;s<r.length;s++)i.push(1);for(let s=0;s<n;s++)0===s?i[e]=1:(i.splice(e,0,1),i.pop());return i}function SB(t,e,n){return n<=t?n:n-(e-1)}function EB(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function CB(t,e,n,r,i){const s=[...i],o=EB(n,e);for(let a=0;a<s.length;a++)if(o.indexOf(a)>-1)s[a]=0;else{const i=SB(e,n,a);let o=r[i];t&1<<i&&(o=0),s[a]=o}return s}function TB(t,e,n,r,i){const s=[...i],o=EB(n,e);for(let a=0;a<s.length;a++)if(o.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{const i=SB(e,n,a);let o=r[i];t&1<<i&&(o=Number.MAX_SAFE_INTEGER),s[a]=o}for(let a=0;a<s.length;a++){const t=i[a];s[a]<0&&(s[a]+=t),s[a]=PF(0,s[a],i[a])}return s}function AB(t,e,n){let r=t[e];return(n&1<<e||null==r)&&(r=1),r}function MB(t,e,n,r,i,s){let o=e[i];(t&1<<i||s&1<<i||null==o)&&(o=(n[i]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const a=r[i];return o<0&&(o+=a),o=PF(0,o,a-1),o}function kB(t,e,n,r,i,s){let o=e[i];const a=n[i]||1;(t&1<<i||s&1<<i||null==o)&&(o=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[i];return o<0&&(o+=l),o=a>0?PF(0,o,l):PF(-1,o,l-1),o}function RB(t,e,n){let r=n.length;for(let i=0;i<n.length;i++)if(n[i]>1){r=i;break}for(let i=r+1;i<n.length;i++)if(e[i]>0||n[i]!==t[i])return!1;return!0}function IB(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function NB(t,e,n){let r,i;return r="number"==typeof e?[e,...new Array(t.rank-1).fill(0)]:e.length<t.rank?e.concat(new Array(t.rank-e.length).fill(0)):e.slice(),r.forEach(t=>{UF(-1!==t,()=>"slice() does not support negative begin indexing.")}),i=null==n?new Array(t.rank).fill(-1):"number"==typeof n?[n,...new Array(t.rank-1).fill(-1)]:n.length<t.rank?n.concat(new Array(t.rank-n.length).fill(-1)):n,i=i.map((e,n)=>e>=0?e:(UF(-1===e,()=>`Negative size values should be exactly -1 but got ${e} for the slice() size at index ${n}.`),t.shape[n]-r[n])),[r,i]}const OB=y$({slice_:function(t,e,n){const r=m$(t,"x","slice");if(0===r.rank)throw new Error("Slicing scalar is not possible");const[i,s]=NB(r,e,n);return bB(r,i,s),o$.runKernelFunc((t,e)=>(e([r]),t.slice(r,i,s)),{x:r},null,sF,{begin:e,size:n})}}),DB=y$({tanh_:function(t){const e=m$(t,"x","tanh");return o$.runKernelFunc((t,n)=>{const r=t.tanh(e);return n([r]),r},{x:e},null,gF)}}),LB=y$({basicLSTMCell_:function(t,e,n,r,i,s){const o=m$(t,"forgetBias","basicLSTMCell"),a=m$(e,"lstmKernel","basicLSTMCell"),l=m$(n,"lstmBias","basicLSTMCell"),c=m$(r,"data","basicLSTMCell"),u=m$(i,"c","basicLSTMCell"),h=m$(s,"h","basicLSTMCell"),d=mB([c,h],1),p=gB(d,a),f=x$(p,l),m=f.shape[1]/4,g=[f.shape[0],m],y=OB(f,[0,0],g),v=OB(f,[0,m],g),b=OB(f,[0,2*m],g),_=OB(f,[0,3*m],g),x=x$(yB(vB(y),DB(v)),yB(u,vB(x$(o,b))));return[x,yB(DB(x),vB(_))]}}),FB=y$({batchToSpaceND_:function(t,e,n){const r=m$(t,"x","batchToSpaceND"),i=e.reduce((t,e)=>t*e);return UF(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),UF(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),UF(r.shape[0]%i==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${i}`),o$.runKernelFunc(t=>t.batchToSpaceND(r,e,n),{x:r},null,iL,{blockShape:e,crops:n})}});function PB(t){return null==t?null:0===t.rank?I$(t,[t.size]):1===t.rank?t:2===t.rank?I$(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?I$(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t}const $B=y$({batchNorm_:function(t,e,n,r,i,s){null==s&&(s=.001);const o=m$(t,"x","batchNorm"),a=m$(e,"mean","batchNorm"),l=m$(n,"variance","batchNorm");let c,u;null!=i&&(c=m$(i,"scale","batchNorm")),null!=r&&(u=m$(r,"offset","batchNorm")),UF(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),UF(null==u||a.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),UF(null==c||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h=function(t){let e;return e=0===t.rank||1===t.rank?I$(t,[1,1,1,t.size]):2===t.rank?I$(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?I$(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,e}(o),d=o$.runKernelFunc((t,e)=>(e([h,a,l,c]),t.batchNorm(h,PB(a),PB(l),PB(u),PB(c),s)),{x:h,scale:c,offset:u,mean:a,variance:l},null,EL,{varianceEpsilon:s});return I$(d,o.shape)}}),BB=y$({batchNorm2d_:function(t,e,n,r,i,s){const o=m$(t,"x","batchNorm"),a=m$(e,"mean","batchNorm"),l=m$(n,"variance","batchNorm");let c,u;return null!=i&&(c=m$(i,"scale","batchNorm")),null!=r&&(u=m$(r,"offset","batchNorm")),UF(2===o.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),UF(2===a.rank||1===a.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),UF(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=c&&UF(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),null!=u&&UF(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),$B(o,a,l,u,c,s)}}),zB=y$({batchNorm3d_:function(t,e,n,r,i,s){const o=m$(t,"x","batchNorm"),a=m$(e,"mean","batchNorm"),l=m$(n,"variance","batchNorm");let c,u;return null!=i&&(c=m$(i,"scale","batchNorm")),null!=r&&(u=m$(r,"offset","batchNorm")),UF(3===o.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),UF(3===a.rank||1===a.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),UF(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=c&&UF(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),null!=u&&UF(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),$B(o,a,l,u,c,s)}}),VB=y$({batchNorm4d_:function(t,e,n,r,i,s){const o=m$(t,"x","batchNorm"),a=m$(e,"mean","batchNorm"),l=m$(n,"variance","batchNorm");let c,u;return null!=i&&(c=m$(i,"scale","batchNorm")),null!=r&&(u=m$(r,"offset","batchNorm")),UF(4===o.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),UF(4===a.rank||1===a.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),UF(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=c&&UF(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),null!=u&&UF(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),$B(o,a,l,u,c,s)}}),UB=y$({clone_:function(t){const e=m$(t,"x","clone",null);return o$.runKernelFunc(()=>o$.makeTensorFromDataId(e.dataId,e.shape,e.dtype),{x:e},null,AL)}}),HB=y$({broadcastTo_:function(t,e){let n=m$(t,"broadcastTo","x");const r=n.shape;if(e.some(t=>!(t>0)||t%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=I$(n,t)}const i=n.shape,s=Array.from(e);for(let o=e.length-1;o>=0;o--)if(i[o]===e[o])s[o]=1;else if(1!==n.shape[o])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);return 0===s.map((t,e)=>t>1?e:-1).filter(t=>t>=0).length?UB(n):o$.runKernelFunc(t=>t.tile(n,s),{x:n},null,sL,{shape:e,inputShape:i})}});function WB(t,e="float32",n){return e=e||"float32",TP(t),new BP(t,e,n)}const jB=y$({ceil_:function(t){const e=m$(t,"x","ceil");return o$.runKernelFunc(t=>t.ceil(e),{x:e},null,aL)}}),GB=y$({clipByValue_:function(t,e,n){const r=m$(t,"x","clipByValue");return UF(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`),o$.runKernelFunc((t,i)=>{const s=t.clip(r,e,n);return i([r]),s},{x:r},null,lL,{clipValueMin:e,clipValueMax:n})}}),qB=y$({complex_:function(t,e){const n=m$(t,"real","complex"),r=m$(e,"imag","complex");return HF(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`),o$.runKernelFunc(t=>t.complex(n,r),{real:n,imag:r},null,"Complex")}}),XB=y$({concat1d_:function(t){return mB(t,0)}}),KB=y$({concat2d_:function(t,e){return mB(t,e)}}),YB=y$({concat3d_:function(t,e){return mB(t,e)}}),ZB=y$({concat4d_:function(t,e){return mB(t,e)}}),JB=y$({conv2d_:function(t,e,n,r,i="NHWC",s=[1,1],o){const a=m$(t,"x","conv2d"),l=m$(e,"filter","conv2d");let c=a,u=!1;3===a.rank&&(u=!0,c=I$(a,[1,a.shape[0],a.shape[1],a.shape[2]])),UF(4===c.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),UF(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),null!=o&&UF(KF(r),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`);const h="NHWC"===i?c.shape[3]:c.shape[1];UF(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),UF(tB(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`);const d=o$.runKernelFunc((t,e)=>{const a=eB(i),u=G$(c.shape,l.shape,n,s,r,o,!1,a),h=t.conv2d(c,l,u);return e([c,l]),h},{x:c,filter:l},null,uL,{strides:n,pad:r,dataFormat:i,dilations:s,dimRoundingMode:o});return u?I$(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),QB=y$({conv1d_:function(t,e,n,r,i="NWC",s=1,o){const a=m$(t,"x","conv1d"),l=m$(e,"filter","conv1d");let c=a,u=!1;2===a.rank&&(u=!0,c=I$(a,[1,a.shape[0],a.shape[1]])),UF(3===c.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),UF(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),null!=o&&UF(KF(r),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`),UF(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),UF(tB(n,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`),UF("NWC"===i,()=>`Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);const h=I$(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=I$(c,[c.shape[0],1,c.shape[1],c.shape[2]]),p=JB(d,h,[1,n],r,"NHWC",[1,s],o);return I$(p,u?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}}),tz=y$({conv2DBackpropInput_:function(t,e,n,r,i,s="NHWC",o){UF(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let a=t,l=e,c=!1;3===e.rank&&(c=!0,l=I$(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,t[0],t[1],t[2]]),UF(4===a.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),UF(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),UF(4===n.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const u="NHWC"===s?a[3]:a[1],h="NHWC"===s?l.shape[3]:l.shape[1];UF(u===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[2]}.`),UF(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),null!=o&&UF(KF(i),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${o} but got pad ${i}.`);const d=o$.runKernelFunc((t,e)=>{const c=eB(s),u=G$(a,n.shape,r,1,i,o,!1,c),h=t.conv2dDerInput(l,n,u);return e([l,n]),h},{dy:l,filter:n},null,hL,{strides:r,pad:i,dataFormat:s,dimRoundingMode:o,inputShape:a});return c?I$(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),ez=y$({conv2dTranspose_:function(t,e,n,r,i,s){const o=m$(t,"x","conv2dTranspose"),a=m$(e,"filter","conv2dTranspose");return tz(n,o,a,r,i,"NHWC",s)}}),nz=y$({conv3d_:function(t,e,n,r,i="NDHWC",s=[1,1,1]){const o=m$(t,"x","conv3d"),a=m$(e,"filter","conv3d");let l=o,c=!1;4===o.rank&&(c=!0,l=I$(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),UF(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),UF(5===a.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),UF(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),UF(tB(n,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),UF("NDHWC"===i,()=>`Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`);const u=o$.runKernelFunc((t,e)=>{const i=q$(l.shape,a.shape,n,s,r),o=t.conv3d(l,a,i);return e([l,a]),o},{x:l,filter:a},null,dL,{strides:n,pad:r,dataFormat:i,dilations:s});return c?I$(u,[u.shape[1],u.shape[2],u.shape[3],u.shape[4]]):u}}),rz=y$({conv3DBackpropInput_:function(t,e,n,r,i){UF(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let s=t,o=e,a=!1;4===e.rank&&(a=!0,o=I$(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,t[0],t[1],t[2],t[3]]);const l=s[4],c=o.shape[4];UF(5===s.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),UF(5===o.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),UF(5===n.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),UF(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),UF(c===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[4]}.`);const u=o$.runKernelFunc(t=>{const e=q$(s,n.shape,r,1,i);return t.conv3dDerInput(o,n,e)},{dy:o},null,"Conv3DBackpropInputV2",{pad:i});return a?I$(u,[u.shape[1],u.shape[2],u.shape[3],u.shape[4]]):u}}),iz=y$({conv3dTranspose_:function(t,e,n,r,i){const s=m$(t,"x","conv3dTranspose"),o=m$(e,"filter","conv3dTranspose");return rz(n,s,o,r,i)}}),sz=y$({cos_:function(t){const e=m$(t,"x","cos");return o$.runKernelFunc((t,n)=>{const r=t.cos(e);return n([e]),r},{x:e},null,"Cos")}}),oz=y$({cosh_:function(t){const e=m$(t,"x","cosh");return o$.runKernelFunc((t,n)=>{const r=t.cosh(e);return n([e]),r},{x:e},null,pL)}}),az=y$({cumsum_:function(t,e=0,n=!1,r=!1){const i=m$(t,"x","cumsum");return o$.runKernelFunc((t,s)=>{const o=M$([e],i.rank);let a=i;null!=o&&(a=N$(i,o));const l=R$(1,i.rank)[0];let c=t.cumsum(a,l,n,r);if(s([i]),null!=o){const t=k$(o);c=N$(c,t)}return c},{x:i},null,fL,{axis:e,exclusive:n,reverse:r})}}),lz=y$({depthToSpace_:function(t,e,n="NHWC"){const r=m$(t,"x","depthToSpace"),i="NHWC"===n?r.shape[1]:r.shape[2],s="NHWC"===n?r.shape[2]:r.shape[3],o="NHWC"===n?r.shape[3]:r.shape[1];return UF(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${e}  for depthToSpace with input shape\n    ${r.shape}`),UF(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${e} for depthToSpace with input shape\n        ${r.shape}`),UF(o%(e*e)==0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${r.shape}`),o$.runKernelFunc(t=>t.depthToSpace(r,e,n),{x:r},null,"DepthToSpace",{blockSize:e,dataFormat:n})}}),cz=y$({depthwiseConv2d_:function(t,e,n,r,i="NHWC",s=[1,1],o){const a=m$(t,"x","depthwiseConv2d"),l=m$(e,"filter","depthwiseConv2d");let c=a,u=!1;3===a.rank&&(u=!0,c=I$(a,[1,a.shape[0],a.shape[1],a.shape[2]])),UF(4===c.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),UF(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`),UF(c.shape[3]===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),null!=o&&UF(KF(r),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`);const h=o$.runKernelFunc((t,e)=>{null==s&&(s=[1,1]),UF(tB(n,s),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`);const i=G$(c.shape,l.shape,n,s,r,o,!0),a=t.depthwiseConv2D(c,l,i);return e([c,l]),a},{x:c,filter:l},null,mL,{strides:n,pad:r,dataFormat:i,dilations:s,dimRoundingMode:o});return u?I$(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),uz=y$({diag_:function(t){const e=m$(t,"x","diag");return o$.runKernelFunc(n=>{const r=I$(e,[e.size]),i=n.diag(r),s=[...t.shape,...t.shape];return I$(i,s)},{x:e},null,"Diag")}}),hz=y$({dilation2d_:function(t,e,n,r,i=[1,1],s="NHWC"){const o=m$(t,"x","dilation2d"),a=m$(e,"filter","dilation2d");UF(3===o.rank||4===o.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),UF(3===a.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),UF("NHWC"===s,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=o,c=!1;3===o.rank&&(l=I$(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0);const u=o$.runKernel(gL,{x:l,filter:a},{strides:n,pad:r,dilations:i});return c?I$(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),dz=y$({floorDiv_:function(t,e){let n=m$(t,"a","floorDiv"),r=m$(e,"b","floorDiv");return[n,r]=QP(n,r),o$.runKernelFunc((t,e)=>{const i=t.floorDiv(n,r);return e([n,r]),i},{a:n,b:r},null,SL)}}),pz=y$({div_:function(t,e){let n=m$(t,"a","div"),r=m$(e,"b","div");return[n,r]=QP(n,r),"int32"===n.dtype&&"int32"===r.dtype?dz(n,r):o$.runKernelFunc((t,e)=>{const i=t.realDivide(n,r);return e([n,r]),i},{a:n,b:r},null,bL,{})}});function fz(t,e){const n=t.length,r=[];for(let i=0;i<n;i++){const s=n-1-i,o=t[s]||1;(e[e.length-1-i]||1)>1&&1===o&&r.unshift(s)}return r}function mz(t,e){const n=[];for(let r=0;r<e.length;r++){const i=t[t.length-r-1],s=e.length-r-1,o=e[s];(null==i||1===i&&o>1)&&n.unshift(s)}return n}function gz(t,e){const n=[],r=Math.max(t.length,e.length);for(let i=0;i<r;i++){let r=t[t.length-i-1];null==r&&(r=1);let s=e[e.length-i-1];if(null==s&&(s=1),1===r)n.unshift(s);else if(1===s)n.unshift(r);else{if(r!==s)throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`);n.unshift(r)}}return n}const yz=y$({equal_:function(t,e){let n=m$(t,"a","equal"),r=m$(e,"b","equal");return[n,r]=QP(n,r),gz(n.shape,r.shape),o$.runKernelFunc(t=>t.equal(n,r),{a:n,b:r},null,"Equal")}}),vz=y$({where_:function(t,e,n){const r=m$(e,"a","where"),i=m$(n,"b","where"),s=m$(t,"condition","where","bool"),o=gz(r.shape,i.shape),a=HB(r,o),l=HB(i,o);return 1===s.rank&&UF(s.shape[0]===r.shape[0],()=>"The first dimension of `a` must match the size of `condition`."),1!==s.rank&&HF(s.shape,l.shape,"Error in where: "),o$.runKernelFunc((t,e)=>{const n=t.select(s,a,l);return e([s]),n},{condition:s,t:a,e:l},null,rF)}}),bz=y$({zerosLike_:function(t){const e=m$(t,"x","zerosLike");return o$.runKernelFunc(t=>t.zerosLike(e),{x:e},null,xF)}}),_z=y$({divNoNan_:function(t,e){let n=m$(t,"a","div"),r=m$(e,"b","div");[n,r]=QP(n,r);const i=pz(n,r),s=bz(i),o=yz(r,s);return vz(o,s,i)}}),xz=y$({dot_:function(t,e){const n=m$(t,"t1","dot"),r=m$(e,"t2","dot");UF(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);const i=1===n.rank?n.size:n.shape[1],s=1===r.rank?r.size:r.shape[0];if(UF(i===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${s}.`),1===n.rank&&1===r.rank){const t=I$(n,[1,-1]),e=I$(r,[-1,1]),i=gB(t,e);return I$(i,[])}if(1===n.rank&&2===r.rank){const t=I$(n,[1,-1]),e=I$(r,[r.shape[0],r.shape[1]]),i=gB(t,e);return I$(i,[i.size])}if(2===n.rank&&1===r.rank){const t=I$(r,[-1,1]),e=gB(n,t);return I$(e,[e.size])}{const t=I$(r,[r.shape[0],r.shape[1]]);return gB(n,t)}}}),wz=y$({elu_:function(t){const e=m$(t,"x","elu");return o$.runKernelFunc((t,n)=>{const r=t.elu(e);return n([r]),r},{x:e},null,"Elu")}}),Sz=y$({erf_:function(t){let e=m$(t,"x","erf");return UF("int32"===e.dtype||"float32"===e.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===e.dtype&&(e=U$(e,"float32")),o$.runKernelFunc((t,n)=>{const r=t.erf(e);return n([e]),r},{x:e},null,"Erf")}}),Ez=y$({exp_:function(t){const e=m$(t,"x","exp");return o$.runKernelFunc((t,n)=>{const r=t.exp(e);return n([r]),r},{x:e},null,"Exp")}}),Cz=y$({expandDims_:function(t,e=0){const n=m$(t,"x","expandDims",null);UF(e<=n.rank,()=>"Axis must be <= rank of the tensor");const r=n.shape.slice();return e<0&&(UF(-(n.rank+1)<=e,()=>`Axis must be in the interval [${-(n.rank+1)}, ${n.rank}]`),e=n.rank+e+1),r.splice(e,0,1),I$(n,r)}}),Tz=y$({expm1_:function(t){const e=m$(t,"x","expm1");return o$.runKernelFunc((t,n)=>{const r=t.expm1(e);return n([e]),r},{x:e},null,_L)}}),Az=y$({tile_:function(t,e){const n=m$(t,"x","tile",null);return UF(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`),o$.runKernelFunc((t,r)=>{const i=t.tile(n,e);return r([n]),i},{x:n},null,yF,{reps:e},[n])}}),Mz=y$({eye_:function(t,e,n,r="float32"){null==e&&(e=t);const i=WB([t,e],r),s=t<=e?t:e;for(let a=0;a<s;++a)i.set(1,a,a);const o=I$(i.toTensor(),[t,e]);if(null==n)return o;if(1===n.length)return Az(Cz(o,0),[n[0],1,1]);if(2===n.length)return Az(Cz(Cz(o,0),0),[n[0],n[1],1,1]);if(3===n.length)return Az(Cz(Cz(Cz(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}}),kz=y$({fft_:function(t){return UF("complex64"===t.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`),o$.runKernelFunc(e=>{const n=t.shape[t.shape.length-1],r=t.as2D(t.size/n,n);return e.fft(r).reshape(t.shape)},{input:t},null,"FFT")}});function Rz(t,e,n){return o$.runKernelFunc(r=>r.fill(t,e,n),{},null,"Fill",{shape:t,value:e,dtype:n})}const Iz=y$({floor_:function(t){const e=m$(t,"x","floor");return o$.runKernelFunc(t=>t.floor(e),{x:e},null,wL)}}),Nz=30;function Oz(t){return t<=Nz?t:yP(t,Math.floor(Math.sqrt(t)))}function Dz(t,e){let n,r=!1;for(t<=Nz?(n=t,r=!0):n=yP(t,Math.floor(Math.sqrt(t)));!r;)n>e||n===t?r=!0:n=yP(t,n+1);return n}function Lz(t,e,n){const r=[],i=t.length;for(let s=0;s<i;s++)r.push(s!==e?t[s]:n);return r}function Fz(t,e,n){const r=t.shape[n],i=[];let s=1,o=1;for(let a=0;a<n;a++)i.push(t.shape[a]),s*=t.shape[a];for(let a=0;a<e.rank;a++)i.push(e.shape[a]);for(let a=n+1;a<t.rank;a++)i.push(t.shape[a]),o*=t.shape[a];return{batchSize:s,sliceSize:o,dimSize:r,outputShape:i}}const Pz=y$({gather_:function(t,e,n=0){const r=m$(t,"x","gather"),i=m$(e,"indices","gather","int32");return o$.runKernelFunc((t,e)=>{const s=nP(n,r.shape)[0],o=Fz(r,i,s),a=t.gather(r,I$(i,[i.size]),s);return e([r,i]),I$(a,o.outputShape)},{x:r,indices:i},null,CL,{axis:n})}}),$z=y$({greater_:function(t,e){let n=m$(t,"a","greater"),r=m$(e,"b","greater");return[n,r]=QP(n,r),gz(n.shape,r.shape),o$.runKernelFunc(t=>t.greater(n,r),{a:n,b:r},null,"Greater")}}),Bz=y$({greaterEqual_:function(t,e){let n=m$(t,"a","greaterEqual"),r=m$(e,"b","greaterEqual");return[n,r]=QP(n,r),gz(n.shape,r.shape),o$.runKernelFunc((t,e)=>{const i=t.greaterEqual(n,r);return e([n,r]),i},{a:n,b:r},null,TL)}}),zz=y$({ifft_:function(t){return UF("complex64"===t.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`),o$.runKernelFunc(e=>{const n=t.shape[t.shape.length-1],r=I$(t,[t.size/n,n]),i=e.ifft(r);return I$(i,t.shape)},{input:t},null,"IFFT")}}),Vz=y$({imag_:function(t){const e=m$(t,"input","imag");return o$.runKernelFunc(t=>t.imag(e),{input:e},null,"Imag")}}),Uz=y$({real_:function(t){const e=m$(t,"input","real");return o$.runKernelFunc(t=>t.real(e),{input:e},null,"Real")}}),Hz=y$({reverse_:function(t,e){const n=m$(t,"x","reverse");return o$.runKernelFunc(t=>{const r=nP(e,n.shape);if(0===n.rank)return UB(n);const i=t.reverse(n,r);return I$(i,n.shape)},{x:n},null,tF,{dims:e})}});function Wz(t,e){if((cP(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&cP(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return pB(t,[],[],e)}const jz=y$({irfft_:function(t){const e=t.shape[t.shape.length-1],n=t.size/e;let r;if(e<=2){const i=I$(t,[n,e]);r=zz(i)}else{const i=[n,2*(e-1)],s=I$(Uz(t),[n,e]),o=I$(Vz(t),[n,e]),a=Hz(OB(s,[0,1],[n,e-2]),1),l=yB(Hz(OB(o,[0,1],[n,e-2]),1),Wz(-1)),c=mB([s,a],1),u=mB([o,l],1),h=I$(qB(c,u),[i[0],i[1]]);r=zz(h)}if(r=Uz(r),3===t.rank&&0!==t.shape[0]){const e=r,n=t.shape[0];r=I$(r,[n,r.shape[0]/n,r.shape[1]]),e.dispose()}return r}}),Gz=y$({isFinite_:function(t){const e=m$(t,"x","isFinite");return o$.runKernelFunc(t=>t.isFinite(e),{x:e},null,ML)}}),qz=y$({isInf_:function(t){const e=m$(t,"x","isInf");return o$.runKernelFunc(t=>t.isInf(e),{x:e},null,kL)}}),Xz=y$({isNaN_:function(t){const e=m$(t,"x","isNaN");return o$.runKernelFunc(t=>t.isNaN(e),{x:e},null,RL)}}),Kz=y$({maximum_:function(t,e){let n=m$(t,"a","maximum"),r=m$(e,"b","maximum");return[n,r]=QP(n,r),"bool"===n.dtype&&(n=U$(n,"int32"),r=U$(r,"int32")),gz(n.shape,r.shape),o$.runKernelFunc((t,e)=>{const i=t.maximum(n,r);return e([n,r]),i},{a:n,b:r},null,DL)}}),Yz=y$({leakyRelu_:function(t,e=.2){const n=m$(t,"x","leakyRelu");return Kz(yB(Wz(e),n),n)}}),Zz=y$({less_:function(t,e){let n=m$(t,"a","less"),r=m$(e,"b","less");return[n,r]=QP(n,r),gz(n.shape,r.shape),o$.runKernelFunc(t=>t.less(n,r),{a:n,b:r},null,"Less")}}),Jz=y$({lessEqual_:function(t,e){let n=m$(t,"a","lessEqual"),r=m$(e,"b","lessEqual");return[n,r]=QP(n,r),gz(n.shape,r.shape),o$.runKernelFunc((t,e)=>{const i=t.lessEqual(n,r);return e([n,r]),i},{a:n,b:r},null,"LessEqual")}});function Qz(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");return o$.runKernelFunc(r=>r.linspace(t,e,n),{},null,"LinSpace",{start:t,stop:e,num:n})}const tV=y$({localResponseNormalization_:function(t,e=5,n=1,r=1,i=.5){const s=m$(t,"x","localResponseNormalization");UF(4===s.rank||3===s.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${s.rank}.`),UF(KF(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=s,a=!1;3===s.rank&&(a=!0,o=I$(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const l=o$.runKernelFunc((t,s)=>{const a=t.localResponseNormalization4D(o,e,n,r,i);return s([o,a]),a},{x:o},null,"LRN",{depthRadius:e,bias:n,alpha:r,beta:i});return a?I$(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),eV=y$({log_:function(t){const e=m$(t,"x","log");return o$.runKernelFunc((t,n)=>{const r=t.log(e);return n([e]),r},{x:e},null,"Log")}}),nV=y$({log1p_:function(t){const e=m$(t,"x","log1p");return o$.runKernelFunc((t,n)=>{const r=t.log1p(e);return n([e]),r},{x:e},null,IL)}});function rV(t){return o$.customGrad(t)}const iV=y$({neg_:function(t){const e=m$(t,"x","neg");return o$.runKernelFunc(t=>t.neg(e),{x:e},null,zL)}}),sV=y$({softplus_:function(t){const e=m$(t,"x","softplus");return o$.runKernelFunc((t,n)=>{const r=t.softplus(e);return n([e]),r},{x:e},null,cF)}}),oV=y$({logSigmoid_:function(t){const e=m$(t,"x","logSigmoid");return rV(t=>({value:iV(sV(iV(t))),gradFunc:e=>yB(e,vB(iV(t)))}))(e)}}),aV=y$({max_:function(t,e=null,n=!1){const r=m$(t,"x","max");return o$.runKernelFunc((t,i)=>{let s=nP(e,r.shape);const o=M$(s,r.rank);let a=r;null!=o&&(a=N$(r,o),s=R$(s.length,a.rank));const l=t.max(a,s);null!=o&&a.dispose();let c=l;if(n){const t=T$(c.shape,nP(e,r.shape));c=I$(c,t),l.dispose()}return i([r,c]),c},{x:r},null,OL,{reductionIndices:e,keepDims:n})}}),lV=y$({sub_:function(t,e){let n=m$(t,"a","sub"),r=m$(e,"b","sub");return[n,r]=QP(n,r),o$.runKernelFunc((t,e)=>{const i=t.subtract(n,r);return e([n,r]),i},{a:n,b:r},null,"Sub")}}),cV=y$({sum_:function(t,e=null,n=!1){let r=m$(t,"x","sum");return"bool"===r.dtype&&(r=U$(r,"int32")),o$.runKernelFunc((t,i)=>{i([r]);const s=nP(e,r.shape),o=M$(s,r.rank);let a=s,l=r;null!=o&&(l=N$(r,o),a=R$(a.length,r.rank));let c=t.sum(l,a);if(n){const t=T$(c.shape,s);c=I$(c,t)}return c},{x:r},null,"Sum",{axis:e,keepDims:n})}}),uV=y$({logSoftmax_:function(t,e=-1){const n=m$(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return o$.runKernelFunc((n,r)=>{const i=aV(t,e,!0),s=lV(t,i),o=lV(U$(s,"float32"),eV(cV(Ez(s),e,!0)));return r([o]),o},{logits:n},null,NL,{axis:e})}}),hV=y$({logSumExp_:function(t,e=null,n=!1){const r=m$(t,"x","logSumExp"),i=nP(e,r.shape),s=aV(r,i,!0),o=lV(r,s),a=Ez(o),l=cV(a,i),c=eV(l),u=x$(I$(s,c.shape),c);if(n){const t=T$(u.shape,i);return I$(u,t)}return u}}),dV=y$({logicalAnd_:function(t,e){const n=m$(t,"a","logicalAnd","bool"),r=m$(e,"b","logicalAnd","bool");return gz(n.shape,r.shape),o$.runKernelFunc(t=>t.logicalAnd(n,r),{a:n,b:r},null,"LogicalAnd")}}),pV=y$({logicalNot_:function(t){const e=m$(t,"x","logicalNot","bool");return o$.runKernelFunc(t=>t.logicalNot(e),{x:e},null,"LogicalNot")}}),fV=y$({logicalOr_:function(t,e){const n=m$(t,"a","logicalOr","bool"),r=m$(e,"b","logicalOr","bool");return gz(n.shape,r.shape),o$.runKernelFunc(t=>t.logicalOr(n,r),{a:n,b:r},null,"LogicalOr")}}),mV=y$({logicalXor_:function(t,e){const n=m$(t,"a","logicalXor","bool"),r=m$(e,"b","logicalXor","bool");return gz(n.shape,r.shape),dV(fV(t,e),pV(dV(t,e)))}}),gV=y$({maxPool_:function(t,e,n,r,i){const s=m$(t,"x","maxPool");let o=s,a=!1;3===s.rank&&(a=!0,o=I$(s,[1,s.shape[0],s.shape[1],s.shape[2]])),UF(4===o.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),UF(tB(n,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`),null!=i&&UF(KF(r),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`);const l=o$.runKernelFunc((t,s)=>{const a=W$(o.shape,e,n,1,r,i);let l;return l=1===a.filterWidth&&1===a.filterHeight&&XF(a.inShape,a.outShape)?o.clone():t.maxPool(o,a),s([o,l]),l},{x:o},null,LL,{filterSize:e,strides:n,pad:r,dimRoundingMode:i});return a?I$(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),yV=y$({maxPool3d_:function(t,e=[1,1,1],n,r,i,s="NDHWC",o){null==o?o=[1,1,1]:rB("dilations is deprecated, this field will be gone in v3.0.0.");const a=m$(t,"x","maxPool3d");let l=a,c=!1;4===a.rank&&(c=!0,l=I$(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),UF(5===l.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${l.rank}.`),UF("NDHWC"===s,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),UF(tB(n,o),()=>`Error in maxPool3d: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),null!=i&&UF(KF(r),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`);const u=o$.runKernelFunc((t,a)=>{null==o&&(o=[1,1,1]);const c=j$(l.shape,e,n,o,r,i,s),u=t.maxPool3d(l,c);return a([l,u]),u},{x:l},null,FL,{filterSize:e,strides:n,pad:r,dimRoundingMode:i,dataFormat:s,dilations:o});return c?I$(u,[u.shape[1],u.shape[2],u.shape[3],u.shape[4]]):u}}),vV=y$({maxPoolWithArgmax_:function(t,e,n,r,i=!1){const s=m$(t,"x","maxPoolWithArgmax"),o=o$.runKernel(PL,{x:s},{filterSize:e,strides:n,pad:r,includeBatchInIndex:i});return{result:o[0],indexes:o[1]}}});function bV(t,e="float32"){if("complex64"===e){const e=bV(t,"float32"),n=bV(t,"float32");return qB(e,n)}const n=SP(GF(t),e);return o$.makeTensor(n,t,e)}function _V(t,e="float32"){if("complex64"===e){const e=_V(t,"float32"),n=bV(t,"float32");return qB(e,n)}const n=wP(GF(t),e);return o$.makeTensor(n,t,e)}const xV=y$({mean_:function(t,e=null,n=!1){const r=m$(t,"x","mean"),i=nP(e,r.shape),s=GF(C$(r.shape,i)[1]);return rV(t=>{const r=Wz(s),o=r.dtype===t.dtype?t:U$(t,r.dtype),a=pz(o,r);return{value:cV(a,e,n),gradFunc:e=>{const n=t.shape.slice();i.forEach(t=>{n[t]=1});const r=I$(e,n);return pz(yB(r,_V(t.shape,"float32")),s)}}})(r)}}),wV=y$({min_:function(t,e=null,n=!1){const r=m$(t,"x","min");return o$.runKernelFunc((t,i)=>{const s=nP(e,r.shape);let o=s;const a=M$(o,r.rank);let l=r;null!=a&&(l=N$(r,a),o=R$(o.length,r.rank));const c=t.min(l,o);null!=a&&l.dispose();let u=c;if(n){const t=T$(u.shape,s);u=I$(c,t),c.dispose()}return i([r,u]),u},{x:r},null,"Min",{axis:e,keepDims:n})}}),SV=y$({minimum_:function(t,e){let n=m$(t,"a","minimum"),r=m$(e,"b","minimum");return[n,r]=QP(n,r),"bool"===n.dtype&&(n=U$(n,"int32"),r=U$(r,"int32")),gz(n.shape,r.shape),o$.runKernelFunc((t,e)=>{const i=t.minimum(n,r);return e([n,r]),i},{a:n,b:r},null,$L)}}),EV=y$({mod_:function(t,e){let n=m$(t,"a","mod"),r=m$(e,"b","mod");return[n,r]=QP(n,r),o$.runKernelFunc((t,e)=>{const i=t.mod(n,r);return e([n,r]),i},{a:n,b:r},null,"Mod")}}),CV=y$({square_:function(t){const e=m$(t,"x","square");return o$.runKernelFunc((t,n)=>(n([e]),t.square(e)),{x:e},null,"Square",{},[e],[])}}),TV=y$({moments_:function(t,e=null,n=!1){const r=nP(e,(t=m$(t,"x","moments")).shape),i=xV(t,r,n);let s=i.shape;n||(s=T$(i.shape,r));const o=CV(lV(U$(t,"float32"),I$(i,s)));return{mean:i,variance:xV(o,r,n)}}}),AV=y$({multiRNNCell_:function(t,e,n,r){const i=m$(e,"data","multiRNNCell"),s=g$(n,"c","multiRNNCell"),o=g$(r,"h","multiRNNCell");let a=i;const l=[];for(let h=0;h<t.length;h++){const e=t[h](a,s[h],o[h]);l.push(e[0]),l.push(e[1]),a=e[1]}const c=[],u=[];for(let h=0;h<l.length;h+=2)c.push(l[h]),u.push(l[h+1]);return[c,u]}}),MV=y$({multinomial_:function(t,e,n,r=!1){const i=m$(t,"logits","multinomial"),s=i.size,o=i.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);n=n||Math.random();const a=1===o?I$(i,[1,-1]):i,l=o$.runKernelFunc(t=>t.multinomial(a,r,e,n),{logits2D:a});return 1===o?I$(l,[l.size]):l}}),kV=y$({notEqual_:function(t,e){let n=m$(t,"a","notEqual"),r=m$(e,"b","notEqual");return[n,r]=QP(n,r),gz(n.shape,r.shape),o$.runKernelFunc(t=>t.notEqual(n,r),{a:n,b:r},null,"NotEqual")}}),RV=y$({oneHot_:function(t,e,n=1,r=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const i=m$(t,"indices","oneHot","int32"),s=[...i.shape,e];return o$.runKernelFunc((t,o)=>(o([i]),I$(t.oneHot(I$(i,[i.size]),e,n,r),s)),{indices:i},null,jL,{depth:e,onValue:n,offValue:r})}}),IV=y$({onesLike_:function(t){const e=m$(t,"x","onesLike");return o$.runKernelFunc((t,n)=>{if("complex64"===e.dtype){const t=IV(Uz(e)),n=bz(Vz(e));return qB(t,n)}return t.onesLike(e)},{x:e},null,WL)}}),NV=y$({outerProduct_:function(t,e){const n=m$(t,"v1","outerProduct"),r=m$(e,"v2","outerProduct");UF(1===n.rank&&1===r.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);const i=I$(n,[-1,1]),s=I$(r,[1,-1]);return gB(i,s)}}),OV=y$({pad_:function(t,e,n=0){const r=m$(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return o$.runKernelFunc((t,i)=>(i([r]),t.pad(r,e,n)),{x:r},null,GL,{paddings:e,constantValue:n})}}),DV=y$({pad1d_:function(t,e,n=0){return UF(2===e.length,()=>"Invalid number of paddings. Must be length of 2."),OV(t,[e],n)}}),LV=y$({pad2d_:function(t,e,n=0){return UF(2===e.length&&2===e[0].length&&2===e[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),OV(t,e,n)}}),FV=y$({pad3d_:function(t,e,n=0){return UF(3===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),OV(t,e,n)}}),PV=y$({pad4d_:function(t,e,n=0){return UF(4===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length&&2===e[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),OV(t,e,n)}}),$V=y$({spaceToBatchND_:function(t,e,n){const r=m$(t,"x","spaceToBatchND");return UF(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),UF(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),UF(r.shape.reduce((t,r,i)=>i>0&&i<=e.length?t&&(r+n[i-1][0]+n[i-1][1])%e[i-1]==0:t,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`),o$.runKernelFunc(t=>t.spaceToBatchND(r,e,n),{x:r},null,hF,{blockShape:e,paddings:n})}}),BV=y$({pool_:function(t,e,n,r,i,s){null==i&&(i=[1,1]),null==s&&(s=1),0===r&&(r="valid");const o=m$(t,"x","maxPool");let a=o,l=!1;3===o.rank&&(l=!0,a=I$(o,[1,o.shape[0],o.shape[1],o.shape[2]])),UF(tB(s,i),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${i}'`);const c=W$(a.shape,e,s,i,r),u=[c.dilationHeight,c.dilationWidth];let h;h="same"===r?function(t,e){const n=t.map((t,n)=>t+(t-1)*(e[n]-1)).map(t=>t-1),r=n.map(t=>Math.floor(t/2)),i=n.map((t,e)=>t-r[e]);return n.map((t,e)=>[r[e],i[e]])}([c.filterHeight,c.filterWidth],u):[[0,0],[0,0]];const d=1===u[0]&&1===u[1],[p,f]=function(t,e,n){const r=n.map(t=>t[0]),i=n.map(t=>t[1]),s=t.concat(r,i),o=e.map((t,e)=>(t-s[e]%t)%t),a=i.map((t,e)=>t+o[e]);return[e.map((t,e)=>[r[e],a[e]]),e.map((t,e)=>[0,o[e]])]}([c.inHeight,c.inWidth],u,h),m=d?r:"valid",g=d?a:$V(a,u,p),y=("avg"===n?()=>nB(g,e,s,m):()=>gV(g,e,s,m))(),v=d?y:FB(y,u,f);return l?I$(v,[v.shape[1],v.shape[2],v.shape[3]]):v}}),zV=y$({pow_:function(t,e){let n=m$(t,"base","pow"),r=m$(e,"exp","pow");return[n,r]=QP(n,r),o$.runKernelFunc((t,e)=>{const i=t.pow(n,r);return e([n,r,i]),i},{a:n,b:r},null,"Pow")}}),VV=y$({prelu_:function(t,e){const n=m$(t,"x","prelu"),r=m$(e,"alpha","prelu");return o$.runKernelFunc((t,e)=>{const i=t.prelu(n,r);return e([n,r]),i},{x:n,alpha:r},null,qL)}});function UV(t,e=!1){console.log(t.toString(e))}const HV=y$({prod_:function(t,e=null,n=!1){let r=m$(t,"x","prod");return o$.runKernelFunc(t=>{"bool"===r.dtype&&(r=U$(r,"int32"));const i=nP(e,r.shape),s=M$(i,r.rank);let o=i,a=r;null!=s&&(a=N$(r,s),o=R$(o.length,r.rank));let l=t.prod(a,o);if(n){const t=T$(l.shape,i);l=I$(l,t)}return l},{x:r},null,"Prod",{axis:e,keepDims:n})}}),WV=y$({rand_:function(t,e,n){const r=GF(t);let i=null;if(null==n||"float32"===n)i=new Float32Array(r);else if("int32"===n)i=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);i=new Uint8Array(r)}for(let s=0;s<r;s++)i[s]=e();return o$.makeTensor(i,t,n)}});var jV=n("YSVl");class GV{constructor(t,e,n,r,i){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=i||Math.random();this.random=jV.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let r,i,s;do{r=2*this.random()-1,i=2*this.random()-1,s=r*r+i*i}while(s>=1||0===s);const o=Math.sqrt(-2*Math.log(s)/s);t=this.mean+this.stdDev*r*o,e=this.mean+this.stdDev*i*o,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class qV{constructor(t,e,n,r){this.alpha=t,this.beta=1/e,this.dtype=n;const i=r||Math.random();this.randu=jV.alea(i.toString()),this.randn=new GV(0,1,n,!1,this.randu()),this.d=t<1?t+2/3:t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,n,r,i,s;for(;;){do{r=this.randn.nextValue(),s=1+this.c*r}while(s<=0);if(s*=s*s,t=r*r,e=1-.331*t*t,n=.5*t+this.d*(1-s+Math.log(s)),i=this.randu(),i<e||Math.log(i)<n)break}return s*=1/this.beta*this.d,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(t){return"float32"===this.dtype?t:Math.round(t)}}class XV{constructor(t=0,e=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=jV.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const KV=y$({randomGamma_:function(t,e,n=1,r="float32",i){if(null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const s=new qV(e,n,r,i),o=WB(t,r);for(let a=0;a<o.values.length;a++)o.values[a]=s.nextValue();return o.toTensor()}}),YV=y$({randomNormal_:function(t,e=0,n=1,r,i){if(null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const s=new GV(e,n,r,!1,i),o=WB(t,r);for(let a=0;a<o.values.length;a++)o.values[a]=s.nextValue();return o.toTensor()}}),ZV=y$({randomUniform_:function(t,e=0,n=1,r="float32",i){const s=WB(t,r),o=new XV(e,n,null,i);for(let a=0;a<s.values.length;a++)s.values[a]=o.nextValue();return s.toTensor()}});function JV(t,e){WF(t);const n=d$(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return pB(t,null,n,e)}function QV(t,e,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");return o$.runKernelFunc(()=>{if(t===e||t<e&&n<0||e<t&&n>1)return bV([0],r);const i=SP(Math.abs(Math.ceil((e-t)/n)),r);e<t&&1===n&&(n=-1),i[0]=t;for(let t=1;t<i.length;t++)i[t]=i[t-1]+n;return JV(i,r)},{},null,"Range",{start:t,stop:e,step:n,dtype:r})}const tU=y$({reciprocal_:function(t){const e=m$(t,"x","reciprocal");return o$.runKernelFunc((t,n)=>{const r=t.reciprocal(e);return n([e]),r},{x:e},null,XL)}}),eU=y$({relu_:function(t){const e=m$(t,"x","relu");return o$.runKernelFunc((t,n)=>(n([e]),"bool"===e.dtype?U$(e,"int32"):t.relu(e)),{x:e},null,KL)}}),nU=y$({relu6_:function(t){const e=m$(t,"x","relu6");return o$.runKernelFunc((t,n)=>(n([e]),"bool"===e.dtype?U$(e,"int32"):t.relu6(e)),{x:e},null,QL)}}),rU=y$({reverse1d_:function(t){const e=m$(t,"x","reverse");return UF(1===e.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Hz(e,0)}}),iU=y$({reverse2d_:function(t,e){const n=m$(t,"x","reverse");return UF(2===n.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),Hz(n,e)}}),sU=y$({reverse3d_:function(t,e){const n=m$(t,"x","reverse");return UF(3===n.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),Hz(n,e)}}),oU=y$({reverse4d_:function(t,e){const n=m$(t,"x","reverse");return UF(4===n.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),Hz(n,e)}});function aU(t,e,n=0){let r=[];if("number"==typeof e)UF(t.shape[n]%e==0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(t.shape[n]/e);else{UF(e.reduce((t,e)=>(-1===e&&(t+=1),t),0)<=1,()=>"There should be only one negative value in split array.");const i=e.indexOf(-1);if(-1!==i){const r=e.reduce((t,e)=>e>0?t+e:t);e[i]=t.shape[n]-r}UF(t.shape[n]===e.reduce((t,e)=>t+e),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}const lU=y$({split_:function(t,e,n=0){const r=m$(t,"x","split");return o$.runKernelFunc((t,i)=>{const s=nP(n,r.shape)[0],o=aU(r,e,s);return t.split(r,o,s)},{x:r},null,dF,{numOrSizeSplits:e,axis:n})}}),cU=y$({rfft_:function(t,e){UF("float32"===t.dtype,()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const r=t.size/n;let i;if(null!=e&&e<n){const r=t.shape.map(t=>0),s=t.shape.map(t=>t);s[t.shape.length-1]=e,i=OB(t,r,s),n=e}else if(null!=e&&e>n){const r=t.shape.map(t=>t);r[t.shape.length-1]=e-n,i=mB([t,bV(r)],t.shape.length-1),n=e}else i=t;const s=bz(i),o=I$(qB(i,s),[r,n]),a=kz(o),l=Math.floor(n/2)+1,c=Uz(a),u=Vz(a),h=lU(c,[l,n-l],c.shape.length-1),d=lU(u,[l,n-l],u.shape.length-1),p=i.shape.slice();return p[i.shape.length-1]=l,I$(qB(h[0],d[0]),p)}}),uU=y$({round_:function(t){const e=m$(t,"x","round");return o$.runKernelFunc(t=>t.round(e),{x:e},null,eF)}}),hU=y$({rsqrt_:function(t){const e=m$(t,"x","rsqrt");return o$.runKernelFunc((t,n)=>{const r=t.rsqrt(e);return n([e]),r},{x:e},null,nF)}}),dU=y$({selu_:function(t){const e=m$(t,"x","selu");return o$.runKernelFunc((t,n)=>{const r=t.selu(e);return n([e]),r},{x:e},null,iF)}}),pU=y$({separableConv2d_:function(t,e,n,r,i,s=[1,1],o="NHWC"){const a=m$(t,"x","separableConv2d"),l=m$(e,"depthwiseFilter","separableConv2d"),c=m$(n,"pointwiseFilter","separableConv2d");let u=a,h=!1;if(3===a.rank&&(h=!0,u=I$(a,[1,a.shape[0],a.shape[1],a.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");UF(4===u.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),UF(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),UF(4===c.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),UF(1===c.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),UF(1===c.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const d=l.shape[2],p=l.shape[3];UF(c.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${c.shape[2]}.`);const f=cz(u,l,r,i,o,s),m=JB(f,c,1,"valid",o);return h?I$(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),fU=async function(t,e){const n=m$(t,"x","setdiff1d"),r=m$(e,"y","setdiff1d");UF(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),UF(1===n.rank,()=>`x should be 1D tensor, but got x (${n.shape}).`),UF(1===r.rank,()=>`y should be 1D tensor, but got y (${r.shape}).`);const i=await n.data(),s=await r.data(),o=new Set(s);let a=0;for(let u=0;u<i.length;u++)o.has(i[u])||a++;const l=new BP([a],n.dtype),c=new BP([a],"int32");for(let u=0,h=0;u<i.length;u++)o.has(i[u])||(l.values[h]=i[u],c.values[h]=u,h++);return[l.toTensor(),c.toTensor()]},mU=y$({sign_:function(t){const e=m$(t,"x","sign");return o$.runKernelFunc(t=>t.sign(e),{x:e},null,aF)}}),gU=y$({sin_:function(t){const e=m$(t,"x","sin");return o$.runKernelFunc((t,n)=>{const r=t.sin(e);return n([e]),r},{x:e},null,"Sin")}}),yU=y$({sinh_:function(t){const e=m$(t,"x","sinh");return o$.runKernelFunc((t,n)=>{const r=t.sinh(e);return n([e]),r},{x:e},null,oF)}}),vU=y$({slice1d_:function(t,e,n){const r=m$(t,"x","slice1d");return UF(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),OB(r,[e],[n])}}),bU=y$({slice2d_:function(t,e,n){const r=m$(t,"x","slice2d");return UF(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),OB(r,e,n)}}),_U=y$({slice3d_:function(t,e,n){const r=m$(t,"x","slice3d");return UF(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),OB(r,e,n)}}),xU=y$({slice4d_:function(t,e,n){const r=m$(t,"x","slice4d");return UF(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),OB(r,e,n)}}),wU=y$({softmax_:function(t,e=-1){const n=m$(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);return o$.runKernelFunc((t,r)=>{const i=t.softmax(n,e);return r([i]),i},{logits:n},null,pF,{dim:e})}}),SU=y$({sqrt_:function(t){const e=m$(t,"x","sqrt");return o$.runKernelFunc((t,n)=>{const r=t.sqrt(e);return n([e]),r},{x:e},null,uF)}}),EU=y$({squaredDifference_:function(t,e){let n=m$(t,"a","squaredDifference"),r=m$(e,"b","squaredDifference");return[n,r]=QP(n,r),gz(n.shape,r.shape),o$.runKernelFunc((t,e)=>{const i=t.squaredDifference(n,r);return e([n,r]),i},{a:n,b:r},null,fF,{})}}),CU=y$({squeeze_:function(t,e){const n=m$(t,"x","squeeze");return I$(n,rP(n.shape,e).newShape)}}),TU=y$({stack_:function(t,e=0){const n=g$(t,"tensors","stack");if(UF(n.length>=1,()=>"Pass at least one tensor to tf.stack"),1===n.length)return Cz(n[0],e);const r=n[0].shape,i=n[0].dtype;UF(e<=n[0].rank,()=>"Axis must be <= rank of the tensor"),n.forEach(t=>{HF(r,t.shape,"All tensors passed to stack must have matching shapes"),UF(i===t.dtype,()=>"All tensors passed to stack must have matching dtypes")});const s=n.map(t=>Cz(t,e));return mB(s,e)}}),AU=y$({step_:function(t,e=0){const n=m$(t,"x","step");return o$.runKernelFunc(t=>t.step(n,e),{x:n},null,wF,{alpha:e})}}),MU=y$({stridedSlice_:function(t,e,n,r,i=0,s=0,o=0,a=0,l=0){null==r&&(r=new Array(e.length));let c=m$(t,"x","stridedSlice");return o$.runKernelFunc(t=>{const u=_B(o);if(u.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==o&&0!==a)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==o&&0!==l)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const h=c.rank-e.length,d=_B(a),p=c.shape.slice();if(d.forEach(t=>{e[t]=0,n[t]=1,p.splice(t,0,1)}),c=I$(c,p),u.length&&h>0){const t=u[0],o=h+1;e=CB(i,t,o,e,c.shape),n=TB(s,t,o,n,c.shape),r=wB(r,t,o,c.shape)}else for(let a=0;a<c.rank;a++)e[a]=MB(i,e,r,c.shape,a,o),n[a]=kB(s,n,r,c.shape,a,o),r[a]=AB(r,a,o);const f=_B(l);f.forEach(t=>{n[t]=e[t]+1,r[t]=1});const m=xB(e,n,r),g=m.filter((t,e)=>-1===f.indexOf(e));if(r.every(t=>1===t))return I$(OB(c,e,m),g);const y=t.stridedSlice(c,e,n,r);return I$(y,g)},{x:c},null,"StridedSlice",{begin:e,end:n,strides:r,beginMask:i,endMask:s,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l})}}),kU=y$({tan_:function(t){const e=m$(t,"x","tan");return o$.runKernelFunc((t,n)=>{const r=t.tan(e);return n([e]),r},{x:e},null,"Tan")}});function RU(t,e,n){if(WF(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const r=d$(t,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return pB(t,e,r,n)}function IU(t,e,n){if(WF(t),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");const r=d$(t,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return pB(t,e,r,n)}function NU(t,e,n){if(WF(t),null!=e&&4!==e.length)throw new Error("tensor4d() requires shape to have four numbers");const r=d$(t,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return pB(t,e,r,n)}function OU(t,e,n){if(WF(t),null!=e&&5!==e.length)throw new Error("tensor5d() requires shape to have five numbers");const r=d$(t,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return pB(t,e,r,n)}function DU(t,e,n){if(WF(t),null!=e&&6!==e.length)throw new Error("tensor6d() requires shape to have six numbers");const r=d$(t,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return pB(t,e=e||r,r,n)}const LU=y$({topk_:function(t,e=1,n=!0){const r=m$(t,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const i=r.shape[r.shape.length-1];if(e>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${e}`);const s={x:r},o={k:e,sorted:n},[a,l]=o$.runKernelFunc(t=>t.topk(r,e,n),s,null,"TopK",o);return{values:a,indices:l}}}),FU=y$({truncatedNormal_:function(t,e=0,n=1,r,i){if(null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const s=new GV(e,n,r,!0,i),o=WB(t,r);for(let a=0;a<o.values.length;a++)o.values[a]=s.nextValue();return o.toTensor()}}),PU=y$({unsortedSegmentSum_:function(t,e,n){const r=m$(t,"x","unsortedSegmentSum"),i=m$(e,"segmentIds","unsortedSegmentSum","int32");return UF(KF(n),()=>"numSegments must be of dtype int"),o$.runKernelFunc((t,e)=>{const s=t.unsortedSegmentSum(r,i,n);return e([i]),s},{x:r,segmentIds:i},null,_F,{numSegments:n})}}),$U=y$({unstack_:function(t,e=0){const n=m$(t,"x","unstack");return UF(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`),e<0&&(e+=n.shape.length),o$.runKernelFunc(t=>t.unstack(n,e),{value:n},null,bF,{axis:e})}});function BU(t,e=!0,n,r){return o$.makeVariable(t,e,n,r)}function zU(t,e){const n=[];for(let s=0;s<e.length;s++)e[s]&&n.push(s);const r=WB(t,"int32"),i=WB([n.length,t.length],"int32");for(let s=0;s<n.length;s++){const e=r.indexToLoc(n[s]);i.values.set(e,s*t.length)}return i.toTensor()}const VU=async function(t){const e=m$(t,"condition","whereAsync","bool"),n=await e.data(),r=zU(e.shape,n);return t!==e&&e.dispose(),r},UU=async function(t,e,n){const r=m$(t,"tensor","boolMask"),i=m$(e,"mask","boolMask","bool"),s=null==n?0:n,o=i.rank,a=r.shape;UF(o>0,()=>"mask cannot be scalar"),HF(a.slice(s,s+o),i.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=s;m<s+o;m++)l*=a[m];const c=a.slice(0,s).concat([l],a.slice(s+o)),u=I$(r,c),h=I$(i,[-1]),d=await VU(h),p=CU(d,[1]),f=Pz(u,p,s);return t!==r&&r.dispose(),e!==i&&i.dispose(),p.dispose(),u.dispose(),h.dispose(),d.dispose(),f},HU=y$({equalStrict_:function(t,e){rB("strict variants of ops have been deprecated and will be removed in future");const n=m$(t,"a","equalStrict"),r=m$(e,"b","equalStrict");return HF(n.shape,r.shape,"Error in equalStrict: "),yz(n,r)}}),WU=y$({greaterEqualStrict_:function(t,e){rB("strict variants of ops have been deprecated and will be removed in future");const n=m$(t,"a","greaterEqualStrict"),r=m$(e,"b","greaterEqualStrict");return HF(n.shape,r.shape,"Error in greaterEqualStrict: "),Bz(n,r)}}),jU=y$({greaterStrict_:function(t,e){rB("strict variants of ops have been deprecated and will be removed in future");const n=m$(t,"a","greaterStrict"),r=m$(e,"b","greaterStrict");return HF(n.shape,r.shape,"Error in greaterStrict: "),$z(n,r)}}),GU=y$({lessEqualStrict_:function(t,e){rB("strict variants of ops have been deprecated and will be removed in future");const n=m$(t,"a","lessEqualStrict"),r=m$(e,"b","lessEqualStrict");return HF(n.shape,r.shape,"Error in lessEqualStrict: "),Jz(n,r)}}),qU=y$({lessStrict_:function(t,e){rB("strict variants of ops have been deprecated and will be removed in future");const n=m$(t,"a","lessStrict"),r=m$(e,"b","lessStrict");return HF(n.shape,r.shape,"Error in lessStrict: "),Zz(n,r)}}),XU=y$({notEqualStrict_:function(t,e){rB("strict variants of ops have been deprecated and will be removed in future");const n=m$(t,"a","notEqualStrict"),r=m$(e,"b","notEqualStrict");return HF(n.shape,r.shape,"Error in notEqualStrict: "),kV(n,r)}}),KU=y$({addStrict_:function(t,e){rB("strict variants of ops have been deprecated and will be removed in future");const n=m$(t,"a","addStrict"),r=m$(e,"b","addStrict");return HF(n.shape,r.shape,"Error in addStrict: "),x$(n,r)}}),YU=y$({divStrict_:function(t,e){rB("strict variants of ops have been deprecated and will be removed in future");const n=m$(t,"a","div"),r=m$(e,"b","div");return HF(n.shape,r.shape,"Error in divideStrict: "),pz(n,r)}}),ZU=y$({maximumStrict_:function(t,e){rB("strict variants of ops have been deprecated and will be removed in future");const n=m$(t,"a","maximumStrict"),r=m$(e,"b","maximumStrict");return HF(n.shape,r.shape,"Error in maximumStrict: "),Kz(n,r)}}),JU=y$({minimumStrict_:function(t,e){rB("strict variants of ops have been deprecated and will be removed in future");const n=m$(t,"a","minimumStrict"),r=m$(e,"b","minimumStrict");return HF(n.shape,r.shape,"Error in minimumStrict: "),SV(n,r)}}),QU=y$({modStrict_:function(t,e){rB("strict variants of ops have been deprecated and will be removed in future");const n=m$(t,"a","modStrict"),r=m$(e,"b","modStrict");return HF(n.shape,r.shape,"Error in modStrict: "),EV(n,r)}}),tH=y$({mulStrict_:function(t,e){rB("strict variants of ops have been deprecated and will be removed in future");const n=m$(t,"a","mul"),r=m$(e,"b","mul");return HF(n.shape,r.shape,"Error in multiplyStrict: "),yB(n,r)}}),eH=y$({powStrict_:function(t,e){return rB("strict variants of ops have been deprecated and will be removed in future"),HF(t.shape,e.shape,"Error in powStrict: "),zV(t,e)}}),nH=y$({squaredDifferenceStrict_:function(t,e){rB("strict variants of ops have been deprecated and will be removed in future");const n=m$(t,"a","squaredDifferenceStrict"),r=m$(e,"b","squaredDifferenceStrict");return HF(n.shape,r.shape,"Error in squaredDifferenceStrict: "),EU(n,r)}}),rH=y$({subStrict_:function(t,e){rB("strict variants of ops have been deprecated and will be removed in future");const n=m$(t,"a","subStrict"),r=m$(e,"b","subStrict");return HF(n.shape,r.shape,"Error in subStrict: "),lV(n,r)}});function iH(t,e,n=null){if(0===t.rank)return v$(t);if(1!==t.rank&&null===n)return iH(I$(t,[-1]),e,n);if(1===t.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===e)return cV(v$(t),n);if(e===1/0)return aV(v$(t),n);if(e===-1/0)return wV(v$(t),n);if("euclidean"===e||2===e)return SU(cV(zV(v$(t),Wz(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&2===n.length){if(1===e)return aV(cV(v$(t),n[0]),n[1]-1);if(e===1/0)return aV(cV(v$(t),n[1]),n[0]);if(e===-1/0)return wV(cV(v$(t),n[1]),n[0]);if("fro"===e||"euclidean"===e)return SU(cV(CV(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const sH=y$({norm_:function(t,e="euclidean",n=null,r=!1){const i=iH(t=m$(t,"x","norm"),e,n);let s=i.shape;if(r){const e=nP(n,t.shape);s=T$(i.shape,e)}return I$(i,s)}}),oH=y$({movingAverage_:function(t,e,n,r,i=!0){const s=m$(t,"v","movingAverage"),o=m$(e,"x","movingAverage"),a=m$(n,"decay","movingAverage");t$(s,o),UF(XF(s.shape,o.shape),()=>"Shape mismatch in v and x");const l=Wz(1),c=lV(l,a);let u=yB(lV(o,s),c);if(i){UF(null!=r,()=>"When using zeroDebias: true, step is required.");const t=m$(r,"step","movingAverage");u=pz(u,lV(l,zV(a,t)))}return x$(s,u)}});function aH(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,i=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${i}.`;if(n.rank<i)throw new Error(s+` update.rank < ${i}. `);if(t.length<r+(n.rank-i))throw new Error(s+` Output shape length < ${r+(n.rank-i)}`);if(n.rank!==i+t.length-r)throw new Error(s+" update.rank != "+(i+t.length-r));for(let o=0;o<i;++o)if(n.shape[o]!==e.shape[o])throw new Error(s+` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<n.rank-i;++o)if(n.shape[o+i]!==t[o+r])throw new Error(s+` updates.shape[${o+i}] (${n.shape[o+i]}) != shape[${o+i}] (${t[o+i]})`)}function lH(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==e.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===e.size)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(0===t.size)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}aH(n,e,t)}function cH(t,e,n){const r=e.shape.length,i=r>1?e.shape[r-1]:1,s=n.length;let o=1;for(let l=i;l<s;++l)o*=n[l];const a=i<1?1:i;return{sliceRank:i,numUpdates:GF(e.shape)/a,sliceSize:o,strides:[...vP(n.slice(0,i)),1],outputSize:GF(n)}}const uH=y$({scatterND_:function(t,e,n){const r=m$(t,"indices","scatterND","int32"),i=m$(e,"updates","scatterND");return lH(i,r,n),o$.runKernelFunc(t=>t.scatterND(r,i,n),{indices:r,updates:i},null,"ScatterNd",{shape:n})}}),hH=y$({sparseToDense_:function(t,e,n,r=0){const i=m$(t,"sparseIndices","sparseToDense","int32"),s=m$(e,"sparseValues","sparseToDense"),o=m$(r,"defaultValue","sparseToDense",s.dtype);return function(t,e,n,r){if("int32"!==t.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const i=t.rank>0?t.shape[0]:1,s=t.rank>1?t.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);if(0!==e.rank&&(1!==e.rank||e.size!==i))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${i}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(i,s,n,o),o$.runKernelFunc(t=>t.sparseToDense(i,s,n,o),{sparseIndices:i,sparseValues:s,defaultValue:o},null,"SparseToDense",{outputShape:n})}}),dH=y$({gatherND_:function(t,e){const n=m$(e,"indices","gatherND","int32"),r=m$(t,"x","gatherND");return o$.runKernelFunc(t=>t.gatherND(r,n),{params:r,indices:n},null,"GatherNd")}}),pH=y$({dropout_:function(t,e,n,r){const i=m$(t,"x","dropout");if(UF("float32"===i.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`),UF(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),0===e)return t instanceof HP?i.clone():i;const s=function(t,e){if(null==e)return t.shape.slice();if(XF(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)n.push(null==e[r]&&null!=t.shape[r]?t.shape[r]:e[r]);return n}return e}(i,n),o=1-e,a=pz(Iz(x$(ZV(s,0,1,"float32",r),o)),o);return yB(i,a)}});function fH(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function mH(t,e,n){const r=1-t%2,i=new Float32Array(t);for(let s=0;s<t;++s){const o=2*Math.PI*s/(t+r-1);i[s]=e-n*Math.cos(o)}return JV(i,"float32")}const gH=async function(t,e,n=1){const r=m$(t,"predictions","inTopK"),i=m$(e,"targets","inTopK");UF(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),UF(r.rank-1===i.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${i.rank}`),HF(r.shape.slice(0,r.shape.length-1),i.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const s=r.shape[r.shape.length-1];UF(n>0&&n<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`);const o=await r.data(),a=await i.data(),[l,c]=[o.length/s,s],u=iP("bool",l);for(let h=0;h<l;h++){const t=h*c,e=o.subarray(t,t+c),r=[];for(let n=0;n<e.length;n++)r.push({value:e[n],index:n});r.sort((t,e)=>e.value-t.value),u[h]=0;for(let i=0;i<n;i++)if(r[i].index===a[h]){u[h]=1;break}}return t!==r&&r.dispose(),e!==i&&i.dispose(),fB(u,i.shape,"bool")},yH=y$({conv2DBackpropFilter_:function(t,e,n,r,i,s="NHWC",o){let a=t;3===t.rank&&(a=I$(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=I$(e,[1,e.shape[0],e.shape[1],e.shape[2]])),UF(4===a.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),UF(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),UF(4===n.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const c="NHWC"===s?a.shape[3]:a.shape[1],u="NHWC"===s?l.shape[3]:l.shape[1];return UF(c===n[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${n[2]}.`),UF(u===n[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${n[3]}).`),null!=o&&UF(KF(i),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${o} but got pad ${i}.`),o$.runKernelFunc(t=>{const e=eB(s),c=G$(a.shape,n,r,1,i,o,!1,e);return t.conv2dDerFilter(a,l,c)},{x:a,dy:l},null,"Conv2DBackpropFilter",{strides:r,pad:i,dataFormat:s,dimRoundingMode:o})}});function vH(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return yB(t,AU(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function bH(t,e){let n=e;const r=mz(t.shape,e.shape);return r.length>0&&(n=cV(n,r)),I$(n,t.shape)}function _H(t,e,n){if("linear"===e)return t;if("relu"===e)return eU(t);if("elu"===e)return wz(t);if("relu6"===e)return nU(t);if("prelu"===e)return VV(t,n);throw new Error(`Unknown fused activation ${e}.`)}const xH=(t,e)=>!(t>0)||"linear"===e,wH=y$({fusedConv2d_:function({x:t,filter:e,strides:n,pad:r,dataFormat:i="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c}){if(!1===xH(o$.state.gradientDepth,l=l||"linear")){let u=JB(t,e,n,r,i,s,o);return null!=a&&(u=x$(u,a)),_H(u,l,c)}const u=m$(t,"x","conv2d"),h=m$(e,"filter","conv2d");let d=u,p=!1;3===u.rank&&(p=!0,d=I$(u,[1,u.shape[0],u.shape[1],u.shape[2]])),UF(4===d.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`),UF(4===h.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),null!=o&&UF(KF(r),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`),UF(d.shape[3]===h.shape[2],()=>`Error in conv2d: depth of input (${d.shape[3]}) must match input depth for filter ${h.shape[2]}.`),UF(tB(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),UF("NHWC"===i,()=>`Error in conv2d: got dataFormat of ${i} but only NHWC is currently supported.`);const f=G$(d.shape,h.shape,n,s,r,o);let m,g;null!=a&&(m=m$(a,"bias","fused conv2d"),[m]=QP(m,u),gz(f.outShape,m.shape)),null!=c&&(g=m$(c,"prelu weights","fused conv2d"));const y=(t,e)=>{const[i,o,a,c]=e,u=vH(t,a,l);UF(Q$(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const h=[tz(o.shape,u,i,n,r),yH(o,u,i.shape,n,r)];if(null!=c){const t=bH(c,u);h.push(t)}return h},v=t=>t.fusedConv2d({input:d,filter:h,convInfo:f,bias:m,activation:l,preluActivationWeights:g}),b={x:d,filter:h,bias:m,preluActivationWeights:g},_={strides:n,pad:r,dataFormat:i,dilations:s,dimRoundingMode:o,activation:l};return null==a?rV((t,e,n)=>{let r=o$.runKernelFunc(v,b,null,TF,_);return n([e,t,r]),p&&(r=I$(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:y}})(d,h):rV((t,e,n,r)=>{let i=o$.runKernelFunc(v,b,null,TF,_);return r([e,t,i,n]),p&&(i=I$(i,[i.shape[1],i.shape[2],i.shape[3]])),{value:i,gradFunc:y}})(d,h,m)}}),SH=y$({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,r){let i=t;3===t.rank&&(i=I$(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let s=e;return 3===s.rank&&(s=I$(e,[1,e.shape[0],e.shape[1],e.shape[2]])),o$.runKernelFunc(t=>t.depthwiseConv2DDerFilter(i,s,r),{x:i,dy:s},null,"DepthwiseConv2dNativeBackpropFilter")}}),EH=y$({depthwiseConv2dNativeBackpropInput_:function(t,e,n,r){let i=e,s=!1;3===e.rank&&(s=!0,i=I$(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const o=o$.runKernelFunc(t=>t.depthwiseConv2DDerInput(i,n,r),{dy:i},null,"DepthwiseConv2dNativeBackpropInput");return s?I$(o,[o.shape[1],o.shape[2],o.shape[3]]):o}}),CH=y$({fusedDepthwiseConv2d_:function({x:t,filter:e,strides:n,pad:r,dataFormat:i="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c}){if(!1===xH(o$.state.gradientDepth,l)){let u=cz(t,e,n,r,i,s,o);return null!=a&&(u=x$(u,a)),_H(u,l,c)}const u=m$(t,"x","depthwiseConv2d"),h=m$(e,"filter","depthwiseConv2d");let d=u,p=!1;3===u.rank&&(p=!0,d=I$(u,[1,u.shape[0],u.shape[1],u.shape[2]])),UF(4===d.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),UF(4===h.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),UF(d.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),null==s&&(s=[1,1]),UF(tB(n,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),null!=o&&UF(KF(r),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${o} but got pad ${r}.`);const f=G$(d.shape,h.shape,n,s,r,o,!0);let m,g;null!=a&&(m=m$(a,"bias","fused conv2d"),[m]=QP(m,u),gz(f.outShape,m.shape)),null!=c&&(g=m$(c,"prelu weights","fused depthwiseConv2d"));const y=(t,e)=>{UF(Q$(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);const[n,r,i,o]=e,a=vH(t,i,l),c=EH(r.shape,a,n,f),u=SH(r,a,n.shape,f);return null!=o?[c,u,bH(m,a)]:[c,u]},v=t=>t.fusedDepthwiseConv2D({input:d,filter:h,convInfo:f,bias:m,activation:l,preluActivationWeights:g}),b={x:d,filter:h,bias:m,preluActivationWeights:g},_={strides:n,pad:r,dataFormat:i,dilations:s,dimRoundingMode:o,activation:l};return null==a?rV((t,e,n)=>{let r=o$.runKernelFunc(v,b,null,AF,_);return n([e,t,r]),p&&(r=I$(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:y}})(d,h):rV((t,e,n,r)=>{let i=o$.runKernelFunc(v,b,null,AF,_);return r([e,t,i,n]),p&&(i=I$(i,[i.shape[1],i.shape[2],i.shape[3]])),{value:i,gradFunc:y}})(d,h,m)}}),TH=y$({fusedMatMul_:function({a:t,b:e,transposeA:n=!1,transposeB:r=!1,bias:i,activation:s="linear",preluActivationWeights:o}){if(!1===xH(o$.state.gradientDepth,s)){let a=gB(t,e,n,r);return null!=i&&(a=x$(a,i)),_H(a,s,o)}let a=m$(t,"a","fused matMul"),l=m$(e,"b","fused matMul");[a,l]=QP(a,l);const c=n?a.shape[a.rank-2]:a.shape[a.rank-1],u=r?l.shape[l.rank-1]:l.shape[l.rank-2],h=n?a.shape[a.rank-1]:a.shape[a.rank-2],d=r?l.shape[l.rank-2]:l.shape[l.rank-1],p=a.shape.slice(0,-2),f=l.shape.slice(0,-2),m=GF(p),g=GF(f);UF(a.rank>=2&&l.rank>=2&&a.rank===l.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${a.rank} and ${l.rank}.`),UF(XF(p,f),()=>`Error in fused matMul: outer dimensions (${p}) and (${f}) of Tensors with shapes ${a.shape} and ${l.shape} must match.`),UF(c===u,()=>`Error in fused matMul: inner shapes (${c}) and (${u}) of Tensors with shapes ${a.shape} and ${l.shape} and transposeA=${n} and transposeB=${r} must match.`);const y=a.shape.slice(0,-2).concat([h,d]),v=I$(a,n?[m,c,h]:[m,h,c]),b=I$(l,r?[g,d,u]:[g,u,d]);let _,x;null!=i&&(_=m$(i,"bias","fused matMul"),[_]=QP(_,a),gz(y,_.shape)),null!=o&&(x=m$(o,"prelu weights","fused matMul"));const w=(t,e)=>{const[o,a,l,c]=e,u=vH(I$(t,l.shape),l,s);let h,d;return n||r?!n&&r?(h=gB(u,a,!1,!1),d=gB(u,o,!0,!1)):n&&!r?(h=gB(a,u,!1,!0),d=gB(o,u,!1,!1)):(h=gB(a,u,!0,!0),d=gB(u,o,!0,!0)):(h=gB(u,a,!1,!0),d=gB(o,u,!0,!1)),null!=i?[h,d,bH(c,u)]:[h,d]},S=t=>t.fusedBatchMatMul({a:v,b:b,transposeA:n,transposeB:r,bias:_,activation:s,preluActivationWeights:x}),E={a:v,b:b,bias:_,preluActivationWeights:x},C={transposeA:n,transposeB:r,activation:s};return null==i?rV((t,e,n)=>{const r=o$.runKernelFunc(S,E,null,CF,C);return n([t,e,r]),{value:I$(r,y),gradFunc:w}})(v,b):rV((t,e,n,r)=>{const i=o$.runKernelFunc(S,E,null,CF,C);return r([t,e,i,n]),{value:I$(i,y),gradFunc:w}})(v,b,_)}}),AH=y$({hammingWindow_:function(t){return mH(t,.54,.46)}}),MH=y$({hannWindow_:function(t){return mH(t,.5,.5)}}),kH=y$({frame_:function(t,e,n,r=!1,i=0){let s=0;const o=[];for(;s+e<=t.size;)o.push(OB(t,s,e)),s+=n;if(r)for(;s<t.size;){const r=s+e-t.size,a=mB([OB(t,s,e-r),Rz([r],i)]);o.push(a),s+=n}return 0===o.length?RU([],[0,e]):I$(mB(o),[o.length,e])}}),RH=y$({stft_:function(t,e,n,r,i=MH){null==r&&(r=fH(e));const s=kH(t,e,n),o=yB(s,i(e)),a=[];for(let l=0;l<s.shape[0];l++)a.push(cU(OB(o,[l,0],[1,e]),r));return mB(a)}}),IH=y$({cropAndResize_:function(t,e,n,r,i,s){const o=m$(t,"image","cropAndResize"),a=m$(e,"boxes","cropAndResize","float32"),l=m$(n,"boxInd","cropAndResize","int32");i=i||"bilinear",s=s||0;const c=a.shape[0];return UF(4===o.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),UF(2===a.rank&&4===a.shape[1],()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),UF(1===l.rank&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),UF(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),UF(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),UF("bilinear"===i||"nearest"===i,()=>`method must be bilinear or nearest, but was ${i}`),o$.runKernelFunc(t=>t.cropAndResize(o,a,l,r,i,s),{image:o,boxes:a,boxInd:l},null,"CropAndResize",{method:i,extrapolationValue:s,cropSize:r})}}),NH=y$({flipLeftRight_:function(t){const e=m$(t,"image","flipLeftRight","float32");return UF(4===e.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`),o$.runKernel(xL,{image:e},{})}}),OH=y$({rotateWithOffset_:function(t,e,n=0,r=.5){const i=m$(t,"image","rotateWithOffset","float32");return UF(4===i.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`),o$.runKernel(EF,{image:i},{radians:e,fillValue:n,center:r})}});function DH(t,e,n,r,i,s){null==r&&(r=.5),null==i&&(i=Number.NEGATIVE_INFINITY),null==s&&(s=0);const o=t.shape[0];return n=Math.min(n,o),UF(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),UF(2===t.rank,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),UF(4===t.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),UF(1===e.rank,()=>"scores must be a 1D tensor"),UF(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),UF(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:i,softNmsSigma:s}}const LH=y$({nonMaxSuppression_:function(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY){const s=m$(t,"boxes","nonMaxSuppression"),o=m$(e,"scores","nonMaxSuppression"),a=DH(s,o,n,r,i);return o$.runKernelFunc(t=>t.nonMaxSuppression(s,o,n,r,i),{boxes:s,scores:o},null,VL,{maxOutputSize:n=a.maxOutputSize,iouThreshold:r=a.iouThreshold,scoreThreshold:i=a.scoreThreshold})}});function FH(t,e,n){const r=function(t,e,n){return function(t,e,n){let r=0,i=t.length,s=0,o=!1;for(;r<i;){s=r+(i-r>>>1);const a=n(e,t[s]);a>0?r=s+1:(i=s,o=!a)}return o?r:-r-1}(t,e,n||PH)}(t,e,n);t.splice(r<0?-(r+1):r,0,e)}function PH(t,e){return t>e?1:t<e?-1:0}function $H(t,e,n,r,i){return VH(t,e,n,r,i,0).selectedIndices}function BH(t,e,n,r,i,s){return VH(t,e,n,r,i,0,!1,s,!0)}function zH(t,e,n,r,i,s){return VH(t,e,n,r,i,s,!0)}function VH(t,e,n,r,i,s,o=!1,a=!1,l=!1){const c=[];for(let g=0;g<e.length;g++)e[g]>i&&c.push({score:e[g],boxIndex:g,suppressBeginIndex:0});c.sort(WH);const u=s>0?-.5/s:0,h=[],d=[];for(;h.length<n&&c.length>0;){const e=c.pop(),{score:n,boxIndex:s,suppressBeginIndex:o}=e;if(n<i)break;let a=!1;for(let l=h.length-1;l>=o;--l){const n=UH(t,s,h[l]);if(n>=r){a=!0;break}if(e.score=e.score*HH(r,u,n),e.score<=i)break}e.suppressBeginIndex=h.length,a||(e.score===n?(h.push(s),d.push(e.score)):e.score>i&&FH(c,e,WH))}const p=h.length,f=n-p;a&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:JV(h,"int32")};return o&&(m.selectedScores=JV(d,"float32")),l&&(m.validOutputs=Wz(p,"int32")),m}function UH(t,e,n){const r=t.subarray(4*e,4*e+4),i=t.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(i[0],i[2]),u=Math.min(i[1],i[3]),h=Math.max(i[0],i[2]),d=Math.max(i[1],i[3]),p=(a-s)*(l-o),f=(h-c)*(d-u);if(p<=0||f<=0)return 0;const m=Math.max(s,c),g=Math.max(o,u),y=Math.min(a,h),v=Math.min(l,d),b=Math.max(y-m,0)*Math.max(v-g,0);return b/(p+f-b)}function HH(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function WH(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}const jH=y$({nonMaxSuppressionWithScore_:function(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY,s=0){const o=m$(t,"boxes","nonMaxSuppression"),a=m$(e,"scores","nonMaxSuppression"),l=DH(o,a,n,r,i,s),c=o$.runKernel(HL,{boxes:o,scores:a},{maxOutputSize:n=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:i=l.scoreThreshold,softNmsSigma:s=l.softNmsSigma});return{selectedIndices:c[0],selectedScores:c[1]}}}),GH=y$({nonMaxSuppressionPadded_:function(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY,s=!1){const o=m$(t,"boxes","nonMaxSuppression"),a=m$(e,"scores","nonMaxSuppression"),l=DH(o,a,n,r,i,null),c=o$.runKernel(UL,{boxes:o,scores:a},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:s});return{selectedIndices:c[0],validOutputs:c[1]}}}),qH=y$({resizeBilinear_:function(t,e,n=!1){const r=m$(t,"images","resizeBilinear");UF(3===r.rank||4===r.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),UF(2===e.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`);let i=r,s=!1;3===r.rank&&(s=!0,i=I$(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[o,a]=e,l=o$.runKernelFunc((t,e)=>(e([i]),t.resizeBilinear(i,o,a,n)),{images:i},null,JL,{alignCorners:n,size:e});return s?I$(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),XH=y$({resizeNearestNeighbor_:function(t,e,n=!1){const r=m$(t,"images","resizeNearestNeighbor");UF(3===r.rank||4===r.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),UF(2===e.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),UF("float32"===r.dtype||"int32"===r.dtype,()=>"`images` must have `int32` or `float32` as dtype");let i=r,s=!1;3===r.rank&&(s=!0,i=I$(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[o,a]=e,l=o$.runKernelFunc((t,e)=>(e([i]),t.resizeNearestNeighbor(i,o,a,n)),{images:i},null,ZL,{alignCorners:n,size:e});return s?I$(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),KH=y$({bandPart_:function(t,e,n){UF(e%1==0,()=>`bandPart(): numLower must be an integer, got ${e}.`),UF(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const r=m$(t,"a","bandPart");UF(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const i=r.shape,[s,o]=r.shape.slice(-2);if(!(e<=s))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${s}).`);if(!(n<=o))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`);e<0&&(e=s),n<0&&(n=o);const a=I$(QV(0,s,1,"int32"),[-1,1]),l=QV(0,o,1,"int32"),c=lV(a,l),u=dV(Jz(c,Wz(+e,"int32")),Bz(c,Wz(-n,"int32"))),h=bV([s,o],r.dtype);return I$(TU($U(I$(r,[-1,s,o])).map(t=>vz(u,t,h))),i)}}),YH=y$({gramSchmidt_:function(t){let e;if(Array.isArray(t)){e=!1,UF(null!=t&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const n=t[0].shape[0];for(let e=1;e<t.length;++e)UF(t[e].shape[0]===n,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[e].shape[0]} vs. ${n})`)}else e=!0,t=lU(t,t.shape[0],0).map(t=>CU(t,[0]));UF(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],r=t;for(let i=0;i<t.length;++i)n.push(o$.tidy(()=>{let t=r[i];if(i>0)for(let e=0;e<i;++e){const r=yB(cV(yB(n[e],t)),n[e]);t=lV(t,r)}return pz(t,sH(t,"euclidean"))}));return e?TU(n,0):n}});function ZH(t,e=!1){return o$.tidy(()=>{UF(2===t.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],r=t.shape[1];let i=Mz(n),s=UB(t);const o=RU([[1]],[1,1]);let a=UB(o);const l=n>=r?r:n;for(let t=0;t<l;++t){const e=s,l=a,c=i;[a,s,i]=o$.tidy(()=>{const e=OB(s,[t,t],[n-t,1]),l=sH(e),c=OB(s,[t,t],[1,1]),u=vz($z(c,0),RU([[-1]]),RU([[1]])),h=lV(c,yB(u,l)),d=pz(e,h);a=1===d.shape[0]?UB(o):mB([o,OB(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=iV(pz(gB(u,h),l)),f=OB(s,[t,0],[n-t,r]),m=yB(p,a),g=N$(a);if(0===t)s=lV(f,gB(m,gB(g,f)));else{const e=lV(f,gB(m,gB(g,f)));s=mB([OB(s,[0,0],[t,r]),e],0)}const y=N$(m),v=OB(i,[0,t],[n,i.shape[1]-t]);if(0===t)i=lV(v,gB(gB(v,a),y));else{const e=lV(v,gB(gB(v,a),y));i=mB([OB(i,[0,0],[n,t]),e],1)}return[a,s,i]}),aB([e,l,c])}return!e&&n>r&&(i=OB(i,[0,0],[n,r]),s=OB(s,[0,0],[r,r])),[i,s]})}const JH=y$({qr_:function(t,e=!1){if(UF(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),2===t.rank)return ZH(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((t,e)=>t*e),r=$U(I$(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),i=[],s=[];return r.forEach(t=>{const[n,r]=ZH(t,e);i.push(n),s.push(r)}),[I$(TU(i,0),t.shape),I$(TU(s,0),t.shape)]}}});var QH;!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(QH||(QH={}));const tW=y$({computeWeightedLoss_:function(t,e,n=QH.SUM_BY_NONZERO_WEIGHTS){const r=m$(t,"losses","computeWeightedLoss");let i=null;null!=e&&(i=m$(e,"weights","computeWeightedLoss"));const s=null==i?r:yB(r,i);if(n===QH.NONE)return s;if(n===QH.SUM)return cV(s);if(n===QH.MEAN){if(null==i)return xV(s);{const t=r.size/i.size,e=pz(cV(s),cV(i));return t>1?pz(e,Wz(t)):e}}if(n===QH.SUM_BY_NONZERO_WEIGHTS){if(null==i)return pz(cV(s),Wz(r.size));{const t=yB(i,_V(r.shape)),e=U$(cV(kV(t,Wz(0))),"float32");return pz(cV(s),e)}}throw Error(`Unknown reduction: ${n}`)}}),eW=y$({absoluteDifference_:function(t,e,n,r=QH.SUM_BY_NONZERO_WEIGHTS){const i=m$(t,"labels","absoluteDifference"),s=m$(e,"predictions","absoluteDifference");let o=null;null!=n&&(o=m$(n,"weights","absoluteDifference")),HF(i.shape,s.shape,"Error in absoluteDifference: ");const a=v$(lV(i,s));return tW(a,o,r)}}),nW=y$({cosineDistance_:function(t,e,n,r,i=QH.SUM_BY_NONZERO_WEIGHTS){const s=m$(t,"labels","cosineDistance"),o=m$(e,"predictions","cosineDistance");let a=null;null!=r&&(a=m$(r,"weights","cosineDistance")),HF(s.shape,o.shape,"Error in cosineDistance: ");const l=Wz(1),c=lV(l,cV(yB(s,o),n,!0));return tW(c,a,i)}}),rW=y$({hingeLoss_:function(t,e,n,r=QH.SUM_BY_NONZERO_WEIGHTS){let i=m$(t,"labels","hingeLoss");const s=m$(e,"predictions","hingeLoss");let o=null;null!=n&&(o=m$(n,"weights","hingeLoss")),HF(i.shape,s.shape,"Error in hingeLoss: ");const a=Wz(1);i=lV(yB(Wz(2),i),a);const l=eU(lV(a,yB(i,s)));return tW(l,o,r)}}),iW=y$({huberLoss_:function(t,e,n,r=1,i=QH.SUM_BY_NONZERO_WEIGHTS){const s=m$(t,"labels","huberLoss"),o=m$(e,"predictions","huberLoss");let a=null;null!=n&&(a=m$(n,"weights","huberLoss")),HF(s.shape,o.shape,"Error in huberLoss: ");const l=Wz(r),c=v$(lV(o,s)),u=SV(c,l),h=lV(c,u),d=x$(yB(Wz(.5),CV(u)),yB(l,h));return tW(d,a,i)}}),sW=y$({logLoss_:function(t,e,n,r=1e-7,i=QH.SUM_BY_NONZERO_WEIGHTS){const s=m$(t,"labels","logLoss"),o=m$(e,"predictions","logLoss");let a=null;null!=n&&(a=m$(n,"weights","logLoss")),HF(s.shape,o.shape,"Error in logLoss: ");const l=Wz(1),c=Wz(r),u=iV(yB(s,eV(x$(o,c)))),h=yB(lV(l,s),eV(x$(lV(l,o),c))),d=lV(u,h);return tW(d,a,i)}}),oW=y$({meanSquaredError_:function(t,e,n,r=QH.SUM_BY_NONZERO_WEIGHTS){const i=m$(t,"labels","meanSquaredError"),s=m$(e,"predictions","meanSquaredError");let o=null;null!=n&&(o=m$(n,"weights","meanSquaredError")),HF(i.shape,s.shape,"Error in meanSquaredError: ");const a=EU(i,s);return tW(a,o,r)}}),aW=y$({sigmoidCrossEntropy_:function(t,e,n,r=0,i=QH.SUM_BY_NONZERO_WEIGHTS){let s=m$(t,"multiClassLabels","sigmoidCrossEntropy");const o=m$(e,"logits","sigmoidCrossEntropy");let a=null;if(null!=n&&(a=m$(n,"weights","sigmoidCrossEntropy")),HF(s.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const t=Wz(r),e=Wz(1),n=Wz(.5);s=x$(yB(s,lV(e,t)),yB(n,t))}const l=function(t,e){const n=m$(t,"labels","sigmoidCrossEntropyWithLogits"),r=m$(e,"logits","sigmoidCrossEntropyWithLogits");HF(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const i=eU(r),s=yB(r,n),o=nV(Ez(iV(v$(r))));return x$(lV(i,s),o)}(s,o);return tW(l,a,i)}}),lW=y$({softmaxCrossEntropy_:function(t,e,n,r=0,i=QH.SUM_BY_NONZERO_WEIGHTS){let s=m$(t,"onehotLabels","softmaxCrossEntropy");const o=m$(e,"logits","softmaxCrossEntropy");let a=null;if(null!=n&&(a=m$(n,"weights","softmaxCrossEntropy")),HF(s.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const t=Wz(r),e=Wz(1),n=Wz(s.shape[1]);s=x$(yB(s,lV(e,t)),pz(t,n))}const l=function(t,e,n=-1){if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return rV((t,e,r)=>{const i=hV(e,[n],!0),s=lV(U$(e,"float32"),i);r([t,s]);const o=iV(yB(s,t));return{value:cV(o,[n]),gradFunc:(t,e)=>{const[r,i]=e,s=T$(t.shape,[n]);return[yB(I$(t,s),lV(U$(r,"float32"),Ez(i))),yB(I$(t,s),lV(Ez(i),U$(r,"float32")))]}}})(t,e)}(s,o);return tW(l,a,i)}}),cW={fft:kz,ifft:zz,rfft:cU,irfft:jz},uW={hammingWindow:AH,hannWindow:MH,frame:kH,stft:RH},hW={flipLeftRight:NH,resizeNearestNeighbor:XH,resizeBilinear:qH,rotateWithOffset:OH,cropAndResize:IH,nonMaxSuppression:LH,nonMaxSuppressionAsync:async function(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY){const s=m$(t,"boxes","nonMaxSuppressionAsync"),o=m$(e,"scores","nonMaxSuppressionAsync"),a=DH(s,o,n,r,i);n=a.maxOutputSize,r=a.iouThreshold,i=a.scoreThreshold;const l=await Promise.all([s.data(),o.data()]),c=$H(l[0],l[1],n,r,i);return s!==t&&s.dispose(),o!==e&&o.dispose(),c},nonMaxSuppressionWithScore:jH,nonMaxSuppressionWithScoreAsync:async function(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY,s=0){const o=m$(t,"boxes","nonMaxSuppressionAsync"),a=m$(e,"scores","nonMaxSuppressionAsync"),l=DH(o,a,n,r,i,s);n=l.maxOutputSize,r=l.iouThreshold,i=l.scoreThreshold,s=l.softNmsSigma;const c=await Promise.all([o.data(),a.data()]),u=zH(c[0],c[1],n,r,i,s);return o!==t&&o.dispose(),a!==e&&a.dispose(),u},nonMaxSuppressionPadded:GH,nonMaxSuppressionPaddedAsync:async function(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY,s=!1){const o=m$(t,"boxes","nonMaxSuppressionAsync"),a=m$(e,"scores","nonMaxSuppressionAsync"),l=DH(o,a,n,r,i,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([o.data(),a.data()]),f=BH(d,p,c,u,h,s);return o!==t&&o.dispose(),a!==e&&a.dispose(),f}},dW={bandPart:KH,gramSchmidt:YH,qr:JH},pW={absoluteDifference:eW,computeWeightedLoss:tW,cosineDistance:nW,hingeLoss:rW,huberLoss:iW,logLoss:sW,meanSquaredError:oW,sigmoidCrossEntropy:aW,softmaxCrossEntropy:lW};VP=c;const fW={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};async function mW(t,e){const n=[],r=[],i=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);for(let s=0;s<i.length;++s){const o=i[s],a=Array.isArray(t)?t[s].tensor:t[o];if("float32"!==a.dtype&&"int32"!==a.dtype&&"bool"!==a.dtype&&"string"!==a.dtype&&"complex64"!==a.dtype)throw new Error(`Unsupported dtype in weight '${o}': ${a.dtype}`);const l={name:o,shape:a.shape,dtype:a.dtype};if("string"===a.dtype){const t=new Promise(async t=>{const e=await a.bytes(),n=e.reduce((t,e)=>t+e.length,0)+4*e.length,r=new Uint8Array(n);let i=0;for(let s=0;s<e.length;s++){const t=e[s],n=new Uint8Array(new Uint32Array([t.length]).buffer);r.set(n,i),i+=4,r.set(t,i),i+=t.length}t(r)});r.push(t)}else r.push(a.data());null!=e&&(l.group=e),n.push(l)}return{data:yW(await Promise.all(r)),specs:n}}function gW(t,e){const n={};let r,i=0;for(const s of e){const e=s.name,o=s.dtype,a=s.shape,l=GF(a);let c;if("quantization"in s){const n=s.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${s.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${s.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==o)throw new Error(`Weight ${s.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${o}.`)}const a=fW[n.dtype],u=t.slice(i,i+l*a),h="uint8"===n.dtype?new Uint8Array(u):new Uint16Array(u);if("float32"===o)if("uint8"===n.dtype||"uint16"===n.dtype){c=new Float32Array(h.length);for(let t=0;t<h.length;t++)c[t]=h[t]*n.scale+n.min}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===r&&(r=SW()),c=r(h)}else{if("int32"!==o)throw new Error(`Unsupported dtype in weight '${e}': ${o}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);c=new Int32Array(h.length);for(let t=0;t<h.length;t++)c[t]=Math.round(h[t]*n.scale+n.min)}i+=l*a}else if("string"===o){const e=GF(s.shape);c=[];for(let n=0;n<e;n++){const e=new Uint32Array(t.slice(i,i+4))[0];i+=4;const n=new Uint8Array(t.slice(i,i+e));c.push(n),i+=e}}else{const r=fW[o],s=t.slice(i,i+l*r);if("float32"===o)c=new Float32Array(s);else if("int32"===o)c=new Int32Array(s);else if("bool"===o)c=new Uint8Array(s);else{if("complex64"!==o)throw new Error(`Unsupported dtype in weight '${e}': ${o}`);{c=new Float32Array(s);const t=new Float32Array(c.length/2),r=new Float32Array(c.length/2);for(let e=0;e<t.length;e++)t[e]=c[2*e],r[e]=c[2*e+1];const i=fB(t,a,"float32"),o=fB(r,a,"float32");n[e]=qB(i,o)}}i+=l*r}"complex64"!==o&&(n[e]=fB(c,a,o))}return n}function yW(t){if(null===t)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(t=>{if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${t.constructor.name}`)});const r=new Uint8Array(e);let i=0;return n.forEach(t=>{r.set(new Uint8Array(t.buffer),i),i+=t.byteLength}),r.buffer}const vW="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function bW(t){return vW?Buffer.byteLength(t):new Blob([t]).size}function _W(t){if(1===t.length)return t[0];let e=0;t.forEach(t=>{e+=t.byteLength});const n=new Uint8Array(e);let r=0;return t.forEach(t=>{n.set(new Uint8Array(t),r),r+=t.byteLength}),n.buffer}function xW(t){for(t=t.trim();t.endsWith("/");)t=t.slice(0,t.length-1);const e=t.split("/");return e[e.length-1]}function wW(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:bW(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:bW(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}function SW(){const t=function(){const t=t=>{let e=t<<13,n=0;for(;0==(8388608&e);)n-=8388608,e<<=1;return e&=-8388609,n+=947912704,e|n},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}(),e=function(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}(),n=function(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}();return r=>{const i=new ArrayBuffer(4*r.length),s=new Uint32Array(i);for(let o=0;o<r.length;o++){const i=r[o];s[o]=t[n[i>>10]+(1023&i)]+e[i>>10]}return new Float32Array(i)}}class EW{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==EW.instance&&(EW.instance=new EW),EW.instance}static registerSaveRouter(t){EW.getInstance().saveRouters.push(t)}static registerLoadRouter(t){EW.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return EW.getHandlers(t,"save")}static getLoadHandlers(t,e){return EW.getHandlers(t,"load",e)}static getHandlers(t,e,n){const r=[];return("load"===e?EW.getInstance().loadRouters:EW.getInstance().saveRouters).forEach(e=>{const i=e(t,n);null!==i&&r.push(i)}),r}}const CW=t=>EW.registerSaveRouter(t),TW=t=>EW.registerLoadRouter(t),AW=t=>EW.getSaveHandlers(t),MW=(t,e)=>EW.getLoadHandlers(t,e),kW="://";class RW{constructor(){this.managers={}}static getInstance(){return null==RW.instance&&(RW.instance=new RW),RW.instance}static registerManager(t,e){UF(null!=t,()=>"scheme must not be undefined or null."),t.endsWith(kW)&&(t=t.slice(0,t.indexOf(kW))),UF(t.length>0,()=>"scheme must not be an empty string.");const n=RW.getInstance();UF(null==n.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),n.managers[t]=e}static getManager(t){const e=this.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}}function IW(t){if(-1===t.indexOf(kW))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${RW.getSchemes().join(",")}`);return{scheme:t.split(kW)[0],path:t.split(kW)[1]}}async function NW(t,e,n=!1){UF(t!==e,()=>`Old path and new path are the same: '${t}'`);const r=EW.getLoadHandlers(t);UF(r.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),UF(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${t}.`);const i=r[0],s=EW.getSaveHandlers(e);UF(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),UF(s.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const o=s[0],a=IW(t).scheme,l=IW(t).path,c=a===IW(t).scheme,u=await i.load();n&&c&&await RW.getManager(a).removeModel(l);const h=await o.save(u);return n&&!c&&await RW.getManager(a).removeModel(l),h.modelArtifactsInfo}async function OW(){const t=RW.getSchemes(),e={};for(const n of t){const t=await RW.getManager(n).listModels();for(const r in t)e[n+kW+r]=t[r]}return e}async function DW(t){const e=IW(t);return RW.getManager(e.scheme).removeModel(e.path)}async function LW(t,e){return NW(t,e,!1)}async function FW(t,e){return NW(t,e,!0)}const PW="tensorflowjs",$W="models_store",BW="model_info_store";function zW(){if(!BD().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"==typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function VW(t){const e=t.result;e.createObjectStore($W,{keyPath:"modelPath"}),e.createObjectStore(BW,{keyPath:"modelPath"})}class UW{constructor(t){if(this.indexedDB=zW(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((t,n)=>{const r=this.indexedDB.open(PW,1);r.onupgradeneeded=()=>VW(r),r.onsuccess=()=>{const i=r.result;if(null==e){const e=i.transaction($W,"readonly"),r=e.objectStore($W).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return i.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));t(r.result.modelArtifacts)},r.onerror=t=>(i.close(),n(r.error)),e.oncomplete=()=>i.close()}else{const r=wW(e),s=i.transaction(BW,"readwrite");let o=s.objectStore(BW);const a=o.put({modelPath:this.modelPath,modelArtifactsInfo:r});let l;a.onsuccess=()=>{l=i.transaction($W,"readwrite");const a=l.objectStore($W).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:r});a.onsuccess=()=>t({modelArtifactsInfo:r}),a.onerror=t=>{o=s.objectStore(BW);const e=o.delete(this.modelPath);e.onsuccess=()=>(i.close(),n(a.error)),e.onerror=t=>(i.close(),n(a.error))}},a.onerror=t=>(i.close(),n(a.error)),s.oncomplete=()=>{null==l?i.close():l.oncomplete=()=>i.close()}}},r.onerror=t=>n(r.error)})}}UW.URL_SCHEME="indexeddb://";const HW=t=>{return BD().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(UW.URL_SCHEME)?(e=t.slice(UW.URL_SCHEME.length),new UW(e)):null;var e};EW.registerSaveRouter(HW),EW.registerLoadRouter(HW);class WW{constructor(){this.indexedDB=zW()}async listModels(){return new Promise((t,e)=>{const n=this.indexedDB.open(PW,1);n.onupgradeneeded=()=>VW(n),n.onsuccess=()=>{const r=n.result,i=r.transaction(BW,"readonly"),s=i.objectStore(BW).getAll();s.onsuccess=()=>{const e={};for(const t of s.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},s.onerror=t=>(r.close(),e(s.error)),i.oncomplete=()=>r.close()},n.onerror=t=>e(n.error)})}async removeModel(t){var e;return t=(e=t).startsWith(UW.URL_SCHEME)?e.slice(UW.URL_SCHEME.length):e,new Promise((e,n)=>{const r=this.indexedDB.open(PW,1);r.onupgradeneeded=()=>VW(r),r.onsuccess=()=>{const i=r.result,s=i.transaction(BW,"readwrite"),o=s.objectStore(BW),a=o.get(t);let l;a.onsuccess=()=>{if(null==a.result)return i.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const r=o.delete(t),s=()=>{l=i.transaction($W,"readwrite");const r=l.objectStore($W).delete(t);r.onsuccess=()=>e(a.result.modelArtifactsInfo),r.onerror=t=>n(a.error)};r.onsuccess=s,r.onerror=t=>(s(),i.close(),n(a.error))}},a.onerror=t=>(i.close(),n(a.error)),s.oncomplete=()=>{null==l?i.close():l.oncomplete=()=>i.close()}},r.onerror=t=>n(r.error)})}}if(BD().getBool("IS_BROWSER"))try{RW.registerManager(UW.URL_SCHEME,new WW)}catch(U3){}const jW="/",GW="tensorflowjs_models",qW="info",XW="model_topology",KW="weight_specs",YW="weight_data",ZW="model_metadata";function JW(t){return{info:[GW,t,qW].join(jW),topology:[GW,t,XW].join(jW),weightSpecs:[GW,t,KW].join(jW),weightData:[GW,t,YW].join(jW),modelMetadata:[GW,t,ZW].join(jW)}}function QW(t){const e=t.split(jW);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(jW)}class tj{constructor(t){if(!BD().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=JW(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),r=wW(t);try{return this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(t){if(vW)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let r=0,i=e.length;r<i;r++)n+=String.fromCharCode(e[r]);return btoa(n)}(t.weightData)),this.LS.setItem(this.keys.modelMetadata,JSON.stringify({format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,userDefinedMetadata:t.userDefinedMetadata})),{modelArtifactsInfo:r}}catch(U3){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(null==t)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=r;const i=this.LS.getItem(this.keys.modelMetadata);if(null!=i){const t=JSON.parse(i);e.format=t.format,e.generatedBy=t.generatedBy,e.convertedBy=t.convertedBy,e.userDefinedMetadata=t.userDefinedMetadata}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=function(t){if(vW){const e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n.set([e.charCodeAt(r)],r);return n.buffer}(s),e}}tj.URL_SCHEME="localstorage://";const ej=t=>{return BD().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(tj.URL_SCHEME)?(e=t.slice(tj.URL_SCHEME.length),new tj(e)):null;var e};EW.registerSaveRouter(ej),EW.registerLoadRouter(ej);class nj{constructor(){UF(BD().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),UF("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},e=GW+jW,n=jW+qW;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);i.startsWith(e)&&i.endsWith(n)&&(t[QW(i)]=JSON.parse(this.LS.getItem(i)))}return t}async removeModel(t){var e;const n=JW(t=(e=t).startsWith(tj.URL_SCHEME)?e.slice(tj.URL_SCHEME.length):e);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${t}'`);const r=JSON.parse(this.LS.getItem(n.info));return this.LS.removeItem(n.info),this.LS.removeItem(n.topology),this.LS.removeItem(n.weightSpecs),this.LS.removeItem(n.weightData),r}}if(BD().getBool("IS_BROWSER"))try{RW.registerManager(tj.URL_SCHEME,new nj)}catch(U3){}function rj(t){return new Promise(t=>setTimeout(t)).then(t)}class ij{constructor(t){if(!BD().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(ij.URL_SCHEME)&&(t=t.slice(ij.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelTopologyFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(t){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=window.URL.createObjectURL(new Blob([JSON.stringify({modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}]})],{type:"application/json"})),r=null==this.jsonAnchor?document.createElement("a"):this.jsonAnchor;if(r.download=this.modelTopologyFileName,r.href=n,await rj(()=>r.dispatchEvent(new MouseEvent("click"))),null!=t.weightData){const t=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;t.download=this.weightDataFileName,t.href=e,await rj(()=>t.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:wW(t)}}}}ij.URL_SCHEME="downloads://";class sj{constructor(t){if(null==t||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.files=t}async load(){const t=this.files[0],e=this.files.slice(1);return new Promise((n,r)=>{const i=new FileReader;i.onload=i=>{const s=JSON.parse(i.target.result),o=s.modelTopology;if(null==o)return void r(new Error(`modelTopology field is missing from file ${t.name}`));0===e.length&&n({modelTopology:o});const a=s.weightsManifest;if(null==a)return void r(new Error(`weightManifest field is missing from file ${t.name}`));let l;try{l=this.checkManifestAndWeightFiles(a,e)}catch(U3){return void r(U3)}const c=[],u=[],h=[];a.forEach(t=>{t.paths.forEach(t=>{u.push(t),h.push(null)}),c.push(...t.weights)}),a.forEach(t=>{t.paths.forEach(t=>{const e=new FileReader;e.onload=e=>{const r=e.target.result,i=u.indexOf(t);h[i]=r,-1===h.indexOf(null)&&n({modelTopology:o,weightSpecs:c,weightData:_W(h),format:s.format,generatedBy:s.generatedBy,convertedBy:s.convertedBy,userDefinedMetadata:s.userDefinedMetadata})},e.onerror=e=>r(`Failed to weights data from file of path '${t}'.`),e.readAsArrayBuffer(l[t])})})},i.onerror=e=>r(`Failed to read model topology and weights manifest JSON from file '${t.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),i.readAsText(t)})}checkManifestAndWeightFiles(t,e){const n=[],r=e.map(t=>xW(t.name)),i={};for(const s of t)s.paths.forEach(t=>{const s=xW(t);if(-1!==n.indexOf(s))throw new Error(`Duplicate file basename found in weights manifest: '${s}'`);if(n.push(s),-1===r.indexOf(s))throw new Error(`Weight file with basename '${s}' is not provided.`);i[t]=e[r.indexOf(s)]});if(n.length!==e.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${e.length}).`);return i}}function oj(t){return new sj(t)}function aj(t,e,n,r){!function(t){UF(null!=t&&Array.isArray(t)&&t.length>0,()=>"promises must be a none empty array")}(t),function(t,e){UF(t>=0&&t<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${t}`),UF(e>=0&&e<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${e}`),UF(e>=t,()=>`startFraction must be no more than endFraction, but got startFraction ${t} and endFraction ${e}`)}(n=null==n?0:n,r=null==r?1:r);let i=0;return Promise.all(t.map(s=>(s.then(s=>{const o=n+ ++i/t.length*(r-n);return e(o),s}),s)))}async function lj(t,e){null==e&&(e={});const n=null==e.fetchFunc?BD().platform.fetch:e.fetchFunc,r=t.map(t=>n(t,e.requestInit,{isBinary:!0})),i=(null==e.onProgress?await Promise.all(r):await aj(r,e.onProgress,0,.5)).map(t=>t.arrayBuffer());return null==e.onProgress?await Promise.all(i):await aj(i,e.onProgress,.5,1)}async function cj(t,e="",n,r){return uj(t=>lj(t,{requestInit:r}))(t,e,n)}function uj(t){return async(e,n="",r)=>{const i=e.map(()=>!1),s={},o=null!=r?r.map(()=>!1):[],a=[];if(e.forEach((t,e)=>{let n=0;t.weights.forEach(t=>{const l=fW["quantization"in t?t.quantization.dtype:t.dtype]*GF(t.shape),c=()=>{i[e]=!0,null==s[e]&&(s[e]=[]),s[e].push({manifestEntry:t,groupOffset:n,sizeBytes:l})};null!=r?r.forEach((e,n)=>{e===t.name&&(c(),o[n]=!0)}):c(),a.push(t.name),n+=l})}),!o.every(t=>t)){const t=r.filter((t,e)=>!o[e]);throw new Error(`Could not find weights in manifest with names: ${t.join(", ")}. \nManifest JSON has weights with names: ${a.join(", ")}.`)}const l=i.reduce((t,e,n)=>(e&&t.push(n),t),[]),c=[];l.forEach(t=>{e[t].paths.forEach(t=>{const e=n+(n.endsWith("/")?"":"/")+t;c.push(e)})});const u=await t(c),h={};let d=0;return l.forEach(t=>{const n=e[t].paths.length;let r=0;for(let e=0;e<n;e++)r+=u[d+e].byteLength;const i=new ArrayBuffer(r),o=new Uint8Array(i);let a=0;for(let e=0;e<n;e++){const t=new Uint8Array(u[d+e]);o.set(t,a),a+=t.byteLength}s[t].forEach(t=>{const e=gW(i.slice(t.groupOffset,t.groupOffset+t.sizeBytes),[t.manifestEntry]);for(const n in e)h[n]=e[n]}),d+=n}),h}}EW.registerSaveRouter(t=>BD().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(ij.URL_SCHEME)?function(t="model"){return new ij(t)}(t.slice(ij.URL_SCHEME.length)):null);class hj{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,null!=e.fetchFunc?(UF("function"==typeof e.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=BD().platform.fetch,UF(null!=t&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&UF(2===t.length,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData,e.body.append("model.json",new Blob([JSON.stringify({modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,userDefinedMetadata:t.userDefinedMetadata,weightsManifest:[{paths:["./model.weights.bin"],weights:t.weightSpecs}]})],{type:"application/json"}),"model.json"),null!=t.weightData&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin");const n=await this.fetch(this.path,e);if(n.ok)return{modelArtifactsInfo:wW(t),responses:[n]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${n.status}.`)}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch(u){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=e.modelTopology,r=e.weightsManifest,i=e.generatedBy,s=e.convertedBy,o=e.format,a=e.userDefinedMetadata;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);let l,c;if(null!=r){const t=await this.loadWeights(r);[l,c]=t}return{modelTopology:n,weightSpecs:l,weightData:c,userDefinedMetadata:a,generatedBy:i,convertedBy:s,format:o}}async loadWeights(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?");return[t.substring(0,e)+"/",n>e?t.substring(n):""]}(e),i=this.weightPathPrefix||n,s=[];for(const a of t)s.push(...a.weights);const o=[];return t.forEach(t=>{t.paths.forEach(t=>{o.push(i+t+r)})}),[s,_W(await lj(o,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function dj(t){return null!=t.match(hj.URL_SCHEME_REGEX)}hj.URL_SCHEME_REGEX=/^https?:\/\//;const pj=(t,e)=>{if("undefined"==typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every(t=>dj(t)):dj(t),n)return fj(t,e)}return null};function fj(t,e){return new hj(t,e)}function mj(t,e){return fj(t,e)}EW.registerSaveRouter(pj),EW.registerLoadRouter(pj);class gj{constructor(t){this.modelArtifacts=t}async load(){return this.modelArtifacts}}class yj{constructor(t){this.saveHandler=t}async save(t){return this.saveHandler(t)}}function vj(t,e,n,r){return 1===arguments.length?null!=t.modelTopology||null!=t.weightSpecs?new gj(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new gj({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new gj({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:r}))}function bj(t){return new yj(t)}let _j;async function xj(t,e){let n=m$(t,"img","toPixels");if(!(t instanceof HP)){const t=n;n=U$(t,"int32"),t.dispose()}if(2!==n.rank&&3!==n.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const[r,i]=n.shape.slice(0,2),s=2===n.rank?1:n.shape[2];if(s>4||2===s)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);const o=await n.data(),a=wV(n),l=aV(n),c=await Promise.all([a.data(),l.data()]),u=c[0][0],h=c[1][0];if(a.dispose(),l.dispose(),"float32"===n.dtype){if(u<0||h>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [${u} - ${h}].`)}else{if("int32"!==n.dtype)throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);if(u<0||h>255)throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [${u} - ${h}].`)}const d="float32"===n.dtype?255:1,p=new Uint8ClampedArray(i*r*4);for(let f=0;f<r*i;++f){let t,e,n,r;1===s?(t=o[f]*d,e=o[f]*d,n=o[f]*d,r=255):3===s?(t=o[3*f]*d,e=o[3*f+1]*d,n=o[3*f+2]*d,r=255):4===s&&(t=o[4*f]*d,e=o[4*f+1]*d,n=o[4*f+2]*d,r=o[4*f+3]*d);const i=4*f;p[i+0]=Math.round(t),p[i+1]=Math.round(e),p[i+2]=Math.round(n),p[i+3]=Math.round(r)}if(null!=e){e.width=i,e.height=r;const t=e.getContext("2d"),n=new ImageData(p,i,r);t.putImageData(n,0,0)}return n!==t&&n.dispose(),p}const wj=y$({fromPixels_:function(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,i=!1,s=!1,o=!1;if(t.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&t instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&t instanceof HTMLVideoElement)i=!0;else if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement)s=!0;else{if(null==t.getContext)throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);o=!0}if(i){const e=2;if(i&&t.readyState<e)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=RF(SF,o$.backendName))return o$.runKernel(SF,{pixels:t},{numChannels:e});const[a,l]=i?[t.videoWidth,t.videoHeight]:[t.width,t.height];let c,u;if(o?c=t.getContext("2d").getImageData(0,0,a,l).data:r||n?c=t.data:(s||i)&&(null==_j&&(_j=document.createElement("canvas").getContext("2d")),_j.canvas.width=a,_j.canvas.height=l,_j.drawImage(t,0,0,a,l),c=_j.getImageData(0,0,a,l).data),4===e)u=new Int32Array(c);else{const t=a*l;u=new Int32Array(t*e);for(let n=0;n<t;n++)for(let t=0;t<e;++t)u[n*e+t]=c[4*n+t]}return IU(u,[l,a,e],"int32")}});class Sj{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class Ej{constructor(){this.classNameMap={}}static getMap(){return null==Ej.instance&&(Ej.instance=new Ej),Ej.instance}static register(t){Ej.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function Cj(t){UF(null!=t.className,()=>"Class being registered does not have the static className property defined."),UF("string"==typeof t.className,()=>"className is required to be a string, but got type "+typeof t.className),UF(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Ej.register(t)}class Tj extends Sj{minimize(t,e=!1,n){const{value:r,grads:i}=this.computeGradients(t,n);if(null!=n){const t=n.map(t=>({name:t.name,tensor:i[t.name]}));this.applyGradients(t)}else this.applyGradients(i);return aB(i),e?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function(t,e){UF(gP(t),()=>"The f passed in variableGrads(f) must be a function"),UF(null==e||Array.isArray(e)&&e.every(t=>t instanceof WP),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=null!=e;if(!n){e=[];for(const t in o$.registeredVariables)e.push(o$.registeredVariables[t])}const r=n?e.filter(t=>!t.trainable):null,i=e.length;UF((e=e.filter(t=>t.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);const{value:s,grads:o}=o$.gradients(t,e,null,!0);UF(o.some(t=>null!=t),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),UF(0===s.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`);const a={};return e.forEach((t,e)=>{null!=o[e]&&(a[t.name]=o[e])}),null!=r&&r.forEach(t=>a[t.name]=null),{value:s,grads:a}}(t,e)}dispose(){null!=this.iterations_&&aB(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:Wz(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(Tj,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});class Aj extends Tj{constructor(t,e,n=null){super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=o$.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=o$.registeredVariables[e];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${e}/accum_grad`,variable:oB(()=>bz(r).variable(!1))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${e}/accum_var`,variable:oB(()=>bz(r).variable(!1))});const i=Array.isArray(t)?t[n].tensor:t[e];if(null==i)return;const s=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;oB(()=>{const t=x$(yB(s,this.rho),yB(CV(i),1-this.rho)),e=yB(pz(SU(x$(o,this.epsilon)),SU(x$(s,this.epsilon))),i),n=x$(yB(o,this.rho),yB(CV(e),1-this.rho));s.assign(t),o.assign(n);const a=x$(yB(e,-this.learningRate),r);r.assign(a)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(aB(this.accumulatedGrads.map(t=>t.variable)),aB(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){const e=(t=await this.extractIterations(t)).length/2;this.accumulatedGrads=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.accumulatedUpdates=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}Aj.className="Adadelta",Cj(Aj);class Mj extends Tj{constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=o$.registeredVariables[e];if(null==this.accumulatedGrads[n]){const t=!1;this.accumulatedGrads[n]={originalName:`${e}/accumulator`,variable:oB(()=>Rz(r.shape,this.initialAccumulatorValue).variable(t))}}const i=Array.isArray(t)?t[n].tensor:t[e];if(null==i)return;const s=this.accumulatedGrads[n].variable;oB(()=>{const t=x$(s,CV(i));s.assign(t);const e=x$(yB(pz(i,SU(x$(t,o$.backend.epsilon()))),-this.learningRate),r);r.assign(e)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&aB(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),this.accumulatedGrads=t.map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}Mj.className="Adagrad",Cj(Mj);class kj extends Tj{constructor(t,e,n,r=null){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],oB(()=>{this.accBeta1=Wz(e).variable(),this.accBeta2=Wz(n).variable()}),null==r&&(this.epsilon=o$.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);oB(()=>{const n=lV(1,this.accBeta1),r=lV(1,this.accBeta2);e.forEach((e,i)=>{const s=o$.registeredVariables[e];null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${e}/m`,variable:oB(()=>bz(s).variable(!1))}),null==this.accumulatedSecondMoment[i]&&(this.accumulatedSecondMoment[i]={originalName:`${e}/v`,variable:oB(()=>bz(s).variable(!1))});const o=Array.isArray(t)?t[i].tensor:t[e];if(null==o)return;const a=this.accumulatedFirstMoment[i].variable,l=this.accumulatedSecondMoment[i].variable,c=x$(yB(a,this.beta1),yB(o,1-this.beta1)),u=x$(yB(l,this.beta2),yB(CV(o),1-this.beta2)),h=pz(c,n),d=pz(u,r);a.assign(c),l.assign(u);const p=x$(yB(pz(h,x$(SU(d),this.epsilon)),-this.learningRate),s);s.assign(p)}),this.accBeta1.assign(yB(this.accBeta1,this.beta1)),this.accBeta2.assign(yB(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&aB(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedSecondMoment&&aB(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),oB(()=>{this.accBeta1.assign(zV(this.beta1,this.iterations_+1)),this.accBeta2.assign(zV(this.beta2,this.iterations_+1))});const e=t.length/2;this.accumulatedFirstMoment=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.accumulatedSecondMoment=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}kj.className="Adam",Cj(kj);class Rj extends Tj{constructor(t,e,n,r=null,i=0){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],oB(()=>{this.iteration=Wz(0).variable(),this.accBeta1=Wz(e).variable()}),null==r&&(this.epsilon=o$.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);oB(()=>{const n=lV(1,this.accBeta1),r=pz(-this.learningRate,x$(yB(this.iteration,this.decay),1));e.forEach((e,i)=>{const s=o$.registeredVariables[e];null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${e}/m`,variable:bz(s).variable(!1)}),null==this.accumulatedWeightedInfNorm[i]&&(this.accumulatedWeightedInfNorm[i]={originalName:`${e}/v`,variable:bz(s).variable(!1)});const o=Array.isArray(t)?t[i].tensor:t[e];if(null==o)return;const a=this.accumulatedFirstMoment[i].variable,l=this.accumulatedWeightedInfNorm[i].variable,c=x$(yB(a,this.beta1),yB(o,1-this.beta1)),u=yB(l,this.beta2),h=v$(o),d=Kz(u,h);a.assign(c),l.assign(d);const p=x$(yB(pz(r,n),pz(c,x$(d,this.epsilon))),s);s.assign(p)}),this.iteration.assign(x$(this.iteration,1)),this.accBeta1.assign(yB(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&aB(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedWeightedInfNorm&&aB(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}Rj.className="Adamax",Cj(Rj);class Ij extends Tj{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const i=o$.registeredVariables[e];oB(()=>{const t=x$(yB(this.c,r),i);i.assign(t)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=lB(Wz(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(0!==(t=await this.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}Ij.className="SGD",Cj(Ij);class Nj extends Ij{constructor(t,e,n=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=Wz(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=o$.registeredVariables[e];if(null==this.accumulations[n]){const t=!1;this.accumulations[n]={originalName:`${e}/momentum`,variable:oB(()=>bz(r).variable(t))}}const i=this.accumulations[n].variable,s=Array.isArray(t)?t[n].tensor:t[e];null!=s&&oB(()=>{let t;const e=x$(yB(this.m,i),s);t=x$(yB(this.c,this.useNesterov?x$(s,yB(e,this.m)):e),r),i.assign(e),r.assign(t)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&aB(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),this.accumulations=t.map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}Nj.className="Momentum",Cj(Nj);class Oj extends Tj{constructor(t,e=.9,n=0,r=null,i=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,null==r&&(this.epsilon=o$.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=o$.registeredVariables[e],i=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${e}/rms`,variable:oB(()=>bz(r).variable(i))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${e}/momentum`,variable:oB(()=>bz(r).variable(i))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${e}/mg`,variable:oB(()=>bz(r).variable(i))});const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const o=this.accumulatedMeanSquares[n].variable,a=this.accumulatedMoments[n].variable;oB(()=>{const t=x$(yB(o,this.decay),yB(CV(s),1-this.decay));if(this.centered){const e=this.accumulatedMeanGrads[n].variable,i=x$(yB(e,this.decay),yB(s,1-this.decay)),l=pz(yB(s,this.learningRate),SU(lV(t,x$(CV(i),this.epsilon)))),c=x$(yB(a,this.momentum),l);o.assign(t),e.assign(i),a.assign(c);const u=lV(r,c);r.assign(u)}else{const t=x$(yB(o,this.decay),yB(CV(s),1-this.decay)),e=x$(yB(a,this.momentum),pz(yB(s,this.learningRate),SU(x$(t,this.epsilon))));o.assign(t),a.assign(e);const n=lV(r,e);r.assign(n)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&aB(this.accumulatedMeanSquares.map(t=>t.variable)),null!=this.accumulatedMeanGrads&&this.centered&&aB(this.accumulatedMeanGrads.map(t=>t.variable)),null!=this.accumulatedMoments&&aB(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,n=!1;this.accumulatedMeanSquares=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(n)})),this.accumulatedMoments=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=t.slice(2*e,3*e).map(t=>({originalName:t.name,variable:t.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}Oj.className="RMSProp",Cj(Oj);class Dj{static sgd(t){return new Ij(t)}static momentum(t,e,n=!1){return new Nj(t,e,n)}static rmsprop(t,e=.9,n=0,r=null,i=!1){return new Oj(t,e,n,r,i)}static adam(t=.001,e=.9,n=.999,r=null){return new kj(t,e,n,r)}static adadelta(t=.001,e=.95,n=null){return new Aj(t,e,n)}static adamax(t=.002,e=.9,n=.999,r=null,i=0){return new Rj(t,e,n,r,i)}static adagrad(t,e=.1){return new Mj(t,e)}}const Lj={sgd:Dj.sgd,momentum:Dj.momentum,adadelta:Dj.adadelta,adagrad:Dj.adagrad,rmsprop:Dj.rmsprop,adamax:Dj.adamax,adam:Dj.adam},Fj="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:t=>t();function Pj(){return new Promise(t=>Fj(()=>t()))}function $j(t,e,n){return[n*("number"==typeof t?t:t[0]),e*("number"==typeof t?t:t[1])]}function Bj(t,e,n,r=!0){let i=[];if(r)i=i.concat(e.slice(0)),i.push(t[0]/n),i=i.concat(t.slice(1));else{i=i.concat(t[0]);const n=e.length;for(let r=0;r<n;++r)i=i.concat([t[r+1]/e[r],e[r]]);i=i.concat(t.slice(n+1))}return i}function zj(t,e,n=!0){const r=[];if(n){r.push(e);for(let n=e+1;n<t;++n)n<=2*e?(r.push(n),r.push(n-(e+1))):r.push(n)}else{const n=[],i=[];for(let r=1;r<t;++r)r>=2*e+1||r%2==1?i.push(r):n.push(r);r.push(...n),r.push(0),r.push(...i)}return r}function Vj(t,e,n,r=!0){const i=[];i.push(r?t[0]/n:t[0]*n);for(let s=1;s<t.length;++s)i.push(s<=e.length?r?e[s-1]*t[s]:t[s]/e[s-1]:t[s]);return i}function Uj(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function Hj(t,e,n){const r=t.slice(0,1);for(let i=0;i<n;++i)r.push(t[i+1]-e[i][0]-e[i][1]);return r}function Wj(t,e){if(t.rank<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==e.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[e.rank-1]>t.rank)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[e.rank-1]} vs. ${t.rank}`);if(0===t.size)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const n=e.shape,r=n[n.length-1];let i=1;for(let c=0;c<n.length-1;++c)i*=n[c];const s=t.shape,o=n.slice();o.pop();let a=1;for(let c=r;c<t.rank;++c)a*=s[c],o.push(s[c]);const l=[...vP(t.shape).map(t=>t/a),1].slice(0,r);return[o,i,a,l]}const jj=1.7580993408473768,Gj=1.0507009873554805,qj=.3275911,Xj=.254829592,Kj=-.284496736,Yj=1.421413741,Zj=-1.453152027,Jj=1.061405429;function Qj(...t){BD().getBool("IS_TEST")||console.warn(...t)}function tG(...t){BD().getBool("IS_TEST")||console.log(...t)}function eG(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(2*t.length);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function nG(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function rG(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let i=0;i<t.length;i+=4)n[Math.floor(i/4)]=t[i],r[Math.floor(i/4)]=t[i+1];return{real:n,imag:r}}function iG(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let i=2;i<t.length;i+=4)n[Math.floor(i/4)]=t[i],r[Math.floor(i/4)]=t[i+1];return{real:n,imag:r}}function sG(t,e){return{real:t[2*e],imag:t[2*e+1]}}function oG(t,e,n,r){t[2*r]=e,t[2*r+1]=n}function aG(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let i=0;i<Math.ceil(t/2);i++){const s=(e?2:-2)*Math.PI*(i/t);n[i]=Math.cos(s),r[i]=Math.sin(s)}return{real:n,imag:r}}function lG(t,e,n){const r=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(r),imag:Math.sin(r)}}function cG(t,e,n){if("complex64"===e){if("complex64"===t.dtype)return t.clone();const e=bV(t.shape),r=U$(t,"float32"),i=n.complex(r,e);return e.dispose(),r.dispose(),i}if(!lP(t.dtype,e))return o$.makeTensorFromDataId(t.dataId,t.shape,e);if("complex64"===t.dtype){const r=n.real(t),i=U$(r,e);return r.dispose(),i}if("int32"===e)return n.int(t);if("bool"===e){const e=Wz(0,t.dtype),r=n.notEqual(t,e);return e.dispose(),r}throw new Error(`Error in Cast: failed to cast ${t.dtype} to ${e}`)}function uG(t,e){return o$.makeTensorFromDataId(t.dataId,e,t.dtype)}function hG(t,e,n){const r=(e-t)/(n-1),i=SP(n,"float32");i[0]=t;for(let s=1;s<i.length;s++)i[s]=i[s-1]+r;return JV(i,"float32")}function dG(t,e,n){const r=new Array(t.rank).fill(0),i=t.shape.slice();return e.map(e=>{const s=[...i];s[n]=e;const o=OB(t,r,s);return r[n]+=e,o})}function pG(t,e){const n=new Array(t.rank);for(let i=0;i<n.length;i++)n[i]=t.shape[i]*e[i];const r=WB(n,t.dtype);for(let i=0;i<r.values.length;++i){const e=r.indexToLoc(i),n=new Array(t.rank);for(let r=0;r<n.length;r++)n[r]=e[r]%t.shape[r];const s=t.locToIndex(n);r.values[i]=t.values[s]}return r.toTensor()}function fG(t,e,n,r,i){const s=e[e.length-1],[o,a]=[t.length/s,s],l=iP(n,o*r),c=iP("int32",o*r);for(let h=0;h<o;h++){const e=h*a,n=t.subarray(e,e+a),i=[];for(let t=0;t<n.length;t++)i.push({value:n[t],index:t});i.sort((t,e)=>e.value-t.value);const s=h*r,o=l.subarray(s,s+r),u=c.subarray(s,s+r);for(let t=0;t<r;t++)o[t]=i[t].value,u[t]=i[t].index}const u=e.slice();return u[u.length-1]=r,[fB(l,u,n),fB(c,u,"int32")]}class mG{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class gG{time(t){return yG("time")}read(t){return yG("read")}readSync(t){return yG("readSync")}numDataIds(){return yG("numDataIds")}disposeData(t){return yG("disposeData")}write(t,e,n){return yG("write")}move(t,e,n,r){return yG("move")}memory(){return yG("memory")}floatPrecision(){return yG("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}batchMatMul(t,e,n,r){return yG("batchMatMul")}fusedBatchMatMul({}){return yG("fusedBatchMatMul")}slice(t,e,n){return yG("slice")}stridedSlice(t,e,n,r){return yG("stridedSlice")}unstack(t,e){return yG("unstack")}reverse(t,e){return yG("reverse")}concat(t,e){return yG("concat")}neg(t){return yG("neg")}add(t,e){return yG("add")}addN(t){return yG("addN")}subtract(t,e){return yG("subtract")}multiply(t,e){return yG("multiply")}realDivide(t,e){return yG("realDivide")}floorDiv(t,e){return yG("floorDiv")}sum(t,e){return yG("sum")}prod(t,e){return yG("prod")}unsortedSegmentSum(t,e,n){return yG("unsortedSegmentSum")}argMin(t,e){return yG("argMin")}argMax(t,e){return yG("argMax")}equal(t,e){return yG("equal")}notEqual(t,e){return yG("notEqual")}less(t,e){return yG("less")}lessEqual(t,e){return yG("lessEqual")}greater(t,e){return yG("greater")}greaterEqual(t,e){return yG("greaterEqual")}logicalNot(t){return yG("logicalNot")}logicalAnd(t,e){return yG("logicalAnd")}logicalOr(t,e){return yG("logicalOr")}where(t){return yG("where")}select(t,e,n){return yG("select")}topk(t,e,n){return yG("topk")}min(t,e){return yG("min")}minimum(t,e){return yG("minimum")}mod(t,e){return yG("mod")}max(t,e){return yG("max")}maximum(t,e){return yG("maximum")}all(t,e){return yG("all")}any(t,e){return yG("any")}squaredDifference(t,e){return yG("squaredDifference")}ceil(t){return yG("ceil")}floor(t){return yG("floor")}round(t){return yG("round")}sign(t){return yG("sign")}isNaN(t){return yG("isNaN")}isInf(t){return yG("isInf")}isFinite(t){return yG("isFinite")}pow(t,e){return yG("pow")}exp(t){return yG("exp")}expm1(t){return yG("expm1")}softmax(t,e){return yG("softmax")}log(t){return yG("log")}log1p(t){return yG("log1p")}sqrt(t){return yG("sqrt")}rsqrt(t){return yG("rsqrt")}square(t){return yG("square")}reciprocal(t){return yG("reciprocal")}relu(t){return yG("relu")}relu6(t){return yG("relu6")}prelu(t,e){return yG("prelu")}elu(t){return yG("elu")}eluDer(t,e){return yG("eluDer")}selu(t){return yG("selu")}int(t){return yG("int")}clip(t,e,n){return yG("clip")}abs(t){return yG("abs")}complexAbs(t){return yG("complexAbs")}sigmoid(t){return yG("sigmoid")}softplus(t){return yG("softplus")}sin(t){return yG("sin")}cos(t){return yG("cos")}tan(t){return yG("tan")}asin(t){return yG("asin")}acos(t){return yG("acos")}atan(t){return yG("atan")}atan2(t,e){return yG("atan2")}sinh(t){return yG("sinh")}cosh(t){return yG("cosh")}tanh(t){return yG("tanh")}asinh(t){return yG("asinh")}acosh(t){return yG("acosh")}atanh(t){return yG("atanh")}erf(t){return yG("erf")}step(t,e){return yG("step")}fusedConv2d({}){return yG("fusedConv2d")}conv2d(t,e,n){return yG("conv2d")}conv2dDerInput(t,e,n){return yG("conv2dDerInput")}conv2dDerFilter(t,e,n){return yG("conv2dDerFilter")}fusedDepthwiseConv2D({}){return yG("fusedDepthwiseConv2D")}depthwiseConv2D(t,e,n){return yG("depthwiseConv2D")}depthwiseConv2DDerInput(t,e,n){return yG("depthwiseConv2DDerInput")}depthwiseConv2DDerFilter(t,e,n){return yG("depthwiseConv2DDerFilter")}conv3d(t,e,n){return yG("conv3d")}conv3dDerInput(t,e,n){return yG("conv3dDerInput")}conv3dDerFilter(t,e,n){return yG("conv3dDerFilter")}maxPool(t,e){return yG("maxPool")}maxPoolBackprop(t,e,n,r){return yG("maxPoolBackprop")}avgPool(t,e){return yG("avgPool")}avgPoolBackprop(t,e,n){return yG("avgPoolBackprop")}avgPool3d(t,e){return yG("avgPool3d")}avgPool3dBackprop(t,e,n){return yG("avgPool3dBackprop")}maxPool3d(t,e){return yG("maxPool3d")}maxPool3dBackprop(t,e,n,r){return yG("maxPool3dBackprop")}reshape(t,e){return yG("reshape")}cast(t,e){return yG("cast")}tile(t,e){return yG("tile")}pad(t,e,n){return yG("pad")}transpose(t,e){return yG("transpose")}gather(t,e,n){return yG("gather")}gatherND(t,e){return yG("gatherND")}scatterND(t,e,n){return yG("scatterND")}batchToSpaceND(t,e,n){return yG("batchToSpaceND")}spaceToBatchND(t,e,n){return yG("spaceToBatchND")}resizeBilinear(t,e,n,r){return yG("resizeBilinear")}resizeBilinearBackprop(t,e,n){return yG("resizeBilinearBackprop")}resizeNearestNeighbor(t,e,n,r){return yG("resizeNearestNeighbor")}resizeNearestNeighborBackprop(t,e,n){return yG("resizeNearestNeighborBackprop")}batchNorm(t,e,n,r,i,s){return yG("batchNorm")}localResponseNormalization4D(t,e,n,r,i){return yG("localResponseNormalization4D")}LRNGrad(t,e,n,r,i,s,o){return yG("LRNGrad")}multinomial(t,e,n,r){return yG("multinomial")}oneHot(t,e,n,r){return yG("oneHot")}cumsum(t,e,n,r){return yG("cumsum")}nonMaxSuppression(t,e,n,r,i){return yG("nonMaxSuppression")}fft(t){return yG("fft")}ifft(t){return yG("ifft")}complex(t,e){return yG("complex")}real(t){return yG("real")}imag(t){return yG("imag")}cropAndResize(t,e,n,r,i,s){return yG("cropAndResize")}depthToSpace(t,e,n){return yG("depthToSpace")}split(t,e,n){return yG("split")}sparseToDense(t,e,n,r){return yG("sparseToDense")}diag(t){return yG("diag")}fill(t,e,n){return yG("fill")}onesLike(t){return yG("onesLike")}zerosLike(t){return yG("zerosLike")}linspace(t,e,n){return yG("linspace")}dispose(){return yG("dispose")}}function yG(t){throw new Error(`'${t}' not yet implemented or not found in the registry. Did you forget to import the kernel?`)}const vG={kernelName:"Abs",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>yB(t,AU(U$(n,"float32"),-1))}}},bG={kernelName:WD,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=CV(U$(n,"float32")),r=SU(lV(Wz(1),e));return iV(pz(t,r))}}}},_G={kernelName:jD,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=SU(lV(CV(U$(n,"float32")),1));return pz(t,e)}}}},xG={kernelName:GD,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=gz(n.shape,r.shape);return{a:()=>{let e=t;const r=mz(n.shape,i);return r.length>0&&(e=cV(e,r)),I$(e,n.shape)},b:()=>{let e=t;const n=mz(r.shape,i);return n.length>0&&(e=cV(e,n)),I$(e,r.shape)}}}},wG={kernelName:qD,saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach((e,r)=>{n[r]=()=>t.clone()}),n}},SG={kernelName:XD,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bz(n)}}},EG={kernelName:KD,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bz(n)}}},CG={kernelName:YD,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>pz(t,SU(lV(Wz(1),CV(U$(n,"float32")))))}}},TG={kernelName:ZD,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=SU(x$(Wz(1),CV(U$(n,"float32"))));return pz(t,e)}}}},AG={kernelName:tL,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=gz(n.shape,r.shape);return{a:()=>{const e=x$(CV(n),CV(r));let s=yB(t,pz(r,e));const o=mz(n.shape,i);return o.length>0&&(s=cV(s,o)),I$(s,n.shape)},b:()=>{const e=x$(CV(n),CV(r));let s=iV(yB(t,pz(n,e)));const o=mz(r.shape,i);return o.length>0&&(s=cV(s,o)),I$(s,r.shape)}}}},MG={kernelName:JD,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>pz(t,x$(CV(U$(n,"float32")),1))}}},kG={kernelName:QD,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>pz(t,lV(Wz(1),CV(U$(n,"float32"))))}}},RG=y$({avgPool3dBackprop_:function(t,e,n,r,i=[1,1,1],s,o){const a=m$(t,"dy","avgPool3dBackprop"),l=m$(e,"input","avgPool3dBackprop");let c=a,u=l,h=!1;4===l.rank&&(h=!0,c=I$(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),u=I$(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),UF(5===c.rank,()=>`Error in avgPool3dBackprop: dy must be rank 5 but got rank ${c.rank}.`),UF(5===u.rank,()=>`Error in avgPool3dBackprop: input must be rank 5 but got rank ${u.rank}.`),UF(tB(r,i),()=>`Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`),null!=o&&UF(KF(s),()=>`Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`);const d=o$.runKernelFunc(t=>{const e=j$(u.shape,n,r,i,s,o);return t.avgPool3dBackprop(c,u,e)},{dy:c,input:u},null,"AvgPool3DBackprop",{filterSize:n,strides:r,dilations:i,pad:s,dimRoundingMode:o});return h?I$(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),IG={kernelName:nL,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:i,strides:s,dilations:o,pad:a,dimRoundingMode:l}=n,c=null==o?[1,1,1]:o;return{x:()=>RG(t,r,i,s,c,a,l)}}},NG=y$({avgPoolBackprop_:function(t,e,n,r,i){const s=m$(t,"dy","avgPoolBackprop"),o=m$(e,"input","avgPoolBackprop");UF(o.rank===s.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${s.rank})`);let a=o,l=s,c=!1;3===o.rank&&(c=!0,a=I$(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=I$(s,[1,s.shape[0],s.shape[1],s.shape[2]])),UF(4===l.rank,()=>`Error in avgPoolBackprop: dy must be rank 4 but got rank ${l.rank}.`),UF(4===a.rank,()=>`Error in avgPoolBackprop: input must be rank 4 but got rank ${a.rank}.`);const u=o$.runKernelFunc(t=>{const e=W$(a.shape,n,r,1,i);return t.avgPoolBackprop(l,a,e)},{dy:l,input:a},null,"AvgPoolBackprop",{filterSize:n,strides:r,pad:i});return c?I$(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),OG={kernelName:eL,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:i,strides:s,pad:o}=n;return{x:()=>NG(t,r,i,s,o)}}},DG={kernelName:rL,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[r,i]=e,{transposeA:s,transposeB:o}=n;return s||o?!s&&o?{a:()=>gB(t,i,!1,!1),b:()=>gB(t,r,!0,!1)}:s&&!o?{a:()=>gB(i,t,!1,!0),b:()=>gB(r,t,!1,!1)}:{a:()=>gB(i,t,!0,!0),b:()=>gB(t,r,!0,!0)}:{a:()=>gB(t,i,!1,!0),b:()=>gB(r,t,!0,!1)}}},LG={kernelName:iL,gradFunc:(t,e,n)=>{const{blockShape:r,crops:i}=n;return{x:()=>$V(t,r,i)}}},FG={kernelName:sL,gradFunc:(t,e,n)=>{const r=n.inputShape,i=n.shape,s=Array.from(i);for(let a=r.length-1;a>=0;a--)if(r[a]===i[a])s[a]=1;else if(1!==r[a])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${i}].`);const o=[];for(let a=0;a<s.length;a++)s[a]>1&&o.push(a);return{x:()=>cV(t,o,!0)}}},PG={kernelName:oL,gradFunc:t=>({x:()=>t.clone()})},$G={kernelName:aL,gradFunc:t=>({x:()=>bz(t)})},BG={kernelName:lL,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{clipValueMin:i,clipValueMax:s}=n;return{x:()=>vz(dV(Bz(r,i),Jz(r,s)),t,bz(t))}}},zG={kernelName:cL,saveAllInputs:!0,gradFunc:(t,e,n)=>{const r=e.map(t=>t.shape),{axis:i}=n,s=nP(i,e[0].shape)[0],o=r.map(t=>t[s]);return lU(t,o,s).map(t=>()=>t)}},VG={kernelName:uL,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,i]=e,{dilations:s,strides:o,pad:a,dataFormat:l}=n;return UF(Q$(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>tz(r.shape,t,i,o,a,l),filter:()=>yH(r,t,i.shape,o,a,l)}}},UG={kernelName:hL,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[r,i]=e,{strides:s,pad:o,dataFormat:a,dimRoundingMode:l}=n;return{dy:()=>JB(t,i,s,o,a,1,l),filter:()=>yH(t,r,i.shape,s,o,a,l)}}},HG=y$({conv3DBackpropFilter_:function(t,e,n,r,i){let s=t;4===t.rank&&(s=I$(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let o=e;return 4===o.rank&&(o=I$(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),UF(5===s.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),UF(5===o.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),UF(5===n.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),UF(s.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`),UF(o.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${n[4]}).`),o$.runKernelFunc(t=>{const e=q$(s.shape,n,r,1,i);return t.conv3dDerFilter(s,o,e)},{x:s,y:o},null,"Conv3DBackpropFilterV2",{strides:r,pad:i})}}),WG={kernelName:dL,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:i,pad:s}=n;UF(Q$(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[o,a]=e;return{x:()=>rz(o.shape,t,a,i,s),filter:()=>HG(o,t,a.shape,i,s)}}},jG={kernelName:"Cos",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>yB(iV(gU(U$(n,"float32"))),t)}}},GG={kernelName:pL,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>yB(yU(U$(n,"float32")),t)}}},qG={kernelName:fL,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:i,exclusive:s,reverse:o}=n;return{x:()=>{const e=M$([i],r.rank);let n=az(t,i,s,!o);return null!=e&&(n=N$(n,e)),n}}}},XG={kernelName:mL,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:i,pad:s,dimRoundingMode:o}=n,a=null==r?[1,1]:r;UF(Q$(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,c]=e;UF(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),UF(4===c.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),UF(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),UF(tB(i,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${a}'.`),null!=o&&UF(KF(s),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`);const u=G$(l.shape,c.shape,i,a,s,o,!0);return{x:()=>EH(l.shape,t,c,u),filter:()=>SH(l,t,c.shape,u)}}},KG={kernelName:gL,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,i]=e,s={x:r,filter:i,dy:t},o={x:r,filter:i,dy:t};return{x:()=>o$.runKernel(yL,s,n),filter:()=>o$.runKernel(vL,o,n)}}},YG={kernelName:bL,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=gz(n.shape,r.shape);return{a:()=>{const e=pz(t,U$(r,"float32")),s=mz(n.shape,i);return s.length>0?I$(cV(e,s),n.shape):e},b:()=>{let e=yB(t,U$(n,"float32"));const s=mz(r.shape,i);s.length>0&&(e=I$(cV(e,s),r.shape));const o=CV(r);return iV(pz(e,U$(o,"float32")))}}}},ZG={kernelName:"Elu",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,r=e=>e.eluDer(t,n),i={dy:t,y:n};return{x:()=>o$.runKernelFunc(r,i,null,"EluGrad")}}},JG={kernelName:"Erf",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=yB(Ez(iV(CV(n))),2/Math.sqrt(Math.PI));return{x:()=>yB(t,r)}}},QG={kernelName:"Exp",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>yB(t,n)}}},tq={kernelName:_L,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>yB(t,Ez(n))}}},eq={kernelName:wL,gradFunc:t=>({x:()=>bz(t)})},nq={kernelName:SL,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=gz(n.shape,r.shape);return{a:()=>{const e=pz(t,U$(r,"float32")),s=mz(n.shape,i);return s.length>0?I$(cV(e,s),n.shape):e},b:()=>{let e=yB(t,U$(n,"float32"));const s=mz(r.shape,i);s.length>0&&(e=I$(cV(e,s),r.shape));const o=CV(r);return iV(pz(e,U$(o,"float32")))}}}},rq={kernelName:EL,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:r}=n,[i,s,o,a]=e,l=null==a?Wz(1):a,c=mz(s.shape,i.shape),u=[];if(1===s.rank){for(let t=0;t<i.shape.length-1;++t)u.push(i.shape[t]);u.push(1)}const h=lV(i,s),d=yB(t,l),p=hU(x$(o,Wz(r))),f=yB(yB(yB(p,p),p),Wz(-.5));return{x:()=>I$(yB(yB(t,1===s.rank?Az(I$(p,[1,1,1,s.shape[0]]),u):p),l),i.shape),mean:()=>{let t=yB(yB(p,Wz(-1)),d);return 1===s.rank&&(t=cV(t,c)),I$(t,s.shape)},variance:()=>{let t=yB(yB(f,h),d);return 1===s.rank&&(t=cV(t,c)),I$(t,s.shape)},scale:()=>{const e=yB(h,p);let n=yB(t,e);return 1===s.rank&&(n=cV(n,c)),I$(n,s.shape)},offset:()=>{let e=t;return 1===s.rank&&(e=cV(e,c)),I$(e,s.shape)}}}},iq={kernelName:CL,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[r,i]=e,{axis:s}=n,o=nP(s,r.shape)[0];return{x:()=>{const e=r.shape,n=i.size,a=e.slice(0,o),l=a.length,c=e.slice(s,e.length).slice(1),u=c.length,h=sq(0,l),d=sq(l+1,l+1+u),p=oq([a,[n],c]),f=I$(t,p),m=I$(i,[n]),g=oq([[l],h,d]),y=N$(f,g);let v=PU(y,m,r.shape[o]);const b=k$(g);return v=N$(v,b),v},indices:()=>i}}};function sq(t,e){const n=[];for(let r=t;r<e;++r)n.push(r);return n}function oq(t){const e=[];for(let n=0;n<t.length;++n)for(let r=0;r<t[n].length;++r)e.push(t[n][r]);return e}const aq={kernelName:TL,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>bz(n),b:()=>bz(r)}}},lq={kernelName:AL,gradFunc:t=>({x:()=>U$(t,"float32")})},cq={kernelName:ML,gradFunc:t=>({x:()=>bz(t)})},uq={kernelName:kL,gradFunc:t=>({x:()=>bz(t)})},hq={kernelName:RL,gradFunc:t=>({x:()=>bz(t)})},dq={kernelName:IL,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>pz(t,x$(n,1))}}},pq={kernelName:"Log",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>pz(t,U$(n,"float32"))}}},fq={kernelName:NL,inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{axis:i}=n;return{logits:()=>{const e=Ez(r);return lV(t,yB(cV(t,i,!0),e))}}}},mq=y$({localResponseNormalizationBackprop_:function(t,e,n,r=5,i=1,s=1,o=.5){return o$.runKernelFunc(a=>a.LRNGrad(n,t,e,r,i,s,o),{x:t,y:e,dy:n},null,"LRNBackprop",{depthRadius:r,bias:i,alpha:s,beta:o})}}),gq={kernelName:"LRN",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,i]=e,{depthRadius:s,bias:o,alpha:a,beta:l}=n;return{x:()=>mq(r,i,t,s,o,a,l)}}};function yq(t,e,n,r,i){return e.rank<n.rank&&(e=I$(e,T$(e.shape,r))),t.rank<n.rank&&(t=I$(t,T$(t.shape,r))),{x:()=>{const r=yB(t,U$(yz(n,e),t.dtype));return null==i?r:N$(r,i)}}}const vq={kernelName:OL,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{reductionIndices:i}=r,[s,o]=e,a=nP(i,s.shape),l=M$(a,s.rank),c=yq(t,o,s,a,l);return{x:()=>{let t=c.x();return null!=l&&(t=N$(t)),t}}}},bq={kernelName:DL,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>yB(t,U$(Bz(n,r),"float32")),b:()=>yB(t,U$(Zz(n,r),"float32"))}}},_q=y$({maxPool3dBackprop_:function(t,e,n,r,i,s=[1,1,1],o,a){const l=m$(t,"dy","maxPool3dBackprop"),c=m$(e,"input","maxPool3dBackprop"),u=m$(n,"output","maxPool3dBackprop");let h=l,d=c,p=u,f=!1;4===c.rank&&(f=!0,h=I$(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=I$(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),p=I$(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),UF(5===h.rank,()=>`Error in maxPool3dBackprop: dy must be rank 5 but got rank ${h.rank}.`),UF(5===d.rank,()=>`Error in maxPool3dBackprop: input must be rank 5 but got rank ${d.rank}.`),UF(5===p.rank,()=>`Error in maxPool3dBackprop: output must be rank 5 but got rank ${p.rank}.`),UF(tB(i,s),()=>`Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides ${i} and dilations '${s}'`),null!=a&&UF(KF(o),()=>`Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode ${a} but got pad ${o}.`);const m=o$.runKernelFunc(t=>{const e=j$(d.shape,r,i,s,o,a);return t.maxPool3dBackprop(h,d,p,e)},{dy:h,input:d,output:p},null,"MaxPool3DBackprop",{filterSize:r,strides:i,dilations:s,pad:o,dimRoundingMode:a});return f?I$(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),xq={kernelName:FL,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,i]=e,{filterSize:s,strides:o,dilations:a,pad:l,dimRoundingMode:c}=n,u=null==a?[1,1,1]:a;return{x:()=>_q(t,r,i,s,o,u,l,c)}}},wq=y$({maxPoolBackprop_:function(t,e,n,r,i,s,o){const a=m$(t,"dy","maxPoolBackprop"),l=m$(e,"input","maxPoolBackprop"),c=m$(n,"output","maxPoolBackprop");return UF(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),UF(4===a.rank,()=>`Error in maxPoolBackprop: dy must be rank 4 but got rank ${a.rank}.`),UF(4===l.rank,()=>`Error in maxPoolBackprop: input must be rank 4 but got rank ${l.rank}.`),null!=o&&UF(KF(s),()=>`Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`),o$.runKernelFunc(t=>{const e=W$(l.shape,r,i,1,s,o);return t.maxPoolBackprop(a,l,c,e)},{dy:a,input:l,output:c},null,"MaxPoolBackprop",{filterSize:r,strides:i,pad:s,dimRoundingMode:o})}}),Sq={kernelName:GL,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:i}=n,s=i.map(t=>t[0]);return{x:()=>OB(t,s,r.shape)}}},Eq={kernelName:hF,gradFunc:(t,e,n)=>{const{blockShape:r,paddings:i}=n;return{x:()=>FB(t,r,i)}}},Cq={kernelName:dF,gradFunc:(t,e,n)=>{const{axis:r}=n;return{x:()=>mB(t,r)}}},Tq=[vG,bG,_G,xG,wG,SG,EG,CG,TG,AG,MG,kG,IG,OG,DG,LG,FG,PG,$G,BG,zG,UG,VG,WG,jG,GG,qG,XG,KG,YG,ZG,JG,QG,tq,nq,eq,rq,iq,aq,lq,cq,uq,hq,dq,pq,fq,gq,vq,vq,bq,xq,{kernelName:LL,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,i]=e,{filterSize:s,strides:o,pad:a}=n;return{x:()=>wq(t,r,i,s,o,a)}}},{kernelName:"Min",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{axis:i}=r,[s,o]=e,a=nP(i,s.shape),l=M$(a,s.rank),c=yq(t,o,s,a,l);return{x:()=>{let t=c.x();return null!=l&&(t=N$(t)),t}}}},{kernelName:$L,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>yB(t,U$(Jz(n,r),"float32")),b:()=>yB(t,U$($z(n,r),"float32"))}}},{kernelName:"Mod",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=gz(n.shape,r.shape);return{a:()=>{const e=mz(n.shape,i);return e.length>0?I$(cV(t,e),n.shape):t},b:()=>{const e=yB(t,iV(Iz(pz(n,r)))),s=mz(r.shape,i);return s.length>0?I$(cV(e,s),r.shape):e}}}},{kernelName:BL,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=gz(n.shape,r.shape);return{a:()=>{const e=yB(t,U$(r,"float32")),s=mz(n.shape,i);return s.length>0?I$(cV(e,s),n.shape):e},b:()=>{const e=yB(t,U$(n,"float32")),s=mz(r.shape,i);return s.length>0?I$(cV(e,s),r.shape):e}}}},{kernelName:zL,gradFunc:t=>({x:()=>iV(t)})},{kernelName:jL,inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>bV(n.shape,"float32")}}},{kernelName:WL,gradFunc:t=>({x:()=>bz(t)})},Sq,Sq,{kernelName:"Pow",inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,r,i]=e,s=n,o=r,a=gz(s.shape,o.shape);return{a:()=>{const e=U$(o,"float32");let n=yB(t,yB(e,zV(s,lV(e,Wz(1)))));const r=mz(s.shape,a);return r.length>0&&(n=cV(n,r)),I$(n,s.shape)},b:()=>{const e=$z(s,0),n=vz(e,eV(s),bz(s));let r=yB(t,yB(i,n));const l=mz(o.shape,a);return l.length>0&&(r=cV(r,l)),I$(r,o.shape)}}}},{kernelName:qL,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,r]=e,i=$z(n,0);return{x:()=>vz(i,t,yB(t,r)),alpha:()=>{let e=vz(i,bz(t),yB(t,n));const s=mz(r.shape,t.shape);return s.length>0&&(e=cV(e,s)),I$(e,r.shape)}}}},{kernelName:XL,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>pz(t,iV(CV(n)))}}},{kernelName:QL,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=yB(Jz(n,6),AU(n));return{x:()=>yB(t,U$(r,"float32"))}}},{kernelName:KL,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>yB(t,U$(AU(n),"float32"))}}},{kernelName:YL,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>I$(t,n.shape)}}},{kernelName:JL,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,i=e=>{const{alignCorners:i}=n;return e.resizeBilinearBackprop(t,r,i)},s={images:r};return{images:()=>o$.runKernelFunc(i,s,null,"ResizeBilinearGrad",n)}}},{kernelName:ZL,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,i=e=>{const{alignCorners:i}=n;return e.resizeNearestNeighborBackprop(t,r,i)},s={images:r};return{images:()=>o$.runKernelFunc(i,s,null,"ResizeNearestNeighborGrad",n)}}},{kernelName:tF,gradFunc:(t,e,n)=>{const{dims:r}=n,i=nP(r,t.shape);return{x:()=>Hz(t,i)}}},{kernelName:eF,gradFunc:t=>({x:()=>bz(t)})},{kernelName:nF,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>iV(pz(t,yB(zV(n,1.5),2)))}}},{kernelName:rF,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>U$(bz(n),"float32"),t:()=>yB(t,U$(n,t.dtype)),e:()=>yB(t,U$(pV(n),t.dtype))}}},{kernelName:iF,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=$z(n,Wz(0)),r=Wz(jj),i=Wz(Gj),s=yB(t,i),o=yB(yB(t,r),Ez(U$(n,"float32")));return vz(e,s,o)}}}},{kernelName:lF,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>yB(t,yB(n,lV(Wz(1),n)))}}},{kernelName:aF,gradFunc:t=>({x:()=>bz(t)})},{kernelName:"Sin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>yB(sz(U$(n,"float32")),t)}}},{kernelName:oF,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>yB(oz(U$(n,"float32")),t)}}},{kernelName:sF,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{begin:i,size:s}=n,o=r.shape,[a,l]=NB(r,i,s),c=[];for(let u=0;u<t.rank;u++)c.push([a[u],o[u]-a[u]-l[u]]);return{x:()=>OV(t,c)}}},{kernelName:pF,outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{dim:i}=n,s=yB(t,r);return{logits:()=>lV(s,yB(cV(s,[i],!0),r))}}},{kernelName:cF,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>yB(t,vB(n))}}},Eq,Eq,Cq,Cq,{kernelName:uF,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>pz(t,yB(SU(U$(n,"float32")),2))}}},{kernelName:fF,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=Wz(2);return{a:()=>yB(t,yB(i,lV(n,r))),b:()=>yB(t,yB(i,lV(r,n)))}}},{kernelName:mF,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>yB(t,yB(U$(n,"float32"),2))}}},{kernelName:wF,gradFunc:t=>({x:()=>bz(t)})},{kernelName:"Sub",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=gz(n.shape,r.shape);return{a:()=>{let e=t;const r=mz(n.shape,i);return r.length>0&&(e=cV(e,r)),I$(e,n.shape)},b:()=>{let e=t;const n=mz(r.shape,i);return n.length>0&&(e=cV(e,n)),I$(iV(e),r.shape)}}}},{kernelName:"Sum",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,i=r.shape.slice(),{axis:s}=n;nP(s,r.shape).forEach(t=>{i[t]=1});const o=I$(t,i),a=yB(o,_V(r.shape,"float32"));return{x:()=>a}}},{kernelName:"Tan",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>pz(t,CV(sz(n)))}}},{kernelName:gF,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>yB(lV(Wz(1),CV(n)),t)}}},{kernelName:yF,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{reps:i}=n;return{x:()=>{let e=bz(r);if(1===r.rank)for(let n=0;n<i[0];++n)e=x$(e,OB(t,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<i[0];++n)for(let s=0;s<i[1];++s)e=x$(e,OB(t,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<i[0];++n)for(let s=0;s<i[1];++s)for(let o=0;o<i[2];++o)e=x$(e,OB(t,[n*r.shape[0],s*r.shape[1],o*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<i[0];++n)for(let s=0;s<i[1];++s)for(let o=0;o<i[2];++o)for(let a=0;a<i[3];++a)e=x$(e,OB(t,[n*r.shape[0],s*r.shape[1],o*r.shape[2],a*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return e}}}},{kernelName:vF,gradFunc:(t,e,n)=>{const r=n,{perm:i}=r,s=k$(i);return{x:()=>N$(t,s)}}},{kernelName:bF,gradFunc:(t,e,n)=>{const r=n,{axis:i}=r;return{value:()=>TU(t,i)}}},{kernelName:_F,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>function(t,e){const n=Kz(e,bz(e)),r=Pz(t,n);let i=Bz(e,Wz(0,"int32"));const s=r.rank-i.rank;for(let a=0;a<s;++a)i=Cz(i,a+1);i=dV(i,_V(r.shape,"bool"));const o=bz(r);return vz(i,r,o)}(t,n)}}},{kernelName:xF,gradFunc:t=>({x:()=>bz(t)})}];for(const H3 of Tq)DF(H3);let Aq;function Mq(){return null==Aq&&(Aq=o$.backend.epsilon()),Aq}HP.prototype.abs=function(){return this.throwIfDisposed(),v$(this)},HP.prototype.acos=function(){return this.throwIfDisposed(),b$(this)},HP.prototype.acosh=function(){return this.throwIfDisposed(),_$(this)},HP.prototype.addStrict=function(t){return this.throwIfDisposed(),KU(this,t)},HP.prototype.add=function(t){return this.throwIfDisposed(),x$(this,t)},HP.prototype.all=function(t,e){return this.throwIfDisposed(),O$(this,t,e)},HP.prototype.any=function(t,e){return this.throwIfDisposed(),D$(this,t,e)},HP.prototype.argMax=function(t){return this.throwIfDisposed(),L$(this,t)},HP.prototype.argMin=function(t){return this.throwIfDisposed(),F$(this,t)},HP.prototype.asScalar=function(){return this.throwIfDisposed(),UF(1===this.size,()=>"The array must have only 1 element."),I$(this,[])},HP.prototype.asType=function(t){return this.throwIfDisposed(),U$(this,t)},HP.prototype.as1D=function(){return this.throwIfDisposed(),I$(this,[this.size])},HP.prototype.as2D=function(t,e){return this.throwIfDisposed(),I$(this,[t,e])},HP.prototype.as3D=function(t,e,n){return this.throwIfDisposed(),I$(this,[t,e,n])},HP.prototype.as4D=function(t,e,n,r){return this.throwIfDisposed(),I$(this,[t,e,n,r])},HP.prototype.as5D=function(t,e,n,r,i){return this.throwIfDisposed(),I$(this,[t,e,n,r,i])},HP.prototype.asin=function(){return this.throwIfDisposed(),P$(this)},HP.prototype.asinh=function(){return this.throwIfDisposed(),$$(this)},HP.prototype.atan=function(){return this.throwIfDisposed(),B$(this)},HP.prototype.atan2=function(t){return this.throwIfDisposed(),z$(this,t)},HP.prototype.atanh=function(){return this.throwIfDisposed(),V$(this)},HP.prototype.avgPool=function(t,e,n,r){return this.throwIfDisposed(),nB(this,t,e,n,r)},HP.prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),FB(this,t,e)},HP.prototype.batchNorm=function(t,e,n,r,i){return this.throwIfDisposed(),$B(this,t,e,n,r,i)},HP.prototype.broadcastTo=function(t){return this.throwIfDisposed(),HB(this,t)},HP.prototype.cast=function(t){return this.throwIfDisposed(),U$(this,t)},HP.prototype.ceil=function(){return this.throwIfDisposed(),jB(this)},HP.prototype.clipByValue=function(t,e){return this.throwIfDisposed(),GB(this,t,e)},HP.prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof HP&&(t=[t]),mB([this,...t],e)},HP.prototype.conv1d=function(t,e,n,r,i,s){return this.throwIfDisposed(),QB(this,t,e,n,r,i,s)},HP.prototype.conv2dTranspose=function(t,e,n,r,i){return this.throwIfDisposed(),ez(this,t,e,n,r,i)},HP.prototype.conv2d=function(t,e,n,r,i,s){return this.throwIfDisposed(),JB(this,t,e,n,r,i,s)},HP.prototype.cos=function(){return this.throwIfDisposed(),sz(this)},HP.prototype.cosh=function(){return this.throwIfDisposed(),oz(this)},HP.prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),az(this,t,e,n)},HP.prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),lz(this,t,e)},HP.prototype.depthwiseConv2D=function(t,e,n,r,i,s){return rB("depthwiseConv2D is deprecated, use depthwiseConv2d instead"),this.throwIfDisposed(),cz(this,t,e,n,r,i,s)},HP.prototype.depthwiseConv2d=function(t,e,n,r,i,s){return this.throwIfDisposed(),cz(this,t,e,n,r,i,s)},HP.prototype.dilation2d=function(t,e,n,r,i){return this.throwIfDisposed(),hz(this,t,e,n,r,i)},HP.prototype.divNoNan=function(t){return this.throwIfDisposed(),_z(this,t)},HP.prototype.divStrict=function(t){return this.throwIfDisposed(),YU(this,t)},HP.prototype.div=function(t){return this.throwIfDisposed(),pz(this,t)},HP.prototype.dot=function(t){return this.throwIfDisposed(),xz(this,t)},HP.prototype.elu=function(){return this.throwIfDisposed(),wz(this)},HP.prototype.equalStrict=function(t){return this.throwIfDisposed(),HU(this,t)},HP.prototype.equal=function(t){return this.throwIfDisposed(),yz(this,t)},HP.prototype.erf=function(){return this.throwIfDisposed(),Sz(this)},HP.prototype.exp=function(){return this.throwIfDisposed(),Ez(this)},HP.prototype.expandDims=function(t){return this.throwIfDisposed(),Cz(this,t)},HP.prototype.expm1=function(){return this.throwIfDisposed(),Tz(this)},HP.prototype.fft=function(){return this.throwIfDisposed(),kz(this)},HP.prototype.flatten=function(){return this.throwIfDisposed(),I$(this,[this.size])},HP.prototype.floor=function(){return this.throwIfDisposed(),Iz(this)},HP.prototype.floorDiv=function(t){return this.throwIfDisposed(),dz(this,t)},HP.prototype.gather=function(t,e){return this.throwIfDisposed(),Pz(this,t,e)},HP.prototype.greaterEqualStrict=function(t){return this.throwIfDisposed(),WU(this,t)},HP.prototype.greaterEqual=function(t){return this.throwIfDisposed(),Bz(this,t)},HP.prototype.greaterStrict=function(t){return this.throwIfDisposed(),jU(this,t)},HP.prototype.greater=function(t){return this.throwIfDisposed(),$z(this,t)},HP.prototype.ifft=function(){return this.throwIfDisposed(),zz(this)},HP.prototype.irfft=function(){return this.throwIfDisposed(),jz(this)},HP.prototype.isFinite=function(){return this.throwIfDisposed(),Gz(this)},HP.prototype.isInf=function(){return this.throwIfDisposed(),qz(this)},HP.prototype.isNaN=function(){return this.throwIfDisposed(),Xz(this)},HP.prototype.leakyRelu=function(t){return this.throwIfDisposed(),Yz(this,t)},HP.prototype.lessEqualStrict=function(t){return this.throwIfDisposed(),GU(this,t)},HP.prototype.lessEqual=function(t){return this.throwIfDisposed(),Jz(this,t)},HP.prototype.lessStrict=function(t){return this.throwIfDisposed(),qU(this,t)},HP.prototype.less=function(t){return this.throwIfDisposed(),Zz(this,t)},HP.prototype.localResponseNormalization=function(t,e,n,r){return this.throwIfDisposed(),tV(this,t,e,n,r)},HP.prototype.logSigmoid=function(){return this.throwIfDisposed(),oV(this)},HP.prototype.logSoftmax=function(t){return this.throwIfDisposed(),uV(this,t)},HP.prototype.logSumExp=function(t,e){return this.throwIfDisposed(),hV(this,t,e)},HP.prototype.log=function(){return this.throwIfDisposed(),eV(this)},HP.prototype.log1p=function(){return this.throwIfDisposed(),nV(this)},HP.prototype.logicalAnd=function(t){return this.throwIfDisposed(),dV(this,t)},HP.prototype.logicalNot=function(){return this.throwIfDisposed(),pV(this)},HP.prototype.logicalOr=function(t){return this.throwIfDisposed(),fV(this,t)},HP.prototype.logicalXor=function(t){return this.throwIfDisposed(),mV(this,t)},HP.prototype.matMul=function(t,e,n){return this.throwIfDisposed(),gB(this,t,e,n)},HP.prototype.maxPool=function(t,e,n,r){return this.throwIfDisposed(),gV(this,t,e,n,r)},HP.prototype.max=function(t,e){return this.throwIfDisposed(),aV(this,t,e)},HP.prototype.maximumStrict=function(t){return this.throwIfDisposed(),ZU(this,t)},HP.prototype.maximum=function(t){return this.throwIfDisposed(),Kz(this,t)},HP.prototype.mean=function(t,e){return this.throwIfDisposed(),xV(this,t,e)},HP.prototype.min=function(t,e){return this.throwIfDisposed(),wV(this,t,e)},HP.prototype.minimumStrict=function(t){return this.throwIfDisposed(),JU(this,t)},HP.prototype.minimum=function(t){return this.throwIfDisposed(),SV(this,t)},HP.prototype.modStrict=function(t){return this.throwIfDisposed(),QU(this,t)},HP.prototype.mod=function(t){return this.throwIfDisposed(),EV(this,t)},HP.prototype.mulStrict=function(t){return this.throwIfDisposed(),tH(this,t)},HP.prototype.mul=function(t){return this.throwIfDisposed(),yB(this,t)},HP.prototype.neg=function(){return this.throwIfDisposed(),iV(this)},HP.prototype.norm=function(t,e,n){return this.throwIfDisposed(),sH(this,t,e,n)},HP.prototype.notEqualStrict=function(t){return this.throwIfDisposed(),XU(this,t)},HP.prototype.notEqual=function(t){return this.throwIfDisposed(),kV(this,t)},HP.prototype.oneHot=function(t,e=1,n=0){return this.throwIfDisposed(),RV(this,t,e,n)},HP.prototype.onesLike=function(){return this.throwIfDisposed(),IV(this)},HP.prototype.pad=function(t,e){return this.throwIfDisposed(),OV(this,t,e)},HP.prototype.pool=function(t,e,n,r,i){return this.throwIfDisposed(),BV(this,t,e,n,r,i)},HP.prototype.powStrict=function(t){return this.throwIfDisposed(),eH(this,t)},HP.prototype.pow=function(t){return this.throwIfDisposed(),zV(this,t)},HP.prototype.prelu=function(t){return this.throwIfDisposed(),VV(this,t)},HP.prototype.prod=function(t,e){return this.throwIfDisposed(),HV(this,t,e)},HP.prototype.reciprocal=function(){return this.throwIfDisposed(),tU(this)},HP.prototype.relu=function(){return this.throwIfDisposed(),eU(this)},HP.prototype.relu6=function(){return this.throwIfDisposed(),nU(this)},HP.prototype.reshapeAs=function(t){return this.throwIfDisposed(),I$(this,t.shape)},HP.prototype.reshape=function(t){return this.throwIfDisposed(),I$(this,t)},HP.prototype.resizeBilinear=function(t,e){return this.throwIfDisposed(),qH(this,t,e)},HP.prototype.resizeNearestNeighbor=function(t,e){return this.throwIfDisposed(),XH(this,t,e)},HP.prototype.reverse=function(t){return this.throwIfDisposed(),Hz(this,t)},HP.prototype.rfft=function(){return this.throwIfDisposed(),cU(this)},HP.prototype.round=function(){return this.throwIfDisposed(),uU(this)},HP.prototype.rsqrt=function(){return this.throwIfDisposed(),hU(this)},HP.prototype.selu=function(){return this.throwIfDisposed(),dU(this)},HP.prototype.separableConv2d=function(t,e,n,r,i,s){return this.throwIfDisposed(),pU(this,t,e,n,r,i,s)},HP.prototype.sigmoid=function(){return this.throwIfDisposed(),vB(this)},HP.prototype.sign=function(){return this.throwIfDisposed(),mU(this)},HP.prototype.sin=function(){return this.throwIfDisposed(),gU(this)},HP.prototype.sinh=function(){return this.throwIfDisposed(),yU(this)},HP.prototype.slice=function(t,e){return this.throwIfDisposed(),OB(this,t,e)},HP.prototype.softmax=function(t){return this.throwIfDisposed(),wU(this,t)},HP.prototype.softplus=function(){return this.throwIfDisposed(),sV(this)},HP.prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),$V(this,t,e)},HP.prototype.split=function(t,e){return this.throwIfDisposed(),lU(this,t,e)},HP.prototype.sqrt=function(){return this.throwIfDisposed(),SU(this)},HP.prototype.square=function(){return this.throwIfDisposed(),CV(this)},HP.prototype.squaredDifference=function(t){return this.throwIfDisposed(),EU(this,t)},HP.prototype.squaredDifferenceStrict=function(t){return this.throwIfDisposed(),nH(this,t)},HP.prototype.squeeze=function(t){return this.throwIfDisposed(),CU(this,t)},HP.prototype.stack=function(t,e){this.throwIfDisposed();const n=t instanceof HP?[this,t]:[this,...t];return TU(n,e)},HP.prototype.step=function(t){return this.throwIfDisposed(),AU(this,t)},HP.prototype.stridedSlice=function(t,e,n,r,i,s,o,a){return this.throwIfDisposed(),MU(this,t,e,n,r,i,s,o,a)},HP.prototype.subStrict=function(t){return this.throwIfDisposed(),rH(this,t)},HP.prototype.sub=function(t){return this.throwIfDisposed(),lV(this,t)},HP.prototype.sum=function(t,e){return this.throwIfDisposed(),cV(this,t,e)},HP.prototype.tan=function(){return this.throwIfDisposed(),kU(this)},HP.prototype.tanh=function(){return this.throwIfDisposed(),DB(this)},HP.prototype.tile=function(t){return this.throwIfDisposed(),Az(this,t)},HP.prototype.toBool=function(){return this.throwIfDisposed(),U$(this,"bool")},HP.prototype.toFloat=function(){return this.throwIfDisposed(),U$(this,"float32")},HP.prototype.toInt=function(){return this.throwIfDisposed(),U$(this,"int32")},HP.prototype.topk=function(t,e){return this.throwIfDisposed(),LU(this,t,e)},HP.prototype.transpose=function(t){return this.throwIfDisposed(),N$(this,t)},HP.prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),PU(this,t,e)},HP.prototype.unstack=function(t){return this.throwIfDisposed(),$U(this,t)},HP.prototype.where=function(t,e){return this.throwIfDisposed(),vz(t,this,e)},HP.prototype.zerosLike=function(){return this.throwIfDisposed(),bz(this)};class kq extends Error{constructor(t){super(t),Object.setPrototypeOf(this,kq.prototype)}}class Rq extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Rq.prototype)}}class Iq extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Iq.prototype)}}class Nq extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Nq.prototype)}}class Oq extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Oq.prototype)}}function Dq(t,e){if(Array.isArray(t)){let n=[];for(let r=0;r<e;r++)n=n.concat(t);return n}{const n=new Array(e);return n.fill(t),n}}function Lq(t,e){if(!t)throw new Oq(e)}function Fq(t,e){let n=0;for(const r of t)r===e&&n++;return n}function Pq(t){return 1===t.length?t[0]:t}function $q(t){return Array.isArray(t)?t:[t]}function Bq(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function zq(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}Error;let Vq={};function Uq(t){if(null==t)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function Hq(t){if(null!=t&&"object"==typeof t)if(Array.isArray(t))t.forEach(t=>Hq(t));else{const e=Object.keys(t);for(const n of e){const e=t[n];null!=e&&"object"==typeof e&&(Array.isArray(e)||"ndarray"!==e.type||"number"!=typeof e.value?Hq(e):t[n]=e.value)}}}function Wq(t,e={},n={},r="object",i=!1){if("string"==typeof t){const i=t;let s;if(i in n)s=n[i];else if(i in Vq)s=Vq[i];else if(s=e[i],null==s)throw new Iq(`Unknown ${r}: ${t}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return s}{const s=t;if(null==s.className||null==s.config)throw new Iq(`${r}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);const o=s.className;let a,l;if(o in n?[a,l]=n[o]:o in Vq?[a,l]=Vq.className:o in e&&([a,l]=e[o]),null==a)throw new Iq(`Unknown ${r}: ${o}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const t={};for(const n of Object.keys(Vq))t[n]=Vq[n];for(const i of Object.keys(n))t[i]=n[i];s.config.customObjects=t;const e=Object.assign({},Vq);for(const i of Object.keys(n))Vq[i]=n[i];Hq(s.config);const r=l(a,s.config,n,i);return Vq=Object.assign({},e),r}{const t=Object.assign({},Vq);for(const r of Object.keys(n))Vq[r]=n[r];const e=new a(s.config);return Vq=Object.assign({},t),e}}}function jq(t,e){return-1*function(t,e){return t<e?-1:t>e?1:0}(t,e)}function Gq(t){if(null==t)return t;const e=[];for(const n of t)-1===e.indexOf(n)&&e.push(n);return e}function qq(t){if(null==t)throw new Iq(`Invalid value in obj: ${JSON.stringify(t)}`);for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function Xq(t,e,n){if(null!=n&&t.indexOf(n)<0)throw new Iq(`${n} is not a valid ${e}.  Valid values are ${t} or null/undefined.`)}function Kq(t,e,n=0,r=1/0){return Lq(n>=0),Lq(r>=n),Array.isArray(t)&&t.length>=n&&t.length<=r&&t.every(t=>typeof t===e)}function Yq(t,e){Array.isArray(t)?(r.assert(t.length>0,()=>`${e} is unexpectedly an empty array.`),t.forEach((t,n)=>Yq(t,`element ${n+1} of ${e}`))):r.assert(Number.isInteger(t)&&t>0,()=>`Expected ${e} to be a positive integer, but got ${Zq(t)}.`)}function Zq(t){return null===t?"null":Array.isArray(t)?"["+t.map(t=>Zq(t)).join(",")+"]":"string"==typeof t?`"${t}"`:`${t}`}function Jq(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}function Qq(t,e){return oB(()=>SU(cV(yB(t,t),e,!0)))}class tX extends d.Serializable{getConfig(){return{}}}class eX extends tX{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return oB(()=>{const e=Qq(t,this.axis),n=GB(e,0,this.maxValue);return yB(t,pz(n,x$(Mq(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}eX.className="MaxNorm",d.registerClass(eX);class nX extends tX{constructor(t){super(),this.defaultAxis=0,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return oB(()=>pz(t,x$(Mq(),Qq(t,this.axis))))}getConfig(){return{axis:this.axis}}}nX.className="UnitNorm",d.registerClass(nX);class rX extends tX{apply(t){return eU(t)}}rX.className="NonNeg",d.registerClass(rX);class iX extends tX{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=t.minValue?t.minValue:this.defaultMinValue,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.rate=null!=t.rate?t.rate:this.defaultRate,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return oB(()=>{const e=Qq(t,this.axis),n=x$(yB(this.rate,GB(e,this.minValue,this.maxValue)),yB(1-this.rate,e));return yB(t,pz(n,x$(Mq(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}iX.className="MinMaxNorm",d.registerClass(iX);const sX={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function oX(t){return Uq(t)}function aX(t,e={}){return Wq(t,d.SerializationMap.getMap().classNameMap,e,"constraint")}function lX(t){return null==t?null:"string"==typeof t?aX({className:t in sX?sX[t]:t,config:{}}):t instanceof tX?t:aX(t)}const cX=["channelsFirst","channelsLast"],uX=["valid","same","causal"],hX=["max","avg"],dX=["sum","mul","concat","ave"],pX=new Map;function fX(t){Xq(cX,"DataFormat",t)}function mX(t){Xq(uX,"PaddingMode",t)}function gX(t){Xq(hX,"PoolMode",t)}const yX=[];function vX(t,e){yX.push(t);try{const t=e();return yX.pop(),t}catch(n){throw yX.pop(),n}}function bX(t){if(!wX(t))throw new Error("Not a valid tensor name: '"+t+"'");return(0===yX.length?"":yX.join("/")+"/")+t}function _X(t){if(!wX(t))throw new Error("Not a valid tensor name: '"+t+"'");pX.has(t)||pX.set(t,0);const e=pX.get(t);if(pX.set(t,pX.get(t)+1),e>0){const n=`${t}_${e}`;return pX.set(n,1),n}return t}const xX=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function wX(t){return!!t.match(xX)}function SX(t,e,n){null==e&&(e=0),null==n&&(n=t.length);let r=1;for(let i=e;i<n;++i)r*=t[i];return r}function EX(t){return JV(t=Array.isArray(t)?new Float32Array(t):t)}function CX(t){return wV(EX(t)).dataSync()[0]}function TX(t){return aV(EX(t)).dataSync()[0]}function AX(t,e){if(e<t)throw new Iq(`end (${e}) < begin (${t}) is forbidden.`);const n=[];for(let r=t;r<e;++r)n.push(r);return n}function MX(t,e){return t.asType(e)}function kX(t,e=-1){const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),t.reshape(n)}function RX(t,e,n){return oB(()=>{switch(t.rank){case 1:return vU(t,e,n);case 2:return bU(t,[e,0],[n,t.shape[1]]);case 3:return _U(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return xU(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return OB(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return OB(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new Iq(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}})}function IX(t,e,n){return oB(()=>{switch(t.rank){case 1:return vU(t,e,n);case 2:return bU(t,[0,e],[t.shape[0],n]);case 3:return _U(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return xU(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new Iq(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function NX(t,e,n,r){return oB(()=>{switch(t.rank){case 1:return vU(t,e,n);case 2:switch(r){case 1:return RX(t,e,n);case 2:return IX(t,e,n);default:throw new Iq(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return RX(t,e,n);case 2:return _U(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return IX(t,e,n);default:throw new Iq(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return RX(t,e,n);case 2:return xU(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return xU(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return IX(t,e,n);default:throw new Iq(`The axis is not within the rank of the tensor ${r}`)}default:throw new Iq(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function OX(t,e=-1){let n;return e<0&&(n=t[0].rank,e=0!==n?n:0),e===t[0].rank&&(e=-1),mB(t,e)}function DX(t,e){switch(t.rank){case 1:return XB([t,e]);case 2:return KB([t,e],0);case 3:return YB([t,e],0);case 4:return ZB([t,e],0);default:throw new Iq(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function LX(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new Iq(`The length of input n (${e.length}) does not match the number of dimensions in input x (${t.rank})`);return Az(t,e)}function FX(t,e=0,n=1,r,i){return YV(t,e,n,r,i)}function PX(t,e,n,r){if(t.rank<2||e.rank<2)throw new Nq(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${e.shape}`);if(e.rank>=3&&t.shape.slice(-1)[0]!==e.shape.slice(-2)[0])throw new Nq(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${e.shape}`);if(2===t.rank&&2===e.rank)return l.matMul({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?zX(t.rank,r,"channelsLast"):null,activation:n});{const i=t.shape.slice(),s=i.pop();t=t.reshape([-1,s]);const o=e.shape.slice(),a=o.pop(),c=o.pop(),u=[...o,a],h=Array.from({length:e.rank},(t,n)=>0===n?e.rank-2:n<=e.rank-2?n-1:n);e=e.transpose(h).reshape([c,-1]);const d=[...i,...u];return l.matMul({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?zX(t.rank,r,"channelsLast"):null,activation:n}).reshape(d)}}function $X(t,e,n){return oB(()=>(e=Array.isArray(e)?JV(e,"int32"):e.toInt(),Pz(t,e,n)))}function BX(t){return yB(t,t)}function zX(t,e,n){const r=e.shape;if(1!==e.rank&&e.rank!==t)throw new Iq(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${t}`);if(5===t){if("channelsFirst"===n)return e.reshape(1===r.length?[1,r[0],1,1,1]:[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return e.reshape(1===r.length?[1,1,1,1,r[0]]:[1].concat(r))}else if(4===t){if("channelsFirst"===n)return e.reshape(1===r.length?[1,r[0],1,1]:[1,r[2],r[0],r[1]]);if("channelsLast"===n)return e.reshape(1===r.length?[1,1,1,r[0]]:[1].concat(r))}else if(3===t){if("channelsFirst"===n)return e.reshape(1===r.length?[1,r[0],1]:[1,r[1],r[0]]);if("channelsLast"===n)return e.reshape(1===r.length?[1,1,r[0]]:[1].concat(r))}else if(t<3)return e;throw new Iq(`Unsupported input rank by biasAdd: ${e.rank}`)}function VX(t,e,n){return oB(()=>(null==n&&(n="channelsLast"),fX(n),t.add(zX(t.rank,e,n))))}function UX(t,e,n,r){return oB(()=>pH(t,e,n,r))}function HX(t,e,n=!1){return n?t():e()}const WX=["fanIn","fanOut","fanAvg"],jX=["normal","uniform","truncatedNormal"];class GX extends d.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class qX extends GX{apply(t,e){return bV(t,e)}}qX.className="Zeros",d.registerClass(qX);class XX extends GX{apply(t,e){return _V(t,e)}}XX.className="Ones",d.registerClass(XX);class KX extends GX{constructor(t){if(super(),"object"!=typeof t)throw new Iq(`Expected argument of type ConstantConfig but got ${t}`);if(void 0===t.value)throw new Iq(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return oB(()=>yB(Wz(this.value),_V(t,e)))}getConfig(){return{value:this.value}}}KX.className="Constant",d.registerClass(KX);class YX extends GX{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return ZV(t,this.minval,this.maxval,e)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}YX.className="RandomUniform",d.registerClass(YX);class ZX extends GX{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new Nq(`randomNormal does not support dType ${e}.`);return FX(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}ZX.className="RandomNormal",d.registerClass(ZX);class JX extends GX{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new Nq(`truncatedNormal does not support dType ${e}.`);return FU(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}JX.className="TruncatedNormal",d.registerClass(JX);class QX extends GX{constructor(t){super(),this.gain=null!=t.gain?t.gain:1}apply(t,e){return oB(()=>{if(2!==t.length||t[0]!==t[1])throw new Iq("Identity matrix initializer can only be used for 2D square matrices.");return yB(this.gain,Mz(t[0]))})}getConfig(){return{gain:this.gain}}}QX.className="Identity",d.registerClass(QX);class tK extends GX{constructor(t){if(super(),t.scale<0)throw new Iq(`scale must be a positive float. Got: ${t.scale}`);this.scale=null==t.scale?1:t.scale,this.mode=null==t.mode?"fanIn":t.mode,Xq(WX,"FanMode",this.mode),this.distribution=null==t.distribution?"normal":t.distribution,Xq(jX,"Distribution",this.distribution),this.seed=t.seed}apply(t,e){const n=function(t,e="channelsLast"){let n,r;if(fX(e),2===t.length)n=t[0],r=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===e){const e=SX(t,2);n=t[1]*e,r=t[0]*e}else if("channelsLast"===e){const e=SX(t,0,t.length-2);n=t[t.length-2]*e,r=t[t.length-1]*e}}else{const e=SX(t);n=Math.sqrt(e),r=Math.sqrt(e)}return[n,r]}(t),r=n[0],i=n[1];let s=this.scale;if(s/="fanIn"===this.mode?Math.max(1,r):"fanOut"===this.mode?Math.max(1,i):Math.max(1,(r+i)/2),"normal"===this.distribution){const n=Math.sqrt(s);if("float32"!==(e=e||"float32")&&"int32"!==e)throw new Nq(`${this.getClassName()} does not support dType ${e}.`);return FU(t,0,n,e,this.seed)}{const n=Math.sqrt(3*s);return ZV(t,-n,n,e)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}tK.className="VarianceScaling",d.registerClass(tK);class eK extends tK{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return tK.className}}eK.className="GlorotUniform",d.registerClass(eK);class nK extends tK{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return tK.className}}nK.className="GlorotNormal",d.registerClass(nK);class rK extends tK{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return tK.className}}rK.className="HeNormal",d.registerClass(rK);class iK extends tK{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return tK.className}}iK.className="HeUniform",d.registerClass(iK);class sK extends tK{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return tK.className}}sK.className="LeCunNormal",d.registerClass(sK);class oK extends tK{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return tK.className}}oK.className="LeCunNormal",d.registerClass(oK);class aK extends GX{constructor(t){if(super(),this.DEFAULT_GAIN=1,this.gain=null==t.gain?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,null!=this.seed)throw new Nq("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,e){return oB(()=>{if(2!==t.length)throw new Nq("The Orthogonal Initializer does not support non-2D shapes yet.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);const e=FX(t[0]>t[1]?[t[1],t[0]]:t,0,1,"float32");let n=dW.gramSchmidt(e);return t[0]>t[1]&&(n=n.transpose()),yB(this.gain,n)})}getConfig(){return{gain:this.gain,seed:this.seed}}}aK.className="Orthogonal",d.registerClass(aK);const lK={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function cK(t,e={}){return Wq(t,d.SerializationMap.getMap().classNameMap,e,"initializer")}function uK(t){return Uq(t)}function hK(t){if("string"==typeof t){const e=t in lK?lK[t]:t;if("GlorotNormal"===e)return new nK;if("GlorotUniform"===e)return new eK;if("HeNormal"===e)return new rK;if("HeUniform"===e)return new iK;if("LeCunNormal"===e)return new sK;if("LeCunUniform"===e)return new oK;{const t={};return t.className=e,t.config={},cK(t)}}return t instanceof GX?t:cK(t)}let dK=0;function pK(){return dK++}const fK={};function mK(t=""){return t in fK||(fK[t]=0),fK[t]+=1,t+fK[t].toString()}function gK(t){return Array.isArray(t)&&Array.isArray(t[0])}function yK(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function vK(t){let e;if(Array.isArray(t)){if(1!==t.length)throw new Iq(`Expected Tensor length to be 1; got ${t.length}`);e=t[0]}else e=t;return e}function bK(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return(t=t)[0];throw new Iq(`Expected exactly 1 Shape; got ${t.length}`)}return t}function _K(t){let e=0;for(const n of t)e+=0===n.shape.length?1:n.shape.reduce((t,e)=>t*e);return e}class xK{constructor(t,e="float32",n="Variable",r=!0,i=null){this.dtype=null==e?"float32":e,this.shape=t.shape,this.id=pK(),this.originalName=bX(n=null==n?"Variable":n),this.name=_X(this.originalName),this.trainable_=r,this.constraint=i,this.val=BU(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function wK(t){return t.map(t=>t.read())}function SK(t){t.forEach(t=>{t[0].write(t[1])})}class EK{constructor(t){this.dtype=t.dtype,this.shape=t.shape,this.ndim=null!=t.shape?t.shape.length:t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class CK{constructor(t,e,n,r,i,s,o){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=r,this.callArgs=i,this.outputTensorIndex=o,this.id=pK(),null!=s&&(this.originalName=bX(s),this.name=_X(this.originalName)),this.rank=e.length}}let TK=0;class AK{constructor(t,e){this.callArgs=e,this.id=TK++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const n of t.inboundLayers)null!=n&&n.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)t.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let MK=0;class kK extends d.Serializable{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=MK++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const t=this.getClassName();e=Bq(t)+"_"+mK(t)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let e;if(null!=t.batchInputShape)e=t.batchInputShape;else if(null!=t.inputShape){let n=null;null!=t.batchSize&&(n=t.batchSize),e=[n].concat(t.inputShape)}this.batchInputShape=e;let n=t.dtype;null==n&&(n=t.inputDType),null==n&&(n="float32"),this.dtype=n}this.initialWeights=null!=t.weights?t.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new Rq(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new Iq(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return Pq(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return Pq(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new kq(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new kq(`Layer ${this.name} is not connected, no input to return.`);return Pq(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new kq(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new kq(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Pq(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=$q(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=$q(this.inputSpec);if(t.length!==e.length)throw new Iq(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let n=0;n<t.length;n++){const r=t[n],i=e[n];if(null==i)continue;const s=r.rank;if(null!=i.ndim&&s!==i.ndim)throw new Iq(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${s}`);if(null!=i.maxNDim&&s>i.maxNDim)throw new Iq(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${s}`);if(null!=i.minNDim&&s<i.minNDim)throw new Iq(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${s}.`);if(null!=i.dtype&&r.dtype!==i.dtype)throw new Iq(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${r.dtype}.`);if(i.axes){const t=r.shape;for(const e in i.axes){const r=Number(e),s=i.axes[e],o=r>=0?t[r]:t[t.length+r];if(null!=s&&-1===[s,null].indexOf(o))throw new Iq(`Input ${n} is incompatible with layer ${this.name}: expected axis ${r} of input shape to have value ${s} but got shape ${t}.`)}}if(null!=i.shape)for(let t=0;t<i.shape.length;++t){const e=i.shape[t],s=r.shape[t];if(null!=e&&null!=s&&e!==s)throw new Iq(`Input ${n} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${r.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const n=$q(t);let r=!0;for(const s of n)if(!(s instanceof CK)){r=!1;break}let i=!0;for(const s of n)if(s instanceof CK){i=!1;break}if(r===i)throw new Iq("Arguments to apply() must be all SymbolicTensors or all Tensors");return vX(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const e=[];for(const n of $q(t))e.push(n.shape);this.build(Pq(e)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&i&&(this._refCount=1)}if(this.assertInputCompatibility(t),i){let r=this.call(t,e);const i=$q(r),s=[];for(let t of i)-1!==n.indexOf(t)&&(t=t.clone()),s.push(t);if(r=Pq(s),null!=this.activityRegularizer)throw new Nq("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(t){t=$q(t);const e=[];for(const n of t)e.push(n.shape);return Pq(e)}(t),r=this.computeOutputShape(n);let i;const s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?n[0]:n),i=null!=r&&r.length>0&&Array.isArray(r[0])?r.map((n,r)=>new CK(s,n,this,$q(t),e,this.name,r)):new CK(s,r,this,$q(t),e,this.name),this.addInboundNode(t,i,null,null,n,r,e),this._refCount++,null!=this.activityRegularizer)throw new Nq("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}})}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((n,r)=>{null!=n&&null!=t[r]&&t[r]!==n&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new kq(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const n=JSON.stringify(e.outputShapes);-1===t.indexOf(n)&&t.push(n)}if(1===t.length){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&1===t.length?t[0]:t}throw new kq(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Rq(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return _K(this.weights)}build(t){this.built=!0}getWeights(t=!1){return wK(t?this.trainableWeights:this.weights)}setWeights(t){oB(()=>{const e=this.weights;if(e.length!==t.length)throw new Iq(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const n=[],i=wK(e);for(let s=0;s<i.length;++s){const o=i[s],a=e[s],l=t[s];if(!r.arraysEqual(o.shape,l.shape))throw new Iq(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);n.push([a,l])}SK(n)})}addWeight(t,e,n,r,i,s,o){if(-1!==this._addedWeightNames.indexOf(t))throw new Iq(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=hK("zeros"));const a=r.apply(e,n),l=new xK(a,n,t,s,o);return a.dispose(),null!=i&&this.addLoss(()=>i.apply(l.read())),null==s&&(s=!0),s?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=$q(t),null!=this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(t=>{if(null!=t)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}addInboundNode(t,e,n,r,i,s,o=null){const a=$q(t);e=$q(e),n=$q(n),r=$q(r),i=yK(i),s=yK(s);const l=[],c=[],u=[];for(const h of a)l.push(h.sourceLayer),c.push(h.nodeIndex),u.push(h.tensorIndex);new AK({outboundLayer:this,inboundLayers:l,nodeIndices:c,tensorIndices:u,inputTensors:a,outputTensors:e,inputMasks:n,outputMasks:r,inputShapes:i,outputShapes:s},o);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function RK(t,e,n){if((null==e||null!=n&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),0===e.inboundNodes.length)return[t];{const t=e.inboundNodes[n];if(0===t.inboundLayers.length)return t.inputTensors;{const e=[];for(let n=0;n<t.inboundLayers.length;n++){const r=RK(t.inputTensors[n],t.inboundLayers[n],t.nodeIndices[n]);for(const t of r)-1===e.indexOf(t)&&e.push(t)}return e}}}class IK extends kK{constructor(t){if(super({dtype:t.dtype,name:null!=t.name?t.name:mK("input").toString()}),null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new Iq("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(null==e){if(null==t.inputShape)throw new Iq("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new Iq("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];const r=new CK(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new AK({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new Iq(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}async function NK(t){if(null==t)return;const e=[],n=[],r=[];for(const i in t){const s=t[i];if("number"!=typeof s){const t=s;e.push(t.data()),n.push(i),r.push(t)}}if(e.length>0){const i=await Promise.all(e);for(let e=0;e<i.length;++e)t[n[e]]=i[e][0];aB(r)}}function OK(t){if(null!=t)for(const e in t){const n=t[e];"number"!=typeof n&&n.dispose()}}var DK;IK.className="InputLayer",d.registerClass(IK),function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"}(DK||(DK={}));class LK{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class FK{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochBegin(t,e)}async onEpochEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochEnd(t,e)}async onBatchBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchBegin(t,e)}async onBatchEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchEnd(t,e)}async onTrainBegin(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class PK extends LK{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){null==e&&(e={});const n=null==e.size?0:e.size;this.seen+=n;for(const r in e){const t=e[r];if("number"==typeof t)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+t*n;else{let e;r in this.totals?e=this.totals[r]:this.totals[r]=0;const i=oB(()=>x$(this.totals[r],yB(t,n)));this.totals[r]=i,null!=e&&e.dispose()}}}async onEpochEnd(t,e){if(null!=e)for(const n of this.params.metrics)null!=this.totals[n]&&("number"==typeof this.totals[n]?e[n]=this.totals[n]/this.seen:oB(()=>{const t=yB(pz(1,this.seen),this.totals[n]);e[n]=t,this.totals[n].dispose(),lB(e[n])}))}}class $K extends LK{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){null==e&&(e={}),this.epoch.push(t);for(const n in e)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(e[n])}async syncData(){const t=[],e=[],n=[];for(const i in this.history){const r=this.history[i];for(let s=0;s<r.length;++s)"number"!=typeof r[s]&&(t.push(r[s].data()),e.push(i),n.push(s))}const r=await Promise.all(t);for(let i=0;i<r.length;++i)this.history[e[i]][n[i]].dispose(),this.history[e[i]][n[i]]=r[i][0]}}class BK extends LK{constructor(t,e){if(super(),this.currentEpoch=0,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");r.isNumber(this.yieldEvery)&&(this.maybeWait=function(t,e){let n,i=r.now();return(...s)=>{const o=r.now();return o-i<e||(i=o,n=t(...s)),n}}(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,n){const r=[];null!=this.yield&&(await NK(n),r.push(this.yield(t,e,n))),r.push(Pj()),await Promise.all(r)}async onEpochBegin(t,e){this.currentEpoch=t,null!=this.epochBegin&&(await NK(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const n=[];null!=this.epochEnd&&(await NK(e),n.push(this.epochEnd(t,e))),"epoch"===this.yieldEvery&&n.push(Pj()),await Promise.all(n)}async onBatchBegin(t,e){null!=this.batchBegin&&(await NK(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const n=[];null!=this.batchEnd&&(await NK(e),n.push(this.batchEnd(t,e))),"batch"===this.yieldEvery?n.push(Pj()):r.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(n)}async onTrainBegin(t){null!=this.trainBegin&&(await NK(t),await this.trainBegin(t))}async onTrainEnd(t){null!=this.trainEnd&&(await NK(t),await this.trainEnd(t))}}function zK(t,e){return null==t&&(t={}),t instanceof LK?[t]:Array.isArray(t)&&t[0]instanceof LK?t:$q(t).map(t=>new BK(t,e))}class VK{constructor(){}static registerCallbackConstructor(t,e){r.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),VK.checkForDuplicate(e),null==VK.constructors[t]&&(VK.constructors[t]=[]),VK.constructors[t].push(e)}static checkForDuplicate(t){for(const e in VK.constructors)VK.constructors[+e].forEach(e=>{if(e===t)throw new Iq("Duplicate callback constructor.")})}static clear(){VK.constructors={}}static createCallbacks(t){const e=[];for(const n in VK.constructors){const r=+n;t>=r&&e.push(...VK.constructors[r])}return e.map(t=>new t)}}function UK(t,e,n,r,i,s,o,a,l){const c=new $K,u=[new PK,...VK.createCallbacks(e)];null!=t&&u.push(...t),u.push(c);const h=new FK(u);return h.setParams({epochs:n,initialEpoch:r,samples:i,steps:s,batchSize:o,verbose:e,doValidation:a,metrics:l}),{callbackList:h,history:c}}function HK(t,e={},n=!1){return Wq(t,d.SerializationMap.getMap().classNameMap,e,"layer",n)}function WK(t,e){return oB(()=>{"float32"!==t.dtype&&(t=t.asType("float32"));const n=cV(BX(t),e,!0),r=Rz(n.shape,Mq()),i=SU(Kz(n,r));return pz(t,i)})}function jK(t,e){return oB(()=>xV(BX(lV(e,t)),-1))}function GK(t,e){return oB(()=>xV(v$(lV(e,t)),-1))}function qK(t,e){return oB(()=>{const n=lV(t,e),r=GB(v$(t),Mq(),Number.MAX_VALUE),i=v$(pz(n,r));return yB(100,xV(i,-1))})}function XK(t,e,n=!1){return oB(()=>{if(n)e=wU(e);else{const t=cV(e,e.shape.length-1,!0);e=pz(e,t)}return e=GB(e,Mq(),1-Mq()),iV(cV(yB(t.toFloat(),eV(e)),e.shape.length-1))})}function KK(t,e,n=!1){return oB(()=>{const r=Iz(function(t){const e=[SX(t.shape)];return t.reshape(e)}(t)).toInt(),i=(e=GB(e,Mq(),1-Mq())).shape;return XK(RV(r,i[i.length-1]).reshape(i),e,n)})}function YK(t,e){return oB(()=>{let n;return n=GB(e,Mq(),1-Mq()),n=eV(pz(n,lV(1,n))),xV(function(t,e){if(!r.arraysEqual(t.shape,e.shape))throw new Iq(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(e.shape)}`);return oB(()=>{const n=e.relu(),r=e.abs().neg();return n.sub(e.mul(t)).add(r.exp().log1p())})}(t,n),-1)})}function ZK(t,e){return oB(()=>{const n=WK(t,-1),r=WK(e,-1),i=yB(n,r);return iV(cV(i,-1))})}VK.constructors={};const JK={meanSquaredError:jK,meanAbsoluteError:GK,meanAbsolutePercentageError:qK,meanSquaredLogarithmicError:function(t,e){return oB(()=>{const n=GB(e,Mq(),Number.MAX_VALUE),r=eV(x$(1,n)),i=GB(t,Mq(),Number.MAX_VALUE),s=eV(x$(1,i));return xV(BX(lV(r,s)),-1)})},squaredHinge:function(t,e){return oB(()=>{const n=Kz(0,lV(1,yB(t,e)));return xV(BX(n),-1)})},hinge:function(t,e){return oB(()=>{const n=Kz(0,lV(1,yB(t,e)));return xV(n,-1)})},categoricalHinge:function(t,e){return oB(()=>{const n=cV(yB(t,e),-1),r=aV(yB(lV(1,t),e),-1);return Kz(0,x$(1,lV(r,n)))})},logcosh:function(t,e){return oB(()=>{const n=Math.log(2),r=lV(e,t),i=lV(x$(r,sV(yB(-2,r))),n);return xV(i,-1)})},categoricalCrossentropy:XK,sparseCategoricalCrossentropy:KK,binaryCrossentropy:YK,kullbackLeiblerDivergence:function(t,e){return oB(()=>{const n=GB(t,Mq(),1),r=GB(e,Mq(),1);return cV(yB(t,eV(pz(n,r))),-1)})},poisson:function(t,e){return oB(()=>{const n=eV(x$(Mq(),e));return xV(lV(e,yB(t,n)),-1)})},cosineProximity:ZK};function QK(t){if("string"==typeof t){if(t in JK)return JK[t];let e=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new Iq(e)}return t}function tY(t,e){return oB(()=>{const n=yB(.5,IV(e)),r=MX($z(e,n),t.dtype);return xV(yz(t,r),-1)})}function eY(t,e){return oB(()=>MX(yz(L$(t,-1),L$(e,-1)),"float32"))}function nY(t,e){return YK(t,e)}function rY(t,e){return t.rank===e.rank&&(t=t.squeeze([t.rank-1])),(e=e.argMax(-1)).dtype!==t.dtype&&(e=e.asType(t.dtype)),yz(t,e).asType("float32")}const iY=XK,sY=KK,oY={binaryAccuracy:tY,categoricalAccuracy:eY,precision:function(t,e){return oB(()=>{const n=function(t,e){return oB(()=>dV(t.equal(1),e.equal(1)).sum().cast("float32"))}(t,e),r=function(t,e){return oB(()=>dV(t.equal(0),e.equal(1)).sum().cast("float32"))}(t,e),i=n.add(r);return vz($z(i,0),n.div(i),0).cast("float32")})},categoricalCrossentropy:iY,sparseCategoricalCrossentropy:sY,mse:jK,MSE:jK,mae:GK,MAE:GK,mape:qK,MAPE:qK,cosine:ZK};function aY(t){if("string"==typeof t&&t in oY)return oY[t];if("string"!=typeof t&&null!=t)return t;throw new Iq(`Unknown metric ${t}`)}function lY(t){if(Lq(null!==t,`Unknown LossOrMetricFn ${t}`),"string"==typeof t)return t;{let e;for(const n of Object.keys(JK))if(JK[n]===t){e=n;break}if(void 0!==e)return e;for(const n of Object.keys(oY))if(oY[n]===t){e=n;break}return void 0!==e?e:t.name}}function cY(t,e,n=!1){if(null==t||"object"!=typeof t||Object.getPrototypeOf(t)!==Object.prototype||!uY(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(t);n.length>1048576&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function uY(t){if(null===t)return!0;if("object"==typeof t){if(Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);for(const n of e){if("string"!=typeof n)return!1;if(!uY(t[n]))return!1}return!0}if(Array.isArray(t)){for(const e of t)if(!uY(e))return!1;return!0}return!1}{const e=typeof t;return"string"===e||"number"===e||"boolean"===e}}function hY(t,e,n=console.log){let r="";for(let i=0;i<t.length;++i)i>0&&(r=r.slice(0,r.length-1)+" "),r+=t[i],r=r.slice(0,e[i]),r+=" ".repeat(e[i]-r.length);n(r)}function dY(t,e,n){let r;try{r=JSON.stringify(t.outputShape)}catch(U3){r="multiple"}hY([`${t.name} (${t.getClassName()})`,r,t.countParams().toString()],e,n)}function pY(t,e,n,r){let i;try{i=JSON.stringify(t.outputShape)}catch(U3){i="multiple"}const s=[];for(const c of t.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(c)))for(let t=0;t<c.inboundLayers.length;++t)s.push(`${c.inboundLayers[t].name}[${c.nodeIndices[t]}][${c.tensorIndices[t]}]`);const o=t.name,a=t.getClassName(),l=0===s.length?"":s[0];hY([`${o} (${a})`,i,t.countParams().toString(),l],e,r);for(let c=1;c<s.length;++c)hY(["","","",s[c]],e,r)}function fY(t,e,n){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===e&&"string"==typeof n}function mY(t,e){if(null===t)return null;if("string"==typeof t)return zq(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const n=[],r=t.length;for(let i=0;i<r;++i){const r=t[i];fY(e,i,r)?n.push(r):n.push(mY(r,e))}return n}{const e={};for(const n of Object.keys(t)){const r=t[n];if("name"===n&&"string"==typeof r)e[n]=r;else{const t=zq(n);e[t]=mY(r,t)}}return e}}function gY(t,e){if(null==t)return null;if("string"==typeof t)return Bq(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const n=[],r=t.length;for(let i=0;i<r;++i){const r=t[i];fY(e,i,r)?n.push(r):n.push(gY(r,e))}return n}{const e={};for(const n of Object.keys(t)){const r=t[n];e[Bq(n)]="name"!==n&&"className"!==n||"string"!=typeof r?gY(r,n):r}return e}}class yY{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof yY)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,n){if(null!=this.id2Value[t.id])throw new Iq(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function(t,e){if(null==t.dtype||t.dtype===e.dtype)return e;try{return U$(e,t.dtype)}catch(U3){throw new Iq(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=n&&(this.id2Mask[t.id]=n),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof CK){if(null==this.id2Value[t.id])throw new Iq(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new Iq(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof CK){if(null==this.id2Value[t.id])throw new Iq(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new Iq(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&aB(this.id2Mask)}}const vY={},bY={};function _Y(t,e,n,i){const s=null!=n&&n.training,o=Array.isArray(t),a=o?t:[t],l=a.map(t=>t.name),c=[],u=e.names();for(const r of l)-1!==u.indexOf(r)?c.push(e.getValue(r)):c.push(null);null!=i&&(i.maxNumTensors=-1/0,i.minNumTensors=1/0);const h=l.join(",")+"|"+e.names().join(",");let d,p;if(null==vY[h]){const t=function(t,e){r.assert(null!=t&&t.length>0,()=>"Expected at least one fetch, got none");let n=[],i={};if(1===t.length){const r=wY(t[0],e);n=r.sorted,i=r.recipientMap}else{const r=new Set;for(const s of t){const{sorted:t,recipientMap:o}=wY(s,e);for(const e of t)r.has(e.name)||(n.push(e),r.add(e.name));for(const e in o)null==i[e]&&(i[e]=new Set),o[e].forEach(t=>i[e].add(t))}}return{sorted:n,recipientCounts:xY(i)}}(a,e);d=t.sorted,p=t.recipientCounts,vY[h]=d,bY[h]=p}d=vY[h],p={},s||Object.assign(p,bY[h]);const f=new yY(e);for(let r=0;r<d.length;++r){if(null!=i){const t=sB().numTensors;t>i.maxNumTensors&&(i.maxNumTensors=t),t<i.minNumTensors&&(i.minNumTensors=t)}const t=d[r],o=t.sourceLayer;if(o instanceof IK)continue;const a=[],u=[],h=[];let m=!1;for(const n of t.inputs){const t=f.getValue(n),r=f.getMask(n);a.push(t),u.push(r),null!=r&&(m=!0),s||(p[n.name]--,0!==p[n.name]||e.hasKey(n)||-1!==l.indexOf(n.name)||t.isDisposed||!0===n.sourceLayer.stateful||h.push(t))}m&&((n=n||{}).mask=u[0]);const g=$q(o.apply(a,n));let y=null;o.supportsMasking&&(y=o.computeMask(a,u));const v=SY(t),b=Array.isArray(v)?v:[v];for(let e=0;e<b.length;++e){f.hasKey(b[e])||f.add(b[e],g[e],Array.isArray(y)?y[0]:y);const t=l.indexOf(b[e].name);-1!==t&&(c[t]=g[e])}s||aB(h)}return f.disposeMasks(),o?c:c[0]}function xY(t){const e={};for(const n in t)e[n]=t[n].size;return e}function wY(t,e){const n=new Set,r=[],i={};for(const a of e.names())n.add(a);const s=[],o=[];for(s.push(t);s.length>0;){const t=s[s.length-1];if(n.has(t.name)){s.pop();continue}const e=o[o.length-1]===s.length-1;if(0===t.inputs.length||e)s.pop(),r.push(t),n.add(t.name),e&&o.pop();else{o.push(s.length-1);for(const e of t.inputs)null==i[e.name]&&(i[e.name]=new Set),i[e.name].add(t.name),n.has(e.name)||s.push(e)}}return{sorted:r,recipientMap:i}}function SY(t){let e;if(1===t.sourceLayer.inboundNodes.length)e=t.sourceLayer.output;else{let n=null;for(let e=0;e<t.sourceLayer.inboundNodes.length;++e)for(const r of t.sourceLayer.inboundNodes[e].outputTensors)if(r.id===t.id){n=e;break}e=t.sourceLayer.getOutputAt(n)}return e}class EY extends kK{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const t=this.getClassName().toLowerCase();this.name=mK(t)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(t.inputs)?t.inputs.slice():[t.inputs],this.outputs=Array.isArray(t.outputs)?t.outputs.slice():[t.outputs],Gq(this.inputs).length!==this.inputs.length)throw new Iq(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(t=>t.name)}`);Gq(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(t=>t.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const t=y.nodeIndex,e=y.tensorIndex;this.outputLayers.push(y.sourceLayer),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(e)}for(const y of this.inputs){const t=y.sourceLayer,e=y.nodeIndex,n=y.tensorIndex;Lq(0===e,"input layer has >1 nodes"),Lq(0===n,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(e),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const e=this.inputLayers[y];if(!(e instanceof IK))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${y} (0-based) originates from layer type ${e.getClassName()}.`);this.inputNames.push(e.name),this.feedInputShapes.push(e.batchInputShape),this.feedInputNames.push(e.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map(t=>t.shape),this.internalOutputShapes=this.outputs.map(t=>t.shape);const e={},n={},r={},i={},s={},o=[],a=(t,e,n,r,i,l)=>{null!=r&&null!=i&&null!=l||(r=t.sourceLayer,i=t.nodeIndex,l=t.tensorIndex);const c=r.inboundNodes[i];if(-1!==n.indexOf(c))throw new Rq(`The tensor ${t.name} at layer "${r.name}" is part of a cycle.`);if(-1!==e.indexOf(c))return;this.containerNodes.add(EY.nodeKey(r,i)),r.id in s||(s[r.id]=Object.keys(s).length),-1===n.indexOf(c)&&n.push(c);const u=c.inboundLayers.length;for(let s=0;s<u;s++)a(c.inputTensors[s],e,n,c.inboundLayers[s],c.nodeIndices[s],c.tensorIndices[s]);for(e.push(c);n.indexOf(c)>=0;)n.splice(n.indexOf(c),1);o.push(c)},l=[],c=[];for(const y of this.outputs)a(y,l,c);const u=o.slice().reverse();for(const y of u){n[y.id]=y,y.id in e||(e[y.id]=0);let t=e[y.id];t=Math.max(t,null==r[y.outboundLayer.id]?0:r[y.outboundLayer.id]),r[y.outboundLayer.id]=t,i[y.outboundLayer.id]=y.outboundLayer,e[y.id]=t;for(let r=0;r<y.inboundLayers.length;r++){const i=y.inboundLayers[r].inboundNodes[y.nodeIndices[r]];e[i.id]=Math.max(t+1,null==e[i.id]?0:e[i.id]),n[i.id]=i}}const h={};for(const y in e){const t=e[y];t in h||(h[t]=[]),h[t].push(n[y])}const d={};for(const y in r){const t=r[y];t in d||(d[t]=[]),d[t].push(i[y])}let p=Object.keys(d).map(t=>parseInt(t,10)).sort(jq);this.layers=[];for(const y of p){const t=d[y];t.sort((t,e)=>{const n=s[t.id],r=s[e.id];return n<r?-1:n>r?1:0});for(const e of t)e instanceof EY&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=d,p=Object.keys(h).map(t=>parseInt(t,10)).sort(jq);const f=this.inputs.slice(),m=[];for(const y of p)for(const t of h[y]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===f.indexOf(n))throw new Rq(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${m}`);for(const e of t.outputTensors)f.push(e);m.push(e.name)}}this.nodesByDepth=h;const g=this.layers.map(t=>t.name);for(const y of g){const t=g.filter(t=>t===y).length;if(1!==t)throw new Rq(`The name "${y}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new AK({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(t=>null),outputMasks:this.outputs.map(t=>null),inputShapes:this.inputs.map(t=>t.shape),outputShapes:this.outputs.map(t=>t.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(e=>e.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new Iq("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.layers)e.push(...t.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const n={};let r=0;for(const s of this.layers)for(const t of s.weights){if(null!=n[t.originalName])throw new Iq(`Duplicate weight name: ${t.originalName}`);n[t.originalName]=t,r++}const i=[];for(const s in t){let r=s;if(null==n[s]){const t=s.split("/");r=t.slice(0,-2).concat([t[t.length-1]]).join("/")}if(null!=n[r])i.push([n[r],t[s]]);else if(e)throw new Iq(`Provided weight data has no target variable: ${s}`);delete n[r]}if(e){const t=[];for(const e in n)t.push(e);if(t.length>0)throw new Iq(`${t.length} of ${r} weights are not set: ${t}`)}SK(i)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers 2.3.0",e.backend="TensorFlow.js",e}toJSON(t,e=!0){const n=gY(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return oB(()=>{t=$q(t);const n=new yY;for(let e=0;e<this.inputs.length;++e)n.add(this.inputs[e],t[e]);return _Y(this.outputs,n,e)})}computeMask(t,e){return oB(()=>{let n;return t=$q(t),n=null==e?Dq(null,t.length):$q(e),this.runInternalGraph(t,n)[1]})}computeOutputShape(t){const e=yK(t);if(e.length!==this.inputLayers.length)throw new Iq(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let o=0;o<e.length;o++)n[this.inputLayers[o].name+"_0_0"]=e[o];const r=Object.keys(this.nodesByDepth).map(t=>parseInt(t,10)).sort(jq);if(r.length>1)for(const o of r){const t=this.nodesByDepth[o];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map(t=>t.id).indexOf(t.id))continue;const r=[];for(let o=0;o<e.inboundLayers.length;o++)r.push(n[`${e.inboundLayers[o].name}_${e.nodeIndices[o]}_${e.tensorIndices[o]}`]);const i=yK(t.computeOutputShape(Pq(r))),s=t.inboundNodes.indexOf(e);for(let e=0;e<i.length;e++)n[`${t.name}_${s}_${e}`]=i[e]}}const i=[],s=[];for(let o=0;o<this.outputLayers.length;o++)s.push(`${this.outputLayers[o].name}_${this.outputLayersNodeIndices[o]}_${this.outputLayersTensorIndices[o]}`);for(let o=0;o<s.length;o++){const t=s[o];Lq(t in n),i.push(n[t])}return Pq(i)}runInternalGraph(t,e){null==e&&(e=Dq(null,t.length));const n={};for(let a=0;a<this.inputs.length;++a)n[this.inputs[a].id]=[t[a],e[a]];const r=Object.keys(this.nodesByDepth).map(t=>parseInt(t,10)).sort(jq);for(const a of r){const t=this.nodesByDepth[a];for(const e of t){const t=e.outboundLayer,r=e.inputTensors,i=e.outputTensors,s=new Array;for(const e of r)e.id in n&&s.push(n[e.id]);if(s.length===r.length){let r,o,a,l,c={};if(null!=e.callArgs&&(c=e.callArgs),1===s.length){const[e,n]=s[0];null==c.mask&&(c.mask=n),a=$q(t.call(e,c)),l=$q(t.computeMask(e,n)),r=[e],o=[n]}else r=s.map(t=>t[0]),o=s.map(t=>t[1]),null==c.mask&&(c.mask=o),a=$q(t.call(r,c)),l=$q(t.computeMask(r,o));if(t.activityRegularizer)throw new Nq("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let t=0;t<i.length;++t)n[i[t].id]=[a[t],l[t]]}}}const i=[],s=[],o=[];for(const a of this.outputs){Lq(a.id in n,`Could not compute output ${a.name} : ${a.id}`);const[t,e]=n[a.id];o.push(t.shape),i.push(t),s.push(e)}return[i,s,o]}buildNodeConversionMap(t){const e={};let n;for(const r of this.layers){n=r instanceof EY?1:0;for(let t=0;t<r.inboundNodes.length;t++){const i=EY.nodeKey(r,t);this.containerNodes.has(i)&&(e[i]=n,n+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new Iq(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==t)throw new Iq("Provide either a layer name or layer index");for(const n of this.layers)if(n.name===t)return n;throw new Iq(`No such layer: ${t}`)}calculateLosses(){return oB(()=>{const t=[];for(const e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){const r=EY.nodeKey(e,n);this.containerNodes.has(r)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(const s of this.layers){const t=s.getClassName(),r=s.getConfig(),i=[];for(let n=0;n<s.inboundNodes.length;n++){const t=s.inboundNodes[n],r=EY.nodeKey(s,n);let o={};if(this.containerNodes.has(r)){if(t.callArgs)try{JSON.stringify(t.callArgs),o=t.callArgs}catch(U3){console.warn(`Layer ${s.name} was passed non-serializable keyword arguments: ${t.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),o={}}if(t.inboundLayers.length>0){const n=[];for(let r=0;r<t.inboundLayers.length;r++){const i=t.inboundLayers[r],s=t.tensorIndices[r];let a=e[EY.nodeKey(i,t.nodeIndices[r])];null==a&&(a=0),n.push([i.name,a,s,o])}i.push(n)}}}const o={};o.name=s.name,o.className=t,o.config=r,o.inboundNodes=i,n.push(o)}t.layers=n;const r=[];for(let s=0;s<this.inputLayers.length;s++){const t=this.inputLayers[s],n=EY.nodeKey(t,this.inputLayersNodeIndices[s]);if(!this.containerNodes.has(n))continue;let i=e[n];null==i&&(i=0),r.push([t.name,i,this.inputLayersTensorIndices[s]])}t.inputLayers=r;const i=[];for(let s=0;s<this.outputLayers.length;s++){const t=this.outputLayers[s],n=EY.nodeKey(t,this.outputLayersNodeIndices[s]);if(!this.containerNodes.has(n))continue;let r=e[n];null==r&&(r=0),i.push([t.name,r,this.outputLayersTensorIndices[s]])}return t.outputLayers=i,t}static fromConfig(t,e,n={},r=!1){const i={},s={};function o(t,e){t.name in s?s[t.name].push(e):s[t.name]=[e]}function a(t,e){const n=[];let r;for(const s of e){const a=s[0],l=s[1],c=s[2];if(r=null==s[3]?{}:s[3],!(a in i))return void o(t,e);const u=i[a];if(u.inboundNodes.length<=l)return void o(t,e);n.push(u.inboundNodes[l].outputTensors[c])}n.length>0&&t.apply(Pq(n),r)}function l(t){const n=t.name,s=HK(t,null!=e.customObjects?e.customObjects:{});s.setFastWeightInitDuringBuild(r),i[n]=s,t.inboundNodes.forEach(t=>{if(!(t instanceof Array))throw new Iq(`Corrupted configuration, expected array for nodeData: ${t}`);o(s,t)})}const c=e.name,u=e.layers;for(const m of u)l(m);for(;!qq(s);)for(const t of u){const e=i[t.name];if(e.name in s){const t=s[e.name];delete s[e.name];for(const n of t)a(e,n)}}const h=[],d=[],p=e.inputLayers;for(const m of p){const t=m[0],e=m[1],n=m[2];Lq(t in i),h.push(i[t].inboundNodes[e].outputTensors[n])}const f=e.outputLayers;for(const m of f){const t=m[0],e=m[1],n=m[2];Lq(t in i),d.push(i[t].inboundNodes[e].outputTensors[n])}return new t({inputs:h,outputs:d,name:c})}get stateful(){if(this._stateful)throw new Iq("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){oB(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function CY(t,e){return function(t,e,n){const r=e.length;if(null==t||Array.isArray(t)&&0===t.length)return e.map(t=>null);if(1===r)return Array.isArray(t)&&1===t.length?t:"object"==typeof t&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error(`Provided classWeight is an array of ${t.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return t}if("object"==typeof t&&Object.keys(t).length>0&&"object"==typeof t[Object.keys(t)[0]]){const n=[];return e.forEach(e=>{n.push(e in t?t[e]:null)}),n}throw new Error(`The model has multiple (${r}) outputs, so classWeight must be either an array with ${r} elements or an object with ${e} keys. Provided classWeight not understood: ${JSON.stringify(t)}`)}(t,e)}async function TY(t,e,n,r){if(null!=e||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const e=oB(()=>{if(1===t.shape.length)return t.clone();if(2===t.shape.length){if(t.shape[1]>1)return t.argMax(1);if(1===t.shape[1])return t.reshape([t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),r=Array.from(await e.data());aB(e);const i=[];return r.forEach(t=>{if(null==n[t])throw new Error(`classWeight must contain all classes in the training data. The class ${t} exists in the data but not in classWeight`);i.push(n[t])}),JV(i,"float32")}return null}function AY(t,e){return yB(t,e)}function MY(t,e){let n,i;n=e.xs,i=e.ys,r.assert(null!=n&&null!=i,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const s=kY("input",t.inputNames,n),o=kY("output",t.outputNames,i),a=s[0].shape[0];r.assert(s.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`),r.assert(o.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`);for(let l=0;l<s.length;l++)r.assert(s[l].shape[0]===a,()=>`Batch size mismatch: input ${t.inputNames[l]} has ${s[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);for(let l=0;l<o.length;l++)r.assert(o[l].shape[0]===a,()=>`Batch size mismatch: output ${t.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);return{xs:s,ys:o}}function kY(t,e,n){if(n instanceof HP)return[n];if(Array.isArray(n))return r.assert(n.length===e.length,()=>`Received an array of ${n.length} Tensors, but expected ${e.length} to match the ${t} keys ${e}.`),n;{const r=[];for(const i of e){if(null==n[i])throw new Iq(`The feature data generated by the dataset lacks the required ${t} key '${i}'.`);r.push(n[i])}return r}}function RY(t){return"function"==typeof t.iterator}function IY(t){r.assert(t>0&&Number.isInteger(t),()=>`batchSize is required to be a positive integer, but got ${t}`)}function NY(t,e,n){return null==t?[null]:Array.isArray(t)?t.map(t=>RX(t,e,n-e)):RX(t,e,n-e)}function OY(t,e){return oB(()=>null==t?null:Array.isArray(t)?t.map(t=>OY(t,e)):$X(t,"int32"===e.dtype?e:e.toInt()))}function DY(t,e){const n=[];let r=0,i=null;for(;r<t;)i=r+e,i>=t&&(i=t),n.push([r,i]),r=i;return n}function LY(t){const e=[];t instanceof HP&&(t=[t]);for(let n=0;n<t.length;++n){const r=t[n];if(1===r.rank)e.push(kX(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(r)}}return e}function FY(t,e){if(null==t)return;const n=[];if(e instanceof HP)n.push(e.id);else if(Array.isArray(e))e.forEach(t=>n.push(t.id));else if(null!=e)for(const i in e)n.push(e[i].id);const r=[];if(t instanceof HP)-1===n.indexOf(t.id)&&r.push(t);else if(Array.isArray(t))t.forEach(t=>{-1===n.indexOf(t.id)&&r.push(t)});else if(null!=t)for(const i in t){const e=t[i];-1===n.indexOf(e.id)&&r.push(e)}r.forEach(t=>{t.isDisposed||t.dispose()})}function PY(t){return Array.isArray(t)}function $Y(t){return!function(t){return t instanceof HP}(t)&&!PY(t)}function BY(t,e,n,r=!0,i=""){if(null==e||0===e.length){if(null!=t){let e=!1;if(PY(t)&&t.length>0)e=!0;else if($Y(t)){for(const n in t)if(t.hasOwnProperty(n)){e=!0;break}}else e=!0;if(e)throw new Iq(`Error when checking model ${i} expected no data, but got ${t}`)}return[]}if(null==t)return e.map(t=>null);let s;if($Y(t)){t=t,s=[];for(const n of e){if(null==t[n])throw new Iq(`No data provided for "${n}". Need data for each key in: ${e}`);s.push(t[n])}}else if(PY(t)){if((t=t).length!==e.length)throw new Iq(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);s=t}else{if(t=t,e.length>1)throw new Iq(`The model ${i} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);s=[t]}if(s=LY(s),null!=n)for(let o=0;o<e.length;++o){if(null==n[o])continue;const t=s[o];if(t.shape.length!==n[o].length)throw new Iq(`Error when checking ${i}: expected ${e[o]} to have ${n[o].length} dimension(s). but got array with shape ${t.shape}`);for(let s=0;s<n[o].length;++s){if(0===s&&!r)continue;const a=t.shape[s],l=n[o][s];if(null!=l&&l>=0&&a!==l)throw new Iq(`Error when checking ${i}: expected ${e[o]} to have shape [${n[o]}], but got array with shape [${t.shape}].`)}}return s}function zY(t,e,n,r=!0,i=""){let s;if(Array.isArray(t)){if(t.length!==e.length)throw new Iq(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${t.length} Tensors(s).`);s=t}else{if(e.length>1)throw new Iq(`The model expects ${e.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);s=[t]}if(null!=n)for(let o=0;o<e.length;++o){if(null==n[o])continue;const t=s[o];if(t.shape.length!==n[o].length)throw new Iq(`Error when checking ${i}: expected ${e[o]} to have ${n[o].length} dimension(s), but got array with shape ${JSON.stringify(t.shape)}`);for(let s=0;s<n[o].length;++s){if(0===s&&!r)continue;const a=t.shape[s],l=n[o][s];if(null!=l&&l!==a)throw new Iq(`Error when checking ${i}: expected ${e[o]} to have shape ${JSON.stringify(n[o])} but got array with shape ${JSON.stringify(t.shape)}.`)}}}class VY extends EY{constructor(t){super(t),this.isTraining=!1}summary(t,e,n=console.log){if(!this.built)throw new Iq("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(t,e,n,r=console.log){const i=function(t){let e=!0;const n=[],r=[];for(const i in t.nodesByDepth)n.push(t.nodesByDepth[i]);for(const i of n){if(i.length>1||1===i.length&&i[0].inboundLayers.length>1){e=!1;break}r.push(...i)}if(e)for(const i of t.layers){let t=!1;for(const n of i.inboundNodes)if(-1!==r.indexOf(n)){if(t){e=!1;break}t=!0}if(!e)break}return e}(t),s=["Layer (type)","Output shape","Param #"];let o;if(i?(e=e||65,n=n||[.45,.85,1]):(e=e||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map(t=>Math.floor(e*t))),!i){s.push("Receives inputs"),o=[];for(const e in t.nodesByDepth)o.push(...t.nodesByDepth[e])}r("_".repeat(e)),hY(s,n,r),r("=".repeat(e));const a=t.layers;for(let u=0;u<a.length;++u)i?dY(a[u],n,r):pY(a[u],n,o,r),r((u===a.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const l=function(t){let e;return e=_K(null!=t.collectedTrainableWeights?t.collectedTrainableWeights:t.trainableWeights),e}(t),c=_K(t.nonTrainableWeights);r(`Total params: ${l+c}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${c}`),r("_".repeat(e))}(this,t,e,n)}compile(t){if(null==t.loss&&(t.loss=[]),this.loss=t.loss,"string"==typeof t.optimizer)this.optimizer_=function(t){const e={Adagrad:()=>Lj.adagrad(.01),Adadelta:()=>Lj.adadelta(1,.95,Mq()),Adam:()=>Lj.adam(.001,.9,.999,Mq()),Adamax:()=>Lj.adamax(.002,.9,.999,Mq(),0),RMSProp:()=>Lj.rmsprop(.001,.9,0,Mq()),SGD:()=>Lj.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new Iq(`Unknown Optimizer ${t}`)}(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Tj))throw new Iq("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(Array.isArray(t.loss)||"string"==typeof t.loss||"function"==typeof t.loss)if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new Iq(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(t=>QK(t))}else{const n=QK(t.loss);this.outputs.forEach(t=>{e.push(n)})}else{t.loss=t.loss;for(const e in t.loss)if(-1===this.outputNames.indexOf(e))throw new Iq(`Unknown entry in loss dictionary: "${e}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==t.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),e.push(QK(t.loss[n]))}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){const t=this.internalOutputShapes[s];this.feedOutputNames.push(this.outputNames[s]),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[s])}const n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],vX("loss",()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;const e=this.lossFunctions[t];this.outputs.length>1&&(this.metricsTensors.push([e,t]),this.metricsNames.push(this.outputNames[t]+"_loss"))}});const r=function(t,e){if(null==t||Array.isArray(t)&&0===t.length)return e.map(t=>[]);let n;if("string"==typeof t||"function"==typeof t)n=[t];else{if(!Array.isArray(t)&&"object"!=typeof t)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);n=t}if(Array.isArray(n))return e.map(t=>n);{const t=[];for(const r of e){let e=n.hasOwnProperty(r)?n[r]:[];Array.isArray(e)||(e=[e]),t.push(e)}return t}}(t.metrics,this.outputNames),i=(t,e,n)=>{this.outputNames.length>1&&(e=this.outputNames[t]+"_"+e),this.metricsNames.push(e),this.metricsTensors.push([n,t])};vX("metric",()=>{for(let t=0;t<this.outputs.length;++t)-1===n.indexOf(t)&&(e=>{let n,r,s;for(const o of e){if("string"==typeof o&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(o)){const e=this.internalOutputShapes[t];let i;1===e[e.length-1]||this.lossFunctions[t]===YK?-1!==["accuracy","acc"].indexOf(o)?r=tY:-1!==["crossentropy","ce"].indexOf(o)&&(r=nY):this.lossFunctions[t]===KK?-1!==["accuracy","acc"].indexOf(o)?r=rY:-1!==["crossentropy","ce"].indexOf(o)&&(r=sY):-1!==["accuracy","acc"].indexOf(o)?r=eY:-1!==["crossentropy","ce"].indexOf(o)&&(r=iY),-1!==["accuracy","acc"].indexOf(o)?i="acc":-1!==["crossentropy","ce"].indexOf(o)&&(i="ce"),s=r,n=""+i}else{const t=aY(o);s=t,n=""+lY(o)}let e;vX(n,()=>{e=s}),i(t,n,e)}})(r[t])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,n={}){const r=null==n.batchSize?32:n.batchSize;IY(r);const i=this.standardizeUserDataXY(t,e,!0,r);try{const s=i[0].concat(i[1]);return this.makeTestFunction(),Pq(this.testLoop(this.testFunction,s,r,n.verbose,n.steps))}finally{FY(i[0],t),FY(i[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),async function(t,e,n){const i=null!=(n=n||{}).batches,s=t.testFunction;let o=[];if(n.verbose>0)throw new Nq("Verbose mode is not implemented yet.");r.assert(!i||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const a="function"==typeof e.next?e:await e.iterator();let l=0,c=0;for(;!i||c<n.batches;){const e=await a.next();if(o=oB(()=>{if(e.value){const{xs:n,ys:r}=MY(t,e.value),i=n.concat(r),a=oB(()=>s(i));if(aB(i),0===c)for(let t=0;t<a.length;++t)o.push(Wz(0));const u=i[0].shape[0];for(let t=0;t<a.length;++t){const e=a[t],n=o[t];o[t]=oB(()=>x$(o[t],yB(u,e))),c>0&&aB(n)}aB(a),l+=u,++c}return o}),e.done){i&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let r=0;r<o.length;++r){const t=o[r];o[r]=pz(o[r],l),aB(t)}return Pq(o)}(this,t,e)}checkNumSamples(t,e,n,r="steps"){let i;if(null!=n){if(i=null,null!=e)throw new Iq(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else{if(null==t)throw new Iq(`Either the input data should have a defined shape, or ${r} shoud be specified.`);i=Array.isArray(t)?t[0].shape[0]:t.shape[0]}return i}execute(t,e){if(Array.isArray(e)&&0===e.length)throw new Iq("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(e),r=this.retrieveSymbolicTensors(n?e:[e]),i=new yY;if(t instanceof HP&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new Iq(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let e=0;e<this.inputs.length;++e)i.add(this.inputs[e],t[e])}else for(const o of this.inputs){const e=t[o.name];if(null==e)throw new Iq(`No value is provided for the model's input ${o.name}`);i.add(o,e)}const s=_Y(r,i);return n?s:s[0]}retrieveSymbolicTensors(t){const e=Dq(null,t.length);let n=t.length;for(const r of this.layers){const i=Array.isArray(r.output)?r.output:[r.output],s=i.map(t=>t.name);for(let r=0;r<t.length;++r){const o=s.indexOf(t[r]);if(-1!==o&&(e[r]=i[o],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw e.forEach((e,r)=>{null==e&&n.push(t[r])}),new Iq(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return e}predictLoop(t,e=32,n=!1){return oB(()=>{const r=this.checkNumSamples(t);if(n)throw new Nq("Verbose predictLoop() is not implemented yet.");const i=DY(r,e),s=this.outputs.map(t=>[]);for(let e=0;e<i.length;++e)oB(()=>{const n=NY(t,i[e][0],i[e][1]),r=[];if(Array.isArray(n))for(let t=0;t<n.length;++t)r.push({key:this.inputs[t],value:n[t]});else r.push({key:this.inputs[0],value:n});const s=new yY(r);return _Y(this.outputs,s)}).forEach((t,e)=>s[e].push(t));return Pq(s.map(t=>mB(t,0)))})}predict(t,e={}){const n=LY(t);zY(n,this.inputNames,this.feedInputShapes,!1);try{const r=null==e.batchSize?32:e.batchSize;return IY(r),this.predictLoop(n,r)}finally{FY(n,t)}}predictOnBatch(t){zY(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,n=!0,i){if(null==this.optimizer_)throw new Rq("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const s=[];for(let r=0;r<this.feedOutputShapes.length;++r){const t=this.feedOutputShapes[r];s.push(this.feedLossFns[r]===KK?t.slice(0,t.length-1).concat([1]):t)}if(function(t,e,n){const i=Gq(t.map(t=>t.shape[0]));i.sort();const s=Gq(e.map(t=>t.shape[0]));if(s.sort(),i.length>1)throw new Iq(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(t=>t.shape))}`);if(s.length>1)throw new Iq(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(t=>t.shape))}`);if(i.length>0&&s.length>0&&!r.arraysEqual(i,s))throw new Iq(`Input Tensors should have the same number of samples as target Tensors. Found ${i[0]} input sample(s) and ${s[0]} target sample(s).`)}(t=BY(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=BY(e,this.feedOutputNames,s,!1,"target")),function(t,e,n){const r=[jK,YK,XK];for(let i=0;i<t.length;++i){const s=t[i],o=e[i],a=n[i];if(null!=o){if(o===XK&&1===s.shape[s.shape.length-1])throw new Iq(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(o)){const t=s.shape.slice(1),e=a.slice(1);for(let n=0;n<t.length;++n){const r=t[n],i=e[n];if(null!=i&&r!==i)throw new Iq(`A target Tensor with shape ${s.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=i&&i>0&&t[0].shape[0]%i!=0)throw new Iq(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${i}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,n,r,i=!0,s){const[o,a]=this.standardizeUserDataXY(t,e,i,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const t=CY(r,this.outputNames);l=[];for(let e=0;e<t.length;++e)l.push(await TY(a[e],null,t[e]))}return[o,a,l]}testLoop(t,e,n,r=0,i){return oB(()=>{const s=this.checkNumSamples(e,n,i,"steps"),o=[];if(r>0)throw new Nq("Verbose mode is not implemented yet.");if(null!=i)throw new Nq("steps mode in testLoop() is not implemented yet");{const r=DY(s,n),i=JV(AX(0,s));for(let n=0;n<r.length;++n){const s=r[n][0],a=r[n][1],l=RX(i,s,a-s),c=OY(e,l),u=t(c);if(0===n)for(let t=0;t<u.length;++t)o.push(Wz(0));for(let t=0;t<u.length;++t)o[t]=x$(o[t],yB(a-s,u[t]))}for(let t=0;t<o.length;++t)o[t]=pz(o[t],s)}return o})}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){const r=t[n];let i=r;Fq(t,r)>1&&(i+=`_${Fq(t.slice(0,n),r)}`),e.push(i)}return e}makeTrainFunction(){return t=>{const e=[],n=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],o=this.collectedTrainableWeights.map(t=>t.read());return[this.optimizer_.minimize(()=>{const t=[];for(let e=0;e<this.inputs.length;++e)t.push({key:this.inputs[e],value:n[e]});const o=new yY(t),a=_Y(this.outputs,o,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let t=(0,this.lossFunctions[n])(r[n],a[n]);null!=i[n]&&(t=AY(t,i[n]));const s=xV(t);e.push(s),l=0===n?t:x$(l,t)}for(let n=0;n<this.metricsTensors.length;++n){let t;if(this.outputs.length>1&&n<this.outputs.length)t=e[n];else{const e=this.metricsTensors[n][1];t=xV((0,this.metricsTensors[n][0])(r[e],a[e]))}lB(t),s.push(t)}return l=xV(l),this.calculateLosses().forEach(t=>{l=x$(l,t)}),l},!0,o)].concat(s)}}makeTestFunction(){this.testFunction=t=>oB(()=>{const e=[];let n;const r=t.slice(0,this.inputs.length),i=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let t=0;t<this.inputs.length;++t)s.push({key:this.inputs[t],value:r[t]});const o=new yY(s),a=_Y(this.outputs,o);for(let t=0;t<this.lossFunctions.length;++t){const r=xV((0,this.lossFunctions[t])(i[t],a[t]));n=0===t?r:x$(n,r),e.push(n)}for(let t=0;t<this.metricsTensors.length;++t){const n=this.metricsTensors[t][1],r=xV((0,this.metricsTensors[t][0])(i[n],a[n]));e.push(r)}return e})}async fit(t,e,n={}){return async function(t,e,n,i={}){if(t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let s,o,a,l,c,u,h;t.isTraining=!0;try{const d=null==i.batchSize?32:i.batchSize;IY(d);const p=!1,f=await t.standardizeUserData(e,n,i.sampleWeight,i.classWeight,p,d);s=f[0],o=f[1],h=f[2];let m,g=!1;if(null!=i.validationData&&i.validationData.length>0){if(g=!0,2!==i.validationData.length)throw 3===i.validationData.length?new Nq("validationData including sample weights is not supported yet."):new Iq(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${i.validationData} is invalid.`);a=i.validationData[0],l=i.validationData[1];const e=!0,n=await t.standardizeUserData(a,l,null,null,e,d);c=n[0],u=n[1],m=c.concat(u)}else if(null!=i.validationSplit&&i.validationSplit>0&&i.validationSplit<1){g=!0;const t=Math.floor(s[0].shape[0]*(1-i.validationSplit)),e=s[0].shape[0];c=NY(s,t,e),s=NY(s,0,t),u=NY(o,t,e),o=NY(o,0,t),m=c.concat(u)}else null!=i.validationSteps&&(g=!0);const y=s.concat(o).concat(h);t.checkTrainableWeightsConsistency();const v=t.makeTrainFunction(),b=t.getDedupedMetricsNames();let _,x;g?(t.makeTestFunction(),_=t.testFunction,x=b.slice().concat(b.map(t=>"val_"+t))):(_=null,m=[],x=b.slice());const w=zK(i.callbacks,i.yieldEvery);return await async function(t,e,n,i,s,o,a,l,c,u,h,d,p,f,m){null==s&&(s=32),null==o&&(o=1),null==h&&(h=!0),null==p&&(p=0);let g=!1;null!=c&&null!=u&&(g=!0);const y=t.checkNumSamples(n,s,null,"steps_per_epoch");let v;null!=y&&(v=AX(0,y)),null==a&&(a=1);const{callbackList:b,history:_}=UK(l,a,o,p,y,null,s,g,d);b.setModel(t),t.history=_,await b.onTrainBegin(),t.stopTraining_=!1;for(let x=p;x<o;++x){await b.onEpochBegin(x);const o={};{if("batch"===h)throw new Nq("batch shuffling is not implemneted yet");h&&r.shuffle(v);const a=JV(v),l=DY(y,s);for(let r=0;r<l.length;++r){const h={};if(await b.onBatchBegin(r,h),oB(()=>{const d=l[r][0],p=l[r][1],f=RX(a,d,p-d);h.batch=r,h.size=p-d;const m=OY(n,f),y=e(m);for(let t=0;t<i.length;++t){const e=y[t];h[i[t]]=e,lB(e)}if(r===l.length-1&&g){const e=t.testLoop(c,u,s);for(let t=0;t<i.length;++t){const n=i[t],r=e[t];lB(r),o["val_"+n]=r}}}),await b.onBatchEnd(r,h),OK(h),t.stopTraining_)break}a.dispose()}if(await b.onEpochEnd(x,o),t.stopTraining_)break}return await b.onTrainEnd(),await t.history.syncData(),t.history}(t,v,y,b,d,i.epochs,i.verbose,w,_,m,i.shuffle,x,i.initialEpoch)}finally{t.isTraining=!1,FY(s,e),FY(o,n),FY(c,a),FY(u,l),null!=h&&aB(h)}}(this,t,e,n)}async fitDataset(t,e){return async function(t,e,n){const i=null!=n.batchesPerEpoch;if(r.assert(null!=t.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),r.assert(null!=n,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),r.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),r.assert(!i||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),r.assert(null==n.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const s=null!=n.validationData;let o,a;if(s)if(RY(n.validationData))r.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const t=function(t){if(3===t.length)throw new Nq("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}(n.validationData);o=t.xs,a=t.ys}const l=t.makeTrainFunction(),c=t.getDedupedMetricsNames();let u;u=s?c.slice().concat(c.map(t=>"val_"+t)):c.slice();const h=zK(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:p,history:f}=UK(h,d,n.epochs,null,null,function(t,e){let n=null;return null!=e.batchesPerEpoch?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size),n}(e,n),null,s,u);p.setModel(t),t.history=f,await p.onTrainBegin(),t.stopTraining_=!1;let m=null==n.initialEpoch?0:n.initialEpoch,g=await e.iterator();for(;m<n.epochs;){const r={};await p.onEpochBegin(m);let u=0,h=0;for(i||(g=await e.iterator());!i||u<n.batchesPerEpoch;){const e=await g.next();if(i&&e.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${u} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=e.value){const{xs:r,ys:i}=MY(t,e.value),s={};s.batch=h,s.size=r[0].shape[0],await p.onBatchBegin(h,s);const o=[];if(null!=n.classWeight){const e=CY(n.classWeight,t.outputNames);for(let t=0;t<e.length;++t)o.push(await TY(i[t],null,e[t]))}const a=r.concat(i).concat(o),d=l(a);aB(a);for(let t=0;t<c.length;++t){const e=d[t];s[c[t]]=e,lB(e)}await p.onBatchEnd(h,s),OK(s),h++,u++}if(i?u>=n.batchesPerEpoch:e.done){if(s){let e;e=RY(n.validationData)?$q(await t.evaluateDataset(n.validationData,{batches:n.validationBatches})):$q(t.evaluate(o,a,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<t.metricsNames.length;++n)r[`val_${t.metricsNames[n]}`]=e[n]}break}if(t.stopTraining_)break}if(await p.onEpochEnd(m,r),m++,t.stopTraining_)break}return await p.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}(this,t,e)}async trainOnBatch(t,e){const n=await this.standardizeUserData(t,e),r=n[0],i=n[1],s=this.makeTrainFunction()(r.concat(i)),o=[];for(const a of s){const t=await a.data();o.push(t[0])}return aB(s),Pq(o)}getNamedWeights(t){const e=[],n=null!=t&&t.trainableOnly,r=n?this.trainableWeights:this.weights,i=this.getWeights(n);for(let s=0;s<r.length;++s)n&&!r[s].trainable||e.push({name:r[s].originalName,tensor:i[s]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(0===t.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const e=sB().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-sB().numTensors}return t}getLossIdentifiers(){let t;if("string"==typeof this.loss)t=Bq(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if("string"!=typeof t)throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(t=>Bq(t))}else{const e=Object.keys(this.loss);t={};const n=this.loss;for(const r of e){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");t[r]=Bq(n[r])}}return t}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[Bq(lY(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>Bq(lY(t)));{const t={};for(const e in this.metrics)t[e]=Bq(lY(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(null!=t.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=t.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=t.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const e=HK(mY(t.optimizer_config));let n,r;if("string"==typeof t.loss)n=zq(t.loss);else if(Array.isArray(t.loss))n=t.loss.map(t=>zq(t));else if(null!=t.loss){n={};for(const e in t.loss)n[e]=zq(t.loss[e])}if(Array.isArray(t.metrics))r=t.metrics.map(t=>zq(t));else if(null!=t.metrics){r={};for(const e in t.metrics)r[e]=zq(t.metrics[e])}this.compile({loss:n,metrics:r,optimizer:e})}async save(t,e){if("string"==typeof t){const e=u.getSaveHandlers(t);if(0===e.length)throw new Iq(`Cannot find any save handlers for URL '${t}'`);if(e.length>1)throw new Iq(`Found more than one (${e.length}) save handlers for URL '${t}'`);t=e[0]}if(null==t.save)throw new Iq("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await u.encodeWeights(this.getNamedWeights(e)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v2.3.0",convertedBy:null};if(null!=e&&e.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();const t="optimizer",{data:e,specs:i}=await u.encodeWeights(await this.optimizer.getWeights(),t);n.specs.push(...i),n.data=u.concatenateArrayBuffers([n.data,e])}return null!=this.userDefinedMetadata&&(cY(this.userDefinedMetadata,this.name,!0),r.userDefinedMetadata=this.userDefinedMetadata),r.weightData=n.data,r.weightSpecs=n.specs,t.save(r)}setUserDefinedMetadata(t){cY(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}VY.className="Model",d.registerClass(VY);class UY extends VY{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=null!=t.name?t.name:mK("sequential_"),null!=t.layers)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(t=>t<0))throw new Iq(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const e=t instanceof UY||t instanceof VY;let n;if(e){if(n=t,1!==n.outputs.length)throw new Iq("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new Iq("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new Iq("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const e=function(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new Iq("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;null!=t.shape&&null==e&&(e=[null].concat(t.shape));let n=t.dtype;return null==n&&(n="float32"),new IK({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(e)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==t.inboundNodes.length)throw new Iq(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(1!==t.inboundNodes[0].outputTensors.length)throw new Iq("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=RK(this.outputs[0])}this.inboundNodes=[],new AK({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Dq(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(t=>t.shape),outputShapes:this.outputs[0].shape})}else{const e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return null==this.model&&this.build(),this.model.call(t,e)}build(t){if(bK(t),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new VY({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,n=console.log){this.built||this.build(),super.summary(t,e,n)}setWeights(t){null==this.model&&this.build(),this.model.setWeights(t)}evaluate(t,e,n={}){if(!this.built)throw new Rq("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)}async evaluateDataset(t,e){if(!this.built)throw new Rq("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return null==this.model&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return null==this.model&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,n={}){if(!this.built)throw new Rq("The model needs to be compiled before being used.");return this.model.fit(t,e,n)}async fitDataset(t,e){if(!this.built)throw new Rq("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,n={},i=!1){let s,o={};if(e instanceof Array){if(null==e[0].className||"Merge"===e[0].className)throw new Iq("Legacy serialization format not supported yet.");s=e}else r.assert(null!=e.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=e.layers,delete e.layers,o=e;const a=new t(o);if(!(a instanceof UY))throw new Nq(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const r of s){const t=HK(r,void 0,i);i&&t.setFastWeightInitDuringBuild(!0),a.add(t)}return a}set stopTraining(t){if(null==this.model)throw new Iq("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(null==this.model)throw new Iq("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const n={};n.className=e.getClassName(),n.config=e.getConfig(),t.push(n)}return{name:this.name,layers:t}}}UY.className="Sequential",d.registerClass(UY);class HY extends d.Serializable{getConfig(){return{}}}class WY extends HY{apply(t,e=1){return function(t,e=1){if(1!==e)throw new Nq(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return wz(t)}(t,e)}}WY.className="elu",d.registerClass(WY);class jY extends HY{apply(t){return dU(t)}}jY.className="selu",d.registerClass(jY);class GY extends HY{apply(t){return eU(t)}}GY.className="relu",d.registerClass(GY);class qY extends HY{apply(t){return oB(()=>SV(6,eU(t)))}}qY.className="relu6",d.registerClass(qY);class XY extends HY{apply(t){return t}}XY.className="linear",d.registerClass(XY);class KY extends HY{apply(t){return vB(t)}}KY.className="sigmoid",d.registerClass(KY);class YY extends HY{apply(t){return function(t){return oB(()=>{const e=x$(.5,yB(.2,t));return GB(e,0,1)})}(t)}}YY.className="hardSigmoid",d.registerClass(YY);class ZY extends HY{apply(t){return sV(t)}}ZY.className="softplus",d.registerClass(ZY);class JY extends HY{apply(t){return function(t){return oB(()=>pz(t,v$(t).add(1)))}(t)}}JY.className="softsign",d.registerClass(JY);class QY extends HY{apply(t){return DB(t)}}QY.className="tanh",d.registerClass(QY);class tZ extends HY{apply(t,e=-1){return wU(t,e)}}tZ.className="softmax",d.registerClass(tZ);class eZ extends HY{apply(t,e=-1){return uV(t,e)}}function nZ(t){return t.getClassName()}function rZ(t,e={}){return Wq(t,d.SerializationMap.getMap().classNameMap,e,"activation")}function iZ(t){if(null==t)return rZ({className:"linear",config:{}});if("string"==typeof t){const e={};return e.className=t,e.config={},rZ(e)}return t instanceof HY?t:rZ(t)}eZ.className="logSoftmax",d.registerClass(eZ);class sZ extends d.Serializable{}class oZ extends sZ{constructor(t){super(),function(t){if(null!=t&&"object"!=typeof t)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}(t),this.l1=null==t||null==t.l1?.01:t.l1,this.l2=null==t||null==t.l2?.01:t.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(t){return oB(()=>{let e=bV([1]);return this.hasL1&&(e=x$(e,cV(yB(this.l1,v$(t))))),this.hasL2&&(e=x$(e,cV(yB(this.l2,BX(t))))),e.asScalar()})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}oZ.className="L1L2",d.registerClass(oZ);const aZ={l1l2:"L1L2"};function lZ(t){return Uq(t)}function cZ(t,e={}){return Wq(t,d.SerializationMap.getMap().classNameMap,e,"regularizer")}function uZ(t){return null==t?null:"string"==typeof t?cZ({className:t in aZ?aZ[t]:t,config:{}}):t instanceof sZ?t:cZ(t)}class hZ extends kK{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,null!=t&&(this.maxValue=t.maxValue)}call(t,e){t=vK(t);let n=eU(t);return null!=this.maxValue&&(n=GB(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}hZ.className="ReLU",d.registerClass(hZ);class dZ extends kK{constructor(t){super(null==t?{}:t),this.DEFAULT_ALPHA=.3,null==t&&(t={}),this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=vK(t);return Yz(n,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}dZ.className="LeakyReLU",d.registerClass(dZ);class pZ extends kK{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),this.supportsMasking=!0,this.alphaInitializer=hK(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=uZ(t.alphaRegularizer),this.alphaConstraint=lX(t.alphaConstraint),null==t.sharedAxes)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else{if("number"!=typeof t.sharedAxes)throw new Iq(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`);this.sharedAxes=[t.sharedAxes]}}build(t){const e=(t=bK(t)).slice(1);if(null!=this.sharedAxes)for(const r of this.sharedAxes)e[r-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let r=1;r<t.length;++r)n[r]=t[r];this.inputSpec=[new EK({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=vK(t),VV(t,this.alpha.read())}getConfig(){const t={alphaInitializer:uK(this.alphaInitializer),alphaRegularizer:lZ(this.alphaRegularizer),alphaConstraint:oX(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}pZ.className="PReLU",d.registerClass(pZ);class fZ extends kK{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==this.DEFAULT_ALPHA)throw new Nq(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=vK(t);return wz(n)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}fZ.className="ELU",d.registerClass(fZ);class mZ extends kK{constructor(t){super(null==t?{}:t),this.DEFAULT_THETA=1,null==t&&(t={}),this.theta=null==t.theta?this.DEFAULT_THETA:t.theta}call(t,e){const n=vK(t);return n.mul(MX(n.greater(this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}mZ.className="ThresholdedReLU",d.registerClass(mZ);class gZ extends kK{constructor(t){super(null==t?{}:t),this.DEFAULT_AXIS=1,null==t&&(t={}),this.softmax=(new tZ).apply,this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis}call(t,e){const n=vK(t);return this.softmax(n,this.axis)}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function yZ(t,e,n){if("number"==typeof t)return Dq(t,e);if(t.length!==e)throw new Iq(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${t.length} elements.`);for(let i=0;i<e;++i){const s=t[i];if((r=s)!==parseInt(r.toString(),10))throw new Iq(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(t)} including a non-integer number ${s}`)}return t;var r}function vZ(t,e,n,r,i=1){if(null==t)return t;let s;return s="same"===n?t:t-(e+(e-1)*(i-1))+1,Math.floor((s+r-1)/r)}function bZ(t,e,n,r){if(null==t)return null;if("valid"===r)t=t*e+TX([n-e,0]);else{if("same"!==r)throw new Iq(`Unsupport padding mode: ${r}.`);t*=e}return t}function _Z(t,e){return oB(()=>(fX(e),"channelsFirst"===e?N$(t,[0,2,3,1]):t))}function xZ(t,e){return oB(()=>(fX(e),"channelsFirst"===e?N$(t,[0,2,3,4,1]):t))}function wZ(t,e,n,r=[1,1],i="valid",s,o,a=null){return oB(()=>{if(null==s&&(s="channelsLast"),fX(s),3!==t.rank&&4!==t.rank)throw new Iq(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(3!==e.rank&&4!==e.rank)throw new Iq(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let c=_Z(t,s);if("causal"===i)throw new Nq("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return c=l.conv2d({x:c,filter:e,strides:r,pad:"same"===i?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:a}),"channelsFirst"===s&&(c=N$(c,[0,3,1,2])),c})}gZ.className="Softmax",d.registerClass(gZ);class SZ extends kK{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",SZ.verifyArgs(e),this.rank=t,Yq(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new Nq(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=yZ(e.kernelSize,t,"kernelSize"),this.strides=yZ(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,mX(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,fX(this.dataFormat),this.activation=iZ(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=hK(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=lX(e.biasConstraint),this.biasRegularizer=uZ(e.biasRegularizer),this.activityRegularizer=uZ(e.activityRegularizer),this.dilationRate=yZ(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new Iq(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new Iq(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new Iq(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(Lq("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!Kq(t.kernelSize,"number",1,3))throw new Iq(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:nZ(this.activation),useBias:this.useBias,biasInitializer:uK(this.biasInitializer),biasRegularizer:lZ(this.biasRegularizer),activityRegularizer:lZ(this.activityRegularizer),biasConstraint:oX(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class EZ extends SZ{constructor(t,e){super(t,e),this.kernel=null,EZ.verifyArgs(e),this.filters=e.filters,Yq(this.filters,"filters"),this.kernelInitializer=hK(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=lX(e.kernelConstraint),this.kernelRegularizer=uZ(e.kernelRegularizer)}build(t){t=bK(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new Iq(`The channel dimension of the input should be defined. Found ${t[e]}`);const n=t[e],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return oB(()=>{let e;t=vK(t);const n=null==this.bias?null:this.bias.read(),r=Jq(this.activation.getClassName());if(null!=r&&2===this.rank)e=wZ(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)e=function(t,e,n,r=1,i="valid",s,o=1){return oB(()=>{if(null==s&&(s="channelsLast"),fX(s),3!==t.shape.length)throw new Iq(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(3!==e.shape.length)throw new Iq(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new Iq(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if("channelsFirst"===s&&(t=N$(t,[0,2,1])),"causal"===i)throw new Nq("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=QB(t,e,r,"same"===i?"same":"valid","NWC",o);return null!=n&&(a=VX(a,n)),a})}(t,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)e=wZ(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new Nq("convolutions greater than 3D are not implemented yet.");e=function(t,e,n,r=[1,1,1],i="valid",s,o){return oB(()=>{if(null==s&&(s="channelsLast"),fX(s),4!==t.rank&&5!==t.rank)throw new Iq(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(4!==e.rank&&5!==e.rank)throw new Iq(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let a=xZ(t,s);if("causal"===i)throw new Nq("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=nz(a,e,r,"same"===i?"same":"valid","NDHWC",o),null!=n&&(a=VX(a,n)),"channelsFirst"===s&&(a=N$(a,[0,4,1,2,3])),a})}(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(e=this.activation.apply(e))}return e})}computeOutputShape(t){t=bK(t);const e=[],n="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let i=0;i<n.length;++i){const t=vZ(n[i],this.kernelSize[i],this.padding,this.strides[i],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[i]);e.push(t)}let r=[t[0]];return"channelsLast"===this.dataFormat?(r=r.concat(e),r.push(this.filters)):(r.push(this.filters),r=r.concat(e)),r}getConfig(){const t={filters:this.filters,kernelInitializer:uK(this.kernelInitializer),kernelRegularizer:lZ(this.kernelRegularizer),kernelConstraint:oX(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new Iq(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class CZ extends EZ{constructor(t){super(2,t),CZ.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!Kq(t.kernelSize,"number",1,2))throw new Iq(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}CZ.className="Conv2D",d.registerClass(CZ);class TZ extends EZ{constructor(t){super(3,t),TZ.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&(!Array.isArray(t.kernelSize)||1!==t.kernelSize.length&&3!==t.kernelSize.length))throw new Iq(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}TZ.className="Conv3D",d.registerClass(TZ);class AZ extends CZ{constructor(t){if(super(t),this.inputSpec=[new EK({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new Iq(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(4!==(t=bK(t)).length)throw new Iq("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new Iq("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new EK({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return oB(()=>{let e=vK(t);if(4!==e.shape.length)throw new Iq(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${e.shape.length}`);const n=e.shape;let r,i;"channelsFirst"===this.dataFormat?(r=2,i=3):(r=1,i=2);const s=n[i],o=this.kernelSize[1],a=this.strides[1],l=[n[0],bZ(n[r],this.strides[0],this.kernelSize[0],this.padding),bZ(s,a,o,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=N$(e,[0,2,3,1]));let c=ez(e,this.kernel.read(),l,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(c=N$(c,[0,3,1,2])),null!=this.bias&&(c=VX(c,this.bias.read(),this.dataFormat)),null!=this.activation&&(c=this.activation.apply(c)),c})}computeOutputShape(t){const e=(t=bK(t)).slice();let n,r,i;"channelsFirst"===this.dataFormat?(n=1,r=2,i=3):(n=3,r=1,i=2);const s=this.kernelSize[0],o=this.kernelSize[1],a=this.strides[0],l=this.strides[1];return e[n]=this.filters,e[r]=bZ(e[r],a,s,this.padding),e[i]=bZ(e[i],l,o,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}AZ.className="Conv2DTranspose",d.registerClass(AZ);class MZ extends EZ{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==e.filters)throw new Iq("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=e.kernelInitializer||null!=e.kernelRegularizer||null!=e.kernelConstraint)throw new Iq("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=e.padding&&"same"!==e.padding&&"valid"!==e.padding)throw new Iq(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=hK(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=uZ(e.depthwiseRegularizer),this.depthwiseConstraint=lX(e.depthwiseConstraint),this.pointwiseInitializer=hK(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=uZ(e.pointwiseRegularizer),this.pointwiseConstraint=lX(e.pointwiseConstraint)}build(t){if((t=bK(t)).length<this.rank+2)throw new Iq(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e]||t[e]<0)throw new Iq(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);const n=t[e],r=this.kernelSize.concat([n,this.depthMultiplier]),i=[];for(let o=0;o<this.rank;++o)i.push(1);i.push(n*this.depthMultiplier,this.filters);const s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):null,this.inputSpec=[new EK({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return oB(()=>{let e;if(t=vK(t),1===this.rank)throw new Nq("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(t=N$(t,[0,2,3,1])),e=pU(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(e=VX(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),"channelsFirst"===this.dataFormat&&(e=N$(e,[0,3,1,2])),e})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=uK(this.depthwiseInitializer),t.pointwiseInitializer=uK(this.pointwiseInitializer),t.depthwiseRegularizer=lZ(this.depthwiseRegularizer),t.pointwiseRegularizer=lZ(this.pointwiseRegularizer),t.depthwiseConstraint=oX(this.depthwiseConstraint),t.pointwiseConstraint=oX(this.pointwiseConstraint),t}}MZ.className="SeparableConv";class kZ extends MZ{constructor(t){super(2,t)}}kZ.className="SeparableConv2D",d.registerClass(kZ);class RZ extends EZ{constructor(t){super(1,t),RZ.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!Kq(t.kernelSize,"number",1,1))throw new Iq(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}RZ.className="Conv1D",d.registerClass(RZ);class IZ extends kK{constructor(t){super(t),this.cropping="number"==typeof t.cropping?[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"==typeof t.cropping[0]?[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:t.cropping,this.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return oB(()=>{if(t=vK(t),"channelsLast"===this.dataFormat){const e=NX(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return NX(e,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const e=NX(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return NX(e,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}IZ.className="Cropping2D",d.registerClass(IZ);class NZ extends kK{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==t.size?this.DEFAULT_SIZE:t.size,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],null==t[2]?null:this.size[0]*t[2],null==t[3]?null:this.size[1]*t[3]]:[t[0],null==t[1]?null:this.size[0]*t[1],null==t[2]?null:this.size[1]*t[2],t[3]]}call(t,e){return oB(()=>{let e=vK(t);const n=e.shape;if("channelsFirst"===this.dataFormat){e=N$(e,[0,2,3,1]);const t=e.resizeNearestNeighbor([this.size[0]*n[2],this.size[1]*n[3]]);return N$(t,[0,3,1,2])}return e.resizeNearestNeighbor([this.size[0]*n[1],this.size[1]*n[2]])})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}NZ.className="UpSampling2D",d.registerClass(NZ);class OZ extends SZ{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=hK(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=lX(t.depthwiseConstraint),this.depthwiseRegularizer=uZ(t.depthwiseRegularizer)}build(t){if((t=bK(t)).length<4)throw new Iq(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e="channelsFirst"===this.dataFormat?1:3;if(null==t[e]||t[e]<0)throw new Iq(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const n=t[e];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return oB(()=>{let e=function(t,e,n=[1,1],r="valid",i,s){return oB(()=>{null==i&&(i="channelsLast"),fX(i);let o=_Z(t,i);if(4!==t.rank)throw new Iq(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(4!==e.rank)throw new Iq(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return o=cz(o,e,n,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===i&&(o=N$(o,[0,3,1,2])),o})}(t=vK(t),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(e=VX(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),e})}computeOutputShape(t){t=bK(t);const e="channelsFirst"===this.dataFormat?t[3]:t[2],n="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,r=vZ("channelsFirst"===this.dataFormat?t[2]:t[1],this.kernelSize[0],this.padding,this.strides[0]),i=vZ(e,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],n,r,i]:[t[0],r,i,n]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=uK(this.depthwiseInitializer),t.depthwiseRegularizer=lZ(this.depthwiseRegularizer),t.depthwiseConstraint=oX(this.depthwiseRegularizer),t}}OZ.className="DepthwiseConv2D",d.registerClass(OZ);class DZ extends kK{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const e=t.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?e[r]:this.noiseShape[r]);return n}call(t,e){return oB(()=>{this.invokeCallHook(t,e);const n=vK(t);if(0<this.rate&&this.rate<1){const t=null!=e.training&&e.training,r=this.getNoiseShape(n);return HX(()=>UX(n,this.rate,r,this.seed),()=>n,t)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}DZ.className="Dropout",d.registerClass(DZ);class LZ extends DZ{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}LZ.className="SpatialDropout1D",d.registerClass(LZ);class FZ extends kK{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,Yq(this.units,"units"),this.activation=iZ(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=hK(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=hK(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=lX(t.kernelConstraint),this.biasConstraint=lX(t.biasConstraint),this.kernelRegularizer=uZ(t.kernelRegularizer),this.biasRegularizer=uZ(t.biasRegularizer),this.activityRegularizer=uZ(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const e=(t=bK(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){const e=(t=bK(t)).slice();return e[e.length-1]=this.units,e}call(t,e){return oB(()=>{this.invokeCallHook(t,e);const n=vK(t),r=Jq(this.activation.getClassName());let i;return null!=r?i=PX(n,this.kernel.read(),r,this.bias?this.bias.read():null):(i=PX(n,this.kernel.read()),null!=this.bias&&(i=VX(i,this.bias.read())),null!=this.activation&&(i=this.activation.apply(i))),i})}getConfig(){const t={units:this.units,activation:nZ(this.activation),useBias:this.useBias,kernelInitializer:uK(this.kernelInitializer),biasInitializer:uK(this.biasInitializer),kernelRegularizer:lZ(this.kernelRegularizer),biasRegularizer:lZ(this.biasRegularizer),activityRegularizer:lZ(this.activityRegularizer),kernelConstraint:oX(this.kernelConstraint),biasConstraint:oX(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}FZ.className="Dense",d.registerClass(FZ);class PZ extends kK{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=bK(t);for(const e of t.slice(1))if(null==e)throw new Iq(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],SX(t,1)]}call(t,e){return oB(()=>{this.invokeCallHook(t,e);let n=vK(t);if("channelsFirst"===this.dataFormat&&n.rank>1){const t=[0];for(let e=2;e<n.rank;++e)t.push(e);t.push(1),n=n.transpose(t)}return function(t){if(t.rank<=1)throw new Iq(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const e=[t.shape[0],SX(t.shape,1)];return t.reshape(e)}(n)})}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}PZ.className="Flatten",d.registerClass(PZ);class $Z extends kK{constructor(t){super(t),this.supportsMasking=!0,this.activation=iZ(t.activation)}call(t,e){return oB(()=>{this.invokeCallHook(t,e);const n=vK(t);return this.activation.apply(n)})}getConfig(){const t={activation:nZ(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}$Z.className="Activation",d.registerClass($Z);class BZ extends kK{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return oB(()=>{return t=vK(t),e=t,n=this.n,oB(()=>{if(2!==e.shape.length)throw new Iq(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return LX(kX(e,1),[1,n,1])});var e,n})}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}BZ.className="RepeatVector",d.registerClass(BZ);class zZ extends kK{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,e){const n="Total size of new array must be unchanged.",r=e.slice();let i=1,s=null;for(let a=0;a<r.length;++a){const t=r[a];if(this.isUnknown(t)){if(null!==s)throw new Iq("Can only specifiy one unknown dimension.");s=a}else i*=t}const o=SX(t);if(null!==s){if(0===i||o%i!=0)throw new Iq(n);r[s]=o/i}else if(o!==i)throw new Iq(n);return r}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return oB(()=>{this.invokeCallHook(t,e);const n=vK(t),r=n.shape,i=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return n.reshape(i)})}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}zZ.className="Reshape",d.registerClass(zZ);class VZ extends kK{constructor(t){if(super(t),null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const e=AX(1,t.dims.length+1);if(!r.arraysEqual(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new EK({ndim:this.dims.length+1})]}computeOutputShape(t){const e=(t=bK(t)).slice();return this.dims.forEach((n,r)=>{e[r+1]=t[n]}),e}call(t,e){return N$(vK(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}VZ.className="Permute",d.registerClass(VZ);class UZ extends kK{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const n=vK(t);return D$(kV(n,this.maskValue),-1)}call(t,e){return oB(()=>{this.invokeCallHook(t,e);const n=vK(t),r=D$(kV(n,this.maskValue),-1,!0);return n.mul(r.asType(n.dtype))})}}UZ.className="Masking",d.registerClass(UZ);class HZ extends kK{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=null==t.inputLength?[e,null]:[e].concat($q(t.inputLength))}this.inputDim=t.inputDim,Yq(this.inputDim,"inputDim"),this.outputDim=t.outputDim,Yq(this.outputDim,"outputDim"),this.embeddingsInitializer=hK(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=uZ(t.embeddingsRegularizer),this.activityRegularizer=uZ(t.activityRegularizer),this.embeddingsConstraint=lX(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return oB(()=>this.maskZero?(t=vK(t),kV(t,bz(t))):null)}computeOutputShape(t){if(t=bK(t),null==this.inputLength)return[...t,this.outputDim];const e=$q(this.inputLength);if(e.length!==t.length-1)throw new Iq(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let n=0;for(let r=0;r<e.length;++r){const i=e[r],s=t[r+1];if(null!=i&&null!=s&&i!==s)throw new Iq(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);null==i&&(e[n]=s),n++}}return[t[0],...e,this.outputDim]}call(t,e){return oB(()=>{this.invokeCallHook(t,e);let n=vK(t);return"int32"!==n.dtype&&(n=MX(n,"int32")),$X(this.embeddings.read(),n.as1D()).reshape(bK(this.computeOutputShape(n.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:uK(this.embeddingsInitializer),embeddingsRegularizer:lZ(this.embeddingsRegularizer),activityRegularizer:lZ(this.activityRegularizer),embeddingsConstraint:oX(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}HZ.className="Embedding",d.registerClass(HZ);class WZ extends kK{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new Nq}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const n=t.slice(0,t.length-e.length);for(let r=0;r<e.length;++r){const i=t[t.length-e.length+r],s=e[r];if(null==i||null==s||i<0||s<0)n.push(null);else if(1===i)n.push(s);else if(1===s)n.push(i);else{if(i!==s)throw new Iq("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(i)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[bK(t)]),(t=t).length<2)throw new Iq(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const i of t)null!=i&&null!==i[0]&&e.push(i[0]);if(e=Gq(e),e.length>1)throw new Iq(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let n=null==t[0]?null:t[0].slice(1);for(let i=1;i<t.length;++i){const e=null==t[i]?null:t[i].slice(1);n=this.computeElementwiseOpOutputShape(n,e)}const r=t.map(t=>t.length);this.reshapeRequired=-1!==t.indexOf(null)||1!==Gq(r).length}call(t,e){return oB(()=>{if(t=t,this.reshapeRequired){const e=[],n=t.map(t=>t.rank);if(-1===n.indexOf(null)){const r=TX(n);for(let n of t){const t=n.rank;for(let e=0;e<r-t;++e)n=kX(n,1);e.push(n)}return this.mergeFunction(e)}{let n=!1;for(const s of t){const t=s.rank;if(null==t){const t=s.shape,r=t[0],i=t.slice(1).concat([r]);let o=s.reshape([r].concat(SX(t.slice(1))));o=N$(o,[1,0]),o=o.reshape(i),e.push(o),n=!0}else if(t>1){const r=AX(1,t).concat([0]);e.push(N$(s,r)),n=!0}else e.push(s)}let r=this.mergeFunction(e);const i=r.rank;if(n)if(null==i){const t=r.shape,e=t[t.length-1],n=[e].concat(t.slice(0,t.length-1));r=N$(r.reshape([-1,e]),[1,0]).reshape(n)}else if(i>1){const t=[i-1].concat(AX(0,i-1));r=N$(r,t)}return r}}return this.mergeFunction(t)})}computeOutputShape(t){let e;e=null==(t=t)[0]?null:t[0].slice(1);for(let r=1;r<t.length;++r){const n=null==t[r]?null:t[r].slice(1);e=this.computeElementwiseOpOutputShape(e,n)}let n=[];for(const r of t)null!=r&&null!==r[0]&&n.push(r[0]);return n=Gq(n),e=1===n.length?n.concat(e):[null].concat(e),e}computeMask(t,e){return oB(()=>{if(null==e)return null;if(!Array.isArray(e))throw new Iq("`mask` should be an Array");if(!Array.isArray(t))throw new Iq("`inputs` should be an Array");if(e.length!==t.length)throw new Iq(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(t=>null==t))return null;let n=(e=e.map(t=>null==t?t:Cz(t,0)))[0];for(let t=1;t<e.length-1;++t)n=dV(n,e[t]);return n})}}class jZ extends WZ{constructor(t){super(t)}mergeFunction(t){return oB(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=x$(e,t[n]);return e})}}jZ.className="Add",d.registerClass(jZ);class GZ extends WZ{constructor(t){super(t)}mergeFunction(t){return oB(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=yB(e,t[n]);return e})}}GZ.className="Multiply",d.registerClass(GZ);class qZ extends WZ{constructor(t){super(t)}mergeFunction(t){return oB(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=x$(e,t[n]);return yB(1/t.length,e)})}}qZ.className="Average",d.registerClass(qZ);class XZ extends WZ{constructor(t){super(t)}mergeFunction(t){return oB(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=Kz(e,t[n]);return e})}}XZ.className="Maximum",d.registerClass(XZ);class KZ extends WZ{constructor(t){super(t)}mergeFunction(t){return oB(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=SV(e,t[n]);return e})}}KZ.className="Minimum",d.registerClass(KZ);class YZ extends WZ{constructor(t){super(t),this.DEFAULT_AXIS=-1,null==t&&(t={}),this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new Iq("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(const r of t)if(null!=r){e=!1;break}if(e)return;const n=[];for(let i=0;i<t.length;++i){const e=t[i].slice();e.splice(this.axis,1);let s=!1;for(const t of n)if(r.arraysEqual(t,e)){s=!0;break}s||n.push(e)}if(n.length>1)throw new Iq("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return oB(()=>OX(t,this.axis))}computeOutputShape(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new Iq("A `Concatenate` layer should be called on a list of inputs.");const e=t,n=e[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const i of e.slice(1)){if(null==n[r]||null==i[r]){n[r]=null;break}n[r]+=i[r]}return n}computeMask(t,e){if(null==e)return null;if(!Array.isArray(e))throw new Iq("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new Iq("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new Iq(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return oB(()=>{let n=!0;if(e.forEach(t=>{null==t||(n=!1)}),n)return null;const r=[];for(let s=0;s<t.length;++s)r.push(null==e[s]?IV(t[s]).asType("bool"):e[s].rank<t[s].rank?Cz(e[s],-1):e[s]);const i=mB(r,this.axis);return O$(i,-1,!1)})}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function ZZ(t,e){for(;t<0;)t+=e;return t}YZ.className="Concatenate",d.registerClass(YZ);class JZ extends WZ{constructor(t){super(t),this.axes=t.axes,this.normalize=null!=t.normalize&&t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){r.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0],n=t[1];if(e.length>3||n.length>3)throw new Nq("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(e,n);if(e[i[0]]!==n[i[1]])throw new Iq(`Dimension incompatibility: ${e[i[0]]} !== ${n[i[1]]}`)}mergeFunction(t){if(2!==t.length)throw new Iq(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e,n=t[0],i=t[1];return e=Array.isArray(this.axes)?this.axes.map((e,n)=>ZZ(e,t[n].shape.length)):[ZZ(this.axes,n.shape.length),ZZ(this.axes,i.shape.length)],this.normalize&&(n=WK(n,e[0]),i=WK(i,e[1])),function(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new Nq("batchDot is not implemented for tensors of 4D or higher rank yet");if(r.assert(t.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`),r.assert(t.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),"number"==typeof n&&(n=[n,n]),"complex64"===t.dtype||"complex64"===e.dtype)throw new Nq("batchDot is not implemented for complex64-type Tensors yet.");const i=t.shape.length,s=e.shape.length;null==n&&(n=[i-1,s-2]);const o=n;return oB(()=>{let n,r;if(i>s){n=i-s;const t=[];for(let e=0;e<n;++e)t.push(1);e=e.reshape(e.shape.concat(t))}else if(s>i){n=s-i;const e=[];for(let t=0;t<n;++t)e.push(1);t=t.reshape(t.shape.concat(e))}else n=0;if(r=2===t.shape.length&&2===e.shape.length?o[0]===o[1]?t.mul(e).sum(o[0]):t.transpose([1,0]).mul(e).sum(o[1]):t.matMul(e,o[0]!==t.shape.length-1,o[1]===e.shape.length-1),n>0){let t;t=i>s?i+s-3:i-1;const e=[];for(let r=t;r<t+n;++r)e.push(r);r=r.squeeze(e)}return 1===r.shape.length&&(r=r.expandDims(1)),r})}(n,i,e)}interpretAxes(t,e){let n;return n=Array.isArray(this.axes)?this.axes:[ZZ(this.axes,t.length),ZZ(this.axes,e.length)],n}computeOutputShape(t){r.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new Nq("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(e,n);e.splice(i[0],1),n.splice(i[1],1),n.splice(0,1);const s=e.concat(n);return 1===s.length&&s.push(1),s}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}JZ.className="Dot",d.registerClass(JZ);class QZ extends kK{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return oB(()=>{this.invokeCallHook(t,e);const n=vK(t);return HX(()=>FX(n.shape,0,this.stddev).add(n),()=>n,e.training||!1)})}}QZ.className="GaussianNoise",d.registerClass(QZ);class tJ extends kK{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return oB(()=>{this.invokeCallHook(t,e);const n=vK(t);return this.rate>0&&this.rate<1?HX(()=>{const t=Math.sqrt(this.rate/(1-this.rate));return n.mul(FX(n.shape,1,t))},()=>n,e.training||!1):n})}}tJ.className="GaussianDropout",d.registerClass(tJ);class eJ extends kK{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||vK(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return oB(()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(t);return HX(()=>{const e=vK(t),r=-1.7580993408473766;let i=Bz(ZV(n),this.rate);i=MX(i,"float32");const s=((1-this.rate)*(1+this.rate*r**2))**-.5,o=-s*r*this.rate;return e.mul(i).add(i.add(-1).mul(r)).mul(s).add(o)},()=>vK(t),e.training||!1)}return t})}}function nJ(t,e,n,r,i,s=.001){let o;if(2===t.rank)o=BB(t,e,n,r,i,s);else if(3===t.rank)o=zB(t,e,n,r,i,s);else{if(4!==t.rank)throw new Nq(`batchNormalization is not implemented for array of rank ${t.rank} yet`);o=VB(t,e,n,r,i,s)}return o}eJ.className="AlphaDropout",d.registerClass(eJ);class rJ extends kK{constructor(t){null==t&&(t={}),super(t),this.supportsMasking=!0,this.axis=null==t.axis?-1:t.axis,this.momentum=null==t.momentum?.99:t.momentum,this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=hK(t.betaInitializer||"zeros"),this.gammaInitializer=hK(t.gammaInitializer||"ones"),this.movingMeanInitializer=hK(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=hK(t.movingVarianceInitializer||"ones"),this.betaConstraint=lX(t.betaConstraint),this.gammaConstraint=lX(t.gammaConstraint),this.betaRegularizer=uZ(t.betaRegularizer),this.gammaRegularizer=uZ(t.gammaRegularizer)}build(t){t=bK(t);const e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(null==n)throw new Iq(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new EK({ndim:t.length,axes:{[e]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return oB(()=>{const n=null!=e.training&&e.training,i=vK(t),s=i.shape,o=s.length,a=AX(0,o),l=this.axis>=0?this.axis:this.axis+o;a.splice(l,1);const c=Dq(1,o);c[l]=s[l];const u=a.slice();u.sort();const h=!r.arraysEqual(u,AX(0,o).slice(0,o-1));if(!n)return(()=>{if(h){const t=this.movingMean.read().reshape(c),e=this.movingVariance.read().reshape(c),n=this.center?this.beta.read().reshape(c):null,r=this.scale?this.gamma.read().reshape(c):null;return nJ(i,t,e,n,r,this.epsilon)}return nJ(i,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[d,p,f]=function(t,e,n,i,s=.001){return r.arraysEqual(i.slice().sort(),AX(0,t.rank-1))?function(t,e,n,r,i=.001){return oB(()=>{const s=TV(t,r),o=s.mean,a=s.variance;return[nJ(t,o,a,n,e,i),o,a]})}(t,e,n,i,s):function(t,e,n,r,i=.001){return oB(()=>{const s=TV(t,r),o=s.mean,a=s.variance,l=[];for(const e of AX(0,t.rank))-1!==r.indexOf(e)?l.push(1):l.push(t.shape[e]);const c=o.reshape(l),u=a.reshape(l),h=null==e?null:e.reshape(l),d=null==n?null:n.reshape(l);return[nJ(t,c,u,d,h,i),o,a]})}(t,e,n,i,s)}(i,this.gamma.read(),this.beta.read(),a,this.epsilon),m=(t,e,n)=>{oB(()=>{const r=1-n,i=t.read(),s=i.sub(e).mul(r);t.write(i.sub(s))})};return(()=>{m(this.movingMean,p,this.momentum),m(this.movingVariance,f,this.momentum)})(),d})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:uK(this.betaInitializer),gammaInitializer:uK(this.gammaInitializer),movingMeanInitializer:uK(this.movingMeanInitializer),movingVarianceInitializer:uK(this.movingVarianceInitializer),betaRegularizer:lZ(this.betaRegularizer),gammaRegularizer:lZ(this.gammaRegularizer),betaConstraint:oX(this.betaConstraint),gammaConstraint:oX(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}rJ.className="BatchNormalization",d.registerClass(rJ);class iJ extends kK{constructor(t){if(null==t&&(t={}),super(t),this.axis=null==t.axis?-1:t.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=hK(t.betaInitializer||"zeros"),this.gammaInitializer=hK(t.gammaInitializer||"ones"),this.betaRegularizer=uZ(t.betaRegularizer),this.gammaRegularizer=uZ(t.gammaRegularizer),this.supportsMasking=!0}build(t){const e=(t=bK(t)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=e);for(const r of this.axis)if(r<0||r>=e)throw new Error(`Invalid axis: ${r}`);if(this.axis.length!==Gq(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map(e=>t[e]);this.gamma=this.scale?this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(t,e){const n=vK(t),r=n.shape,i=r.length;return oB(()=>{let{mean:t,variance:e}=TV(n,this.axis,!0);const s=Dq(1,i);for(const n of this.axis)s[n]=r[n];const o=t=>null!=t&&t.shape.length!==i&&this.axis!==[i-1]?t.reshape(s):t;let a=o(this.gamma.read()),l=o(this.beta.read());const c=[],u=[];for(let n=0;n<i;++n)-1!==this.axis.indexOf(n)?(c.push(r[n]),u.push(1)):(c.push(1),u.push(r[n]));return t=t.tile(c),e=e.tile(c),a=a.tile(u),l=l.tile(u),nJ(n,t,e,l,a,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:uK(this.betaInitializer),gammaInitializer:uK(this.gammaInitializer),betaRegularizer:lZ(this.betaRegularizer),gammaRegularizer:lZ(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}iJ.className="LayerNormalization",d.registerClass(iJ);class sJ extends kK{constructor(t){if(null==t&&(t={}),super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,null==t.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof t.padding)this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new Iq(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,n;if("number"==typeof t.padding[0])e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new Iq(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],2!==t.padding[1].length)throw new Iq(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new EK({ndim:4})]}computeOutputShape(t){let e,n;return t=bK(t),"channelsFirst"===this.dataFormat?(e=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],e,n]):(e=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],e,n,t[3]])}call(t,e){return oB(()=>{return e=vK(t),n=this.padding,r=this.dataFormat,oB(()=>{if(4!==e.rank)throw new Iq(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new Iq("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new Iq(`Unknown data format: ${r}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let t;return t="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],OV(e,t)});var e,n,r})}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}function oJ(t,e,n,r,i,s){return oB(()=>{let o;fX(i),gX(s),mX(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==i&&(i="channelsLast"),null==s&&(s="max"),t=_Z(t,i);const a="same"===r?"same":"valid";return o="max"===s?gV(t,e,n,a):nB(t,e,n,a),"channelsFirst"===i&&(o=N$(o,[0,3,1,2])),o})}function aJ(t,e,n,r,i,s){return oB(()=>{let o;fX(i),gX(s),mX(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==i&&(i="channelsLast"),null==s&&(s="max"),t=xZ(t,i);const a="same"===r?"same":"valid";return o="max"===s?yV(t,e,n,a):uB(t,e,n,a),"channelsFirst"===i&&(o=N$(o,[0,4,1,2,3])),o})}sJ.className="ZeroPadding2D",d.registerClass(sJ);class lJ extends kK{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new Iq(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if(Yq(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new Iq(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}Yq(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,mX(this.padding),this.inputSpec=[new EK({ndim:3})]}computeOutputShape(t){const e=vZ((t=bK(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return oB(()=>{this.invokeCallHook(t,e),t=kX(vK(t),2);const n=this.poolingFunction(vK(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return CU(n,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class cJ extends lJ{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return fX(i),mX(r),oJ(t,e,n,r,i,"max")}}cJ.className="MaxPooling1D",d.registerClass(cJ);class uJ extends lJ{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return fX(i),mX(r),oJ(t,e,n,r,i,"avg")}}uJ.className="AveragePooling1D",d.registerClass(uJ);class hJ extends kK{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new Iq(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];Yq(this.poolSize,"poolSize"),Yq(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,fX(this.dataFormat),mX(this.padding),this.inputSpec=[new EK({ndim:4})]}computeOutputShape(t){t=bK(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2];return e=vZ(e,this.poolSize[0],this.padding,this.strides[0]),n=vZ(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return oB(()=>(this.invokeCallHook(t,e),this.poolingFunction(vK(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class dJ extends hJ{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return fX(i),mX(r),oJ(t,e,n,r,i,"max")}}dJ.className="MaxPooling2D",d.registerClass(dJ);class pJ extends hJ{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return fX(i),mX(r),oJ(t,e,n,r,i,"avg")}}pJ.className="AveragePooling2D",d.registerClass(pJ);class fJ extends kK{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new Iq(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];Yq(this.poolSize,"poolSize"),Yq(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,fX(this.dataFormat),mX(this.padding),this.inputSpec=[new EK({ndim:5})]}computeOutputShape(t){t=bK(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[4]:t[3];return e=vZ(e,this.poolSize[0],this.padding,this.strides[0]),n=vZ(n,this.poolSize[1],this.padding,this.strides[1]),r=vZ(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n,r]:[t[0],e,n,r,t[4]]}call(t,e){return oB(()=>(this.invokeCallHook(t,e),this.poolingFunction(vK(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class mJ extends fJ{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return fX(i),mX(r),aJ(t,e,n,r,i,"max")}}mJ.className="MaxPooling3D",d.registerClass(mJ);class gJ extends fJ{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return fX(i),mX(r),aJ(t,e,n,r,i,"avg")}}gJ.className="AveragePooling3D",d.registerClass(gJ);class yJ extends kK{constructor(t){super(t),this.inputSpec=[new EK({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new Nq}}class vJ extends yJ{constructor(t){super(t||{})}call(t,e){return oB(()=>{const e=vK(t);return xV(e,1)})}}vJ.className="GlobalAveragePooling1D",d.registerClass(vJ);class bJ extends yJ{constructor(t){super(t||{})}call(t,e){return oB(()=>{const e=vK(t);return aV(e,1)})}}bJ.className="GlobalMaxPooling1D",d.registerClass(bJ);class _J extends kK{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,fX(this.dataFormat),this.inputSpec=[new EK({ndim:4})]}computeOutputShape(t){return t=t,"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new Nq}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class xJ extends _J{call(t,e){return oB(()=>{const e=vK(t);return xV(e,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}xJ.className="GlobalAveragePooling2D",d.registerClass(xJ);class wJ extends _J{call(t,e){return oB(()=>{const e=vK(t);return aV(e,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}function SJ(t,e,n,r){if(Array.isArray(t)){if(null!=e||null!=n)throw new Iq("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function i(t){return null==t||Array.isArray(t)?t:[t]}return{inputs:t,initialState:e=i(e),constants:n=i(n)}}function EJ(t,e,n,r=!1,i,s,o=!1,a=!1){return oB(()=>{const l=e.shape.length;if(l<3)throw new Iq(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(AX(2,l));if(e=N$(e,c),null!=s)throw new Nq("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=i&&((i=i.asType("bool").asType("float32")).rank===l-1&&(i=Cz(i,-1)),i=N$(i,c)),r&&(e=Hz(e,0),null!=i&&(i=Hz(i,0)));const u=[];let h,d=n;const p=e.shape[0],f=$U(e);let m,g;null!=i&&(m=$U(i));for(let e=0;e<p;++e){const n=f[e],r=oB(()=>t(n,d));if(null==i)h=r[0],d=r[1];else{const t=oB(()=>{const t=m[e],n=IV(t).sub(t);return{output:r[0].mul(t).add(d[0].mul(n)),newStates:d.map((e,i)=>r[1][i].mul(t).add(e.mul(n)))}});h=t.output,d=t.newStates}a&&u.push(h)}return a&&(g=TU(u,1)),[h,g,d]})}wJ.className="GlobalMaxPooling2D",d.registerClass(wJ);class CJ extends kK{constructor(t){let e;if(super(t),null==t.cell)throw new Iq("cell property is missing for the constructor of RNN.");if(e=Array.isArray(t.cell)?new OJ({cells:t.cell}):t.cell,null==e.stateSize)throw new Iq("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=null!=t.returnSequences&&t.returnSequences,this.returnState=null!=t.returnState&&t.returnState,this.goBackwards=null!=t.goBackwards&&t.goBackwards,this._stateful=null!=t.stateful&&t.stateful,this.unroll=null!=t.unroll&&t.unroll,this.supportsMasking=!0,this.inputSpec=[new EK({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?AX(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(t=>null):this.states_}setStates(t){this.states_=t}computeOutputShape(t){gK(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const n=e[0];let r;if(r=this.returnSequences?[t[0],t[1],n]:[t[0],n],this.returnState){const n=[];for(const r of e)n.push([t[0],r]);return[r].concat(n)}return r}computeMask(t,e){return oB(()=>{Array.isArray(e)&&(e=e[0]);const t=this.returnSequences?e:null;if(this.returnState){const e=this.states.map(t=>null);return[t].concat(e)}return t})}get states(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let n=0;n<t;++n)e.push(null);return e}return this.states_}set states(t){this.states_=t}build(t){if(null!=this.numConstants)throw new Nq("Constants support is not implemented in RNN yet.");gK(t)&&(t=t[0]),t=t,this.inputSpec[0]=new EK({shape:[this.stateful?t[0]:null,null,t[t.length-1]]});const e=[t[0]].concat(t.slice(2));let n;if(this.cell.build(e),n=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!r.arraysEqual(this.stateSpec.map(t=>t.shape[t.shape.length-1]),n))throw new Iq(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=n.map(t=>new EK({shape:[null,t]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){oB(()=>{if(!this.stateful)throw new kq("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new Iq("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(t=>bV([n,t])):[bV([n,this.cell.stateSize])];else if(null==t)aB(this.states_),null!=this.keptStates&&(aB(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(t=>bV([n,t])):this.states_[0]=bV([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new Iq(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);!0===e?this.keptStates.push(this.states_.slice()):aB(this.states_);for(let e=0;e<this.states_.length;++e){const i=t[e],s=Array.isArray(this.cell.stateSize)?this.cell.stateSize[e]:this.cell.stateSize,o=[n,s];if(!r.arraysEqual(i.shape,o))throw new Iq(`State ${e} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${i.shape}`);this.states_[e]=i}}this.states_=this.states_.map(t=>lB(t.clone()))})}apply(t,e){let n=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const i=SJ(t,n,r,this.numConstants);t=i.inputs,n=i.initialState,r=i.constants;let s=[],o=[];if(null!=n){e.initialState=n,s=s.concat(n),this.stateSpec=[];for(const t of n)this.stateSpec.push(new EK({shape:t.shape}));o=o.concat(this.stateSpec)}if(null!=r&&(e.constants=r,s=s.concat(r),this.numConstants=r.length),s[0]instanceof CK){const n=[t].concat(s),r=this.inputSpec.concat(o),i=this.inputSpec;this.inputSpec=r;const a=super.apply(n,e);return this.inputSpec=i,a}return super.apply(t,e)}call(t,e){return oB(()=>{const n=null==e?null:e.mask,r=null==e?null:e.training;let i=null==e?null:e.initialState;t=vK(t),null==i&&(i=this.stateful?this.states_:this.getInitialState(t));const s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==s)throw new Iq(`RNN Layer has ${s} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:r},a=EJ((t,e)=>{const n=this.cell.call([t].concat(e),o);return[n[0],n.slice(1)]},t,i,this.goBackwards,n,null,this.unroll,this.returnSequences),l=a[0],c=a[1],u=a[2];this.stateful&&this.resetStates(u,r);const h=this.returnSequences?c:l;return this.returnState?[h].concat(u):h})}getInitialState(t){return oB(()=>{let e=bV(t.shape);return e=cV(e,[1,2]),e=kX(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(t=>t>1?LX(e,[1,t]):e):this.cell.stateSize>1?[LX(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const e=this.cell.getConfig();t.cell={className:this.cell.getClassName(),config:e};const n=super.getConfig();return Object.assign(t,n),t}static fromConfig(t,e,n={}){const r=HK(e.cell,n);return new t(Object.assign(e,{cell:r}))}}CJ.className="RNN",d.registerClass(CJ);class TJ extends kK{}class AJ extends TJ{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Yq(this.units,"units"),this.activation=iZ(null==t.activation?this.DEFAULT_ACTIVATION:t.activation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=hK(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=hK(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=hK(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=uZ(t.kernelRegularizer),this.recurrentRegularizer=uZ(t.recurrentRegularizer),this.biasRegularizer=uZ(t.biasRegularizer),this.kernelConstraint=lX(t.kernelConstraint),this.recurrentConstraint=lX(t.recurrentConstraint),this.biasConstraint=lX(t.biasConstraint),this.dropout=CX([1,TX([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=CX([1,TX([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=bK(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return oB(()=>{if(2!==(t=t).length)throw new Iq(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let n=t[1];t=t[0];const r=null!=e.training&&e.training;let i;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=DJ(()=>IV(t),this.dropout,r)),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=DJ(()=>IV(n),this.recurrentDropout,r));const s=this.dropoutMask,o=this.recurrentDropoutMask;i=PX(null!=s?yB(t,s):t,this.kernel.read()),null!=this.bias&&(i=VX(i,this.bias.read())),null!=o&&(n=yB(n,o));let a=x$(i,PX(n,this.recurrentKernel.read()));return null!=this.activation&&(a=this.activation.apply(a)),[a,a]})}getConfig(){const t={units:this.units,activation:nZ(this.activation),useBias:this.useBias,kernelInitializer:uK(this.kernelInitializer),recurrentInitializer:uK(this.recurrentInitializer),biasInitializer:uK(this.biasInitializer),kernelRegularizer:lZ(this.kernelRegularizer),recurrentRegularizer:lZ(this.recurrentRegularizer),biasRegularizer:lZ(this.biasRegularizer),activityRegularizer:lZ(this.activityRegularizer),kernelConstraint:oX(this.kernelConstraint),recurrentConstraint:oX(this.recurrentConstraint),biasConstraint:oX(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout},e=super.getConfig();return Object.assign(t,e),t}}AJ.className="SimpleRNNCell",d.registerClass(AJ);class MJ extends CJ{constructor(t){t.cell=new AJ(t),super(t)}call(t,e){return oB(()=>(null!=this.cell.dropoutMask&&(aB(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(aB(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}get units(){return this.cell.units}get activation(){return this.cell.activation}get useBias(){return this.cell.useBias}get kernelInitializer(){return this.cell.kernelInitializer}get recurrentInitializer(){return this.cell.recurrentInitializer}get biasInitializer(){return this.cell.biasInitializer}get kernelRegularizer(){return this.cell.kernelRegularizer}get recurrentRegularizer(){return this.cell.recurrentRegularizer}get biasRegularizer(){return this.cell.biasRegularizer}get kernelConstraint(){return this.cell.kernelConstraint}get recurrentConstraint(){return this.cell.recurrentConstraint}get biasConstraint(){return this.cell.biasConstraint}get dropout(){return this.cell.dropout}get recurrentDropout(){return this.cell.recurrentDropout}getConfig(){const t={units:this.units,activation:nZ(this.activation),useBias:this.useBias,kernelInitializer:uK(this.kernelInitializer),recurrentInitializer:uK(this.recurrentInitializer),biasInitializer:uK(this.biasInitializer),kernelRegularizer:lZ(this.kernelRegularizer),recurrentRegularizer:lZ(this.recurrentRegularizer),biasRegularizer:lZ(this.biasRegularizer),activityRegularizer:lZ(this.activityRegularizer),kernelConstraint:oX(this.kernelConstraint),recurrentConstraint:oX(this.recurrentConstraint),biasConstraint:oX(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout},e=super.getConfig();return delete e.cell,Object.assign(t,e),t}static fromConfig(t,e){return new t(e)}}MJ.className="SimpleRNN",d.registerClass(MJ);class kJ extends TJ{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new Iq("GRUCell does not support reset_after parameter set to true.");this.units=t.units,Yq(this.units,"units"),this.activation=iZ(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=iZ(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=hK(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=hK(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=hK(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=uZ(t.kernelRegularizer),this.recurrentRegularizer=uZ(t.recurrentRegularizer),this.biasRegularizer=uZ(t.biasRegularizer),this.kernelConstraint=lX(t.kernelConstraint),this.recurrentConstraint=lX(t.recurrentConstraint),this.biasConstraint=lX(t.biasConstraint),this.dropout=CX([1,TX([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=CX([1,TX([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=bK(t),this.kernel=this.addWeight("kernel",[t[t.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return oB(()=>{if(2!==(t=t).length)throw new Iq(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const n=null!=e.training&&e.training;let r=t[1];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=DJ(()=>IV(t),this.dropout,n,3)),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=DJ(()=>IV(r),this.recurrentDropout,n,3));const i=this.recurrentDropoutMask;let s,o,a;0<this.dropout&&this.dropout<1&&(t=yB(t,this.dropoutMask[0]));let l=PX(t,this.kernel.read());this.useBias&&(l=VX(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=yB(r,i[0]));const c=this.recurrentKernel.read(),[u,h]=lU(c,[2*this.units,this.units],c.rank-1),d=PX(r,u),[p,f,m]=lU(l,3,l.rank-1),[g,y]=lU(d,2,d.rank-1);s=this.recurrentActivation.apply(x$(p,g)),o=this.recurrentActivation.apply(x$(f,y));const v=PX(yB(o,r),h);a=this.activation.apply(x$(m,v));const b=x$(yB(s,r),yB(x$(1,iV(s)),a));return[b,b]})}getConfig(){const t={units:this.units,activation:nZ(this.activation),recurrentActivation:nZ(this.recurrentActivation),useBias:this.useBias,kernelInitializer:uK(this.kernelInitializer),recurrentInitializer:uK(this.recurrentInitializer),biasInitializer:uK(this.biasInitializer),kernelRegularizer:lZ(this.kernelRegularizer),recurrentRegularizer:lZ(this.recurrentRegularizer),biasRegularizer:lZ(this.biasRegularizer),activityRegularizer:lZ(this.activityRegularizer),kernelConstraint:oX(this.kernelConstraint),recurrentConstraint:oX(this.recurrentConstraint),biasConstraint:oX(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1},e=super.getConfig();return Object.assign(t,e),t}}kJ.className="GRUCell",d.registerClass(kJ);class RJ extends CJ{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new kJ(t),super(t)}call(t,e){return oB(()=>(null!=this.cell.dropoutMask&&(aB(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(aB(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}get units(){return this.cell.units}get activation(){return this.cell.activation}get recurrentActivation(){return this.cell.recurrentActivation}get useBias(){return this.cell.useBias}get kernelInitializer(){return this.cell.kernelInitializer}get recurrentInitializer(){return this.cell.recurrentInitializer}get biasInitializer(){return this.cell.biasInitializer}get kernelRegularizer(){return this.cell.kernelRegularizer}get recurrentRegularizer(){return this.cell.recurrentRegularizer}get biasRegularizer(){return this.cell.biasRegularizer}get kernelConstraint(){return this.cell.kernelConstraint}get recurrentConstraint(){return this.cell.recurrentConstraint}get biasConstraint(){return this.cell.biasConstraint}get dropout(){return this.cell.dropout}get recurrentDropout(){return this.cell.recurrentDropout}get implementation(){return this.cell.implementation}getConfig(){const t={units:this.units,activation:nZ(this.activation),recurrentActivation:nZ(this.recurrentActivation),useBias:this.useBias,kernelInitializer:uK(this.kernelInitializer),recurrentInitializer:uK(this.recurrentInitializer),biasInitializer:uK(this.biasInitializer),kernelRegularizer:lZ(this.kernelRegularizer),recurrentRegularizer:lZ(this.recurrentRegularizer),biasRegularizer:lZ(this.biasRegularizer),activityRegularizer:lZ(this.activityRegularizer),kernelConstraint:oX(this.kernelConstraint),recurrentConstraint:oX(this.recurrentConstraint),biasConstraint:oX(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1},e=super.getConfig();return delete e.cell,Object.assign(t,e),t}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}RJ.className="GRU",d.registerClass(RJ);class IJ extends TJ{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Yq(this.units,"units"),this.activation=iZ(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=iZ(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=hK(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=hK(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=hK(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=uZ(t.kernelRegularizer),this.recurrentRegularizer=uZ(t.recurrentRegularizer),this.biasRegularizer=uZ(t.biasRegularizer),this.kernelConstraint=lX(t.kernelConstraint),this.recurrentConstraint=lX(t.recurrentConstraint),this.biasConstraint=lX(t.biasConstraint),this.dropout=CX([1,TX([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=CX([1,TX([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;let n;if(t=bK(t),this.kernel=this.addWeight("kernel",[t[t.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const t=this.biasInitializer,r=this.units;n=new((e=class extends GX{apply(e,n){const i=t.apply([r]),s=(new XX).apply([r]),o=t.apply([2*r]);return DX(DX(i,s),o)}}).className="CustomInit",e)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return oB(()=>{const n=null!=e.training&&e.training;if(3!==(t=t).length)throw new Iq(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let r=t[1];const i=t[2];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=DJ(()=>IV(t),this.dropout,n,4)),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=DJ(()=>IV(r),this.recurrentDropout,n,4));const s=this.recurrentDropoutMask;let o,a,l,c;0<this.dropout&&this.dropout<1&&(t=yB(t,this.dropoutMask[0]));let u=PX(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=yB(r,s[0])),u=x$(u,PX(r,this.recurrentKernel.read())),this.useBias&&(u=VX(u,this.bias.read()));const[h,d,p,f]=lU(u,4,u.rank-1);o=this.recurrentActivation.apply(h),a=this.recurrentActivation.apply(d),l=x$(yB(a,i),yB(o,this.activation.apply(p))),c=this.recurrentActivation.apply(f);const m=yB(c,this.activation.apply(l));return[m,m,l]})}getConfig(){const t={units:this.units,activation:nZ(this.activation),recurrentActivation:nZ(this.recurrentActivation),useBias:this.useBias,kernelInitializer:uK(this.kernelInitializer),recurrentInitializer:uK(this.recurrentInitializer),biasInitializer:uK(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:lZ(this.kernelRegularizer),recurrentRegularizer:lZ(this.recurrentRegularizer),biasRegularizer:lZ(this.biasRegularizer),activityRegularizer:lZ(this.activityRegularizer),kernelConstraint:oX(this.kernelConstraint),recurrentConstraint:oX(this.recurrentConstraint),biasConstraint:oX(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},e=super.getConfig();return Object.assign(t,e),t}}IJ.className="LSTMCell",d.registerClass(IJ);class NJ extends CJ{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new IJ(t),super(t)}call(t,e){return oB(()=>(null!=this.cell.dropoutMask&&(aB(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(aB(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}get units(){return this.cell.units}get activation(){return this.cell.activation}get recurrentActivation(){return this.cell.recurrentActivation}get useBias(){return this.cell.useBias}get kernelInitializer(){return this.cell.kernelInitializer}get recurrentInitializer(){return this.cell.recurrentInitializer}get biasInitializer(){return this.cell.biasInitializer}get unitForgetBias(){return this.cell.unitForgetBias}get kernelRegularizer(){return this.cell.kernelRegularizer}get recurrentRegularizer(){return this.cell.recurrentRegularizer}get biasRegularizer(){return this.cell.biasRegularizer}get kernelConstraint(){return this.cell.kernelConstraint}get recurrentConstraint(){return this.cell.recurrentConstraint}get biasConstraint(){return this.cell.biasConstraint}get dropout(){return this.cell.dropout}get recurrentDropout(){return this.cell.recurrentDropout}get implementation(){return this.cell.implementation}getConfig(){const t={units:this.units,activation:nZ(this.activation),recurrentActivation:nZ(this.recurrentActivation),useBias:this.useBias,kernelInitializer:uK(this.kernelInitializer),recurrentInitializer:uK(this.recurrentInitializer),biasInitializer:uK(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:lZ(this.kernelRegularizer),recurrentRegularizer:lZ(this.recurrentRegularizer),biasRegularizer:lZ(this.biasRegularizer),activityRegularizer:lZ(this.activityRegularizer),kernelConstraint:oX(this.kernelConstraint),recurrentConstraint:oX(this.recurrentConstraint),biasConstraint:oX(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},e=super.getConfig();return delete e.cell,Object.assign(t,e),t}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}NJ.className="LSTM",d.registerClass(NJ);class OJ extends TJ{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return oB(()=>{let n=(t=t).slice(1);const r=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?r.push(n.splice(0,t.stateSize.length)):r.push(n.splice(0,1));r.reverse();const i=[];let s;for(let o=0;o<this.cells.length;++o){const a=this.cells[o];n=r[o],s=0===o?[t[0]].concat(n):[s[0]].concat(n),s=a.call(s,e),i.push(s.slice(1))}n=[];for(const t of i.slice().reverse())n.push(...t);return[s[0]].concat(n)})}build(t){let e;gK(t)&&(t=t[0]),t=t,this.cells.forEach((n,r)=>{vX(`RNNCell_${r}`,()=>{n.build(t),e=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){const t=[];for(const r of this.cells)t.push({className:r.getClassName(),config:r.getConfig()});const e={cells:t},n=super.getConfig();return Object.assign(e,n),e}static fromConfig(t,e,n={}){const r=[];for(const i of e.cells)r.push(HK(i,n));return new t({cells:r})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return wK(t)}setWeights(t){const e=[];for(const n of this.cells){const r=t.splice(n.weights.length);for(let t=0;t<n.weights.length;++t)e.push([n.weights[t],r[t]])}SK(e)}}function DJ(t,e,n=null,r=1){function i(){return UX(t(),e)}if(r>1){const e=[];for(let s=0;s<r;s++)e.push(HX(i,t,n));return e.map(t=>lB(t.clone()))}return lB(HX(i,t,n).clone())}OJ.className="StackedRNNCells",d.registerClass(OJ);class LJ extends kK{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,n={}){const r=HK(e.layer,n);delete e.layer;const i={layer:r};return Object.assign(i,e),new t(i)}}class FJ extends LJ{constructor(t){super(t),this.supportsMasking=!0}build(t){if((t=bK(t)).length<3)throw new Iq(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){const e=[(t=bK(t))[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e);return[n[0],t[1]].concat(n.slice(1))}call(t,e){return oB(()=>EJ((t,n)=>[vK(this.layer.call(t,e)),[]],t=vK(t),[],!1,null,null,!1,!0)[1])}}FJ.className="TimeDistributed",d.registerClass(FJ);class PJ extends LJ{constructor(t){super(t);const e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=HK(n),e.goBackwards=!0!==e.goBackwards;const r={};if(r.className=t.layer.getClassName(),r.config=e,this.backwardLayer=HK(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===t.mergeMode?"concat":t.mergeMode,Xq(dX,"BidirectionalMergeMode",this.mergeMode),t.weights)throw new Nq("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=Math.floor(t.length/2);this.forwardLayer.setWeights(t.slice(0,e)),this.backwardLayer.setWeights(t.slice(e))}computeOutputShape(t){let e,n,r,i=this.forwardLayer.computeOutputShape(t);return Array.isArray(i)&&Array.isArray(i[0])||(i=[i]),i=i,this.returnState?(r=i.slice(1),e=i[0]):e=i[0],e=e,"concat"===this.mergeMode?(e[e.length-1]*=2,n=[e]):n=null==this.mergeMode?[e,e.slice()]:[e],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[e].concat(r).concat(r.slice()):Pq(n)}apply(t,e){let n=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const i=SJ(t,n,r,this.numConstants);if(t=i.inputs,n=i.initialState,r=i.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(null==n||0===n.length)&&null==r)return super.apply(t,e);const s=[],o=[];if(null!=n){const t=n.length;if(t%2>0)throw new Iq("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,s.push(...n);const r=n.map(t=>new EK({shape:t.shape}));this.forwardLayer.stateSpec=r.slice(0,t/2),this.backwardLayer.stateSpec=r.slice(t/2),o.push(...r)}if(null!=r)throw new Nq("Support for constants in Bidirectional layers is not implemented yet.");const a=s[0]instanceof CK;for(const l of s)if(l instanceof CK!==a)throw new Iq("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(a){const n=[t].concat(s),r=this.inputSpec.concat(o),i=this.inputSpec;this.inputSpec=r;const a=super.apply(n,e);return this.inputSpec=i,a}return super.apply(t,e)}call(t,e){return oB(()=>{const n=e.initialState;let r,i,s,o;if(null==n)r=this.forwardLayer.call(t,e),i=this.backwardLayer.call(t,e);else{const s=n.slice(0,n.length/2),o=n.slice(n.length/2);r=this.forwardLayer.call(t,Object.assign(e,{initialState:s})),i=this.backwardLayer.call(t,Object.assign(e,{initialState:o}))}return this.returnState&&(Array.isArray(r)&&(s=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),this.returnSequences&&(i=Hz(i,1)),"concat"===this.mergeMode?o=OX([r,i]):"sum"===this.mergeMode?o=x$(r,i):"ave"===this.mergeMode?o=yB(.5,x$(r,i)):"mul"===this.mergeMode?o=yB(r,i):null==this.mergeMode&&(o=[r,i]),this.returnState?null==this.mergeMode?o.concat(s):[o].concat(s):o})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){vX(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),vX(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){let n;if(Array.isArray(e)&&(e=e[0]),n=this.returnSequences?null==this.mergeMode?[e,e]:e:null==this.mergeMode?[null,null]:null,this.returnState){const t=this.forwardLayer.states.map(t=>null);return Array.isArray(n)?n.concat(t).concat(t):[n].concat(t).concat(t)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const n=HK(e.layer);if(delete e.layer,null!=e.numConstants)throw new Nq("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=e;return r.layer=n,new t(r)}}var $J,BJ;PJ.className="Bidirectional",d.registerClass(PJ),function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}($J||($J={})),function(t){let e;!function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(e=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))}(BJ||(BJ={}));const zJ=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],VJ=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"clip_value_min",name:"clipValueMin",type:"number"},{tfName:"clip_value_max",name:"clipValueMax",type:"number"}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"clipValueMin",name:"clipValueMin",type:"number",defaultValue:0},{tfName:"clipValueMax",name:"clipValueMax",type:"number",defaultValue:6}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],UJ=[{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],HJ=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],WJ=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],jJ=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],GJ=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]}],qJ=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],XJ=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],KJ=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],YJ=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ZJ=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],JJ=[{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],QJ=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool",notSupported:!0}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],tQ=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],eQ=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}];function nQ(t,e,n=new Map,r=new Set){if(null==t)return null;if(r.has(t))throw new Error("Circular references are not supported.");if(n.has(t))return n.get(t);const i=e(t);if(i.recurse&&null!==i.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(i.recurse){if(oQ(t)){const i=Array.isArray(t)?[]:{};r.add(t);for(const s in t){const o=nQ(t[s],e,n,r);i[s]=o}return r.delete(t),i}throw new Error(`Can't recurse into non-iterable type: ${t}`)}return n.set(t,i.value),i.value}function rQ(t,e=sQ){return iQ(t,e)}function iQ(t,e,n=new Set){const r=t[0];if(n.has(r))throw new Error("Circular references are not supported.");const i=e(t);if(i.recurse&&null!==i.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(i.recurse){if(oQ(r)){const i=Array.isArray(r)?[]:{};n.add(r);for(const s in r){const r=iQ(t.map(t=>t[s]),e,n);i[s]=r}return n.delete(r),i}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return i.value}function sQ(t){return null===t?null:oQ(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}function oQ(t){return null!=t&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||"object"==typeof t&&!(t instanceof HP))}function aQ(t){return nQ(t,lQ)}function lQ(t){return t instanceof HP?{value:t.clone(),recurse:!1}:oQ(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}class cQ{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}}class uQ extends cQ{constructor(){super(uQ.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){const t=2*this.capacity,e=new Array(t),n=this.length();for(let r=0;r<n;r++)e[r]=this.get(this.wrap(this.begin+r));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}uQ.INITIAL_CAPACITY=32;class hQ{async toArray(){const t=[];let e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){const t=this.prefetch(100),e=[];let n=await t.next();for(;!n.done;)e.push(n.value),n=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),n=t(e.value);for(;!e.done&&n;)e=await this.next(),n=t(e.value)}handleErrors(t){return new _Q(this,t)}filter(t){return new vQ(this,t)}map(t){return new bQ(this,t)}mapAsync(t){return new xQ(this,t)}serialMapAsync(t){return new xQ(this,t).serial()}flatmap(t){return new SQ(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile(t=>!0===t)}rowMajorBatch(t,e=!0){return new yQ(this,t,e)}columnMajorBatch(t,e=!0,n=sQ){return this.rowMajorBatch(t,e).map(t=>rQ(t,n))}concatenate(t,e){return new EQ(new dQ([this,t]),e)}take(t){return t<0||null==t?this:new gQ(this,t)}skip(t){return t<0||null==t?this:new mQ(this,t)}prefetch(t){return new TQ(this,t)}shuffle(t,e){return new AQ(this,t,e)}serial(){return new fQ(this)}}class dQ extends hQ{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const t=this.items[this.trav];return this.trav++,{value:aQ(t),done:!1}}}class pQ extends hQ{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}}}class fQ extends hQ{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class mQ extends hQ{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const t=await this.upstream.next();if(t.done)return t;aB(t.value)}return this.upstream.next()}}class gQ extends hQ{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class yQ extends hQ{constructor(t,e,n=!0){super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const t=[];for(;t.length<this.batchSize;){const e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}}class vQ extends hQ{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;aB(t.value)}}}class bQ extends hQ{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Map`}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=i.getTensorsInContainer(t.value),n=this.transform(t.value),r=i.getTensorsInContainer(n);for(const s of e)i.isTensorInList(s,r)||s.dispose();return{value:n,done:!1}}}class _Q extends hQ{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}}class xQ extends hQ{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=i.getTensorsInContainer(t.value),n=await this.transform(t.value),r=i.getTensorsInContainer(n);for(const s of e)i.isTensorInList(s,r)||s.dispose();return{value:n,done:!1}}}class wQ extends hQ{constructor(){super(),this.outputQueue=new uQ,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!(await this.pump()))return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class SQ extends wQ{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const t=await this.upstream.next();if(t.done)return!1;const e=i.getTensorsInContainer(t.value),n=this.transform(t.value),r=i.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(const s of e)i.isTensorInList(s,r)||s.dispose();return!0}}class EQ extends hQ{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,null==this.iterator){const t=await this.moreIterators.next();if(t.done)return{value:null,done:!0};this.iterator=t.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}}var CQ;!function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"}(CQ||(CQ={}));class TQ extends hQ{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new cQ(e)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class AQ extends TQ{constructor(t,e,n){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=jV.alea(n||r.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(!e.done)return this.refill(),e;this.upstreamExhausted=!0}return{value:null,done:!0}}}class MQ{constructor(){this.size=null}batch(t,e=!0){const n=this;let i;return r.assert(t>0,()=>`batchSize needs to be positive, but it is\n      ${t}`),i=this.size===1/0||null==this.size?this.size:e?Math.ceil(this.size/t):Math.floor(this.size/t),kQ(async()=>(await n.iterator()).columnMajorBatch(t,e,RQ),i)}concatenate(t){const e=this;let n;return n=this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null,kQ(async()=>(await e.iterator()).concatenate(await t.iterator()),n)}filter(t){const e=this;let n;return n=this.size===1/0?1/0:null,kQ(async()=>(await e.iterator()).filter(e=>oB(()=>t(e))),n)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){const e=this;return kQ(async()=>(await e.iterator()).map(e=>oB(()=>t(e))),this.size)}mapAsync(t){const e=this;return kQ(async()=>(await e.iterator()).mapAsync(t),this.size)}prefetch(t){if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const e=this;return kQ(async()=>(await e.iterator()).prefetch(t),this.size)}repeat(t){const e=this;let n;return n=null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null,kQ(async()=>{return n=(r=async()=>({value:await e.iterator(),done:!1}),new pQ(r)).take(t),new EQ(n,undefined);var n,r},n)}skip(t){const e=this;let n;return n=null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null,kQ(async()=>(await e.iterator()).skip(t),n)}shuffle(t,e,n=!0){if(null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const i=this,s=jV.alea(e||r.now().toString());return kQ(async()=>{let e=s.int32();return n&&(e+=s.int32()),(await i.iterator()).shuffle(t,e.toString())},this.size)}take(t){const e=this;let n;return n=null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null,kQ(async()=>(await e.iterator()).take(t),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function kQ(t,e=null){return new class extends MQ{constructor(){super(...arguments),this.size=e}async iterator(){return t()}}}function RQ(t){return null===t?null:null==(e=t[0])||null===(n=e)||"object"!=typeof n&&"function"!=typeof n||Array.isArray(e)||"object"==typeof e&&e instanceof HP||r.isTypedArray(e)?{value:function(t){if(0===t.length)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof HP?TU(t):fB(t)}(t),recurse:!1}:{value:null,recurse:!0};var e,n}function IQ(t,e){Array.isArray(t)||(t=[t]),t.forEach(t=>{null!=t&&r.assert("complex64"!==t.dtype,()=>`${e} does not support complex64 tensors in the CPU backend.`)})}function NQ(t,e,n,r,i,s){const o=i.strideHeight,a=i.strideWidth,l=i.dilationHeight,c=i.dilationWidth,u=i.effectiveFilterHeight,h=i.effectiveFilterWidth,d=i.padInfo.top,p=i.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=WB(i.outShape,n),g=m.values,y=i.outShape[1]*i.outShape[2]*i.outShape[3],v=i.outShape[2]*i.outShape[3],b=i.outShape[3];for(let _=0;_<i.batchSize;++_){const e=_*y,n=_*r[0];for(let m=0;m<i.inChannels;++m)for(let y=0;y<i.outHeight;++y){const _=y*o-d,x=Math.max(0,_),w=Math.min(i.inHeight,u+_),S=e+y*v;for(let e=0;e<i.outWidth;++e){const o=e*a-p,u=Math.max(0,o),d=Math.min(i.inWidth,h+o);let y=f,v=0,_=0;for(let e=x;e<w;e+=l){const i=n+e*r[1];for(let e=u;e<d;e+=c){const n=t[i+e*r[2]+m];"max"===s&&n>y?y=n:"avg"===s&&(v+=n,_++)}if(isNaN(y))break}g[S+e*b+m]="avg"===s?v/_:y}}}return m}function OQ(t,e,n,r,i=!1,s=!1){const o=WB(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,c=r.dilationHeight,u=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=WB(e,n,t);for(let g=0;g<r.batchSize;++g)for(let t=0;t<r.inChannels;++t)for(let e=0;e<r.outHeight;++e){const n=e*a-p;let y=n;for(;y<0;)y+=c;const v=Math.min(r.inHeight,h+n);for(let a=0;a<r.outWidth;++a){const h=a*l-f;let p=h;for(;p<0;)p+=u;const b=Math.min(r.inWidth,d+h);let _=Number.NEGATIVE_INFINITY,x=-1;for(let e=y;e<v;e+=c){const o=e-n;for(let n=p;n<b;n+=u){const a=n-h,l=m.get(g,e,n,t);l>_&&(_=l,x=i?s?((g*r.inHeight+e)*r.inWidth+n)*r.inChannels+t:(e*r.inWidth+n)*r.inChannels+t:o*d+a)}}o.set(x,g,e,a,t)}}return o}MQ.MAX_BUFFER_SIZE=1e4,Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const DQ=f.nonMaxSuppressionV3Impl,LQ=f.split,FQ=f.tile,PQ=f.topkImpl,$Q=f.whereImpl;function BQ(t,e,n,r){if("linear"===n)return t.linear(e);if("relu"===n)return t.relu(e);if("elu"===n)return t.elu(e);if("relu6"===n)return t.relu6(e);if("prelu"===n)return t.prelu(e,r);throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}class zQ extends gG{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new mG(this,iB())}write(t,e,n){this.firstUse&&(this.firstUse=!1,BD().get("IS_NODE")&&p.warn("\n============================\nHi there \ud83d\udc4b. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const r={};return this.data.set(r,{values:t,dtype:n}),r}move(t,e,n,r){this.data.set(t,{values:e,dtype:r})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensors:n}=this.data.get(t);if("complex64"===e){const t=this.readSync(n.real.dataId),e=this.readSync(n.imag.dataId);return p.mergeRealAndImagArrays(t,e)}return this.data.get(t).values}bufferSync(t){const e=this.readSync(t.dataId);let n=e;if("string"===t.dtype)try{n=e.map(t=>r.decodeString(t))}catch(V3){throw new Error("Failed to decode encoded string bytes into utf-8")}return WB(t.shape,t.dtype,n)}makeOutput(t,e,n){const r=this.write(t,e,n);return iB().makeTensorFromDataId(r,e,n,this)}disposeData(t){if(this.data.has(t)){const{complexTensors:e}=this.data.get(t);null!=e&&(e.real.dispose(),e.imag.dispose()),this.data.delete(t)}}async time(t){const e=r.now();return t(),{kernelMs:r.now()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}complex(t,e){const n=this.makeOutput(null,t.shape,"complex64");return this.data.get(n.dataId).complexTensors={real:iB().keep(t.clone()),imag:iB().keep(e.clone())},n}real(t){return this.data.get(t.dataId).complexTensors.real.clone()}imag(t){return this.data.get(t.dataId).complexTensors.imag.clone()}slice(t,e,n){if(IQ(t,"slice"),o.isSliceContinous(t.shape,e,n)){const i=o.computeFlatOffset(e,t.strides),s=r.sizeFromShape(n);return fB(this.readSync(t.dataId).subarray(i,i+s),n,t.dtype)}const i=WB(n,t.dtype),s=this.bufferSync(t);for(let r=0;r<i.size;++r){const t=i.indexToLoc(r).map((t,n)=>t+e[n]);i.values[r]=s.get(...t)}return i.toTensor()}stridedSlice(t,e,n,r){IQ(t,"stridedSlice");const i=o.computeOutShape(e,n,r);if(i.some(t=>0===t))return fB([],i);const s=WB(i,t.dtype),a=this.bufferSync(t);for(let o=0;o<s.size;o++){const t=s.indexToLoc(o),n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[i]*r[i]+e[i];s.set(a.get(...n),...t)}return s.toTensor()}diag(t){const e=this.readSync(t.dataId),n=WB([t.size,t.size],t.dtype),r=n.values;for(let i=0;i<e.length;i++)r[i*t.size+i]=e[i];return n.toTensor()}unstack(t,e){const n=t.shape[e],r=new Array(t.rank-1);let i=0;for(let l=0;l<t.rank;l++)l!==e&&(r[i++]=t.shape[l]);const s=new Array(t.rank).fill(0),o=t.shape.slice();o[e]=1;const a=new Array(n);for(let l=0;l<a.length;l++)s[e]=l,a[l]=this.slice(t,s,o).reshape(r);return a}reverse(t,e){IQ(t,"reverse");const n=WB(t.shape,t.dtype),r=this.bufferSync(t);for(let i=0;i<n.size;i++){const s=n.indexToLoc(i),o=s.slice();e.forEach(e=>o[e]=t.shape[e]-1-o[e]),n.set(r.get(...o),...s)}return n.toTensor()}concat(t,e){if("complex64"===t[0].dtype){const n=t.map(t=>Uz(t)),r=t.map(t=>Vz(t));return qB(this.concat(n,e),this.concat(r,e))}const n=t.map(t=>{const n=r.sizeFromShape(t.shape.slice(e));return t.as2D(-1,n)}),i=p.computeOutShape(n.map(t=>t.shape),1),s=WB(i,t[0].dtype).values;if(1===n[0].shape[0]){let t=0;n.forEach(e=>{s.set(this.readSync(e.dataId),t),t+=e.size})}else{let t=0;n.forEach(e=>{const n=this.readSync(e.dataId);let r=0;for(let o=0;o<e.shape[0];++o){const a=o*i[1]+t;for(let t=0;t<e.shape[1];++t)s[a+t]=n[r++]}t+=e.shape[1]})}const o=p.computeOutShape(t.map(t=>t.shape),e);return fB(s,o,t[0].dtype)}neg(t){return IQ(t,"neg"),this.multiply(Wz(-1),t)}add(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),(t,e,n,r)=>({real:t+n,imag:e+r})):this.broadcastedBinaryOp(t,e,ZP(t.dtype,e.dtype),(t,e)=>t+e)}addN(t){IQ(t,"addN");const e=t.map(t=>this.readSync(t.dataId)),n=WB(t[0].shape,t[0].dtype),r=n.values;for(let i=0;i<t.length;i++){const t=e[i];for(let e=0;e<r.length;e++)r[e]+=t[e]}return n.toTensor()}softmax(t,e){const n=r.parseAxisParam([e],t.shape),i=aV(t,n),s=p.expandShapeToKeepDim(i.shape,n),o=this.subtract(t,i.reshape(s)),a=this.exp(o),l=this.sum(a,n).reshape(s);return pz(a,l)}subtract(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),(t,e,n,r)=>({real:t-n,imag:e-r})):this.broadcastedBinaryOp(t,e,ZP(t.dtype,e.dtype),(t,e)=>t-e)}pow(t,e){return IQ([t,e],"pow"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.pow(t,e))}batchMatMul(t,e,n,r){IQ([t,e],"matMul");const i=n?t.shape[1]:t.shape[2],s=n?t.shape[2]:t.shape[1],o=r?e.shape[1]:e.shape[2],a=t.shape[0],l=this.readSync(t.dataId),c=this.readSync(e.dataId),[u,h,d]=n?[t.strides[0],1,t.strides[1]]:[t.strides[0],t.strides[1],1],[p,f,m]=r?[1,e.strides[1],e.strides[0]]:[e.strides[1],1,e.strides[0]],g=s*o,y=WB([a,s,o],t.dtype),v=y.values,b=this.blockSize;for(let _=0;_<a;_++)for(let t=0;t<s;t+=b)for(let e=0;e<o;e+=b)for(let n=0;n<i;n+=b){const r=Math.min(t+b,s),a=Math.min(e+b,o),y=Math.min(n+b,i);for(let i=t;i<r;i++)for(let t=e;t<a;t++){let e=0;for(let r=n;r<y;r++)e+=l[_*u+i*h+r*d]*c[r*p+t*f+_*m];v[_*g+(i*o+t)]+=e}}return y.toTensor()}fusedBatchMatMul({a:t,b:e,transposeA:n,transposeB:r,bias:i,activation:s,preluActivationWeights:o}){let a=this.batchMatMul(t,e,n,r);return i&&(a=this.add(a,i)),s&&(a=BQ(this,a,s,o)),a}multiply(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),(t,e,n,r)=>({real:t*n-e*r,imag:t*r+e*n})):this.broadcastedBinaryOp(t,e,ZP(t.dtype,e.dtype),(t,e)=>t*e)}floorDiv(t,e){return IQ([t,e],"floorDiv"),this.broadcastedBinaryOp(t,e,"int32",(t,e)=>Math.floor(t/e))}sum(t,e){IQ(t,"sum"),p.assertAxesAreInnerMostDims("sum",e,t.rank);const[n,i]=p.computeOutAndReduceShapes(t.shape,e),s=bV(n,ZP(t.dtype,"int32")),o=r.sizeFromShape(i),a=this.readSync(s.dataId),l=this.readSync(t.dataId);for(let r=0;r<a.length;++r){const t=r*o;let e=0;for(let n=0;n<o;++n)e+=l[t+n];a[r]=e}return s}prod(t,e){IQ(t,"sum");const[n,i]=p.computeOutAndReduceShapes(t.shape,e),s=bV(n,ZP(t.dtype,"int32")),o=r.sizeFromShape(i),a=this.readSync(s.dataId),l=this.readSync(t.dataId);for(let r=0;r<a.length;++r){const t=r*o;let e=1;for(let n=0;n<o;++n)e*=l[t+n];a[r]=e}return s}unsortedSegmentSum(t,e,n){IQ(t,"unsortedSegmentSum");const r=[],i=t.rank-e.rank;for(let s=0;s<i;++s)e=e.expandDims(s+1);for(let s=0;s<n;++s){const n=Wz(s,"int32"),i=yz(n,e).asType("float32").mul(t).sum(0);r.push(i)}return TU(r)}argMin(t,e){IQ(t,"argMin");const n=[e];p.assertAxesAreInnerMostDims("argMin",n,t.rank);const[i,s]=p.computeOutAndReduceShapes(t.shape,n),o=bV(i,"int32"),a=r.sizeFromShape(s),l=this.readSync(o.dataId),c=this.readSync(t.dataId);for(let r=0;r<l.length;++r){const t=r*a;let e=c[t],n=0;for(let r=0;r<a;++r){const i=c[t+r];i<e&&(e=i,n=r)}l[r]=n}return o}argMax(t,e){IQ(t,"argMax");const n=[e];p.assertAxesAreInnerMostDims("argMax",n,t.rank);const[i,s]=p.computeOutAndReduceShapes(t.shape,n),o=bV(i,"int32"),a=r.sizeFromShape(s),l=this.readSync(o.dataId),c=this.readSync(t.dataId);for(let r=0;r<l.length;++r){const t=r*a;let e=c[t],n=0;for(let r=0;r<a;++r){const i=c[t+r];i>e&&(e=i,n=r)}l[r]=n}return o}cumsum(t,e,n,r){if(IQ(t,"cumsum"),e!==t.rank-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${t.rank-1} but got axis=${e}`);const i=ZP(t.dtype,"int32"),s=bV(t.shape,i),o=this.readSync(s.dataId),a=this.readSync(t.dataId),l=t.shape[t.rank-1],c=r?(t,e)=>t+l-e-1:(t,e)=>t+e;for(let u=0;u<a.length;u+=l)for(let t=0;t<l;t++){const e=c(u,t);if(0===t)o[e]=n?0:a[e];else{const r=c(u,t-1);o[e]=n?a[r]+o[r]:a[e]+o[r]}}return s}equal(t,e){return IQ([t,e],"equal"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t===e?1:0)}notEqual(t,e){return IQ([t,e],"notEqual"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t!==e?1:0)}less(t,e){return IQ([t,e],"less"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t<e?1:0)}lessEqual(t,e){return IQ([t,e],"lessEqual"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t<=e?1:0)}greater(t,e){return IQ([t,e],"greater"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t>e?1:0)}greaterEqual(t,e){return IQ([t,e],"greaterEqual"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t>=e?1:0)}logicalNot(t){IQ(t,"logicalNot");const e=this.readSync(t.dataId),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n[r]=e[r]?0:1;return this.makeOutput(n,t.shape,"bool")}logicalAnd(t,e){return IQ([t,e],"logicalAnd"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t&&e)}logicalOr(t,e){return IQ([t,e],"logicalOr"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t||e)}select(t,e,n){IQ([t,e,n],"select");const i=this.readSync(t.dataId),s=this.readSync(e.dataId),o=this.readSync(n.dataId),a=bV(e.shape,ZP(e.dtype,n.dtype)),l=this.readSync(a.dataId);let c=0;const u=0===t.rank||t.rank>1||1===e.rank?1:r.sizeFromShape(e.shape.slice(1));for(let r=0;r<i.length;r++)for(let t=0;t<u;t++)l[c++]=1===i[r]?s[r]:o[r];return a}where(t){IQ([t],"where");const e=this.readSync(t.dataId);return $Q(t.shape,e)}topk(t,e,n){IQ(t,"topk");const r=this.readSync(t.dataId);return PQ(r,t.shape,t.dtype,e,n)}min(t,e){IQ(t,"min"),p.assertAxesAreInnerMostDims("min",e,t.rank);const[n,i]=p.computeOutAndReduceShapes(t.shape,e),s=bV(n,t.dtype),o=r.sizeFromShape(i),a=this.readSync(s.dataId),l=this.readSync(t.dataId);for(let r=0;r<a.length;++r){const t=r*o;let e=l[t];for(let n=0;n<o;++n){const r=l[t+n];r<e&&(e=r)}a[r]=e}return s}minimum(t,e){return IQ([t,e],"minimum"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.min(t,e))}mod(t,e){return IQ([t,e],"mod"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>{const n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e})}maximum(t,e){return IQ([t,e],"maximum"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.max(t,e))}all(t,e){IQ(t,"all"),p.assertAxesAreInnerMostDims("all",e,t.rank);const[n,i]=p.computeOutAndReduceShapes(t.shape,e),s=bV(n,t.dtype),o=r.sizeFromShape(i),a=this.readSync(s.dataId),l=this.readSync(t.dataId);for(let r=0;r<a.length;++r){const t=r*o;let e=l[t];for(let n=0;n<o;++n){const r=l[t+n];e=e&&r}a[r]=e}return s}any(t,e){IQ(t,"any"),p.assertAxesAreInnerMostDims("any",e,t.rank);const[n,i]=p.computeOutAndReduceShapes(t.shape,e),s=bV(n,t.dtype),o=r.sizeFromShape(i),a=this.readSync(s.dataId),l=this.readSync(t.dataId);for(let r=0;r<a.length;++r){const t=r*o;let e=l[t];for(let n=0;n<o;++n){const r=l[t+n];e=e||r}a[r]=e}return s}squaredDifference(t,e){return IQ([t,e],"squaredDifference"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>{const n=t-e;return n*n})}ceil(t){IQ(t,"ceil");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=Math.ceil(e[r]);return this.makeOutput(n,t.shape,"float32")}floor(t){IQ(t,"floor");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=Math.floor(e[r]);return this.makeOutput(n,t.shape,"float32")}sign(t){IQ(t,"x");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=e[r]<0?-1:e[r]>0?1:0;return this.makeOutput(n,t.shape,"float32")}isNaN(t){IQ(t,"x");const e=this.readSync(t.dataId),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)Number.isNaN(e[r])&&(n[r]=1);return this.makeOutput(n,t.shape,"bool")}isInf(t){IQ(t,"x");const e=this.readSync(t.dataId),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)Math.abs(e[r])===1/0&&(n[r]=1);return this.makeOutput(n,t.shape,"bool")}isFinite(t){IQ(t,"x");const e=this.readSync(t.dataId),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)Number.isFinite(e[r])&&(n[r]=1);return this.makeOutput(n,t.shape,"bool")}round(t){IQ(t,"round");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r){const t=Math.floor(e[r]);n[r]=e[r]-t<.5?Math.floor(e[r]):e[r]-t>.5?Math.ceil(e[r]):t%2==0?t:t+1}return this.makeOutput(n,t.shape,"float32")}exp(t){IQ(t,"exp");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=Math.exp(e[r]);return this.makeOutput(n,t.shape,"float32")}expm1(t){IQ(t,"expm1");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=Math.expm1(e[r]);return this.makeOutput(n,t.shape,"float32")}log(t){IQ(t,"log");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=Math.log(e[r]);return this.makeOutput(n,t.shape,"float32")}log1p(t){IQ(t,"log1p");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=Math.log1p(e[r]);return this.makeOutput(n,t.shape,"float32")}sqrt(t){IQ(t,"sqrt");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=Math.sqrt(e[r]);return this.makeOutput(n,t.shape,"float32")}rsqrt(t){IQ(t,"rsqrt");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=1/Math.sqrt(e[r]);return this.makeOutput(n,t.shape,"float32")}reciprocal(t){IQ(t,"reciprocal");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=1/e[r];return this.makeOutput(n,t.shape,"float32")}linear(t){return t}relu(t){IQ(t,"relu");const e=bV(t.shape,t.dtype),n=this.readSync(e.dataId),r=this.readSync(t.dataId);for(let i=0;i<r.length;++i)n[i]=Math.max(0,r[i]);return e}relu6(t){IQ(t,"relu");const e=bV(t.shape,t.dtype),n=this.readSync(e.dataId),r=this.readSync(t.dataId);for(let i=0;i<r.length;++i)n[i]=Math.min(Math.max(0,r[i]),6);return e}prelu(t,e){return IQ([t,e],"prelu"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>t<0?e*t:t)}elu(t){IQ(t,"elu");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r){const t=n[r];e[r]=t>=0?t:Math.exp(t)-1}return this.makeOutput(e,t.shape,"float32")}eluDer(t,e){IQ([t,e],"eluDer");const n=new Float32Array(e.size),r=this.readSync(e.dataId),i=this.readSync(t.dataId);for(let s=0;s<r.length;++s){const t=r[s];n[s]=t>=1?i[s]:i[s]*(t+1)}return this.makeOutput(n,e.shape,"float32")}selu(t){IQ(t,"selu");const e=p.SELU_SCALEALPHA,n=p.SELU_SCALE,r=new Float32Array(t.size),i=this.readSync(t.dataId);for(let s=0;s<i.length;++s){const t=i[s];r[s]=t>=0?n*t:e*(Math.exp(t)-1)}return this.makeOutput(r,t.shape,"float32")}clip(t,e,n){IQ(t,"clip");const r=new Float32Array(t.size),i=this.readSync(t.dataId);for(let s=0;s<i.length;++s){const t=i[s];r[s]=t>n?n:t<e?e:t}return this.makeOutput(r,t.shape,"float32")}abs(t){const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.abs(n[r]);return this.makeOutput(e,t.shape,"float32")}complexAbs(t){const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<t.size;++r)e[r]=Math.hypot(n[2*r],n[2*r+1]);return this.makeOutput(e,t.shape,"float32")}int(t){IQ(t,"int");const e=new Int32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=n[r];return this.makeOutput(e,t.shape,"int32")}sigmoid(t){IQ(t,"sigmoid");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=1/(1+Math.exp(-n[r]));return this.makeOutput(e,t.shape,"float32")}softplus(t){IQ(t,"softplus");const e=Math.log(1.1920928955078125e-7)+2,n=new Float32Array(t.size),r=this.readSync(t.dataId);for(let i=0;i<r.length;++i){const t=r[i]>-e,s=r[i]<e,o=Math.exp(r[i]);let a;a=s?o:t?r[i]:Math.log(1+o),n[i]=a}return this.makeOutput(n,t.shape,"float32")}sin(t){IQ(t,"sin");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.sin(n[r]);return this.makeOutput(e,t.shape,"float32")}cos(t){IQ(t,"cos");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.cos(n[r]);return this.makeOutput(e,t.shape,"float32")}tan(t){IQ(t,"tan");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.tan(n[r]);return this.makeOutput(e,t.shape,"float32")}asin(t){IQ(t,"asin");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.asin(n[r]);return this.makeOutput(e,t.shape,"float32")}acos(t){IQ(t,"acos");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.acos(n[r]);return this.makeOutput(e,t.shape,"float32")}atan(t){IQ(t,"atan");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.atan(n[r]);return this.makeOutput(e,t.shape,"float32")}atan2(t,e){return IQ([t,e],"atan2"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.atan2(t,e))}sinh(t){IQ(t,"sinh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.sinh(n[r]);return this.makeOutput(e,t.shape,"float32")}cosh(t){IQ(t,"cosh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.cosh(n[r]);return this.makeOutput(e,t.shape,"float32")}tanh(t){IQ(t,"tanh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let i=0;i<n.length;++i)e[i]=r.tanh(n[i]);return this.makeOutput(e,t.shape,"float32")}asinh(t){IQ(t,"asinh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.asinh(n[r]);return this.makeOutput(e,t.shape,"float32")}acosh(t){IQ(t,"acosh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.acosh(n[r]);return this.makeOutput(e,t.shape,"float32")}atanh(t){IQ(t,"atanh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.atanh(n[r]);return this.makeOutput(e,t.shape,"float32")}erf(t){IQ(t,"erf");const e=new Float32Array(t.size),n=this.readSync(t.dataId),r=p.ERF_P,i=p.ERF_A1,s=p.ERF_A2,o=p.ERF_A3,a=p.ERF_A4,l=p.ERF_A5;for(let c=0;c<n.length;++c){const t=Math.sign(n[c]),u=Math.abs(n[c]),h=1/(1+r*u);e[c]=t*(1-((((l*h+a)*h+o)*h+s)*h+i)*h*Math.exp(-u*u))}return this.makeOutput(e,t.shape,"float32")}step(t,e=0){IQ(t,"step");const n=new Float32Array(t.size),r=this.readSync(t.dataId);for(let i=0;i<r.length;++i){const t=r[i];n[i]=isNaN(t)?NaN:t>0?1:e}return this.makeOutput(n,t.shape,"float32")}fusedConv2d({input:t,filter:e,convInfo:n,bias:r,activation:i,preluActivationWeights:s}){let o=this.conv2d(t,e,n);return r&&(o=this.add(o,r)),i&&(o=BQ(this,o,i,s)),o}conv2d(t,e,n){IQ([t,e],"conv2d");const r=n.filterHeight,i=n.filterWidth,s=n.dilationHeight,o=n.dilationWidth,a=n.padInfo.left,l=n.padInfo.top,c="channelsLast"===n.dataFormat,u=WB(n.outShape,t.dtype),h=t.strides[0],d=c?t.strides[1]:t.strides[2],p=c?t.strides[2]:1,f=c?1:t.strides[1],m=u.strides[0],g=c?u.strides[1]:u.strides[2],y=c?u.strides[2]:1,v=c?1:u.strides[1],b=this.readSync(t.dataId),_=this.readSync(e.dataId),x=u.values;for(let w=0;w<n.batchSize;++w){const t=w*h,c=w*m;for(let u=0;u<n.outHeight;++u){const h=c+u*g,m=u*n.strideHeight-l;for(let l=0;l<r;l++){const r=m+l*s;if(r<0||r>=n.inHeight)continue;const c=l*e.strides[0],u=t+r*d;for(let t=0;t<n.outWidth;++t){const r=h+t*y,s=t*n.strideWidth-a;for(let t=0;t<i;t++){const i=s+t*o;if(i<0||i>=n.inWidth)continue;const a=u+i*p;let l=c+t*e.strides[1];for(let t=0;t<n.inChannels;++t){const e=b[a+t*f];for(let t=0;t<n.outChannels;++t)x[r+t*v]+=e*_[l+t];l+=n.outChannels}}}}}}return u.toTensor()}conv3d(t,e,n){const r=n.filterDepth,i=n.filterHeight,s=n.filterWidth,o=n.dilationDepth,a=n.dilationHeight,l=n.dilationWidth,c=n.padInfo.front,u=n.padInfo.left,h=n.padInfo.top,d=WB(n.outShape,t.dtype),p=this.readSync(t.dataId),f=this.readSync(e.dataId),m=d.values;for(let g=0;g<n.batchSize;++g){const y=g*t.strides[0],v=g*d.strides[0];for(let g=0;g<n.outDepth;++g){const b=v+g*d.strides[1],_=g*n.strideDepth-c;for(let c=0;c<r;c++){const r=_+c*o;if(r<0||r>=n.inDepth)continue;const g=c*e.strides[0],v=y+r*t.strides[1];for(let o=0;o<n.outHeight;++o){const r=b+o*d.strides[2],c=o*n.strideHeight-h;for(let o=0;o<i;o++){const i=c+o*a;if(i<0||i>=n.inHeight)continue;const h=g+o*e.strides[1],d=v+i*t.strides[2];for(let t=0;t<n.outWidth;++t){const i=r+t*n.outChannels,o=t*n.strideWidth-u;for(let t=0;t<s;t++){const r=o+t*l;if(r<0||r>=n.inWidth)continue;const s=d+r*n.inChannels;let a=h+t*e.strides[2];for(let t=0;t<n.inChannels;++t){const e=p[s+t];for(let t=0;t<n.outChannels;++t)m[i+t]+=e*f[a+t];a+=n.outChannels}}}}}}}}return d.toTensor()}conv2dDerInput(t,e,n){IQ([t,e],"conv2dDerInput");const r=WB(n.inShape,"float32"),i=r.values,s=this.readSync(t.dataId),o=this.readSync(e.dataId),[a,l,c]=e.strides,{batchSize:u,filterHeight:h,filterWidth:d,inChannels:p,inHeight:f,inWidth:m,outChannels:g,outHeight:y,outWidth:v,strideHeight:b,strideWidth:_,dataFormat:x}=n,w=h-1-n.padInfo.top,S=d-1-n.padInfo.left,E="channelsLast"===x,C=r.strides[0],T=E?r.strides[1]:r.strides[2],A=E?r.strides[2]:1,M=E?1:r.strides[1],k=t.strides[0],R=E?t.strides[1]:t.strides[2],I=E?t.strides[2]:1,N=E?1:t.strides[1];for(let O=0;O<u;++O)for(let t=0;t<p;++t)for(let e=0;e<f;++e){const n=e-w,r=Math.max(0,Math.ceil(n/b)),u=Math.min(y,(h+n)/b);for(let p=0;p<m;++p){const f=p-S,m=Math.max(0,Math.ceil(f/_)),y=Math.min(v,(d+f)/_);let x=0;for(let e=r;e<u;++e){const r=e*b-n;for(let n=m;n<y;++n){const i=k*O+R*e+I*n,u=a*(h-1-r)+l*(d-1-(n*_-f))+c*t;for(let t=0;t<g;++t)x+=s[i+N*t]*o[u+t]}}i[C*O+T*e+A*p+M*t]=x}}return r.toTensor()}conv3dDerInput(t,e,n){const r=WB(n.inShape,"float32"),i=r.values,[s,o,a,l]=r.strides,c=this.readSync(t.dataId),[u,h,d,p]=t.strides,f=this.readSync(e.dataId),[m,g,y,v]=e.strides,{batchSize:b,filterDepth:_,filterHeight:x,filterWidth:w,inChannels:S,inDepth:E,inHeight:C,inWidth:T,outChannels:A,outDepth:M,outHeight:k,outWidth:R,strideDepth:I,strideHeight:N,strideWidth:O}=n,D=_-1-n.padInfo.front,L=x-1-n.padInfo.top,F=w-1-n.padInfo.left;for(let P=0;P<b;++P)for(let t=0;t<S;++t)for(let e=0;e<E;++e){const n=e-D,r=Math.max(0,Math.ceil(n/I)),b=Math.min(M,(_+n)/I);for(let S=0;S<C;++S){const E=S-L,C=Math.max(0,Math.ceil(E/N)),M=Math.min(k,(x+E)/N);for(let k=0;k<T;++k){const T=k-F,D=Math.max(0,Math.ceil(T/O)),L=Math.min(R,(w+T)/O);let $=0;for(let e=r;e<b;++e){const r=e*I-n;for(let n=C;n<M;++n){const i=n*N-E;for(let s=D;s<L;++s){const o=u*P+h*e+d*n+p*s,a=m*(_-1-r)+g*(x-1-i)+y*(w-1-(s*O-T))+v*t;for(let t=0;t<A;++t)$+=c[o+t]*f[a+t]}}}i[s*P+o*e+a*S+l*k+t]=$}}}return r.toTensor()}conv2dDerFilter(t,e,n){IQ([t,e],"conv2dDerFilter");const r=n.strideHeight,i=n.strideWidth,s=n.filterHeight,o=n.filterWidth,a="channelsLast"===n.dataFormat,l=WB(n.filterShape,"float32"),c=n.padInfo.left,u=n.padInfo.top,h=this.bufferSync(t),d=this.bufferSync(e);for(let p=0;p<s;++p){const t=Math.max(0,Math.ceil((u-p)/r)),e=Math.min(n.outHeight,(n.inHeight+u-p)/r);for(let s=0;s<o;++s){const o=Math.max(0,Math.ceil((c-s)/i)),f=Math.min(n.outWidth,(n.inWidth+c-s)/i);for(let m=0;m<n.inChannels;++m)for(let g=0;g<n.outChannels;++g){let y=0;for(let l=0;l<n.batchSize;++l)for(let n=t;n<e;++n){const t=p+n*r-u;for(let e=o;e<f;++e){const r=s+e*i-c;y+=a?h.get(l,t,r,m)*d.get(l,n,e,g):h.get(l,m,t,r)*d.get(l,g,n,e)}}l.set(y,p,s,m,g)}}}return l.toTensor()}conv3dDerFilter(t,e,n){const r=n.strideDepth,i=n.strideHeight,s=n.strideWidth,o=n.filterDepth,a=n.filterHeight,l=n.filterWidth,c=WB(n.filterShape,"float32"),u=c.values,[h,d,p,f]=c.strides,m=this.readSync(e.dataId),[g,y,v,b]=e.strides,_=this.readSync(t.dataId),[x,w,S,E]=t.strides,C=n.padInfo.front,T=n.padInfo.left,A=n.padInfo.top;for(let M=0;M<o;++M){const t=Math.max(0,Math.ceil((C-M)/r)),e=Math.min(n.outDepth,(n.inDepth+C-M)/r),o=M*h;for(let c=0;c<a;++c){const a=Math.max(0,Math.ceil((A-c)/i)),h=Math.min(n.outHeight,(n.inHeight+A-c)/i),k=c*d+o;for(let o=0;o<l;++o){const l=Math.max(0,Math.ceil((T-o)/s)),d=Math.min(n.outWidth,(n.inWidth+T-o)/s),R=o*p+k;for(let p=0;p<n.inChannels;++p){const k=p*f+R;for(let f=0;f<n.outChannels;++f){let R=0;for(let u=0;u<n.batchSize;++u){const n=u*x,k=u*g;for(let u=t;u<e;++u){const t=(M+u*r-C)*w+n,e=u*y+k;for(let n=a;n<h;++n){const r=(c+n*i-A)*S+t,a=n*v+e;for(let t=l;t<d;++t)R+=_[(o+t*s-T)*E+r+p]*m[t*b+a+f]}}}u[k+f]=R}}}}}return c.toTensor()}fusedDepthwiseConv2D({input:t,filter:e,convInfo:n,bias:r,activation:i,preluActivationWeights:s}){let o=this.depthwiseConv2D(t,e,n);return r&&(o=this.add(o,r)),i&&(o=BQ(this,o,i,s)),o}depthwiseConv2D(t,e,n){IQ([t,e],"depthwiseConv2D");const r=n.filterHeight,i=n.filterWidth,s=n.dilationHeight,o=n.dilationWidth,a=n.padInfo.left,l=n.padInfo.top,c=n.outChannels/n.inChannels,u=WB(n.outShape,t.dtype),h=this.readSync(t.dataId),d=this.readSync(e.dataId),p=u.values;for(let f=0;f<n.batchSize;++f){const m=f*t.strides[0],g=f*u.strides[0];for(let f=0;f<n.outHeight;++f){const y=g+f*u.strides[1],v=f*n.strideHeight-a;for(let a=0;a<r;++a){const r=v+a*s;if(r<0||r>=n.inHeight)continue;const f=a*e.strides[0],g=m+r*t.strides[1];for(let t=0;t<n.outWidth;++t){const r=y+t*u.strides[2],s=t*n.strideWidth-l;for(let t=0;t<i;++t){const i=s+t*o;if(i<0||i>=n.inWidth)continue;const a=g+i*n.inChannels;let l=r,u=f+t*e.strides[1];for(let t=0;t<n.inChannels;++t){const e=h[a+t];for(let t=0;t<c;++t)p[l+t]+=e*d[u+t];l+=c,u+=c}}}}}}return u.toTensor()}depthwiseConv2DDerInput(t,e,n){IQ([t,e],"depthwiseConv2DDerInput");const r=WB(n.inShape,"float32"),i=r.values,[s,o,a]=r.strides,l=this.readSync(t.dataId),[c,u,h]=t.strides,d=this.readSync(e.dataId),[p,f,m]=e.strides,{batchSize:g,filterHeight:y,filterWidth:v,inChannels:b,inHeight:_,inWidth:x,outChannels:w,outHeight:S,outWidth:E,strideHeight:C,strideWidth:T}=n,A=y-1-n.padInfo.top,M=v-1-n.padInfo.left,k=w/b;for(let R=0;R<g;++R)for(let t=0;t<b;++t)for(let e=0;e<_;++e){const n=e-A,r=Math.max(0,Math.ceil(n/C)),g=Math.min(S,(y+n)/C);for(let b=0;b<x;++b){const _=b-M,x=Math.max(0,Math.ceil(_/T)),w=Math.min(E,(v+_)/T);let S=0;for(let e=r;e<g;++e){const r=e*C-n;for(let n=x;n<w;++n){const i=c*R+u*e+h*n,s=p*(y-1-r)+f*(v-1-(n*T-_))+m*t;for(let e=0;e<k;++e)S+=l[i+(t*k+e)]*d[s+e]}}i[s*R+o*e+a*b+t]=S}}return r.toTensor()}depthwiseConv2DDerFilter(t,e,n){IQ([t,e],"depthwiseConv2DDerFilter");const r=n.strideHeight,i=n.strideWidth,s=n.filterHeight,o=n.filterWidth,a=WB(n.filterShape,"float32"),l=n.padInfo.left,c=n.padInfo.top,u=n.outChannels/n.inChannels,h=this.bufferSync(t),d=this.bufferSync(e);for(let p=0;p<s;++p){const t=Math.max(0,Math.ceil((c-p)/r)),e=Math.min(n.outHeight,(n.inHeight+c-p)/r);for(let s=0;s<o;++s){const o=Math.max(0,Math.ceil((l-s)/i)),f=Math.min(n.outWidth,(n.inWidth+l-s)/i);for(let m=0;m<n.outChannels;++m){const g=Math.trunc(m/u),y=m%u;let v=0;for(let a=0;a<n.batchSize;++a)for(let n=t;n<e;++n){const t=p+n*r-c;for(let e=o;e<f;++e)v+=h.get(a,t,s+e*i-l,g)*d.get(a,n,e,m)}a.set(v,p,s,g,y)}}}return a.toTensor()}tile(t,e){return IQ(t,"tile"),FQ(this.bufferSync(t),e)}pad(t,e,n){IQ(t,"pad");const r=e.map((e,n)=>e[0]+t.shape[n]+e[1]),i=e.map(t=>t[0]),s=this.bufferSync(t),o=WB(r,t.dtype);0!==n&&o.values.fill(n);for(let a=0;a<t.size;a++){const t=s.indexToLoc(a),e=t.map((t,e)=>t+i[e]);o.set(s.get(...t),...e)}return o.toTensor()}gather(t,e,n){IQ([t,e],"gather");const r=t.shape.slice(),i=this.readSync(e.dataId);r[n]=i.length;const s=WB(r,t.dtype),o=this.bufferSync(t);for(let a=0;a<s.size;++a){const t=s.indexToLoc(a),e=t.slice();e[n]=i[t[n]];const r=o.locToIndex(e);s.values[a]=o.values[r]}return s.toTensor()}batchToSpaceND(t,e,n){IQ([t],"batchToSpaceND");const r=e.reduce((t,e)=>t*e),i=p.getReshaped(t.shape,e,r),s=p.getPermuted(i.length,e.length),o=p.getReshapedPermuted(t.shape,e,r),a=p.getSliceBeginCoords(n,e.length),l=p.getSliceSize(o,n,e.length);return N$(t.reshape(i),s).reshape(o).slice(a,l)}spaceToBatchND(t,e,n){IQ([t],"spaceToBatchND");const r=e.reduce((t,e)=>t*e),i=[[0,0]];i.push(...n);for(let u=1+e.length;u<t.shape.length;++u)i.push([0,0]);const s=t.pad(i),o=p.getReshaped(s.shape,e,r,!1),a=p.getPermuted(o.length,e.length,!1),l=p.getReshapedPermuted(s.shape,e,r,!1),c=N$(s.reshape(o),a);return I$(c,l)}maxPool(t,e){return IQ(t,"maxPool"),NQ(this.readSync(t.dataId),0,t.dtype,t.strides,e,"max").toTensor()}maxPoolBackprop(t,e,n,r){IQ([e,n],"maxPoolBackprop");const i=this.readSync(e.dataId),s=WB(r.outShape,e.dtype,OQ(i,e.shape,e.dtype,r).values),o=r.strideHeight,a=r.strideWidth,l=r.dilationHeight,c=r.dilationWidth,u=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=h-1-r.padInfo.left,p=u-1-r.padInfo.top,f=WB(e.shape,"float32"),m=this.bufferSync(t);for(let g=0;g<r.batchSize;++g)for(let t=0;t<r.inChannels;++t)for(let e=0;e<r.inHeight;++e)for(let n=0;n<r.inWidth;++n){const i=e-p,y=n-d;let v=0;for(let e=0;e<u;e+=l){const n=(i+e)/o;if(!(n<0||n>=r.outHeight||Math.floor(n)!==n))for(let i=0;i<h;i+=c){const o=(y+i)/a;if(o<0||o>=r.outWidth||Math.floor(o)!==o)continue;const l=u*h-1-s.get(g,n,o,t)===e*h+i?1:0;0!==l&&(v+=m.get(g,n,o,t)*l)}}f.set(v,g,e,n,t)}return f.toTensor()}avgPoolBackprop(t,e,n){IQ([t,e],"avgPoolBackprop");const r=n.strideHeight,i=n.strideWidth,s=n.filterHeight,o=n.filterWidth,a=n.dilationHeight,l=n.dilationWidth,c=n.effectiveFilterHeight,u=n.effectiveFilterWidth,h=u-1-n.padInfo.left,d=c-1-n.padInfo.top,p=WB(e.shape,"float32"),f=1/(s*o),m=this.bufferSync(t);for(let g=0;g<n.batchSize;++g)for(let t=0;t<n.inChannels;++t)for(let e=0;e<n.inHeight;++e)for(let s=0;s<n.inWidth;++s){const o=e-d,y=s-h;let v=0;for(let e=0;e<c;e+=a){const s=(o+e)/r;if(!(s<0||s>=n.outHeight||Math.floor(s)!==s))for(let e=0;e<u;e+=l){const r=(y+e)/i;r<0||r>=n.outWidth||Math.floor(r)!==r||(v+=m.get(g,s,r,t))}}p.set(v*f,g,e,s,t)}return p.toTensor()}pool3d(t,e,n){IQ(t,"pool3d");const r=e.strideDepth,i=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left,m="max"===n?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=this.readSync(t.dataId),y=WB(e.outShape,t.dtype),v=y.values,b=e.outShape[1]*e.outShape[2]*e.outShape[3]*e.outShape[4],_=e.outShape[2]*e.outShape[3]*e.outShape[4],x=e.outShape[3]*e.outShape[4],w=e.outShape[4];for(let S=0;S<e.batchSize;++S){const y=S*b,E=S*t.strides[0];for(let b=0;b<e.inChannels;++b)for(let S=0;S<e.outDepth;++S){const C=S*r-d;let T=C;for(;T<0;)T+=o;const A=Math.min(e.inDepth,c+C),M=y+S*_;for(let r=0;r<e.outHeight;++r){const c=r*i-p;let d=c;for(;d<0;)d+=a;const y=Math.min(e.inHeight,u+c),_=M+r*x;for(let r=0;r<e.outWidth;++r){const i=r*s-f;let c=i;for(;c<0;)c+=l;const u=Math.min(e.inWidth,h+i),p=_+r*w;let x=m,S=0,C=0;for(let e=T;e<A;e+=o){const r=E+e*t.strides[1];for(let e=d;e<y;e+=a){const i=r+e*t.strides[2];for(let e=c;e<u;e+=l){const r=g[i+e*t.strides[3]+b];if("max"===n&&r>x?x=r:"avg"===n&&(S+=r,C++),isNaN(x))break}if(isNaN(x))break}if(isNaN(x))break}v[p+b]="avg"===n?S/C:x}}}}return y.toTensor()}avgPool3d(t,e){return IQ(t,"avgPool3d"),this.pool3d(t,e,"avg").toFloat()}avgPool3dBackprop(t,e,n){IQ([t,e],"avgPool3dBackprop");const r=n.strideDepth,i=n.strideHeight,s=n.strideWidth,o=n.filterDepth,a=n.filterHeight,l=n.filterWidth,c=n.dilationDepth,u=n.dilationHeight,h=n.dilationWidth,d=n.effectiveFilterDepth,p=n.effectiveFilterHeight,f=n.effectiveFilterWidth,m=d-1-n.padInfo.front,g=f-1-n.padInfo.left,y=p-1-n.padInfo.top,v=WB(e.shape,"float32"),b=1/(o*a*l),_=this.bufferSync(t);for(let x=0;x<n.batchSize;++x)for(let t=0;t<n.inChannels;++t)for(let e=0;e<n.inDepth;++e)for(let o=0;o<n.inHeight;++o)for(let a=0;a<n.inWidth;++a){const l=e-m,w=o-y,S=a-g;let E=0;for(let e=0;e<d;e+=c){const o=(l+e)/r;if(!(o<0||o>=n.outDepth||Math.floor(o)!==o))for(let e=0;e<p;e+=u){const r=(w+e)/i;if(!(r<0||r>=n.outHeight||Math.floor(r)!==r))for(let e=0;e<f;e+=h){const i=(S+e)/s;i<0||i>=n.outWidth||Math.floor(i)!==i||(E+=_.get(x,o,r,i,t))}}}v.set(E*b,x,e,o,a,t)}return v.toTensor()}maxPool3d(t,e){return IQ(t,"maxPool3d"),this.pool3d(t,e,"max").toFloat()}maxPool3dPositions(t,e){const n=WB(e.outShape,"int32"),r=e.strideDepth,i=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left,m=this.bufferSync(t);for(let g=0;g<e.batchSize;++g)for(let t=0;t<e.inChannels;++t)for(let y=0;y<e.outDepth;++y){const v=y*r-d;let b=v;for(;b<0;)b+=o;const _=Math.min(e.inDepth,c+v);for(let r=0;r<e.outHeight;++r){const c=r*i-p;let d=c;for(;d<0;)d+=a;const x=Math.min(e.inHeight,u+c);for(let i=0;i<e.outWidth;++i){const p=i*s-f;let w=p;for(;w<0;)w+=l;const S=Math.min(e.inWidth,h+p);let E=Number.NEGATIVE_INFINITY,C=-1;for(let e=b;e<_;e+=o){const n=e-v;for(let r=d;r<x;r+=a){const i=r-c;for(let s=w;s<S;s+=l){const o=s-p,a=m.get(g,e,r,s,t);a>=E&&(E=a,C=n*u*h+i*u+o)}}}n.set(C,g,y,r,i,t)}}}return n.toTensor()}maxPool3dBackprop(t,e,n,r){IQ([e,n],"maxPool3dBackprop");const i=this.maxPool3dPositions(e,r),s=r.strideDepth,o=r.strideHeight,a=r.strideWidth,l=r.dilationDepth,c=r.dilationHeight,u=r.dilationWidth,h=r.effectiveFilterDepth,d=r.effectiveFilterHeight,p=r.effectiveFilterWidth,f=h-1-r.padInfo.front,m=p-1-r.padInfo.left,g=d-1-r.padInfo.top,y=WB(e.shape,"float32"),v=this.bufferSync(i),b=this.bufferSync(t);for(let _=0;_<r.batchSize;++_)for(let t=0;t<r.inChannels;++t)for(let e=0;e<r.inDepth;++e)for(let n=0;n<r.inHeight;++n)for(let i=0;i<r.inWidth;++i){const x=e-f,w=n-g,S=i-m;let E=0;for(let e=0;e<h;e+=l){const n=(x+e)/s;if(!(n<0||n>=r.outDepth||Math.floor(n)!==n))for(let i=0;i<d;i+=c){const s=(w+i)/o;if(!(s<0||s>=r.outHeight||Math.floor(s)!==s))for(let o=0;o<p;o+=u){const l=(S+o)/a;if(l<0||l>=r.outWidth||Math.floor(l)!==l)continue;const c=h*d*p-1-v.get(_,n,s,l,t)===e*d*p+i*p+o?1:0;0!==c&&(E+=b.get(_,n,s,l,t)*c)}}}y.set(E,_,e,n,i,t)}return y.toTensor()}cast(t,e){return p.castTensor(t,e,this)}reshape(t,e){return p.reshapeTensor(t,e)}avgPool(t,e){return IQ(t,"avgPool"),IQ(t,"maxPool"),NQ(this.readSync(t.dataId),0,t.dtype,t.strides,e,"avg").toTensor().toFloat()}resizeBilinear(t,e,n,i){IQ(t,"resizeBilinear");const[s,o,a,l]=t.shape,c=this.readSync(t.dataId),u=new Float32Array(r.sizeFromShape([s,e,n,l])),h=[i&&e>1?o-1:o,i&&n>1?a-1:a],d=[i&&e>1?e-1:e,i&&n>1?n-1:n];let p=0;const f=h[0]/d[0],m=h[1]/d[1];for(let r=0;r<s;r++)for(let i=0;i<e;i++){const e=f*i,s=Math.floor(e),h=e-s,d=Math.min(o-1,Math.ceil(e)),g=r*t.strides[0]+s*t.strides[1],y=r*t.strides[0]+d*t.strides[1];for(let r=0;r<n;r++){const e=m*r,n=Math.floor(e),i=e-n,s=Math.min(a-1,Math.ceil(e)),o=g+n*t.strides[2],d=y+n*t.strides[2],f=g+s*t.strides[2],v=y+s*t.strides[2];for(let t=0;t<l;t++){const e=c[o+t],n=c[d+t],r=e+(c[f+t]-e)*i;u[p++]=r+(n+(c[v+t]-n)*i-r)*h}}}return fB(u,[s,e,n,l])}resizeBilinearBackprop(t,e,n){IQ([t,e],"resizeBilinearBackprop");const[r,i,s,o]=e.shape,[,a,l]=t.shape,c=new Float32Array(r*i*s*o),u=[n&&a>1?i-1:i,n&&l>1?s-1:s],h=[n&&a>1?a-1:a,n&&l>1?l-1:l],d=u[0]/h[0],p=u[1]/h[1],f=this.readSync(t.dataId);let m=0;for(let g=0;g<r;g++){const t=g*e.strides[0];for(let n=0;n<a;n++){const r=n*d,a=Math.floor(r),u=Math.min(Math.ceil(r),i-1),h=t+a*e.strides[1],g=t+u*e.strides[1],y=r-a,v=1-y;for(let t=0;t<l;t++){const n=t*p,r=Math.floor(n),i=Math.min(Math.ceil(n),s-1),a=n-r,l=1-a,u=h+r*e.strides[2],d=h+i*e.strides[2],b=g+r*e.strides[2],_=g+i*e.strides[2],x=v*l,w=v*a,S=y*l,E=y*a;for(let t=0;t<o;t++){const e=f[m++];c[u+t]+=e*x,c[d+t]+=e*w,c[b+t]+=e*S,c[_+t]+=e*E}}}}return NU(c,[r,s,i,o],e.dtype)}resizeNearestNeighbor(t,e,n,r){IQ(t,"resizeNearestNeighbor");const[i,s,o,a]=t.shape,l=this.readSync(t.dataId),c=new Float32Array(i*e*n*a),u=[r&&e>1?s-1:s,r&&n>1?o-1:o],h=[r&&e>1?e-1:e,r&&n>1?n-1:n],d=u[0]/h[0],p=u[1]/h[1];let f=0;for(let m=0;m<i;m++){const i=m*t.strides[0];for(let u=0;u<e;u++){const e=d*u,h=i+Math.min(s-1,r?Math.round(e):Math.floor(e))*t.strides[1];for(let i=0;i<n;i++){const e=p*i,n=h+Math.min(o-1,r?Math.round(e):Math.floor(e))*t.strides[2];for(let t=0;t<a;t++)c[f++]=l[n+t]}}}return fB(c,[i,e,n,a],t.dtype)}resizeNearestNeighborBackprop(t,e,n){IQ([t,e],"resizeNearestNeighborBackprop");const[r,i,s,o]=e.shape,[,a,l]=t.shape,c=new Float32Array(r*i*s*o),u=this.readSync(t.dataId),h=[n&&a>1?i-1:i,n&&l>1?s-1:s],d=[n&&a>1?a-1:a,n&&l>1?l-1:l],p=h[0]/d[0],f=h[1]/d[1],m=1/p,g=1/f,y=2*Math.ceil(m)+2,v=2*Math.ceil(g)+2;for(let b=0;b<r;b++){const r=b*e.strides[0];for(let h=0;h<i;h++){const d=r+h*e.strides[1],b=Math.floor(h*m),_=Math.floor(b-y/2);for(let m=0;m<s;m++){const b=d+m*e.strides[2],x=Math.floor(m*g),w=Math.floor(x-v/2);for(let e=0;e<o;e++){let o=0;for(let c=0;c<y;c++){const d=c+_;if(d<0||d>=a)continue;const g=r+d*t.strides[1],y=d*p;if(h===Math.min(i-1,n?Math.round(y):Math.floor(y)))for(let r=0;r<v;r++){const i=r+w;if(i<0||i>=l)continue;const a=g+i*t.strides[2],c=i*f;m===Math.min(s-1,n?Math.round(c):Math.floor(c))&&(o+=u[a+e])}}c[b+e]=o}}}}return NU(c,e.shape,e.dtype)}batchNorm(t,e,n,r,i,s){IQ([t,e,n,i,r],"batchNorm");const o=this.readSync(t.dataId),a=this.readSync(e.dataId),l=this.readSync(n.dataId),c=i?this.readSync(i.dataId):new Float32Array([1]),u=r?this.readSync(r.dataId):new Float32Array([0]),h=new Float32Array(o.length),d=u.length,p=c.length,f=l.length,m=a.length;let g=0,y=0,v=0,b=0;for(let _=0;_<o.length;++_)h[_]=u[g++]+(o[_]-a[y++])*c[v++]/Math.sqrt(l[b++]+s),g>=d&&(g=0),y>=m&&(y=0),v>=p&&(v=0),b>=f&&(b=0);return NU(h,t.shape)}localResponseNormalization4D(t,e,n,r,i){IQ(t,"localResponseNormalization4D");const s=t.shape[3],o=s-1,a=this.readSync(t.dataId),l=t.size,c=new Float32Array(l);function u(t){const n=t%s;let r=t-n+Math.max(0,n-e);const i=t-n+Math.min(n+e,o);let l=0;for(;r<=i;r++){const t=a[r];l+=t*t}return l}for(let h=0;h<l;h++){const t=u(h),e=a[h]*Math.pow(n+r*t,-i);c[h]=e}return NU(c,t.shape)}LRNGrad(t,e,n,r,i,s,o){IQ(t,"LRNGrad");const a=t.shape[3],l=this.readSync(t.dataId),c=this.readSync(e.dataId),u=this.readSync(n.dataId),h=new Float32Array(t.size),d=t.size;for(let p=0;p<d;p++){const t=p%a,e=p-t+Math.max(0,t-r),n=p-t+Math.min(a,t+r+1);let d=0;for(let r=e;r<n;r++)d+=Math.pow(c[r],2);d=s*d+i;for(let r=e;r<n;r++){let t=-2*s*o*c[r]*u[p]/d;p===r&&(t+=Math.pow(d,-o)),t*=l[p],h[r]+=t}}return NU(h,t.shape)}multinomial(t,e,n,r){IQ(t,"multinomial");const i=e?t:wU(t),s=i.shape[0],o=i.shape[1],a=bV([s,n],"int32"),l=this.readSync(a.dataId),c=this.readSync(i.dataId);for(let u=0;u<s;++u){const t=u*o,e=new Float32Array(o-1);e[0]=c[t];for(let n=1;n<e.length;++n)e[n]=e[n-1]+c[t+n];const i=jV.alea(r.toString()),s=u*n;for(let r=0;r<n;++r){const t=i();l[s+r]=e.length;for(let n=0;n<e.length;n++)if(t<e[n]){l[s+r]=n;break}}}return a}oneHot(t,e,n,r){IQ(t,"oneHot");const i=new Float32Array(t.size*e);i.fill(r);const s=this.readSync(t.dataId);for(let o=0;o<t.size;++o)s[o]>=0&&s[o]<e&&(i[o*e+s[o]]=n);return RU(i,[t.size,e],"int32")}nonMaxSuppression(t,e,n,r,i){IQ(t,"nonMaxSuppression");const s=this.readSync(t.dataId),o=this.readSync(e.dataId);return DQ(s,o,n,r,i)}fft(t){return this.fftBatch(t,!1)}ifft(t){return this.fftBatch(t,!0)}fftBatch(t,e){const n=t.shape[0],r=t.shape[1],i=WB(t.shape,"float32"),s=WB(t.shape,"float32"),o=Uz(t).as2D(n,r),a=Vz(t).as2D(n,r);for(let l=0;l<n;l++){const t=o.slice([l,0],[1,r]),n=a.slice([l,0],[1,r]),c=qB(t,n),u=this.readSync(this.fftImpl(c,e).dataId);for(let e=0;e<r;e++){const t=p.getComplexWithIndex(u,e);i.values[l*r+e]=t.real,s.values[l*r+e]=t.imag}}return qB(i.toTensor(),s.toTensor()).as2D(n,r)}fftImpl(t,e){const n=t.as1D(),r=n.size;if(this.isExponentOf2(r)){let i=this.fftRadix2(n,r,e).as2D(t.shape[0],t.shape[1]);return e&&(i=qB(Uz(i).div(Wz(r)),Vz(i).div(Wz(r)))),i}{const n=this.readSync(t.dataId),i=this.fourierTransformByMatmul(n,r,e),s=p.splitRealAndImagArrays(i);return qB(s.real,s.imag).as2D(t.shape[0],t.shape[1])}}isExponentOf2(t){return 0==(t&t-1)}fftRadix2(t,e,n){if(1===e)return t;const r=this.readSync(t.dataId),i=e/2,s=p.complexWithEvenIndex(r);let o=qB(s.real,s.imag).as1D();const a=p.complexWithOddIndex(r);let l=qB(a.real,a.imag).as1D();o=this.fftRadix2(o,i,n),l=this.fftRadix2(l,i,n);const c=p.exponents(e,n),u=qB(c.real,c.imag).mul(l),h=o.add(u),d=o.sub(u),f=Uz(h).concat(Uz(d)),m=Vz(h).concat(Vz(d));return qB(f,m).as1D()}fourierTransformByMatmul(t,e,n){const r=new Float32Array(2*e);for(let i=0;i<e;i++){let s=0,o=0;for(let r=0;r<e;r++){const a=p.exponent(i*r,e,n),l=p.getComplexWithIndex(t,r);s+=l.real*a.real-l.imag*a.imag,o+=l.real*a.imag+l.imag*a.real}n&&(s/=e,o/=e),p.assignToTypedArray(r,s,o,i)}return r}depthToSpace(t,e,n){r.assert("NHWC"===n,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${n}`),r.assert(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`);const i=t.shape[0],s=t.shape[1],o=t.shape[2],a=t.shape[3],l=s*e,c=o*e,u=a/(e*e),h=this.readSync(t.dataId),d=new Float32Array(i*l*c*u);let p=0;for(let r=0;r<i;++r)for(let t=0;t<l;++t){const n=Math.floor(t/e),i=t%e;for(let t=0;t<c;++t){const l=Math.floor(t/e),c=(i*e+t%e)*u;for(let t=0;t<u;++t)d[p++]=h[t+c+a*(l+o*(n+s*r))]}}return NU(d,[i,l,c,u])}broadcastedBinaryOp(t,e,n,r){const i=p.assertAndGetBroadcastShape(t.shape,e.shape),s=WB(i,n),o=this.readSync(t.dataId),a=this.readSync(e.dataId),l=p.getBroadcastDims(t.shape,i),c=p.getBroadcastDims(e.shape,i),u=s.values;if(l.length+c.length===0)for(let h=0;h<u.length;++h)u[h]=r(o[h%o.length],a[h%a.length]);else{const n=this.bufferSync(t),i=this.bufferSync(e);for(let h=0;h<u.length;++h){const d=s.indexToLoc(h),p=d.slice(-t.rank);l.forEach(t=>p[t]=0);const f=n.locToIndex(p),m=d.slice(-e.rank);c.forEach(t=>m[t]=0);const g=i.locToIndex(m);u[h]=r(o[f],a[g])}}return s.toTensor()}broadcastedBinaryComplexOp(t,e,n){const r=p.assertAndGetBroadcastShape(t.shape,e.shape),i=WB(r,"float32"),s=WB(r,"float32"),o=this.readSync(t.dataId),a=this.readSync(e.dataId),l=p.getBroadcastDims(t.shape,r),c=p.getBroadcastDims(e.shape,r),u=i.values,h=s.values;if(l.length+c.length===0)for(let d=0;d<u.length;d++){const t=d%o.length,e=d%a.length,r=n(o[2*t],o[2*t+1],a[2*e],a[2*e+1]);u[d]=r.real,h[d]=r.imag}else{const r=this.bufferSync(this.data.get(t.dataId).complexTensors.real),s=this.bufferSync(this.data.get(e.dataId).complexTensors.real);for(let d=0;d<u.length;d++){const p=i.indexToLoc(d),f=p.slice(-t.rank);l.forEach(t=>f[t]=0);const m=r.locToIndex(f),g=p.slice(-e.rank);c.forEach(t=>g[t]=0);const y=s.locToIndex(g),v=n(o[2*m],o[2*m+1],a[2*y],a[2*y+1]);u[d]=v.real,h[d]=v.imag}}return this.complex(i.toTensor(),s.toTensor())}split(t,e,n){return LQ(t,e,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}cropAndResize(t,e,n,r,i,s){const[o,a,l,c]=t.shape,u=e.shape[0],[h,d]=r,p=WB([u,h,d,c],"float32"),f=this.readSync(e.dataId),m=this.readSync(n.dataId),g=this.readSync(t.dataId),y=t.strides,v=p.strides;for(let b=0;b<u;b++){const t=4*b,e=f[t],n=f[t+1],r=f[t+2],u=f[t+3],_=m[b];if(_>=o)continue;const x=h>1?(r-e)*(a-1)/(h-1):0,w=d>1?(u-n)*(l-1)/(d-1):0;for(let o=0;o<h;o++){const t=h>1?e*(a-1)+o*x:.5*(e+r)*(a-1);if(t<0||t>a-1)for(let e=0;e<d;e++)for(let t=0;t<c;t++)p.values[t+e*v[2]+o*v[1]+b*v[0]]=s;else if("bilinear"===i){const e=Math.floor(t),r=Math.ceil(t),i=t-e;for(let t=0;t<d;t++){const a=d>1?n*(l-1)+t*w:.5*(n+u)*(l-1);if(a<0||a>l-1){for(let e=0;e<c;e++)p.values[e+t*v[2]+o*v[1]+b*v[0]]=s;continue}const h=Math.floor(a),f=Math.ceil(a),m=a-h;for(let n=0;n<c;n++){let s=n+h*y[2]+e*y[1]+_*y[0];const a=g[s];s=n+f*y[2]+e*y[1]+_*y[0];const l=g[s];s=n+h*y[2]+r*y[1]+_*y[0];const c=g[s];s=n+f*y[2]+r*y[1]+_*y[0];const u=g[s],d=a+(l-a)*m;s=n+t*v[2]+o*v[1]+b*v[0],p.values[s]=d+(c+(u-c)*m-d)*i}}}else for(let e=0;e<d;++e){const r=d>1?n*(l-1)+e*w:.5*(n+u)*(l-1);if(r<0||r>l-1){for(let t=0;t<c;t++)p.values[t+e*v[2]+o*v[1]+b*v[0]]=s;continue}const i=Math.round(r),a=Math.round(t);for(let t=0;t<c;t++)p.values[t+e*v[2]+o*v[1]+b*v[0]]=g[t+i*y[2]+a*y[1]+_*y[0]]}}}return p.toTensor()}sparseToDense(t,e,n,r){const{sliceRank:i,numUpdates:s,sliceSize:o,strides:a,outputSize:l}=p.calculateShapes(e,t,n);return this.scatter(t,e,n,l,o,s,i,a,r,!1)}gatherND(t,e){const n=e.shape,r=n[n.length-1],[i,s,o,a]=p.prepareAndValidate(t,e);if(0===s)return fB([],i,t.dtype);const l=new BP([s,o],t.dtype),c=this.readSync(e.dataId),u=this.readSync(t.dataId);for(let h=0;h<s;h++){const e=[];let n=0;for(let t=0;t<r;t++){const i=c[h*r+t];n+=i*a[t],e.push(i)}if(n<0||n>=t.size/o)throw new Error(`Invalid indices: ${e} does not index into ${t.shape}`);for(let t=0;t<o;t++)l.values[h*o+t]=u[n*o+t]}return l.toTensor().reshape(i)}scatterND(t,e,n){const{sliceRank:r,numUpdates:i,sliceSize:s,strides:o,outputSize:a}=p.calculateShapes(e,t,n),l=Wz(0);return this.scatter(t,e,n,a,s,i,r,o,l,!0)}fill(t,e,n){n=n||r.inferDtype(e);const i=r.getArrayFromDType(n,r.sizeFromShape(t));return i.fill(e),iB().makeTensor(i,t,n,this)}onesLike(t){if("string"===t.dtype)throw new Error("onesLike is not supported for string tensors");return this.fill(t.shape,1,t.dtype)}zerosLike(t){const e=r.getArrayFromDType(t.dtype,r.sizeFromShape(t.shape));return this.makeOutput(e,t.shape,t.dtype)}linspace(t,e,n){return p.linspaceImpl(t,e,n)}scatter(t,e,n,r,i,s,o,a,l,c){const u=[r/i,i],h=this.readSync(t.dataId),d=this.readSync(e.dataId);if(0===r)return fB([],n,e.dtype);const p=new BP(u,e.dtype);p.values.fill(this.readSync(l.dataId)[0]);for(let f=0;f<s;f++){const t=[];let s=0;for(let e=0;e<o;e++){const n=h[f*o+e];t.push(n),s+=n*a[e]}if(s<0||s>=r/i)throw new Error(`Invalid indices: ${t} does not index into ${n}`);for(let n=0;n<i;n++)c?p.values[s*i+n]+=d[f*i+n]:p.values[s*i+n]=0===e.rank?d[0]:d[f*i+n]}return p.toTensor().reshape(n)}}cB("cpu",()=>new zQ,1);const VQ={kernelName:gL,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:i,filter:s}=t,{strides:o,pad:a,dilations:l}=n,c=e,u=r.toNestedArray(i.shape,c.data.get(i.dataId).values),h=r.toNestedArray(s.shape,c.data.get(s.dataId).values),{batchSize:d,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:v,padInfo:b,strideHeight:_,strideWidth:x,filterHeight:w,filterWidth:S,dilationHeight:E,dilationWidth:C,outShape:T}=p.computeDilation2DInfo(i.shape,s.shape,o,a,"NHWC",l),A=r.makeZerosNestedTypedArray(T,i.dtype);for(let r=0;r<d;++r)for(let t=0;t<y;++t){const e=t*_-b.top;for(let n=0;n<v;++n){const i=n*x-b.left;for(let s=0;s<g;++s){let o=Number.MIN_SAFE_INTEGER;for(let t=0;t<w;++t){const n=e+t*E;if(n>=0&&n<f)for(let e=0;e<S;++e){const a=i+e*C;if(a>=0&&a<m){const i=u[r][n][a][s]+h[t][e][s];i>o&&(o=i)}}}A[r][t][n][s]=o}}}return{dataId:c.write(r.toTypedArray(A,i.dtype),T,i.dtype),shape:T,dtype:i.dtype}}},UQ={kernelName:vL,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:i,filter:s,dy:o}=t,{strides:a,pad:l,dilations:c}=n,u=e,h=r.toNestedArray(i.shape,u.data.get(i.dataId).values),d=r.toNestedArray(s.shape,u.data.get(s.dataId).values),{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:v,outWidth:b,padInfo:_,strideHeight:x,strideWidth:w,filterHeight:S,filterWidth:E,dilationHeight:C,dilationWidth:T,outShape:A}=p.computeDilation2DInfo(i.shape,s.shape,a,l,"NHWC",c);r.assert(o.rank===A.length,()=>`Error in Dilation2DBackpropFilter, dy must have the same rank as output ${A.length}, but got ${o.rank}`);const M=r.toNestedArray(A,u.data.get(o.dataId).values),k=r.makeZerosNestedTypedArray(s.shape,s.dtype);for(let r=0;r<f;++r)for(let t=0;t<v;++t){const e=t*x-_.top;for(let n=0;n<b;++n){const i=n*w-_.left;for(let s=0;s<y;++s){let o=Number.MIN_SAFE_INTEGER,a=0,l=0;for(let t=0;t<S;++t){const n=e+t*C;if(n>=0&&n<m)for(let e=0;e<E;++e){const c=i+e*T;if(c>=0&&c<g){const i=h[r][n][c][s]+d[t][e][s];i>o&&(o=i,a=t,l=e)}}}k[a][l][s]+=M[r][t][n][s]}}}return{dataId:u.write(r.toTypedArray(k,i.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},HQ={kernelName:yL,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:i,filter:s,dy:o}=t,{strides:a,pad:l,dilations:c}=n,u=e,h=r.toNestedArray(i.shape,u.data.get(i.dataId).values),d=r.toNestedArray(s.shape,u.data.get(s.dataId).values),{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:v,outWidth:b,padInfo:_,strideHeight:x,strideWidth:w,filterHeight:S,filterWidth:E,dilationHeight:C,dilationWidth:T,outShape:A}=p.computeDilation2DInfo(i.shape,s.shape,a,l,"NHWC",c);r.assert(o.rank===A.length,()=>`Error in Dilation2DBackpropInput, dy must have the same rank as output ${A.length}, but got ${o.rank}`);const M=r.toNestedArray(A,u.data.get(o.dataId).values),k=r.makeZerosNestedTypedArray(i.shape,i.dtype);for(let r=0;r<f;++r)for(let t=0;t<v;++t){const e=t*x-_.top;for(let n=0;n<b;++n){const i=n*w-_.left;for(let s=0;s<y;++s){let o=Number.MIN_SAFE_INTEGER,a=e<0?0:e,l=i<0?0:i;for(let t=0;t<S;++t){const n=e+t*C;if(n>=0&&n<m)for(let e=0;e<E;++e){const c=i+e*T;if(c>=0&&c<g){const i=h[r][n][c][s]+d[t][e][s];i>o&&(o=i,a=n,l=c)}}}k[r][a][l][s]+=M[r][t][n][s]}}}return{dataId:u.write(r.toTypedArray(k,i.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};function WQ(t,e){return{kernelName:t,backendName:"cpu",kernelFunc:({inputs:n,backend:r})=>{const{a:i,b:s}=n,o=r;IQ([i,s],t);const a=o.data.get(i.dataId).values,l=o.data.get(s.dataId).values,[c,u]=e(i.shape,s.shape,a,l,i.dtype);return{dataId:o.write(c,u,i.dtype),shape:u,dtype:i.dtype}}}}function jQ(t){return(e,n,i,s,o)=>{const a=p.assertAndGetBroadcastShape(e,n),l=a.length,c=r.computeStrides(a),u=r.sizeFromShape(a),h=r.getTypedArrayFromDType(o,u),d=e.length,f=n.length,m=r.computeStrides(e),g=r.computeStrides(n),y=p.getBroadcastDims(e,a),v=p.getBroadcastDims(n,a);if(y.length+v.length===0)for(let r=0;r<h.length;++r)h[r]=t(i[r%i.length],s[r%s.length]);else for(let p=0;p<h.length;++p){const e=r.indexToLoc(p,l,c),n=e.slice(-d);y.forEach(t=>n[t]=0);const o=r.locToIndex(n,d,m),a=e.slice(-f);v.forEach(t=>a[t]=0);const u=r.locToIndex(a,f,g);h[p]=t(i[o],s[u])}return[h,a]}}const GQ=jQ((t,e)=>t/e),qQ=WQ(bL,GQ),XQ={kernelName:xL,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,i=e,s=r.getTypedArrayFromDType(n.dtype,r.sizeFromShape(n.shape)),[o,a,l,c]=n.shape,u=i.data.get(n.dataId).values;for(let r=0;r<o;r++){const t=r*l*a*c;for(let e=0;e<a;e++){const n=e*(l*c);for(let r=0;r<l;r++){const i=r*c;for(let a=0;a<c;a++){const h=Math.round(l-[o,e,r,a][2]),d=t+n+i+a;let p=u[d];h>=0&&h<l&&(p=u[t+n+h*c+a]),s[d]=p}}}}return{dataId:i.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};function KQ(t,e,n,i){const s=r.getTypedArrayFromDType(i,r.sizeFromShape(n));for(let r=0;r<s.length;++r){const n=r*e;let i=t[n];for(let r=0;r<e;++r){const e=t[n+r];e>i&&(i=e)}s[r]=i}return s}function YQ(t,e,n,i,s){const o=e.length,a=r.sizeFromShape(e),l=r.computeStrides(e),c=r.computeStrides(s),u=r.getTypedArrayFromDType(n,r.sizeFromShape(s));for(let h=0;h<a;++h){const e=r.indexToLoc(h,o,l),n=new Array(e.length);for(let t=0;t<n.length;t++)n[t]=e[i[t]];u[r.locToIndex(n,o,c)]=t[h]}return u}const ZQ={kernelName:OL,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:i}=t,{reductionIndices:s,keepDims:o}=e,a=n;let l=i.shape;const c=l.length,u=r.parseAxisParam(s,l);let h=u;const d=p.getAxesPermutation(h,c);let f=a.data.get(i.dataId).values;if(null!=d){const t=new Array(c);for(let e=0;e<t.length;e++)t[e]=l[d[e]];f=YQ(f,l,i.dtype,d,t),h=p.getInnerMostAxes(h.length,c),l=t}IQ(i,"max"),p.assertAxesAreInnerMostDims("max",h,c);const[m,g]=p.computeOutAndReduceShapes(l,h),y=KQ(f,r.sizeFromShape(g),m,i.dtype),v=a.write(y,m,i.dtype);let b=m;return o&&(b=p.expandShapeToKeepDim(m,u)),{dataId:v,shape:b,dtype:i.dtype}}},JQ={kernelName:PL,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:i}=t,{filterSize:s,strides:o,pad:a,includeBatchInIndex:l}=e,c=n;IQ(i,"MaxPoolWithArgmax");const u=c.data.get(i.dataId).values,h=p.computePool2DInfo(i.shape,s,o,[1,1],a),[d,f]=function(t,e,n,i,s){const o=NQ(t,0,n,r.computeStrides(e),s,"max"),a=OQ(t,e,n,s,!0,i);return[o.values,a.values]}(u,i.shape,i.dtype,l,h),m=c.write(d,h.outShape,i.dtype),g=c.write(f,h.outShape,i.dtype);return[{dataId:m,shape:h.outShape,dtype:i.dtype},{dataId:g,shape:h.outShape,dtype:"int32"}]}},QQ=f.nonMaxSuppressionV4Impl,t0={kernelName:UL,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{boxes:r,scores:i}=t,{maxOutputSize:s,iouThreshold:o,scoreThreshold:a,padToMaxOutputSize:l}=n,c=e;IQ(r,"NonMaxSuppressionPadded");const u=c.data.get(r.dataId).values,h=c.data.get(i.dataId).values,{selectedIndices:d,validOutputs:p}=QQ(u,h,s,o,a,l);return[d,p]}},e0=f.nonMaxSuppressionV5Impl,n0={kernelName:HL,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{boxes:r,scores:i}=t,{maxOutputSize:s,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}=n,c=e;IQ(r,"NonMaxSuppressionWithScore");const u=c.data.get(r.dataId).values,h=c.data.get(i.dataId).values,d=s,p=o,f=a,m=l,{selectedIndices:g,selectedScores:y}=e0(u,h,d,p,f,m);return[g,y]}},r0={kernelName:EF,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:i}=t,{radians:s,fillValue:o,center:a}=e,l=n,c=r.getTypedArrayFromDType(i.dtype,r.sizeFromShape(i.shape)),[u,h,d,f]=i.shape,[m,g]=p.getImageCenter(a,h,d),y=Math.sin(s),v=Math.cos(s),b=l.data.get(i.dataId).values;for(let r=0;r<u;r++){const t=r*d*h*f;for(let e=0;e<h;e++){const n=e*(d*f);for(let r=0;r<d;r++){const i=r*f;for(let s=0;s<f;s++){const a=[u,e,r,s],l=a[2],p=a[1];let _=(l-m)*v-(p-g)*y,x=(l-m)*y+(p-g)*v;_=Math.round(_+m),x=Math.round(x+g);let w=o;"number"!=typeof o&&(w=3===s?255:o[s]),_>=0&&_<d&&x>=0&&x<h&&(w=b[t+x*(d*f)+_*f+s]),c[t+n+i+s]=w}}}}return{dataId:l.write(c,i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},i0={kernelName:mF,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,r=e;IQ(n,"square");const i=r.data.get(n.dataId).values,s=new Float32Array(i.length);for(let o=0;o<i.length;++o){const t=i[o];s[o]=t*t}return{dataId:r.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},s0=jQ((t,e)=>{const n=t-e;return n*n}),o0=[VQ,HQ,UQ,qQ,XQ,JQ,ZQ,t0,n0,r0,i0,WQ(fF,s0),{kernelName:vF,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{perm:i}=e,s=n;IQ(r,"transpose");const o=new Array(r.shape.length);for(let l=0;l<o.length;l++)o[l]=r.shape[i[l]];const a=YQ(s.data.get(r.dataId).values,r.shape,r.dtype,i,o);return{dataId:s.write(a,o,r.dtype),shape:o,dtype:r.dtype}}}];for(const H3 of o0)OF(H3);const a0={},l0={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function c0(t){t in a0||(a0[t]=function(t){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=function(t){if("undefined"!=typeof OffscreenCanvas&&2===t)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(t);return e.addEventListener("webglcontextlost",e=>{e.preventDefault(),delete a0[t]},!1),1===t?e.getContext("webgl",l0)||e.getContext("experimental-webgl",l0):e.getContext("webgl2",l0)}(t));const e=a0[t];return e.isContextLost()?(delete a0[t],c0(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),a0[t])}var u0,h0,d0;function p0(t,e){return[e,t]}function f0(t){const e=r.sizeFromShape(t),n=Math.ceil(e/4);return r.sizeToSquarishShape(n)}function m0(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function g0(t,e){const n=t;let r,i,s,o,a,l,c,u,h,d;return 2===BD().getNumber("WEBGL_VERSION")?(r=n.R32F,i=n.R16F,s=n.RGBA16F,o=n.RGBA32F,a=n.RED,c=4,u=1,h=n.HALF_FLOAT,d=n.FLOAT):(r=t.RGBA,i=t.RGBA,s=t.RGBA,o=n.RGBA,a=t.RGBA,c=4,u=4,h=null!=e?e.HALF_FLOAT_OES:null,d=t.FLOAT),l=t.RGBA,{internalFormatFloat:r,internalFormatHalfFloat:i,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:d}}function y0(t,e){const n=e();return BD().getBool("DEBUG")&&function(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+function(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}(t,e))}(t),n}function v0(t){return!!(BD().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||5.96e-8<Math.abs(t)&&Math.abs(t)<65504)}function b0(t,e){return T0(t,()=>t.getExtension(e),'Extension "'+e+'" not supported on this browser.')}!function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"}(u0||(u0={})),function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(h0||(h0={})),function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(d0||(d0={}));const _0=/ERROR: [0-9]+:([0-9]+):/g;function x0(t,e){if(y0(t,()=>t.validateProgram(e)),!1===t.getProgramParameter(e,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function w0(t,e,n,r,i,s,o){const a=t.getAttribLocation(e,n);return-1!==a&&(y0(t,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),y0(t,()=>t.vertexAttribPointer(a,i,t.FLOAT,!1,s,o)),y0(t,()=>t.enableVertexAttribArray(a)),!0)}function S0(t,e,n){y0(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),y0(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0))}function E0(t,e){y0(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),y0(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function C0(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}(t,e))}function T0(t,e,n){const r=y0(t,()=>e());if(null==r)throw new Error(n);return r}function A0(t,e=2){return r.sizeFromShape(t.slice(0,t.length-e))}function M0(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function k0(t){let e=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(e=[A0(t),...M0(t)]),e}function R0(t){return t%2==0}function I0(t,e){if(t=t.slice(-2),e=e.slice(-2),r.arraysEqual(t,e))return!0;if(!t.length||!e.length)return!0;if(0===t[0]||0===t[1]||0===e[0]||0===e[1])return!0;if(t.length!==e.length){const n=t.slice(-1)[0],r=e.slice(-1)[0];if(n===r)return!0;if(R0(n)&&R0(r)&&(1===t[0]||1===e[0]))return!0}return t[1]===e[1]&&R0(t[0])&&R0(e[0])}let N0,O0;function D0(t,e){return null!=t.getExtension(e)}function L0(t){try{if(null!=c0(t))return!0}catch(e){return!1}return!1}function F0(t){const e=g0(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(r),i}const P0=BD();P0.registerFlag("HAS_WEBGL",()=>P0.getNumber("WEBGL_VERSION")>0),P0.registerFlag("WEBGL_VERSION",()=>L0(2)?2:L0(1)?1:0),P0.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),P0.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===P0.get("WEBGL_VERSION")),P0.registerFlag("WEBGL_CPU_FORWARD",()=>!0),P0.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),P0.registerFlag("WEBGL_PACK",()=>P0.getBool("HAS_WEBGL")),P0.registerFlag("WEBGL_PACK_NORMALIZATION",()=>P0.getBool("WEBGL_PACK")),P0.registerFlag("WEBGL_PACK_CLIP",()=>P0.getBool("WEBGL_PACK")),P0.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>!1),P0.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>P0.getBool("WEBGL_PACK")),P0.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>P0.getBool("WEBGL_PACK")),P0.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>P0.getBool("WEBGL_PACK")),P0.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>P0.getBool("WEBGL_PACK")),P0.registerFlag("WEBGL_PACK_REDUCE",()=>P0.getBool("WEBGL_PACK")),P0.registerFlag("WEBGL_LAZILY_UNPACK",()=>P0.getBool("WEBGL_PACK")),P0.registerFlag("WEBGL_CONV_IM2COL",()=>P0.getBool("WEBGL_PACK")),P0.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(t){if(null==N0){const e=c0(t);N0=e.getParameter(e.MAX_TEXTURE_SIZE)}return N0}(P0.getNumber("WEBGL_VERSION"))),P0.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(t){if(null==O0){const e=c0(t);O0=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,O0)}(P0.getNumber("WEBGL_VERSION"))),P0.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=P0.getNumber("WEBGL_VERSION");return 0===t?0:function(t){if(0===t)return 0;let e;const n=c0(t);return e=D0(n,"EXT_disjoint_timer_query_webgl2")&&2===t?2:D0(n,"EXT_disjoint_timer_query")?1:0,e}(t)}),P0.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>P0.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!s.isMobile()),P0.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(t){if(0===t)return!1;const e=c0(t);if(1===t){if(!D0(e,"OES_texture_float"))return!1}else if(!D0(e,"EXT_color_buffer_float"))return!1;return F0(e)}(P0.getNumber("WEBGL_VERSION"))),P0.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!P0.getBool("WEBGL_FORCE_F16_TEXTURES")&&P0.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),P0.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function(t){if(0===t)return!1;const e=c0(t);if(1!==t){if(D0(e,"EXT_color_buffer_float"))return F0(e);const t="EXT_color_buffer_half_float";if(D0(e,t)){const n=e.getExtension(t);return function(t,e){const n=g0(t,e),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const s=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(i),s}(e,n)}return!1}return!!D0(e,"OES_texture_float")&&!!D0(e,"WEBGL_color_buffer_float")&&F0(e)}(P0.getNumber("WEBGL_VERSION"))),P0.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return 2===(t=P0.getNumber("WEBGL_VERSION"))&&null!=c0(t).fenceSync;var t}),P0.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>P0.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),P0.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)});class $0{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((t,e)=>`T${e}`);const n=[];this.variableNames.forEach(t=>{n.push(`float v${t} = get${t}AtOutCoords();`)});const r=this.variableNames.map(t=>`v${t}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class B0{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((t,e)=>`T${e}`);const n=[];this.variableNames.forEach(t=>{n.push(`vec4 v${t} = get${t}AtOutCoords();`)});const r=this.variableNames.map(t=>`v${t}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}class z0{constructor(t,e,n){this.variableNames=["A"];const r=t.windowSize,i=t.batchSize,s=Math.ceil(t.inSize/r);n||this.variableNames.push("bestIndicesA"),this.outputShape=[i,s],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}function V0(t,e){return["x","y","z","w","u","v"].slice(0,e).map(e=>`${t}.${e}`)}function U0(t,e){return 1===e?[t]:V0(t,e)}function H0(){let t,e,n,r,i,s,o,a,l,c;return 2===BD().getNumber("WEBGL_VERSION")?(t="#version 300 es",e="in",n="out",r="in",i="texture",s="outputColor",o="out vec4 outputColor;",a="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",e="attribute",n="varying",r="varying",i="texture2D",s="gl_FragColor",o="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:i,output:s,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}function W0(t,e,n="index"){const i=r.computeStrides(e);return i.map((e,r)=>`int ${t[r]} = ${n} / ${e}; ${r===i.length-1?`int ${t[r+1]} = ${n} - ${t[r]} * ${e}`:`index -= ${t[r]} * ${e}`};`).join("")}function j0(t){const e=r.computeStrides(t).map(t=>t.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;\n  }\n`}const G0="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:q0}=p;function X0(t,e,n,i){const s=[];t.forEach(t=>{const e=r.sizeFromShape(t.shapeInfo.logicalShape);t.shapeInfo.isUniform?s.push(`uniform float ${t.name}${e>1?`[${e}]`:""};`):(s.push(`uniform sampler2D ${t.name};`),s.push(`uniform int offset${t.name};`))});const o=s.join("\n"),a=t.map(t=>function(t,e,n=!1){let i="";return i+=n?Y0(t):K0(t),t.shapeInfo.logicalShape.length<=e.logicalShape.length&&(i+=n?function(t,e){const n=t.name,i=n.charAt(0).toUpperCase()+n.slice(1),s="get"+i+"AtOutCoords",o=t.shapeInfo.logicalShape.length,a=e.logicalShape.length,l=q0(t.shapeInfo.logicalShape,e.logicalShape),c=r1(a),u=a-o;let h;const d=["x","y","z","w","u","v"];h=0===o?"":a<2&&l.length>=1?"coords = 0;":l.map(t=>`coords.${d[t+u]} = 0;`).join("\n");let p="";p=a<2&&o>0?"coords":t.shapeInfo.logicalShape.map((t,e)=>`coords.${d[e+u]}`).join(", ");let f="return outputValue;";const m=1===r.sizeFromShape(t.shapeInfo.logicalShape),g=1===r.sizeFromShape(e.logicalShape);if(1!==o||m||g){if(m&&!g)f=1===a?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(l.length){const t=o-2,e=o-1;l.indexOf(t)>-1&&l.indexOf(e)>-1?f="return vec4(outputValue.x);":l.indexOf(t)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(e)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${c} coords = getOutputCoords();\n      ${h}\n      vec4 outputValue = get${i}(${p});\n      ${f}\n    }\n  `}(t,e):function(t,e){const n=t.name,i=n.charAt(0).toUpperCase()+n.slice(1),s="get"+i+"AtOutCoords",o=t.shapeInfo.logicalShape.length,a=e.logicalShape.length;if(!t.shapeInfo.isUniform&&o===a&&null==t.shapeInfo.flatOffset&&r.arraysEqual(t.shapeInfo.texShape,e.texShape))return`\n      float ${s}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const l=r1(a),c=q0(t.shapeInfo.logicalShape,e.logicalShape),u=a-o;let h;const d=["x","y","z","w","u","v"];h=0===o?"":a<2&&c.length>=1?"coords = 0;":c.map(t=>`coords.${d[t+u]} = 0;`).join("\n");let p="";return p=a<2&&o>0?"coords":t.shapeInfo.logicalShape.map((t,e)=>`coords.${d[e+u]}`).join(", "),`\n    float ${s}() {\n      ${l} coords = getOutputCoords();\n      ${h}\n      return get${i}(${p});\n    }\n  `}(t,e)),i}(t,e,i)).join("\n"),l=e.texShape,c=H0(),u=function(t){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${t.texture2D}(textureSampler, uv).r;\n    }\n  `}(c);let h,d,p=function(t){return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFs} vec2 resultUV;\n    ${t.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${t.defineSpecialNaN}\n    ${t.defineSpecialInf}\n    ${t.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Z0}\n    ${J0}\n    ${Q0}\n  `}(c);return e.isPacked?(h=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return 1===n[0]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);\n    }\n  `}(0,e);case 2:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(r.arraysEqual(t,e))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;const i=Math.ceil(t[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(t,e);case 3:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[2]/2),i=r*Math.ceil(t[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(t,e);default:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[t.length-1]/2),i=r*Math.ceil(t[t.length-2]/2);let s=i,o="",a="b, r, c";for(let l=2;l<t.length-1;l++)s*=t[t.length-l-1],o=`\n      int b${l} = index / ${s};\n      index -= b${l} * ${s};\n    `+o,a=`b${l}, `+a;return`\n    ivec${t.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${t.length}(${a});\n    }\n  `}(t,e)}}(e.logicalShape,l),d=function(t){return`\n    void setOutput(vec4 val) {\n      ${t.output} = val;\n    }\n  `}(c)):(h=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return 1===(n=e)[0]?`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `;case 2:return function(t,e){return r.arraysEqual(t,e)?`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));\n      }\n    `:1===t[1]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===t[0]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      int r = index / ${t[1]};\n      int c = index - r * ${t[1]};\n      return ivec2(r, c);\n    }\n  `}(t,e);case 3:return function(t,e){const n=W0(["r","c","d"],t);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}(t,e);case 4:return function(t,e){const n=W0(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}(t,e);case 5:return function(t,e){const n=W0(["r","c","d","d2","d3"],t);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},\n                             ${e[1]}));\n\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(t,e);case 6:return function(t,e){const n=W0(["r","c","d","d2","d3","d4"],t);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}var n}(e.logicalShape,l),d=function(t){return`\n    void setOutput(float val) {\n      ${t.output} = vec4(val, 0, 0, 0);\n    }\n  `}(c)),i&&(p+=t1),[p,u,d,o,h,a,n].join("\n")}function K0(t){const e=t.shapeInfo.logicalShape;switch(e.length){case 0:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`float ${n}() {return ${e};}`;const[r,i]=t.shapeInfo.texShape;if(1===r&&1===i)return`\n      float ${n}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const[s,o]=t.shapeInfo.texShape;return`\n    float ${n}() {\n      vec2 uv = uvFromFlat(${s}, ${o}, ${e1(e)});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 1:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`\n      float ${n}(int index) {\n        ${n1(t)}\n      }\n    `;const r=t.shapeInfo.texShape,i=r[0],s=r[1];if(1===s&&1===i)return`\n      float ${n}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const o=e1(e);return 1===s?`\n      float ${n}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${i}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===i?`\n      float ${n}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${s}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n    float ${n}(int index) {\n      vec2 uv = uvFromFlat(${i}, ${s}, index + ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 2:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t.shapeInfo.texShape;if(null!=s&&r.arraysEqual(e,s))return`\n    float ${i}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${s[0]}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;const{newShape:o,keptDims:a}=r.squeezeShape(e);if(o.length<e.length){const e=["row","col"];return`\n      ${K0(i1(t,o))}\n      float ${i}(int row, int col) {\n        return ${i}(${s1(e,a)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${i}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${n1(t)}\n      }\n    `;const l=s[0],c=s[1],u=e1(n);return 1===c?`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${u}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:1===l?`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${u}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n  float ${i}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${u};\n    vec2 uv = uvFromFlat(${l}, ${c}, index);\n    return sampleTexture(${n}, uv);\n  }\n`}(t);case 3:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[1]*e[2],o=e[2],{newShape:a,keptDims:l}=r.squeezeShape(e);if(a.length<e.length){const e=["row","col","depth"];return`\n        ${K0(i1(t,a))}\n        float ${i}(int row, int col, int depth) {\n          return ${i}(${s1(e,l)});\n        }\n      `}if(t.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${o}, 1)));\n        ${n1(t)}\n      }\n    `;const c=t.shapeInfo.texShape,u=c[0],h=c[1],d=t.shapeInfo.flatOffset;return h===s&&null==d?`\n        float ${i}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${u}.0);\n          return sampleTexture(${n}, uv);\n        }\n      `:h===o&&null==d?`\n    float ${i}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${u}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n      float ${i}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${o} + depth + ${e1(n)};\n        vec2 uv = uvFromFlat(${u}, ${h}, index);\n        return sampleTexture(${n}, uv);\n      }\n  `}(t);case 4:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[3],o=e[2]*s,a=e[1]*o,{newShape:l,keptDims:c}=r.squeezeShape(e);if(l.length<e.length){const e=["row","col","depth","depth2"];return`\n      ${K0(i1(t,l))}\n      float ${i}(int row, int col, int depth, int depth2) {\n        return ${i}(${s1(e,c)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${o}, ${s}, 1)));\n        ${n1(t)}\n      }\n    `;const u=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],p=h[1];return p===a&&null==u?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:p===s&&null==u?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${i}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${o} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${p}, index + ${e1(n)});\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 5:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[4],o=e[3]*s,a=e[2]*o,l=e[1]*a,{newShape:c,keptDims:u}=r.squeezeShape(e);if(c.length<e.length){const e=["row","col","depth","depth2","depth3"];return`\n      ${K0(i1(t,c))}\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        return ${i}(${s1(e,u)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${l}, ${a}, ${o}, ${s})) +\n          depth3;\n        ${n1(t)}\n      }\n    `;const h=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,p=d[0],f=d[1];return f===l&&null==h?`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${a}, ${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:f===s&&null==h?`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]},\n               ${e[2]*e[3]}, ${e[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${i}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${l} + col * ${a} + depth * ${o} +\n          depth2 * ${s} + depth3 + ${e1(n)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 6:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:o}=r.squeezeShape(e);if(s.length<e.length){const e=["row","col","depth","depth2","depth3","depth4"];return`\n      ${K0(i1(t,s))}\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${i}(${s1(e,o)});\n      }\n    `}const a=e[5],l=e[4]*a,c=e[3]*l,u=e[2]*c,h=e[1]*u;if(t.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${h}, ${u}, ${c}, ${l})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${a}, 1)));\n        ${n1(t)}\n      }\n    `;const d=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,f=p[0],m=p[1];return m===h&&null==d?`\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${c}, ${l}, ${a})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${m}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:m===a&&null==d?`\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]*e[4]},\n               ${e[2]*e[3]*e[4]},\n               ${e[3]*e[4]},\n               ${e[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${m}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${i}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${h} + col * ${u} + depth * ${c} +\n          depth2 * ${l} + depth3 * ${a} + depth4 + ${e1(n)};\n      vec2 uv = uvFromFlat(${f}, ${m}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function Y0(t){switch(t.shapeInfo.logicalShape.length){case 0:return function(t){const e=t.name;return`\n    vec4 ${"get"+e.charAt(0).toUpperCase()+e.slice(1)}() {\n      return ${H0().texture2D}(${e}, halfCR);\n    }\n  `}(t);case 1:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t.shapeInfo.texShape,i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],s=H0();return`\n    vec4 ${n}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${s.texture2D}(${e}, uv);\n    }\n  `}(t);case 2:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t.shapeInfo.texShape,o=s[0],a=s[1],l=H0();if(null!=s&&r.arraysEqual(e,s))return`\n      vec4 ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);\n\n        return ${l.texture2D}(${n}, uv);\n      }\n    `;const c=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${i}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${c[0]}, ${c[1]}, row, col);\n      return ${l.texture2D}(${n}, uv);\n    }\n  `}(t);case 3:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=t.shapeInfo.texShape,s=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(1===e[0]){const n=[1,2],i=["b","row","col"];return`\n        ${Y0(i1(t,e.slice(1)))}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${s1(i,n)});\n        }\n      `}const o=s[0],a=s[1],l=Math.ceil(e[2]/2);return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${o}, ${a}, ${l*Math.ceil(e[1]/2)}, ${l}, b, row, col);\n      return ${H0().texture2D}(${n}, uv);\n    }\n  `}(t);default:return function(t){const e=t.shapeInfo.logicalShape,n=e.length,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],a=o[0],l=o[1],c=Math.ceil(e[n-1]/2);let u=c*Math.ceil(e[n-2]/2),h="int b, int row, int col",d=`b * ${u} + (row / 2) * ${c} + (col / 2)`;for(let p=2;p<n-1;p++)h=`int b${p}, `+h,u*=e[n-p-1],d=`b${p} * ${u} + `+d;return`\n    vec4 ${i}(${h}) {\n      int index = ${d};\n      int texR = index / ${l};\n      int texC = index - texR * ${l};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${a});\n      return ${H0().texture2D}(${r}, uv);\n    }\n  `}(t)}}const Z0="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",J0="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Q0="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",t1="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function e1(t){return`offset${t}`}function n1(t){const e=t.name,n=r.sizeFromShape(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${e}[i];\n      }\n    }\n  `}function r1(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function i1(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function s1(t,e){return e.map(e=>t[e]).join(", ")}class o1{constructor(t,e,n,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,r.assert(t.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const s=Math.ceil(t[t.length-1]/e);this.outputShape=t.slice(0,-1),s>1&&this.outputShape.push(s),i||this.variableNames.push("bestIndicesA");const o=this.outputShape,a=o.length,l=r1(a),c=U0("coords",a);let u,h;if(1===s){h=a+1;const t=r1(h);u=`\n        ${t} sourceLocR = ${t}(${c.join()}, 0);\n        ++${c[a-1]};\n        ${t} sourceLocG = ${t}(${c.join()}, 0);\n        ++${c[a-2]};\n        ${t} sourceLocA = ${t}(${c.join()}, 0);\n        --${c[a-1]};\n        ${t} sourceLocB = ${t}(${c.join()}, 0);\n        --${c[a-2]};`}else h=a,u=`\n        ${l} sourceLocR = coords;\n        ++${c[a-1]};\n        ${l} sourceLocG = coords;\n        ++${c[a-2]};\n        ${l} sourceLocA = coords;\n        --${c[a-1]};\n        ${l} sourceLocB = coords;\n        --${c[a-2]};`;const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map(t=>"int "+t),m=U0("sourceLocR",h-1).concat("inIdx.r"),g=U0("sourceLocG",h-1).concat("inIdx.g"),y=U0("sourceLocB",h-1).concat("inIdx.b"),v=U0("sourceLocA",h-1).concat("inIdx.a"),b="max"===n?"greaterThan":"lessThan",_=i?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${v.join()})));`,x=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,w=i?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${d.join()}),\n                                          vec2(${d.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${d.join()}),\n                               vec2(${d.slice(-2).join()}));\n      }\n      ${w}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${c[a-1]} < ${o[a-1]-1};\n        bool hasNextRow = ${c[a-2]} < ${o[a-2]-1};\n        ${u}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${x};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${_}\n          vec4 candidate = ${x};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${b}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}class a1{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.effectiveFilterHeight,n=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class l1{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.effectiveFilterDepth,n=t.effectiveFilterHeight,r=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${e};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${r};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class c1{constructor(t,e,n,r,i,s){this.outputShape=[],this.variableNames=["x","mean","variance"],p.assertAndGetBroadcastShape(t,e),p.assertAndGetBroadcastShape(t,n);let o="0.0";null!=r&&(p.assertAndGetBroadcastShape(t,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let a="1.0";null!=i&&(p.assertAndGetBroadcastShape(t,i),this.variableNames.push("scale"),a="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${o};\n        float scale = ${a};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class u1{constructor(t,e,n,r,i,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],p.assertAndGetBroadcastShape(t,e),p.assertAndGetBroadcastShape(t,n);let o="vec4(0.0)";null!=r&&(p.assertAndGetBroadcastShape(t,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let a="vec4(1.0)";null!=i&&(p.assertAndGetBroadcastShape(t,i),this.variableNames.push("scale"),a="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${o};\n        vec4 scale = ${a};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}class h1{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=p.assertAndGetBroadcastShape(e,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const d1="return a + b;",p1="return a - b;",f1="return a * b;",m1="return (a < 0.) ? b * a : a;";class g1{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=p.assertAndGetBroadcastShape(e,n),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const y1="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";class v1{constructor(t,e,n,i=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=p.assertAndGetBroadcastShape(e,n);const s=this.outputShape.length;let o="";if(i)if(0===s||1===r.sizeFromShape(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(o=`\n          ${r1(s)} coords = getOutputCoords();\n        `,1===s)o+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const t=U0("coords",s);o+=`\n            bool nextRowOutOfBounds =\n              (${t[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${t[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${o}\n\n        setOutput(result);\n      }\n    `}}class b1{constructor(t){this.variableNames=["A"],this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(t,e){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}}class _1{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(t,e){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}}class x1{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}class w1{constructor(t){this.outputShape=[],this.outputShape=p.computeOutShape(t,1),this.variableNames=t.map((t,e)=>`T${e}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let r=1;r<e.length;r++)e[r]=e[r-1]+t[r][1];const n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let r=1;r<e.length;r++)n.push(`else if (yC < ${e[r]}) setOutput(getT${r}(yR, yC-${e[r-1]}));`);n.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class S1{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=p.computeOutShape(t,e);const n=this.outputShape,r=n.length,i=r1(r),s=U0("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map((t,e)=>`T${e}`);const a=new Array(t.length-1);a[0]=t[0][e];for(let p=1;p<a.length;p++)a[p]=a[p-1]+t[p][e];const l=o[e],c=o.slice(-2),u=o.join();let h=`if (${l} < ${a[0]}) {\n        return getChannel(\n            getT0(${u}), vec2(${c.join()}));\n        }`;for(let p=1;p<a.length;p++){const t=a[p-1];h+=`\n        if (${l} < ${a[p]}  && ${l} >= ${a[p-1]}) {\n          return getChannel(\n            getT${p}(${E1(o,l,t)}),\n            vec2(${E1(c,l,t)}));\n        }`}const d=a[a.length-1];h+=`\n        return getChannel(\n          getT${a.length}(${E1(o,l,d)}),\n          vec2(${E1(c,l,d)}));`,this.userCode=`\n      float getValue(${o.map(t=>"int "+t)}) {\n        ${h}\n      }\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[r-1]} = ${s[r-1]} + 1;\n        if (${s[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[r-2]} = ${s[r-2]} + 1;\n        if (${s[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[r-1]} = ${s[r-1]} - 1;\n        if (${s[r-2]} < ${n[r-2]} &&\n            ${s[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}}function E1(t,e,n){const r=t.indexOf(e);return t.map((t,e)=>e===r?`${t} - ${n}`:t).join()}class C1{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===t.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class T1{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${r?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${r?1:2}], coords[${r?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${r}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class A1{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class M1{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,r=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class k1{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class R1{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${r}; dm++) {\n              int d2 = d1 * ${r} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class I1{constructor(t,e=!1,n=null,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const i=t.padInfo.top,s=t.padInfo.left,o=t.strideHeight,a=t.strideWidth,l=t.dilationHeight,c=t.dilationWidth,u=t.filterHeight,h=t.filterWidth,d=4*Math.floor(t.inChannels/4),p=t.inChannels%4,f="channelsLast"===t.dataFormat,m=f?1:2,g=f?2:3,y=f?3:1;let v="",b="";n&&(v=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,b="result = activation(result);");const _=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${o}, ${a});\n      const ivec2 pads = ivec2(${i}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${y}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${m}], coords[${g}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${u}; wR++) {\n          int xR = xRCorner + wR * ${l};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${d}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${f}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===p}) {\n\n              if (${f}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${d}) *\n                    getW(wR, wC, ${d}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${d}, xR, xC) *\n                    getW(wR, wC, ${d}, d2);\n              }\n\n            } else if (${2===p}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${d}, d2),\n                getW(wR, wC, ${d} + 1, d2)\n              );\n\n              if (${f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${d}),\n                  getX(batch, xR, xC, ${d} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${d}, xR, xC),\n                  getX(batch, ${d} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===p}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${d}, d2),\n                getW(wR, wC, ${d} + 1, d2),\n                getW(wR, wC, ${d} + 2, d2)\n              );\n\n              if (${f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${d}),\n                  getX(batch, xR, xC, ${d} + 1),\n                  getX(batch, xR, xC, ${d} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${d}, xR, xC),\n                  getX(batch, ${d} + 1, xR, xC),\n                  getX(batch, ${d} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${_}\n        ${b}\n        setOutput(result);\n      }\n    `}}class N1{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,n=t.padInfo.top,r=t.padInfo.left,i=t.strideDepth,s=t.strideHeight,o=t.strideWidth,a=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,u=t.filterDepth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${i}, ${s}, ${o});\n      const ivec3 pads = ivec3(${e}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${u}; wF++) {\n          int xF = xFCorner + wF * ${a};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${c};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class O1{constructor(t,e=!1,n=null,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const i=t.inHeight,s=t.inWidth,o=t.padInfo.top,a=t.padInfo.left,l=t.strideHeight,c=t.strideWidth,u=t.dilationHeight,h=t.dilationWidth,d=t.filterHeight,p=t.filterWidth,f=t.outChannels/t.inChannels;let m="",g="";n&&(m=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,g="result = activation(result);");const y=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${m}\n\n      const ivec2 strides = ivec2(${l}, ${c});\n      const ivec2 pads = ivec2(${o}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${f};\n        int q = d2 - d1 * ${f};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${i}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${h};\n\n            if (xC < 0 || xC >= ${s}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${y}\n        ${g}\n        setOutput(result);\n      }\n    `}}class D1{constructor(t,e=!1,n=null,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.outShape;const s=t.inHeight,o=t.inWidth,a=t.padInfo.top,l=t.padInfo.left,c=t.strideHeight,u=t.strideWidth,h=t.dilationHeight,d=t.dilationWidth,p=t.filterHeight,f=t.filterWidth,m=f;let g="int xR; int xC; int xCOffset;";for(let r=0;r<p;r++)for(let t=0;t<f;t++)g+=`\n          vec4 xTexelR${r}C${2*t} = vec4(0.);\n          vec4 wR${r}C${t} = vec4(0.);\n          vec4 xR${r}C${t} = vec4(0.);`;for(let _=0;_<p;_++)for(let t=0;t<m;t++){const e=2*t;if(g+=`\n          xR = xRCorner + ${_*h};\n          xC = xCCorner + ${e*d};\n        `,1===u){if(e<f&&(g+=l%2==1?`\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ${s} && xCOffset >= 0 && xCOffset < ${o}) {\n                  xTexelR${_}C${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${o}) {\n                    xTexelR${_}C${e}.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR${_}C${e} = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ${s} && xCOffset >= 0 && xCOffset < ${o}) {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${o}) {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR${_}C${e} = vec4(previous.zw, xTexelR${_}C${e}.xy);\n                } else {\n                  xR${_}C${e} = vec4(0, 0, xTexelR${_}C${e}.xy);\n                }\n              `:`\n                if(xR >= 0 && xR < ${s} && xC >= 0 && xC < ${o}) {\n                  xTexelR${_}C${e} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${_}C${e} = vec4(0.);\n                }\n\n                xR${_}C${e} = xTexelR${_}C${e};\n              `,e+1<f)){const t=l%2==0?r.nearestLargerEven(d):d;d%2==0&&l%2==1||d%2!=0&&l%2!=1?(g+=`\n                  xCOffset = xC + ${l%2} + ${t};\n\n                  if(xR >= 0 && xR < ${s} &&\n                    xCOffset >= 0 && xCOffset < ${o}) {\n                    xTexelR${_}C${e+2} = getX(batch, xR, xCOffset, d1);\n                  }\n                `,d>1&&(g+=`\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ${s} &&\n                      xCOffset >= 0 && xCOffset < ${o}) {\n                      xTexelR${_}C${e} = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR${_}C${e} = vec4(0.);\n                    }\n                  `),g+=`\n                  xR${_}C${e+1} = vec4(\n                    xTexelR${_}C${e}.zw, xTexelR${_}C${e+2}.xy);\n                `):g+=`\n                  xCOffset = xC + ${t};\n\n                  if(xR >= 0 && xR < ${s} &&\n                    xCOffset >= 0 && xCOffset < ${o}) {\n                    xTexelR${_}C${e+2} = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR${_}C${e+1} = xTexelR${_}C${e+2};\n                `}}else e<f&&(g+=`\n              if(xR >= 0 && xR < ${s}) {\n            `,l%2==1?(g+=`\n                xCOffset = xC + 1 - ${u};\n                if(xCOffset >= 0 && xCOffset < ${o}) {\n                  xTexelR${_}C${e} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${_}C${e} = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${o}) {\n                  xTexelR${_}C${e+2} = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR${_}C${e+2} = vec4(0.);\n                }\n\n                xR${_}C${e} = vec4(\n                  xTexelR${_}C${e}.zw, xTexelR${_}C${e+2}.zw);\n              `,e+1<f&&(g+=`\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ${u};\n                  if(xCOffset >= 0 && xCOffset < ${o}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR${_}C${e+1} = vec4(xTexelR${_}C${e+2}.xy, final.xy);\n                `)):(g+=`\n                if(xC >= 0 && xC < ${o}) {\n                  xTexelR${_}C${e} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${_}C${e} = vec4(0.);\n                }\n\n                xCOffset = xC + ${u};\n                if(xCOffset >= 0 && xCOffset < ${o}) {\n                  xTexelR${_}C${e+2} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${_}C${e+2} = vec4(0.);\n                }\n\n                xR${_}C${e} = vec4(\n                  xTexelR${_}C${e}.xy, xTexelR${_}C${e+2}.xy);\n              `,e+1<f&&(g+=`\n                  xR${_}C${e+1} = vec4(\n                    xTexelR${_}C${e}.zw, xTexelR${_}C${e+2}.zw);\n                `)),g+="}");e<f&&(g+=`\n            vec4 wTexelR${_}C${e} = getW(${_}, ${e}, d1, q);\n            wR${_}C${e} = vec4(wTexelR${_}C${e}.xz, wTexelR${_}C${e}.xz);\n          `,e+1<f&&(g+=`\n              vec4 wTexelR${_}C${e+1} = getW(${_}, ${e+1}, d1, q);\n              wR${_}C${e+1} =\n                vec4(wTexelR${_}C${e+1}.xz, wTexelR${_}C${e+1}.xz);`))}for(let r=0;r<p;r++)for(let t=0;t<f;t++)g+=`dotProd += xR${r}C${t} * wR${r}C${t};`;let y="",v="";n&&(y=i?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,v="result = activation(result);");const b=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${y}\n\n      const ivec2 strides = ivec2(${c}, ${u});\n      const ivec2 pads = ivec2(${a}, ${l});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ${g}\n\n        vec4 result = dotProd;\n        ${b}\n        ${v}\n        setOutput(result);\n      }\n    `}}class L1{constructor(t,e,n,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,o,a,l]=t,[c]=e,[u,h]=n;this.outputShape=[c,u,h,l];const d="bilinear"===r?1:0,[p,f]=[o-1+".0",a-1+".0"],[m,g,y]=u>1?[""+(o-1)/(u-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[v,b,_]=h>1?[""+(a-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${v});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${b};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${i}));\n          return;\n        }\n        float in_x = ${_};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${i}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}class F1{constructor(t,e,n){this.variableNames=["x"],this.outputShape=t;const r=t.length,i=e?"0.0":`getX(${P1(r,"coords")})`,s=t[t.length-1];let o="",a="";e?(o=n?"end != "+(s-1):"end != 0",a=n?"end + 1":"end - 1"):(o=n?`end + pow2 < ${s}`:"end >= pow2",a=n?"end + pow2":"end - pow2"),this.userCode=`\n      uniform float index;\n      void main() {\n        ${r1(r)} coords = getOutputCoords();\n        int end = ${$1(r,"coords")};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${o}) {\n          int idx = ${a};\n          ${$1(r,"coords")} = idx;\n          val += getX(${P1(r,"coords")});\n        }\n        setOutput(val);\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.index&&(this.index=e.getUniformLocation(n,"index")),e.gl.uniform1f(this.index,t)}}}function P1(t,e){if(1===t)return`${e}`;if(2===t)return`${e}.x, ${e}.y`;if(3===t)return`${e}.x, ${e}.y, ${e}.z`;if(4===t)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}function $1(t,e){if(1===t)return`${e}`;if(2===t)return`${e}.y`;if(3===t)return`${e}.z`;if(4===t)return`${e}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}class B1{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=u0.DENSE;const e=f0(t),n=H0();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${W0(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class z1{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=u0.DENSE;const e=f0(t),n=H0();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${W0(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class V1{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}class U1{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}class H1{constructor(t){this.variableNames=["A"],this.outTexUsage=h0.DOWNLOAD;const e=H0();this.outputShape=t,this.userCode=`\n      ${G0}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class W1{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=h0.DOWNLOAD;const e=H0();this.outputShape=t,this.userCode=`\n      ${G0}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}class j1{constructor(t,e,n=!1){this.variableNames=["A"];const r=H0(),[i,s]=e;this.outputShape=t;let o="result";n&&(o="floor(result * 255. + 0.5)"),this.userCode=`\n      ${j0(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${s};\n        int c = imod(flatIndex, ${s});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${s}.0, ${i}.0);\n        vec4 values = ${r.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${r.output} = vec4(${o}, 0., 0., 0.);\n      }\n    `}}class G1{constructor(t,e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const r=H0(),[i,s]=e;this.outputShape=t;let o="",a="result";n&&(a="floor(result * 255. + 0.5)");for(let l=0;l<=1;l++)for(let e=0;e<=1;e++){const n=2*l+e;o+=`\n          localCoords = coords;\n          if(localCoords[2] + ${e} < ${t[2]}) {\n            localCoords[2] += ${e};\n            if(localCoords[1] + ${l} < ${t[1]}) {\n              localCoords[1] += ${l};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${s};\n              c = imod(flatIndex, ${s});\n              uv = (vec2(c, r) + halfCR) / vec2(${s}.0, ${i}.0);\n              values = ${r.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${n}] = values[0];\n              } else if(offset == 1) {\n                result[${n}] = values[1];\n              } else if(offset == 2) {\n                result[${n}] = values[2];\n              } else {\n                result[${n}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${j0(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${o}\n\n        ${r.output} = ${a};\n      }\n    `}}class q1{constructor(t,e,n){this.variableNames=["real","imag"];const r=e[1];this.outputShape=e;const i=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`;this.userCode=`\n      const float exponentMultiplier = ${i};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${t}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${n?`${r}.0`:"1.0"};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}class X1{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(t){return(e,n)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(n,"value")),e.gl.uniform1f(this.valueLoc,t)}}}class K1{constructor(t,e,n){this.variableNames=["A","indices"];const r=t.slice();r[n]=e,this.outputShape=r,this.rank=r.length;const i=r1(this.rank),s=function(t,e){const n=t.length;if(n>4)throw Error(`Gather for rank ${n} is not yet supported`);if(1===n)return"int(getIndices(resRC))";const r=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[];for(let s=0;s<t.length;s++)i.push(s===e?`int(getIndices(${r[s]}))`:`${r[s]}`);return i.join()}(t,n);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}class Y1{constructor(t,e,n){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=n;const r=r1(e.length),i=r1(n.length);this.userCode=`\n        ${r} strides = ${r}(${this.strides});\n         void main() {\n          ${i} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${this.sliceDim>1?"strides[j]":"strides"};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}function Z1(t,e,n,r,i,s){!function(t,e){const n=BD().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0)throw new Error(`Requested texture size [${t}x${e}] is invalid.`);if(t>n||e>n)throw new Error(`Requested texture size [${t}x${e}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(e,n);const o=function(t){return T0(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}(t),a=t.TEXTURE_2D;return y0(t,()=>t.bindTexture(a,o)),y0(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),y0(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),y0(t,()=>t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.NEAREST)),y0(t,()=>t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.NEAREST)),y0(t,()=>t.texImage2D(a,0,r,e,n,0,i,s,null)),y0(t,()=>t.bindTexture(t.TEXTURE_2D,null)),o}function J1(t){return t.internalFormatFloat}function Q1(t){return t.internalFormatHalfFloat}function t2(t){return t.downloadTextureFormat}function e2(t){return t.internalFormatPackedFloat}function n2(t){return t.internalFormatPackedHalfFloat}class r2{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const e=BD().getNumber("WEBGL_VERSION");null!=t?(this.gl=t,function(t,e){a0[t]=e}(e,t)):this.gl=c0(e);let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(1===BD().getNumber("WEBGL_VERSION")){const t="OES_texture_half_float";if(this.textureFloatExtension=b0(this.gl,"OES_texture_float"),D0(this.gl,t))this.textureHalfFloatExtension=b0(this.gl,t);else if(BD().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),D0(this.gl,r))this.colorBufferHalfFloatExtension=b0(this.gl,r);else if(BD().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",D0(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!D0(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=function(t){return function(t,e){const n=T0(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return y0(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),y0(t,()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)),n}(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(t){return function(t,e){const n=T0(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return y0(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)),y0(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW)),n}(t,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(t){return T0(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=g0(this.gl,this.textureHalfFloatExtension)}get debug(){return BD().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;y0(t,()=>t.finish()),y0(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),y0(t,()=>t.deleteFramebuffer(this.framebuffer)),y0(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),y0(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),y0(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[i,s]=p0(e,n);return Z1(t,i,s,J1(r),r.textureFormatFloat,t.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[i,s]=p0(e,n);return Z1(t,i,s,Q1(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[i,s]=p0(e,n);return Z1(t,i,s,t2(r),t.RGBA,t.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function(t,e,n){y0(t,()=>t.bindTexture(t.TEXTURE_2D,e)),n.data instanceof Uint8Array?y0(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data)):y0(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),y0(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,r){this.throwIfDisposed(),function(t,e,n,r,i,s){let o,a,l;y0(t,()=>t.bindTexture(t.TEXTURE_2D,e)),i instanceof Uint8Array?(o=new Uint8Array(n*r*4),a=t.UNSIGNED_BYTE,l=t.RGBA):(o=new Float32Array(n*r*4),a=t.FLOAT,l=s.internalFormatPackedFloat),o.set(i),y0(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,n,r,0,t.RGBA,a,o)),y0(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,t,e,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[i,s]=m0(e,n);return Z1(t,i,s,n2(r),t.RGBA,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[i,s]=m0(e,n);return Z1(t,i,s,e2(r),t.RGBA,t.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(E0(this.gl,this.framebuffer),this.outputTexture=null),y0(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,()=>function(t,e,n,r){const[i,s]=p0(e,n),o=new Uint8Array(e*n*4);return y0(t,()=>t.readPixels(0,0,i,s,r.downloadTextureFormat,t.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}(this.gl,e,n,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,n,r,i,s){return function(t,e,n,r,i,s,o,a){const l=t,c=new Float32Array(function(t,e){const[n,r]=m0(t,e);return n*r*4}(s,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}(this.gl,t,0,0,0,i,s)}downloadFloat32MatrixFromBuffer(t,e){return function(t,e,n){const r=t,i=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,i),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),i}(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);const r=function(t,e,n,r){const i=t.createBuffer();y0(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,i));const s=16*e*n;return y0(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,s,t.STREAM_READ)),y0(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0)),y0(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),i}(this.gl,e,n);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(BD().getBool("WEBGL_FENCE_API_ENABLED")){const r=t,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{const t=r.clientWaitSync(i,0,0);return t===r.ALREADY_SIGNALED||t===r.CONDITION_SATISFIED},e=i}else BD().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,BD().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,()=>function(t,e,n){const r=new Float32Array(e*n*4);return y0(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,r)),r}(this.gl,e,n))}createProgram(t){this.throwIfDisposed();const e=this.gl,n=function(t,e){const n=T0(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(y0(t,()=>t.shaderSource(n,e)),y0(t,()=>t.compileShader(n)),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw function(t,e){const n=_0.exec(e);if(null==n)return console.log(`Couldn't parse line number in error: ${e}`),void console.log(t);const i=+n[1],s=t.split("\n"),o=s.length.toString().length+2,a=s.map((t,e)=>r.rightPad((e+1).toString(),o)+t);let l=0;for(let r=0;r<a.length;r++)l=Math.max(a[r].length,l);const c=a.slice(0,i-1),u=a.slice(i-1,i),h=a.slice(i);console.log(c.join("\n")),console.log(e.split("\n")[0]),console.log(`%c ${r.rightPad(u[0],l)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join("\n"))}(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e,t),i=function(t){const e=H0();return function(t,e){const n=T0(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(y0(t,()=>t.shaderSource(n,e)),y0(t,()=>t.compileShader(n)),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(t,`${e.version}\n    precision highp float;\n    ${e.attribute} vec3 clipSpacePos;\n    ${e.attribute} vec2 uv;\n    ${e.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e),s=function(t){return T0(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}(e);return y0(e,()=>e.attachShader(s,i)),y0(e,()=>e.attachShader(s,n)),function(t,e){if(y0(t,()=>t.linkProgram(e)),!1===t.getProgramParameter(e,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}(e,s),this.debug&&x0(e,s),this.vertexAttrsAreBound||(this.setProgram(s),this.vertexAttrsAreBound=function(t,e,n){return y0(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),w0(t,e,"clipSpacePos",n,3,20,0)&&w0(t,e,"uv",n,2,20,12)}(e,this.program,this.vertexBuffer)),s}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&y0(this.gl,()=>this.gl.deleteProgram(t))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&x0(this.gl,this.program),y0(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?function(t,e,n){return T0(t,()=>t.getUniformLocation(e,n),'uniform "'+n+'" not present in program.')}(this.gl,t,e):function(t,e,n){return t.getUniformLocation(e,n)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),y0(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),function(t,e,n,r){y0(t,()=>function(t,e,n){(function(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)})(t,n),y0(t,()=>t.activeTexture(t.TEXTURE0+n)),y0(t,()=>t.bindTexture(t.TEXTURE_2D,e))}(t,e,r)),y0(t,()=>t.uniform1i(n,r))}(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();const[r,i]=m0(e,n);this.setOutputMatrixTextureDriver(t,r,i)}setOutputMatrixWriteRegion(t,e,n,r){this.setOutputMatrixWriteRegionDriver(n,t,r,e)}setOutputPackedMatrixWriteRegion(t,e,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&x0(this.gl,this.program),C0(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;this.debug&&this.debugValidate(),y0(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),y0(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=b0(this.gl,2===BD().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===BD().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2(),n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===BD().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2();return void t.endQuery(e.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await r.repeatedTry(()=>this.disposed||this.isQueryAvailable(t,BD().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,BD().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(0===e)return null;if(2===e){const e=this.gl;return e.getQueryParameter(t,e.QUERY_RESULT)/1e6}{const e=this.getQueryTimerExtensionWebGL1();return e.getQueryObjectEXT(t,e.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const e=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=e.getQueryParameter(t,e.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const e=this.getQueryTimerExtensionWebGL1(),n=e.getQueryObjectEXT(t,e.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(e.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}(this.itemsToPoll.map(t=>t.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:t}=this.itemsToPoll[e];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||r.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),S0(this.gl,t,this.framebuffer),this.debug&&C0(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(S0(this.gl,this.outputTexture,this.framebuffer),this.debug&&C0(this.gl)):E0(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();const r=this.gl;S0(r,t,this.framebuffer),this.debug&&C0(r),this.outputTexture=t,y0(r,()=>r.viewport(0,0,e,n)),y0(r,()=>r.scissor(0,0,e,n))}setOutputMatrixWriteRegionDriver(t,e,n,r){this.throwIfDisposed(),y0(this.gl,()=>this.gl.scissor(t,e,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}function i2(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((t,n)=>{const i=t.logicalShape,s=e[n],o=s.shape;if(!r.arraysEqual(i,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${o} must match`);if(t.isUniform&&s.isUniform)return;const a=t.texShape,l=s.isUniform?null:s.texData.texShape;if(!r.arraysEqual(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}class s2{constructor(t,e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;const{filterWidth:r,inChannels:i,strideWidth:s,strideHeight:o,padInfo:a,outWidth:l,dilationWidth:c,dilationHeight:u,dataFormat:h}=n,{left:d,top:p}=a,f=i*r,m=H0(),g="channelsLast"===h,y=g?0:1,v=g?1:2;let b="";for(let _=0;_<=1;_++)for(let n=0;n<=1;n++)b+=`\n          blockIndex = rc.y + ${n};\n          pos = rc.x + ${_};\n\n          if(blockIndex < ${t[1]} && pos < ${t[0]}) {\n            offsetY = int(blockIndex / (${l})) * ${o} - ${p};\n            d0 = offsetY + ${u} * (pos / ${f});\n\n            if(d0 < ${e[y]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${l}.) * ${s}. - ${d}.);\n              d1 = offsetX + ${c} * (int(mod(float(pos), ${f}.) / ${i}.));\n\n              if(d1 < ${e[v]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${i}.));\n\n                if (${g}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*_+n}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*_+n}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${b}\n\n        ${m.output} = result;\n      }\n    `}}class o2{constructor(t,e,n,r,i){this.variableNames=["x"],this.outputShape=[];const s=e,o=t[3]-1;let a;this.outputShape=t;const l=`float(${n}) + float(${r}) * sum`;a=.5===i?`inversesqrt(${l})`:1===i?`1.0/(${l})`:`exp(log(${l}) * float(-${i}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${o}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${a};\n        setOutput(val);\n      }\n    `}}class a2{constructor(t,e,n,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=r,this.beta=i,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${i})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${i});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}class l2{constructor(t,e,n,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const s=e,o=t[3]-1;let a;this.outputShape=t;const l=`float(${n}) + float(${r}) * sum`;a=.5===i?`inversesqrt(${l})`:1===i?`1.0/(${l})`:`exp(log(${l}) * float(-${i}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${a};\n        setOutput(result);\n      }\n    `}}class c2{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.effectiveFilterHeight,n=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${e*n-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${n} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class u2{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.effectiveFilterDepth,n=t.effectiveFilterHeight,r=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${e};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${r};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${e*n*r-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${n} * ${r} +\n                  wR * ${r} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class h2{constructor(t,e,n=!1,r=!1,i=!1,s=null,o=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;const a=Math.ceil((n?t[1]:t[2])/2),l=n?"i * 2, rc.y":"rc.y, i * 2",c=r?"rc.z, i * 2":"i * 2, rc.z",u=n?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let d="",p="";s&&(d=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${s}\n        }`:`vec4 activation(vec4 x) {\n          ${s}\n        }`,p="result = activation(result);");const f=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${d}\n\n      const float sharedDimension = ${a}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${a}; i++) {\n          vec4 a = getMatrixA(rc.x, ${l});\n          vec4 b = getMatrixB(rc.x, ${c});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${u[0]} * ${h[0]});\n          result += (${u[1]} * ${h[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${f}\n\n        ${p}\n\n        setOutput(result);\n      }\n    `}}class d2{constructor(t,e,n){this.variableNames=["probs"],this.outputShape=[t,n],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.seedLoc&&(this.seedLoc=e.getUniformLocation(n,"seed")),e.gl.uniform1f(this.seedLoc,t)}}}class p2{constructor(t,e,n,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}class f2{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t;const e=t.length;if(0===e)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=U0("rc",e),r=r1(e),i=function(t,e,n){if(1===t)return`rc > ${e[0]}`;let r="";for(let i=t-2;i<t;i++)r+=`${n[i]} >= ${e[i]}`,i<t-1&&(r+="||");return r}(e,t,n),s=function(t,e,n,r){if(1===t)return"";const i=r.slice(-2);return`\n    int r = ${i[0]};\n    int c = ${i[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${e};\n    bool rEdge = rp1 >= ${n};\n  `}(e,t[t.length-1],t[t.length-2],n),o=function(t,e){const n=t.length,r=function(t,e){const n=[];for(let r=0;r<=1;r++)for(let i=0;i<=1;i++){let s=`${0===r?"r":"rp1"}, ${0===i?"c":"cp1"}`;for(let n=2;n<t;n++)s=`${e[e.length-1-n]},`+s;n.push(s)}return n}(n,e);return 1===n?`getA(rc),\n            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),\n            0, 0`:`getA(${r[0]}),\n          cEdge ? 0. : getA(${r[1]}),\n          rEdge ? 0. : getA(${r[2]}),\n          rEdge || cEdge ? 0. : getA(${r[3]})`}(t,n);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${i}) {\n            setOutput(vec4(0));\n          } else {\n            ${s}\n\n            setOutput(vec4(${o}));\n          }\n        }\n      `}}}class m2{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const r=t.length,i=r1(r),s=e.map(t=>t[0]).join(","),o=e.map((e,n)=>e[0]+t[n]).join(","),a=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${i} start = ${i}(${s});\n      ${i} end = ${i}(${o});\n\n      void main() {\n        ${i} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(${n}));\n        } else {\n          ${i} coords = outC - start;\n          setOutput(getX(${a}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(${n}));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class g2{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const r=t.length,i=r1(r),s=e.map(t=>t[0]).join(","),o=e.map((e,n)=>e[0]+t[n]).join(","),a=U0("rc",r),l=U0("source",r),c=`${a[r-1]} < ${this.outputShape[r-1]}`,u=1===r?"source":`vec2(${l.slice(-2).join()})`,h=[`${i} rc = outputLoc;`,`${a[r-1]} += 1;\n       if(${c}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${a[r-2]} += 1;\n       if(${a[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${a[r-1]} += 1;\n         if(${c}) {`],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===r?2:4;f<m;f++)p+=`\n        ${h[f]}\n        if (${d}) {\n          result[${f}] = float(${n});\n        } else {\n          ${i} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${u});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${i} start = ${i}(${s});\n      const ${i} end = ${i}(${o});\n\n      void main() {\n        ${i} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}class y2{constructor(t,e,n,r=!1,i=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const s=t.filterWidth,o=t.strideHeight,a=t.strideWidth,l=t.dilationHeight,c=t.dilationWidth,u=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.top,p=t.padInfo.left;this.outputShape=t.outShape;const f="avg"===e;let m="0.0";if(f||(m="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec2 strides = ivec2(${o}, ${a});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${u};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${c}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?i?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let g=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(g="avgValue / count");const y=4*Math.floor(s/4),v=s%4,b=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${a});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${m};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${m});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${u};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${y}; wC += 4) {\n            int xC = xCCorner + wC * ${c};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              getValue(batch, xR, xC + 3 * ${c}, d)\n            );\n\n            ${b}\n          }\n\n          int xC = xCCorner + ${y};\n          if (${1===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${b}\n          } else if (${2===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${b}\n          } else if (${3===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              initializationValue\n            );\n\n            ${b}\n          }\n        }\n        setOutput(${g});\n      }\n    `}}class v2{constructor(t,e,n,r=!1,i=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const s=t.filterWidth,o=t.strideDepth,a=t.strideHeight,l=t.strideWidth,c=t.dilationDepth,u=t.dilationHeight,h=t.dilationWidth,d=t.effectiveFilterDepth,p=t.effectiveFilterHeight,f=t.effectiveFilterWidth,m=t.padInfo.front,g=t.padInfo.top,y=t.padInfo.left;this.outputShape=t.outShape;const v="avg"===e;let b="0.0";if(v||(b="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${o}, ${a}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${c}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${u}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?i?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let _=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(_="avgValue / count");const x=4*Math.floor(s/4),w=s%4,S=`\n      if (${v}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${o}, ${a}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${c}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${x}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${x};\n            if (${1===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n          setOutput(${_});\n        }\n      }\n    `}}class b2{constructor(t,e){this.variableNames=["x"];const n=t.windowSize,r=t.batchSize,i=t.inSize,s=Math.ceil(i/n);this.outputShape=[r,s];let o="0.0",a="";"prod"===e?o="1.0":"min"===e?(o="1.0 / 1e-20",a="min"):"max"===e&&(o="-1.0 / 1e-20",a="max");let l=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?l="sumValue":"prod"===e?l="prodValue":"all"===e?l="allValue":"any"===e&&(l="anyValue");const c=4*Math.floor(n/4),u=n%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${a}(values, minMaxValue);\n      }\n    `,d="vec4";"all"===e?(o="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===e&&(o="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";i%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${o};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${o});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===u}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===u}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===u}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${l});\n      }\n    `}}class _2{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;let n="";for(let i=0;i<4;i++){let t="thisRC = rc;";i%2==1&&(t+="thisRC.z += 1;"),i>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${i>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${i}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${i>0?"}":""}\n      `}var r;this.userCode=`\n      ${r=e,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${W0(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${j0(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${t[1]};\n        int cols = ${t[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class x2{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;const[,r,i]=e.shape,[,s,o]=t.shape,a=[n&&s>1?r-1:r,n&&o>1?i-1:i],l=[n&&s>1?s-1:s,n&&o>1?o-1:o],c=a[0]/l[0],u=a[1]/l[1],h=1/c,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${u});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}class w2{constructor(t,e,n,r){this.variableNames=["A"],this.outputShape=[];const[i,s,o,a]=t;this.outputShape=[i,e,n,a];const l=[r&&e>1?s-1:s,r&&n>1?o-1:o],c=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${s}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class S2{constructor(t,e,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,s,o,a]=t;this.outputShape=[i,e,n,a];const l=[r&&e>1?s-1:s,r&&n>1?o-1:o],c=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${s}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${a-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}class E2{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;const[,r,i]=e.shape,[,s,o]=t.shape,a=[n&&s>1?r-1:r,n&&o>1?i-1:i],l=[n&&s>1?s-1:s,n&&o>1?o-1:o],c=a[0]/l[0],u=a[1]/l[1],h=1/c,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${u});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${a[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${a[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${i}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}class C2{constructor(t,e,n,r){this.variableNames=["A"],this.outputShape=[];const[i,s,o,a]=t;this.outputShape=[i,e,n,a];const l=[r&&e>1?s-1:s,r&&n>1?o-1:o],c=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${s}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r?"0.5":"0.0"})));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class T2{constructor(t,e){this.variableNames=["x"];const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const r=t.map((n,r)=>(n=>-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - coords[${n}] - 1`:`coords[${n}]`)(r)).join(","),i=r1(n);this.userCode=`\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class A2{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;const r=U0("rc",n),i=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,o=r1(n);function a(n){const r=t.map((r,i)=>function(n,r){return-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - ${r[n]} - 1`:`${r[n]}`}(i,n));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${i}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${o} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(t){return a(t)}(r.slice())};\n          if(${i}){\n            result.g = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",a(t)}(r.slice())};\n          }\n          if(${s}) {\n            result.b = ${function(t){return t[n-2]="("+t[n-2]+" + 1)",a(t)}(r.slice())};\n            if(${i}) {\n              result.a = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",t[n-2]="("+t[n-2]+" + 1)",a(t)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}class M2{constructor(t,e,n,r,i,s,o=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const a=r1(i.length),l=r1(s.length);let c="";1===n?c="i":2===n&&(c="i, j");let u="";1===r?u="i":2===r&&(u="i, coords[1]"),this.userCode=`\n        ${a} strides = ${a}(${i});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${c}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${u});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}class k2{constructor(t,e){this.variableNames=["x","segmentIds"];const n=t.windowSize,r=t.batchSize,i=t.inSize,s=t.numSegments,o=s*Math.ceil(i/n);this.outputShape=[r,o];const a=4*Math.floor(n/4),l=n%4,c="\n        sumValue += dot(values, segFilter);\n    ";let u="";i%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `);let h="";i%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${c}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${c}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `}}class R2{constructor(t,e,n){let r,i;if(this.variableNames=["c","a","b"],this.outputShape=e,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)i="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],o=[];for(let r=0;r<e.length;r++)o.push(`${n[r]}`),r<t&&s.push(`${n[r]}`);r=s.join(),i=o.join()}const s=r1(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${i}));\n        } else {\n          setOutput(getB(${i}));\n        }\n      }\n    `}}class I2{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=r1(this.rank),n=`uniform int start[${this.rank}];`,r=function(t){if(1===t)return"sourceLoc";if(t<=6)return N2.slice(0,t).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}(this.rank);let i;i=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((t,e)=>`sourceLoc.${N2[e]} = start[${e}] + coords.${N2[e]};`).join("\n")}\n      `,this.userCode=`\n      ${n}\n      void main() {\n        ${i}\n        setOutput(getSource(${r}));\n      }\n    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,n)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,t)}}}const N2=["x","y","z","w","u","v"];class O2{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length;const e=r1(this.rank),n=U0("coords",this.rank),r=U0("sourceLoc",this.rank),i=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${i})`,o=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${s};\n        --${r[this.rank-1]};\n      }\n    `,a=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((t,e)=>`start[${e}]`).join()});`:t.map((t,e)=>`${r[e]} = ${n[e]} + start[${e}];`).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${o}\n        ${a}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,n)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,t)}}}class D2{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,i=r1(n.length),s=r1(n.length);let o="";if(1===r)o="coords * strides + begin";else{let t=0;o=n.map((e,r)=>(t++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${t-1}] * strides[${r}] + begin[${r}]`)).join(",")}this.userCode=`\n      ${i} begin = ${i}(${t});\n      ${i} strides = ${i}(${e});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}class L2{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,n){const r=P2(e,n),i=$2(t,r,n);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const s=F2(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();const t=this.freeTextures[i].shift();return this.usedTextures[i].push(t),t}let o;return r===d0.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===d0.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===d0.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===d0.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===d0.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[i].push(o),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),o}releaseTexture(t,e,n,r){if(null==this.freeTextures)return;const i=P2(n,r),s=$2(e,i,r);s in this.freeTextures||(this.freeTextures[s]=[]);const o=F2(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),a=BD().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==a&&this._numBytesAllocated>a?(this.gpgpu.deleteMatrixTexture(t),this._numBytesAllocated-=o):(this.freeTextures[s].push(t),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const l=this.usedTextures[s],c=l.indexOf(t);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(c,1),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});for(const t in this.usedTextures)this.usedTextures[t].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function F2(t,e,n,r,i){const s=function(t,e){switch(t){case d0.PACKED_2X2_FLOAT32:return e2(e);case d0.PACKED_2X2_FLOAT16:return n2(e);case d0.UNPACKED_FLOAT32:return J1(e);case d0.UNPACKED_FLOAT16:return Q1(e);case d0.PACKED_4X1_UNSIGNED_BYTE:return t2(e);default:throw new Error(`Unknown physical texture type ${t}`)}}(e,r);let o;if(i){const[e,n]=m0(t[0],t[1]);o=e*n}else{const[e,n]=p0(t[0],t[1]);o=e*n}return o*function(t,e){if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===t.RGBA16F)return 8;throw new Error(`Unknown internal format ${e}`)}(n,s)}function P2(t,e){if(t===h0.UPLOAD)return d0.PACKED_2X2_FLOAT32;if(t===h0.RENDER||null==t)return function(t){return BD().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?d0.PACKED_2X2_FLOAT32:d0.UNPACKED_FLOAT32:t?d0.PACKED_2X2_FLOAT16:d0.UNPACKED_FLOAT16}(e);if(t===h0.DOWNLOAD||t===h0.PIXELS)return d0.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function $2(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}class B2{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let s=0;s<n.length;s++)n[s]=t[s]*e[s];this.outputShape=n,this.rank=n.length;const r=r1(this.rank),i=function(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let i=0;i<t.length;i++)r.push(`imod(${n[i]}, ${t[i]})`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${i}));\n      }\n    `}}class z2{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const V2="return abs(x);",U2="if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",H2="if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",W2="return (x >= 0.0) ? x : (exp(x) - 1.0);",j2=`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${p.SELU_SCALEALPHA};\n  float scale = ${p.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`,G2="return -x;",q2="return ceil(x);",X2="return floor(x);",K2="return exp(x);",Y2="return exp(x) - 1.0;",Z2=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${p.ERF_P};\n  float a1 = ${p.ERF_A1};\n  float a2 = ${p.ERF_A2};\n  float a3 = ${p.ERF_A3};\n  float a4 = ${p.ERF_A4};\n  float a5 = ${p.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`,J2="return x;",Q2="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",t3="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",e3="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n";class n3{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class r3{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t;const e=t.length,n=U0("rc",e),r=r1(e),i=function(t,e){if(1===t)return"rc";let n="";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}(e,n),s=n.slice(-2),o=e<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${i});\n\n        setOutput(getChannel(packedInput, ${o}));\n      }\n    `}}const{segment_util:i3}=p,s3=f.split,o3=f.tile,a3=f.topkImpl,l3=f.whereImpl,c3={};function u3(t,e=!1){if("linear"===t)return"return x;";if("relu"===t)return e?Q2:U2;if("elu"===t)return e?e3:W2;if("relu6"===t)return e?t3:H2;if("prelu"===t)return e?y1:m1;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}class h3 extends gG{constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.warnedAboutMemory=!1,this.warnedAboutCPUBackend=!1,this.pendingDeletes=0,this.disposed=!1,!BD().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==t){const t=c0(BD().getNumber("WEBGL_VERSION"));this.binaryCache=((e=BD().getNumber("WEBGL_VERSION"))in c3||(c3[e]={}),c3[e]),this.gpgpu=new r2(t),this.canvas=t.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=t,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=t.gl.canvas;var e;this.textureManager=new L2(this.gpgpu),this.numMBBeforeWarning=null==BD().global.screen?1024:BD().global.screen.height*BD().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new mG(this,iB())}numDataIds(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes}write(t,e,n){if((BD().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||BD().getBool("DEBUG"))&&this.checkNumericalProblems(t),"complex64"===n&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={};return this.texData.set(r,{shape:e,dtype:n,values:t,usage:h0.UPLOAD}),r}move(t,e,n,r){if(BD().getBool("DEBUG")&&this.checkNumericalProblems(e),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:r,values:e,usage:h0.UPLOAD})}readSync(t){const e=this.texData.get(t),{values:n,dtype:i,complexTensors:s,slice:o,shape:a,isPacked:l}=e;if(null!=o){let e;e=l?new n3(a,J2):new z2(a,J2);const n=this.runWebGLProgram(e,[{dataId:t,shape:a,dtype:i}],i),r=this.readSync(n.dataId);return this.disposeData(n.dataId),r}if(null!=n)return this.convertAndCacheOnCPU(t);if("string"===i)return n;const c=null!=this.activeTimers;let u,h;if(c&&(u=r.now()),"complex64"===i){const t=s.real.dataSync(),e=s.imag.dataSync();h=p.mergeRealAndImagArrays(t,e)}else h=this.getValuesFromTexture(t);return c&&(this.downloadWaitMs+=r.now()-u),this.convertAndCacheOnCPU(t,h)}async read(t){if(this.pendingRead.has(t)){const e=this.pendingRead.get(t);return new Promise(t=>e.push(t))}const e=this.texData.get(t),{values:n,shape:i,slice:s,dtype:o,complexTensors:a,isPacked:l}=e;if(null!=s){let e;e=l?new n3(i,J2):new z2(i,J2);const n=this.runWebGLProgram(e,[{dataId:t,shape:i,dtype:o}],o),r=this.read(n.dataId);return this.disposeData(n.dataId),r}if(null!=n)return this.convertAndCacheOnCPU(t);if(!BD().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===BD().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c,u,h=null;if("complex64"!==o&&BD().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(t);const e=this.texData.get(c.dataId);h=this.gpgpu.createBufferFromTexture(e.texture,...f0(i))}if(this.pendingRead.set(t,[]),"complex64"!==o&&await this.gpgpu.createAndWaitForFence(),"complex64"===o){const t=await Promise.all([a.real.data(),a.imag.data()]);u=p.mergeRealAndImagArrays(t[0],t[1])}else if(null==h)u=this.getValuesFromTexture(t);else{const t=r.sizeFromShape(i);u=this.gpgpu.downloadFloat32MatrixFromBuffer(h,t)}null!=c&&this.disposeData(c.dataId);const d=this.convertAndCacheOnCPU(t,u),f=this.pendingRead.get(t);return this.pendingRead.delete(t),f.forEach(t=>t(d)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t),this.pendingDeletes--),d}checkNumericalProblems(t){if(null!=t)for(let e=0;e<t.length;e++){const n=t[e];if(!v0(n)){if(BD().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(t){const{shape:e,dtype:n,isPacked:i}=this.texData.get(t),s=r.sizeFromShape(e);if(BD().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(t),r=this.texData.get(n.dataId),i=this.gpgpu.downloadMatrixFromPackedTexture(r.texture,...f0(e)).subarray(0,s);return this.disposeData(n.dataId),i}const o=BD().getBool("WEBGL_PACK")&&!0===i,a=o?k0(e):e,l=o?new W1(a):new H1(a),c=this.runWebGLProgram(l,[{shape:a,dtype:n,dataId:t}],"float32"),u=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture,u.texShape[0],u.texShape[1]).subarray(0,s);return this.disposeData(c.dataId),h}async time(t){const e=this.activeTimers,n=[];let i=!1;null==this.programTimersStack?(this.programTimersStack=n,i=!0):this.activeTimers.push(n),this.activeTimers=n,t();const s=r.flatten(this.activeTimers.map(t=>t.query)).filter(t=>null!=t),o=r.flatten(this.activeTimers.map(t=>t.name)).filter(t=>null!=t);this.activeTimers=e,i&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(BD().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const t=await Promise.all(s);a.kernelMs=r.sum(t),a.getExtraProfileInfo=()=>t.map((t,e)=>({name:o[e],ms:t})).map(t=>`${t.name}: ${t.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return BD().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:r.now(),endMs:null}}endTimer(t){return BD().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=r.now(),t)}async getQueryTime(t){return BD().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.waitForQueryAndGetTime(t):t.endMs-t.startMs}disposeData(t){if(this.pendingDisposal.has(t))return;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),void this.pendingDeletes++;if(!this.texData.has(t))return;this.releaseGPUData(t);const{complexTensors:e}=this.texData.get(t);null!=e&&(e.real.dispose(),e.imag.dispose()),this.texData.delete(t)}releaseGPUData(t){const{texture:e,dtype:n,texShape:r,usage:i,isPacked:s,slice:o}=this.texData.get(t),a=o&&o.origDataId||t,l=this.dataRefCount.get(a);l>1?this.dataRefCount.set(a,l-1):(this.dataRefCount.delete(a),null!=e&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(e,r,i,s)));const c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture}getDataInfo(t){return this.texData.get(t)}getCPUBackend(){return BD().getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=iB().findBackend("cpu")),this.cpuBackend):null}shouldExecuteOnCPU(t,e=128){const n=this.getCPUBackend();return this.warnedAboutCPUBackend||null!=n||BD().getBool("IS_TEST")||(console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."),this.warnedAboutCPUBackend=!0),null!=n&&t.every(t=>null==this.texData.get(t.dataId).texture&&r.sizeFromShape(t.shape)<e)}getGPGPUContext(){return this.gpgpu}complex(t,e){const n=this.makeOutput(t.shape,"complex64");return this.texData.get(n.dataId).complexTensors={real:iB().keep(t.clone()),imag:iB().keep(e.clone())},n}real(t){return this.texData.get(t.dataId).complexTensors.real.clone()}imag(t){return this.texData.get(t.dataId).complexTensors.imag.clone()}slice(t,e,n){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.slice(t,e,n);if(0===r.sizeFromShape(n))return fB([],n,t.dtype);const{isPacked:i}=this.texData.get(t.dataId),s=o.isSliceContinous(t.shape,e,n);if(i||!s){const r=BD().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new O2(n):new I2(n),i=r.getCustomSetupFunc(e);return this.compileAndRun(r,[t],null,i)}return this.uploadToGPU(t.dataId),this.shallowSlice(t,e,n)}shallowSlice(t,e,n){const r=this.texData.get(t.dataId),i=this.makeOutput(n,t.dtype),s=this.texData.get(i.dataId);Object.assign(s,r),s.shape=n,s.dtype=t.dtype;let a=o.computeFlatOffset(e,t.strides);r.slice&&(a+=r.slice.flatOffset),s.slice={flatOffset:a,origDataId:r.slice&&r.slice.origDataId||t.dataId};const l=this.dataRefCount.get(s.slice.origDataId)||1;return this.dataRefCount.set(s.slice.origDataId,l+1),i}stridedSlice(t,e,n,r){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.stridedSlice(t,e,n,r);const i=o.computeOutShape(e,n,r);if(i.some(t=>0===t))return fB([],i);const s=new D2(e,r,i);return this.compileAndRun(s,[t])}reverse(t,e){const n=BD().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new A2(t.shape,e):new T2(t.shape,e);return this.compileAndRun(n,[t])}concat(t,e){if("complex64"===t[0].dtype){const n=t.map(t=>Uz(t)),r=t.map(t=>Vz(t));return qB(this.concat(n,e),this.concat(r,e))}if(this.shouldExecuteOnCPU(t))return this.cpuBackend.concat(t,e);if(1===t.length)return t[0];if(t.length>BD().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const n=Math.floor(t.length/2),r=this.concat(t.slice(0,n),e),i=this.concat(t.slice(n),e);return this.concat([r,i],e)}if(BD().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&t[0].rank>1){const n=new S1(t.map(t=>t.shape),e);return this.compileAndRun(n,t)}const n=p.computeOutShape(t.map(t=>t.shape),e),i=t.map(t=>t.as2D(-1,r.sizeFromShape(t.shape.slice(e)))),s=new w1(i.map(t=>t.shape));return this.compileAndRun(s,i).reshape(n)}neg(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.neg(t);if(BD().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,G2,t.dtype);const e=new z2(t.shape,G2);return this.compileAndRun(e,[t])}batchMatMul(t,e,n,r){const i=n?t.shape[2]:t.shape[1],s=r?e.shape[1]:e.shape[2],o=n?t.shape[1]:t.shape[2],[a,,]=t.shape;if((1===i||1===s)&&o>1e3){n&&(t=N$(t,[0,2,1])),r&&(e=N$(e,[0,2,1]));const i=1===s?t:t.as3D(a,o,1),l=1===s?2:1,c=1===s?e.as3D(a,1,o):e;return this.multiply(i,c).sum(l,!0)}const l=ZP(t.dtype,e.dtype),c=new h2(t.shape,[a,i,s],n,r);return this.compileAndRun(c,[t,e],l)}fusedBatchMatMul({a:t,b:e,transposeA:n,transposeB:r,bias:i,activation:s,preluActivationWeights:o}){const a=n?t.shape[2]:t.shape[1],l=r?e.shape[1]:e.shape[2],[c,,]=t.shape,u=ZP(t.dtype,e.dtype),h=null!=i,d=null!=o,p=s?u3(s,!0):null,f=new h2(t.shape,[c,a,l],n,r,h,p,d),m=[t,e];return i&&m.push(i),o&&m.push(o),this.compileAndRun(f,m,u)}multiply(t,e){if("complex64"===t.dtype){const n=this.texData.get(t.dataId),r=this.texData.get(e.dataId),i=new h1("return areal * breal - aimag * bimag;",t.shape,e.shape),s=new h1("return areal * bimag + aimag * breal;",t.shape,e.shape),o=[this.makeComplexComponentTensorInfo(t,n.complexTensors.real),this.makeComplexComponentTensorInfo(t,n.complexTensors.imag),this.makeComplexComponentTensorInfo(e,r.complexTensors.real),this.makeComplexComponentTensorInfo(e,r.complexTensors.imag)],a=this.compileAndRun(i,o),l=this.compileAndRun(s,o),c=this.complex(a,l);return a.dispose(),l.dispose(),c}if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.multiply(t,e);if(BD().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,f1,t.dtype);const n=new g1(f1,t.shape,e.shape);return this.compileAndRun(n,[t,e],t.dtype)}batchNorm(t,e,n,r,i,s){const o=[t,e,n];let a=null;null!=r&&(a=r.shape,o.push(r));let l=null;if(null!=i&&(l=i.shape,o.push(i)),BD().getBool("WEBGL_PACK_NORMALIZATION")){const r=new u1(t.shape,e.shape,n.shape,a,l,s);return this.compileAndRun(r,o)}const c=new c1(t.shape,e.shape,n.shape,a,l,s);return this.compileAndRun(c,o)}localResponseNormalization4D(t,e,n,r,i){const s=BD().getBool("WEBGL_PACK_NORMALIZATION")?new l2(t.shape,e,n,r,i):new o2(t.shape,e,n,r,i);return this.compileAndRun(s,[t])}LRNGrad(t,e,n,r,i,s,o){const a=new a2(e.shape,r,i,s,o);return this.compileAndRun(a,[e,n,t])}tile(t,e){if("string"===t.dtype){const n=this.readSync(t.dataId).map(t=>r.decodeString(t)),i=WB(t.shape,t.dtype,n);return o3(i,e)}const n=new B2(t.shape,e);return this.compileAndRun(n,[t])}pad(t,e,n){const r=BD().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new g2(t.shape,e,n):new m2(t.shape,e,n);return this.compileAndRun(r,[t])}gather(t,e,n){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.gather(t,e,n);const r=new K1(t.shape,e.size,n);return this.compileAndRun(r,[t,e])}batchToSpaceND(t,e,n){r.assert(t.rank<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const i=e.reduce((t,e)=>t*e),s=p.getReshaped(t.shape,e,i),o=p.getPermuted(s.length,e.length),a=p.getReshapedPermuted(t.shape,e,i),l=p.getSliceBeginCoords(n,e.length),c=p.getSliceSize(a,n,e.length);return N$(t.reshape(s),o).reshape(a).slice(l,c)}spaceToBatchND(t,e,n){r.assert(t.rank<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const i=e.reduce((t,e)=>t*e),s=[[0,0]];s.push(...n);for(let r=1+e.length;r<t.shape.length;++r)s.push([0,0]);const o=t.pad(s),a=p.getReshaped(o.shape,e,i,!1),l=p.getPermuted(a.length,e.length,!1),c=p.getReshapedPermuted(o.shape,e,i,!1),u=N$(o.reshape(a),l);return I$(u,c)}reduce(t,e,n){const r=t.shape[0],i=t.shape[1],s=p.computeOptimalWindowSize(i),o=new b2({windowSize:s,inSize:i,batchSize:r},e),a=this.compileAndRun(o,[t],n);return 1===a.shape[1]?a:this.reduce(a,e,n)}argReduce(t,e,n=null){let r=t.shape[0],i=t.shape[1];null!=n&&(r=n.shape[0],i=n.shape[1]);const s=p.computeOptimalWindowSize(i),o=new z0({windowSize:s,inSize:i,batchSize:r},e,null==n),a=[t];null!=n&&a.push(n);const l=this.compileAndRun(o,a,"int32");return 1===l.shape[1]?l:this.argReduce(t,e,l)}argReducePacked(t,e,n=null){const r=null!=n?n.shape:t.shape,i=p.computeOptimalWindowSize(r[r.length-1]),s=new o1(r,i,e,null==n),o=this.compileAndRun(s,null==n?[t]:[t,n],"int32");return o.rank===t.rank?this.argReducePacked(t,e,o):o}sum(t,e){p.assertAxesAreInnerMostDims("sum",e,t.rank);const[n,i]=p.computeOutAndReduceShapes(t.shape,e),s=r.sizeFromShape(i),o=t.as2D(-1,s),a=JP(t.dtype);return this.reduce(o,"sum",a).reshape(n)}prod(t,e){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.prod(t,e);const[n,i]=p.computeOutAndReduceShapes(t.shape,e),s=r.sizeFromShape(i),o=t.as2D(-1,s),a=JP(t.dtype);return this.reduce(o,"prod",a).reshape(n)}unsortedSegmentSum(t,e,n){let i=0;const s=p.getAxesPermutation([i],t.rank);let o=t;null!=s&&(o=N$(t,s),i=p.getInnerMostAxes(1,t.rank)[0]);const a=i3.computeOutShape(o.shape,i,n),l=r.sizeFromShape([o.shape[i]]),c=o.as2D(-1,l),u=JP(t.dtype);let h=this.segOpCompute(c,"unsortedSegmentSum",e,u,n).reshape(a);return null!=s&&(h=N$(h,p.getUndoAxesPermutation(s))),h}segOpCompute(t,e,n,r,i){const s=t.shape[0],o=t.shape[1],a=i3.segOpComputeOptimalWindowSize(o,i),l=new k2({windowSize:a,inSize:o,batchSize:s,numSegments:i},e),c=this.compileAndRun(l,[t,n],r);return c.shape[1]===i?c:(n=QV(0,i).tile([o/a]),this.segOpCompute(c,e,n,r,i))}argMinMaxReduce(t,e,n){const i=[e];if(p.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),i,t.rank),!BD().getBool("WEBGL_PACK_REDUCE")||t.rank<=2){const[e,s]=p.computeOutAndReduceShapes(t.shape,i),o=r.sizeFromShape(s),a=t.as2D(-1,o);return this.argReduce(a,n).reshape(e)}return this.argReducePacked(t,n)}argMin(t,e){return this.argMinMaxReduce(t,e,"min")}argMax(t,e){return this.argMinMaxReduce(t,e,"max")}cumsum(t,e,n,r){if(e!==t.rank-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${t.rank-1} but got axis=${e}`);const i=t.shape[e];let s=t;for(let o=0;o<=Math.ceil(Math.log2(i))-1;o++){const e=new F1(t.shape,!1,r),n=e.getCustomSetupFunc(o),i=s;s=this.compileAndRun(e,[s],s.dtype,n),i.dispose()}if(n){const e=new F1(t.shape,n,r),i=s;s=this.compileAndRun(e,[s]),i.dispose()}return s}equal(t,e){if(BD().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(equal(a, b));\n","bool");const n=new g1("return float(a == b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}notEqual(t,e){if(BD().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(notEqual(a, b));\n","bool");const n=new g1("return float(a != b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}less(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.less(t,e);if(BD().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(lessThan(a, b));\n","bool");const n=new g1("return float(a < b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}lessEqual(t,e){if(BD().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(lessThanEqual(a, b));\n","bool");const n=new g1("return float(a <= b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}greater(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.greater(t,e);if(BD().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(greaterThan(a, b));\n","bool");const n=new g1("return float(a > b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}greaterEqual(t,e){if(BD().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(greaterThanEqual(a, b));\n","bool");const n=new g1("return float(a >= b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}logicalNot(t){const e=new z2(t.shape,"return float(!(x >= 1.0));");return this.compileAndRun(e,[t])}logicalAnd(t,e){if(BD().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n","bool");const n=new g1("return float(a >= 1.0 && b >= 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}logicalOr(t,e){if(BD().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n","bool");const n=new g1("return float(a >= 1.0 || b >= 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}select(t,e,n){const r=new R2(t.rank,e.shape,e.rank);return this.compileAndRun(r,[t,e,n],ZP(e.dtype,n.dtype))}where(t){p.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return l3(t.shape,e)}topk(t,e,n){const r=t.dataSync();return a3(r,t.shape,t.dtype,e,n)}min(t,e){p.assertAxesAreInnerMostDims("min",e,t.rank);const[n,i]=p.computeOutAndReduceShapes(t.shape,e),s=r.sizeFromShape(i),o=t.as2D(-1,s);return this.reduce(o,"min",o.dtype).reshape(n)}minimum(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.minimum(t,e);const n=BD().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new v1("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new g1("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])}mod(t,e){const n=BD().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new v1("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new g1("if (b == 0.0) return NAN;\n  return mod(a, b);",t.shape,e.shape);return this.compileAndRun(n,[t,e])}maximum(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.maximum(t,e);const n=BD().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new v1("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new g1("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])}all(t,e){p.assertAxesAreInnerMostDims("all",e,t.rank);const[n,i]=p.computeOutAndReduceShapes(t.shape,e),s=r.sizeFromShape(i),o=t.as2D(-1,s);return this.reduce(o,"all",o.dtype).reshape(n)}any(t,e){p.assertAxesAreInnerMostDims("any",e,t.rank);const[n,i]=p.computeOutAndReduceShapes(t.shape,e),s=r.sizeFromShape(i),o=t.as2D(-1,s);return this.reduce(o,"any",o.dtype).reshape(n)}floorDiv(t,e){const n="int32";if(BD().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",n);const r=new g1("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",t.shape,e.shape);return this.compileAndRun(r,[t,e],n)}add(t,e){if("complex64"===t.dtype&&"complex64"===e.dtype)return this.complexSeparableBinaryOp(t,e,d1);if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.add(t,e);const n=ZP(t.dtype,e.dtype);if(BD().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,d1,n);const r=new g1(d1,t.shape,e.shape);return this.compileAndRun(r,[t,e],n)}packedUnaryOp(t,e,n){const r=new n3(t.shape,e);return this.compileAndRun(r,[t],n)}packedBinaryOp(t,e,n,r,i=!1){const s=new v1(n,t.shape,e.shape,i);return this.compileAndRun(s,[t,e],r)}complexSeparableBinaryOp(t,e,n){const r=this.texData.get(t.dataId),i=this.texData.get(e.dataId),[s,o]=[[r.complexTensors.real,i.complexTensors.real],[r.complexTensors.imag,i.complexTensors.imag]].map(r=>{const[i,s]=r,o=this.makeComplexComponentTensorInfo(t,i),a=this.makeComplexComponentTensorInfo(e,s),l=new g1(n,t.shape,e.shape);return this.compileAndRun(l,[o,a],ZP(i.dtype,s.dtype))}),a=this.complex(s,o);return s.dispose(),o.dispose(),a}makeComplexComponentTensorInfo(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}addN(t){if(1===t.length)return t[0];if(t.length>BD().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const e=Math.floor(t.length/2),n=this.addN(t.slice(0,e)),r=this.addN(t.slice(e));return this.addN([n,r])}const e=t.map(t=>t.dtype).reduce((t,e)=>ZP(t,e)),n=t.map(t=>t.shape),r=BD().getBool("WEBGL_PACK")?new B0(t[0].shape,n):new $0(t[0].shape,n);return this.compileAndRun(r,t,e)}subtract(t,e){if("complex64"===t.dtype&&"complex64"===e.dtype)return this.complexSeparableBinaryOp(t,e,p1);if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.subtract(t,e);const n=ZP(t.dtype,e.dtype);if(BD().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,p1,t.dtype);const r=new g1(p1,t.shape,e.shape);return this.compileAndRun(r,[t,e],n)}pow(t,e){const n=BD().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new v1("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new g1("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",t.shape,e.shape),r=ZP(t.dtype,e.dtype);return this.compileAndRun(n,[t,e],r)}ceil(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.ceil(t);if(BD().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,q2,t.dtype);const e=new z2(t.shape,q2);return this.compileAndRun(e,[t])}floor(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.floor(t);if(BD().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,X2,t.dtype);const e=new z2(t.shape,X2);return this.compileAndRun(e,[t])}sign(t){const e=new z2(t.shape,"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");return this.compileAndRun(e,[t])}isNaN(t){const e=new z2(t.shape,"return float(isnan(x));");return this.compileAndRun(e,[t],"bool")}isInf(t){const e=new z2(t.shape,"return float(isinf(x));");return this.compileAndRun(e,[t],"bool")}isFinite(t){const e=new z2(t.shape,"return float(!isnan(x) && !isinf(x));");return this.compileAndRun(e,[t],"bool")}round(t){const e=new z2(t.shape,"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");return this.compileAndRun(e,[t])}exp(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.exp(t);if(BD().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,K2,t.dtype);const e=new z2(t.shape,K2);return this.compileAndRun(e,[t])}expm1(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.expm1(t);if(BD().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,Y2,t.dtype);const e=new z2(t.shape,Y2);return this.compileAndRun(e,[t])}softmax(t,e){const n=r.parseAxisParam([e],t.shape),i=aV(t,n),s=p.expandShapeToKeepDim(i.shape,n),o=this.subtract(t,i.reshape(s)),a=this.exp(o),l=this.sum(a,n).reshape(s);return pz(a,l)}log(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.log(t);if(BD().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",t.dtype);const e=new z2(t.shape,"if (x < 0.0) return NAN;\n  return log(x);");return this.compileAndRun(e,[t])}log1p(t){const e=new z2(t.shape,"return log(1.0 + x);");return this.compileAndRun(e,[t])}sqrt(t){const e=new z2(t.shape,"return sqrt(x);");return this.compileAndRun(e,[t])}rsqrt(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.rsqrt(t);const e=new z2(t.shape,"return inversesqrt(x);");return this.compileAndRun(e,[t])}reciprocal(t){const e=new z2(t.shape,"return 1.0 / x;");return this.compileAndRun(e,[t])}relu(t){let e;return e=BD().getBool("WEBGL_PACK")?new n3(t.shape,Q2):new z2(t.shape,U2),this.compileAndRun(e,[t])}relu6(t){let e;return e=BD().getBool("WEBGL_PACK")?new n3(t.shape,t3):new z2(t.shape,H2),this.compileAndRun(e,[t])}prelu(t,e){const n=BD().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new v1(y1,t.shape,e.shape):new g1(m1,t.shape,e.shape);return this.compileAndRun(n,[t,e])}elu(t){if(BD().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,e3,t.dtype);const e=new z2(t.shape,W2);return this.compileAndRun(e,[t])}eluDer(t,e){const n=BD().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new v1("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",t.shape,e.shape):new g1("return (b >= 1.0) ? a : a * (b + 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e])}selu(t){const e=new z2(t.shape,j2);return this.compileAndRun(e,[t])}int(t){const e=new z2(t.shape,"return float(int(x));");return this.compileAndRun(e,[t],"int32")}clip(t,e,n){let r;r=BD().getBool("WEBGL_PACK_CLIP")?new _1(t.shape):new b1(t.shape);const i=r.getCustomSetupFunc(e,n);return this.compileAndRun(r,[t],null,i)}abs(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.abs(t);if(BD().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,V2,t.dtype);const e=new z2(t.shape,V2);return this.compileAndRun(e,[t])}complexAbs(t){const e=this.texData.get(t.dataId),n=new x1(t.shape),r=[this.makeComplexComponentTensorInfo(t,e.complexTensors.real),this.makeComplexComponentTensorInfo(t,e.complexTensors.imag)];return this.compileAndRun(n,r)}sigmoid(t){const e=new z2(t.shape,"return 1.0 / (1.0 + exp(-1.0 * x));");return this.compileAndRun(e,[t])}softplus(t){const e=new z2(t.shape,"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");return this.compileAndRun(e,[t])}sin(t){const e=new z2(t.shape,"if (isnan(x)) return x;\n  return sin(x);\n");return this.compileAndRun(e,[t])}cos(t){const e=new z2(t.shape,"if (isnan(x)) return x;\n  return cos(x);\n");return this.compileAndRun(e,[t])}tan(t){const e=new z2(t.shape,"return tan(x);");return this.compileAndRun(e,[t])}asin(t){const e=new z2(t.shape,"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n");return this.compileAndRun(e,[t])}acos(t){const e=new z2(t.shape,"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n");return this.compileAndRun(e,[t])}atan(t){const e=new z2(t.shape,"if (isnan(x)) return x;\n  return atan(x);\n");return this.compileAndRun(e,[t])}atan2(t,e){const n=BD().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new v1("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new g1("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])}sinh(t){const e=new z2(t.shape,"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");return this.compileAndRun(e,[t])}cosh(t){const e=new z2(t.shape,"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");return this.compileAndRun(e,[t])}tanh(t){const e=new z2(t.shape,"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");return this.compileAndRun(e,[t])}asinh(t){const e=new z2(t.shape,"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));");return this.compileAndRun(e,[t])}acosh(t){const e=new z2(t.shape,"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));");return this.compileAndRun(e,[t])}atanh(t){const e=new z2(t.shape,"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;");return this.compileAndRun(e,[t])}erf(t){const e=new z2(t.shape,Z2);return this.compileAndRun(e,[t])}step(t,e){const n=new z2(t.shape,function(t=0){return`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t});\n  `}(e));return this.compileAndRun(n,[t])}conv2dByMatMul(t,e,n,i,s,o){const a=t.shape,l=this.texData.get(t.dataId),c="channelsLast"===n.dataFormat,u=a[2]%2!=0&&!!l.isPacked;if((1==a[0]*a[1]*a[2]||1===n.outChannels)&&n.inChannels>1e3||!BD().getBool("WEBGL_LAZILY_UNPACK")||!BD().getBool("WEBGL_PACK_BINARY_OPERATIONS")||!u){const r=this.reshape(t,[1,c?a[0]*a[1]*a[2]:a[0]*a[2]*a[3],n.inChannels]),l=this.reshape(e,[1,n.inChannels,n.outChannels]);return this.reshape(this.fusedBatchMatMul({a:r,b:l,transposeA:!1,transposeB:!1,bias:i,activation:s,preluActivationWeights:o}),n.outShape)}const h={dataId:t.dataId,shape:[1,c?a[0]*a[1]*(a[2]+1):a[0]*a[2]*(a[3]+1),n.inChannels],dtype:t.dtype},d=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,r.assert(I0(l.shape,h.shape),()=>`packed reshape ${l.shape} to ${h.shape} isn't free`);const p=this.reshape(e,[1,n.inChannels,n.outChannels]),f=this.fusedBatchMatMul({a:h,b:p,transposeA:!1,transposeB:!1,bias:i,activation:s,preluActivationWeights:o}),m=this.texData.get(f.dataId);return r.assert(m.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=d,m.shape=n.outShape,iB().makeTensorFromDataId(f.dataId,n.outShape,f.dtype)}conv2dWithIm2Row(t,e,n,r,i,s){const{filterWidth:o,filterHeight:a,inChannels:l,outWidth:c,outHeight:u,dataFormat:h}=n,d="channelsLast"===h,p=o*a*l,f=u*c,m=[p,f],g=t.squeeze([0]),y=e.reshape([1,p,-1]),v=new s2(m,g.shape,n),b=this.compileAndRun(v,[g]).reshape([1,m[0],m[1]]),_=null!=r,x=null!=s,w=i?u3(i,!0):null,S=new h2(b.shape,[1,f,n.outChannels],!0,!1,_,w,x),E=[b,y];return r&&E.push(r),x&&E.push(s),this.compileAndRun(S,E).reshape(d?[1,u,c,n.outChannels]:[1,n.outChannels,u,c])}fusedConv2d({input:t,filter:e,convInfo:n,bias:r,activation:i,preluActivationWeights:s}){if(1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type))return this.conv2dByMatMul(t,e,n,r,i,s);if(BD().getBool("WEBGL_CONV_IM2COL")&&1===t.shape[0])return this.conv2dWithIm2Row(t,e,n,r,i,s);const o=null!=r,a=null!=s,l=i?u3(i,!1):null,c=new I1(n,o,l,a),u=[t,e];return r&&u.push(r),s&&u.push(s),this.compileAndRun(c,u)}conv2d(t,e,n){if(1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type))return this.conv2dByMatMul(t,e,n);if(BD().getBool("WEBGL_CONV_IM2COL")&&1===t.shape[0])return this.conv2dWithIm2Row(t,e,n);const r=new I1(n);return this.compileAndRun(r,[t,e])}conv2dDerInput(t,e,n){const r=new T1(n);return this.compileAndRun(r,[t,e])}conv2dDerFilter(t,e,n){const r=new C1(n);return this.compileAndRun(r,[t,e])}fusedDepthwiseConv2D({input:t,filter:e,convInfo:n,bias:r,activation:i,preluActivationWeights:s}){const o=BD().getBool("WEBGL_PACK_DEPTHWISECONV")&&n.strideWidth<=2&&n.outChannels/n.inChannels==1,a=i?u3(i,o):null,l=[t,e],c=null!=r,u=null!=s;let h;return c&&l.push(r),u&&l.push(s),o?(h=new D1(n,c,a,u),this.compileAndRun(h,l)):(h=new O1(n,c,a,u),this.compileAndRun(h,l))}depthwiseConv2D(t,e,n){let r;return BD().getBool("WEBGL_PACK_DEPTHWISECONV")&&n.strideWidth<=2&&n.outChannels/n.inChannels==1?(r=new D1(n),this.compileAndRun(r,[t,e])):(r=new O1(n),this.compileAndRun(r,[t,e]))}depthwiseConv2DDerInput(t,e,n){const r=new R1(n);return this.compileAndRun(r,[t,e])}depthwiseConv2DDerFilter(t,e,n){const r=new k1(n);return this.compileAndRun(r,[t,e])}conv3d(t,e,n){const r=new N1(n);return this.compileAndRun(r,[t,e])}conv3dDerInput(t,e,n){const r=new M1(n);return this.compileAndRun(r,[t,e])}conv3dDerFilter(t,e,n){const r=new A1(n);return this.compileAndRun(r,[t,e])}maxPool(t,e){const n=new y2(e,"max",!1);return this.compileAndRun(n,[t])}avgPool(t,e){const n=new y2(e,"avg",!1);return this.compileAndRun(n,[t],"float32")}maxPoolBackprop(t,e,n,r){const i=new y2(r,"max",!0),s=this.compileAndRun(i,[e]),o=new c2(r),a=this.compileAndRun(o,[t,s],e.dtype);return s.dispose(),a}avgPoolBackprop(t,e,n){const r=new a1(n);return this.compileAndRun(r,[t],e.dtype)}cast(t,e){return p.castTensor(t,e,this)}unstack(t,e){const n=t.shape[e],r=new Array(t.rank-1);let i=0;for(let l=0;l<t.rank;l++)l!==e&&(r[i++]=t.shape[l]);const s=new Array(t.rank).fill(0),o=t.shape.slice();o[e]=1;const a=new Array(n);for(let l=0;l<a.length;l++)s[e]=l,a[l]=this.slice(t,s,o).reshape(r);return a}avgPool3d(t,e){const n=new v2(e,"avg",!1);return this.compileAndRun(n,[t],"float32")}avgPool3dBackprop(t,e,n){const r=new l1(n);return this.compileAndRun(r,[t],e.dtype)}maxPool3d(t,e){const n=new v2(e,"max",!1);return this.compileAndRun(n,[t],"float32")}maxPool3dBackprop(t,e,n,r){const i=new v2(r,"max",!0),s=this.compileAndRun(i,[e]),o=new u2(r),a=this.compileAndRun(o,[t,s],e.dtype);return s.dispose(),a}reshape(t,e){const n=this.texData.get(t.dataId);if(n.isPacked&&!I0(t.shape,e)&&(null===n.texture||!I0(n.shape,e))){const n=this.packedReshape(t,e);return iB().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}return p.reshapeTensor(t,e)}resizeBilinear(t,e,n,r){const i=BD().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new S2(t.shape,e,n,r):new w2(t.shape,e,n,r);return this.compileAndRun(i,[t],"float32")}resizeBilinearBackprop(t,e,n){const r=new x2(t,e,n);return this.compileAndRun(r,[t])}resizeNearestNeighbor(t,e,n,r){const i=new C2(t.shape,e,n,r);return this.compileAndRun(i,[t])}resizeNearestNeighborBackprop(t,e,n){const r=new E2(t,e,n);return this.compileAndRun(r,[t])}multinomial(t,e,n,r){const i=e?t:wU(t),s=new d2(i.shape[0],i.shape[1],n),o=s.getCustomSetupFunc(r);return this.compileAndRun(s,[i],"int32",o)}oneHot(t,e,n,r){const i=new p2(t.size,e,n,r);return this.compileAndRun(i,[t])}diag(t){const e=new U1(t.size);return this.compileAndRun(e,[t])}cropAndResize(t,e,n,r,i,s){const o=new L1(t.shape,e.shape,r,i,s);return this.compileAndRun(o,[t,e,n],"float32")}depthToSpace(t,e,n){r.assert(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`);const i=t.shape[0],s=("NHWC"===n?t.shape[1]:t.shape[2])*e,o=("NHWC"===n?t.shape[2]:t.shape[3])*e,a=("NHWC"===n?t.shape[3]:t.shape[1])/(e*e),l=new V1("NHWC"===n?[i,s,o,a]:[i,a,s,o],e,n);return this.compileAndRun(l,[t])}split(t,e,n){return s3(t,e,n)}scatterND(t,e,n){const{sliceRank:r,numUpdates:i,sliceSize:s,strides:o,outputSize:a}=p.calculateShapes(e,t,n),l=[a/s,s],c=t.reshape([i,r]),u=e.reshape([i,s]);if(0===a)return p.reshapeTensor(fB([]),n);const h=Wz(0),d=new M2(i,r,c.rank,u.rank,o,l);return this.compileAndRun(d,[u,c,h]).reshape(n)}sparseToDense(t,e,n,r){const{sliceRank:i,numUpdates:s,strides:o,outputSize:a}=p.calculateShapes(e,t,n),l=new M2(s,i,t.rank,e.rank,o,[a,1],!1);return this.compileAndRun(l,[e,t,r]).reshape(n)}fft(t){return this.fftImpl(t,!1)}ifft(t){return this.fftImpl(t,!0)}fftImpl(t,e){const n=this.texData.get(t.dataId),r=new q1("return real * expR - imag * expI;",t.shape,e),i=new q1("return real * expI + imag * expR;",t.shape,e),s=[this.makeComplexComponentTensorInfo(t,n.complexTensors.real),this.makeComplexComponentTensorInfo(t,n.complexTensors.imag)],o=this.compileAndRun(r,s),a=this.compileAndRun(i,s),l=this.complex(o,a).as2D(t.shape[0],t.shape[1]);return o.dispose(),a.dispose(),l}gatherND(t,e){const n=e.shape,r=n[n.length-1],[i,s,o,a]=p.prepareAndValidate(t,e),l=e.reshape([s,r]),c=t.reshape([t.size/o,o]),u=new Y1(r,a,[s,o]);return this.compileAndRun(u,[c,l]).reshape(i)}fill(t,e,n){if("string"===(n=n||r.inferDtype(e))){const i=r.getArrayFromDType(n,r.sizeFromShape(t));return i.fill(e),iB().makeTensor(i,t,n,this)}{const r=new X1(t,e),i=r.getCustomSetupFunc(e);return this.compileAndRun(r,[],n,i)}}onesLike(t){if("string"===t.dtype)throw new Error("onesLike is not supported under string dtype");return this.fill(t.shape,1,t.dtype)}zerosLike(t){return this.fill(t.shape,"string"===t.dtype?"":0,t.dtype)}linspace(t,e,n){return p.linspaceImpl(t,e,n)}makeTensorInfo(t,e){const n=this.write(null,t,e);return this.texData.get(n).usage=null,{dataId:n,shape:t,dtype:e}}makeOutput(t,e){const{dataId:n}=this.makeTensorInfo(t,e);return iB().makeTensorFromDataId(n,t,e,this)}unpackTensor(t){const e=new r3(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new f2(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const n=[A0(t.shape),...M0(t.shape)],r={dtype:t.dtype,shape:n,dataId:t.dataId},i=[A0(e),...M0(e)],s=new _2(i,n),o=this.runWebGLProgram(s,[r],t.dtype,null,!0);return{dataId:o.dataId,shape:e,dtype:o.dtype}}decode(t){const e=this.texData.get(t),{isPacked:n,shape:r,dtype:i}=e,s=k0(r);let o;return o=n?new z1(s):new B1(s),{dtype:i,shape:r,dataId:this.runWebGLProgram(o,[{shape:s,dtype:i,dataId:t}],i,null,!0).dataId}}runWebGLProgram(t,e,n,i,s=!1){const o=this.makeTensorInfo(t.outputShape,n),a=this.texData.get(o.dataId);if(t.packedOutput&&(a.isPacked=!0),t.outPackingScheme===u0.DENSE){const e=f0(t.outputShape);a.texShape=e.map(t=>2*t)}if(null!=t.outTexUsage&&(a.usage=t.outTexUsage),0===r.sizeFromShape(o.shape))return a.values=r.getTypedArrayFromDType(o.dtype,0),o;const l=[],c=e.map(e=>{if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(e.dataId);if(null==n.texture){if(!t.packedInputs&&r.sizeFromShape(e.shape)<=BD().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:n.values};t.packedInputs&&(n.isPacked=!0,n.shape=e.shape)}else if(!!n.isPacked!=!!t.packedInputs)e=n.isPacked?this.unpackTensor(e):this.packTensor(e),l.push(e),n=this.texData.get(e.dataId);else if(n.isPacked&&!I0(n.shape,e.shape)){const t=e,r=e.shape;e.shape=n.shape,e=this.packedReshape(e,r),l.push(e),n=this.texData.get(e.dataId),t.shape=r}return this.uploadToGPU(e.dataId),{shape:e.shape,texData:n,isUniform:!1}});this.uploadToGPU(o.dataId);const u={shape:o.shape,texData:a,isUniform:!1},h=function(t,e,n){let r="";e.concat(n).forEach(t=>{r+=`${t.shape}_${t.isUniform?"uniform":t.texData.texShape}_${null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0}`});let i=t.constructor.name;return i+="_"+r+"_"+t.userCode,i}(t,c,u),d=this.getAndSaveBinary(h,()=>function(t,e,n,r){const i=e.userCode,s=n.map((t,n)=>{const r={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(r.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[n],shapeInfo:r}}),o=s.map(t=>t.shapeInfo),a={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},l=X0(s,a,i,e.packedInputs),c=t.createProgram(l);let u=null;const h=t.getUniformLocation(c,"NAN",!1);1===BD().getNumber("WEBGL_VERSION")&&(u=t.getUniformLocation(c,"INFINITY",!1));const d={};for(let p=0;p<e.variableNames.length;p++){const n=e.variableNames[p],r=!1;d[n]=t.getUniformLocation(c,n,r),d[`offset${n}`]=t.getUniformLocation(c,`offset${n}`,r)}return{program:e,source:l,webGLProgram:c,uniformLocations:d,inShapeInfos:o,outShapeInfo:a,infLoc:u,nanLoc:h}}(this.gpgpu,t,c,u)),p=null!=this.activeTimers;let f;if(p&&(f=this.startTimer()),function(t,e,n,i,s){i2(e.inShapeInfos,n),i2([e.outShapeInfo],[i]);const o=i.texData.texture,a=i.texData.texShape;i.texData.isPacked?t.setOutputPackedMatrixTexture(o,a[0],a[1]):t.setOutputMatrixTexture(o,a[0],a[1]),t.setProgram(e.webGLProgram),1===BD().getNumber("WEBGL_VERSION")&&null!==e.infLoc&&t.gl.uniform1f(e.infLoc,1/0),null!==e.nanLoc&&t.gl.uniform1f(e.nanLoc,NaN),n.forEach((n,i)=>{const s=e.program.variableNames[i],o=e.uniformLocations[s],a=e.uniformLocations[`offset${s}`];if(null!=o)if(n.isUniform)if(r.sizeFromShape(n.shape)<2)t.gl.uniform1f(o,n.uniformValues[0]);else{let e=n.uniformValues;e instanceof Float32Array||(e=new Float32Array(e)),t.gl.uniform1fv(o,e)}else null!=n.texData.slice&&null!=a&&t.gl.uniform1i(a,n.texData.slice.flatOffset),t.setInputMatrixTexture(n.texData.texture,o,i)}),null!=s&&s(t,e.webGLProgram),t.executeProgram()}(this.gpgpu,d,c,u,i),l.forEach(t=>this.disposeData(t.dataId)),p&&(f=this.endTimer(f),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(f)})),!BD().getBool("WEBGL_LAZILY_UNPACK")&&a.isPacked&&!1===s){const t=this.unpackTensor(o);return this.disposeData(o.dataId),t}return o}compileAndRun(t,e,n,r,i=!1){const s=this.runWebGLProgram(t,e,n=n||e[0].dtype,r,i);return iB().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(BD().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=oB(()=>{if(!BD().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=BD().getBool("DEBUG");BD().set("DEBUG",!1);const e=this.abs(Wz(1e-8)).dataSync()[0];if(BD().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(t){const e=this.texData.get(t),{shape:n,dtype:i,values:s,texture:o,usage:a,isPacked:l}=e;if(null!=o)return;const c=null!=this.activeTimers;let u;c&&(u=r.now());let h=e.texShape;if(null==h&&(h=function(t,e=!1){let n=BD().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e&&(n*=2,1===(t=t.map((e,n)=>n>=t.length-2?r.nearestLargerEven(t[n]):t[n])).length&&(t=[2,t[0]])),2!==t.length){const e=r.squeezeShape(t);t=e.newShape}let i=r.sizeFromShape(t);if(t.length<=1&&i<=n)return[1,i];if(2===t.length&&t[0]<=n&&t[1]<=n)return t;if(3===t.length&&t[0]*t[1]<=n&&t[2]<=n)return[t[0]*t[1],t[2]];if(3===t.length&&t[0]<=n&&t[1]*t[2]<=n)return[t[0],t[1]*t[2]];if(4===t.length&&t[0]*t[1]*t[2]<=n&&t[3]<=n)return[t[0]*t[1]*t[2],t[3]];if(4===t.length&&t[0]<=n&&t[1]*t[2]*t[3]<=n)return[t[0],t[1]*t[2]*t[3]];if(e){const e=A0(t);let n=2,s=2;return t.length&&([n,s]=M0(t)),i=e*(n/2)*(s/2),r.sizeToSquarishShape(i).map(t=>2*t)}return r.sizeToSquarishShape(i)}(n,l),e.texShape=h),null!=s){const t=k0(n);let o,a=h[1],d=h[0];const p=s instanceof Uint8Array;l?([a,d]=m0(h[0],h[1]),o=new G1(t,[d,a],p)):o=new j1(t,[d,a],p);const f=this.makeTensorInfo([d,a],i);this.texData.get(f.dataId).usage=p?h0.PIXELS:h0.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),a,d,s);const m=this.runWebGLProgram(o,[f],i,null,!0),g=this.texData.get(m.dataId);e.texture=g.texture,e.texShape=g.texShape,e.isPacked=g.isPacked,e.usage=g.usage,this.disposeData(f.dataId),this.texData.delete(m.dataId),e.values=null,c&&(this.uploadWaitMs+=r.now()-u)}else{const t=this.acquireTexture(h,a,i,l);e.texture=t}}convertAndCacheOnCPU(t,e){const n=this.texData.get(t),{dtype:r}=n;return this.releaseGPUData(t),null!=e&&(n.values=function(t,e){if("float32"===e||"complex64"===e)return t;if("int32"===e||"bool"===e){const n="int32"===e?new Int32Array(t.length):new Uint8Array(t.length);for(let e=0;e<n.length;++e)n[e]=Math.round(t[e]);return n}throw new Error(`Unknown dtype ${e}`)}(e,r)),n.values}acquireTexture(t,e,n,r){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const t=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${t} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,r)}computeBytes(t,e){return t[0]*t[1]*r.bytesPerElement(e)}}s.isBrowser()&&cB("webgl",()=>new h3,2);const d3={kernelName:bL,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{a:n,b:r}=t;return function(t,e,n){let r=new g1("\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",t.shape,e.shape);return BD().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&(r=new v1("\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",t.shape,e.shape,!0)),n.runWebGLProgram(r,[t,e],"float32")}(n,r,e)}};class p3{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const f3={kernelName:xL,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,r=e,i=new p3(n.shape);return r.runWebGLProgram(i,[n],n.dtype)}};class m3{constructor(t){this.variableNames=["A"];const e=H0(),[n,r]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class g3{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=H0(),[n,r]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const y3={kernelName:SF,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:i}=e;const{numChannels:s}=r,o="undefined"!=typeof HTMLVideoElement&&i instanceof HTMLVideoElement,a="undefined"!=typeof HTMLImageElement&&i instanceof HTMLImageElement,[l,c]=o?[i.videoWidth,i.videoHeight]:[i.width,i.height],u=[c,l],h=[c,l,s];(a||o)&&(null==v3&&(v3=document.createElement("canvas").getContext("2d")),v3.canvas.width=l,v3.canvas.height=c,v3.drawImage(i,0,0,l,c),i=v3.canvas);const d=n.makeTensorInfo(u,"int32");n.texData.get(d.dataId).usage=h0.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),i);const p=BD().getBool("WEBGL_PACK")?new g3(h):new m3(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let v3;const{maxImpl:b3,transposeImpl:_3}=I;function x3(t,e,n,r){const[i,s]=t.shape,o=p.computeOptimalWindowSize(s),a=new b2({windowSize:o,inSize:s,batchSize:i},n),l=r.runWebGLProgram(a,[t],e);return 1===l.shape[1]?l:x3(l,e,n,r)}function w3(t,e,n){const r=n.texData.get(t.dataId);return!r.isPacked||I0(t.shape,e)||null!==r.texture&&I0(r.shape,e)?{dataId:t.dataId,shape:e,dtype:t.dtype}:function(t,e,n){const r=[A0(t.shape),...M0(t.shape)],i={dtype:t.dtype,shape:r,dataId:t.dataId},s=[A0(e),...M0(e)],o=new _2(s,r),a=n.runWebGLProgram(o,[i],t.dtype,null,!0);return{dataId:a.dataId,shape:e,dtype:a.dtype}}(t,e,n)}function S3(t,e,n,i){const s=r.sizeFromShape(e),o=w3(t,[r.sizeFromShape(t.shape)/s,s],i),a=x3(o,t.dtype,"max",i);return o.dataId!==t.dataId&&i.disposeData(o.dataId),w3(a,n,i)}class E3{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let s=0;s<n.length;s++)n[s]=t[e[s]];this.outputShape=n,this.rank=n.length;const r=r1(this.rank),i=function(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let i=0;i<t.length;i++)r[t[i]]=n[i];return r.join()}(e);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${i}));\n    }\n    `}}class C3{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(t.length);for(let c=0;c<n.length;c++)n[c]=t[e[c]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=r1(this.rank),i=V0("rc",this.rank),s=new Array(this.rank);for(let c=0;c<e.length;c++)s[e[c]]=i[c];const o=`vec2(${s.slice(-2).join()})`,a=`++${i[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${o})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${a}) {\n        result[1] = ${l};\n      }\n      --${i[this.rank-1]};\n      if(++${i[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${a}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function T3(t,e,n){const r=BD().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new C3(t.shape,e):new E3(t.shape,e);return n.runWebGLProgram(r,[t],t.dtype)}const A3={kernelName:OL,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:i}=t,{reductionIndices:s,keepDims:o}=e,a=n,l=i.shape.length,c=r.parseAxisParam(s,i.shape);let u=c;const h=p.getAxesPermutation(u,l),d=null!=h,f=a.shouldExecuteOnCPU([i]);let m=i;if(d){if(f){const t=a.texData.get(m.dataId).values,e=new Array(l);for(let r=0;r<e.length;r++)e[r]=i.shape[h[r]];const n=_3(t,i.shape,i.dtype,h,e);m=a.makeTensorInfo(e,i.dtype),a.texData.get(m.dataId).values=n}else m=T3(i,h,a);u=p.getInnerMostAxes(u.length,l)}p.assertAxesAreInnerMostDims("max",u,l);const[g,y]=p.computeOutAndReduceShapes(m.shape,u);let v,b=g;if(o&&(b=p.expandShapeToKeepDim(g,c)),f){const t=a.texData.get(m.dataId),e=b3(t.values,r.sizeFromShape(y),b,i.dtype);v=a.makeTensorInfo(b,i.dtype),a.texData.get(v.dataId).values=e}else v=S3(m,y,b,a);return d&&a.disposeData(m.dataId),v}},M3={kernelName:PL,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:i}=t,{filterSize:s,strides:o,pad:a,includeBatchInIndex:l}=e,c=n;r.assert(4===i.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${i.shape.length}.`);const u=[1,1];r.assert(p.eitherStridesOrDilationsAreOne(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const h=p.computePool2DInfo(i.shape,s,o,u,a),[d,f]=function(t,e,n,r){let i=new y2(n,"max",!1);const s=r.runWebGLProgram(i,[t],"float32");return i=new y2(n,"max",!0,!0,e),[s,r.runWebGLProgram(i,[t],"float32")]}(i,l,h,c);return[d,f]}},k3={kernelName:VL,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{p.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{boxes:r,scores:i}=t,{maxOutputSize:s,iouThreshold:o,scoreThreshold:a}=n,l=e,c=l.readSync(r.dataId),u=l.readSync(i.dataId);return f.nonMaxSuppressionV3Impl(c,u,s,o,a)}},R3=f.nonMaxSuppressionV4Impl,I3={kernelName:UL,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{p.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{boxes:r,scores:i}=t,{maxOutputSize:s,iouThreshold:o,scoreThreshold:a,padToMaxOutputSize:l}=n,c=e,u=c.readSync(r.dataId),h=c.readSync(i.dataId),{selectedIndices:d,validOutputs:f}=R3(u,h,s,o,a,l);return[d,f]}},N3=f.nonMaxSuppressionV5Impl,O3={kernelName:HL,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{p.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{boxes:r,scores:i}=t,{maxOutputSize:s,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}=n,c=e,u=c.readSync(r.dataId),h=c.readSync(i.dataId),d=s,f=o,m=a,g=l,{selectedIndices:y,selectedScores:v}=N3(u,h,d,f,m,g);return[y,v]}};class D3{constructor(t,e,n,r){this.variableNames=["Image"],this.outputShape=[];const i=t[1],s=t[2],o=Math.sin(e).toFixed(3),a=Math.cos(e).toFixed(3);this.outputShape=t;const[l,c]=p.getImageCenter(r,i,s),u=l.toFixed(3),h=c.toFixed(3);let d="";d="number"==typeof n?`float outputValue = ${n.toFixed(2)};`:`\n        vec3 fill = vec3(${n.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - ${u}) * ${a} - (float(y) - ${h}) * ${o};\n          float coordYFloat = (float(x) - ${u}) * ${o} + (float(y) - ${h}) * ${a};\n          int coordX = int(round(coordXFloat + ${u}));\n          int coordY = int(round(coordYFloat + ${h}));\n          ${d}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${i}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const L3=[A3,f3,y3,d3,M3,k3,I3,O3,{kernelName:EF,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:i,fillValue:s,center:o}=e,a=n,l=new D3(r.shape,i,s,o);return a.runWebGLProgram(l,[r],r.dtype)}},{kernelName:mF,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,r=e,i=new z2(n.shape,"return x * x;");return r.runWebGLProgram(i,[n],n.dtype)}},{kernelName:fF,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{a:n,b:r}=t,i="return (a - b) * (a - b);",s=e,o=BD().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new v1(i,n.shape,r.shape):new g1(i,n.shape,r.shape);return s.compileAndRun(o,[n,r])}},{kernelName:vF,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{perm:i}=e,s=n,o=new Array(r.shape.length);for(let l=0;l<o.length;l++)o[l]=r.shape[i[l]];let a;if(s.shouldExecuteOnCPU([r])){const t=s.texData.get(r.dataId),e=_3(t.values,r.shape,r.dtype,i,o);a=s.makeTensorInfo(o,r.dtype),s.texData.get(a.dataId).values=e}else a=T3(r,i,s);return a}}];for(const H3 of L3)OF(H3);let F3=(()=>{class t{constructor(){var t;this.shoulderWidth=new Float32Array(20).fill(0),this.shoulderWidthIndex=0,(null==t&&(t={}),async function(t,e){if(null==e&&(e={}),"string"==typeof t){const n=u.getLoadHandlers(t,e);if(0===n.length)n.push(u.browserHTTPRequest(t,e));else if(n.length>1)throw new Iq(`Found more than one (${n.length}) load handlers for URL '${t}'`);t=n[0]}return async function(t,e,n){if(null==n&&(n={}),null==t.load)throw new Iq("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=await t.load();let i=r.modelTopology;null!=i.model_config&&(i=i.model_config);const s=null==n.strict||n.strict,o=null!=r.weightData&&null!=r.weightSpecs&&s,a=HK(mY(i),void 0,o),l=r.trainingConfig;if(null!=l&&a.loadTrainingConfig(l),null!=r.userDefinedMetadata&&a.setUserDefinedMetadata(r.userDefinedMetadata),null!=r.weightData){if(null==r.weightSpecs)throw new Iq("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:t,optimizerWeights:e}=function(t,e){const n=u.decodeWeights(t,e),r={},i=[];return e.forEach(t=>{"optimizer"===t.group?i.push({name:t.name,tensor:n[t.name]}):r[t.name]=n[t.name]}),{modelWeights:r,optimizerWeights:i}}(r.weightData,r.weightSpecs);a.loadWeights(t,s),null!=a.optimizer&&e.length>0&&await a.optimizer.setWeights(e),aB(t),aB(e.map(t=>t.tensor))}return a}(t,0,e)}("assets/models/sign-detector/model.json",t)).then(t=>this.sequentialModel=t)}distance(t,e){const n=t.x-e.x,r=t.y-e.y;return Math.sqrt(n*n+r*r)}normalizePose(t){const e={x:0,y:0,z:0},n=t.poseLandmarks||new Array(Object.keys(YS.POSE_LANDMARKS).length).fill(e),r=t.leftHandLandmarks||new Array(21).fill(e),i=t.leftHandLandmarks||new Array(21).fill(e),s=n.concat(r,i).map(t=>this.isValidLandmark(t)?t:e),o=s[YS.POSE_LANDMARKS.LEFT_SHOULDER],a=s[YS.POSE_LANDMARKS.RIGHT_SHOULDER];if(o.x>0&&a.x>0&&(this.shoulderWidth[this.shoulderWidthIndex%20]=this.distance(o,a),this.shoulderWidthIndex++),this.shoulderWidthIndex<20)return null;const l=this.shoulderWidth.reduce((t,e)=>t+e,0)/20,c=new Array(s.length);return s.forEach((t,e)=>{c[e]={x:t.x/l,y:t.y/l}}),[c[YS.POSE_LANDMARKS.NOSE],{x:(c[YS.POSE_LANDMARKS.LEFT_SHOULDER].x+c[YS.POSE_LANDMARKS.RIGHT_SHOULDER].x)/2,y:(c[YS.POSE_LANDMARKS.LEFT_SHOULDER].y+c[YS.POSE_LANDMARKS.RIGHT_SHOULDER].y)/2},c[YS.POSE_LANDMARKS.RIGHT_SHOULDER],c[YS.POSE_LANDMARKS.RIGHT_ELBOW],c[YS.POSE_LANDMARKS.RIGHT_WRIST],c[YS.POSE_LANDMARKS.LEFT_SHOULDER],c[YS.POSE_LANDMARKS.LEFT_ELBOW],c[YS.POSE_LANDMARKS.LEFT_WRIST],e,e,e,e,e,e,e,c[YS.POSE_LANDMARKS.RIGHT_EYE],c[YS.POSE_LANDMARKS.LEFT_EYE],c[YS.POSE_LANDMARKS.RIGHT_EAR],c[YS.POSE_LANDMARKS.LEFT_EAR],e,e,e,e,e,e]}isValidLandmark(t){return t.x>.02&&t.x<.98&&t.y>.02&&t.y<.98}distance2DTensors(t,e,n=1){const r=new Float32Array(t.length).fill(0);for(let i=0;i<r.length;i+=1){const s=t[i],o=e[i];s.x>0&&o.x>0&&(r[i]=this.distance(s,o)*n)}return r}getSequentialConfidence(t){const e=this.sequentialModel.predict(fB(t).reshape([1,1,t.length]));return wU(e).dataSync()[1]}detect(t){const e=performance.now()/1e3;let n=0;const r=this.normalizePose(t);if(this.lastPose&&r){const t=this.distance2DTensors(r,this.lastPose,1/(e-this.lastTimestamp));n=this.getSequentialConfidence(t)}return this.lastTimestamp=e,this.lastPose=r,n}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Pt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const P3={signingProbability:0,isSigning:!1};let $3=(()=>{let t=class{constructor(t){this.detector=t,this.detectSign=!1}ngxsOnInit({dispatch:t}){this.detectSign$.subscribe(t=>this.detectSign=t),this.pose$.pipe(yd(Boolean),yd(()=>this.detectSign),$d(e=>t(new PD(e)))).subscribe()}detectSigning({patchState:t},{pose:e}){return Vh(this,void 0,void 0,function*(){const n=yield this.detector.detect(e);t({signingProbability:n,isSigning:n>.5})})}};return t.\u0275fac=function(e){return new(e||t)(zr(F3))},t.\u0275prov=Pt({token:t,factory:t.\u0275fac}),zh([Vp(t=>t.pose.pose)],t.prototype,"pose$",void 0),zh([Vp(t=>t.settings.detectSign)],t.prototype,"detectSign$",void 0),zh([Bp(PD)],t.prototype,"detectSigning",null),t=zh([zp({name:"detector",defaults:P3})],t),t})(),B3=(()=>{class t{}return t.\u0275mod=be({type:t}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},providers:[F3],imports:[[$p.forFeature([$3])]]}),t})(),z3=(()=>{class t{}return t.\u0275mod=be({type:t,bootstrap:[jO]}),t.\u0275inj=Bt({factory:function(e){return new(e||t)},providers:[lD],imports:[[Bh,TD,FD,kD,LD,B3]]}),t})();(function(){if(fu)throw new Error("Cannot enable prod mode after platform setup.");pu=!1})(),Ph().bootstrapModule(z3).catch(t=>console.error(t))},zn8P:function(t,e){function n(t){return Promise.resolve().then(function(){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e})}n.keys=function(){return[]},n.resolve=n,t.exports=n,n.id="zn8P"}},[[0,0]]]);