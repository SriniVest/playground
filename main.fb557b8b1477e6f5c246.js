(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{0:function(t,e,n){t.exports=n("zUnb")},1:function(t,e){},2:function(t,e){},"2lpH":function(t,e){t.exports=i;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(C){}function i(t,e,n){this.low=0|t,this.high=0|e,this.unsigned=!!n}function r(t){return!0===(t&&t.__isLong__)}Object.defineProperty(i.prototype,"__isLong__",{value:!0}),i.isLong=r;var s={},o={};function a(t,e){var n,i,r;return e?(r=0<=(t>>>=0)&&t<256)&&(i=o[t])?i:(n=c(t,(0|t)<0?-1:0,!0),r&&(o[t]=n),n):(r=-128<=(t|=0)&&t<128)&&(i=s[t])?i:(n=c(t,t<0?-1:0,!1),r&&(s[t]=n),n)}function l(t,e){if(isNaN(t))return e?v:y;if(e){if(t<0)return v;if(t>=f)return _}else{if(t<=-m)return S;if(t+1>=m)return w}return t<0?l(-t,e).neg():c(t%p|0,t/p|0,e)}function c(t,e,n){return new i(t,e,n)}i.fromInt=a,i.fromNumber=l,i.fromBits=c;var u=Math.pow;function h(t,e,n){if(0===t.length)throw Error("empty string");if("NaN"===t||"Infinity"===t||"+Infinity"===t||"-Infinity"===t)return y;if("number"==typeof e?(n=e,e=!1):e=!!e,(n=n||10)<2||36<n)throw RangeError("radix");var i;if((i=t.indexOf("-"))>0)throw Error("interior hyphen");if(0===i)return h(t.substring(1),e,n).neg();for(var r=l(u(n,8)),s=y,o=0;o<t.length;o+=8){var a=Math.min(8,t.length-o),c=parseInt(t.substring(o,o+a),n);if(a<8){var d=l(u(n,a));s=s.mul(d).add(l(c))}else s=(s=s.mul(r)).add(l(c))}return s.unsigned=e,s}function d(t,e){return"number"==typeof t?l(t,e):"string"==typeof t?h(t,e):c(t.low,t.high,"boolean"==typeof e?e:t.unsigned)}i.fromString=h,i.fromValue=d;var p=4294967296,f=p*p,m=f/2,g=a(1<<24),y=a(0);i.ZERO=y;var v=a(0,!0);i.UZERO=v;var b=a(1);i.ONE=b;var A=a(1,!0);i.UONE=A;var x=a(-1);i.NEG_ONE=x;var w=c(-1,2147483647,!1);i.MAX_VALUE=w;var _=c(-1,-1,!0);i.MAX_UNSIGNED_VALUE=_;var S=c(0,-2147483648,!1);i.MIN_VALUE=S;var E=i.prototype;E.toInt=function(){return this.unsigned?this.low>>>0:this.low},E.toNumber=function(){return this.unsigned?(this.high>>>0)*p+(this.low>>>0):this.high*p+(this.low>>>0)},E.toString=function(t){if((t=t||10)<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var e=l(t),n=this.div(e),i=n.mul(e).sub(this);return n.toString(t)+i.toInt().toString(t)}return"-"+this.neg().toString(t)}for(var r=l(u(t,6),this.unsigned),s=this,o="";;){var a=s.div(r),c=(s.sub(a.mul(r)).toInt()>>>0).toString(t);if((s=a).isZero())return c+o;for(;c.length<6;)c="0"+c;o=""+c+o}},E.getHighBits=function(){return this.high},E.getHighBitsUnsigned=function(){return this.high>>>0},E.getLowBits=function(){return this.low},E.getLowBitsUnsigned=function(){return this.low>>>0},E.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var t=0!=this.high?this.high:this.low,e=31;e>0&&0==(t&1<<e);e--);return 0!=this.high?e+33:e+1},E.isZero=function(){return 0===this.high&&0===this.low},E.eqz=E.isZero,E.isNegative=function(){return!this.unsigned&&this.high<0},E.isPositive=function(){return this.unsigned||this.high>=0},E.isOdd=function(){return 1==(1&this.low)},E.isEven=function(){return 0==(1&this.low)},E.equals=function(t){return r(t)||(t=d(t)),(this.unsigned===t.unsigned||this.high>>>31!=1||t.high>>>31!=1)&&this.high===t.high&&this.low===t.low},E.eq=E.equals,E.notEquals=function(t){return!this.eq(t)},E.neq=E.notEquals,E.ne=E.notEquals,E.lessThan=function(t){return this.comp(t)<0},E.lt=E.lessThan,E.lessThanOrEqual=function(t){return this.comp(t)<=0},E.lte=E.lessThanOrEqual,E.le=E.lessThanOrEqual,E.greaterThan=function(t){return this.comp(t)>0},E.gt=E.greaterThan,E.greaterThanOrEqual=function(t){return this.comp(t)>=0},E.gte=E.greaterThanOrEqual,E.ge=E.greaterThanOrEqual,E.compare=function(t){if(r(t)||(t=d(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1},E.comp=E.compare,E.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(b)},E.neg=E.negate,E.add=function(t){r(t)||(t=d(t));var e=0,n=0,i=0,s=0;return i+=(s+=(65535&this.low)+(65535&t.low))>>>16,n+=(i+=(this.low>>>16)+(t.low>>>16))>>>16,e+=(n+=(65535&this.high)+(65535&t.high))>>>16,e+=(this.high>>>16)+(t.high>>>16),c((i&=65535)<<16|(s&=65535),(e&=65535)<<16|(n&=65535),this.unsigned)},E.subtract=function(t){return r(t)||(t=d(t)),this.add(t.neg())},E.sub=E.subtract,E.multiply=function(t){if(this.isZero())return y;if(r(t)||(t=d(t)),n)return c(n.mul(this.low,this.high,t.low,t.high),n.get_high(),this.unsigned);if(t.isZero())return y;if(this.eq(S))return t.isOdd()?S:y;if(t.eq(S))return this.isOdd()?S:y;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(g)&&t.lt(g))return l(this.toNumber()*t.toNumber(),this.unsigned);var e=65535&this.high,i=this.low>>>16,s=65535&this.low,o=65535&t.high,a=t.low>>>16,u=65535&t.low,h=0,p=0,f=0,m=0;return f+=(m+=s*u)>>>16,p+=(f+=i*u)>>>16,f&=65535,p+=(f+=s*a)>>>16,h+=(p+=e*u)>>>16,p&=65535,h+=(p+=i*a)>>>16,p&=65535,h+=(p+=s*o)>>>16,h+=(this.high>>>16)*u+e*a+i*o+s*(t.high>>>16),c((f&=65535)<<16|(m&=65535),(h&=65535)<<16|(p&=65535),this.unsigned)},E.mul=E.multiply,E.divide=function(t){if(r(t)||(t=d(t)),t.isZero())throw Error("division by zero");var e,i,s;if(n)return this.unsigned||-2147483648!==this.high||-1!==t.low||-1!==t.high?c((this.unsigned?n.div_u:n.div_s)(this.low,this.high,t.low,t.high),n.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?v:y;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return v;if(t.gt(this.shru(1)))return A;s=v}else{if(this.eq(S))return t.eq(b)||t.eq(x)?S:t.eq(S)?b:(e=this.shr(1).div(t).shl(1)).eq(y)?t.isNegative()?b:x:(i=this.sub(t.mul(e)),s=e.add(i.div(t)));if(t.eq(S))return this.unsigned?v:y;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();s=y}for(i=this;i.gte(t);){e=Math.max(1,Math.floor(i.toNumber()/t.toNumber()));for(var o=Math.ceil(Math.log(e)/Math.LN2),a=o<=48?1:u(2,o-48),h=l(e),p=h.mul(t);p.isNegative()||p.gt(i);)p=(h=l(e-=a,this.unsigned)).mul(t);h.isZero()&&(h=b),s=s.add(h),i=i.sub(p)}return s},E.div=E.divide,E.modulo=function(t){return r(t)||(t=d(t)),n?c((this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,t.low,t.high),n.get_high(),this.unsigned):this.sub(this.div(t).mul(t))},E.mod=E.modulo,E.rem=E.modulo,E.not=function(){return c(~this.low,~this.high,this.unsigned)},E.and=function(t){return r(t)||(t=d(t)),c(this.low&t.low,this.high&t.high,this.unsigned)},E.or=function(t){return r(t)||(t=d(t)),c(this.low|t.low,this.high|t.high,this.unsigned)},E.xor=function(t){return r(t)||(t=d(t)),c(this.low^t.low,this.high^t.high,this.unsigned)},E.shiftLeft=function(t){return r(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?c(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):c(0,this.low<<t-32,this.unsigned)},E.shl=E.shiftLeft,E.shiftRight=function(t){return r(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?c(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):c(this.high>>t-32,this.high>=0?0:-1,this.unsigned)},E.shr=E.shiftRight,E.shiftRightUnsigned=function(t){if(r(t)&&(t=t.toInt()),0==(t&=63))return this;var e=this.high;return t<32?c(this.low>>>t|e<<32-t,e>>>t,this.unsigned):c(32===t?e:e>>>t-32,0,this.unsigned)},E.shru=E.shiftRightUnsigned,E.shr_u=E.shiftRightUnsigned,E.toSigned=function(){return this.unsigned?c(this.low,this.high,!1):this},E.toUnsigned=function(){return this.unsigned?this:c(this.low,this.high,!0)},E.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()},E.toBytesLE=function(){var t=this.high,e=this.low;return[255&e,e>>>8&255,e>>>16&255,e>>>24,255&t,t>>>8&255,t>>>16&255,t>>>24]},E.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,255&t,e>>>24,e>>>16&255,e>>>8&255,255&e]},i.fromBytes=function(t,e,n){return n?i.fromBytesLE(t,e):i.fromBytesBE(t,e)},i.fromBytesLE=function(t,e){return new i(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)},i.fromBytesBE=function(t,e){return new i(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)}},3:function(t,e){},"34t7":function(t,e,n){(function(t){var i;!function(t,r,s){function o(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var i=0;i<n.length+64;i++)e.x^=0|n.charCodeAt(i),i==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function a(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function l(t,e){var n=new o(t),i=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,i&&("object"==typeof i&&a(i,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(i=(function(){return l}).call(e,n,e,r))||(r.exports=i):this.xorwow=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},4:function(t,e){},5:function(t,e){},"5vwH":function(t,e,n){(function(t){var i;!function(t,r,s){function o(t){var e=this;e.next=function(){var t,n,i=e.w,r=e.X,s=e.i;return e.w=i=i+1640531527|0,n=r[s+34&127],t=r[s=s+1&127],n^=n<<13,t^=t<<17,n=r[s]=(n^=n>>>15)^(t^=t>>>12),e.i=s,n+(i^i>>>16)|0},function(t,e){var n,i,r,s,o,a=[],l=128;for(e===(0|e)?(i=e,e=null):(e+="\0",i=0,l=Math.max(l,e.length)),r=0,s=-32;s<l;++s)e&&(i^=e.charCodeAt((s+32)%e.length)),0===s&&(o=i),i^=i<<10,i^=i>>>15,i^=i<<4,i^=i>>>13,s>=0&&(r=0==(n=a[127&s]^=i+(o=o+1640531527|0))?r+1:0);for(r>=128&&(a[127&(e&&e.length||0)]=-1),r=127,s=512;s>0;--s)i=a[r+34&127],n=a[r=r+1&127],i^=i<<13,n^=n<<17,a[r]=(i^=i>>>15)^(n^=n>>>12);t.w=o,t.X=a,t.i=r}(e,t)}function a(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function l(t,e){null==t&&(t=+new Date);var n=new o(t),i=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,i&&(i.X&&a(i,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(i=(function(){return l}).call(e,n,e,r))||(r.exports=i):this.xor4096=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},6:function(t,e){},"9/Hw":function(t,e,n){var i;!function(r,s){var o,a=this,l=256,c=s.pow(l,6),u=s.pow(2,52),h=2*u,d=255;function p(t,e,n){var i=[],d=y(g((e=1==e?{entropy:!0}:e||{}).entropy?[t,v(r)]:null==t?function(){try{var t;return o&&(t=o.randomBytes)?t=t(l):(t=new Uint8Array(l),(a.crypto||a.msCrypto).getRandomValues(t)),v(t)}catch(i){var e=a.navigator,n=e&&e.plugins;return[+new Date,a,n,a.screen,v(r)]}}():t,3),i),p=new f(i),b=function(){for(var t=p.g(6),e=c,n=0;t<u;)t=(t+n)*l,e*=l,n=p.g(1);for(;t>=h;)t/=2,e/=2,n>>>=1;return(t+n)/e};return b.int32=function(){return 0|p.g(4)},b.quick=function(){return p.g(4)/4294967296},b.double=b,y(v(p.S),r),(e.pass||n||function(t,e,n,i){return i&&(i.S&&m(i,p),t.state=function(){return m(p,{})}),n?(s.random=t,e):t})(b,d,"global"in e?e.global:this==s,e.state)}function f(t){var e,n=t.length,i=this,r=0,s=i.i=i.j=0,o=i.S=[];for(n||(t=[n++]);r<l;)o[r]=r++;for(r=0;r<l;r++)o[r]=o[s=d&s+t[r%n]+(e=o[r])],o[s]=e;(i.g=function(t){for(var e,n=0,r=i.i,s=i.j,o=i.S;t--;)e=o[r=d&r+1],n=n*l+o[d&(o[r]=o[s=d&s+e])+(o[s]=e)];return i.i=r,i.j=s,n})(l)}function m(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function g(t,e){var n,i=[],r=typeof t;if(e&&"object"==r)for(n in t)try{i.push(g(t[n],e-1))}catch(s){}return i.length?i:"string"==r?t:t+"\0"}function y(t,e){for(var n,i=t+"",r=0;r<i.length;)e[d&r]=d&(n^=19*e[d&r])+i.charCodeAt(r++);return v(e)}function v(t){return String.fromCharCode.apply(0,t)}if(s.seedrandom=p,y(s.random(),r),t.exports){t.exports=p;try{o=n(3)}catch(b){}}else void 0===(i=(function(){return p}).call(e,n,e,t))||(t.exports=i)}([],Math)},B9Yq:function(t,e){t.exports=function(){throw new Error("define cannot be used indirect")}},DZm5:function(t,e,n){"use strict";n.d(e,"a",function(){return Nt}),n.d(e,"b",function(){return M}),n.d(e,"c",function(){return Y}),n.d(e,"d",function(){return dt}),n.d(e,"e",function(){return K}),n.d(e,"f",function(){return pt}),n.d(e,"g",function(){return kt}),n.d(e,"h",function(){return st}),n.d(e,"i",function(){return S}),n.d(e,"j",function(){return I}),n.d(e,"k",function(){return f}),n.d(e,"l",function(){return gt}),n.d(e,"m",function(){return _}),n.d(e,"n",function(){return Rt});let i,r,s,o=!1,a=!1,l=!1,c=!1,u=!1;const h="undefined"!=typeof window?window:{},d=h.document||{head:{}},p={$flags$:0,$resourcesUrl$:"",jmp:t=>t(),raf:t=>requestAnimationFrame(t),ael:(t,e,n,i)=>t.addEventListener(e,n,i),rel:(t,e,n,i)=>t.removeEventListener(e,n,i),ce:(t,e)=>new CustomEvent(t,e)},f=t=>Promise.resolve(t),m=(()=>{try{return new CSSStyleSheet,!0}catch(t){}return!1})(),g=(t,e,n,i)=>{n&&n.map(([n,i,r])=>{const s=v(t,n),o=y(e,r),a=b(n);p.ael(s,i,o,a),(e.$rmListeners$=e.$rmListeners$||[]).push(()=>p.rel(s,i,o,a))})},y=(t,e)=>n=>{try{256&t.$flags$?t.$lazyInstance$[e](n):(t.$queuedListeners$=t.$queuedListeners$||[]).push([e,n])}catch(i){bt(i)}},v=(t,e)=>4&e?d:8&e?h:16&e?d.body:t,b=t=>0!=(2&t),A="http://www.w3.org/1999/xlink",x=new WeakMap,w=(t,e)=>"sc-"+(e&&32&t.$flags$?t.$tagName$+"-"+e:t.$tagName$),_=t=>_t.push(t),S=t=>mt(t).$modeName$,E={},C=t=>"object"==(t=typeof t)||"function"===t,I=(t,e,...n)=>{let i=null,r=null,s=null,o=!1,a=!1,l=[];const c=e=>{for(let n=0;n<e.length;n++)i=e[n],Array.isArray(i)?c(i):null!=i&&"boolean"!=typeof i&&((o="function"!=typeof t&&!C(i))&&(i=String(i)),o&&a?l[l.length-1].$text$+=i:l.push(o?T(null,i):i),a=o)};if(c(n),e){e.key&&(r=e.key),e.name&&(s=e.name);{const t=e.className||e.class;t&&(e.class="object"!=typeof t?t:Object.keys(t).filter(e=>t[e]).join(" "))}}if("function"==typeof t)return t(null===e?{}:e,l,k);const u=T(t,null);return u.$attrs$=e,l.length>0&&(u.$children$=l),u.$key$=r,u.$name$=s,u},T=(t,e)=>({$flags$:0,$tag$:t,$text$:e,$elm$:null,$children$:null,$attrs$:null,$key$:null,$name$:null}),M={},k={forEach:(t,e)=>t.map(R).forEach(e),map:(t,e)=>t.map(R).map(e).map(N)},R=t=>({vattrs:t.$attrs$,vchildren:t.$children$,vkey:t.$key$,vname:t.$name$,vtag:t.$tag$,vtext:t.$text$}),N=t=>{if("function"==typeof t.vtag){const e=Object.assign({},t.vattrs);return t.vkey&&(e.key=t.vkey),t.vname&&(e.name=t.vname),I(t.vtag,e,...t.vchildren||[])}const e=T(t.vtag,t.vtext);return e.$attrs$=t.vattrs,e.$children$=t.vchildren,e.$key$=t.vkey,e.$name$=t.vname,e},L=(t,e,n,i,r,s)=>{if(n!==i){let a=vt(t,e),l=e.toLowerCase();if("class"===e){const e=t.classList,r=B(n),s=B(i);e.remove(...r.filter(t=>t&&!s.includes(t))),e.add(...s.filter(t=>t&&!r.includes(t)))}else if("style"===e){for(const e in n)i&&null!=i[e]||(e.includes("-")?t.style.removeProperty(e):t.style[e]="");for(const e in i)n&&i[e]===n[e]||(e.includes("-")?t.style.setProperty(e,i[e]):t.style[e]=i[e])}else if("key"===e);else if("ref"===e)i&&i(t);else if(a||"o"!==e[0]||"n"!==e[1]){const c=C(i);if((a||c&&null!==i)&&!r)try{if(t.tagName.includes("-"))t[e]=i;else{let r=null==i?"":i;"list"===e?a=!1:null!=n&&t[e]==r||(t[e]=r)}}catch(o){}let u=!1;l!==(l=l.replace(/^xlink\:?/,""))&&(e=l,u=!0),null==i||!1===i?!1===i&&""!==t.getAttribute(e)||(u?t.removeAttributeNS(A,e):t.removeAttribute(e)):(!a||4&s||r)&&!c&&(i=!0===i?"":i,u?t.setAttributeNS(A,e,i):t.setAttribute(e,i))}else e="-"===e[2]?e.slice(3):vt(h,l)?l.slice(2):l[2]+e.slice(3),n&&p.rel(t,e,n,!1),i&&p.ael(t,e,i,!1)}},D=/\s/,B=t=>t?t.split(D):[],O=(t,e,n,i)=>{const r=11===e.$elm$.nodeType&&e.$elm$.host?e.$elm$.host:e.$elm$,s=t&&t.$attrs$||E,o=e.$attrs$||E;for(i in s)i in o||L(r,i,s[i],void 0,n,e.$flags$);for(i in o)L(r,i,s[i],o[i],n,e.$flags$)},P=(t,e,n,a)=>{let u,h,p,f=e.$children$[n],m=0;if(o||(l=!0,"slot"===f.$tag$&&(i&&a.classList.add(i+"-s"),f.$flags$|=f.$children$?2:1)),null!==f.$text$)u=f.$elm$=d.createTextNode(f.$text$);else if(1&f.$flags$)u=f.$elm$=d.createTextNode("");else{if(c||(c="svg"===f.$tag$),u=f.$elm$=d.createElementNS(c?"http://www.w3.org/2000/svg":"http://www.w3.org/1999/xhtml",2&f.$flags$?"slot-fb":f.$tag$),c&&"foreignObject"===f.$tag$&&(c=!1),O(null,f,c),null!=i&&u["s-si"]!==i&&u.classList.add(u["s-si"]=i),f.$children$)for(m=0;m<f.$children$.length;++m)h=P(t,f,m,u),h&&u.appendChild(h);"svg"===f.$tag$?c=!1:"foreignObject"===u.tagName&&(c=!0)}return u["s-hn"]=s,3&f.$flags$&&(u["s-sr"]=!0,u["s-cr"]=r,u["s-sn"]=f.$name$||"",p=t&&t.$children$&&t.$children$[n],p&&p.$tag$===f.$tag$&&t.$elm$&&F(t.$elm$,!1)),u},F=(t,e)=>{p.$flags$|=1;const n=t.childNodes;for(let i=n.length-1;i>=0;i--){const t=n[i];t["s-hn"]!==s&&t["s-ol"]&&(V(t).insertBefore(t,H(t)),t["s-ol"].remove(),t["s-ol"]=void 0,l=!0),e&&F(t,e)}p.$flags$&=-2},$=(t,e,n,i,r,o)=>{let a,l=t["s-cr"]&&t["s-cr"].parentNode||t;for(l.shadowRoot&&l.tagName===s&&(l=l.shadowRoot);r<=o;++r)i[r]&&(a=P(null,n,r,t),a&&(i[r].$elm$=a,l.insertBefore(a,H(e))))},z=(t,e,n,i,r)=>{for(;e<=n;++e)(i=t[e])&&(r=i.$elm$,X(i),a=!0,r["s-ol"]?r["s-ol"].remove():F(r,!0),r.remove())},U=(t,e)=>t.$tag$===e.$tag$&&("slot"===t.$tag$?t.$name$===e.$name$:t.$key$===e.$key$),H=t=>t&&t["s-ol"]||t,V=t=>(t["s-ol"]?t["s-ol"]:t).parentNode,G=(t,e)=>{const n=e.$elm$=t.$elm$,i=t.$children$,r=e.$children$,s=e.$tag$,o=e.$text$;let a;null===o?(c="svg"===s||"foreignObject"!==s&&c,"slot"===s||O(t,e,c),null!==i&&null!==r?((t,e,n,i)=>{let r,s,o=0,a=0,l=0,c=0,u=e.length-1,h=e[0],d=e[u],p=i.length-1,f=i[0],m=i[p];for(;o<=u&&a<=p;)if(null==h)h=e[++o];else if(null==d)d=e[--u];else if(null==f)f=i[++a];else if(null==m)m=i[--p];else if(U(h,f))G(h,f),h=e[++o],f=i[++a];else if(U(d,m))G(d,m),d=e[--u],m=i[--p];else if(U(h,m))"slot"!==h.$tag$&&"slot"!==m.$tag$||F(h.$elm$.parentNode,!1),G(h,m),t.insertBefore(h.$elm$,d.$elm$.nextSibling),h=e[++o],m=i[--p];else if(U(d,f))"slot"!==h.$tag$&&"slot"!==m.$tag$||F(d.$elm$.parentNode,!1),G(d,f),t.insertBefore(d.$elm$,h.$elm$),d=e[--u],f=i[++a];else{for(l=-1,c=o;c<=u;++c)if(e[c]&&null!==e[c].$key$&&e[c].$key$===f.$key$){l=c;break}l>=0?(s=e[l],s.$tag$!==f.$tag$?r=P(e&&e[a],n,l,t):(G(s,f),e[l]=void 0,r=s.$elm$),f=i[++a]):(r=P(e&&e[a],n,a,t),f=i[++a]),r&&V(h.$elm$).insertBefore(r,H(h.$elm$))}o>u?$(t,null==i[p+1]?null:i[p+1].$elm$,n,i,a,p):a>p&&z(e,o,u)})(n,i,e,r):null!==r?(null!==t.$text$&&(n.textContent=""),$(n,null,e,r,0,r.length-1)):null!==i&&z(i,0,i.length-1),c&&"svg"===s&&(c=!1)):(a=n["s-cr"])?a.parentNode.textContent=o:t.$text$!==o&&(n.data=o)},W=t=>{let e,n,i,r,s,o,a=t.childNodes;for(n=0,i=a.length;n<i;n++)if(e=a[n],1===e.nodeType){if(e["s-sr"])for(s=e["s-sn"],e.hidden=!1,r=0;r<i;r++)if(a[r]["s-hn"]!==e["s-hn"])if(o=a[r].nodeType,""!==s){if(1===o&&s===a[r].getAttribute("slot")){e.hidden=!0;break}}else if(1===o||3===o&&""!==a[r].textContent.trim()){e.hidden=!0;break}W(e)}},j=[],Q=t=>{let e,n,i,r,s,o,l=0,c=t.childNodes,u=c.length;for(;l<u;l++){if(e=c[l],e["s-sr"]&&(n=e["s-cr"]))for(i=n.parentNode.childNodes,r=e["s-sn"],o=i.length-1;o>=0;o--)n=i[o],n["s-cn"]||n["s-nr"]||n["s-hn"]===e["s-hn"]||(q(n,r)?(s=j.find(t=>t.$nodeToRelocate$===n),a=!0,n["s-sn"]=n["s-sn"]||r,s?s.$slotRefNode$=e:j.push({$slotRefNode$:e,$nodeToRelocate$:n}),n["s-sr"]&&j.map(t=>{q(t.$nodeToRelocate$,n["s-sn"])&&(s=j.find(t=>t.$nodeToRelocate$===n),s&&!t.$slotRefNode$&&(t.$slotRefNode$=s.$slotRefNode$))})):j.some(t=>t.$nodeToRelocate$===n)||j.push({$nodeToRelocate$:n}));1===e.nodeType&&Q(e)}},q=(t,e)=>1===t.nodeType?null===t.getAttribute("slot")&&""===e||t.getAttribute("slot")===e:t["s-sn"]===e||""===e,X=t=>{t.$attrs$&&t.$attrs$.ref&&t.$attrs$.ref(null),t.$children$&&t.$children$.map(X)},Y=t=>mt(t).$hostElement$,K=(t,e,n)=>{const i=Y(t);return{emit:t=>J(i,e,{bubbles:!!(4&n),composed:!!(2&n),cancelable:!!(1&n),detail:t})}},J=(t,e,n)=>{const i=p.ce(e,n);return t.dispatchEvent(i),i},Z=(t,e)=>{e&&!t.$onRenderResolve$&&e["s-p"]&&e["s-p"].push(new Promise(e=>t.$onRenderResolve$=e))},tt=(t,e)=>{if(t.$flags$|=16,!(4&t.$flags$))return Z(t,t.$ancestorComponent$),Rt(()=>et(t,e));t.$flags$|=512},et=(t,e)=>{const n=t.$lazyInstance$;let i;return e&&(t.$flags$|=256,t.$queuedListeners$&&(t.$queuedListeners$.map(([t,e])=>at(n,t,e)),t.$queuedListeners$=null),i=at(n,"componentWillLoad")),i=lt(i,()=>at(n,"componentWillRender")),lt(i,()=>nt(t,n,e))},nt=async(t,e,n)=>{const c=t.$hostElement$,u=c["s-rc"];n&&(t=>{const e=t.$cmpMeta$,n=t.$hostElement$,i=e.$flags$,r=((t,e,n,i)=>{let r=w(e,n),s=wt.get(r);if(t=11===t.nodeType?t:d,s)if("string"==typeof s){let e,n=x.get(t=t.head||t);n||x.set(t,n=new Set),n.has(r)||(e=d.createElement("style"),e.innerHTML=s,t.insertBefore(e,t.querySelector("link")),n&&n.add(r))}else t.adoptedStyleSheets.includes(s)||(t.adoptedStyleSheets=[...t.adoptedStyleSheets,s]);return r})(n.shadowRoot?n.shadowRoot:n.getRootNode(),e,t.$modeName$);10&i&&(n["s-sc"]=r,n.classList.add(r+"-h"),2&i&&n.classList.add(r+"-s"))})(t),((t,e)=>{const n=t.$hostElement$,c=t.$cmpMeta$,u=t.$vnode$||T(null,null),h=(f=e)&&f.$tag$===M?e:I(null,null,e);var f;if(s=n.tagName,c.$attrsToReflect$&&(h.$attrs$=h.$attrs$||{},c.$attrsToReflect$.map(([t,e])=>h.$attrs$[e]=n[t])),h.$tag$=null,h.$flags$|=4,t.$vnode$=h,h.$elm$=u.$elm$=n.shadowRoot||n,i=n["s-sc"],r=n["s-cr"],o=0!=(1&c.$flags$),a=!1,G(u,h),p.$flags$|=1,l){let t,e,n,i,r,s;Q(h.$elm$);let o=0;for(;o<j.length;o++)t=j[o],e=t.$nodeToRelocate$,e["s-ol"]||(n=d.createTextNode(""),n["s-nr"]=e,e.parentNode.insertBefore(e["s-ol"]=n,e));for(o=0;o<j.length;o++)if(t=j[o],e=t.$nodeToRelocate$,t.$slotRefNode$){for(i=t.$slotRefNode$.parentNode,r=t.$slotRefNode$.nextSibling,n=e["s-ol"];n=n.previousSibling;)if(s=n["s-nr"],s&&s["s-sn"]===e["s-sn"]&&i===s.parentNode&&(s=s.nextSibling,!s||!s["s-nr"])){r=s;break}(!r&&i!==e.parentNode||e.nextSibling!==r)&&e!==r&&(!e["s-hn"]&&e["s-ol"]&&(e["s-hn"]=e["s-ol"].parentNode.nodeName),i.insertBefore(e,r))}else 1===e.nodeType&&(e.hidden=!0)}a&&W(h.$elm$),p.$flags$&=-2,j.length=0})(t,it(t,e)),u&&(u.map(t=>t()),c["s-rc"]=void 0);{const e=c["s-p"],n=()=>rt(t);0===e.length?n():(Promise.all(e).then(n),t.$flags$|=4,e.length=0)}},it=(t,e)=>{try{e=e.render&&e.render(),t.$flags$&=-17,t.$flags$|=2}catch(n){bt(n,t.$hostElement$)}return e},rt=t=>{const e=t.$hostElement$,n=t.$lazyInstance$,i=t.$ancestorComponent$;64&t.$flags$?at(n,"componentDidUpdate"):(t.$flags$|=64,ct(e),at(n,"componentDidLoad"),t.$onReadyResolve$(e),i||ot()),t.$onInstanceResolve$(e),t.$onRenderResolve$&&(t.$onRenderResolve$(),t.$onRenderResolve$=void 0),512&t.$flags$&&Mt(()=>tt(t,!1)),t.$flags$&=-517},st=t=>{{const e=mt(t),n=e.$hostElement$.isConnected;return n&&2==(18&e.$flags$)&&tt(e,!1),n}},ot=t=>{ct(d.documentElement),Mt(()=>J(h,"appload",{detail:{namespace:"sgnw-components"}}))},at=(t,e,n)=>{if(t&&t[e])try{return t[e](n)}catch(i){bt(i)}},lt=(t,e)=>t&&t.then?t.then(e):e(),ct=t=>t.classList.add("hydrated"),ut=(t,e,n)=>{if(e.$members$){t.watchers&&(e.$watchers$=t.watchers);const i=Object.entries(e.$members$),r=t.prototype;if(i.map(([t,[i]])=>{31&i||2&n&&32&i?Object.defineProperty(r,t,{get(){return e=t,mt(this).$instanceValues$.get(e);var e},set(n){((t,e,n,i)=>{const r=mt(this),s=r.$hostElement$,o=r.$instanceValues$.get(e),a=r.$flags$,l=r.$lazyInstance$;var c,u;if(u=i.$members$[e][0],n=null==(c=n)||C(c)?c:4&u?"false"!==c&&(""===c||!!c):2&u?parseFloat(c):1&u?String(c):c,!(8&a&&void 0!==o||n===o)&&(r.$instanceValues$.set(e,n),l)){if(i.$watchers$&&128&a){const t=i.$watchers$[e];t&&t.map(t=>{try{l[t](n,o,e)}catch(i){bt(i,s)}})}2==(18&a)&&tt(r,!1)}})(0,t,n,e)},configurable:!0,enumerable:!0}):1&n&&64&i&&Object.defineProperty(r,t,{value(...e){const n=mt(this);return n.$onInstancePromise$.then(()=>n.$lazyInstance$[t](...e))}})}),1&n){const n=new Map;r.attributeChangedCallback=function(t,e,i){p.jmp(()=>{const e=n.get(t);this[e]=(null!==i||"boolean"!=typeof this[e])&&i})},t.observedAttributes=i.filter(([t,e])=>15&e[0]).map(([t,i])=>{const r=i[1]||t;return n.set(r,t),512&i[0]&&e.$attrsToReflect$.push([t,r]),r})}}return t},ht=t=>{at(t,"connectedCallback")},dt=(t,e={})=>{const n=[],i=e.exclude||[],r=h.customElements,s=d.head,o=s.querySelector("meta[charset]"),a=d.createElement("style"),l=[];let c,u=!0;Object.assign(p,e),p.$resourcesUrl$=new URL(e.resourcesUrl||"./",d.baseURI).href,t.map(t=>t[1].map(e=>{const s={$flags$:e[0],$tagName$:e[1],$members$:e[2],$listeners$:e[3]};s.$members$=e[2],s.$listeners$=e[3],s.$attrsToReflect$=[],s.$watchers$={};const o=s.$tagName$,a=class extends HTMLElement{constructor(t){super(t),yt(t=this,s),1&s.$flags$&&t.attachShadow({mode:"open",delegatesFocus:!!(16&s.$flags$)})}connectedCallback(){c&&(clearTimeout(c),c=null),u?l.push(this):p.jmp(()=>(t=>{if(0==(1&p.$flags$)){const e=mt(t),n=e.$cmpMeta$,i=()=>{};if(1&e.$flags$)g(t,e,n.$listeners$),ht(e.$lazyInstance$);else{e.$flags$|=1,12&n.$flags$&&(t=>{const e=t["s-cr"]=d.createComment("");e["s-cn"]=!0,t.insertBefore(e,t.firstChild)})(t);{let n=t;for(;n=n.parentNode||n.host;)if(n["s-p"]){Z(e,e.$ancestorComponent$=n);break}}n.$members$&&Object.entries(n.$members$).map(([e,[n]])=>{if(31&n&&t.hasOwnProperty(e)){const n=t[e];delete t[e],t[e]=n}}),(async(t,e,n,i,r)=>{if(0==(32&e.$flags$)){{if(e.$flags$|=32,(r=xt(n)).then){const t=()=>{};r=await r,t()}r.isProxied||(n.$watchers$=r.watchers,ut(r,n,2),r.isProxied=!0);const t=()=>{};e.$flags$|=8;try{new r(e)}catch(a){bt(a)}e.$flags$&=-9,e.$flags$|=128,t(),ht(e.$lazyInstance$)}if(r.style){let i=r.style;"string"!=typeof i&&(i=i[e.$modeName$=(t=>_t.map(e=>e(t)).find(t=>!!t))(t)]);const s=w(n,e.$modeName$);if(!wt.has(s)){const t=()=>{};((t,e,n)=>{let i=wt.get(t);m&&n?(i=i||new CSSStyleSheet,i.replace(e)):i=e,wt.set(t,i)})(s,i,!!(1&n.$flags$)),t()}}}const s=e.$ancestorComponent$,o=()=>tt(e,!0);s&&s["s-rc"]?s["s-rc"].push(o):o()})(t,e,n)}i()}})(this))}disconnectedCallback(){p.jmp(()=>(t=>{if(0==(1&p.$flags$)){const t=mt(this),e=t.$lazyInstance$;t.$rmListeners$&&(t.$rmListeners$.map(t=>t()),t.$rmListeners$=void 0),at(e,"disconnectedCallback")}})())}componentOnReady(){return mt(this).$onReadyPromise$}};s.$lazyBundleId$=t[0],i.includes(o)||r.get(o)||(n.push(o),r.define(o,ut(a,s,1)))})),a.innerHTML=n+"{visibility:hidden}.hydrated{visibility:inherit}",a.setAttribute("data-styles",""),s.insertBefore(a,o?o.nextSibling:s.firstChild),u=!1,l.length?l.map(t=>t.connectedCallback()):p.jmp(()=>c=setTimeout(ot,30))},pt=t=>{const e=new URL(t,p.$resourcesUrl$);return e.origin!==h.location.origin?e.href:e.pathname},ft=new WeakMap,mt=t=>ft.get(t),gt=(t,e)=>ft.set(e.$lazyInstance$=t,e),yt=(t,e)=>{const n={$flags$:0,$hostElement$:t,$cmpMeta$:e,$instanceValues$:new Map};return n.$onInstancePromise$=new Promise(t=>n.$onInstanceResolve$=t),n.$onReadyPromise$=new Promise(t=>n.$onReadyResolve$=t),t["s-p"]=[],t["s-rc"]=[],g(t,n,e.$listeners$),ft.set(t,n)},vt=(t,e)=>e in t,bt=(t,e)=>(0,console.error)(t,e),At=new Map,xt=(t,e,i)=>{const r=t.$tagName$.replace(/-/g,"_"),s=t.$lazyBundleId$,o=At.get(s);return o?o[r]:n("mQJU")(`./${s}.entry.js`).then(t=>(At.set(s,t),t[r]),bt)},wt=new Map,_t=[],St=[],Et=[],Ct=(t,e)=>n=>{t.push(n),u||(u=!0,e&&4&p.$flags$?Mt(Tt):p.raf(Tt))},It=t=>{for(let n=0;n<t.length;n++)try{t[n](performance.now())}catch(e){bt(e)}t.length=0},Tt=()=>{It(St),It(Et),(u=St.length>0)&&p.raf(Tt)},Mt=t=>f().then(t),kt=Ct(St,!1),Rt=Ct(Et,!0),Nt={isDev:!1,isBrowser:!0,isServer:!1,isTesting:!1}},EUiz:function(t,e){(function(){"use strict";var t;function e(t){var e=0;return function(){return e<t.length?{done:!1,value:t[e++]}:{done:!0}}}var n,i="function"==typeof Object.defineProperties?Object.defineProperty:function(t,e,n){return t==Array.prototype||t==Object.prototype||(t[e]=n.value),t},r=function(t){t=["object"==typeof globalThis&&globalThis,t,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof global&&global];for(var e=0;e<t.length;++e){var n=t[e];if(n&&n.Math==Math)return n}throw Error("Cannot find global object")}(this);function s(t,e){if(e)t:{var n=r;t=t.split(".");for(var s=0;s<t.length-1;s++){var o=t[s];if(!(o in n))break t;n=n[o]}(e=e(s=n[t=t[t.length-1]]))!=s&&null!=e&&i(n,t,{configurable:!0,writable:!0,value:e})}}function o(t){return(t={next:t})[Symbol.iterator]=function(){return this},t}function a(t){var n="undefined"!=typeof Symbol&&Symbol.iterator&&t[Symbol.iterator];return n?n.call(t):{next:e(t)}}function l(t){if(!(t instanceof Array)){t=a(t);for(var e,n=[];!(e=t.next()).done;)n.push(e.value);t=n}return t}if(s("Symbol",function(t){function e(t,e){this.g=t,i(this,"description",{configurable:!0,writable:!0,value:e})}if(t)return t;e.prototype.toString=function(){return this.g};var n="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",r=0;return function t(i){if(this instanceof t)throw new TypeError("Symbol is not a constructor");return new e(n+(i||"")+"_"+r++,i)}}),s("Symbol.iterator",function(t){if(t)return t;t=Symbol("Symbol.iterator");for(var n="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),s=0;s<n.length;s++){var a=r[n[s]];"function"==typeof a&&"function"!=typeof a.prototype[t]&&i(a.prototype,t,{configurable:!0,writable:!0,value:function(){return o(e(this))}})}return t}),"function"==typeof Object.setPrototypeOf)n=Object.setPrototypeOf;else{var c;t:{var u={};try{u.__proto__={a:!0},c=u.a;break t}catch(j){}c=!1}n=c?function(t,e){if(t.__proto__=e,t.__proto__!==e)throw new TypeError(t+" is not extensible");return t}:null}var h=n;function d(){this.l=!1,this.h=null,this.i=void 0,this.g=1,this.s=this.m=0,this.j=null}function p(t){if(t.l)throw new TypeError("Generator is already running");t.l=!0}function f(t,e){t.j={O:e,P:!0},t.g=t.m||t.s}function m(t,e,n){return t.g=n,{value:e}}function g(t){this.g=new d,this.h=t}function y(t,e,n,i){try{var r=e.call(t.g.h,n);if(!(r instanceof Object))throw new TypeError("Iterator result "+r+" is not an object");if(!r.done)return t.g.l=!1,r;var s=r.value}catch(o){return t.g.h=null,f(t.g,o),v(t)}return t.g.h=null,i.call(t.g,s),v(t)}function v(t){for(;t.g.g;)try{var e=t.h(t.g);if(e)return t.g.l=!1,{value:e.value,done:!1}}catch(n){t.g.i=void 0,f(t.g,n)}if(t.g.l=!1,t.g.j){if(e=t.g.j,t.g.j=null,e.P)throw e.O;return{value:e.return,done:!0}}return{value:void 0,done:!0}}function b(t){this.next=function(e){return p(t.g),t.g.h?e=y(t,t.g.h.next,e,t.g.o):(t.g.o(e),e=v(t)),e},this.throw=function(e){return p(t.g),t.g.h?e=y(t,t.g.h.throw,e,t.g.o):(f(t.g,e),e=v(t)),e},this.return=function(e){return function(t,e){p(t.g);var n=t.g.h;return n?y(t,"return"in n?n.return:function(t){return{value:t,done:!0}},e,t.g.return):(t.g.return(e),v(t))}(t,e)},this[Symbol.iterator]=function(){return this}}function A(t,e){return e=new b(new g(e)),h&&t.prototype&&h(e,t.prototype),e}d.prototype.o=function(t){this.i=t},d.prototype.return=function(t){this.j={return:t},this.g=this.s};var x="function"==typeof Object.assign?Object.assign:function(t,e){for(var n=1;n<arguments.length;n++){var i=arguments[n];if(i)for(var r in i)Object.prototype.hasOwnProperty.call(i,r)&&(t[r]=i[r])}return t};s("Object.assign",function(t){return t||x}),s("Promise",function(t){function e(t){this.h=0,this.i=void 0,this.g=[],this.o=!1;var e=this.j();try{t(e.resolve,e.reject)}catch(n){e.reject(n)}}function n(){this.g=null}function i(t){return t instanceof e?t:new e(function(e){e(t)})}if(t)return t;n.prototype.h=function(t){if(null==this.g){this.g=[];var e=this;this.i(function(){e.l()})}this.g.push(t)};var s=r.setTimeout;n.prototype.i=function(t){s(t,0)},n.prototype.l=function(){for(;this.g&&this.g.length;){var t=this.g;this.g=[];for(var e=0;e<t.length;++e){var n=t[e];t[e]=null;try{n()}catch(i){this.j(i)}}}this.g=null},n.prototype.j=function(t){this.i(function(){throw t})},e.prototype.j=function(){function t(t){return function(i){n||(n=!0,t.call(e,i))}}var e=this,n=!1;return{resolve:t(this.v),reject:t(this.l)}},e.prototype.v=function(t){if(t===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(t instanceof e)this.G(t);else{t:switch(typeof t){case"object":var n=null!=t;break t;case"function":n=!0;break t;default:n=!1}n?this.u(t):this.m(t)}},e.prototype.u=function(t){var e=void 0;try{e=t.then}catch(n){return void this.l(n)}"function"==typeof e?this.M(e,t):this.m(t)},e.prototype.l=function(t){this.s(2,t)},e.prototype.m=function(t){this.s(1,t)},e.prototype.s=function(t,e){if(0!=this.h)throw Error("Cannot settle("+t+", "+e+"): Promise already settled in state"+this.h);this.h=t,this.i=e,2===this.h&&this.F(),this.C()},e.prototype.F=function(){var t=this;s(function(){if(t.D()){var e=r.console;void 0!==e&&e.error(t.i)}},1)},e.prototype.D=function(){if(this.o)return!1;var t=r.CustomEvent,e=r.Event,n=r.dispatchEvent;return void 0===n||("function"==typeof t?t=new t("unhandledrejection",{cancelable:!0}):"function"==typeof e?t=new e("unhandledrejection",{cancelable:!0}):(t=r.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection",!1,!0,t),t.promise=this,t.reason=this.i,n(t))},e.prototype.C=function(){if(null!=this.g){for(var t=0;t<this.g.length;++t)o.h(this.g[t]);this.g=null}};var o=new n;return e.prototype.G=function(t){var e=this.j();t.H(e.resolve,e.reject)},e.prototype.M=function(t,e){var n=this.j();try{t.call(e,n.resolve,n.reject)}catch(i){n.reject(i)}},e.prototype.then=function(t,n){function i(t,e){return"function"==typeof t?function(e){try{r(t(e))}catch(n){s(n)}}:e}var r,s,o=new e(function(t,e){r=t,s=e});return this.H(i(t,r),i(n,s)),o},e.prototype.catch=function(t){return this.then(void 0,t)},e.prototype.H=function(t,e){function n(){switch(i.h){case 1:t(i.i);break;case 2:e(i.i);break;default:throw Error("Unexpected state: "+i.h)}}var i=this;null==this.g?o.h(n):this.g.push(n),this.o=!0},e.resolve=i,e.reject=function(t){return new e(function(e,n){n(t)})},e.race=function(t){return new e(function(e,n){for(var r=a(t),s=r.next();!s.done;s=r.next())i(s.value).H(e,n)})},e.all=function(t){var n=a(t),r=n.next();return r.done?i([]):new e(function(t,e){function s(e){return function(n){o[e]=n,0==--a&&t(o)}}var o=[],a=0;do{o.push(void 0),a++,i(r.value).H(s(o.length-1),e),r=n.next()}while(!r.done)})},e}),s("Array.prototype.keys",function(t){return t||function(){return function(t,e){t instanceof String&&(t+="");var n=0,i=!1,r={next:function(){return!i&&n<t.length?{value:n++,done:!1}:(i=!0,{done:!0,value:void 0})}};return r[Symbol.iterator]=function(){return r},r}(this)}});var w=this||self;function _(t,e){t=t.split(".");var n,i=w;t[0]in i||void 0===i.execScript||i.execScript("var "+t[0]);for(;t.length&&(n=t.shift());)t.length||void 0===e?i=i[n]&&i[n]!==Object.prototype[n]?i[n]:i[n]={}:i[n]=e}function S(t,e){var n=void 0;return new(n||(n=Promise))(function(i,r){function s(t){try{a(e.next(t))}catch(n){r(n)}}function o(t){try{a(e.throw(t))}catch(n){r(n)}}function a(t){t.done?i(t.value):new n(function(e){e(t.value)}).then(s,o)}a((e=e.apply(t,void 0)).next())})}var E=[[61,146],[146,91],[91,181],[181,84],[84,17],[17,314],[314,405],[405,321],[321,375],[375,291],[61,185],[185,40],[40,39],[39,37],[37,0],[0,267],[267,269],[269,270],[270,409],[409,291],[78,95],[95,88],[88,178],[178,87],[87,14],[14,317],[317,402],[402,318],[318,324],[324,308],[78,191],[191,80],[80,81],[81,82],[82,13],[13,312],[312,311],[311,310],[310,415],[415,308]],C=[[263,249],[249,390],[390,373],[373,374],[374,380],[380,381],[381,382],[382,362],[263,466],[466,388],[388,387],[387,386],[386,385],[385,384],[384,398],[398,362]],I=[[276,283],[283,282],[282,295],[295,285],[300,293],[293,334],[334,296],[296,336]],T=[[33,7],[7,163],[163,144],[144,145],[145,153],[153,154],[154,155],[155,133],[33,246],[246,161],[161,160],[160,159],[159,158],[158,157],[157,173],[173,133]],M=[[46,53],[53,52],[52,65],[65,55],[70,63],[63,105],[105,66],[66,107]],k=[[10,338],[338,297],[297,332],[332,284],[284,251],[251,389],[389,356],[356,454],[454,323],[323,361],[361,288],[288,397],[397,365],[365,379],[379,378],[378,400],[400,377],[377,152],[152,148],[148,176],[176,149],[149,150],[150,136],[136,172],[172,58],[58,132],[132,93],[93,234],[234,127],[127,162],[162,21],[21,54],[54,103],[103,67],[67,109],[109,10]],R=[].concat(l(E),l(C),l(I),l(T),l(M),l(k));function N(t,e,n){if(n=t.createShader(0===n?t.VERTEX_SHADER:t.FRAGMENT_SHADER),t.shaderSource(n,e),t.compileShader(n),!t.getShaderParameter(n,t.COMPILE_STATUS))throw Error("Could not compile WebGL shader.\n\n"+t.getShaderInfoLog(n));return n}function L(t,e){this.g=t,this.i=e,this.j=0}function D(t,e){var n=t.i;if(void 0===t.l){var i=N(n,"\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }",0),r=N(n,"\n  precision highp float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }",1),s=n.createProgram();if(n.attachShader(s,i),n.attachShader(s,r),n.linkProgram(s),!n.getProgramParameter(s,n.LINK_STATUS))throw Error("Could not compile WebGL program.\n\n"+n.getProgramInfoLog(s));i=t.l=s,n.useProgram(i),r=n.getUniformLocation(i,"sampler0"),t.h={B:n.getAttribLocation(i,"aVertex"),A:n.getAttribLocation(i,"aTex"),R:r},t.o=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,t.o),n.enableVertexAttribArray(t.h.B),n.vertexAttribPointer(t.h.B,2,n.FLOAT,!1,0,0),n.bufferData(n.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,null),t.m=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,t.m),n.enableVertexAttribArray(t.h.A),n.vertexAttribPointer(t.h.A,2,n.FLOAT,!1,0,0),n.bufferData(n.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,null),n.uniform1i(r,0)}i=t.h,n.useProgram(t.l),n.canvas.width=e.width,n.canvas.height=e.height,n.viewport(0,0,e.width,e.height),n.activeTexture(n.TEXTURE0),t.g.bindTexture2d(e.glName),n.enableVertexAttribArray(i.B),n.bindBuffer(n.ARRAY_BUFFER,t.o),n.vertexAttribPointer(i.B,2,n.FLOAT,!1,0,0),n.enableVertexAttribArray(i.A),n.bindBuffer(n.ARRAY_BUFFER,t.m),n.vertexAttribPointer(i.A,2,n.FLOAT,!1,0,0),n.bindFramebuffer(n.DRAW_FRAMEBUFFER?n.DRAW_FRAMEBUFFER:n.FRAMEBUFFER,null),n.drawArrays(n.TRIANGLE_FAN,0,4),n.disableVertexAttribArray(i.B),n.disableVertexAttribArray(i.A),n.bindBuffer(n.ARRAY_BUFFER,null),t.g.bindTexture2d(0)}function B(t){this.g=t}var O=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function P(t,e){return e+t}function F(t,e){window[t]=e}function $(t){for(var e=[],n=t.size(),i=0;i<n;++i){var r=t.get(i);e.push({x:r.x,y:r.y,z:r.z,visibility:r.hasVisibility?r.visibility:void 0})}return e}function z(t){for(var e=[],n=t.size(),i=0;i<n;++i){var r=t.get(i);e.push({index:r.index,score:r.score,label:r.hasLabel?r.label:void 0,displayName:r.hasDisplayName?r.displayName:void 0})}return e}function U(t,e,n){this.graph=t,this.locateFile=e,this.g=n}function H(t){if(this.i=t,this.listeners={},this.s={},this.j={},this.l={},this.C=this.G=!0,this.v=Promise.resolve(),this.locateFile=t&&t.locateFile||P,"object"==typeof window)t=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else{if("undefined"==typeof location)throw Error("solutions can only be loaded on a web page or in a web worker");t=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/"}this.F=t}function V(t,e,n){if(n.isNumber())return n.getNumber();if(n.isRect())return n.getRect();if(n.isLandmarks())return n.getLandmarks();if(n.isLandmarksList())return n.getLandmarksList();if(n.isClassificationsList())return n.getClassificationsList();if(n.isObjectDetectionList())return n.getObjectDetectionList();if(n.isTexture2d()){var i=t.l[e];return i||(i=new L(t.g,t.o),t.l[e]=i),D(t=i,n=n.getTexture2d()),t.i.canvas}}function G(t,e){for(var n=e.name||"$",i=[].concat(l(e.wants)),r=new t.g.StringList,s=a(e.wants),o=s.next();!o.done;o=s.next())r.push_back(o.value);s=t.g.PacketListener.implement({onResults:function(r){return S(t,function t(){var s,o,l,c,u,h=this;return A(t,function(t){if(1==t.g){for(s={},o=0;o<e.wants.length;++o)s[i[o]]=r.get(o);var d;if(d=e.outs){for(var p={},f=a(Object.keys(d)),g=f.next();!g.done;g=f.next()){var y=d[g=g.value];if("string"==typeof y)p[g]=V(h,g,s[y]);else{var v=s[y.stream];if(void 0!==v){if("detection_list"===y.type){var b=v.getRectList(),A=v.getLandmarksList();v=v.getClassificationsList();var x=[];if(b)for(var w=0;w<b.size();++w){var _={N:b.get(w),L:$(A.get(w)),K:z(v.get(w))};x.push(_)}p[g]=x}else if("landmarks"===y.type)b=v.getLandmarks(),p[g]=b?$(b):void 0;else if("landmarks_list"===y.type){if(b=v.getLandmarksList()){for(A=[],v=b.size(),x=0;x<v;++x)w=b.get(x),A.push($(w));b=A}else b=void 0;p[g]=b}else if("rect_list"===y.type){if(b=v.getRectList()){for(A=[],v=b.size(),x=0;x<v;++x)w=b.get(x),A.push(w);b=A}else b=void 0;p[g]=b}else if("classifications_list"===y.type){if(b=v.getClassificationsList()){for(A=[],v=b.size(),x=0;x<v;++x)w=b.get(x),A.push(z(w));b=A}else b=void 0;p[g]=b}else if("object_detection_list"===y.type){if(b=v.getObjectDetectionList()){for(A=[],v=b.size(),x=0;x<v;++x){var S=b.get(x);_=(w=A).push;for(var E=S.id,C=S.keypoints,I=[],T=C.size(),M=0;M<T;++M){var k=C.get(M);I.push({id:k.id,point3d:{x:k.point3d.x,y:k.point3d.y,z:k.point3d.z},point2d:{x:k.point2d.x,y:k.point2d.y,depth:k.point2d.depth}})}_.call(w,{id:E,keypoints:I,visibility:S.visibility})}b=A}else b=void 0;p[g]=b}else{if("texture"!==y.type)throw Error("Unknown output config type: '"+y.type+"'");(b=h.l[g])||(b=new L(h.g,h.o),h.l[g]=b),D(b,A=v.getTexture2d()),p[g]=b.i.canvas}y.transform&&p[g]&&(p[g]=y.transform(p[g]))}}}d=p}else d=s;return l=d,(c=h.listeners[n])?t=m(t,h.v,3):(t.g=0,t=void 0),t}if(u=c(l))return h.v=u,t.return(u);t.g=0})})}}),t.h.attachMultiListener(r,s),r.delete()}function W(t){var e=this;this.g=new H({locateFile:(t=t||{}).locateFile,files:[{url:"holistic_solution_packed_assets_loader.js"},{simd:!1,url:"holistic_solution_wasm_bin.js"},{simd:!0,url:"holistic_solution_simd_wasm_bin.js"}],graph:{url:"holistic.binarypb"},inputs:{image:{type:"video",stream:"input_frames_gpu"}},listeners:[{wants:["left_hand_landmarks","right_hand_landmarks","face_landmarks","pose_landmarks","image_transformed"],outs:{image:"image_transformed",leftHandLandmarks:{type:"landmarks",stream:"left_hand_landmarks"},rightHandLandmarks:{type:"landmarks",stream:"right_hand_landmarks"},faceLandmarks:{type:"landmarks",stream:"face_landmarks"},poseLandmarks:{type:"landmarks",stream:"pose_landmarks"}}}],options:{selfieMode:{type:1,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(t){return S(e,function e(){var n,i,r,s=this;return A(e,function(e){if(1==e.g){switch(n="",t){case 1:n="pose_landmark_full.tflite";break;case 2:n="pose_landmark_heavy.tflite";break;default:n="pose_landmark_lite.tflite"}return i="third_party/mediapipe/modules/pose_landmark/"+n,r=s.g.locateFile(n,""),m(e,fetch(r),3)}return 2!=e.g?m(e,e.i.arrayBuffer(),2):(s.g.overrideFile(i,e.i),m(e,s.g.reset(),0))})})}},smoothLandmarks:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},minDetectionConfidence:{type:0,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"holisticlandmarkgpu__poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:0,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"holisticlandmarkgpu__poselandmarkgpu__poselandmarkbyroigpu__ThresholdingCalculator",fieldName:"threshold"}}}})}U.prototype.toArrayBuffer=function(){return S(this,function t(){var e,n=this;return A(t,function(t){return 1==t.g?(n.graph.url?t=m(t,fetch(n.locateFile(n.graph.url,n.g)),3):(t.g=2,t=void 0),t):2!=t.g&&(e=t.i).body?t.return(e.arrayBuffer()):t.return(new ArrayBuffer(0))})})},(t=H.prototype).close=function(){return this.h&&this.h.delete(),Promise.resolve()},t.reset=function(){return S(this,function t(){var e=this;return A(t,function(t){e.h&&(e.h.reset(),e.j={},e.l={}),t.g=0})})},t.setOptions=function(t){var e=this;if(this.i.options){for(var n=[],i=[],r={},s=a(Object.keys(t)),o=s.next();!o.done;r={I:r.I,J:r.J},o=s.next()){var l=o.value;(!(l in this.s)||this.s[l]!==t[l])&&(this.s[l]=t[l],o=this.i.options[l])&&(o.onChange&&(r.I=o.onChange,r.J=t[l],n.push(function(t){return function(){return S(e,function e(){return A(e,function(e){return m(e,t.I(t.J),0)})})}}(r))),o.graphOptionXref&&(l={valueNumber:0===o.type?t[l]:0,valueBoolean:1===o.type&&t[l]},o=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),o.graphOptionXref),l),i.push(o)))}0===n.length&&0===i.length||(this.C=!0,this.D=i,this.u=n)}},t.initialize=function(){return S(this,function t(){var e=this;return A(t,function(t){return 1==t.g?m(t,S(e,function t(){var e,n,i,r,s,o,l,c,u=this;return A(t,function(t){switch(t.g){case 1:return e=u,u.G?(F("createMediapipeSolutionsWasm",{locateFile:u.locateFile}),F("createMediapipeSolutionsPackedAssets",{locateFile:u.locateFile}),n=u.i.files||[],m(t,function(){return S(this,function t(){return A(t,function(t){switch(t.g){case 1:return t.m=2,m(t,WebAssembly.instantiate(O),4);case 4:t.g=3,t.m=0;break;case 2:return t.m=0,t.j=null,t.return(!1);case 3:return t.return(!0)}})})}(),2)):t.return();case 2:return i=t.i,m(t,Promise.all(n.map(function(t){return void 0===t.simd||t.simd&&i||!t.simd&&!i?function(t){var e=document.createElement("script");return e.setAttribute("src",t),e.setAttribute("crossorigin","anonymous"),document.body.appendChild(e),new Promise(function(t){e.addEventListener("load",function(){t()},!1)})}(e.locateFile(t.url,e.F)):Promise.resolve()})),3);case 3:return r=window.createMediapipeSolutionsWasm,s=window.createMediapipeSolutionsPackedAssets,m(t,r(s),4);case 4:return u.g=t.i,u.m=document.createElement("canvas"),u.g.canvas=u.m,u.g.createContext(u.m,!0,!0,{}),u.h=new u.g.SolutionWasm,o=new U(u.i.graph,u.locateFile,u.F),m(t,u.loadGraph(o),5);case 5:if(u.i.listeners)for(l=a(u.i.listeners),c=l.next();!c.done;c=l.next())G(u,c.value);u.G=!1,t.g=0}})}),2):m(t,S(e,function t(){var e,n,i,r,s,o,l=this;return A(t,function(t){switch(t.g){case 1:if(!l.C)return t.return();if(!(e=l.m.getContext("webgl2"))&&!(e=l.m.getContext("webgl")))return alert("Failed to create WebGL canvas context when passing video frame."),t.return();if(l.o=e,!l.u){t.g=2;break}n=a(l.u),i=n.next();case 3:if(i.done){t.g=5;break}return m(t,(0,i.value)(),4);case 4:i=n.next(),t.g=3;break;case 5:l.u=void 0;case 2:if(l.D){for(r=new l.g.GraphOptionChangeRequestList,s=a(l.D),o=s.next();!o.done;o=s.next())r.push_back(o.value);l.h.changeOptions(r),r.delete(),l.D=void 0}l.C=!1,t.g=0}})}),0)})})},t.overrideFile=function(t,e){this.h.overrideFile(t,e)},t.clearOverriddenFiles=function(){this.h.clearOverriddenFiles()},t.loadGraph=function(t){return S(this,function e(){var n=this;return A(e,function(e){if(1==e.g)return m(e,t.toArrayBuffer(),2);n.h.loadGraph(e.i),e.g=0})})},t.send=function(t,e){return S(this,function n(){var i,r,s,o,l,c,u,h,d,p=this;return A(n,function(n){if(1==n.g)return p.i.inputs?(i=1e3*(null==e?performance.now():e),m(n,p.v,2)):n.return();if(3!=n.g)return m(n,p.initialize(),3);for(r=new p.g.PacketDataList,s=a(Object.keys(t)),o=s.next();!o.done;o=s.next())if(c=p.i.inputs[l=o.value]){t:{var f=p,g=t[l];switch(c.type){case"video":var y=f.j[c.stream];if(y||(y=new L(f.g,f.o),f.j[c.stream]=y),0===(f=y).j&&(f.j=f.g.createTexture()),g instanceof HTMLVideoElement){var v=g.videoWidth;y=g.videoHeight}else g instanceof HTMLImageElement?(v=g.naturalWidth,y=g.naturalHeight):(v=g.width,y=g.height);y={glName:f.j,width:v,height:y},(v=f.i).canvas.width=y.width,v.canvas.height=y.height,v.activeTexture(v.TEXTURE0),f.g.bindTexture2d(f.j),v.texImage2D(v.TEXTURE_2D,0,v.RGBA,v.RGBA,v.UNSIGNED_BYTE,g),f.g.bindTexture2d(0),f=y;break t;case"detections":for((y=f.j[c.stream])||(y=new B(f.g),f.j[c.stream]=y),(f=y).data||(f.data=new f.g.DetectionListData),f.data.reset(g.length),y=0;y<g.length;++y){f.data.setBoundingBox(y,(v=g[y]).N);for(var b=0;b<v.L.length;++b){var A=v.L[b],x=!!A.visibility;f.data.addNormalizedLandmark(y,Object.assign(Object.assign({},A),{hasVisibility:x,visibility:x?A.visibility:0}))}for(b=0;b<v.K.length;++b){var w=!!(A=v.K[b]).label,_=!!A.displayName;f.data.addClassification(y,{score:A.score,hasIndex:x=!!A.index,index:x?A.index:-1,hasLabel:w,label:w?A.label:"",hasDisplayName:_,displayName:_?A.displayName:""})}}f=f.data;break t;default:f={}}}switch(u=f,h=c.stream,c.type){case"video":r.pushTexture2d(Object.assign(Object.assign({},u),{stream:h,timestamp:i}));break;case"detections":(d=u).stream=h,d.timestamp=i,r.pushDetectionList(d);break;default:throw Error("Unknown input config type: '"+c.type+"'")}}p.h.send(r),r.delete(),n.g=0})})},t.onResults=function(t,e){this.listeners[e||"$"]=t},_("Solution",H),_("OptionType",{NUMBER:0,BOOL:1,0:"NUMBER",1:"BOOL"}),(t=W.prototype).close=function(){return this.g.close(),Promise.resolve()},t.onResults=function(t){this.g.onResults(t)},t.initialize=function(){return S(this,function t(){var e=this;return A(t,function(t){return m(t,e.g.initialize(),0)})})},t.reset=function(){this.g.reset()},t.send=function(t){return S(this,function e(){var n=this;return A(e,function(e){return m(e,n.g.send(t),0)})})},t.setOptions=function(t){this.g.setOptions(t)},_("Holistic",W),_("FACEMESH_LIPS",E),_("FACEMESH_LEFT_EYE",C),_("FACEMESH_LEFT_EYEBROW",I),_("FACEMESH_RIGHT_EYE",T),_("FACEMESH_RIGHT_EYEBROW",M),_("FACEMESH_FACE_OVAL",k),_("FACEMESH_CONTOURS",R),_("FACEMESH_TESSELATION",[[127,34],[34,139],[139,127],[11,0],[0,37],[37,11],[232,231],[231,120],[120,232],[72,37],[37,39],[39,72],[128,121],[121,47],[47,128],[232,121],[121,128],[128,232],[104,69],[69,67],[67,104],[175,171],[171,148],[148,175],[118,50],[50,101],[101,118],[73,39],[39,40],[40,73],[9,151],[151,108],[108,9],[48,115],[115,131],[131,48],[194,204],[204,211],[211,194],[74,40],[40,185],[185,74],[80,42],[42,183],[183,80],[40,92],[92,186],[186,40],[230,229],[229,118],[118,230],[202,212],[212,214],[214,202],[83,18],[18,17],[17,83],[76,61],[61,146],[146,76],[160,29],[29,30],[30,160],[56,157],[157,173],[173,56],[106,204],[204,194],[194,106],[135,214],[214,192],[192,135],[203,165],[165,98],[98,203],[21,71],[71,68],[68,21],[51,45],[45,4],[4,51],[144,24],[24,23],[23,144],[77,146],[146,91],[91,77],[205,50],[50,187],[187,205],[201,200],[200,18],[18,201],[91,106],[106,182],[182,91],[90,91],[91,181],[181,90],[85,84],[84,17],[17,85],[206,203],[203,36],[36,206],[148,171],[171,140],[140,148],[92,40],[40,39],[39,92],[193,189],[189,244],[244,193],[159,158],[158,28],[28,159],[247,246],[246,161],[161,247],[236,3],[3,196],[196,236],[54,68],[68,104],[104,54],[193,168],[168,8],[8,193],[117,228],[228,31],[31,117],[189,193],[193,55],[55,189],[98,97],[97,99],[99,98],[126,47],[47,100],[100,126],[166,79],[79,218],[218,166],[155,154],[154,26],[26,155],[209,49],[49,131],[131,209],[135,136],[136,150],[150,135],[47,126],[126,217],[217,47],[223,52],[52,53],[53,223],[45,51],[51,134],[134,45],[211,170],[170,140],[140,211],[67,69],[69,108],[108,67],[43,106],[106,91],[91,43],[230,119],[119,120],[120,230],[226,130],[130,247],[247,226],[63,53],[53,52],[52,63],[238,20],[20,242],[242,238],[46,70],[70,156],[156,46],[78,62],[62,96],[96,78],[46,53],[53,63],[63,46],[143,34],[34,227],[227,143],[123,117],[117,111],[111,123],[44,125],[125,19],[19,44],[236,134],[134,51],[51,236],[216,206],[206,205],[205,216],[154,153],[153,22],[22,154],[39,37],[37,167],[167,39],[200,201],[201,208],[208,200],[36,142],[142,100],[100,36],[57,212],[212,202],[202,57],[20,60],[60,99],[99,20],[28,158],[158,157],[157,28],[35,226],[226,113],[113,35],[160,159],[159,27],[27,160],[204,202],[202,210],[210,204],[113,225],[225,46],[46,113],[43,202],[202,204],[204,43],[62,76],[76,77],[77,62],[137,123],[123,116],[116,137],[41,38],[38,72],[72,41],[203,129],[129,142],[142,203],[64,98],[98,240],[240,64],[49,102],[102,64],[64,49],[41,73],[73,74],[74,41],[212,216],[216,207],[207,212],[42,74],[74,184],[184,42],[169,170],[170,211],[211,169],[170,149],[149,176],[176,170],[105,66],[66,69],[69,105],[122,6],[6,168],[168,122],[123,147],[147,187],[187,123],[96,77],[77,90],[90,96],[65,55],[55,107],[107,65],[89,90],[90,180],[180,89],[101,100],[100,120],[120,101],[63,105],[105,104],[104,63],[93,137],[137,227],[227,93],[15,86],[86,85],[85,15],[129,102],[102,49],[49,129],[14,87],[87,86],[86,14],[55,8],[8,9],[9,55],[100,47],[47,121],[121,100],[145,23],[23,22],[22,145],[88,89],[89,179],[179,88],[6,122],[122,196],[196,6],[88,95],[95,96],[96,88],[138,172],[172,136],[136,138],[215,58],[58,172],[172,215],[115,48],[48,219],[219,115],[42,80],[80,81],[81,42],[195,3],[3,51],[51,195],[43,146],[146,61],[61,43],[171,175],[175,199],[199,171],[81,82],[82,38],[38,81],[53,46],[46,225],[225,53],[144,163],[163,110],[110,144],[52,65],[65,66],[66,52],[229,228],[228,117],[117,229],[34,127],[127,234],[234,34],[107,108],[108,69],[69,107],[109,108],[108,151],[151,109],[48,64],[64,235],[235,48],[62,78],[78,191],[191,62],[129,209],[209,126],[126,129],[111,35],[35,143],[143,111],[117,123],[123,50],[50,117],[222,65],[65,52],[52,222],[19,125],[125,141],[141,19],[221,55],[55,65],[65,221],[3,195],[195,197],[197,3],[25,7],[7,33],[33,25],[220,237],[237,44],[44,220],[70,71],[71,139],[139,70],[122,193],[193,245],[245,122],[247,130],[130,33],[33,247],[71,21],[21,162],[162,71],[170,169],[169,150],[150,170],[188,174],[174,196],[196,188],[216,186],[186,92],[92,216],[2,97],[97,167],[167,2],[141,125],[125,241],[241,141],[164,167],[167,37],[37,164],[72,38],[38,12],[12,72],[38,82],[82,13],[13,38],[63,68],[68,71],[71,63],[226,35],[35,111],[111,226],[101,50],[50,205],[205,101],[206,92],[92,165],[165,206],[209,198],[198,217],[217,209],[165,167],[167,97],[97,165],[220,115],[115,218],[218,220],[133,112],[112,243],[243,133],[239,238],[238,241],[241,239],[214,135],[135,169],[169,214],[190,173],[173,133],[133,190],[171,208],[208,32],[32,171],[125,44],[44,237],[237,125],[86,87],[87,178],[178,86],[85,86],[86,179],[179,85],[84,85],[85,180],[180,84],[83,84],[84,181],[181,83],[201,83],[83,182],[182,201],[137,93],[93,132],[132,137],[76,62],[62,183],[183,76],[61,76],[76,184],[184,61],[57,61],[61,185],[185,57],[212,57],[57,186],[186,212],[214,207],[207,187],[187,214],[34,143],[143,156],[156,34],[79,239],[239,237],[237,79],[123,137],[137,177],[177,123],[44,1],[1,4],[4,44],[201,194],[194,32],[32,201],[64,102],[102,129],[129,64],[213,215],[215,138],[138,213],[59,166],[166,219],[219,59],[242,99],[99,97],[97,242],[2,94],[94,141],[141,2],[75,59],[59,235],[235,75],[24,110],[110,228],[228,24],[25,130],[130,226],[226,25],[23,24],[24,229],[229,23],[22,23],[23,230],[230,22],[26,22],[22,231],[231,26],[112,26],[26,232],[232,112],[189,190],[190,243],[243,189],[221,56],[56,190],[190,221],[28,56],[56,221],[221,28],[27,28],[28,222],[222,27],[29,27],[27,223],[223,29],[30,29],[29,224],[224,30],[247,30],[30,225],[225,247],[238,79],[79,20],[20,238],[166,59],[59,75],[75,166],[60,75],[75,240],[240,60],[147,177],[177,215],[215,147],[20,79],[79,166],[166,20],[187,147],[147,213],[213,187],[112,233],[233,244],[244,112],[233,128],[128,245],[245,233],[128,114],[114,188],[188,128],[114,217],[217,174],[174,114],[131,115],[115,220],[220,131],[217,198],[198,236],[236,217],[198,131],[131,134],[134,198],[177,132],[132,58],[58,177],[143,35],[35,124],[124,143],[110,163],[163,7],[7,110],[228,110],[110,25],[25,228],[356,389],[389,368],[368,356],[11,302],[302,267],[267,11],[452,350],[350,349],[349,452],[302,303],[303,269],[269,302],[357,343],[343,277],[277,357],[452,453],[453,357],[357,452],[333,332],[332,297],[297,333],[175,152],[152,377],[377,175],[347,348],[348,330],[330,347],[303,304],[304,270],[270,303],[9,336],[336,337],[337,9],[278,279],[279,360],[360,278],[418,262],[262,431],[431,418],[304,408],[408,409],[409,304],[310,415],[415,407],[407,310],[270,409],[409,410],[410,270],[450,348],[348,347],[347,450],[422,430],[430,434],[434,422],[313,314],[314,17],[17,313],[306,307],[307,375],[375,306],[387,388],[388,260],[260,387],[286,414],[414,398],[398,286],[335,406],[406,418],[418,335],[364,367],[367,416],[416,364],[423,358],[358,327],[327,423],[251,284],[284,298],[298,251],[281,5],[5,4],[4,281],[373,374],[374,253],[253,373],[307,320],[320,321],[321,307],[425,427],[427,411],[411,425],[421,313],[313,18],[18,421],[321,405],[405,406],[406,321],[320,404],[404,405],[405,320],[315,16],[16,17],[17,315],[426,425],[425,266],[266,426],[377,400],[400,369],[369,377],[322,391],[391,269],[269,322],[417,465],[465,464],[464,417],[386,257],[257,258],[258,386],[466,260],[260,388],[388,466],[456,399],[399,419],[419,456],[284,332],[332,333],[333,284],[417,285],[285,8],[8,417],[346,340],[340,261],[261,346],[413,441],[441,285],[285,413],[327,460],[460,328],[328,327],[355,371],[371,329],[329,355],[392,439],[439,438],[438,392],[382,341],[341,256],[256,382],[429,420],[420,360],[360,429],[364,394],[394,379],[379,364],[277,343],[343,437],[437,277],[443,444],[444,283],[283,443],[275,440],[440,363],[363,275],[431,262],[262,369],[369,431],[297,338],[338,337],[337,297],[273,375],[375,321],[321,273],[450,451],[451,349],[349,450],[446,342],[342,467],[467,446],[293,334],[334,282],[282,293],[458,461],[461,462],[462,458],[276,353],[353,383],[383,276],[308,324],[324,325],[325,308],[276,300],[300,293],[293,276],[372,345],[345,447],[447,372],[352,345],[345,340],[340,352],[274,1],[1,19],[19,274],[456,248],[248,281],[281,456],[436,427],[427,425],[425,436],[381,256],[256,252],[252,381],[269,391],[391,393],[393,269],[200,199],[199,428],[428,200],[266,330],[330,329],[329,266],[287,273],[273,422],[422,287],[250,462],[462,328],[328,250],[258,286],[286,384],[384,258],[265,353],[353,342],[342,265],[387,259],[259,257],[257,387],[424,431],[431,430],[430,424],[342,353],[353,276],[276,342],[273,335],[335,424],[424,273],[292,325],[325,307],[307,292],[366,447],[447,345],[345,366],[271,303],[303,302],[302,271],[423,266],[266,371],[371,423],[294,455],[455,460],[460,294],[279,278],[278,294],[294,279],[271,272],[272,304],[304,271],[432,434],[434,427],[427,432],[272,407],[407,408],[408,272],[394,430],[430,431],[431,394],[395,369],[369,400],[400,395],[334,333],[333,299],[299,334],[351,417],[417,168],[168,351],[352,280],[280,411],[411,352],[325,319],[319,320],[320,325],[295,296],[296,336],[336,295],[319,403],[403,404],[404,319],[330,348],[348,349],[349,330],[293,298],[298,333],[333,293],[323,454],[454,447],[447,323],[15,16],[16,315],[315,15],[358,429],[429,279],[279,358],[14,15],[15,316],[316,14],[285,336],[336,9],[9,285],[329,349],[349,350],[350,329],[374,380],[380,252],[252,374],[318,402],[402,403],[403,318],[6,197],[197,419],[419,6],[318,319],[319,325],[325,318],[367,364],[364,365],[365,367],[435,367],[367,397],[397,435],[344,438],[438,439],[439,344],[272,271],[271,311],[311,272],[195,5],[5,281],[281,195],[273,287],[287,291],[291,273],[396,428],[428,199],[199,396],[311,271],[271,268],[268,311],[283,444],[444,445],[445,283],[373,254],[254,339],[339,373],[282,334],[334,296],[296,282],[449,347],[347,346],[346,449],[264,447],[447,454],[454,264],[336,296],[296,299],[299,336],[338,10],[10,151],[151,338],[278,439],[439,455],[455,278],[292,407],[407,415],[415,292],[358,371],[371,355],[355,358],[340,345],[345,372],[372,340],[346,347],[347,280],[280,346],[442,443],[443,282],[282,442],[19,94],[94,370],[370,19],[441,442],[442,295],[295,441],[248,419],[419,197],[197,248],[263,255],[255,359],[359,263],[440,275],[275,274],[274,440],[300,383],[383,368],[368,300],[351,412],[412,465],[465,351],[263,467],[467,466],[466,263],[301,368],[368,389],[389,301],[395,378],[378,379],[379,395],[412,351],[351,419],[419,412],[436,426],[426,322],[322,436],[2,164],[164,393],[393,2],[370,462],[462,461],[461,370],[164,0],[0,267],[267,164],[302,11],[11,12],[12,302],[268,12],[12,13],[13,268],[293,300],[300,301],[301,293],[446,261],[261,340],[340,446],[330,266],[266,425],[425,330],[426,423],[423,391],[391,426],[429,355],[355,437],[437,429],[391,327],[327,326],[326,391],[440,457],[457,438],[438,440],[341,382],[382,362],[362,341],[459,457],[457,461],[461,459],[434,430],[430,394],[394,434],[414,463],[463,362],[362,414],[396,369],[369,262],[262,396],[354,461],[461,457],[457,354],[316,403],[403,402],[402,316],[315,404],[404,403],[403,315],[314,405],[405,404],[404,314],[313,406],[406,405],[405,313],[421,418],[418,406],[406,421],[366,401],[401,361],[361,366],[306,408],[408,407],[407,306],[291,409],[409,408],[408,291],[287,410],[410,409],[409,287],[432,436],[436,410],[410,432],[434,416],[416,411],[411,434],[264,368],[368,383],[383,264],[309,438],[438,457],[457,309],[352,376],[376,401],[401,352],[274,275],[275,4],[4,274],[421,428],[428,262],[262,421],[294,327],[327,358],[358,294],[433,416],[416,367],[367,433],[289,455],[455,439],[439,289],[462,370],[370,326],[326,462],[2,326],[326,370],[370,2],[305,460],[460,455],[455,305],[254,449],[449,448],[448,254],[255,261],[261,446],[446,255],[253,450],[450,449],[449,253],[252,451],[451,450],[450,252],[256,452],[452,451],[451,256],[341,453],[453,452],[452,341],[413,464],[464,463],[463,413],[441,413],[413,414],[414,441],[258,442],[442,441],[441,258],[257,443],[443,442],[442,257],[259,444],[444,443],[443,259],[260,445],[445,444],[444,260],[467,342],[342,445],[445,467],[459,458],[458,250],[250,459],[289,392],[392,290],[290,289],[290,328],[328,460],[460,290],[376,433],[433,435],[435,376],[250,290],[290,392],[392,250],[411,416],[416,433],[433,411],[341,463],[463,464],[464,341],[453,464],[464,465],[465,453],[357,465],[465,412],[412,357],[343,412],[412,399],[399,343],[360,363],[363,440],[440,360],[437,399],[399,456],[456,437],[420,456],[456,363],[363,420],[401,435],[435,288],[288,401],[372,383],[383,353],[353,372],[339,255],[255,249],[249,339],[448,261],[261,255],[255,448],[133,243],[243,190],[190,133],[133,155],[155,112],[112,133],[33,246],[246,247],[247,33],[33,130],[130,25],[25,33],[398,384],[384,286],[286,398],[362,398],[398,414],[414,362],[362,463],[463,341],[341,362],[263,359],[359,467],[467,263],[263,249],[249,255],[255,263],[466,467],[467,260],[260,466],[75,60],[60,166],[166,75],[238,239],[239,79],[79,238],[162,127],[127,139],[139,162],[72,11],[11,37],[37,72],[121,232],[232,120],[120,121],[73,72],[72,39],[39,73],[114,128],[128,47],[47,114],[233,232],[232,128],[128,233],[103,104],[104,67],[67,103],[152,175],[175,148],[148,152],[119,118],[118,101],[101,119],[74,73],[73,40],[40,74],[107,9],[9,108],[108,107],[49,48],[48,131],[131,49],[32,194],[194,211],[211,32],[184,74],[74,185],[185,184],[191,80],[80,183],[183,191],[185,40],[40,186],[186,185],[119,230],[230,118],[118,119],[210,202],[202,214],[214,210],[84,83],[83,17],[17,84],[77,76],[76,146],[146,77],[161,160],[160,30],[30,161],[190,56],[56,173],[173,190],[182,106],[106,194],[194,182],[138,135],[135,192],[192,138],[129,203],[203,98],[98,129],[54,21],[21,68],[68,54],[5,51],[51,4],[4,5],[145,144],[144,23],[23,145],[90,77],[77,91],[91,90],[207,205],[205,187],[187,207],[83,201],[201,18],[18,83],[181,91],[91,182],[182,181],[180,90],[90,181],[181,180],[16,85],[85,17],[17,16],[205,206],[206,36],[36,205],[176,148],[148,140],[140,176],[165,92],[92,39],[39,165],[245,193],[193,244],[244,245],[27,159],[159,28],[28,27],[30,247],[247,161],[161,30],[174,236],[236,196],[196,174],[103,54],[54,104],[104,103],[55,193],[193,8],[8,55],[111,117],[117,31],[31,111],[221,189],[189,55],[55,221],[240,98],[98,99],[99,240],[142,126],[126,100],[100,142],[219,166],[166,218],[218,219],[112,155],[155,26],[26,112],[198,209],[209,131],[131,198],[169,135],[135,150],[150,169],[114,47],[47,217],[217,114],[224,223],[223,53],[53,224],[220,45],[45,134],[134,220],[32,211],[211,140],[140,32],[109,67],[67,108],[108,109],[146,43],[43,91],[91,146],[231,230],[230,120],[120,231],[113,226],[226,247],[247,113],[105,63],[63,52],[52,105],[241,238],[238,242],[242,241],[124,46],[46,156],[156,124],[95,78],[78,96],[96,95],[70,46],[46,63],[63,70],[116,143],[143,227],[227,116],[116,123],[123,111],[111,116],[1,44],[44,19],[19,1],[3,236],[236,51],[51,3],[207,216],[216,205],[205,207],[26,154],[154,22],[22,26],[165,39],[39,167],[167,165],[199,200],[200,208],[208,199],[101,36],[36,100],[100,101],[43,57],[57,202],[202,43],[242,20],[20,99],[99,242],[56,28],[28,157],[157,56],[124,35],[35,113],[113,124],[29,160],[160,27],[27,29],[211,204],[204,210],[210,211],[124,113],[113,46],[46,124],[106,43],[43,204],[204,106],[96,62],[62,77],[77,96],[227,137],[137,116],[116,227],[73,41],[41,72],[72,73],[36,203],[203,142],[142,36],[235,64],[64,240],[240,235],[48,49],[49,64],[64,48],[42,41],[41,74],[74,42],[214,212],[212,207],[207,214],[183,42],[42,184],[184,183],[210,169],[169,211],[211,210],[140,170],[170,176],[176,140],[104,105],[105,69],[69,104],[193,122],[122,168],[168,193],[50,123],[123,187],[187,50],[89,96],[96,90],[90,89],[66,65],[65,107],[107,66],[179,89],[89,180],[180,179],[119,101],[101,120],[120,119],[68,63],[63,104],[104,68],[234,93],[93,227],[227,234],[16,15],[15,85],[85,16],[209,129],[129,49],[49,209],[15,14],[14,86],[86,15],[107,55],[55,9],[9,107],[120,100],[100,121],[121,120],[153,145],[145,22],[22,153],[178,88],[88,179],[179,178],[197,6],[6,196],[196,197],[89,88],[88,96],[96,89],[135,138],[138,136],[136,135],[138,215],[215,172],[172,138],[218,115],[115,219],[219,218],[41,42],[42,81],[81,41],[5,195],[195,51],[51,5],[57,43],[43,61],[61,57],[208,171],[171,199],[199,208],[41,81],[81,38],[38,41],[224,53],[53,225],[225,224],[24,144],[144,110],[110,24],[105,52],[52,66],[66,105],[118,229],[229,117],[117,118],[227,34],[34,234],[234,227],[66,107],[107,69],[69,66],[10,109],[109,151],[151,10],[219,48],[48,235],[235,219],[183,62],[62,191],[191,183],[142,129],[129,126],[126,142],[116,111],[111,143],[143,116],[118,117],[117,50],[50,118],[223,222],[222,52],[52,223],[94,19],[19,141],[141,94],[222,221],[221,65],[65,222],[196,3],[3,197],[197,196],[45,220],[220,44],[44,45],[156,70],[70,139],[139,156],[188,122],[122,245],[245,188],[139,71],[71,162],[162,139],[149,170],[170,150],[150,149],[122,188],[188,196],[196,122],[206,216],[216,92],[92,206],[164,2],[2,167],[167,164],[242,141],[141,241],[241,242],[0,164],[164,37],[37,0],[11,72],[72,12],[12,11],[12,38],[38,13],[13,12],[70,63],[63,71],[71,70],[31,226],[226,111],[111,31],[36,101],[101,205],[205,36],[203,206],[206,165],[165,203],[126,209],[209,217],[217,126],[98,165],[165,97],[97,98],[237,220],[220,218],[218,237],[237,239],[239,241],[241,237],[210,214],[214,169],[169,210],[140,171],[171,32],[32,140],[241,125],[125,237],[237,241],[179,86],[86,178],[178,179],[180,85],[85,179],[179,180],[181,84],[84,180],[180,181],[182,83],[83,181],[181,182],[194,201],[201,182],[182,194],[177,137],[137,132],[132,177],[184,76],[76,183],[183,184],[185,61],[61,184],[184,185],[186,57],[57,185],[185,186],[216,212],[212,186],[186,216],[192,214],[214,187],[187,192],[139,34],[34,156],[156,139],[218,79],[79,237],[237,218],[147,123],[123,177],[177,147],[45,44],[44,4],[4,45],[208,201],[201,32],[32,208],[98,64],[64,129],[129,98],[192,213],[213,138],[138,192],[235,59],[59,219],[219,235],[141,242],[242,97],[97,141],[97,2],[2,141],[141,97],[240,75],[75,235],[235,240],[229,24],[24,228],[228,229],[31,25],[25,226],[226,31],[230,23],[23,229],[229,230],[231,22],[22,230],[230,231],[232,26],[26,231],[231,232],[233,112],[112,232],[232,233],[244,189],[189,243],[243,244],[189,221],[221,190],[190,189],[222,28],[28,221],[221,222],[223,27],[27,222],[222,223],[224,29],[29,223],[223,224],[225,30],[30,224],[224,225],[113,247],[247,225],[225,113],[99,60],[60,240],[240,99],[213,147],[147,215],[215,213],[60,20],[20,166],[166,60],[192,187],[187,213],[213,192],[243,112],[112,244],[244,243],[244,233],[233,245],[245,244],[245,128],[128,188],[188,245],[188,114],[114,174],[174,188],[134,131],[131,220],[220,134],[174,217],[217,236],[236,174],[236,198],[198,134],[134,236],[215,177],[177,58],[58,215],[156,143],[143,124],[124,156],[25,110],[110,7],[7,25],[31,228],[228,25],[25,31],[264,356],[356,368],[368,264],[0,11],[11,267],[267,0],[451,452],[452,349],[349,451],[267,302],[302,269],[269,267],[350,357],[357,277],[277,350],[350,452],[452,357],[357,350],[299,333],[333,297],[297,299],[396,175],[175,377],[377,396],[280,347],[347,330],[330,280],[269,303],[303,270],[270,269],[151,9],[9,337],[337,151],[344,278],[278,360],[360,344],[424,418],[418,431],[431,424],[270,304],[304,409],[409,270],[272,310],[310,407],[407,272],[322,270],[270,410],[410,322],[449,450],[450,347],[347,449],[432,422],[422,434],[434,432],[18,313],[313,17],[17,18],[291,306],[306,375],[375,291],[259,387],[387,260],[260,259],[424,335],[335,418],[418,424],[434,364],[364,416],[416,434],[391,423],[423,327],[327,391],[301,251],[251,298],[298,301],[275,281],[281,4],[4,275],[254,373],[373,253],[253,254],[375,307],[307,321],[321,375],[280,425],[425,411],[411,280],[200,421],[421,18],[18,200],[335,321],[321,406],[406,335],[321,320],[320,405],[405,321],[314,315],[315,17],[17,314],[423,426],[426,266],[266,423],[396,377],[377,369],[369,396],[270,322],[322,269],[269,270],[413,417],[417,464],[464,413],[385,386],[386,258],[258,385],[248,456],[456,419],[419,248],[298,284],[284,333],[333,298],[168,417],[417,8],[8,168],[448,346],[346,261],[261,448],[417,413],[413,285],[285,417],[326,327],[327,328],[328,326],[277,355],[355,329],[329,277],[309,392],[392,438],[438,309],[381,382],[382,256],[256,381],[279,429],[429,360],[360,279],[365,364],[364,379],[379,365],[355,277],[277,437],[437,355],[282,443],[443,283],[283,282],[281,275],[275,363],[363,281],[395,431],[431,369],[369,395],[299,297],[297,337],[337,299],[335,273],[273,321],[321,335],[348,450],[450,349],[349,348],[359,446],[446,467],[467,359],[283,293],[293,282],[282,283],[250,458],[458,462],[462,250],[300,276],[276,383],[383,300],[292,308],[308,325],[325,292],[283,276],[276,293],[293,283],[264,372],[372,447],[447,264],[346,352],[352,340],[340,346],[354,274],[274,19],[19,354],[363,456],[456,281],[281,363],[426,436],[436,425],[425,426],[380,381],[381,252],[252,380],[267,269],[269,393],[393,267],[421,200],[200,428],[428,421],[371,266],[266,329],[329,371],[432,287],[287,422],[422,432],[290,250],[250,328],[328,290],[385,258],[258,384],[384,385],[446,265],[265,342],[342,446],[386,387],[387,257],[257,386],[422,424],[424,430],[430,422],[445,342],[342,276],[276,445],[422,273],[273,424],[424,422],[306,292],[292,307],[307,306],[352,366],[366,345],[345,352],[268,271],[271,302],[302,268],[358,423],[423,371],[371,358],[327,294],[294,460],[460,327],[331,279],[279,294],[294,331],[303,271],[271,304],[304,303],[436,432],[432,427],[427,436],[304,272],[272,408],[408,304],[395,394],[394,431],[431,395],[378,395],[395,400],[400,378],[296,334],[334,299],[299,296],[6,351],[351,168],[168,6],[376,352],[352,411],[411,376],[307,325],[325,320],[320,307],[285,295],[295,336],[336,285],[320,319],[319,404],[404,320],[329,330],[330,349],[349,329],[334,293],[293,333],[333,334],[366,323],[323,447],[447,366],[316,15],[15,315],[315,316],[331,358],[358,279],[279,331],[317,14],[14,316],[316,317],[8,285],[285,9],[9,8],[277,329],[329,350],[350,277],[253,374],[374,252],[252,253],[319,318],[318,403],[403,319],[351,6],[6,419],[419,351],[324,318],[318,325],[325,324],[397,367],[367,365],[365,397],[288,435],[435,397],[397,288],[278,344],[344,439],[439,278],[310,272],[272,311],[311,310],[248,195],[195,281],[281,248],[375,273],[273,291],[291,375],[175,396],[396,199],[199,175],[312,311],[311,268],[268,312],[276,283],[283,445],[445,276],[390,373],[373,339],[339,390],[295,282],[282,296],[296,295],[448,449],[449,346],[346,448],[356,264],[264,454],[454,356],[337,336],[336,299],[299,337],[337,338],[338,151],[151,337],[294,278],[278,455],[455,294],[308,292],[292,415],[415,308],[429,358],[358,355],[355,429],[265,340],[340,372],[372,265],[352,346],[346,280],[280,352],[295,442],[442,282],[282,295],[354,19],[19,370],[370,354],[285,441],[441,295],[295,285],[195,248],[248,197],[197,195],[457,440],[440,274],[274,457],[301,300],[300,368],[368,301],[417,351],[351,465],[465,417],[251,301],[301,389],[389,251],[394,395],[395,379],[379,394],[399,412],[412,419],[419,399],[410,436],[436,322],[322,410],[326,2],[2,393],[393,326],[354,370],[370,461],[461,354],[393,164],[164,267],[267,393],[268,302],[302,12],[12,268],[312,268],[268,13],[13,312],[298,293],[293,301],[301,298],[265,446],[446,340],[340,265],[280,330],[330,425],[425,280],[322,426],[426,391],[391,322],[420,429],[429,437],[437,420],[393,391],[391,326],[326,393],[344,440],[440,438],[438,344],[458,459],[459,461],[461,458],[364,434],[434,394],[394,364],[428,396],[396,262],[262,428],[274,354],[354,457],[457,274],[317,316],[316,402],[402,317],[316,315],[315,403],[403,316],[315,314],[314,404],[404,315],[314,313],[313,405],[405,314],[313,421],[421,406],[406,313],[323,366],[366,361],[361,323],[292,306],[306,407],[407,292],[306,291],[291,408],[408,306],[291,287],[287,409],[409,291],[287,432],[432,410],[410,287],[427,434],[434,411],[411,427],[372,264],[264,383],[383,372],[459,309],[309,457],[457,459],[366,352],[352,401],[401,366],[1,274],[274,4],[4,1],[418,421],[421,262],[262,418],[331,294],[294,358],[358,331],[435,433],[433,367],[367,435],[392,289],[289,439],[439,392],[328,462],[462,326],[326,328],[94,2],[2,370],[370,94],[289,305],[305,455],[455,289],[339,254],[254,448],[448,339],[359,255],[255,446],[446,359],[254,253],[253,449],[449,254],[253,252],[252,450],[450,253],[252,256],[256,451],[451,252],[256,341],[341,452],[452,256],[414,413],[413,463],[463,414],[286,441],[441,414],[414,286],[286,258],[258,441],[441,286],[258,257],[257,442],[442,258],[257,259],[259,443],[443,257],[259,260],[260,444],[444,259],[260,467],[467,445],[445,260],[309,459],[459,250],[250,309],[305,289],[289,290],[290,305],[305,290],[290,460],[460,305],[401,376],[376,435],[435,401],[309,250],[250,392],[392,309],[376,411],[411,433],[433,376],[453,341],[341,464],[464,453],[357,453],[453,465],[465,357],[343,357],[357,412],[412,343],[437,343],[343,399],[399,437],[344,360],[360,440],[440,344],[420,437],[437,456],[456,420],[360,420],[420,363],[363,360],[361,401],[401,288],[288,361],[265,372],[372,353],[353,265],[390,339],[339,249],[249,390],[339,448],[448,255],[255,339]]),_("HAND_CONNECTIONS",[[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[0,17],[17,18],[18,19],[19,20]]),_("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),_("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),_("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),_("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),_("POSE_LANDMARKS_NEUTRAL",{NOSE:0})}).call(this)},EUkQ:function(t,e){function n(t){return t&&t.constructor&&"function"==typeof t.constructor.isBuffer&&t.constructor.isBuffer(t)}function i(t){return t}function r(t,e){const r=(e=e||{}).delimiter||".",s=e.maxDepth,o=e.transformKey||i,a={};return function t(i,l,c){c=c||1,Object.keys(i).forEach(function(u){const h=i[u],d=e.safe&&Array.isArray(h),p=Object.prototype.toString.call(h),f=n(h),m="[object Object]"===p||"[object Array]"===p,g=l?l+r+o(u):o(u);if(!d&&!f&&m&&Object.keys(h).length&&(!e.maxDepth||c<s))return t(h,g,c+1);a[g]=h})}(t),a}t.exports=r,r.flatten=r,r.unflatten=function t(e,s){const o=(s=s||{}).delimiter||".",a=s.overwrite||!1,l=s.transformKey||i,c={};if(n(e)||"[object Object]"!==Object.prototype.toString.call(e))return e;function u(t){const e=Number(t);return isNaN(e)||-1!==t.indexOf(".")||s.object?t:e}return e=Object.keys(e).reduce(function(t,n){const i=Object.prototype.toString.call(e[n]);return"[object Object]"!==i&&"[object Array]"!==i||function(t){const e=Object.prototype.toString.call(t);return!t||("[object Array]"===e?!t.length:"[object Object]"===e?!Object.keys(t).length:void 0)}(e[n])?(t[n]=e[n],t):function(t,e,n){return Object.keys(n).reduce(function(e,i){return e[t+o+i]=n[i],e},e)}(n,t,r(e[n],s))},{}),Object.keys(e).forEach(function(n){const i=n.split(o).map(l);let r=u(i.shift()),h=u(i[0]),d=c;for(;void 0!==h;){if("__proto__"===r)return;const t=Object.prototype.toString.call(d[r]),e="[object Object]"===t||"[object Array]"===t;if(!a&&!e&&void 0!==d[r])return;(a&&!e||!a&&null==d[r])&&(d[r]="number"!=typeof h||s.object?{}:[]),d=d[r],i.length>0&&(r=u(i.shift()),h=u(i[0]))}d[r]=t(e[n],s)}),c}},EhIR:function(t,e,n){(function(t){var i;!function(t,r,s){function o(t){var e,n=this,i=(e=4022871197,function(t){t=t.toString();for(var n=0;n<t.length;n++){var i=.02519603282416938*(e+=t.charCodeAt(n));i-=e=i>>>0,e=(i*=e)>>>0,e+=4294967296*(i-=e)}return 2.3283064365386963e-10*(e>>>0)});n.next=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=i(" "),n.s1=i(" "),n.s2=i(" "),n.s0-=i(t),n.s0<0&&(n.s0+=1),n.s1-=i(t),n.s1<0&&(n.s1+=1),n.s2-=i(t),n.s2<0&&(n.s2+=1),i=null}function a(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function l(t,e){var n=new o(t),i=e&&e.state,r=n.next;return r.int32=function(){return 4294967296*n.next()|0},r.double=function(){return r()+11102230246251565e-32*(2097152*r()|0)},r.quick=r,i&&("object"==typeof i&&a(i,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(i=(function(){return l}).call(e,n,e,r))||(r.exports=i):this.alea=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},MZFn:function(t,e,n){var i;t.exports=((i=function(){function t(t){return r.appendChild(t.dom),t}function e(t){for(var e=0;e<r.children.length;e++)r.children[e].style.display=e===t?"block":"none";n=t}var n=0,r=document.createElement("div");r.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",r.addEventListener("click",function(t){t.preventDefault(),e(++n%r.children.length)},!1);var s=(performance||Date).now(),o=s,a=0,l=t(new i.Panel("FPS","#0ff","#002")),c=t(new i.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var u=t(new i.Panel("MB","#f08","#201"));return e(0),{REVISION:16,dom:r,addPanel:t,showPanel:e,begin:function(){s=(performance||Date).now()},end:function(){a++;var t=(performance||Date).now();if(c.update(t-s,200),t>o+1e3&&(l.update(1e3*a/(t-o),100),o=t,a=0,u)){var e=performance.memory;u.update(e.usedJSHeapSize/1048576,e.jsHeapSizeLimit/1048576)}return t},update:function(){s=this.end()},domElement:r,setMode:e}}).Panel=function(t,e,n){var i=1/0,r=0,s=Math.round,o=s(window.devicePixelRatio||1),a=80*o,l=48*o,c=3*o,u=2*o,h=3*o,d=15*o,p=74*o,f=30*o,m=document.createElement("canvas");m.width=a,m.height=l,m.style.cssText="width:80px;height:48px";var g=m.getContext("2d");return g.font="bold "+9*o+"px Helvetica,Arial,sans-serif",g.textBaseline="top",g.fillStyle=n,g.fillRect(0,0,a,l),g.fillStyle=e,g.fillText(t,c,u),g.fillRect(h,d,p,f),g.fillStyle=n,g.globalAlpha=.9,g.fillRect(h,d,p,f),{dom:m,update:function(l,y){i=Math.min(i,l),r=Math.max(r,l),g.fillStyle=n,g.globalAlpha=1,g.fillRect(0,0,a,d),g.fillStyle=e,g.fillText(s(l)+" "+t+" ("+s(i)+"-"+s(r)+")",c,u),g.drawImage(m,h+o,d,p-o,f,h,d,p-o,f),g.fillRect(h+p-o,d,o,f),g.fillStyle=n,g.globalAlpha=.9,g.fillRect(h+p-o,d,o,s((1-l/y)*f))}}},i)},PDX0:function(t,e){(function(e){t.exports=e}).call(this,{})},PkQR:function(t,e,n){(function(t){var i;!function(t,r,s){function o(t){var e=this;e.next=function(){var t,n,i=e.x,r=e.i;return t=i[r],n=(t^=t>>>7)^t<<24,n^=(t=i[r+1&7])^t>>>10,n^=(t=i[r+3&7])^t>>>3,n^=(t=i[r+4&7])^t<<7,t=i[r+7&7],i[r]=n^=(t^=t<<13)^t<<9,e.i=r+1&7,n},function(t,e){var n,i=[];if(e===(0|e))i[0]=e;else for(e=""+e,n=0;n<e.length;++n)i[7&n]=i[7&n]<<15^e.charCodeAt(n)+i[n+1&7]<<13;for(;i.length<8;)i.push(0);for(n=0;n<8&&0===i[n];++n);for(8==n&&(i[7]=-1),t.x=i,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function a(t,e){return e.x=t.x.slice(),e.i=t.i,e}function l(t,e){null==t&&(t=+new Date);var n=new o(t),i=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,i&&(i.x&&a(i,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(i=(function(){return l}).call(e,n,e,r))||(r.exports=i):this.xorshift7=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},U0tu:function(t,e,n){var i={"./pose-viewer.entry.js":["ouXD",99]};function r(t){if(!n.o(i,t))return Promise.resolve().then(function(){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e});var e=i[t],r=e[0];return n.e(e[1]).then(function(){return n(r)})}r.keys=function(){return Object.keys(i)},r.id="U0tu",t.exports=r},VcDv:function(t,e,n){"use strict";n.d(e,"a",function(){return g}),n.d(e,"b",function(){return O}),n.d(e,"c",function(){return _}),n.d(e,"d",function(){return w}),n.d(e,"e",function(){return f}),n.d(e,"f",function(){return c}),n.d(e,"g",function(){return $});let i,r,s=!1;const o="undefined"!=typeof window?window:{},a=o.document||{head:{}},l={$flags$:0,$resourcesUrl$:"",jmp:t=>t(),raf:t=>requestAnimationFrame(t),ael:(t,e,n,i)=>t.addEventListener(e,n,i),rel:(t,e,n,i)=>t.removeEventListener(e,n,i),ce:(t,e)=>new CustomEvent(t,e)},c=t=>Promise.resolve(t),u=(()=>{try{return new CSSStyleSheet,"function"==typeof(new CSSStyleSheet).replace}catch(t){}return!1})(),h=new WeakMap,d=(t,e)=>"sc-"+t.$tagName$,p=t=>"object"==(t=typeof t)||"function"===t,f=(t,e,...n)=>{let i=null,r=!1,s=!1,o=[];const a=e=>{for(let n=0;n<e.length;n++)i=e[n],Array.isArray(i)?a(i):null!=i&&"boolean"!=typeof i&&((r="function"!=typeof t&&!p(i))&&(i=String(i)),r&&s?o[o.length-1].$text$+=i:o.push(r?m(null,i):i),s=r)};a(n);const l=m(t,null);return l.$attrs$=e,o.length>0&&(l.$children$=o),l},m=(t,e)=>({$flags$:0,$tag$:t,$text$:e,$elm$:null,$children$:null}),g={},y=(t,e,n,r)=>{let s,o,l=e.$children$[n],c=0;if(null!==l.$text$)s=l.$elm$=a.createTextNode(l.$text$);else if(s=l.$elm$=a.createElement(l.$tag$),null!=i&&s["s-si"]!==i&&s.classList.add(s["s-si"]=i),l.$children$)for(c=0;c<l.$children$.length;++c)o=y(t,l,c),o&&s.appendChild(o);return s},v=(t,e,n,i,s,o)=>{let a,l=t;for(l.shadowRoot&&l.tagName===r&&(l=l.shadowRoot);s<=o;++s)i[s]&&(a=y(null,n,s),a&&(i[s].$elm$=a,l.insertBefore(a,e)))},b=(t,e,n,i,r)=>{for(;e<=n;++e)(i=t[e])&&i.$elm$.remove()},A=(t,e)=>t.$tag$===e.$tag$,x=(t,e)=>{const n=e.$elm$=t.$elm$,i=t.$children$,r=e.$children$,s=e.$text$;null===s?null!==i&&null!==r?((t,e,n,i)=>{let r,s=0,o=0,a=e.length-1,l=e[0],c=e[a],u=i.length-1,h=i[0],d=i[u];for(;s<=a&&o<=u;)null==l?l=e[++s]:null==c?c=e[--a]:null==h?h=i[++o]:null==d?d=i[--u]:A(l,h)?(x(l,h),l=e[++s],h=i[++o]):A(c,d)?(x(c,d),c=e[--a],d=i[--u]):A(l,d)?(x(l,d),t.insertBefore(l.$elm$,c.$elm$.nextSibling),l=e[++s],d=i[--u]):A(c,h)?(x(c,h),t.insertBefore(c.$elm$,l.$elm$),c=e[--a],h=i[++o]):(r=y(e&&e[o],n,o),h=i[++o],r&&l.$elm$.parentNode.insertBefore(r,l.$elm$));s>a?v(t,null==i[u+1]?null:i[u+1].$elm$,n,i,o,u):o>u&&b(e,s,a)})(n,i,e,r):null!==r?(null!==t.$text$&&(n.textContent=""),v(n,null,e,r,0,r.length-1)):null!==i&&b(i,0,i.length-1):t.$text$!==s&&(n.data=s)},w=t=>F(t).$hostElement$,_=(t,e,n)=>{const i=w(t);return{emit:t=>S(i,e,{bubbles:!!(4&n),composed:!!(2&n),cancelable:!!(1&n),detail:t})}},S=(t,e,n)=>{const i=l.ce(e,n);return t.dispatchEvent(i),i},E=(t,e)=>{e&&!t.$onRenderResolve$&&e["s-p"]&&e["s-p"].push(new Promise(e=>t.$onRenderResolve$=e))},C=(t,e)=>{if(t.$flags$|=16,!(4&t.$flags$))return E(t,t.$ancestorComponent$),K(()=>I(t,e));t.$flags$|=512},I=(t,e)=>{const n=t.$lazyInstance$;let i;return e&&(i=N(n,"componentWillLoad")),L(i,()=>T(t,n,e))},T=async(t,e,n)=>{const i=t.$hostElement$,r=i["s-rc"];n&&(t=>{const e=t.$cmpMeta$,n=t.$hostElement$,i=e.$flags$,r=((t,e,n,i)=>{let r=d(e),s=G.get(r);if(t=11===t.nodeType?t:a,s)if("string"==typeof s){let e,n=h.get(t=t.head||t);n||h.set(t,n=new Set),n.has(r)||(e=a.createElement("style"),e.innerHTML=s,t.insertBefore(e,t.querySelector("link")),n&&n.add(r))}else t.adoptedStyleSheets.includes(s)||(t.adoptedStyleSheets=[...t.adoptedStyleSheets,s]);return r})(n.shadowRoot?n.shadowRoot:n.getRootNode(),e);10&i&&(n["s-sc"]=r,n.classList.add(r+"-h"))})(t),M(t,e),r&&(r.map(t=>t()),i["s-rc"]=void 0);{const e=i["s-p"],n=()=>k(t);0===e.length?n():(Promise.all(e).then(n),t.$flags$|=4,e.length=0)}},M=(t,e,n)=>{try{e=e.render(),t.$flags$&=-17,t.$flags$|=2,((t,e)=>{const n=t.$hostElement$,s=t.$vnode$||m(null,null),o=(a=e)&&a.$tag$===g?e:f(null,null,e);var a;r=n.tagName,o.$tag$=null,o.$flags$|=4,t.$vnode$=o,o.$elm$=s.$elm$=n.shadowRoot||n,i=n["s-sc"],x(s,o)})(t,e)}catch(s){U(s,t.$hostElement$)}return null},k=t=>{const e=t.$hostElement$,n=t.$lazyInstance$,i=t.$ancestorComponent$;64&t.$flags$||(t.$flags$|=64,D(e),N(n,"componentDidLoad"),t.$onReadyResolve$(e),i||R()),t.$onInstanceResolve$(e),t.$onRenderResolve$&&(t.$onRenderResolve$(),t.$onRenderResolve$=void 0),512&t.$flags$&&Y(()=>C(t,!1)),t.$flags$&=-517},R=t=>{D(a.documentElement),Y(()=>S(o,"appload",{detail:{namespace:"pose-viewer"}}))},N=(t,e,n)=>{if(t&&t[e])try{return t[e](n)}catch(i){U(i)}},L=(t,e)=>t&&t.then?t.then(e):e(),D=t=>t.classList.add("hydrated"),B=(t,e,n)=>{if(e.$members$){t.watchers&&(e.$watchers$=t.watchers);const i=Object.entries(e.$members$),r=t.prototype;if(i.map(([t,[i]])=>{31&i||2&n&&32&i?Object.defineProperty(r,t,{get(){return e=t,F(this).$instanceValues$.get(e);var e},set(n){((t,e,n,i)=>{const r=F(this),s=r.$hostElement$,o=r.$instanceValues$.get(e),a=r.$flags$,l=r.$lazyInstance$;var c,u;if(u=i.$members$[e][0],n=null==(c=n)||p(c)?c:4&u?"false"!==c&&(""===c||!!c):2&u?parseFloat(c):1&u?String(c):c,!(8&a&&void 0!==o||n===o)&&(r.$instanceValues$.set(e,n),l)){if(i.$watchers$&&128&a){const t=i.$watchers$[e];t&&t.map(t=>{try{l[t](n,o,e)}catch(i){U(i,s)}})}2==(18&a)&&C(r,!1)}})(0,t,n,e)},configurable:!0,enumerable:!0}):1&n&&64&i&&Object.defineProperty(r,t,{value(...e){const n=F(this);return n.$onInstancePromise$.then(()=>n.$lazyInstance$[t](...e))}})}),1&n){const e=new Map;r.attributeChangedCallback=function(t,n,i){l.jmp(()=>{const n=e.get(t);this[n]=(null!==i||"boolean"!=typeof this[n])&&i})},t.observedAttributes=i.filter(([t,e])=>15&e[0]).map(([t,n])=>{const i=n[1]||t;return e.set(i,t),i})}}return t},O=(t,e={})=>{const n=[],i=e.exclude||[],r=o.customElements,s=a.head,c=s.querySelector("meta[charset]"),h=a.createElement("style"),p=[];let f,m=!0;Object.assign(l,e),l.$resourcesUrl$=new URL(e.resourcesUrl||"./",a.baseURI).href,t.map(t=>t[1].map(e=>{const s={$flags$:e[0],$tagName$:e[1],$members$:e[2],$listeners$:e[3]};s.$members$=e[2],s.$watchers$={};const o=s.$tagName$,a=class extends HTMLElement{constructor(t){super(t),z(t=this,s),1&s.$flags$&&t.attachShadow({mode:"open"})}connectedCallback(){f&&(clearTimeout(f),f=null),m?p.push(this):l.jmp(()=>(t=>{if(0==(1&l.$flags$)){const e=F(t),n=e.$cmpMeta$,i=()=>{};if(!(1&e.$flags$)){e.$flags$|=1;{let n=t;for(;n=n.parentNode||n.host;)if(n["s-p"]){E(e,e.$ancestorComponent$=n);break}}n.$members$&&Object.entries(n.$members$).map(([e,[n]])=>{if(31&n&&t.hasOwnProperty(e)){const n=t[e];delete t[e],t[e]=n}}),(async(t,e,n,i,r)=>{if(0==(32&e.$flags$)){{if(e.$flags$|=32,(r=V(n)).then){const t=()=>{};r=await r,t()}r.isProxied||(n.$watchers$=r.watchers,B(r,n,2),r.isProxied=!0);const t=()=>{};e.$flags$|=8;try{new r(e)}catch(a){U(a)}e.$flags$&=-9,e.$flags$|=128,t()}if(r.style){let t=r.style;const e=d(n);if(!G.has(e)){const i=()=>{};((t,e,n)=>{let i=G.get(t);u&&n?(i=i||new CSSStyleSheet,i.replace(e)):i=e,G.set(t,i)})(e,t,!!(1&n.$flags$)),i()}}}const s=e.$ancestorComponent$,o=()=>C(e,!0);s&&s["s-rc"]?s["s-rc"].push(o):o()})(0,e,n)}i()}})(this))}disconnectedCallback(){l.jmp(()=>(t=>{if(0==(1&l.$flags$)){const t=F(this);N(t.$lazyInstance$,"disconnectedCallback")}})())}componentOnReady(){return F(this).$onReadyPromise$}};s.$lazyBundleId$=t[0],i.includes(o)||r.get(o)||(n.push(o),r.define(o,B(a,s,1)))})),h.innerHTML=n+"{visibility:hidden}.hydrated{visibility:inherit}",h.setAttribute("data-styles",""),s.insertBefore(h,c?c.nextSibling:s.firstChild),m=!1,p.length?p.map(t=>t.connectedCallback()):l.jmp(()=>f=setTimeout(R,30))},P=new WeakMap,F=t=>P.get(t),$=(t,e)=>P.set(e.$lazyInstance$=t,e),z=(t,e)=>{const n={$flags$:0,$hostElement$:t,$cmpMeta$:e,$instanceValues$:new Map};return n.$onInstancePromise$=new Promise(t=>n.$onInstanceResolve$=t),n.$onReadyPromise$=new Promise(t=>n.$onReadyResolve$=t),t["s-p"]=[],t["s-rc"]=[],P.set(t,n)},U=(t,e)=>(0,console.error)(t,e),H=new Map,V=(t,e,i)=>{const r=t.$tagName$.replace(/-/g,"_"),s=t.$lazyBundleId$,o=H.get(s);return o?o[r]:n("U0tu")(`./${s}.entry.js`).then(t=>(H.set(s,t),t[r]),U)},G=new Map,W=[],j=[],Q=(t,e)=>n=>{t.push(n),s||(s=!0,e&&4&l.$flags$?Y(X):l.raf(X))},q=t=>{for(let n=0;n<t.length;n++)try{t[n](performance.now())}catch(e){U(e)}t.length=0},X=()=>{q(W),q(j),(s=W.length>0)&&l.raf(X)},Y=t=>c().then(t),K=Q(j,!0)},"W4f/":function(t,e,n){"use strict";n.d(e,"a",function(){return l}),n.d(e,"b",function(){return c}),n.d(e,"c",function(){return u});let i={};const r=document.createElement("canvas");r.width=152,r.height=152;const s=r.getContext("2d"),o=function(t){if(t in i)return[...i[t]];s.clearRect(0,0,152,152),s.font="60px 'SuttonSignWritingLine'",s.fillText(String.fromCodePoint(t+983040),0,0);const e=s.getImageData(0,0,152,152).data;let n,r,o,a;t:for(n=151;n>=0;n--)for(r=0;r<152;r+=1)for(a=0;a<4;a+=1)if(o=4*n+4*r*152+a,e[o])break t;var l=n;t:for(r=151;r>=0;r--)for(n=0;n<l;n+=1)for(a=0;a<4;a+=1)if(o=4*n+4*r*152+a,e[o])break t;var c=r+1;if(l=Math.ceil(l/2),c=Math.ceil(c/2),14394==t&&(l=19),[10468,10480,10496,10512,10500,10532,10548,10862,10878,10894,11058,11074,11476,11488,11492,11504,11508,11520,10516,10910,10926,11042,11082,10942].includes(t)&&(l=20),31921==t&&(l=22),38460==t&&(l=23),[20164,20212].includes(t)&&(l=25),31894==t&&(l=28),46698==t&&(l=29),29606==t&&(l=30),44855==t&&(l=40),32667==t&&(l=50),[11088,11474,11490,11506].includes(t)&&(c=20),6285==t&&(c=21),40804==t&&(c=31),41475==t&&(c=36),0==l&&0==c){const e={9:[15,30],10:[21,30],11:[30,15],12:[30,21],13:[15,30],14:[21,30]};t in e&&(l=e[t][0],c=e[t][1])}return 0!=l||0!=c?(i[t]=[l,c],[l,c]):void 0};window.sgnw=!1;const a=new Event("sgnw"),l=function(t){return t.replace(/rgba?\((.+?)\)/gi,(t,e)=>{let n=e.split(",");return 4==n.length&&0==parseInt(n[3])?"transparent":n.slice(0,3).map(t=>parseInt(t,10).toString(16).padStart(2,"0")).join("")})},c=function(t){return t.replace(/rgba?\((.+?)\)/gi,(t,e)=>{let n=e.split(",");return 4==n.length&&parseInt(n[3])<1?"transparent":n.slice(0,3).map(t=>parseInt(t,10).toString(16).padStart(2,"0")).join("")})};function u(){!function(t=""){if(!document.getElementById("SgnwFontCss")){const e=document.createElement("style");e.setAttribute("id","SgnwFontCss"),e.appendChild(document.createTextNode(`\n  @font-face {\n    font-family: "SuttonSignWritingLine";\n    src: \n      local('SuttonSignWritingLine'),\n      ${t?`url('${t}SuttonSignWritingLine.ttf') format('truetype'),`:""}\n      url('https://cdn.jsdelivr.net/npm/@sutton-signwriting/font-ttf@1.0.0/font/SuttonSignWritingLine.ttf') format('truetype');\n  }\n  @font-face {\n    font-family: "SuttonSignWritingFill";\n    src: \n      local('SuttonSignWritingFill'),\n      ${t?`url('${t}SuttonSignWritingFill.ttf') format('truetype'),`:""}\n      url('https://cdn.jsdelivr.net/npm/@sutton-signwriting/font-ttf@1.0.0/font/SuttonSignWritingFill.ttf') format('truetype');\n  }\n  @font-face {\n    font-family: "SuttonSignWritingOneD";\n    src: \n      local('SuttonSignWritingOneD'),\n      ${t?`url('${t}SuttonSignWritingOneD.ttf') format('truetype'),`:""}\n      url('https://cdn.jsdelivr.net/npm/@sutton-signwriting/font-ttf@1.0.0/font/SuttonSignWritingOneD.ttf') format('truetype');\n  }\n    `)),document.head.appendChild(e)}}(),function(t){let e=!1,n=!1;(function(t){if(o(1))t();else{const e=setInterval(function(){o(1)&&(clearInterval(e),t())},100)}})(()=>{e=!0}),function(t){const e=function(){const t=document.createElement("canvas");t.width=15,t.height=30;const e=t.getContext("2d");return e.font="30px 'SuttonSignWritingFill'",e.fillText(String.fromCodePoint(1048577),0,0),!e.getImageData(0,0,15,30).data.every(t=>0===t)};if(e())t();else{const n=setInterval(function(){e()&&(clearInterval(n),t())},100)}}(()=>{n=!0});const i=setInterval(function(){e&&n&&(clearInterval(i),window.sgnw=!0,window.dispatchEvent(a))},100)}(),function(t=""){if(!document.getElementById("SgnwUnicode8FontCss")){const e=document.createElement("style");e.setAttribute("id","SgnwUnicode8FontCss"),e.appendChild(document.createTextNode(`\n    @font-face {\n      font-family: "NotoSansSignWriting";\n      src: \n        local('NotoSansSignWriting'),\n        local('Noto Sans SignWriting'),\n        local('Noto_Sans_SignWriting'),\n        local('Noto Sans SignWriting Regular'),\n        local('Noto_Sans_SignWriting_Regular'),\n        ${t?`url('${t}NotoSansSignWriting-Regular.otf') format('truetype'),`:""}\n        url('https://cdn.jsdelivr.net/gh/googlefonts/noto-fonts/unhinted/otf/NotoSansSignWriting/NotoSansSignWriting-Regular.otf') format('opentype');\n    }\n    `)),document.head.appendChild(e)}}()}},YCnO:function(t,e,n){!function(t){"use strict";let e={};const n=152,i=document.createElement("canvas");i.width=n,i.height=n;const r=i.getContext("2d"),s=function(t){if(t in e)return[...e[t]];r.clearRect(0,0,n,n),r.font="60px 'SuttonSignWritingLine'",r.fillText(String.fromCodePoint(t+983040),0,0);const i=r.getImageData(0,0,n,n).data;let s,o,a,l;t:for(s=151;s>=0;s--)for(o=0;o<n;o+=1)for(l=0;l<4;l+=1)if(a=4*s+4*o*n+l,i[a])break t;var c=s;t:for(o=151;o>=0;o--)for(s=0;s<c;s+=1)for(l=0;l<4;l+=1)if(a=4*s+4*o*n+l,i[a])break t;var u=o+1;if(c=Math.ceil(c/2),u=Math.ceil(u/2),14394==t&&(c=19),[10468,10480,10496,10512,10500,10532,10548,10862,10878,10894,11058,11074,11476,11488,11492,11504,11508,11520,10516,10910,10926,11042,11082,10942].includes(t)&&(c=20),31921==t&&(c=22),38460==t&&(c=23),[20164,20212].includes(t)&&(c=25),31894==t&&(c=28),46698==t&&(c=29),29606==t&&(c=30),44855==t&&(c=40),32667==t&&(c=50),[11088,11474,11490,11506].includes(t)&&(u=20),6285==t&&(u=21),40804==t&&(u=31),41475==t&&(u=36),0==c&&0==u){const e={9:[15,30],10:[21,30],11:[30,15],12:[30,21],13:[15,30],14:[21,30]};t in e&&(c=e[t][0],u=e[t][1])}return 0!=c||0!=u?(e[t]=[c,u],[c,u]):void 0},o=function(t){return String.fromCodePoint(t+983040)},a=function(t){return String.fromCodePoint(t+1048576)},l=function(t){return`    <text class="sym-fill" fill="white" style="pointer-events:none;font-family:'SuttonSignWritingFill';font-size:30px;">${a(t)}</text>\n    <text class="sym-line" fill="black" style="pointer-events:none;font-family:'SuttonSignWritingLine';font-size:30px;">${o(t)}</text>`},c=function(t){if(s(1))t();else{const e=setInterval(function(){s(1)&&(clearInterval(e),t())},100)}},u=function(t){const e=function(){const t=document.createElement("canvas");t.width=15,t.height=30;const e=t.getContext("2d");return e.font="30px 'SuttonSignWritingFill'",e.fillText(a(1),0,0),!e.getImageData(0,0,15,30).data.every(t=>0===t)};if(e())t();else{const n=setInterval(function(){e()&&(clearInterval(n),t())},100)}};var h=Object.freeze({__proto__:null,cssAppend:function(t=""){if(!document.getElementById("SgnwFontCss")){const e=document.createElement("style");e.setAttribute("id","SgnwFontCss"),e.appendChild(document.createTextNode(`\n  @font-face {\n    font-family: "SuttonSignWritingLine";\n    src: \n      local('SuttonSignWritingLine'),\n      ${t?`url('${t}SuttonSignWritingLine.ttf') format('truetype'),`:""}\n      url('https://cdn.jsdelivr.net/npm/@sutton-signwriting/font-ttf@1.0.0/font/SuttonSignWritingLine.ttf') format('truetype');\n  }\n  @font-face {\n    font-family: "SuttonSignWritingFill";\n    src: \n      local('SuttonSignWritingFill'),\n      ${t?`url('${t}SuttonSignWritingFill.ttf') format('truetype'),`:""}\n      url('https://cdn.jsdelivr.net/npm/@sutton-signwriting/font-ttf@1.0.0/font/SuttonSignWritingFill.ttf') format('truetype');\n  }\n  @font-face {\n    font-family: "SuttonSignWritingOneD";\n    src: \n      local('SuttonSignWritingOneD'),\n      ${t?`url('${t}SuttonSignWritingOneD.ttf') format('truetype'),`:""}\n      url('https://cdn.jsdelivr.net/npm/@sutton-signwriting/font-ttf@1.0.0/font/SuttonSignWritingOneD.ttf') format('truetype');\n  }\n    `)),document.head.appendChild(e)}},cssLoaded:function(t){let e=!1,n=!1;c(()=>{e=!0}),u(()=>{n=!0});const i=setInterval(function(){e&&n&&(clearInterval(i),t())},100)},cssLoadedLine:c,cssLoadedFill:u,symbolSize:s,symbolLine:o,symbolFill:a,symbolText:l});const d=t=>t.map(t=>(t=>String.fromCodePoint(120844+parseInt(t)-250))(t)).join(""),p=t=>(t=>parseInt(t.codePointAt(0)))(t)-262144,f=t=>1+96*(parseInt(t.slice(1,4),16)-256)+16*parseInt(t.slice(4,5),16)+parseInt(t.slice(5,6),16),m=function(t){return s(f(t))},g=function(t){return o(f(t))},y=function(t){return a(f(t))},v=function(t){return l(f(t))};let b={colorize:"C",colorhex:"(?:[0-9a-fA-F]{3}){1,2}",colorname:"[a-zA-Z]+",padding:"P[0-9]{2}",zoom:"Z(?:[0-9]+(?:\\.[0-9]+)?|x)",zoomsym:"Z[0-9]{2},[0-9]+(?:\\.[0-9]+)?(?:,[0-9]{3}x[0-9]{3})?",classbase:"-?[_a-zA-Z][_a-zA-Z0-9-]{0,100}",id:"[a-zA-Z][_a-zA-Z0-9-]{0,100}"};b.colorbase=`(?:${b.colorhex}|${b.colorname})`,b.color=`_${b.colorbase}_`,b.colors=`_${b.colorbase}(?:,${b.colorbase})?_`,b.background=`G${b.color}`,b.detail=`D${b.colors}`,b.detailsym=`D[0-9]{2}${b.colors}`,b.classes=`${b.classbase}(?: ${b.classbase})*`,b.full=`-(${b.colorize})?(${b.padding})?(${b.background})?(${b.detail})?(${b.zoom})?(?:-((?:${b.detailsym})*)((?:${b.zoomsym})*))?(?:-(${b.classes})?!(?:(${b.id})!)?)?`;const A=t=>(new RegExp(`^${b.colorhex}$`).test(t)?"#":"")+t,x=t=>{const e=("string"==typeof t?t.match(new RegExp(`^${b.full}`)):[])||[];return{colorize:e[1]?!!e[1]:void 0,padding:e[2]?parseInt(e[2].slice(1)):void 0,background:e[3]?A(e[3].slice(2,-1)):void 0,detail:e[4]?e[4].slice(2,-1).split(",").map(A):void 0,zoom:e[5]?"Zx"===e[5]?"x":parseFloat(e[5].slice(1)):void 0,detailsym:e[6]?e[6].match(new RegExp(b.detailsym,"g")).map(t=>{const e=t.split("_"),n=e[1].split(",").map(A);return{index:parseInt(e[0].slice(1)),detail:n}}):void 0,zoomsym:e[7]?e[7].match(new RegExp(b.zoomsym,"g")).map(t=>{const e=t.split(",");return{index:parseInt(e[0].slice(1)),zoom:parseFloat(e[1]),offset:e[2]?e[2].split("x").map(t=>parseInt(t)-500):void 0}}):void 0,classes:e[8]?e[8]:void 0,id:e[9]?e[9]:void 0}};let w={symbol:"S[123][0-9a-f]{2}[0-5][0-9a-f]",coord:"[0-9]{3}x[0-9]{3}",sort:"A",box:"[BLMR]"};w.prefix=`(?:${w.sort}(?:${w.symbol})+)`,w.spatial=`${w.symbol}${w.coord}`,w.signbox=`${w.box}${w.coord}(?:${w.spatial})*`,w.sign=`${w.prefix}?${w.signbox}`,w.sortable=`${w.prefix}${w.signbox}`;let _={colorize:"C",colorhex:"(?:[0-9a-fA-F]{3}){1,2}",colorname:"[a-zA-Z]+",padding:"P[0-9]{2}",zoom:"Z(?:[0-9]+(?:\\.[0-9]+)?|x)",zoomsym:"Z[0-9]{2},[0-9]+(?:\\.[0-9]+)?(?:,[0-9]{3}x[0-9]{3})?",classbase:"-?[_a-zA-Z][_a-zA-Z0-9-]{0,100}",id:"[a-zA-Z][_a-zA-Z0-9-]{0,100}"};_.colorbase=`(?:${_.colorhex}|${_.colorname})`,_.color=`_${_.colorbase}_`,_.colors=`_${_.colorbase}(?:,${_.colorbase})?_`,_.background=`G${_.color}`,_.detail=`D${_.colors}`,_.detailsym=`D[0-9]{2}${_.colors}`,_.classes=`${_.classbase}(?: ${_.classbase})*`,_.full=`-(${_.colorize})?(${_.padding})?(${_.background})?(${_.detail})?(${_.zoom})?(?:-((?:${_.detailsym})*)((?:${_.zoomsym})*))?(?:-(${_.classes})?!(?:(${_.id})!)?)?`;const S=t=>t.split("x").map(t=>parseInt(t)),E=t=>{const e="string"==typeof t?t.match(new RegExp(`^(${w.symbol})(${w.coord})?(${_.full})?`)):void 0;return{symbol:e?e[1]:void 0,coord:e&&e[2]?S(e[2]):void 0,style:e?e[3]:void 0}},C=t=>{const e="string"==typeof t?t.match(new RegExp(`^(${w.prefix})?(${w.signbox})(${_.full})?`)):void 0;return e?{sequence:e[1]?e[1].slice(1).match(/.{6}/g):void 0,box:e[2][0],max:S(e[2].slice(1,8)),spatials:e[2].length<9?void 0:e[2].slice(8).match(/(.{13})/g).map(t=>({symbol:t.slice(0,6),coord:[parseInt(t.slice(6,9)),parseInt(t.slice(10,13))]})),style:e[3]}:{}},I=[256,517,759,767,877,895,903],T=[767,876],M=[767,885],k=["#0000CC","#CC0000","#FF0099","#006600","#000000","#884411","#FF9900"],R=t=>{const e=E(t);let n="#000000";if(e.symbol){const t=parseInt(e.symbol.slice(1,4),16),i=I.findIndex(e=>e>t);n=k[i<0?6:i-1]}return n};var N=Object.freeze({__proto__:null,symbolSize:m,symbolLine:g,symbolFill:y,symbolText:v,symbolSvg:t=>{const e=E(t);if(e.symbol){let n=m(e.symbol);if(n){let i,r=x(e.style),s=v(e.symbol);s=`  <g transform="translate(500,500)">\n${s}\n  </g>`,r.colorize?i=R(e.symbol):r.detail&&(i=r.detail[0]),i&&(s=s.replace(/class="sym-line" fill="black"/,`class="sym-line" fill="${i}"`));let o=r.detail&&r.detail[1];o&&(s=s.replace(/class="sym-fill" fill="white"/,`class="sym-fill" fill="${o}"`));let a=500,l=500,c="";r.padding&&(a-=r.padding,l-=r.padding,n[0]+=2*r.padding,n[1]+=2*r.padding),r.background&&(c=`\n  <rect x="${a}" y="${l}" width="${n[0]}" height="${n[1]}" style="fill:${r.background};" />`);let u="";"x"!=r.zoom&&(u=` width="${n[0]*(r.zoom?r.zoom:1)}" height="${n[1]*(r.zoom?r.zoom:1)}"`);let h="";r.classes&&(h=` class="${r.classes}"`);let d="";return r.id&&(d=` id="${r.id}"`),`<svg${h}${d} version="1.1" xmlns="http://www.w3.org/2000/svg"${u} viewBox="${a} ${l} ${n[0]} ${n[1]}">\n  <text font-size="0">${t}</text>${c}\n${s}\n</svg>`}}return'<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="1" height="1"></svg>'},symbolPng:t=>{const e=function(t){const e=E(t);if(e.symbol){let t=m(e.symbol);if(t){const n=document.createElement("canvas"),i=n.getContext("2d");let r=x(e.style),s="black";r.colorize?s=R(e.symbol):r.detail&&(s=r.detail[0]);let o=r.detail&&r.detail[1]||"white",a=500,l=a+t[0],c=500,u=c+t[1];r.padding&&(a-=r.padding,c-=r.padding,l+=r.padding,u+=r.padding);let h=1;"x"!=r.zoom&&(h=r.zoom);let d=(l-a)*h,p=(u-c)*h;return n.width=d||1,n.height=p||1,r.background&&(i.rect(0,0,d,p),i.fillStyle=r.background,i.fill()),i.font=30*h+"px 'SuttonSignWritingFill'",i.fillStyle=o,i.fillText(y(e.symbol),(500-a)*h,(500-c)*h),i.font=30*h+"px 'SuttonSignWritingLine'",i.fillStyle=s,i.fillText(g(e.symbol),(500-a)*h,(500-c)*h),n}}}(t),n=e.toDataURL("image/png");return e.remove(),n},symbolNormalize:t=>{const e=E(t);if(!e.symbol)return null;{let t=m(e.symbol);if(t)return`${e.symbol}${500-parseInt(t[0]/2)}x${500-parseInt(t[1]/2)}${e.style||""}`}},signSvg:t=>{let e=C(t);if(e.spatials){let n=x(e.style);n.detailsym&&n.detailsym.forEach(t=>{e.spatials[t.index-1]&&(e.spatials[t.index-1].detail=t.detail)});let i=Math.min(...e.spatials.map(t=>t.coord[0])),r=Math.min(...e.spatials.map(t=>t.coord[1])),s=e.max[0],o=e.max[1];n.zoomsym&&n.zoomsym.forEach(t=>{if(e.spatials[t.index-1]){e.spatials[t.index-1].zoom=t.zoom,t.offset&&(e.spatials[t.index-1].coord[0]+=t.offset[0],e.spatials[t.index-1].coord[1]+=t.offset[1]);let n=m(e.spatials[t.index-1].symbol);s=Math.max(s,e.spatials[t.index-1].coord[0]+n[0]*t.zoom),o=Math.max(o,e.spatials[t.index-1].coord[1]+n[1]*t.zoom)}});let a="";n.classes&&(a=` class="${n.classes}"`);let l="";n.id&&(l=` id="${n.id}"`);let c="";n.padding&&(i-=n.padding,r-=n.padding,s+=n.padding,o+=n.padding),n.background&&(c=`\n  <rect x="${i}" y="${r}" width="${s-i}" height="${o-r}" style="fill:${n.background};" />`);let u="";"x"!=n.zoom&&(u=` width="${(s-i)*(n.zoom?n.zoom:1)}" height="${(o-r)*(n.zoom?n.zoom:1)}"`);let h=`<svg${a}${l} version="1.1" xmlns="http://www.w3.org/2000/svg"${u} viewBox="${i} ${r} ${s-i} ${o-r}">\n  <text font-size="0">${t}</text>${c}`;const d=n.detail&&n.detail[0],p=n.detail&&n.detail[1];return h+="\n"+e.spatials.map(t=>{let e=v(t.symbol),i=d;t.detail?i=t.detail[0]:n.colorize&&(i=R(t.symbol)),i&&(e=e.replace(/class="sym-line" fill="black"/,`class="sym-line" fill="${i}"`));let r=p;return t.detail&&t.detail[1]&&(r=t.detail[1]),r&&(e=e.replace(/class="sym-fill" fill="white"/,`class="sym-fill" fill="${r}"`)),t.zoom&&(e=`<g transform="scale(${t.zoom})">${e}</g>`),`  <g transform="translate(${t.coord[0]},${t.coord[1]})">\n${e}\n  </g>`}).join("\n"),h+="\n</svg>",h}return'<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="1" height="1"></svg>'},signPng:t=>{const e=function(t){const e=C(t);if(e.spatials){const t=document.createElement("canvas"),n=t.getContext("2d");let i=x(e.style);i.detailsym&&i.detailsym.forEach(t=>{e.spatials[t.index-1]&&(e.spatials[t.index-1].detail=t.detail)});let r=Math.min(...e.spatials.map(t=>t.coord[0])),s=Math.min(...e.spatials.map(t=>t.coord[1])),o=e.max[0],a=e.max[1];i.zoomsym&&i.zoomsym.forEach(t=>{if(e.spatials[t.index-1]){e.spatials[t.index-1].zoom=t.zoom,t.offset&&(e.spatials[t.index-1].coord[0]+=t.offset[0],e.spatials[t.index-1].coord[1]+=t.offset[1]);let n=m(e.spatials[t.index-1].symbol);o=Math.max(o,e.spatials[t.index-1].coord[0]+n[0]*t.zoom),a=Math.max(a,e.spatials[t.index-1].coord[1]+n[1]*t.zoom)}}),i.padding&&(r-=i.padding,s-=i.padding,o+=i.padding,a+=i.padding);let l=1;"x"!=i.zoom&&(l=i.zoom);let c=(o-r)*l,u=(a-s)*l;t.width=c||1,t.height=u||1,i.background&&(n.rect(0,0,c,u),n.fillStyle=i.background,n.fill());const h=i.detail&&i.detail[0]||"black",d=i.detail&&i.detail[1]||"white";return e.spatials.forEach(t=>{let e=h;t.detail?e=t.detail[0]:i.colorize&&(e=R(t.symbol));let o=d;t.detail&&t.detail[1]&&(o=t.detail[1]);let a=t.zoom||1;n.font=30*l*a+"px 'SuttonSignWritingFill'",n.fillStyle=o,n.fillText(y(t.symbol),(t.coord[0]-r)*l,(t.coord[1]-s)*l),n.font=30*l*a+"px 'SuttonSignWritingLine'",n.fillStyle=e,n.fillText(g(t.symbol),(t.coord[0]-r)*l,(t.coord[1]-s)*l)}),t}}(t),n=e.toDataURL("image/png");return e.remove(),n},signNormalize:t=>{const e=C(t);if(e.spatials){const t=e.spatials.reduce((t,e)=>{const n=m(e.symbol);return t[e.symbol]={width:n[0],height:n[1]},t},{}),n=e=>({x1:Math.min(...e.map(t=>t.coord[0])),y1:Math.min(...e.map(t=>t.coord[1])),x2:Math.max(...e.map(e=>e.coord[0]+parseInt(t[e.symbol].width))),y2:Math.max(...e.map(e=>e.coord[1]+parseInt(t[e.symbol].height)))}),i=T,r=e.spatials.filter(t=>{const e=parseInt(t.symbol.slice(1,4),16);return i[0]<=e&&i[1]>=e}),s=M,o=e.spatials.filter(t=>{const e=parseInt(t.symbol.slice(1,4),16);return s[0]<=e&&s[1]>=e});let a=n(e.spatials),l=[a.x2,a.y2];if(r.length){const t=n(r);a.x1=t.x1,a.x2=t.x2}if(o.length){const t=n(o);a.y1=t.y1,a.y2=t.y2}const c=[parseInt((a.x2+a.x1)/2)-500,parseInt((a.y2+a.y1)/2)-500];return(e.sequence?"A"+e.sequence.join(""):"")+e.box+(l[0]-c[0])+"x"+(l[1]-c[1])+e.spatials.map(t=>t.symbol+(t.coord[0]-c[0])+"x"+(t.coord[1]-c[1])).join("")+(e.style||"")}}});const L=function(t){return s(p(t))},D=function(t){return o(p(t))},B=function(t){return a(p(t))},O=function(t){return l(p(t))};let P={symbol:"(?:(?:\ud8c0[\udc01-\udfff])|(?:[\ud8c1-\ud8fc][\udc00-\udfff])|(?:\ud8fd[\udc00-\udc80]))",coord:"(?:\ud836[\udc0c-\uddff]){2}",sort:"\ud836\udc00",box:"\ud836[\udc01-\udc04]"};P.prefix=`(?:${P.sort}(?:${P.symbol})+)`,P.spatial=`${P.symbol}${P.coord}`,P.signbox=`${P.box}${P.coord}(?:${P.spatial})*`,P.sign=`${P.prefix}?${P.signbox}`,P.sortable=`${P.prefix}${P.signbox}`;let F={colorize:"C",colorhex:"(?:[0-9a-fA-F]{3}){1,2}",colorname:"[a-zA-Z]+",padding:"P[0-9]{2}",zoom:"Z(?:[0-9]+(?:\\.[0-9]+)?|x)",zoomsym:"Z[0-9]{2},[0-9]+(?:\\.[0-9]+)?(?:,[0-9]{3}x[0-9]{3})?",classbase:"-?[_a-zA-Z][_a-zA-Z0-9-]{0,100}",id:"[a-zA-Z][_a-zA-Z0-9-]{0,100}"};F.colorbase=`(?:${F.colorhex}|${F.colorname})`,F.color=`_${F.colorbase}_`,F.colors=`_${F.colorbase}(?:,${F.colorbase})?_`,F.background=`G${F.color}`,F.detail=`D${F.colors}`,F.detailsym=`D[0-9]{2}${F.colors}`,F.classes=`${F.classbase}(?: ${F.classbase})*`,F.full=`-(${F.colorize})?(${F.padding})?(${F.background})?(${F.detail})?(${F.zoom})?(?:-((?:${F.detailsym})*)((?:${F.zoomsym})*))?(?:-(${F.classes})?!(?:(${F.id})!)?)?`;const $=t=>parseInt(t.codePointAt(0))-120844+250,z=t=>[$(t.slice(0,2)),$(t.slice(2,4))],U=t=>{const e="string"==typeof t?t.match(new RegExp(`^(${P.symbol})(${P.coord})?(${F.full})?`)):void 0;return{symbol:e?e[1]:void 0,coord:e&&e[2]?z(e[2]):void 0,style:e?e[3]:void 0}},H=t=>{const e="string"==typeof t?t.match(new RegExp(`^(${P.prefix})?(${P.signbox})(${F.full})?`)):void 0;return e?{sequence:e[1]?e[1].slice(2).match(/.{2}/g):void 0,box:e[2].slice(0,2),max:z(e[2].slice(2,6)),spatials:e[2].length<7?void 0:e[2].slice(6).match(/(.{6})/g).map(t=>({symbol:t.slice(0,2),coord:z(t.slice(2))})),style:e[3]}:{}},V=[262145,287201,310433,311201,321761,323489,324257],G=[311201,321760],W=[311201,322624],j=["#0000CC","#CC0000","#FF0099","#006600","#000000","#884411","#FF9900"],Q=t=>{const e=U(t);let n="#000000";if(e.symbol){const t=(t=>parseInt(t.codePointAt(0)))(e.symbol),i=V.findIndex(e=>e>t);n=j[i<0?6:i-1]}return n};var q=Object.freeze({__proto__:null,symbolSize:L,symbolLine:D,symbolFill:B,symbolText:O,symbolSvg:t=>{const e=U(t);if(e.symbol){let n=L(e.symbol);if(n){let i,r=x(e.style),s=O(e.symbol);s=`  <g transform="translate(500,500)">\n${s}\n  </g>`,r.colorize?i=Q(e.symbol):r.detail&&(i=r.detail[0]),i&&(s=s.replace(/class="sym-line" fill="black"/,`class="sym-line" fill="${i}"`));let o=r.detail&&r.detail[1];o&&(s=s.replace(/class="sym-fill" fill="white"/,`class="sym-fill" fill="${o}"`));let a=500,l=500,c="";r.padding&&(a-=r.padding,l-=r.padding,n[0]+=2*r.padding,n[1]+=2*r.padding),r.background&&(c=`\n  <rect x="${a}" y="${l}" width="${n[0]}" height="${n[1]}" style="fill:${r.background};" />`);let u="";"x"!=r.zoom&&(u=` width="${n[0]*(r.zoom?r.zoom:1)}" height="${n[1]*(r.zoom?r.zoom:1)}"`);let h="";r.classes&&(h=` class="${r.classes}"`);let d="";return r.id&&(d=` id="${r.id}"`),`<svg${h}${d} version="1.1" xmlns="http://www.w3.org/2000/svg"${u} viewBox="${a} ${l} ${n[0]} ${n[1]}">\n  <text font-size="0">${t}</text>${c}\n${s}\n</svg>`}}return'<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="1" height="1"></svg>'},symbolPng:t=>{const e=function(t){const e=U(t);if(e.symbol){let t=L(e.symbol);if(t){const n=document.createElement("canvas"),i=n.getContext("2d");let r=x(e.style),s="black";r.colorize?s=Q(e.symbol):r.detail&&(s=r.detail[0]);let o=r.detail&&r.detail[1]||"white",a=500,l=a+t[0],c=500,u=c+t[1];r.padding&&(a-=r.padding,c-=r.padding,l+=r.padding,u+=r.padding);let h=1;"x"!=r.zoom&&(h=r.zoom);let d=(l-a)*h,p=(u-c)*h;return n.width=d||1,n.height=p||1,r.background&&(i.rect(0,0,d,p),i.fillStyle=r.background,i.fill()),i.font=30*h+"px 'SuttonSignWritingFill'",i.fillStyle=o,i.fillText(B(e.symbol),(500-a)*h,(500-c)*h),i.font=30*h+"px 'SuttonSignWritingLine'",i.fillStyle=s,i.fillText(D(e.symbol),(500-a)*h,(500-c)*h),n}}}(t),n=e.toDataURL("image/png");return e.remove(),n},symbolNormalize:t=>{const e=U(t);if(!e.symbol)return null;{let t=L(e.symbol);if(t)return`${e.symbol}${d([500-parseInt(t[0]/2),500-parseInt(t[1]/2)])}${e.style||""}`}},signSvg:t=>{let e=H(t);if(e.spatials){let n=x(e.style);n.detailsym&&n.detailsym.forEach(t=>{e.spatials[t.index-1]&&(e.spatials[t.index-1].detail=t.detail)});let i=Math.min(...e.spatials.map(t=>t.coord[0])),r=Math.min(...e.spatials.map(t=>t.coord[1])),s=e.max[0],o=e.max[1];n.zoomsym&&n.zoomsym.forEach(t=>{if(e.spatials[t.index-1]){e.spatials[t.index-1].zoom=t.zoom,t.offset&&(e.spatials[t.index-1].coord[0]+=t.offset[0],e.spatials[t.index-1].coord[1]+=t.offset[1]);let n=L(e.spatials[t.index-1].symbol);s=Math.max(s,e.spatials[t.index-1].coord[0]+n[0]*t.zoom),o=Math.max(o,e.spatials[t.index-1].coord[1]+n[1]*t.zoom)}});let a="";n.classes&&(a=` class="${n.classes}"`);let l="";n.id&&(l=` id="${n.id}"`);let c="";n.padding&&(i-=n.padding,r-=n.padding,s+=n.padding,o+=n.padding),n.background&&(c=`\n  <rect x="${i}" y="${r}" width="${s-i}" height="${o-r}" style="fill:${n.background};" />`);let u="";"x"!=n.zoom&&(u=` width="${(s-i)*(n.zoom?n.zoom:1)}" height="${(o-r)*(n.zoom?n.zoom:1)}"`);let h=`<svg${a}${l} version="1.1" xmlns="http://www.w3.org/2000/svg"${u} viewBox="${i} ${r} ${s-i} ${o-r}">\n  <text font-size="0">${t}</text>${c}`;const d=n.detail&&n.detail[0],p=n.detail&&n.detail[1];return h+="\n"+e.spatials.map(t=>{let e=O(t.symbol),i=d;t.detail?i=t.detail[0]:n.colorize&&(i=Q(t.symbol)),i&&(e=e.replace(/class="sym-line" fill="black"/,`class="sym-line" fill="${i}"`));let r=p;return t.detail&&t.detail[1]&&(r=t.detail[1]),r&&(e=e.replace(/class="sym-fill" fill="white"/,`class="sym-fill" fill="${r}"`)),t.zoom&&(e=`<g transform="scale(${t.zoom})">${e}</g>`),`  <g transform="translate(${t.coord[0]},${t.coord[1]})">\n${e}\n  </g>`}).join("\n"),h+="\n</svg>",h}return'<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="1" height="1"></svg>'},signPng:t=>{const e=function(t){const e=H(t);if(e.spatials){const t=document.createElement("canvas"),n=t.getContext("2d");let i=x(e.style);i.detailsym&&i.detailsym.forEach(t=>{e.spatials[t.index-1]&&(e.spatials[t.index-1].detail=t.detail)});let r=Math.min(...e.spatials.map(t=>t.coord[0])),s=Math.min(...e.spatials.map(t=>t.coord[1])),o=e.max[0],a=e.max[1];i.zoomsym&&i.zoomsym.forEach(t=>{if(e.spatials[t.index-1]){e.spatials[t.index-1].zoom=t.zoom,t.offset&&(e.spatials[t.index-1].coord[0]+=t.offset[0],e.spatials[t.index-1].coord[1]+=t.offset[1]);let n=L(e.spatials[t.index-1].symbol);o=Math.max(o,e.spatials[t.index-1].coord[0]+n[0]*t.zoom),a=Math.max(a,e.spatials[t.index-1].coord[1]+n[1]*t.zoom)}}),i.padding&&(r-=i.padding,s-=i.padding,o+=i.padding,a+=i.padding);let l=1;"x"!=i.zoom&&(l=i.zoom);let c=(o-r)*l,u=(a-s)*l;t.width=c||1,t.height=u||1,i.background&&(n.rect(0,0,c,u),n.fillStyle=i.background,n.fill());const h=i.detail&&i.detail[0]||"black",d=i.detail&&i.detail[1]||"white";return e.spatials.forEach(t=>{let e=h;t.detail?e=t.detail[0]:i.colorize&&(e=Q(t.symbol));let o=d;t.detail&&t.detail[1]&&(o=t.detail[1]);let a=t.zoom||1;n.font=30*l*a+"px 'SuttonSignWritingFill'",n.fillStyle=o,n.fillText(B(t.symbol),(t.coord[0]-r)*l,(t.coord[1]-s)*l),n.font=30*l*a+"px 'SuttonSignWritingLine'",n.fillStyle=e,n.fillText(D(t.symbol),(t.coord[0]-r)*l,(t.coord[1]-s)*l)}),t}}(t),n=e.toDataURL("image/png");return e.remove(),n},signNormalize:t=>{const e=H(t);if(e.spatials){const t=e.spatials.reduce((t,e)=>{const n=L(e.symbol);return t[e.symbol]={width:n[0],height:n[1]},t},{}),n=e=>({x1:Math.min(...e.map(t=>t.coord[0])),y1:Math.min(...e.map(t=>t.coord[1])),x2:Math.max(...e.map(e=>e.coord[0]+parseInt(t[e.symbol].width))),y2:Math.max(...e.map(e=>e.coord[1]+parseInt(t[e.symbol].height)))}),i=G,r=e.spatials.filter(t=>{const e=parseInt(t.symbol.slice(1,4),16);return i[0]<=e&&i[1]>=e}),s=W,o=e.spatials.filter(t=>{const e=parseInt(t.symbol.slice(1,4),16);return s[0]<=e&&s[1]>=e});let a=n(e.spatials),l=[a.x2,a.y2];if(r.length){const t=n(r);a.x1=t.x1,a.x2=t.x2}if(o.length){const t=n(o);a.y1=t.y1,a.y2=t.y2}const c=[parseInt((a.x2+a.x1)/2)-500,parseInt((a.y2+a.y1)/2)-500];return(e.sequence?"\ud836\udc00"+e.sequence.join(""):"")+e.box+d([l[0]-c[0],l[1]-c[1]])+e.spatials.map(t=>t.symbol+d([t.coord[0]-c[0],t.coord[1]-c[1]])).join("")+(e.style||"")}}});t.font=h,t.fsw=N,t.swu=q,Object.defineProperty(t,"__esModule",{value:!0})}(e)},YSVl:function(t,e,n){var i=n("EhIR"),r=n("uDiL"),s=n("pJ6O"),o=n("yuCN"),a=n("euyF"),l=n("ie1u"),c=n("pJ3+");c.alea=i,c.xor128=r,c.xorwow=s,c.xorshift7=o,c.xor4096=a,c.tychei=l,t.exports=c},YWYm:function(t,e,n){(function(t){var i;!function(t,r,s){function o(t){var e,n=this,i=(e=4022871197,function(t){t=t.toString();for(var n=0;n<t.length;n++){var i=.02519603282416938*(e+=t.charCodeAt(n));i-=e=i>>>0,e=(i*=e)>>>0,e+=4294967296*(i-=e)}return 2.3283064365386963e-10*(e>>>0)});n.next=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=i(" "),n.s1=i(" "),n.s2=i(" "),n.s0-=i(t),n.s0<0&&(n.s0+=1),n.s1-=i(t),n.s1<0&&(n.s1+=1),n.s2-=i(t),n.s2<0&&(n.s2+=1),i=null}function a(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function l(t,e){var n=new o(t),i=e&&e.state,r=n.next;return r.int32=function(){return 4294967296*n.next()|0},r.double=function(){return r()+11102230246251565e-32*(2097152*r()|0)},r.quick=r,i&&("object"==typeof i&&a(i,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(i=(function(){return l}).call(e,n,e,r))||(r.exports=i):this.alea=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},YuTi:function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children||(t.children=[]),Object.defineProperty(t,"loaded",{enumerable:!0,get:function(){return t.l}}),Object.defineProperty(t,"id",{enumerable:!0,get:function(){return t.i}}),t.webpackPolyfill=1),t}},aOSE:function(t,e){(function(){"use strict";function t(t){var e=0;return function(){return e<t.length?{done:!1,value:t[e++]}:{done:!0}}}var e="function"==typeof Object.defineProperties?Object.defineProperty:function(t,e,n){return t==Array.prototype||t==Object.prototype||(t[e]=n.value),t},n=function(t){t=["object"==typeof globalThis&&globalThis,t,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof global&&global];for(var e=0;e<t.length;++e){var n=t[e];if(n&&n.Math==Math)return n}throw Error("Cannot find global object")}(this);function i(t,i){if(i)t:{var r=n;t=t.split(".");for(var s=0;s<t.length-1;s++){var o=t[s];if(!(o in r))break t;r=r[o]}(i=i(s=r[t=t[t.length-1]]))!=s&&null!=i&&e(r,t,{configurable:!0,writable:!0,value:i})}}function r(e){var n="undefined"!=typeof Symbol&&Symbol.iterator&&e[Symbol.iterator];return n?n.call(e):{next:t(e)}}var s="function"==typeof Object.assign?Object.assign:function(t,e){for(var n=1;n<arguments.length;n++){var i=arguments[n];if(i)for(var r in i)Object.prototype.hasOwnProperty.call(i,r)&&(t[r]=i[r])}return t};function o(t){return t||Array.prototype.fill}i("Object.assign",function(t){return t||s}),i("Array.prototype.fill",function(t){return t||function(t,e,n){var i=this.length||0;for(0>e&&(e=Math.max(0,i+e)),(null==n||n>i)&&(n=i),0>(n=Number(n))&&(n=Math.max(0,i+n)),e=Number(e||0);e<n;e++)this[e]=t;return this}}),i("Int8Array.prototype.fill",o),i("Uint8Array.prototype.fill",o),i("Uint8ClampedArray.prototype.fill",o),i("Int16Array.prototype.fill",o),i("Uint16Array.prototype.fill",o),i("Int32Array.prototype.fill",o),i("Uint32Array.prototype.fill",o),i("Float32Array.prototype.fill",o),i("Float64Array.prototype.fill",o);var a=this||self;function l(t,e){t=t.split(".");var n,i=a;t[0]in i||void 0===i.execScript||i.execScript("var "+t[0]);for(;t.length&&(n=t.shift());)t.length||void 0===e?i=i[n]&&i[n]!==Object.prototype[n]?i[n]:i[n]={}:i[n]=e}var c={color:"white",lineWidth:4,radius:6,visibilityMin:.5};function u(t){return t=t||{},Object.assign(Object.assign(Object.assign({},c),{fillColor:t.color}),t)}function h(t,e){return t instanceof Function?t(e):t}function d(t,e,n){return Math.max(Math.min(e,n),Math.min(Math.max(e,n),t))}l("clamp",d),l("drawLandmarks",function(t,e,n){if(e){n=u(n),t.save();for(var i=t.canvas,s=0,o=(e=r(e)).next();!o.done;o=e.next())if(void 0!==(o=o.value)&&(void 0===o.visibility||o.visibility>n.visibilityMin)){t.fillStyle=h(n.fillColor,{index:s,from:o}),t.strokeStyle=h(n.color,{index:s,from:o}),t.lineWidth=h(n.lineWidth,{index:s,from:o});var a=new Path2D;a.arc(o.x*i.width,o.y*i.height,h(n.radius,{index:s,from:o}),0,2*Math.PI),t.fill(a),t.stroke(a),++s}t.restore()}}),l("drawConnectors",function(t,e,n,i){if(e&&n){i=u(i),t.save();for(var s=t.canvas,o=0,a=(n=r(n)).next();!a.done;a=n.next()){var l=a.value;t.beginPath(),a=e[l[0]],l=e[l[1]],a&&l&&(void 0===a.visibility||a.visibility>i.visibilityMin)&&(void 0===l.visibility||l.visibility>i.visibilityMin)&&(t.strokeStyle=h(i.color,{index:o,from:a,to:l}),t.lineWidth=h(i.lineWidth,{index:o,from:a,to:l}),t.moveTo(a.x*s.width,a.y*s.height),t.lineTo(l.x*s.width,l.y*s.height)),++o,t.stroke()}t.restore()}}),l("drawRectangle",function(t,e,n){n=u(n),t.save();var i=t.canvas;t.beginPath(),t.lineWidth=h(n.lineWidth,{}),t.strokeStyle=h(n.color,{}),t.fillStyle=h(n.fillColor,{}),t.translate(e.xCenter*i.width,e.yCenter*i.height),t.rotate(e.rotation*Math.PI/180),t.rect(-e.width/2*i.width,-e.height/2*i.height,e.width*i.width,e.height*i.height),t.translate(-e.xCenter*i.width,-e.yCenter*i.height),t.stroke(),t.fill(),t.restore()}),l("lerp",function(t,e,n,i,r){return d(i*(1-(t-e)/(n-e))+r*(1-(n-t)/(n-e)),i,r)})}).call(this)},euyF:function(t,e,n){(function(t){var i;!function(t,r,s){function o(t){var e=this;e.next=function(){var t,n,i=e.w,r=e.X,s=e.i;return e.w=i=i+1640531527|0,n=r[s+34&127],t=r[s=s+1&127],n^=n<<13,t^=t<<17,n=r[s]=(n^=n>>>15)^(t^=t>>>12),e.i=s,n+(i^i>>>16)|0},function(t,e){var n,i,r,s,o,a=[],l=128;for(e===(0|e)?(i=e,e=null):(e+="\0",i=0,l=Math.max(l,e.length)),r=0,s=-32;s<l;++s)e&&(i^=e.charCodeAt((s+32)%e.length)),0===s&&(o=i),i^=i<<10,i^=i>>>15,i^=i<<4,i^=i>>>13,s>=0&&(r=0==(n=a[127&s]^=i+(o=o+1640531527|0))?r+1:0);for(r>=128&&(a[127&(e&&e.length||0)]=-1),r=127,s=512;s>0;--s)i=a[r+34&127],n=a[r=r+1&127],i^=i<<13,n^=n<<17,a[r]=(i^=i>>>15)^(n^=n>>>12);t.w=o,t.X=a,t.i=r}(e,t)}function a(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function l(t,e){null==t&&(t=+new Date);var n=new o(t),i=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,i&&(i.X&&a(i,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(i=(function(){return l}).call(e,n,e,r))||(r.exports=i):this.xor4096=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},"f+t/":function(t,e,n){(function(t){var i;!function(t,r,s){function o(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var i=0;i<n.length+64;i++)e.x^=0|n.charCodeAt(i),e.next()}function a(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function l(t,e){var n=new o(t),i=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,i&&("object"==typeof i&&a(i,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(i=(function(){return l}).call(e,n,e,r))||(r.exports=i):this.xor128=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},ie1u:function(t,e,n){(function(t){var i;!function(t,r,s){function o(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,i=e.d,r=e.a;return t=t<<25^t>>>7^n,n=n-i|0,i=i<<24^i>>>8^r,r=r-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-i|0,e.d=i<<16^n>>>16^r,e.a=r-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var i=0;i<n.length+20;i++)e.b^=0|n.charCodeAt(i),e.next()}function a(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function l(t,e){var n=new o(t),i=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,i&&("object"==typeof i&&a(i,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(i=(function(){return l}).call(e,n,e,r))||(r.exports=i):this.tychei=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},mQJU:function(t,e,n){var i={"./ion-action-sheet.entry.js":["bAdf",1,4,63],"./ion-alert.entry.js":["KSzb",1,4,0,64],"./ion-app.entry.js":["VhYk",65],"./ion-avatar.entry.js":["zCy3",66],"./ion-back-button.entry.js":["Fvaf",43],"./ion-backdrop.entry.js":["Fy8L",32],"./ion-badge.entry.js":["CiCf",44],"./ion-button_14.entry.js":["7XjF",0,23],"./ion-buttons.entry.js":["fsmC",67],"./ion-card-content.entry.js":["SC4L",68],"./ion-card-header.entry.js":["xL8d",45],"./ion-card-subtitle.entry.js":["6C0T",46],"./ion-card-title.entry.js":["fPoL",47],"./ion-checkbox.entry.js":["RSLk",24],"./ion-chip.entry.js":["X8gB",48],"./ion-content.entry.js":["7eKZ",49],"./ion-datetime.entry.js":["q4oe",11],"./ion-fab-button.entry.js":["Tvjp",50],"./ion-fab-list.entry.js":["mgRc",69],"./ion-fab.entry.js":["we9E",70],"./ion-footer.entry.js":["FrIb",71],"./ion-header.entry.js":["cNfd",37],"./ion-img.entry.js":["yrsb",72],"./ion-infinite-scroll-content.entry.js":["cxpd",0,73],"./ion-infinite-scroll.entry.js":["rqFz",74],"./ion-item-divider.entry.js":["3Rbw",51],"./ion-item-group.entry.js":["z5Wh",75],"./ion-item-option.entry.js":["ByEe",52],"./ion-item-options.entry.js":["5ZkO",38],"./ion-item-sliding.entry.js":["ceLy",39],"./ion-list_4.entry.js":["6soY",25],"./ion-loading.entry.js":["UgMD",1,0,15],"./ion-menu-button.entry.js":["oBu3",1,0,22],"./ion-menu-toggle.entry.js":["tVEq",1,0,35],"./ion-menu.entry.js":["Uef6",1,0,19],"./ion-modal.entry.js":["5k42",1,0,10],"./ion-nav-link.entry.js":["Tgkc",76],"./ion-nav.entry.js":["a/hJ",0,40],"./ion-note.entry.js":["wmUQ",53],"./ion-picker-column.entry.js":["0xrh",21],"./ion-picker.entry.js":["J+Lp",1,16],"./ion-popover.entry.js":["1wdO",1,0,17],"./ion-progress-bar.entry.js":["hyz9",26],"./ion-refresher-content.entry.js":["RBSy",0,77],"./ion-refresher.entry.js":["TMeA",1,0,33],"./ion-reorder-group.entry.js":["2DMg",34],"./ion-reorder.entry.js":["7BVk",78],"./ion-route-redirect.entry.js":["UTcv",79],"./ion-route.entry.js":["XnbH",80],"./ion-router-link.entry.js":["BE3N",54],"./ion-router-outlet.entry.js":["BmyH",0,81],"./ion-router.entry.js":["Csvv",41],"./ion-searchbar.entry.js":["N25X",27],"./ion-segment-button.entry.js":["i/Xz",28],"./ion-segment.entry.js":["klIy",29],"./ion-select-option.entry.js":["w+2+",82],"./ion-select-popover.entry.js":["DrcQ",12],"./ion-select.entry.js":["C84G",13],"./ion-skeleton-text.entry.js":["8N5u",55],"./ion-slide.entry.js":["aERr",83],"./ion-slides.entry.js":["pWn1",84],"./ion-spinner.entry.js":["k9so",0,56],"./ion-split-pane.entry.js":["e37z",85],"./ion-tab-bar.entry.js":["cqly",57],"./ion-tab-button.entry.js":["v/ZA",86],"./ion-tab.entry.js":["15CR",0,87],"./ion-tabs.entry.js":["6mrY",88],"./ion-text.entry.js":["9Hor",58],"./ion-textarea.entry.js":["kyg/",30],"./ion-thumbnail.entry.js":["SG5X",89],"./ion-toast.entry.js":["v0WJ",1,0,18],"./ion-toggle.entry.js":["UKvY",14],"./ion-toolbar.entry.js":["KyvP",59],"./ion-virtual-scroll.entry.js":["Cigx",90],"./sgnw-sign.entry.js":["B15D",0,94],"./sgnw-uni8-string.entry.js":["fHMd",95],"./sgnw-uni8-symbol.entry.js":["dU3u",96]};function r(t){if(!n.o(i,t))return Promise.resolve().then(function(){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e});var e=i[t],r=e[0];return Promise.all(e.slice(1).map(n.e)).then(function(){return n(r)})}r.keys=function(){return Object.keys(i)},r.id="mQJU",t.exports=r},oIJX:function(t,e,n){(function(t){var i;!function(t,r,s){function o(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,i=e.d,r=e.a;return t=t<<25^t>>>7^n,n=n-i|0,i=i<<24^i>>>8^r,r=r-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-i|0,e.d=i<<16^n>>>16^r,e.a=r-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var i=0;i<n.length+20;i++)e.b^=0|n.charCodeAt(i),e.next()}function a(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function l(t,e){var n=new o(t),i=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,i&&("object"==typeof i&&a(i,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(i=(function(){return l}).call(e,n,e,r))||(r.exports=i):this.tychei=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},pDBr:function(t,e,n){var i=n("YWYm"),r=n("f+t/"),s=n("34t7"),o=n("PkQR"),a=n("5vwH"),l=n("oIJX"),c=n("9/Hw");c.alea=i,c.xor128=r,c.xorwow=s,c.xorshift7=o,c.xor4096=a,c.tychei=l,t.exports=c},"pJ3+":function(t,e,n){var i;!function(r,s){var o,a=(0,eval)("this"),l=256,c=s.pow(l,6),u=s.pow(2,52),h=2*u,d=255;function p(t,e,n){var i=[],d=y(g((e=1==e?{entropy:!0}:e||{}).entropy?[t,v(r)]:null==t?function(){try{var t;return o&&(t=o.randomBytes)?t=t(l):(t=new Uint8Array(l),(a.crypto||a.msCrypto).getRandomValues(t)),v(t)}catch(i){var e=a.navigator,n=e&&e.plugins;return[+new Date,a,n,a.screen,v(r)]}}():t,3),i),p=new f(i),b=function(){for(var t=p.g(6),e=c,n=0;t<u;)t=(t+n)*l,e*=l,n=p.g(1);for(;t>=h;)t/=2,e/=2,n>>>=1;return(t+n)/e};return b.int32=function(){return 0|p.g(4)},b.quick=function(){return p.g(4)/4294967296},b.double=b,y(v(p.S),r),(e.pass||n||function(t,e,n,i){return i&&(i.S&&m(i,p),t.state=function(){return m(p,{})}),n?(s.random=t,e):t})(b,d,"global"in e?e.global:this==s,e.state)}function f(t){var e,n=t.length,i=this,r=0,s=i.i=i.j=0,o=i.S=[];for(n||(t=[n++]);r<l;)o[r]=r++;for(r=0;r<l;r++)o[r]=o[s=d&s+t[r%n]+(e=o[r])],o[s]=e;(i.g=function(t){for(var e,n=0,r=i.i,s=i.j,o=i.S;t--;)e=o[r=d&r+1],n=n*l+o[d&(o[r]=o[s=d&s+e])+(o[s]=e)];return i.i=r,i.j=s,n})(l)}function m(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function g(t,e){var n,i=[],r=typeof t;if(e&&"object"==r)for(n in t)try{i.push(g(t[n],e-1))}catch(s){}return i.length?i:"string"==r?t:t+"\0"}function y(t,e){for(var n,i=t+"",r=0;r<i.length;)e[d&r]=d&(n^=19*e[d&r])+i.charCodeAt(r++);return v(e)}function v(t){return String.fromCharCode.apply(0,t)}if(s.seedrandom=p,y(s.random(),r),t.exports){t.exports=p;try{o=n(4)}catch(b){}}else void 0===(i=(function(){return p}).call(e,n,e,t))||(t.exports=i)}([],Math)},pJ6O:function(t,e,n){(function(t){var i;!function(t,r,s){function o(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var i=0;i<n.length+64;i++)e.x^=0|n.charCodeAt(i),i==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function a(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function l(t,e){var n=new o(t),i=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,i&&("object"==typeof i&&a(i,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(i=(function(){return l}).call(e,n,e,r))||(r.exports=i):this.xorwow=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},qkWt:function(t,e,n){t.exports=function(t){var e={};function n(i){if(e[i])return e[i].exports;var r=e[i]={i:i,l:!1,exports:{}};return t[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}return n.m=t,n.c=e,n.d=function(t,e,i){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:i})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var r in t)n.d(i,r,(function(e){return t[e]}).bind(null,r));return i},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=8)}([function(t,e,n){var i,r;void 0===(r="function"==typeof(i={af:function(t,e){return e?"other":1==t?"one":"other"},ak:function(t,e){return e?"other":0==t||1==t?"one":"other"},am:function(t,e){return e?"other":t>=0&&t<=1?"one":"other"},ar:function(t,e){var n=String(t).split("."),i=Number(n[0])==t&&n[0].slice(-2);return e?"other":0==t?"zero":1==t?"one":2==t?"two":i>=3&&i<=10?"few":i>=11&&i<=99?"many":"other"},ars:function(t,e){var n=String(t).split("."),i=Number(n[0])==t&&n[0].slice(-2);return e?"other":0==t?"zero":1==t?"one":2==t?"two":i>=3&&i<=10?"few":i>=11&&i<=99?"many":"other"},as:function(t,e){return e?1==t||5==t||7==t||8==t||9==t||10==t?"one":2==t||3==t?"two":4==t?"few":6==t?"many":"other":t>=0&&t<=1?"one":"other"},asa:function(t,e){return e?"other":1==t?"one":"other"},ast:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},az:function(t,e){var n=String(t).split(".")[0],i=n.slice(-1),r=n.slice(-2),s=n.slice(-3);return e?1==i||2==i||5==i||7==i||8==i||20==r||50==r||70==r||80==r?"one":3==i||4==i||100==s||200==s||300==s||400==s||500==s||600==s||700==s||800==s||900==s?"few":0==n||6==i||40==r||60==r||90==r?"many":"other":1==t?"one":"other"},be:function(t,e){var n=String(t).split("."),i=Number(n[0])==t,r=i&&n[0].slice(-1),s=i&&n[0].slice(-2);return e?2!=r&&3!=r||12==s||13==s?"other":"few":1==r&&11!=s?"one":r>=2&&r<=4&&(s<12||s>14)?"few":i&&0==r||r>=5&&r<=9||s>=11&&s<=14?"many":"other"},bem:function(t,e){return e?"other":1==t?"one":"other"},bez:function(t,e){return e?"other":1==t?"one":"other"},bg:function(t,e){return e?"other":1==t?"one":"other"},bh:function(t,e){return e?"other":0==t||1==t?"one":"other"},bm:function(t,e){return"other"},bn:function(t,e){return e?1==t||5==t||7==t||8==t||9==t||10==t?"one":2==t||3==t?"two":4==t?"few":6==t?"many":"other":t>=0&&t<=1?"one":"other"},bo:function(t,e){return"other"},br:function(t,e){var n=String(t).split("."),i=Number(n[0])==t,r=i&&n[0].slice(-1),s=i&&n[0].slice(-2),o=i&&n[0].slice(-6);return e?"other":1==r&&11!=s&&71!=s&&91!=s?"one":2==r&&12!=s&&72!=s&&92!=s?"two":(3==r||4==r||9==r)&&(s<10||s>19)&&(s<70||s>79)&&(s<90||s>99)?"few":0!=t&&i&&0==o?"many":"other"},brx:function(t,e){return e?"other":1==t?"one":"other"},bs:function(t,e){var n=String(t).split("."),i=n[0],r=n[1]||"",s=!n[1],o=i.slice(-1),a=i.slice(-2),l=r.slice(-1),c=r.slice(-2);return e?"other":s&&1==o&&11!=a||1==l&&11!=c?"one":s&&o>=2&&o<=4&&(a<12||a>14)||l>=2&&l<=4&&(c<12||c>14)?"few":"other"},ca:function(t,e){var n=String(t).split(".");return e?1==t||3==t?"one":2==t?"two":4==t?"few":"other":1!=t||n[1]?"other":"one"},ce:function(t,e){return e?"other":1==t?"one":"other"},cgg:function(t,e){return e?"other":1==t?"one":"other"},chr:function(t,e){return e?"other":1==t?"one":"other"},ckb:function(t,e){return e?"other":1==t?"one":"other"},cs:function(t,e){var n=String(t).split("."),i=n[0],r=!n[1];return e?"other":1==t&&r?"one":i>=2&&i<=4&&r?"few":r?"other":"many"},cy:function(t,e){return e?0==t||7==t||8==t||9==t?"zero":1==t?"one":2==t?"two":3==t||4==t?"few":5==t||6==t?"many":"other":0==t?"zero":1==t?"one":2==t?"two":3==t?"few":6==t?"many":"other"},da:function(t,e){var n=String(t).split("."),i=n[0],r=Number(n[0])==t;return e||1!=t&&(r||0!=i&&1!=i)?"other":"one"},de:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},dsb:function(t,e){var n=String(t).split("."),i=n[1]||"",r=!n[1],s=n[0].slice(-2),o=i.slice(-2);return e?"other":r&&1==s||1==o?"one":r&&2==s||2==o?"two":r&&(3==s||4==s)||3==o||4==o?"few":"other"},dv:function(t,e){return e?"other":1==t?"one":"other"},dz:function(t,e){return"other"},ee:function(t,e){return e?"other":1==t?"one":"other"},el:function(t,e){return e?"other":1==t?"one":"other"},en:function(t,e){var n=String(t).split("."),i=!n[1],r=Number(n[0])==t,s=r&&n[0].slice(-1),o=r&&n[0].slice(-2);return e?1==s&&11!=o?"one":2==s&&12!=o?"two":3==s&&13!=o?"few":"other":1==t&&i?"one":"other"},eo:function(t,e){return e?"other":1==t?"one":"other"},es:function(t,e){return e?"other":1==t?"one":"other"},et:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},eu:function(t,e){return e?"other":1==t?"one":"other"},fa:function(t,e){return e?"other":t>=0&&t<=1?"one":"other"},ff:function(t,e){return e?"other":t>=0&&t<2?"one":"other"},fi:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},fil:function(t,e){var n=String(t).split("."),i=n[0],r=n[1]||"",s=!n[1],o=i.slice(-1),a=r.slice(-1);return e?1==t?"one":"other":s&&(1==i||2==i||3==i)||s&&4!=o&&6!=o&&9!=o||!s&&4!=a&&6!=a&&9!=a?"one":"other"},fo:function(t,e){return e?"other":1==t?"one":"other"},fr:function(t,e){return e?1==t?"one":"other":t>=0&&t<2?"one":"other"},fur:function(t,e){return e?"other":1==t?"one":"other"},fy:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},ga:function(t,e){var n=String(t).split("."),i=Number(n[0])==t;return e?1==t?"one":"other":1==t?"one":2==t?"two":i&&t>=3&&t<=6?"few":i&&t>=7&&t<=10?"many":"other"},gd:function(t,e){var n=String(t).split("."),i=Number(n[0])==t;return e?1==t||11==t?"one":2==t||12==t?"two":3==t||13==t?"few":"other":1==t||11==t?"one":2==t||12==t?"two":i&&t>=3&&t<=10||i&&t>=13&&t<=19?"few":"other"},gl:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},gsw:function(t,e){return e?"other":1==t?"one":"other"},gu:function(t,e){return e?1==t?"one":2==t||3==t?"two":4==t?"few":6==t?"many":"other":t>=0&&t<=1?"one":"other"},guw:function(t,e){return e?"other":0==t||1==t?"one":"other"},gv:function(t,e){var n=String(t).split("."),i=n[0],r=!n[1],s=i.slice(-1),o=i.slice(-2);return e?"other":r&&1==s?"one":r&&2==s?"two":!r||0!=o&&20!=o&&40!=o&&60!=o&&80!=o?r?"other":"many":"few"},ha:function(t,e){return e?"other":1==t?"one":"other"},haw:function(t,e){return e?"other":1==t?"one":"other"},he:function(t,e){var n=String(t).split("."),i=n[0],r=!n[1],s=Number(n[0])==t,o=s&&n[0].slice(-1);return e?"other":1==t&&r?"one":2==i&&r?"two":r&&(t<0||t>10)&&s&&0==o?"many":"other"},hi:function(t,e){return e?1==t?"one":2==t||3==t?"two":4==t?"few":6==t?"many":"other":t>=0&&t<=1?"one":"other"},hr:function(t,e){var n=String(t).split("."),i=n[0],r=n[1]||"",s=!n[1],o=i.slice(-1),a=i.slice(-2),l=r.slice(-1),c=r.slice(-2);return e?"other":s&&1==o&&11!=a||1==l&&11!=c?"one":s&&o>=2&&o<=4&&(a<12||a>14)||l>=2&&l<=4&&(c<12||c>14)?"few":"other"},hsb:function(t,e){var n=String(t).split("."),i=n[1]||"",r=!n[1],s=n[0].slice(-2),o=i.slice(-2);return e?"other":r&&1==s||1==o?"one":r&&2==s||2==o?"two":r&&(3==s||4==s)||3==o||4==o?"few":"other"},hu:function(t,e){return e?1==t||5==t?"one":"other":1==t?"one":"other"},hy:function(t,e){return e?1==t?"one":"other":t>=0&&t<2?"one":"other"},ia:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},id:function(t,e){return"other"},ig:function(t,e){return"other"},ii:function(t,e){return"other"},in:function(t,e){return"other"},io:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},is:function(t,e){var n=String(t).split("."),i=n[0],r=Number(n[0])==t,s=i.slice(-1),o=i.slice(-2);return e?"other":r&&1==s&&11!=o||!r?"one":"other"},it:function(t,e){var n=String(t).split(".");return e?11==t||8==t||80==t||800==t?"many":"other":1!=t||n[1]?"other":"one"},iu:function(t,e){return e?"other":1==t?"one":2==t?"two":"other"},iw:function(t,e){var n=String(t).split("."),i=n[0],r=!n[1],s=Number(n[0])==t,o=s&&n[0].slice(-1);return e?"other":1==t&&r?"one":2==i&&r?"two":r&&(t<0||t>10)&&s&&0==o?"many":"other"},ja:function(t,e){return"other"},jbo:function(t,e){return"other"},jgo:function(t,e){return e?"other":1==t?"one":"other"},ji:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},jmc:function(t,e){return e?"other":1==t?"one":"other"},jv:function(t,e){return"other"},jw:function(t,e){return"other"},ka:function(t,e){var n=String(t).split(".")[0],i=n.slice(-2);return e?1==n?"one":0==n||i>=2&&i<=20||40==i||60==i||80==i?"many":"other":1==t?"one":"other"},kab:function(t,e){return e?"other":t>=0&&t<2?"one":"other"},kaj:function(t,e){return e?"other":1==t?"one":"other"},kcg:function(t,e){return e?"other":1==t?"one":"other"},kde:function(t,e){return"other"},kea:function(t,e){return"other"},kk:function(t,e){var n=String(t).split("."),i=Number(n[0])==t,r=i&&n[0].slice(-1);return e?6==r||9==r||i&&0==r&&0!=t?"many":"other":1==t?"one":"other"},kkj:function(t,e){return e?"other":1==t?"one":"other"},kl:function(t,e){return e?"other":1==t?"one":"other"},km:function(t,e){return"other"},kn:function(t,e){return e?"other":t>=0&&t<=1?"one":"other"},ko:function(t,e){return"other"},ks:function(t,e){return e?"other":1==t?"one":"other"},ksb:function(t,e){return e?"other":1==t?"one":"other"},ksh:function(t,e){return e?"other":0==t?"zero":1==t?"one":"other"},ku:function(t,e){return e?"other":1==t?"one":"other"},kw:function(t,e){return e?"other":1==t?"one":2==t?"two":"other"},ky:function(t,e){return e?"other":1==t?"one":"other"},lag:function(t,e){var n=String(t).split(".")[0];return e?"other":0==t?"zero":0!=n&&1!=n||0==t?"other":"one"},lb:function(t,e){return e?"other":1==t?"one":"other"},lg:function(t,e){return e?"other":1==t?"one":"other"},lkt:function(t,e){return"other"},ln:function(t,e){return e?"other":0==t||1==t?"one":"other"},lo:function(t,e){return e&&1==t?"one":"other"},lt:function(t,e){var n=String(t).split("."),i=n[1]||"",r=Number(n[0])==t,s=r&&n[0].slice(-1),o=r&&n[0].slice(-2);return e?"other":1==s&&(o<11||o>19)?"one":s>=2&&s<=9&&(o<11||o>19)?"few":0!=i?"many":"other"},lv:function(t,e){var n=String(t).split("."),i=n[1]||"",r=i.length,s=Number(n[0])==t,o=s&&n[0].slice(-1),a=s&&n[0].slice(-2),l=i.slice(-2),c=i.slice(-1);return e?"other":s&&0==o||a>=11&&a<=19||2==r&&l>=11&&l<=19?"zero":1==o&&11!=a||2==r&&1==c&&11!=l||2!=r&&1==c?"one":"other"},mas:function(t,e){return e?"other":1==t?"one":"other"},mg:function(t,e){return e?"other":0==t||1==t?"one":"other"},mgo:function(t,e){return e?"other":1==t?"one":"other"},mk:function(t,e){var n=String(t).split("."),i=n[0],r=n[1]||"",s=!n[1],o=i.slice(-1),a=i.slice(-2),l=r.slice(-1),c=r.slice(-2);return e?1==o&&11!=a?"one":2==o&&12!=a?"two":7!=o&&8!=o||17==a||18==a?"other":"many":s&&1==o&&11!=a||1==l&&11!=c?"one":"other"},ml:function(t,e){return e?"other":1==t?"one":"other"},mn:function(t,e){return e?"other":1==t?"one":"other"},mo:function(t,e){var n=String(t).split("."),i=!n[1],r=Number(n[0])==t&&n[0].slice(-2);return e?1==t?"one":"other":1==t&&i?"one":!i||0==t||1!=t&&r>=1&&r<=19?"few":"other"},mr:function(t,e){return e?1==t?"one":2==t||3==t?"two":4==t?"few":"other":t>=0&&t<=1?"one":"other"},ms:function(t,e){return e&&1==t?"one":"other"},mt:function(t,e){var n=String(t).split("."),i=Number(n[0])==t&&n[0].slice(-2);return e?"other":1==t?"one":0==t||i>=2&&i<=10?"few":i>=11&&i<=19?"many":"other"},my:function(t,e){return"other"},nah:function(t,e){return e?"other":1==t?"one":"other"},naq:function(t,e){return e?"other":1==t?"one":2==t?"two":"other"},nb:function(t,e){return e?"other":1==t?"one":"other"},nd:function(t,e){return e?"other":1==t?"one":"other"},ne:function(t,e){var n=String(t).split("."),i=Number(n[0])==t;return e?i&&t>=1&&t<=4?"one":"other":1==t?"one":"other"},nl:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},nn:function(t,e){return e?"other":1==t?"one":"other"},nnh:function(t,e){return e?"other":1==t?"one":"other"},no:function(t,e){return e?"other":1==t?"one":"other"},nqo:function(t,e){return"other"},nr:function(t,e){return e?"other":1==t?"one":"other"},nso:function(t,e){return e?"other":0==t||1==t?"one":"other"},ny:function(t,e){return e?"other":1==t?"one":"other"},nyn:function(t,e){return e?"other":1==t?"one":"other"},om:function(t,e){return e?"other":1==t?"one":"other"},or:function(t,e){var n=String(t).split("."),i=Number(n[0])==t;return e?1==t||5==t||i&&t>=7&&t<=9?"one":2==t||3==t?"two":4==t?"few":6==t?"many":"other":1==t?"one":"other"},os:function(t,e){return e?"other":1==t?"one":"other"},pa:function(t,e){return e?"other":0==t||1==t?"one":"other"},pap:function(t,e){return e?"other":1==t?"one":"other"},pl:function(t,e){var n=String(t).split("."),i=n[0],r=!n[1],s=i.slice(-1),o=i.slice(-2);return e?"other":1==t&&r?"one":r&&s>=2&&s<=4&&(o<12||o>14)?"few":r&&1!=i&&(0==s||1==s)||r&&s>=5&&s<=9||r&&o>=12&&o<=14?"many":"other"},prg:function(t,e){var n=String(t).split("."),i=n[1]||"",r=i.length,s=Number(n[0])==t,o=s&&n[0].slice(-1),a=s&&n[0].slice(-2),l=i.slice(-2),c=i.slice(-1);return e?"other":s&&0==o||a>=11&&a<=19||2==r&&l>=11&&l<=19?"zero":1==o&&11!=a||2==r&&1==c&&11!=l||2!=r&&1==c?"one":"other"},ps:function(t,e){return e?"other":1==t?"one":"other"},pt:function(t,e){var n=String(t).split(".")[0];return e?"other":0==n||1==n?"one":"other"},"pt-PT":function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},rm:function(t,e){return e?"other":1==t?"one":"other"},ro:function(t,e){var n=String(t).split("."),i=!n[1],r=Number(n[0])==t&&n[0].slice(-2);return e?1==t?"one":"other":1==t&&i?"one":!i||0==t||1!=t&&r>=1&&r<=19?"few":"other"},rof:function(t,e){return e?"other":1==t?"one":"other"},root:function(t,e){return"other"},ru:function(t,e){var n=String(t).split("."),i=n[0],r=!n[1],s=i.slice(-1),o=i.slice(-2);return e?"other":r&&1==s&&11!=o?"one":r&&s>=2&&s<=4&&(o<12||o>14)?"few":r&&0==s||r&&s>=5&&s<=9||r&&o>=11&&o<=14?"many":"other"},rwk:function(t,e){return e?"other":1==t?"one":"other"},sah:function(t,e){return"other"},saq:function(t,e){return e?"other":1==t?"one":"other"},sc:function(t,e){var n=String(t).split(".");return e?11==t||8==t||80==t||800==t?"many":"other":1!=t||n[1]?"other":"one"},scn:function(t,e){var n=String(t).split(".");return e?11==t||8==t||80==t||800==t?"many":"other":1!=t||n[1]?"other":"one"},sd:function(t,e){return e?"other":1==t?"one":"other"},sdh:function(t,e){return e?"other":1==t?"one":"other"},se:function(t,e){return e?"other":1==t?"one":2==t?"two":"other"},seh:function(t,e){return e?"other":1==t?"one":"other"},ses:function(t,e){return"other"},sg:function(t,e){return"other"},sh:function(t,e){var n=String(t).split("."),i=n[0],r=n[1]||"",s=!n[1],o=i.slice(-1),a=i.slice(-2),l=r.slice(-1),c=r.slice(-2);return e?"other":s&&1==o&&11!=a||1==l&&11!=c?"one":s&&o>=2&&o<=4&&(a<12||a>14)||l>=2&&l<=4&&(c<12||c>14)?"few":"other"},shi:function(t,e){var n=String(t).split("."),i=Number(n[0])==t;return e?"other":t>=0&&t<=1?"one":i&&t>=2&&t<=10?"few":"other"},si:function(t,e){var n=String(t).split(".");return e?"other":0==t||1==t||0==n[0]&&1==(n[1]||"")?"one":"other"},sk:function(t,e){var n=String(t).split("."),i=n[0],r=!n[1];return e?"other":1==t&&r?"one":i>=2&&i<=4&&r?"few":r?"other":"many"},sl:function(t,e){var n=String(t).split("."),i=!n[1],r=n[0].slice(-2);return e?"other":i&&1==r?"one":i&&2==r?"two":i&&(3==r||4==r)||!i?"few":"other"},sma:function(t,e){return e?"other":1==t?"one":2==t?"two":"other"},smi:function(t,e){return e?"other":1==t?"one":2==t?"two":"other"},smj:function(t,e){return e?"other":1==t?"one":2==t?"two":"other"},smn:function(t,e){return e?"other":1==t?"one":2==t?"two":"other"},sms:function(t,e){return e?"other":1==t?"one":2==t?"two":"other"},sn:function(t,e){return e?"other":1==t?"one":"other"},so:function(t,e){return e?"other":1==t?"one":"other"},sq:function(t,e){var n=String(t).split("."),i=Number(n[0])==t,r=i&&n[0].slice(-1),s=i&&n[0].slice(-2);return e?1==t?"one":4==r&&14!=s?"many":"other":1==t?"one":"other"},sr:function(t,e){var n=String(t).split("."),i=n[0],r=n[1]||"",s=!n[1],o=i.slice(-1),a=i.slice(-2),l=r.slice(-1),c=r.slice(-2);return e?"other":s&&1==o&&11!=a||1==l&&11!=c?"one":s&&o>=2&&o<=4&&(a<12||a>14)||l>=2&&l<=4&&(c<12||c>14)?"few":"other"},ss:function(t,e){return e?"other":1==t?"one":"other"},ssy:function(t,e){return e?"other":1==t?"one":"other"},st:function(t,e){return e?"other":1==t?"one":"other"},sv:function(t,e){var n=String(t).split("."),i=!n[1],r=Number(n[0])==t,s=r&&n[0].slice(-1),o=r&&n[0].slice(-2);return e?1!=s&&2!=s||11==o||12==o?"other":"one":1==t&&i?"one":"other"},sw:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},syr:function(t,e){return e?"other":1==t?"one":"other"},ta:function(t,e){return e?"other":1==t?"one":"other"},te:function(t,e){return e?"other":1==t?"one":"other"},teo:function(t,e){return e?"other":1==t?"one":"other"},th:function(t,e){return"other"},ti:function(t,e){return e?"other":0==t||1==t?"one":"other"},tig:function(t,e){return e?"other":1==t?"one":"other"},tk:function(t,e){var n=String(t).split("."),i=Number(n[0])==t&&n[0].slice(-1);return e?6==i||9==i||10==t?"few":"other":1==t?"one":"other"},tl:function(t,e){var n=String(t).split("."),i=n[0],r=n[1]||"",s=!n[1],o=i.slice(-1),a=r.slice(-1);return e?1==t?"one":"other":s&&(1==i||2==i||3==i)||s&&4!=o&&6!=o&&9!=o||!s&&4!=a&&6!=a&&9!=a?"one":"other"},tn:function(t,e){return e?"other":1==t?"one":"other"},to:function(t,e){return"other"},tr:function(t,e){return e?"other":1==t?"one":"other"},ts:function(t,e){return e?"other":1==t?"one":"other"},tzm:function(t,e){var n=String(t).split("."),i=Number(n[0])==t;return e?"other":0==t||1==t||i&&t>=11&&t<=99?"one":"other"},ug:function(t,e){return e?"other":1==t?"one":"other"},uk:function(t,e){var n=String(t).split("."),i=n[0],r=!n[1],s=Number(n[0])==t,o=s&&n[0].slice(-1),a=s&&n[0].slice(-2),l=i.slice(-1),c=i.slice(-2);return e?3==o&&13!=a?"few":"other":r&&1==l&&11!=c?"one":r&&l>=2&&l<=4&&(c<12||c>14)?"few":r&&0==l||r&&l>=5&&l<=9||r&&c>=11&&c<=14?"many":"other"},ur:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},uz:function(t,e){return e?"other":1==t?"one":"other"},ve:function(t,e){return e?"other":1==t?"one":"other"},vi:function(t,e){return e&&1==t?"one":"other"},vo:function(t,e){return e?"other":1==t?"one":"other"},vun:function(t,e){return e?"other":1==t?"one":"other"},wa:function(t,e){return e?"other":0==t||1==t?"one":"other"},wae:function(t,e){return e?"other":1==t?"one":"other"},wo:function(t,e){return"other"},xh:function(t,e){return e?"other":1==t?"one":"other"},xog:function(t,e){return e?"other":1==t?"one":"other"},yi:function(t,e){var n=String(t).split(".");return e||1!=t||n[1]?"other":"one"},yo:function(t,e){return"other"},yue:function(t,e){return"other"},zh:function(t,e){return"other"},zu:function(t,e){return e?"other":t>=0&&t<=1?"one":"other"}})?i.call(e,n,e,t):i)||(t.exports=r)},function(t,e,n){t.exports={date:n(4),duration:n(5),number:n(6),time:n(7)}},function(t,e,n){"use strict";function i(t,e,n,r){this.message=t,this.expected=e,this.found=n,this.location=r,this.name="SyntaxError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,i)}!function(t,e){function n(){this.constructor=t}n.prototype=e.prototype,t.prototype=new n}(i,Error),i.buildMessage=function(t,e){var n={literal:function(t){return'"'+r(t.text)+'"'},class:function(t){var e,n="";for(e=0;e<t.parts.length;e++)n+=t.parts[e]instanceof Array?s(t.parts[e][0])+"-"+s(t.parts[e][1]):s(t.parts[e]);return"["+(t.inverted?"^":"")+n+"]"},any:function(t){return"any character"},end:function(t){return"end of input"},other:function(t){return t.description}};function i(t){return t.charCodeAt(0).toString(16).toUpperCase()}function r(t){return t.replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,function(t){return"\\x0"+i(t)}).replace(/[\x10-\x1F\x7F-\x9F]/g,function(t){return"\\x"+i(t)})}function s(t){return t.replace(/\\/g,"\\\\").replace(/\]/g,"\\]").replace(/\^/g,"\\^").replace(/-/g,"\\-").replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,function(t){return"\\x0"+i(t)}).replace(/[\x10-\x1F\x7F-\x9F]/g,function(t){return"\\x"+i(t)})}return"Expected "+function(t){var e,i,r,s=new Array(t.length);for(e=0;e<t.length;e++)s[e]=n[(r=t[e]).type](r);if(s.sort(),s.length>0){for(e=1,i=1;e<s.length;e++)s[e-1]!==s[e]&&(s[i]=s[e],i++);s.length=i}switch(s.length){case 1:return s[0];case 2:return s[0]+" or "+s[1];default:return s.slice(0,-1).join(", ")+", or "+s[s.length-1]}}(t)+" but "+function(t){return t?'"'+r(t)+'"':"end of input"}(e)+" found."},t.exports={SyntaxError:i,parse:function(t,e){e=void 0!==e?e:{};var n,r={},s={start:Ct},o=Ct,a=xt("#",!1),l=function(){return Ft[0]},c=function(t){return t.join("")},u="{",h=xt("{",!1),d="}",p=xt("}",!1),f=",",m=xt(",",!1),g="select",y=xt("select",!1),v=function(t,n){return e.strict&&Ft.unshift(!1),n},b=function(t,n){return e.strict&&Ft.shift(),{type:"select",arg:t,cases:n}},A="plural",x=xt("plural",!1),w="selectordinal",_=xt("selectordinal",!1),S=function(t,n,i,r){var s=("selectordinal"===n?e.ordinal:e.cardinal)||["zero","one","two","few","many","other"];return s&&s.length&&r.forEach(function(e){if(isNaN(e.key)&&s.indexOf(e.key)<0)throw new Error("Invalid key `"+e.key+"` for argument `"+t+"`. Valid "+n+" keys for this locale are `"+s.join("`, `")+"`, and explicit keys like `=0`.")}),Ft.shift(),{type:n,arg:t,offset:i||0,cases:r}},E=_t("identifier"),C=/^[^\t-\r \x85\u200E\u200F\u2028\u2029!-\/:-@[-\^`{-~\xA1-\xA7\xA9\xAB\xAC\xAE\xB0\xB1\xB6\xBB\xBF\xD7\xF7\u2010-\u2027\u2030-\u203E\u2041-\u2053\u2055-\u205E\u2190-\u245F\u2500-\u2775\u2794-\u2BFF\u2E00-\u2E7F\u3001-\u3003\u3008-\u3020\u3030\uFD3E\uFD3F\uFE45\uFE46]/,I=wt([["\t","\r"]," ","\x85","\u200e","\u200f","\u2028","\u2029",["!","/"],[":","@"],["[","^"],"`",["{","~"],["\xa1","\xa7"],"\xa9","\xab","\xac","\xae","\xb0","\xb1","\xb6","\xbb","\xbf","\xd7","\xf7",["\u2010","\u2027"],["\u2030","\u203e"],["\u2041","\u2053"],["\u2055","\u205e"],["\u2190","\u245f"],["\u2500","\u2775"],["\u2794","\u2bff"],["\u2e00","\u2e7f"],["\u3001","\u3003"],["\u3008","\u3020"],"\u3030","\ufd3e","\ufd3f","\ufe45","\ufe46"],!0,!1),T=function(t,e){return{key:t,tokens:e}},M=_t("plural offset"),k="offset",R=xt("offset",!1),N=xt(":",!1),L=xt("=",!1),D="number",B=xt("number",!1),O="date",P=xt("date",!1),F="time",$=xt("time",!1),z="spellout",U=xt("spellout",!1),H="ordinal",V=xt("ordinal",!1),G="duration",W=xt("duration",!1),j=function(t){if(e.strict||/^\d/.test(t))return!1;switch(t.toLowerCase()){case"select":case"plural":case"selectordinal":return!1;default:return!0}},Q=function(t){return!e.strict},q=_t("a valid (strict) function parameter"),X=/^[^'{}]/,Y=wt(["'","{","}"],!0,!1),K="'",J=xt("'",!1),Z=_t("doubled apostrophe"),tt=xt("''",!1),et=/^[^']/,nt=wt(["'"],!0,!1),it=xt("'{",!1),rt=xt("'}",!1),st=_t("escaped string"),ot=xt("'#",!1),at=_t("plain char"),lt=/^[^{}#\0-\x08\x0E-\x1F\x7F]/,ct=wt(["{","}","#",["\0","\b"],["\x0e","\x1f"],"\x7f"],!0,!1),ut=_t("integer"),ht=/^[0-9]/,dt=wt([["0","9"]],!1,!1),pt=_t("white space"),ft=/^[\t-\r \x85\u200E\u200F\u2028\u2029]/,mt=wt([["\t","\r"]," ","\x85","\u200e","\u200f","\u2028","\u2029"],!1,!1),gt=0,yt=[{line:1,column:1}],vt=0,bt=[],At=0;if("startRule"in e){if(!(e.startRule in s))throw new Error("Can't start parsing from rule \""+e.startRule+'".');o=s[e.startRule]}function xt(t,e){return{type:"literal",text:t,ignoreCase:e}}function wt(t,e,n){return{type:"class",parts:t,inverted:e,ignoreCase:n}}function _t(t){return{type:"other",description:t}}function St(e){var n,i=yt[e];if(i)return i;for(n=e-1;!yt[n];)n--;for(i={line:(i=yt[n]).line,column:i.column};n<e;)10===t.charCodeAt(n)?(i.line++,i.column=1):i.column++,n++;return yt[e]=i,i}function Et(t){gt<vt||(gt>vt&&(vt=gt,bt=[]),bt.push(t))}function Ct(){var t,e;for(t=[],e=It();e!==r;)t.push(e),e=It();return t}function It(){var e,n,i;if((e=function(){var e,n,i,s;return e=gt,123===t.charCodeAt(gt)?(n=u,gt++):(n=r,0===At&&Et(h)),n!==r&&Pt()!==r&&(i=Tt())!==r&&Pt()!==r?(125===t.charCodeAt(gt)?(s=d,gt++):(s=r,0===At&&Et(p)),s!==r?e=n=function(t){return{type:"argument",arg:t}}(i):(gt=e,e=r)):(gt=e,e=r),e}())===r&&(e=function(){var e,n,i,s,o,a,l,c,A;if(e=gt,123===t.charCodeAt(gt)?(n=u,gt++):(n=r,0===At&&Et(h)),n!==r)if(Pt()!==r)if((i=Tt())!==r)if(Pt()!==r)if(44===t.charCodeAt(gt)?(s=f,gt++):(s=r,0===At&&Et(m)),s!==r)if(Pt()!==r)if(t.substr(gt,6)===g?(o=g,gt+=6):(o=r,0===At&&Et(y)),o!==r&&(o=v(0,o)),o!==r)if((o=Pt())!==r)if(44===t.charCodeAt(gt)?(a=f,gt++):(a=r,0===At&&Et(m)),a!==r)if(Pt()!==r){if(l=[],(c=Mt())!==r)for(;c!==r;)l.push(c),c=Mt();else l=r;l!==r&&(c=Pt())!==r?(125===t.charCodeAt(gt)?(A=d,gt++):(A=r,0===At&&Et(p)),A!==r?e=n=b(i,l):(gt=e,e=r)):(gt=e,e=r)}else gt=e,e=r;else gt=e,e=r;else gt=e,e=r;else gt=e,e=r;else gt=e,e=r;else gt=e,e=r;else gt=e,e=r;else gt=e,e=r;else gt=e,e=r;else gt=e,e=r;return e}())===r&&(e=function(){var e,n,i,s,o,a,l,c,g,y,v;if(e=gt,123===t.charCodeAt(gt)?(n=u,gt++):(n=r,0===At&&Et(h)),n!==r)if(Pt()!==r)if((i=Tt())!==r)if(Pt()!==r)if(44===t.charCodeAt(gt)?(s=f,gt++):(s=r,0===At&&Et(m)),s!==r)if(Pt()!==r)if(t.substr(gt,6)===A?(a=A,gt+=6):(a=r,0===At&&Et(x)),a===r&&(t.substr(gt,13)===w?(a=w,gt+=13):(a=r,0===At&&Et(_))),a!==r&&(a=function(t,e){return Ft.unshift(!0),e}(0,a)),(o=a)!==r)if((a=Pt())!==r)if(44===t.charCodeAt(gt)?(l=f,gt++):(l=r,0===At&&Et(m)),l!==r)if(Pt()!==r)if((c=function(){var e,n,i,s;return At++,e=gt,Pt()!==r?(t.substr(gt,6)===k?(n=k,gt+=6):(n=r,0===At&&Et(R)),n!==r&&Pt()!==r?(58===t.charCodeAt(gt)?(i=":",gt++):(i=r,0===At&&Et(N)),i!==r&&Pt()!==r&&(s=Ot())!==r&&Pt()!==r?e=s:(gt=e,e=r)):(gt=e,e=r)):(gt=e,e=r),At--,e===r&&0===At&&Et(M),e}())===r&&(c=null),c!==r){if(g=[],(y=kt())!==r)for(;y!==r;)g.push(y),y=kt();else g=r;g!==r&&(y=Pt())!==r?(125===t.charCodeAt(gt)?(v=d,gt++):(v=r,0===At&&Et(p)),v!==r?e=n=S(i,o,c,g):(gt=e,e=r)):(gt=e,e=r)}else gt=e,e=r;else gt=e,e=r;else gt=e,e=r;else gt=e,e=r;else gt=e,e=r;else gt=e,e=r;else gt=e,e=r;else gt=e,e=r;else gt=e,e=r;else gt=e,e=r;else gt=e,e=r;return e}())===r&&(e=function(){var e,n,i,s,o,a,l;return e=gt,123===t.charCodeAt(gt)?(n=u,gt++):(n=r,0===At&&Et(h)),n!==r&&Pt()!==r&&(i=Tt())!==r&&Pt()!==r?(44===t.charCodeAt(gt)?(s=f,gt++):(s=r,0===At&&Et(m)),s!==r&&Pt()!==r&&(o=function(){var e,n,i,s,o;return t.substr(gt,6)===D?(e=D,gt+=6):(e=r,0===At&&Et(B)),e===r&&(t.substr(gt,4)===O?(e=O,gt+=4):(e=r,0===At&&Et(P)),e===r&&(t.substr(gt,4)===F?(e=F,gt+=4):(e=r,0===At&&Et($)),e===r&&(t.substr(gt,8)===z?(e=z,gt+=8):(e=r,0===At&&Et(U)),e===r&&(t.substr(gt,7)===H?(e=H,gt+=7):(e=r,0===At&&Et(V)),e===r&&(t.substr(gt,8)===G?(e=G,gt+=8):(e=r,0===At&&Et(W)),e===r&&(e=gt,n=gt,At++,t.substr(gt,6)===g?(i=g,gt+=6):(i=r,0===At&&Et(y)),At--,i===r?n=void 0:(gt=n,n=r),n!==r?(i=gt,At++,t.substr(gt,6)===A?(s=A,gt+=6):(s=r,0===At&&Et(x)),At--,s===r?i=void 0:(gt=i,i=r),i!==r?(s=gt,At++,t.substr(gt,13)===w?(o=w,gt+=13):(o=r,0===At&&Et(_)),At--,o===r?s=void 0:(gt=s,s=r),s!==r&&(o=Tt())!==r&&(j(o)?void 0:r)!==r?e=n=o:(gt=e,e=r)):(gt=e,e=r)):(gt=e,e=r))))))),e}())!==r&&Pt()!==r?((a=function(){var e,n,i,s;if(e=gt,Pt()!==r)if(44===t.charCodeAt(gt)?(n=f,gt++):(n=r,0===At&&Et(m)),n!==r){for(i=[],s=It();s!==r;)i.push(s),s=It();i!==r&&(s=(s=Q())?void 0:r)!==r?e=function(t){return{tokens:t}}(i):(gt=e,e=r)}else gt=e,e=r;else gt=e,e=r;if(e===r)if(e=gt,Pt()!==r)if(44===t.charCodeAt(gt)?(n=f,gt++):(n=r,0===At&&Et(m)),n!==r){for(i=[],s=Nt();s!==r;)i.push(s),s=Nt();i!==r?e=function(t){return{tokens:[t.join("")]}}(i):(gt=e,e=r)}else gt=e,e=r;else gt=e,e=r;return e}())===r&&(a=null),a!==r?(125===t.charCodeAt(gt)?(l=d,gt++):(l=r,0===At&&Et(p)),l!==r?e=n=function(t,e,n){return{type:"function",arg:t,key:e,param:n}}(i,o,a):(gt=e,e=r)):(gt=e,e=r)):(gt=e,e=r)):(gt=e,e=r),e}())===r&&(e=gt,35===t.charCodeAt(gt)?(n="#",gt++):(n=r,0===At&&Et(a)),n!==r&&(i=(i=l())?void 0:r)!==r?e=n={type:"octothorpe"}:(gt=e,e=r),e===r)){if(e=gt,n=[],(i=Bt())!==r)for(;i!==r;)n.push(i),i=Bt();else n=r;n!==r&&(n=c(n)),e=n}return e}function Tt(){var e,n,i;if(At++,e=gt,n=[],C.test(t.charAt(gt))?(i=t.charAt(gt),gt++):(i=r,0===At&&Et(I)),i!==r)for(;i!==r;)n.push(i),C.test(t.charAt(gt))?(i=t.charAt(gt),gt++):(i=r,0===At&&Et(I));else n=r;return e=n!==r?t.substring(e,gt):n,At--,e===r&&(n=r,0===At&&Et(E)),e}function Mt(){var t,e,n;return t=gt,Pt()!==r&&(e=Tt())!==r&&Pt()!==r&&(n=Rt())!==r?t=T(e,n):(gt=t,t=r),t}function kt(){var e,n,i;return e=gt,Pt()!==r&&(n=function(){var e,n,i;return(e=Tt())===r&&(e=gt,61===t.charCodeAt(gt)?(n="=",gt++):(n=r,0===At&&Et(L)),n!==r&&(i=Ot())!==r?e=n=i:(gt=e,e=r)),e}())!==r&&Pt()!==r&&(i=Rt())!==r?e=T(n,i):(gt=e,e=r),e}function Rt(){var e,n,i,s,o,a;if(e=gt,123===t.charCodeAt(gt)?(n=u,gt++):(n=r,0===At&&Et(h)),n!==r)if(i=gt,(s=Pt())!==r?(o=gt,At++,123===t.charCodeAt(gt)?(a=u,gt++):(a=r,0===At&&Et(h)),At--,a!==r?(gt=o,o=void 0):o=r,o!==r?i=s=[s,o]:(gt=i,i=r)):(gt=i,i=r),i===r&&(i=null),i!==r){for(s=[],o=It();o!==r;)s.push(o),o=It();s!==r&&(o=Pt())!==r?(125===t.charCodeAt(gt)?(a=d,gt++):(a=r,0===At&&Et(p)),a!==r?e=n=s:(gt=e,e=r)):(gt=e,e=r)}else gt=e,e=r;else gt=e,e=r;return e}function Nt(){var e,n,i,s;if(At++,e=gt,n=[],X.test(t.charAt(gt))?(i=t.charAt(gt),gt++):(i=r,0===At&&Et(Y)),i!==r)for(;i!==r;)n.push(i),X.test(t.charAt(gt))?(i=t.charAt(gt),gt++):(i=r,0===At&&Et(Y));else n=r;if(n!==r&&(n=function(t){return t.join("")}(n)),(e=n)===r&&(e=Lt())===r&&(e=gt,39===t.charCodeAt(gt)?(n=K,gt++):(n=r,0===At&&Et(J)),n!==r&&(i=Dt())!==r?(39===t.charCodeAt(gt)?(s=K,gt++):(s=r,0===At&&Et(J)),s!==r?e=n=i:(gt=e,e=r)):(gt=e,e=r),e===r))if(e=gt,123===t.charCodeAt(gt)?(n=u,gt++):(n=r,0===At&&Et(h)),n!==r){for(i=[],s=Nt();s!==r;)i.push(s),s=Nt();i!==r?(125===t.charCodeAt(gt)?(s=d,gt++):(s=r,0===At&&Et(p)),s!==r?e=n=function(t){return"{"+t.join("")+"}"}(i):(gt=e,e=r)):(gt=e,e=r)}else gt=e,e=r;return At--,e===r&&(n=r,0===At&&Et(q)),e}function Lt(){var e,n;return At++,"''"===t.substr(gt,2)?(n="''",gt+=2):(n=r,0===At&&Et(tt)),n!==r&&(n="'"),At--,(e=n)===r&&(n=r,0===At&&Et(Z)),e}function Dt(){var e,n,i;if((e=Lt())===r){if(e=gt,n=[],et.test(t.charAt(gt))?(i=t.charAt(gt),gt++):(i=r,0===At&&Et(nt)),i!==r)for(;i!==r;)n.push(i),et.test(t.charAt(gt))?(i=t.charAt(gt),gt++):(i=r,0===At&&Et(nt));else n=r;n!==r&&(n=c(n)),e=n}return e}function Bt(){var e,n;return(e=Lt())===r&&(e=function(){var e,n,i,s,o,a;if(At++,(e=function(){var e,n,i,s;if(e=gt,"'{"===t.substr(gt,2)?(n="'{",gt+=2):(n=r,0===At&&Et(it)),n!==r){for(i=[],s=Dt();s!==r;)i.push(s),s=Dt();i!==r?(39===t.charCodeAt(gt)?(s=K,gt++):(s=r,0===At&&Et(J)),s!==r?e=n=function(t){return"{"+t.join("")}(i):(gt=e,e=r)):(gt=e,e=r)}else gt=e,e=r;if(e===r)if(e=gt,"'}"===t.substr(gt,2)?(n="'}",gt+=2):(n=r,0===At&&Et(rt)),n!==r){for(i=[],s=Dt();s!==r;)i.push(s),s=Dt();i!==r?(39===t.charCodeAt(gt)?(s=K,gt++):(s=r,0===At&&Et(J)),s!==r?e=n=function(t){return"}"+t.join("")}(i):(gt=e,e=r)):(gt=e,e=r)}else gt=e,e=r;return e}())===r){if(e=gt,n=gt,i=gt,"'#"===t.substr(gt,2)?(s="'#",gt+=2):(s=r,0===At&&Et(ot)),s!==r){for(o=[],a=Dt();a!==r;)o.push(a),a=Dt();o!==r?(39===t.charCodeAt(gt)?(a=K,gt++):(a=r,0===At&&Et(J)),a!==r?i=s=function(t){return"#"+t.join("")}(o):(gt=i,i=r)):(gt=i,i=r)}else gt=i,i=r;i!==r&&(s=(s=l())?void 0:r)!==r?n=i=[i,s]:(gt=n,n=r),n!==r&&(n=function(t){return t[0]}(n)),(e=n)===r&&(39===t.charCodeAt(gt)?(e=K,gt++):(e=r,0===At&&Et(J)))}return At--,e===r&&(n=r,0===At&&Et(st)),e}())===r&&(e=gt,35===t.charCodeAt(gt)?(n="#",gt++):(n=r,0===At&&Et(a)),n!==r&&(Ft[0]?r:void 0)!==r?e=n=n:(gt=e,e=r),e===r&&(e=function(){var e;return At++,lt.test(t.charAt(gt))?(e=t.charAt(gt),gt++):(e=r,0===At&&Et(ct)),At--,e===r&&0===At&&Et(at),e}())),e}function Ot(){var e,n,i;if(At++,e=gt,n=[],ht.test(t.charAt(gt))?(i=t.charAt(gt),gt++):(i=r,0===At&&Et(dt)),i!==r)for(;i!==r;)n.push(i),ht.test(t.charAt(gt))?(i=t.charAt(gt),gt++):(i=r,0===At&&Et(dt));else n=r;return e=n!==r?t.substring(e,gt):n,At--,e===r&&(n=r,0===At&&Et(ut)),e}function Pt(){var e,n,i;for(At++,e=gt,n=[],ft.test(t.charAt(gt))?(i=t.charAt(gt),gt++):(i=r,0===At&&Et(mt));i!==r;)n.push(i),ft.test(t.charAt(gt))?(i=t.charAt(gt),gt++):(i=r,0===At&&Et(mt));return e=n!==r?t.substring(e,gt):n,At--,e===r&&(n=r,0===At&&Et(pt)),e}var Ft=[!1];if((n=o())!==r&&gt===t.length)return n;throw n!==r&&gt<t.length&&Et({type:"end"}),function(t,e,n){return new i(i.buildMessage(t,e),t,e,n)}(bt,vt<t.length?t.charAt(vt):null,function(t,e){var n=St(t),i=St(e);return{start:{offset:t,line:n.line,column:n.column},end:{offset:e,line:i.line,column:i.column}}}(vt,vt<t.length?vt+1:vt))}}},function(t,e,n){var i,r,s=[{cardinal:["other"],ordinal:["other"]},{cardinal:["one","other"],ordinal:["other"]},{cardinal:["one","other"],ordinal:["one","other"]},{cardinal:["one","two","other"],ordinal:["other"]}];void 0===(r="function"==typeof(i={af:s[1],ak:s[1],am:s[1],ar:{cardinal:["zero","one","two","few","many","other"],ordinal:["other"]},ars:{cardinal:["zero","one","two","few","many","other"],ordinal:["other"]},as:{cardinal:["one","other"],ordinal:["one","two","few","many","other"]},asa:s[1],ast:s[1],az:{cardinal:["one","other"],ordinal:["one","few","many","other"]},be:{cardinal:["one","few","many","other"],ordinal:["few","other"]},bem:s[1],bez:s[1],bg:s[1],bh:s[1],bm:s[0],bn:{cardinal:["one","other"],ordinal:["one","two","few","many","other"]},bo:s[0],br:{cardinal:["one","two","few","many","other"],ordinal:["other"]},brx:s[1],bs:{cardinal:["one","few","other"],ordinal:["other"]},ca:{cardinal:["one","other"],ordinal:["one","two","few","other"]},ce:s[1],cgg:s[1],chr:s[1],ckb:s[1],cs:{cardinal:["one","few","many","other"],ordinal:["other"]},cy:{cardinal:["zero","one","two","few","many","other"],ordinal:["zero","one","two","few","many","other"]},da:s[1],de:s[1],dsb:{cardinal:["one","two","few","other"],ordinal:["other"]},dv:s[1],dz:s[0],ee:s[1],el:s[1],en:{cardinal:["one","other"],ordinal:["one","two","few","other"]},eo:s[1],es:s[1],et:s[1],eu:s[1],fa:s[1],ff:s[1],fi:s[1],fil:s[2],fo:s[1],fr:s[2],fur:s[1],fy:s[1],ga:{cardinal:["one","two","few","many","other"],ordinal:["one","other"]},gd:{cardinal:["one","two","few","other"],ordinal:["one","two","few","other"]},gl:s[1],gsw:s[1],gu:{cardinal:["one","other"],ordinal:["one","two","few","many","other"]},guw:s[1],gv:{cardinal:["one","two","few","many","other"],ordinal:["other"]},ha:s[1],haw:s[1],he:{cardinal:["one","two","many","other"],ordinal:["other"]},hi:{cardinal:["one","other"],ordinal:["one","two","few","many","other"]},hr:{cardinal:["one","few","other"],ordinal:["other"]},hsb:{cardinal:["one","two","few","other"],ordinal:["other"]},hu:s[2],hy:s[2],ia:s[1],id:s[0],ig:s[0],ii:s[0],in:s[0],io:s[1],is:s[1],it:{cardinal:["one","other"],ordinal:["many","other"]},iu:s[3],iw:{cardinal:["one","two","many","other"],ordinal:["other"]},ja:s[0],jbo:s[0],jgo:s[1],ji:s[1],jmc:s[1],jv:s[0],jw:s[0],ka:{cardinal:["one","other"],ordinal:["one","many","other"]},kab:s[1],kaj:s[1],kcg:s[1],kde:s[0],kea:s[0],kk:{cardinal:["one","other"],ordinal:["many","other"]},kkj:s[1],kl:s[1],km:s[0],kn:s[1],ko:s[0],ks:s[1],ksb:s[1],ksh:{cardinal:["zero","one","other"],ordinal:["other"]},ku:s[1],kw:s[3],ky:s[1],lag:{cardinal:["zero","one","other"],ordinal:["other"]},lb:s[1],lg:s[1],lkt:s[0],ln:s[1],lo:{cardinal:["other"],ordinal:["one","other"]},lt:{cardinal:["one","few","many","other"],ordinal:["other"]},lv:{cardinal:["zero","one","other"],ordinal:["other"]},mas:s[1],mg:s[1],mgo:s[1],mk:{cardinal:["one","other"],ordinal:["one","two","many","other"]},ml:s[1],mn:s[1],mo:{cardinal:["one","few","other"],ordinal:["one","other"]},mr:{cardinal:["one","other"],ordinal:["one","two","few","other"]},ms:{cardinal:["other"],ordinal:["one","other"]},mt:{cardinal:["one","few","many","other"],ordinal:["other"]},my:s[0],nah:s[1],naq:s[3],nb:s[1],nd:s[1],ne:s[2],nl:s[1],nn:s[1],nnh:s[1],no:s[1],nqo:s[0],nr:s[1],nso:s[1],ny:s[1],nyn:s[1],om:s[1],or:{cardinal:["one","other"],ordinal:["one","two","few","many","other"]},os:s[1],pa:s[1],pap:s[1],pl:{cardinal:["one","few","many","other"],ordinal:["other"]},prg:{cardinal:["zero","one","other"],ordinal:["other"]},ps:s[1],pt:s[1],"pt-PT":s[1],rm:s[1],ro:{cardinal:["one","few","other"],ordinal:["one","other"]},rof:s[1],root:s[0],ru:{cardinal:["one","few","many","other"],ordinal:["other"]},rwk:s[1],sah:s[0],saq:s[1],sc:{cardinal:["one","other"],ordinal:["many","other"]},scn:{cardinal:["one","other"],ordinal:["many","other"]},sd:s[1],sdh:s[1],se:s[3],seh:s[1],ses:s[0],sg:s[0],sh:{cardinal:["one","few","other"],ordinal:["other"]},shi:{cardinal:["one","few","other"],ordinal:["other"]},si:s[1],sk:{cardinal:["one","few","many","other"],ordinal:["other"]},sl:{cardinal:["one","two","few","other"],ordinal:["other"]},sma:s[3],smi:s[3],smj:s[3],smn:s[3],sms:s[3],sn:s[1],so:s[1],sq:{cardinal:["one","other"],ordinal:["one","many","other"]},sr:{cardinal:["one","few","other"],ordinal:["other"]},ss:s[1],ssy:s[1],st:s[1],sv:s[2],sw:s[1],syr:s[1],ta:s[1],te:s[1],teo:s[1],th:s[0],ti:s[1],tig:s[1],tk:{cardinal:["one","other"],ordinal:["few","other"]},tl:s[2],tn:s[1],to:s[0],tr:s[1],ts:s[1],tzm:s[1],ug:s[1],uk:{cardinal:["one","few","many","other"],ordinal:["few","other"]},ur:s[1],uz:s[1],ve:s[1],vi:{cardinal:["other"],ordinal:["one","other"]},vo:s[1],vun:s[1],wa:s[1],wae:s[1],wo:s[0],xh:s[1],xog:s[1],yi:s[1],yo:s[0],yue:s[0],zh:s[0],zu:s[1]})?i.call(e,n,e,t):i)||(t.exports=r)},function(t,e){function n(t,e,n){var i={day:"numeric",month:"short",year:"numeric"};switch(n){case"full":i.weekday="long";case"long":i.month="long";break;case"short":i.month="numeric"}return new Date(t).toLocaleDateString(e,i)}t.exports=function(){return n}},function(t,e){function n(t){if(!isFinite(t))return String(t);var e="";t<0?(e="-",t=Math.abs(t)):t=Number(t);var n=t%60,i=[Math.round(n)===n?n:n.toFixed(3)];return t<60?i.unshift(0):(t=Math.round((t-i[0])/60),i.unshift(t%60),t>=60&&(t=Math.round((t-i[0])/60),i.unshift(t))),e+i.shift()+":"+i.map(function(t){return t<10?"0"+String(t):String(t)}).join(":")}t.exports=function(){return n}},function(t,e){t.exports=function(t){var e=(function(t,e,n){var i=n&&n.split(":")||[],r={integer:{maximumFractionDigits:0},percent:{style:"percent"},currency:{style:"currency",currency:i[1]&&i[1].trim()||CURRENCY,minimumFractionDigits:2,maximumFractionDigits:2}};return new Intl.NumberFormat(e,r[i[0]]||{}).format(t)}).toString().replace("CURRENCY",JSON.stringify(t.currency||"USD")).match(/\(([^)]*)\)[^{]*{([\s\S]*)}/);return new Function(e[1],e[2])}},function(t,e){function n(t,e,n){var i={second:"numeric",minute:"numeric",hour:"numeric"};switch(n){case"full":case"long":i.timeZoneName="short";break;case"short":delete i.second}return new Date(t).toLocaleTimeString(e,i)}t.exports=function(){return n}},function(t,e,n){"use strict";n.r(e);var i=n(1),r=n.n(i),s=n(2),o={break:!0,continue:!0,delete:!0,else:!0,for:!0,function:!0,if:!0,in:!0,new:!0,return:!0,this:!0,typeof:!0,var:!0,void:!0,while:!0,with:!0,case:!0,catch:!0,default:!0,do:!0,finally:!0,instanceof:!0,switch:!0,throw:!0,try:!0},a={debugger:!0,class:!0,enum:!0,extends:!0,super:!0,const:!0,export:!0,import:!0,null:!0,true:!0,false:!0,implements:!0,let:!0,private:!0,public:!0,yield:!0,interface:!0,package:!0,protected:!0,static:!0};function l(t,e){if(/^[A-Z_$][0-9A-Z_$]*$/i.test(t)&&!o[t])return e?"".concat(e,".").concat(t):t;var n=JSON.stringify(t);return e?e+"[".concat(n,"]"):n}function c(t){var e=t.trim().replace(/\W+/g,"_");return o[e]||a[e]||/^\d/.test(e)?"_"+e:e}var u=new RegExp("^"+["ar","ckb","fa","he","ks($|[^bfh])","lrc","mzn","pa-Arab","ps","ug","ur","uz-Arab","yi"].join("|^"));function h(t){return(h="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}var d=function(){function t(e){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.mf=e,this.lc=null,this.locales={},this.runtime={},this.formatters={}}var e;return(e=[{key:"compile",value:function(t,e,n){var i=this;if("object"!=h(t)){this.lc=e;var r=n[e]||{cardinal:[],ordinal:[]};r.strict=!!this.mf.options.strictNumberSign;var o=Object(s.parse)(t,r).map(function(t){return i.token(t)});return"function(d) { return ".concat(o.join(" + ")||'""',"; }")}var a={};for(var l in t){var c=n.hasOwnProperty(l)?l:e;a[l]=this.compile(t[l],c,n)}return a}},{key:"cases",value:function(t,e){var n=this,i="select"===t.type||!this.mf.hasCustomPluralFuncs,r=t.cases.map(function(t){var r=t.key;"other"===r&&(i=!1);var s=t.tokens.map(function(t){return n.token(t,e)});return l(r)+": "+(s.join(" + ")||'""')});if(i)throw new Error("No 'other' form found in "+JSON.stringify(t));return"{ ".concat(r.join(", ")," }")}},{key:"token",value:function(t,e){var n,i=this;if("string"==typeof t)return JSON.stringify(t);var r,s,o,a=[l(t.arg,"d")];switch(t.type){case"argument":return this.mf.options.biDiSupport?(r=a[0],s=u.test(this.lc),o=JSON.stringify(s?"\u200f":"\u200e"),"".concat(o," + ").concat(r," + ").concat(o)):a[0];case"select":n="select",e&&this.mf.options.strictNumberSign&&(e=null),a.push(this.cases(t,e)),this.runtime.select=!0;break;case"selectordinal":n="plural",a.push(0,c(this.lc),this.cases(t,t),1),this.locales[this.lc]=!0,this.runtime.plural=!0;break;case"plural":n="plural",a.push(t.offset||0,c(this.lc),this.cases(t,t)),this.locales[this.lc]=!0,this.runtime.plural=!0;break;case"function":if(!(t.key in this.mf.fmt)&&t.key in this.mf.constructor.formatters&&(this.mf.fmt[t.key]=(0,this.mf.constructor.formatters[t.key])(this.mf)),!this.mf.fmt[t.key])throw new Error("Formatting function ".concat(JSON.stringify(t.key)," not found!"));if(a.push(JSON.stringify(this.lc)),t.param){e&&this.mf.options.strictNumberSign&&(e=null);var h=t.param.tokens.map(function(t){return i.token(t,e)});a.push("("+(h.join(" + ")||'""')+").trim()")}n=l(t.key,"fmt"),this.formatters[t.key]=!0;break;case"octothorpe":if(!e)return'"#"';n="number",a=[l(e.arg,"d"),JSON.stringify(e.arg)],e.offset&&a.push(e.offset),this.runtime.number=!0}if(!n)throw new Error("Parser error for token "+JSON.stringify(t));return"".concat(n,"(").concat(a.join(", "),")")}}])&&function(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}(t.prototype,e),t}(),p=n(3),f=n.n(p),m=n(0),g=n.n(m);function y(t,e,n){var i=function(){return e.apply(this,arguments)};if(i.toString=function(){return e.toString()},n){var r=f.a[t]||{};i.cardinal=r.cardinal,i.ordinal=r.ordinal}else i.cardinal=[],i.ordinal=[];return i}function v(t,e){for(var n=e.pluralKeyChecks,i=String(t);i;i=i.replace(/[-_]?[^-_]*$/,"")){var r=g.a[i];if(r)return y(i,r,n)}throw new Error("Localisation function not found for locale "+JSON.stringify(t))}function b(t){return(b="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}var A=function(){function t(e){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.plural=function(t,e,n,i,r){if({}.hasOwnProperty.call(i,t))return i[t];e&&(t-=e);var s=n(t,r);return s in i?i[s]:i.other},this.select=function(t,e){return{}.hasOwnProperty.call(e,t)?e[t]:e.other},this.mf=e,this.setStrictNumber(e.options.strictNumberSign)}var e;return(e=[{key:"setStrictNumber",value:function(e){this.number=e?t.strictNumber:t.defaultNumber}},{key:"toString",value:function(t,e){for(var n={},i=Object.keys(e.locales),r=0;r<i.length;++r){var s=i[r];n[c(s)]=t[s]}for(var o=Object.keys(e.runtime),a=0;a<o.length;++a){var u=o[a];n[u]=this[u]}var h=Object.keys(e.formatters);if(h.length>0){n.fmt={};for(var d=0;d<h.length;++d){var p=h[d];n.fmt[p]=this.mf.fmt[p]}}return function t(e,n){if("object"!=b(e)){var i=e.toString().replace(/^(function )\w*/,"$1"),r=/([ \t]*)\S.*$/.exec(i);return r?i.replace(new RegExp("^"+r[1],"mg"),""):i}var s=[];for(var o in e){var a=t(e[o],n+1);s.push(0===n?"var ".concat(o," = ").concat(a,";\n"):"".concat(l(o),": ").concat(a))}if(0===n)return s.join("");if(0===s.length)return"{}";for(var c="  ";--n;)c+="  ";var u=s.join(",\n").replace(/^/gm,c);return"{\n".concat(u,"\n}")}(n,0)}}])&&function(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}(t.prototype,e),t}();function x(t){return(x="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function w(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}function _(t,e,n){return e&&w(t.prototype,e),n&&w(t,n),t}A.defaultNumber=function(t,e,n){if(!n)return t;if(isNaN(t))throw new Error("Can't apply offset:"+n+" to argument `"+e+"` with non-numerical value "+JSON.stringify(t)+".");return t-n},A.strictNumber=function(t,e,n){if(isNaN(t))throw new Error("Argument `"+e+"` has non-numerical value "+JSON.stringify(t)+".");return t-(n||0)},n.d(e,"default",function(){return S});var S=function(){function t(e,n){var i=this;if(function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.options=Object.assign({biDiSupport:!1,customFormatters:null,pluralKeyChecks:!0,strictNumberSign:!1},n),this.pluralFuncs={},"string"==typeof e)this.pluralFuncs[e]=v(e,this.options),this.defaultLocale=e;else if(Array.isArray(e))e.forEach(function(t){i.pluralFuncs[t]=v(t,i.options)}),this.defaultLocale=e[0];else{if(e)for(var r=Object.keys(e),s=0;s<r.length;++s){var o=r[s];if("function"!=typeof e[o]){var a="Expected function value for locale "+String(o);throw new Error(a)}this.pluralFuncs[o]=e[o],this.defaultLocale||(this.defaultLocale=o)}this.defaultLocale?this.hasCustomPluralFuncs=!0:(this.defaultLocale=t.defaultLocale,this.hasCustomPluralFuncs=!1)}this.fmt=Object.assign({},this.options.customFormatters),this.runtime=new A(this)}return _(t,null,[{key:"escape",value:function(t,e){var n=e?/[#{}]/g:/[{}]/g;return String(t).replace(n,"'$&'")}}]),_(t,[{key:"addFormatters",value:function(t){for(var e=Object.keys(t),n=0;n<e.length;++n){var i=e[n];this.fmt[i]=t[i]}return this}},{key:"disablePluralKeyChecks",value:function(){for(var t in this.options.pluralKeyChecks=!1,this.pluralFuncs){var e=this.pluralFuncs[t];e&&(e.cardinal=[],e.ordinal=[])}return this}},{key:"setBiDiSupport",value:function(t){return this.options.biDiSupport=!!t||void 0===t,this}},{key:"setStrictNumberSign",value:function(t){return this.options.strictNumberSign=!!t||void 0===t,this.runtime.setStrictNumber(this.options.strictNumberSign),this}},{key:"compile",value:function(t,e){var n={};if(0===Object.keys(this.pluralFuncs).length)if(e){var i=v(e,this.options);if(!i){var r=JSON.stringify(e);throw new Error("Locale ".concat(r," not found!"))}n[e]=i}else e=this.defaultLocale,n=function(t){for(var e=t.pluralKeyChecks,n={},i=Object.keys(g.a),r=0;r<i.length;++r){var s=i[r];n[s]=y(s,g.a[s],e)}return n}(this.options);else if(e){var s=this.pluralFuncs[e];if(!s){var o=JSON.stringify(e),a=JSON.stringify(this.pluralFuncs);throw new Error("Locale ".concat(o," not found in ").concat(a,"!"))}n[e]=s}else e=this.defaultLocale,n=this.pluralFuncs;var u=new d(this),h=u.compile(t,e,n);if("object"!=x(t)){var p=new Function("number, plural, select, fmt",c(e),"return "+h),f=this.runtime;return p(f.number,f.plural,f.select,this.fmt,n[e])}var m=this.runtime.toString(n,u)+"\n",b=function t(e,n){if(n||(n=0),"object"!=x(e))return e;for(var i="",r=0;r<n;++r)i+="  ";var s=[];for(var o in e){var a=t(e[o],n+1);s.push("\n".concat(i,"  ").concat(l(o),": ").concat(a))}return"{".concat(s.join(","),"\n").concat(i,"}")}(h),A=new Function(m+"return "+b)();if(A.hasOwnProperty("toString"))throw new Error("The top-level message key `toString` is reserved");return A.toString=function(t){return t&&"export default"!==t?t.indexOf(".")>-1?m+t+" = "+b:m+["(function (root, G) {",'  if (typeof define === "function" && define.amd) { define(G); }','  else if (typeof exports === "object") { module.exports = G; }',"  else { "+l(t,"root")+" = G; }","})(this, "+b+");"].join("\n"):m+"export default "+b},A}}]),t}();S.defaultLocale="en",S.formatters=r.a}]).default},sZor:function(t,e,n){"use strict";n.d(e,"a",function(){return r}),n.d(e,"b",function(){return y}),n.d(e,"c",function(){return x}),n.d(e,"d",function(){return w});var i=n("DZm5");const r=(t,e)=>{return"string"==typeof t&&(e=t,t=void 0),(n=t,s(n)).includes(e);var n},s=(t=window)=>{if(void 0===t)return[];t.Ionic=t.Ionic||{};let e=t.Ionic.platforms;return null==e&&(e=t.Ionic.platforms=o(t),e.forEach(e=>t.document.documentElement.classList.add(`plt-${e}`))),e},o=t=>Object.keys(m).filter(e=>m[e](t)),a=t=>!!p(t,/iPad/i)||!(!p(t,/Macintosh/i)||!c(t)),l=t=>p(t,/android|sink/i),c=t=>f(t,"(any-pointer:coarse)"),u=t=>h(t)||d(t),h=t=>!!(t.cordova||t.phonegap||t.PhoneGap),d=t=>{const e=t.Capacitor;return!(!e||!e.isNative)},p=(t,e)=>e.test(t.navigator.userAgent),f=(t,e)=>t.matchMedia(e).matches,m={ipad:a,iphone:t=>p(t,/iPhone/i),ios:t=>p(t,/iPhone|iPod/i)||a(t),android:l,phablet:t=>{const e=t.innerWidth,n=t.innerHeight,i=Math.min(e,n),r=Math.max(e,n);return i>390&&i<520&&r>620&&r<800},tablet:t=>{const e=t.innerWidth,n=t.innerHeight,i=Math.min(e,n),r=Math.max(e,n);return a(t)||(t=>l(t)&&!p(t,/mobile/i))(t)||i>460&&i<820&&r>780&&r<1400},cordova:h,capacitor:d,electron:t=>p(t,/electron/i),pwa:t=>!(!t.matchMedia("(display-mode: standalone)").matches&&!t.navigator.standalone),mobile:c,mobileweb:t=>c(t)&&!u(t),desktop:t=>!c(t),hybrid:u};class g{constructor(){this.m=new Map}reset(t){this.m=new Map(Object.entries(t))}get(t,e){const n=this.m.get(t);return void 0!==n?n:e}getBoolean(t,e=!1){const n=this.m.get(t);return void 0===n?e:"string"==typeof n?"true"===n:!!n}getNumber(t,e){const n=parseFloat(this.m.get(t));return isNaN(n)?void 0!==e?e:NaN:n}set(t,e){this.m.set(t,e)}}const y=new g,v="ionic:",b="ionic-persist-config";let A;const x=t=>t&&Object(i.i)(t)||A,w=()=>{const t=document,e=window,n=e.Ionic=e.Ionic||{};s(e);const o=Object.assign(Object.assign(Object.assign(Object.assign({},(t=>{try{const e=t.sessionStorage.getItem(b);return null!==e?JSON.parse(e):{}}catch(e){return{}}})(e)),{persistConfig:!1}),n.config),(t=>{const e={};return t.location.search.slice(1).split("&").map(t=>t.split("=")).map(([t,e])=>[decodeURIComponent(t),decodeURIComponent(e)]).filter(([t])=>"ionic:"===t.substr(0,v.length)).map(([t,e])=>[t.slice(v.length),e]).forEach(([t,n])=>{e[t]=n}),e})(e));y.reset(o),y.getBoolean("persistConfig")&&((t,e)=>{try{t.sessionStorage.setItem(b,JSON.stringify(e))}catch(n){return}})(e,o),n.config=y,n.mode=A=y.get("mode",t.documentElement.getAttribute("mode")||(r(e,"ios")?"ios":"md")),y.set("mode",A),t.documentElement.setAttribute("mode",A),t.documentElement.classList.add(A),y.getBoolean("_testing")&&y.set("animated",!1);const a=t=>t.tagName&&t.tagName.startsWith("ION-"),l=t=>["ios","md"].includes(t);Object(i.m)(t=>{for(;t;){const e=t.mode||t.getAttribute("mode");if(e){if(l(e))return e;a(t)&&console.warn('Invalid ionic mode: "'+e+'", expected: "ios" or "md"')}t=t.parentElement}return A})}},uDiL:function(t,e,n){(function(t){var i;!function(t,r,s){function o(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var i=0;i<n.length+64;i++)e.x^=0|n.charCodeAt(i),e.next()}function a(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function l(t,e){var n=new o(t),i=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,i&&("object"==typeof i&&a(i,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(i=(function(){return l}).call(e,n,e,r))||(r.exports=i):this.xor128=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},yuCN:function(t,e,n){(function(t){var i;!function(t,r,s){function o(t){var e=this;e.next=function(){var t,n,i=e.x,r=e.i;return t=i[r],n=(t^=t>>>7)^t<<24,n^=(t=i[r+1&7])^t>>>10,n^=(t=i[r+3&7])^t>>>3,n^=(t=i[r+4&7])^t<<7,t=i[r+7&7],i[r]=n^=(t^=t<<13)^t<<9,e.i=r+1&7,n},function(t,e){var n,i=[];if(e===(0|e))i[0]=e;else for(e=""+e,n=0;n<e.length;++n)i[7&n]=i[7&n]<<15^e.charCodeAt(n)+i[n+1&7]<<13;for(;i.length<8;)i.push(0);for(n=0;n<8&&0===i[n];++n);for(8==n&&(i[7]=-1),t.x=i,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function a(t,e){return e.x=t.x.slice(),e.i=t.i,e}function l(t,e){null==t&&(t=+new Date);var n=new o(t),i=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,i&&(i.x&&a(i,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(i=(function(){return l}).call(e,n,e,r))||(r.exports=i):this.xorshift7=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},zUnb:function(t,e,n){"use strict";n.r(e);var i={};n.r(i),n.d(i,"shuffle",function(){return mM}),n.d(i,"shuffleCombo",function(){return gM}),n.d(i,"clamp",function(){return yM}),n.d(i,"nearestLargerEven",function(){return vM}),n.d(i,"swap",function(){return bM}),n.d(i,"sum",function(){return AM}),n.d(i,"randUniform",function(){return xM}),n.d(i,"distSquared",function(){return wM}),n.d(i,"assert",function(){return _M}),n.d(i,"assertShapesMatch",function(){return SM}),n.d(i,"assertNonNull",function(){return EM}),n.d(i,"flatten",function(){return CM}),n.d(i,"sizeFromShape",function(){return IM}),n.d(i,"isScalarShape",function(){return TM}),n.d(i,"arraysEqual",function(){return MM}),n.d(i,"isInt",function(){return kM}),n.d(i,"tanh",function(){return RM}),n.d(i,"sizeToSquarishShape",function(){return NM}),n.d(i,"createShuffledIndices",function(){return LM}),n.d(i,"rightPad",function(){return DM}),n.d(i,"repeatedTry",function(){return BM}),n.d(i,"inferFromImplicitShape",function(){return OM}),n.d(i,"parseAxisParam",function(){return PM}),n.d(i,"squeezeShape",function(){return FM}),n.d(i,"getTypedArrayFromDType",function(){return $M}),n.d(i,"getArrayFromDType",function(){return zM}),n.d(i,"checkConversionForErrors",function(){return UM}),n.d(i,"isValidDtype",function(){return HM}),n.d(i,"hasEncodingLoss",function(){return VM}),n.d(i,"isTypedArray",function(){return GM}),n.d(i,"bytesPerElement",function(){return WM}),n.d(i,"bytesFromStringArray",function(){return jM}),n.d(i,"isString",function(){return QM}),n.d(i,"isBoolean",function(){return qM}),n.d(i,"isNumber",function(){return XM}),n.d(i,"inferDtype",function(){return YM}),n.d(i,"isFunction",function(){return KM}),n.d(i,"nearestDivisor",function(){return JM}),n.d(i,"computeStrides",function(){return ZM}),n.d(i,"toNestedArray",function(){return ek}),n.d(i,"makeOnesTypedArray",function(){return nk}),n.d(i,"makeZerosTypedArray",function(){return ik}),n.d(i,"makeZerosNestedTypedArray",function(){return rk}),n.d(i,"assertNonNegativeIntegerDimensions",function(){return sk}),n.d(i,"locToIndex",function(){return ok}),n.d(i,"indexToLoc",function(){return ak}),n.d(i,"isPromise",function(){return lk}),n.d(i,"hexToLong",function(){return IL}),n.d(i,"fingerPrint64",function(){return FL}),n.d(i,"createScalarValue",function(){return $L}),n.d(i,"toTypedArray",function(){return zL}),n.d(i,"now",function(){return UL}),n.d(i,"fetch",function(){return HL}),n.d(i,"encodeString",function(){return VL}),n.d(i,"decodeString",function(){return GL});var r={};n.r(r),n.d(r,"makeTypesMatch",function(){return fD}),n.d(r,"assertTypesMatch",function(){return mD}),n.d(r,"isTensorInList",function(){return gD}),n.d(r,"getTensorsInContainer",function(){return yD});var s={};n.r(s),n.d(s,"isMobile",function(){return ED}),n.d(s,"isBrowser",function(){return CD});var o={};n.r(o),n.d(o,"copyModel",function(){return IB}),n.d(o,"listModels",function(){return EB}),n.d(o,"moveModel",function(){return TB}),n.d(o,"removeModel",function(){return CB}),n.d(o,"browserFiles",function(){return PB}),n.d(o,"browserHTTPRequest",function(){return jB}),n.d(o,"concatenateArrayBuffers",function(){return VD}),n.d(o,"decodeWeights",function(){return $D}),n.d(o,"encodeWeights",function(){return FD}),n.d(o,"fromMemory",function(){return XB}),n.d(o,"getLoadHandlers",function(){return ZD}),n.d(o,"getModelArtifactsForJSON",function(){return jD}),n.d(o,"getModelArtifactsInfoForJSON",function(){return QD}),n.d(o,"getSaveHandlers",function(){return JD}),n.d(o,"http",function(){return WB}),n.d(o,"isHTTPScheme",function(){return VB}),n.d(o,"loadWeights",function(){return zB}),n.d(o,"registerLoadRouter",function(){return KD}),n.d(o,"registerSaveRouter",function(){return YD}),n.d(o,"weightsLoaderFactory",function(){return UB}),n.d(o,"withSaveHandler",function(){return YB});var a={};n.r(a),n.d(a,"fromPixelsAsync",function(){return ZB}),n.d(a,"toPixels",function(){return tO}),n.d(a,"fromPixels",function(){return eO});var l={};n.r(l),n.d(l,"assertParamsValid",function(){return nO}),n.d(l,"maskToAxes",function(){return iO}),n.d(l,"computeOutShape",function(){return rO}),n.d(l,"stridesWithElidedDims",function(){return sO}),n.d(l,"getNormalizedAxes",function(){return lO}),n.d(l,"startIndicesWithElidedDims",function(){return cO}),n.d(l,"stopIndicesWithElidedDims",function(){return uO}),n.d(l,"stridesForAxis",function(){return hO}),n.d(l,"startForAxis",function(){return dO}),n.d(l,"stopForAxis",function(){return pO}),n.d(l,"isSliceContinous",function(){return fO}),n.d(l,"computeFlatOffset",function(){return mO}),n.d(l,"parseSliceParams",function(){return gO}),n.d(l,"sliceInfo",function(){return yO});var c={};n.r(c),n.d(c,"Serializable",function(){return vO}),n.d(c,"SerializationMap",function(){return bO}),n.d(c,"registerClass",function(){return AO});var u={};n.r(u),n.d(u,"conv2d",function(){return i$}),n.d(u,"depthwiseConv2d",function(){return o$}),n.d(u,"matMul",function(){return a$});var h={};n.r(h),n.d(h,"segOpComputeOptimalWindowSize",function(){return Wz}),n.d(h,"computeOutShape",function(){return jz}),n.d(h,"collectGatherOpShapeInfo",function(){return Qz});var d={};n.r(d),n.d(d,"axesAreInnerMostDims",function(){return qP}),n.d(d,"combineLocations",function(){return XP}),n.d(d,"computeOutAndReduceShapes",function(){return YP}),n.d(d,"expandShapeToKeepDim",function(){return KP}),n.d(d,"assertAxesAreInnerMostDims",function(){return JP}),n.d(d,"getAxesPermutation",function(){return ZP}),n.d(d,"getUndoAxesPermutation",function(){return tF}),n.d(d,"getInnerMostAxes",function(){return eF}),n.d(d,"getBroadcastDims",function(){return AP}),n.d(d,"getReductionAxes",function(){return xP}),n.d(d,"assertAndGetBroadcastShape",function(){return wP}),n.d(d,"assertParamsConsistent",function(){return sz}),n.d(d,"computeOutShape",function(){return oz}),n.d(d,"computeDilation2DInfo",function(){return BO}),n.d(d,"computePool2DInfo",function(){return OO}),n.d(d,"computePool3DInfo",function(){return PO}),n.d(d,"computeConv2DInfo",function(){return FO}),n.d(d,"computeConv3DInfo",function(){return $O}),n.d(d,"computeDefaultPad",function(){return zO}),n.d(d,"tupleValuesAreOne",function(){return WO}),n.d(d,"eitherStridesOrDilationsAreOne",function(){return jO}),n.d(d,"convertConv2DDataFormat",function(){return QO}),n.d(d,"getFusedDyActivation",function(){return ZF}),n.d(d,"getFusedBiasGradient",function(){return t$}),n.d(d,"applyActivation",function(){return e$}),n.d(d,"shouldFuse",function(){return n$}),n.d(d,"PARALLELIZE_THRESHOLD",function(){return az}),n.d(d,"computeOptimalWindowSize",function(){return lz}),n.d(d,"slice_util",function(){return l}),n.d(d,"upcastType",function(){return dD}),n.d(d,"getImageCenter",function(){return cz}),n.d(d,"getReshaped",function(){return uz}),n.d(d,"getPermuted",function(){return hz}),n.d(d,"getReshapedPermuted",function(){return dz}),n.d(d,"getSliceBeginCoords",function(){return pz}),n.d(d,"getSliceSize",function(){return fz}),n.d(d,"prepareAndValidate",function(){return mz}),n.d(d,"validateUpdateShape",function(){return gz}),n.d(d,"validateInput",function(){return yz}),n.d(d,"calculateShapes",function(){return vz}),n.d(d,"SELU_SCALEALPHA",function(){return bz}),n.d(d,"SELU_SCALE",function(){return Az}),n.d(d,"ERF_P",function(){return xz}),n.d(d,"ERF_A1",function(){return wz}),n.d(d,"ERF_A2",function(){return _z}),n.d(d,"ERF_A3",function(){return Sz}),n.d(d,"ERF_A4",function(){return Ez}),n.d(d,"ERF_A5",function(){return Cz}),n.d(d,"warn",function(){return Iz}),n.d(d,"log",function(){return Tz}),n.d(d,"mergeRealAndImagArrays",function(){return Mz}),n.d(d,"splitRealAndImagArrays",function(){return kz}),n.d(d,"complexWithEvenIndex",function(){return Rz}),n.d(d,"complexWithOddIndex",function(){return Nz}),n.d(d,"getComplexWithIndex",function(){return Lz}),n.d(d,"assignToTypedArray",function(){return Dz}),n.d(d,"exponents",function(){return Bz}),n.d(d,"exponent",function(){return Oz}),n.d(d,"decodeEinsumEquation",function(){return Fz}),n.d(d,"getEinsumPermutation",function(){return $z}),n.d(d,"checkEinsumDimSizes",function(){return zz}),n.d(d,"getEinsumComputePath",function(){return Uz}),n.d(d,"isIdentityPermutation",function(){return Hz}),n.d(d,"prepareSplitSize",function(){return Gz}),n.d(d,"segment_util",function(){return h}),n.d(d,"fromUint8ToStringArray",function(){return qz}),n.d(d,"fromStringArrayToUint8",function(){return Xz});var p={};n.r(p),n.d(p,"nonMaxSuppressionV3Impl",function(){return v$}),n.d(p,"nonMaxSuppressionV4Impl",function(){return b$}),n.d(p,"nonMaxSuppressionV5Impl",function(){return A$}),n.d(p,"whereImpl",function(){return Yz});var f={};n.r(f),n.d(f,"json",function(){return qq});var m={};n.r(m),n.d(m,"json",function(){return Xq});var g={};n.r(g),n.d(g,"json",function(){return Yq});var y={};n.r(y),n.d(y,"json",function(){return Kq});var v={};n.r(v),n.d(v,"json",function(){return Jq});var b={};n.r(b),n.d(b,"json",function(){return Zq});var A={};n.r(A),n.d(A,"json",function(){return tX});var x={};n.r(x),n.d(x,"json",function(){return eX});var w={};n.r(w),n.d(w,"json",function(){return nX});var _={};n.r(_),n.d(_,"json",function(){return iX});var S={};n.r(S),n.d(S,"json",function(){return rX});var E={};n.r(E),n.d(E,"json",function(){return sX});var C={};n.r(C),n.d(C,"json",function(){return oX});var I={};n.r(I),n.d(I,"json",function(){return aX});var T={};n.r(T),n.d(T,"json",function(){return lX});var M={};n.r(M),n.d(M,"json",function(){return cX});var k={};n.r(k),n.d(k,"json",function(){return uX});var R={};n.r(R),n.d(R,"json",function(){return hX});var N={};n.r(N),n.d(N,"json",function(){return dX});var L={};function D(t){return"function"==typeof t}n.r(L),n.d(L,"simpleAbsImpl",function(){return MY}),n.d(L,"addImpl",function(){return AY}),n.d(L,"bincountImpl",function(){return dK}),n.d(L,"bincountReduceImpl",function(){return pK}),n.d(L,"ceilImpl",function(){return gK}),n.d(L,"concatImpl",function(){return wK}),n.d(L,"equalImpl",function(){return rJ}),n.d(L,"expImpl",function(){return mJ}),n.d(L,"expm1Impl",function(){return AJ}),n.d(L,"floorImpl",function(){return PJ}),n.d(L,"gatherNdImpl",function(){return WJ}),n.d(L,"gatherV2Impl",function(){return QJ}),n.d(L,"greaterImpl",function(){return XJ}),n.d(L,"greaterEqualImpl",function(){return JJ}),n.d(L,"lessImpl",function(){return lZ}),n.d(L,"lessEqualImpl",function(){return hZ}),n.d(L,"linSpaceImpl",function(){return fZ}),n.d(L,"logImpl",function(){return gZ}),n.d(L,"maxImpl",function(){return RZ}),n.d(L,"maximumImpl",function(){return DZ}),n.d(L,"minimumImpl",function(){return GZ}),n.d(L,"multiplyImpl",function(){return YK}),n.d(L,"negImpl",function(){return t0}),n.d(L,"notEqualImpl",function(){return l0}),n.d(L,"prodImpl",function(){return x0}),n.d(L,"rangeImpl",function(){return _0}),n.d(L,"rsqrtImpl",function(){return B0}),n.d(L,"sliceImpl",function(){return lK}),n.d(L,"sparseFillEmptyRowsImpl",function(){return e1}),n.d(L,"sparseReshapeImpl",function(){return i1}),n.d(L,"sparseSegmentReductionImpl",function(){return s1}),n.d(L,"squaredDifferenceImpl",function(){return p1}),n.d(L,"stridedSliceImpl",function(){return v1}),n.d(L,"stringNGramsImpl",function(){return x1}),n.d(L,"stringSplitImpl",function(){return S1}),n.d(L,"stringToHashBucketFastImpl",function(){return C1}),n.d(L,"subImpl",function(){return CJ}),n.d(L,"tileImpl",function(){return R1}),n.d(L,"topKImpl",function(){return D1}),n.d(L,"transposeImpl",function(){return OY}),n.d(L,"uniqueImpl",function(){return $1});let B=!1;const O={Promise:void 0,set useDeprecatedSynchronousErrorHandling(t){if(t){const t=new Error;console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n"+t.stack)}else B&&console.log("RxJS: Back to a better error behavior. Thank you. <3");B=t},get useDeprecatedSynchronousErrorHandling(){return B}};function P(t){setTimeout(()=>{throw t},0)}const F={closed:!0,next(t){},error(t){if(O.useDeprecatedSynchronousErrorHandling)throw t;P(t)},complete(){}},$=(()=>Array.isArray||(t=>t&&"number"==typeof t.length))();function z(t){return null!==t&&"object"==typeof t}const U=(()=>{function t(t){return Error.call(this),this.message=t?`${t.length} errors occurred during unsubscription:\n${t.map((t,e)=>`${e+1}) ${t.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=t,this}return t.prototype=Object.create(Error.prototype),t})();let H=(()=>{class t{constructor(t){this.closed=!1,this._parentOrParents=null,this._subscriptions=null,t&&(this._ctorUnsubscribe=!0,this._unsubscribe=t)}unsubscribe(){let e;if(this.closed)return;let{_parentOrParents:n,_ctorUnsubscribe:i,_unsubscribe:r,_subscriptions:s}=this;if(this.closed=!0,this._parentOrParents=null,this._subscriptions=null,n instanceof t)n.remove(this);else if(null!==n)for(let t=0;t<n.length;++t)n[t].remove(this);if(D(r)){i&&(this._unsubscribe=void 0);try{r.call(this)}catch(o){e=o instanceof U?V(o.errors):[o]}}if($(s)){let t=-1,n=s.length;for(;++t<n;){const n=s[t];if(z(n))try{n.unsubscribe()}catch(o){e=e||[],o instanceof U?e=e.concat(V(o.errors)):e.push(o)}}}if(e)throw new U(e)}add(e){let n=e;if(!e)return t.EMPTY;switch(typeof e){case"function":n=new t(e);case"object":if(n===this||n.closed||"function"!=typeof n.unsubscribe)return n;if(this.closed)return n.unsubscribe(),n;if(!(n instanceof t)){const e=n;n=new t,n._subscriptions=[e]}break;default:throw new Error("unrecognized teardown "+e+" added to Subscription.")}let{_parentOrParents:i}=n;if(null===i)n._parentOrParents=this;else if(i instanceof t){if(i===this)return n;n._parentOrParents=[i,this]}else{if(-1!==i.indexOf(this))return n;i.push(this)}const r=this._subscriptions;return null===r?this._subscriptions=[n]:r.push(n),n}remove(t){const e=this._subscriptions;if(e){const n=e.indexOf(t);-1!==n&&e.splice(n,1)}}}return t.EMPTY=function(t){return t.closed=!0,t}(new t),t})();function V(t){return t.reduce((t,e)=>t.concat(e instanceof U?e.errors:e),[])}const G=(()=>"function"==typeof Symbol?Symbol("rxSubscriber"):"@@rxSubscriber_"+Math.random())();class W extends H{constructor(t,e,n){switch(super(),this.syncErrorValue=null,this.syncErrorThrown=!1,this.syncErrorThrowable=!1,this.isStopped=!1,arguments.length){case 0:this.destination=F;break;case 1:if(!t){this.destination=F;break}if("object"==typeof t){t instanceof W?(this.syncErrorThrowable=t.syncErrorThrowable,this.destination=t,t.add(this)):(this.syncErrorThrowable=!0,this.destination=new j(this,t));break}default:this.syncErrorThrowable=!0,this.destination=new j(this,t,e,n)}}[G](){return this}static create(t,e,n){const i=new W(t,e,n);return i.syncErrorThrowable=!1,i}next(t){this.isStopped||this._next(t)}error(t){this.isStopped||(this.isStopped=!0,this._error(t))}complete(){this.isStopped||(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe())}_next(t){this.destination.next(t)}_error(t){this.destination.error(t),this.unsubscribe()}_complete(){this.destination.complete(),this.unsubscribe()}_unsubscribeAndRecycle(){const{_parentOrParents:t}=this;return this._parentOrParents=null,this.unsubscribe(),this.closed=!1,this.isStopped=!1,this._parentOrParents=t,this}}class j extends W{constructor(t,e,n,i){let r;super(),this._parentSubscriber=t;let s=this;D(e)?r=e:e&&(r=e.next,n=e.error,i=e.complete,e!==F&&(s=Object.create(e),D(s.unsubscribe)&&this.add(s.unsubscribe.bind(s)),s.unsubscribe=this.unsubscribe.bind(this))),this._context=s,this._next=r,this._error=n,this._complete=i}next(t){if(!this.isStopped&&this._next){const{_parentSubscriber:e}=this;O.useDeprecatedSynchronousErrorHandling&&e.syncErrorThrowable?this.__tryOrSetError(e,this._next,t)&&this.unsubscribe():this.__tryOrUnsub(this._next,t)}}error(t){if(!this.isStopped){const{_parentSubscriber:e}=this,{useDeprecatedSynchronousErrorHandling:n}=O;if(this._error)n&&e.syncErrorThrowable?(this.__tryOrSetError(e,this._error,t),this.unsubscribe()):(this.__tryOrUnsub(this._error,t),this.unsubscribe());else if(e.syncErrorThrowable)n?(e.syncErrorValue=t,e.syncErrorThrown=!0):P(t),this.unsubscribe();else{if(this.unsubscribe(),n)throw t;P(t)}}}complete(){if(!this.isStopped){const{_parentSubscriber:t}=this;if(this._complete){const e=()=>this._complete.call(this._context);O.useDeprecatedSynchronousErrorHandling&&t.syncErrorThrowable?(this.__tryOrSetError(t,e),this.unsubscribe()):(this.__tryOrUnsub(e),this.unsubscribe())}else this.unsubscribe()}}__tryOrUnsub(t,e){try{t.call(this._context,e)}catch(n){if(this.unsubscribe(),O.useDeprecatedSynchronousErrorHandling)throw n;P(n)}}__tryOrSetError(t,e,n){if(!O.useDeprecatedSynchronousErrorHandling)throw new Error("bad call");try{e.call(this._context,n)}catch(i){return O.useDeprecatedSynchronousErrorHandling?(t.syncErrorValue=i,t.syncErrorThrown=!0,!0):(P(i),!0)}return!1}_unsubscribe(){const{_parentSubscriber:t}=this;this._context=null,this._parentSubscriber=null,t.unsubscribe()}}const Q=(()=>"function"==typeof Symbol&&Symbol.observable||"@@observable")();function q(t){return t}let X=(()=>{class t{constructor(t){this._isScalar=!1,t&&(this._subscribe=t)}lift(e){const n=new t;return n.source=this,n.operator=e,n}subscribe(t,e,n){const{operator:i}=this,r=function(t,e,n){if(t){if(t instanceof W)return t;if(t[G])return t[G]()}return t||e||n?new W(t,e,n):new W(F)}(t,e,n);if(r.add(i?i.call(r,this.source):this.source||O.useDeprecatedSynchronousErrorHandling&&!r.syncErrorThrowable?this._subscribe(r):this._trySubscribe(r)),O.useDeprecatedSynchronousErrorHandling&&r.syncErrorThrowable&&(r.syncErrorThrowable=!1,r.syncErrorThrown))throw r.syncErrorValue;return r}_trySubscribe(t){try{return this._subscribe(t)}catch(e){O.useDeprecatedSynchronousErrorHandling&&(t.syncErrorThrown=!0,t.syncErrorValue=e),function(t){for(;t;){const{closed:e,destination:n,isStopped:i}=t;if(e||i)return!1;t=n&&n instanceof W?n:null}return!0}(t)?t.error(e):console.warn(e)}}forEach(t,e){return new(e=Y(e))((e,n)=>{let i;i=this.subscribe(e=>{try{t(e)}catch(r){n(r),i&&i.unsubscribe()}},n,e)})}_subscribe(t){const{source:e}=this;return e&&e.subscribe(t)}[Q](){return this}pipe(...t){return 0===t.length?this:(0===(e=t).length?q:1===e.length?e[0]:function(t){return e.reduce((t,e)=>e(t),t)})(this);var e}toPromise(t){return new(t=Y(t))((t,e)=>{let n;this.subscribe(t=>n=t,t=>e(t),()=>t(n))})}}return t.create=e=>new t(e),t})();function Y(t){if(t||(t=O.Promise||Promise),!t)throw new Error("no Promise impl found");return t}const K=(()=>{function t(){return Error.call(this),this.message="object unsubscribed",this.name="ObjectUnsubscribedError",this}return t.prototype=Object.create(Error.prototype),t})();class J extends H{constructor(t,e){super(),this.subject=t,this.subscriber=e,this.closed=!1}unsubscribe(){if(this.closed)return;this.closed=!0;const t=this.subject,e=t.observers;if(this.subject=null,!e||0===e.length||t.isStopped||t.closed)return;const n=e.indexOf(this.subscriber);-1!==n&&e.splice(n,1)}}class Z extends W{constructor(t){super(t),this.destination=t}}let tt=(()=>{class t extends X{constructor(){super(),this.observers=[],this.closed=!1,this.isStopped=!1,this.hasError=!1,this.thrownError=null}[G](){return new Z(this)}lift(t){const e=new et(this,this);return e.operator=t,e}next(t){if(this.closed)throw new K;if(!this.isStopped){const{observers:e}=this,n=e.length,i=e.slice();for(let r=0;r<n;r++)i[r].next(t)}}error(t){if(this.closed)throw new K;this.hasError=!0,this.thrownError=t,this.isStopped=!0;const{observers:e}=this,n=e.length,i=e.slice();for(let r=0;r<n;r++)i[r].error(t);this.observers.length=0}complete(){if(this.closed)throw new K;this.isStopped=!0;const{observers:t}=this,e=t.length,n=t.slice();for(let i=0;i<e;i++)n[i].complete();this.observers.length=0}unsubscribe(){this.isStopped=!0,this.closed=!0,this.observers=null}_trySubscribe(t){if(this.closed)throw new K;return super._trySubscribe(t)}_subscribe(t){if(this.closed)throw new K;return this.hasError?(t.error(this.thrownError),H.EMPTY):this.isStopped?(t.complete(),H.EMPTY):(this.observers.push(t),new J(this,t))}asObservable(){const t=new X;return t.source=this,t}}return t.create=(t,e)=>new et(t,e),t})();class et extends tt{constructor(t,e){super(),this.destination=t,this.source=e}next(t){const{destination:e}=this;e&&e.next&&e.next(t)}error(t){const{destination:e}=this;e&&e.error&&this.destination.error(t)}complete(){const{destination:t}=this;t&&t.complete&&this.destination.complete()}_subscribe(t){const{source:e}=this;return e?this.source.subscribe(t):H.EMPTY}}function nt(t){return t&&"function"==typeof t.schedule}function it(t,e){return function(n){if("function"!=typeof t)throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");return n.lift(new rt(t,e))}}class rt{constructor(t,e){this.project=t,this.thisArg=e}call(t,e){return e.subscribe(new st(t,this.project,this.thisArg))}}class st extends W{constructor(t,e,n){super(t),this.project=e,this.count=0,this.thisArg=n||this}_next(t){let e;try{e=this.project.call(this.thisArg,t,this.count++)}catch(n){return void this.destination.error(n)}this.destination.next(e)}}const ot=t=>e=>{for(let n=0,i=t.length;n<i&&!e.closed;n++)e.next(t[n]);e.complete()};function at(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}const lt=at(),ct=t=>t&&"number"==typeof t.length&&"function"!=typeof t;function ut(t){return!!t&&"function"!=typeof t.subscribe&&"function"==typeof t.then}const ht=t=>{if(t&&"function"==typeof t[Q])return i=t,t=>{const e=i[Q]();if("function"!=typeof e.subscribe)throw new TypeError("Provided object does not correctly implement Symbol.observable");return e.subscribe(t)};if(ct(t))return ot(t);if(ut(t))return n=t,t=>(n.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,P),t);if(t&&"function"==typeof t[lt])return e=t,t=>{const n=e[lt]();for(;;){let e;try{e=n.next()}catch(i){return t.error(i),t}if(e.done){t.complete();break}if(t.next(e.value),t.closed)break}return"function"==typeof n.return&&t.add(()=>{n.return&&n.return()}),t};{const e=z(t)?"an invalid object":`'${t}'`;throw new TypeError(`You provided ${e} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`)}var e,n,i};function dt(t,e){return new X(n=>{const i=new H;let r=0;return i.add(e.schedule(function(){r!==t.length?(n.next(t[r++]),n.closed||i.add(this.schedule())):n.complete()})),i})}function pt(t,e){return e?function(t,e){if(null!=t){if(function(t){return t&&"function"==typeof t[Q]}(t))return function(t,e){return new X(n=>{const i=new H;return i.add(e.schedule(()=>{const r=t[Q]();i.add(r.subscribe({next(t){i.add(e.schedule(()=>n.next(t)))},error(t){i.add(e.schedule(()=>n.error(t)))},complete(){i.add(e.schedule(()=>n.complete()))}}))})),i})}(t,e);if(ut(t))return function(t,e){return new X(n=>{const i=new H;return i.add(e.schedule(()=>t.then(t=>{i.add(e.schedule(()=>{n.next(t),i.add(e.schedule(()=>n.complete()))}))},t=>{i.add(e.schedule(()=>n.error(t)))}))),i})}(t,e);if(ct(t))return dt(t,e);if(function(t){return t&&"function"==typeof t[lt]}(t)||"string"==typeof t)return function(t,e){if(!t)throw new Error("Iterable cannot be null");return new X(n=>{const i=new H;let r;return i.add(()=>{r&&"function"==typeof r.return&&r.return()}),i.add(e.schedule(()=>{r=t[lt](),i.add(e.schedule(function(){if(n.closed)return;let t,e;try{const n=r.next();t=n.value,e=n.done}catch(i){return void n.error(i)}e?n.complete():(n.next(t),this.schedule())}))})),i})}(t,e)}throw new TypeError((null!==t&&typeof t||t)+" is not observable")}(t,e):t instanceof X?t:new X(ht(t))}class ft extends W{constructor(t){super(),this.parent=t}_next(t){this.parent.notifyNext(t)}_error(t){this.parent.notifyError(t),this.unsubscribe()}_complete(){this.parent.notifyComplete(),this.unsubscribe()}}class mt extends W{notifyNext(t){this.destination.next(t)}notifyError(t){this.destination.error(t)}notifyComplete(){this.destination.complete()}}function gt(t,e){if(e.closed)return;if(t instanceof X)return t.subscribe(e);let n;try{n=ht(t)(e)}catch(i){e.error(i)}return n}function yt(t,e,n=Number.POSITIVE_INFINITY){return"function"==typeof e?i=>i.pipe(yt((n,i)=>pt(t(n,i)).pipe(it((t,r)=>e(n,t,i,r))),n)):("number"==typeof e&&(n=e),e=>e.lift(new vt(t,n)))}class vt{constructor(t,e=Number.POSITIVE_INFINITY){this.project=t,this.concurrent=e}call(t,e){return e.subscribe(new bt(t,this.project,this.concurrent))}}class bt extends mt{constructor(t,e,n=Number.POSITIVE_INFINITY){super(t),this.project=e,this.concurrent=n,this.hasCompleted=!1,this.buffer=[],this.active=0,this.index=0}_next(t){this.active<this.concurrent?this._tryNext(t):this.buffer.push(t)}_tryNext(t){let e;const n=this.index++;try{e=this.project(t,n)}catch(i){return void this.destination.error(i)}this.active++,this._innerSub(e)}_innerSub(t){const e=new ft(this),n=this.destination;n.add(e);const i=gt(t,e);i!==e&&n.add(i)}_complete(){this.hasCompleted=!0,0===this.active&&0===this.buffer.length&&this.destination.complete(),this.unsubscribe()}notifyNext(t){this.destination.next(t)}notifyComplete(){const t=this.buffer;this.active--,t.length>0?this._next(t.shift()):0===this.active&&this.hasCompleted&&this.destination.complete()}}function At(t=Number.POSITIVE_INFINITY){return yt(q,t)}function xt(t,e){return e?dt(t,e):new X(ot(t))}function wt(...t){let e=Number.POSITIVE_INFINITY,n=null,i=t[t.length-1];return nt(i)?(n=t.pop(),t.length>1&&"number"==typeof t[t.length-1]&&(e=t.pop())):"number"==typeof i&&(e=t.pop()),null===n&&1===t.length&&t[0]instanceof X?t[0]:At(e)(xt(t,n))}function _t(){return function(t){return t.lift(new St(t))}}class St{constructor(t){this.connectable=t}call(t,e){const{connectable:n}=this;n._refCount++;const i=new Et(t,n),r=e.subscribe(i);return i.closed||(i.connection=n.connect()),r}}class Et extends W{constructor(t,e){super(t),this.connectable=e}_unsubscribe(){const{connectable:t}=this;if(!t)return void(this.connection=null);this.connectable=null;const e=t._refCount;if(e<=0)return void(this.connection=null);if(t._refCount=e-1,e>1)return void(this.connection=null);const{connection:n}=this,i=t._connection;this.connection=null,!i||n&&i!==n||i.unsubscribe()}}class Ct extends X{constructor(t,e){super(),this.source=t,this.subjectFactory=e,this._refCount=0,this._isComplete=!1}_subscribe(t){return this.getSubject().subscribe(t)}getSubject(){const t=this._subject;return t&&!t.isStopped||(this._subject=this.subjectFactory()),this._subject}connect(){let t=this._connection;return t||(this._isComplete=!1,t=this._connection=new H,t.add(this.source.subscribe(new Tt(this.getSubject(),this))),t.closed&&(this._connection=null,t=H.EMPTY)),t}refCount(){return _t()(this)}}const It=(()=>{const t=Ct.prototype;return{operator:{value:null},_refCount:{value:0,writable:!0},_subject:{value:null,writable:!0},_connection:{value:null,writable:!0},_subscribe:{value:t._subscribe},_isComplete:{value:t._isComplete,writable:!0},getSubject:{value:t.getSubject},connect:{value:t.connect},refCount:{value:t.refCount}}})();class Tt extends Z{constructor(t,e){super(t),this.connectable=e}_error(t){this._unsubscribe(),super._error(t)}_complete(){this.connectable._isComplete=!0,this._unsubscribe(),super._complete()}_unsubscribe(){const t=this.connectable;if(t){this.connectable=null;const e=t._connection;t._refCount=0,t._subject=null,t._connection=null,e&&e.unsubscribe()}}}function Mt(t,e){return function(n){let i;if(i="function"==typeof t?t:function(){return t},"function"==typeof e)return n.lift(new kt(i,e));const r=Object.create(n,It);return r.source=n,r.subjectFactory=i,r}}class kt{constructor(t,e){this.subjectFactory=t,this.selector=e}call(t,e){const{selector:n}=this,i=this.subjectFactory(),r=n(i).subscribe(t);return r.add(e.subscribe(i)),r}}function Rt(){return new tt}function Nt(){return t=>_t()(Mt(Rt)(t))}function Lt(t){for(let e in t)if(t[e]===Lt)return e;throw Error("Could not find renamed property on target object.")}function Dt(t,e){for(const n in e)e.hasOwnProperty(n)&&!t.hasOwnProperty(n)&&(t[n]=e[n])}function Bt(t){if("string"==typeof t)return t;if(Array.isArray(t))return"["+t.map(Bt).join(", ")+"]";if(null==t)return""+t;if(t.overriddenName)return`${t.overriddenName}`;if(t.name)return`${t.name}`;const e=t.toString();if(null==e)return""+e;const n=e.indexOf("\n");return-1===n?e:e.substring(0,n)}function Ot(t,e){return null==t||""===t?null===e?"":e:null==e||""===e?t:t+" "+e}const Pt=Lt({__forward_ref__:Lt});function Ft(t){return t.__forward_ref__=Ft,t.toString=function(){return Bt(this())},t}function $t(t){return zt(t)?t():t}function zt(t){return"function"==typeof t&&t.hasOwnProperty(Pt)&&t.__forward_ref__===Ft}class Ut extends Error{constructor(t,e){super(function(t,e){return`${t?`NG0${t}: `:""}${e}`}(t,e)),this.code=t}}function Ht(t){return"string"==typeof t?t:null==t?"":String(t)}function Vt(t){return"function"==typeof t?t.name||t.toString():"object"==typeof t&&null!=t&&"function"==typeof t.type?t.type.name||t.type.toString():Ht(t)}function Gt(t,e){const n=e?` in ${e}`:"";throw new Ut("201",`No provider for ${Vt(t)} found${n}`)}function Wt(t){return{token:t.token,providedIn:t.providedIn||null,factory:t.factory,value:void 0}}const jt=Wt;function Qt(t){return{providers:t.providers||[],imports:t.imports||[]}}function qt(t){return Xt(t,Kt)||Xt(t,Zt)}function Xt(t,e){return t.hasOwnProperty(e)?t[e]:null}function Yt(t){return t&&(t.hasOwnProperty(Jt)||t.hasOwnProperty(te))?t[Jt]:null}const Kt=Lt({"\u0275prov":Lt}),Jt=Lt({"\u0275inj":Lt}),Zt=Lt({ngInjectableDef:Lt}),te=Lt({ngInjectorDef:Lt});var ee=function(t){return t[t.Default=0]="Default",t[t.Host=1]="Host",t[t.Self=2]="Self",t[t.SkipSelf=4]="SkipSelf",t[t.Optional=8]="Optional",t}({});let ne;function ie(t){const e=ne;return ne=t,e}function re(t,e,n){const i=qt(t);return i&&"root"==i.providedIn?void 0===i.value?i.value=i.factory():i.value:n&ee.Optional?null:void 0!==e?e:void Gt(Bt(t),"Injector")}function se(t){return{toString:t}.toString()}var oe=function(t){return t[t.OnPush=0]="OnPush",t[t.Default=1]="Default",t}({}),ae=function(t){return t[t.Emulated=0]="Emulated",t[t.None=2]="None",t[t.ShadowDom=3]="ShadowDom",t}({});const le="undefined"!=typeof globalThis&&globalThis,ce="undefined"!=typeof window&&window,ue="undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self,he="undefined"!=typeof global&&global,de=le||he||ce||ue,pe={},fe=[],me=[],ge=Lt({"\u0275cmp":Lt}),ye=Lt({"\u0275dir":Lt}),ve=Lt({"\u0275pipe":Lt}),be=Lt({"\u0275mod":Lt}),Ae=Lt({"\u0275loc":Lt}),xe=Lt({"\u0275fac":Lt}),we=Lt({__NG_ELEMENT_ID__:Lt});let _e=0;function Se(t){return se(()=>{const e={},n={type:t.type,providersResolver:null,decls:t.decls,vars:t.vars,factory:null,template:t.template||null,consts:t.consts||null,ngContentSelectors:t.ngContentSelectors,hostBindings:t.hostBindings||null,hostVars:t.hostVars||0,hostAttrs:t.hostAttrs||null,contentQueries:t.contentQueries||null,declaredInputs:e,inputs:null,outputs:null,exportAs:t.exportAs||null,onPush:t.changeDetection===oe.OnPush,directiveDefs:null,pipeDefs:null,selectors:t.selectors||me,viewQuery:t.viewQuery||null,features:t.features||null,data:t.data||{},encapsulation:t.encapsulation||ae.Emulated,id:"c",styles:t.styles||me,_:null,setInput:null,schemas:t.schemas||null,tView:null},i=t.directives,r=t.features,s=t.pipes;return n.id+=_e++,n.inputs=Me(t.inputs,e),n.outputs=Me(t.outputs),r&&r.forEach(t=>t(n)),n.directiveDefs=i?()=>("function"==typeof i?i():i).map(Ee):null,n.pipeDefs=s?()=>("function"==typeof s?s():s).map(Ce):null,n})}function Ee(t){return Ne(t)||function(t){return t[ye]||null}(t)}function Ce(t){return function(t){return t[ve]||null}(t)}const Ie={};function Te(t){const e={type:t.type,bootstrap:t.bootstrap||me,declarations:t.declarations||me,imports:t.imports||me,exports:t.exports||me,transitiveCompileScopes:null,schemas:t.schemas||null,id:t.id||null};return null!=t.id&&se(()=>{Ie[t.id]=t.type}),e}function Me(t,e){if(null==t)return pe;const n={};for(const i in t)if(t.hasOwnProperty(i)){let r=t[i],s=r;Array.isArray(r)&&(s=r[1],r=r[0]),n[r]=i,e&&(e[r]=s)}return n}const ke=Se;function Re(t){return{type:t.type,name:t.name,factory:null,pure:!1!==t.pure,onDestroy:t.type.prototype.ngOnDestroy||null}}function Ne(t){return t[ge]||null}function Le(t,e){const n=t[be]||null;if(!n&&!0===e)throw new Error(`Type ${Bt(t)} does not have '\u0275mod' property.`);return n}const De=20,Be=10;function Oe(t){return Array.isArray(t)&&"object"==typeof t[1]}function Pe(t){return Array.isArray(t)&&!0===t[1]}function Fe(t){return 0!=(8&t.flags)}function $e(t){return 2==(2&t.flags)}function ze(t){return 1==(1&t.flags)}function Ue(t){return null!==t.template}function He(t,e){return t.hasOwnProperty(xe)?t[xe]:null}class Ve{constructor(t,e,n){this.previousValue=t,this.currentValue=e,this.firstChange=n}isFirstChange(){return this.firstChange}}function Ge(){return We}function We(t){return t.type.prototype.ngOnChanges&&(t.setInput=Qe),je}function je(){const t=qe(this),e=null==t?void 0:t.current;if(e){const n=t.previous;if(n===pe)t.previous=e;else for(let t in e)n[t]=e[t];t.current=null,this.ngOnChanges(e)}}function Qe(t,e,n,i){const r=qe(t)||function(t,e){return t.__ngSimpleChanges__=e}(t,{previous:pe,current:null}),s=r.current||(r.current={}),o=r.previous,a=this.declaredInputs[n],l=o[a];s[a]=new Ve(l&&l.currentValue,e,o===pe),t[i]=e}function qe(t){return t.__ngSimpleChanges__||null}Ge.ngInherit=!0;const Xe="http://www.w3.org/2000/svg";let Ye;function Ke(){return void 0!==Ye?Ye:"undefined"!=typeof document?document:void 0}function Je(t){return!!t.listen}const Ze={createRenderer:(t,e)=>Ke()};function tn(t){for(;Array.isArray(t);)t=t[0];return t}function en(t,e){return tn(e[t])}function nn(t,e){return tn(e[t.index])}function rn(t,e){return t.data[e]}function sn(t,e){return t[e]}function on(t,e){const n=e[t];return Oe(n)?n:n[0]}function an(t){const e=function(t){return t.__ngContext__||null}(t);return e?Array.isArray(e)?e:e.lView:null}function ln(t){return 4==(4&t[2])}function cn(t){return 128==(128&t[2])}function un(t,e){return null==e?null:t[e]}function hn(t){t[18]=0}function dn(t,e){t[5]+=e;let n=t,i=t[3];for(;null!==i&&(1===e&&1===n[5]||-1===e&&0===n[5]);)i[5]+=e,n=i,i=i[3]}const pn={lFrame:Fn(null),bindingsEnabled:!0,isInCheckNoChangesMode:!1};function fn(){return pn.bindingsEnabled}function mn(){return pn.lFrame.lView}function gn(){return pn.lFrame.tView}function yn(t){pn.lFrame.contextLView=t}function vn(){let t=bn();for(;null!==t&&64===t.type;)t=t.parent;return t}function bn(){return pn.lFrame.currentTNode}function An(t,e){const n=pn.lFrame;n.currentTNode=t,n.isParent=e}function xn(){return pn.lFrame.isParent}function wn(){pn.lFrame.isParent=!1}function _n(){return pn.isInCheckNoChangesMode}function Sn(t){pn.isInCheckNoChangesMode=t}function En(){const t=pn.lFrame;let e=t.bindingRootIndex;return-1===e&&(e=t.bindingRootIndex=t.tView.bindingStartIndex),e}function Cn(){return pn.lFrame.bindingIndex}function In(){return pn.lFrame.bindingIndex++}function Tn(t){const e=pn.lFrame,n=e.bindingIndex;return e.bindingIndex=e.bindingIndex+t,n}function Mn(t,e){const n=pn.lFrame;n.bindingIndex=n.bindingRootIndex=t,kn(e)}function kn(t){pn.lFrame.currentDirectiveIndex=t}function Rn(t){const e=pn.lFrame.currentDirectiveIndex;return-1===e?null:t[e]}function Nn(){return pn.lFrame.currentQueryIndex}function Ln(t){pn.lFrame.currentQueryIndex=t}function Dn(t){const e=t[1];return 2===e.type?e.declTNode:1===e.type?t[6]:null}function Bn(t,e,n){if(n&ee.SkipSelf){let i=e,r=t;for(;i=i.parent,!(null!==i||n&ee.Host||(i=Dn(r),null===i)||(r=r[15],10&i.type)););if(null===i)return!1;e=i,t=r}const i=pn.lFrame=Pn();return i.currentTNode=e,i.lView=t,!0}function On(t){const e=Pn(),n=t[1];pn.lFrame=e,e.currentTNode=n.firstChild,e.lView=t,e.tView=n,e.contextLView=t,e.bindingIndex=n.bindingStartIndex,e.inI18n=!1}function Pn(){const t=pn.lFrame,e=null===t?null:t.child;return null===e?Fn(t):e}function Fn(t){const e={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:t,child:null,inI18n:!1};return null!==t&&(t.child=e),e}function $n(){const t=pn.lFrame;return pn.lFrame=t.parent,t.currentTNode=null,t.lView=null,t}const zn=$n;function Un(){const t=$n();t.isParent=!0,t.tView=null,t.selectedIndex=-1,t.contextLView=null,t.elementDepthCount=0,t.currentDirectiveIndex=-1,t.currentNamespace=null,t.bindingRootIndex=-1,t.bindingIndex=-1,t.currentQueryIndex=0}function Hn(){return pn.lFrame.selectedIndex}function Vn(t){pn.lFrame.selectedIndex=t}function Gn(){const t=pn.lFrame;return rn(t.tView,t.selectedIndex)}function Wn(t,e){for(let n=e.directiveStart,i=e.directiveEnd;n<i;n++){const e=t.data[n].type.prototype,{ngAfterContentInit:i,ngAfterContentChecked:r,ngAfterViewInit:s,ngAfterViewChecked:o,ngOnDestroy:a}=e;i&&(t.contentHooks||(t.contentHooks=[])).push(-n,i),r&&((t.contentHooks||(t.contentHooks=[])).push(n,r),(t.contentCheckHooks||(t.contentCheckHooks=[])).push(n,r)),s&&(t.viewHooks||(t.viewHooks=[])).push(-n,s),o&&((t.viewHooks||(t.viewHooks=[])).push(n,o),(t.viewCheckHooks||(t.viewCheckHooks=[])).push(n,o)),null!=a&&(t.destroyHooks||(t.destroyHooks=[])).push(n,a)}}function jn(t,e,n){Xn(t,e,3,n)}function Qn(t,e,n,i){(3&t[2])===n&&Xn(t,e,n,i)}function qn(t,e){let n=t[2];(3&n)===e&&(n&=2047,n+=1,t[2]=n)}function Xn(t,e,n,i){const r=null!=i?i:-1,s=e.length-1;let o=0;for(let a=void 0!==i?65535&t[18]:0;a<s;a++)if("number"==typeof e[a+1]){if(o=e[a],null!=i&&o>=i)break}else e[a]<0&&(t[18]+=65536),(o<r||-1==r)&&(Yn(t,n,e,a),t[18]=(4294901760&t[18])+a+2),a++}function Yn(t,e,n,i){const r=n[i]<0,s=n[i+1],o=t[r?-n[i]:n[i]];if(r){if(t[2]>>11<t[18]>>16&&(3&t[2])===e){t[2]+=2048;try{s.call(o)}finally{}}}else try{s.call(o)}finally{}}const Kn=-1;class Jn{constructor(t,e,n){this.factory=t,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=n}}function Zn(t,e,n){const i=Je(t);let r=0;for(;r<n.length;){const s=n[r];if("number"==typeof s){if(0!==s)break;r++;const o=n[r++],a=n[r++],l=n[r++];i?t.setAttribute(e,a,l,o):e.setAttributeNS(o,a,l)}else{const o=s,a=n[++r];ei(o)?i&&t.setProperty(e,o,a):i?t.setAttribute(e,o,a):e.setAttribute(o,a),r++}}return r}function ti(t){return 3===t||4===t||6===t}function ei(t){return 64===t.charCodeAt(0)}function ni(t,e){if(null===e||0===e.length);else if(null===t||0===t.length)t=e.slice();else{let n=-1;for(let i=0;i<e.length;i++){const r=e[i];"number"==typeof r?n=r:0===n||ii(t,n,r,null,-1===n||2===n?e[++i]:null)}}return t}function ii(t,e,n,i,r){let s=0,o=t.length;if(-1===e)o=-1;else for(;s<t.length;){const n=t[s++];if("number"==typeof n){if(n===e){o=-1;break}if(n>e){o=s-1;break}}}for(;s<t.length;){const e=t[s];if("number"==typeof e)break;if(e===n){if(null===i)return void(null!==r&&(t[s+1]=r));if(i===t[s+1])return void(t[s+2]=r)}s++,null!==i&&s++,null!==r&&s++}-1!==o&&(t.splice(o,0,e),s=o+1),t.splice(s++,0,n),null!==i&&t.splice(s++,0,i),null!==r&&t.splice(s++,0,r)}function ri(t){return t!==Kn}function si(t){return 32767&t}function oi(t,e){let n=t>>16,i=e;for(;n>0;)i=i[15],n--;return i}let ai=!0;function li(t){const e=ai;return ai=t,e}let ci=0;function ui(t,e){const n=di(t,e);if(-1!==n)return n;const i=e[1];i.firstCreatePass&&(t.injectorIndex=e.length,hi(i.data,t),hi(e,null),hi(i.blueprint,null));const r=pi(t,e),s=t.injectorIndex;if(ri(r)){const t=si(r),n=oi(r,e),i=n[1].data;for(let r=0;r<8;r++)e[s+r]=n[t+r]|i[t+r]}return e[s+8]=r,s}function hi(t,e){t.push(0,0,0,0,0,0,0,0,e)}function di(t,e){return-1===t.injectorIndex||t.parent&&t.parent.injectorIndex===t.injectorIndex||null===e[t.injectorIndex+8]?-1:t.injectorIndex}function pi(t,e){if(t.parent&&-1!==t.parent.injectorIndex)return t.parent.injectorIndex;let n=0,i=null,r=e;for(;null!==r;){const t=r[1],e=t.type;if(i=2===e?t.declTNode:1===e?r[6]:null,null===i)return Kn;if(n++,r=r[15],-1!==i.injectorIndex)return i.injectorIndex|n<<16}return Kn}function fi(t,e,n){!function(t,e,n){let i;"string"==typeof n?i=n.charCodeAt(0)||0:n.hasOwnProperty(we)&&(i=n[we]),null==i&&(i=n[we]=ci++);const r=255&i;e.data[t+(r>>5)]|=1<<r}(t,e,n)}function mi(t,e,n){if(n&ee.Optional)return t;Gt(e,"NodeInjector")}function gi(t,e,n,i){if(n&ee.Optional&&void 0===i&&(i=null),0==(n&(ee.Self|ee.Host))){const r=t[9],s=ie(void 0);try{return r?r.get(e,i,n&ee.Optional):re(e,i,n&ee.Optional)}finally{ie(s)}}return mi(i,e,n)}function yi(t,e,n,i=ee.Default,r){if(null!==t){const s=function(t){if("string"==typeof t)return t.charCodeAt(0)||0;const e=t.hasOwnProperty(we)?t[we]:void 0;return"number"==typeof e?e>=0?255&e:bi:e}(n);if("function"==typeof s){if(!Bn(e,t,i))return i&ee.Host?mi(r,n,i):gi(e,n,i,r);try{const t=s();if(null!=t||i&ee.Optional)return t;Gt(n)}finally{zn()}}else if("number"==typeof s){let r=null,o=di(t,e),a=Kn,l=i&ee.Host?e[16][6]:null;for((-1===o||i&ee.SkipSelf)&&(a=-1===o?pi(t,e):e[o+8],a!==Kn&&Si(i,!1)?(r=e[1],o=si(a),e=oi(a,e)):o=-1);-1!==o;){const t=e[1];if(_i(s,o,t.data)){const t=Ai(o,e,n,r,i,l);if(t!==vi)return t}a=e[o+8],a!==Kn&&Si(i,e[1].data[o+8]===l)&&_i(s,o,e)?(r=t,o=si(a),e=oi(a,e)):o=-1}}}return gi(e,n,i,r)}const vi={};function bi(){return new Ei(vn(),mn())}function Ai(t,e,n,i,r,s){const o=e[1],a=o.data[t+8],l=xi(a,o,n,null==i?$e(a)&&ai:i!=o&&0!=(3&a.type),r&ee.Host&&s===a);return null!==l?wi(e,o,l,a):vi}function xi(t,e,n,i,r){const s=t.providerIndexes,o=e.data,a=1048575&s,l=t.directiveStart,c=s>>20,u=r?a+c:t.directiveEnd;for(let h=i?a:a+c;h<u;h++){const t=o[h];if(h<l&&n===t||h>=l&&t.type===n)return h}if(r){const t=o[l];if(t&&Ue(t)&&t.type===n)return l}return null}function wi(t,e,n,i){let r=t[n];const s=e.data;if(r instanceof Jn){const o=r;o.resolving&&function(t,e){throw new Ut("200",`Circular dependency in DI detected for ${t}`)}(Vt(s[n]));const a=li(o.canSeeViewProviders);o.resolving=!0;const l=o.injectImpl?ie(o.injectImpl):null;Bn(t,i,ee.Default);try{r=t[n]=o.factory(void 0,s,t,i),e.firstCreatePass&&n>=i.directiveStart&&function(t,e,n){const{ngOnChanges:i,ngOnInit:r,ngDoCheck:s}=e.type.prototype;if(i){const i=We(e);(n.preOrderHooks||(n.preOrderHooks=[])).push(t,i),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(t,i)}r&&(n.preOrderHooks||(n.preOrderHooks=[])).push(0-t,r),s&&((n.preOrderHooks||(n.preOrderHooks=[])).push(t,s),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(t,s))}(n,s[n],e)}finally{null!==l&&ie(l),li(a),o.resolving=!1,zn()}}return r}function _i(t,e,n){return!!(n[e+(t>>5)]&1<<t)}function Si(t,e){return!(t&ee.Self||t&ee.Host&&e)}class Ei{constructor(t,e){this._tNode=t,this._lView=e}get(t,e){return yi(this._tNode,this._lView,t,void 0,e)}}function Ci(t){return se(()=>{const e=t.prototype.constructor,n=e[xe]||Ii(e),i=Object.prototype;let r=Object.getPrototypeOf(t.prototype).constructor;for(;r&&r!==i;){const t=r[xe]||Ii(r);if(t&&t!==n)return t;r=Object.getPrototypeOf(r)}return t=>new t})}function Ii(t){return zt(t)?()=>{const e=Ii($t(t));return e&&e()}:He(t)}function Ti(t){return function(t,e){if("class"===e)return t.classes;if("style"===e)return t.styles;const n=t.attrs;if(n){const t=n.length;let i=0;for(;i<t;){const r=n[i];if(ti(r))break;if(0===r)i+=2;else if("number"==typeof r)for(i++;i<t&&"string"==typeof n[i];)i++;else{if(r===e)return n[i+1];i+=2}}}return null}(vn(),t)}const Mi="__parameters__";function ki(t,e,n){return se(()=>{const i=function(t){return function(...e){if(t){const n=t(...e);for(const t in n)this[t]=n[t]}}}(e);function r(...t){if(this instanceof r)return i.apply(this,t),this;const e=new r(...t);return n.annotation=e,n;function n(t,n,i){const r=t.hasOwnProperty(Mi)?t[Mi]:Object.defineProperty(t,Mi,{value:[]})[Mi];for(;r.length<=i;)r.push(null);return(r[i]=r[i]||[]).push(e),t}}return n&&(r.prototype=Object.create(n.prototype)),r.prototype.ngMetadataName=t,r.annotationCls=r,r})}class Ri{constructor(t,e){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=Wt({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}toString(){return`InjectionToken ${this._desc}`}}const Ni=new Ri("AnalyzeForEntryComponents"),Li=Function;function Di(t,e){void 0===e&&(e=t);for(let n=0;n<t.length;n++){let i=t[n];Array.isArray(i)?(e===t&&(e=t.slice(0,n)),Di(i,e)):e!==t&&e.push(i)}return e}function Bi(t,e){t.forEach(t=>Array.isArray(t)?Bi(t,e):e(t))}function Oi(t,e,n){e>=t.length?t.push(n):t.splice(e,0,n)}function Pi(t,e){return e>=t.length-1?t.pop():t.splice(e,1)[0]}function Fi(t,e){const n=[];for(let i=0;i<t;i++)n.push(e);return n}function $i(t,e,n){let i=Ui(t,e);return i>=0?t[1|i]=n:(i=~i,function(t,e,n,i){let r=t.length;if(r==e)t.push(n,i);else if(1===r)t.push(i,t[0]),t[0]=n;else{for(r--,t.push(t[r-1],t[r]);r>e;)t[r]=t[r-2],r--;t[e]=n,t[e+1]=i}}(t,i,e,n)),i}function zi(t,e){const n=Ui(t,e);if(n>=0)return t[1|n]}function Ui(t,e){return function(t,e,n){let i=0,r=t.length>>1;for(;r!==i;){const n=i+(r-i>>1),s=t[n<<1];if(e===s)return n<<1;s>e?r=n:i=n+1}return~(r<<1)}(t,e)}const Hi={},Vi=/\n/gm,Gi="__source",Wi=Lt({provide:String,useValue:Lt});let ji;function Qi(t){const e=ji;return ji=t,e}function qi(t,e=ee.Default){if(void 0===ji)throw new Error("inject() must be called from an injection context");return null===ji?re(t,void 0,e):ji.get(t,e&ee.Optional?null:void 0,e)}function Xi(t,e=ee.Default){return(ne||qi)($t(t),e)}const Yi=Xi;function Ki(t){const e=[];for(let n=0;n<t.length;n++){const i=$t(t[n]);if(Array.isArray(i)){if(0===i.length)throw new Error("Arguments array must have arguments.");let t,n=ee.Default;for(let e=0;e<i.length;e++){const r=i[e],s=r.__NG_DI_FLAG__;"number"==typeof s?-1===s?t=r.token:n|=s:t=r}e.push(Xi(t,n))}else e.push(Xi(i))}return e}function Ji(t,e){return t.__NG_DI_FLAG__=e,t.prototype.__NG_DI_FLAG__=e,t}const Zi=Ji(ki("Inject",t=>({token:t})),-1),tr=Ji(ki("Optional"),8),er=Ji(ki("SkipSelf"),4);let nr,ir;function rr(t){var e;return(null===(e=function(){if(void 0===nr&&(nr=null,de.trustedTypes))try{nr=de.trustedTypes.createPolicy("angular",{createHTML:t=>t,createScript:t=>t,createScriptURL:t=>t})}catch(e){}return nr}())||void 0===e?void 0:e.createHTML(t))||t}function sr(t){var e;return(null===(e=function(){if(void 0===ir&&(ir=null,de.trustedTypes))try{ir=de.trustedTypes.createPolicy("angular#unsafe-bypass",{createHTML:t=>t,createScript:t=>t,createScriptURL:t=>t})}catch(e){}return ir}())||void 0===e?void 0:e.createHTML(t))||t}class or{constructor(t){this.changingThisBreaksApplicationSecurity=t}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`}}class ar extends or{getTypeName(){return"HTML"}}class lr extends or{getTypeName(){return"Style"}}class cr extends or{getTypeName(){return"Script"}}class ur extends or{getTypeName(){return"URL"}}class hr extends or{getTypeName(){return"ResourceURL"}}function dr(t){return t instanceof or?t.changingThisBreaksApplicationSecurity:t}function pr(t,e){const n=fr(t);if(null!=n&&n!==e){if("ResourceURL"===n&&"URL"===e)return!0;throw new Error(`Required a safe ${e}, got a ${n} (see https://g.co/ng/security#xss)`)}return n===e}function fr(t){return t instanceof or&&t.getTypeName()||null}class mr{constructor(t){this.inertDocumentHelper=t}getInertBodyElement(t){t="<body><remove></remove>"+t;try{const e=(new window.DOMParser).parseFromString(rr(t),"text/html").body;return null===e?this.inertDocumentHelper.getInertBodyElement(t):(e.removeChild(e.firstChild),e)}catch(e){return null}}}class gr{constructor(t){if(this.defaultDoc=t,this.inertDocument=this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"),null==this.inertDocument.body){const t=this.inertDocument.createElement("html");this.inertDocument.appendChild(t);const e=this.inertDocument.createElement("body");t.appendChild(e)}}getInertBodyElement(t){const e=this.inertDocument.createElement("template");if("content"in e)return e.innerHTML=rr(t),e;const n=this.inertDocument.createElement("body");return n.innerHTML=rr(t),this.defaultDoc.documentMode&&this.stripCustomNsAttrs(n),n}stripCustomNsAttrs(t){const e=t.attributes;for(let i=e.length-1;0<i;i--){const n=e.item(i).name;"xmlns:ns1"!==n&&0!==n.indexOf("ns1:")||t.removeAttribute(n)}let n=t.firstChild;for(;n;)n.nodeType===Node.ELEMENT_NODE&&this.stripCustomNsAttrs(n),n=n.nextSibling}}const yr=/^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi,vr=/^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;function br(t){return(t=String(t)).match(yr)||t.match(vr)?t:"unsafe:"+t}function Ar(t){const e={};for(const n of t.split(","))e[n]=!0;return e}function xr(...t){const e={};for(const n of t)for(const t in n)n.hasOwnProperty(t)&&(e[t]=!0);return e}const wr=Ar("area,br,col,hr,img,wbr"),_r=Ar("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),Sr=Ar("rp,rt"),Er=xr(Sr,_r),Cr=xr(wr,xr(_r,Ar("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")),xr(Sr,Ar("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")),Er),Ir=Ar("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),Tr=Ar("srcset"),Mr=xr(Ir,Tr,Ar("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"),Ar("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")),kr=Ar("script,style,template");class Rr{constructor(){this.sanitizedSomething=!1,this.buf=[]}sanitizeChildren(t){let e=t.firstChild,n=!0;for(;e;)if(e.nodeType===Node.ELEMENT_NODE?n=this.startElement(e):e.nodeType===Node.TEXT_NODE?this.chars(e.nodeValue):this.sanitizedSomething=!0,n&&e.firstChild)e=e.firstChild;else for(;e;){e.nodeType===Node.ELEMENT_NODE&&this.endElement(e);let t=this.checkClobberedElement(e,e.nextSibling);if(t){e=t;break}e=this.checkClobberedElement(e,e.parentNode)}return this.buf.join("")}startElement(t){const e=t.nodeName.toLowerCase();if(!Cr.hasOwnProperty(e))return this.sanitizedSomething=!0,!kr.hasOwnProperty(e);this.buf.push("<"),this.buf.push(e);const n=t.attributes;for(let r=0;r<n.length;r++){const t=n.item(r),e=t.name,s=e.toLowerCase();if(!Mr.hasOwnProperty(s)){this.sanitizedSomething=!0;continue}let o=t.value;Ir[s]&&(o=br(o)),Tr[s]&&(i=o,o=(i=String(i)).split(",").map(t=>br(t.trim())).join(", ")),this.buf.push(" ",e,'="',Dr(o),'"')}var i;return this.buf.push(">"),!0}endElement(t){const e=t.nodeName.toLowerCase();Cr.hasOwnProperty(e)&&!wr.hasOwnProperty(e)&&(this.buf.push("</"),this.buf.push(e),this.buf.push(">"))}chars(t){this.buf.push(Dr(t))}checkClobberedElement(t,e){if(e&&(t.compareDocumentPosition(e)&Node.DOCUMENT_POSITION_CONTAINED_BY)===Node.DOCUMENT_POSITION_CONTAINED_BY)throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`);return e}}const Nr=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,Lr=/([^\#-~ |!])/g;function Dr(t){return t.replace(/&/g,"&amp;").replace(Nr,function(t){return"&#"+(1024*(t.charCodeAt(0)-55296)+(t.charCodeAt(1)-56320)+65536)+";"}).replace(Lr,function(t){return"&#"+t.charCodeAt(0)+";"}).replace(/</g,"&lt;").replace(/>/g,"&gt;")}let Br;function Or(t,e){let n=null;try{Br=Br||function(t){const e=new gr(t);return function(){try{return!!(new window.DOMParser).parseFromString(rr(""),"text/html")}catch(t){return!1}}()?new mr(e):e}(t);let i=e?String(e):"";n=Br.getInertBodyElement(i);let r=5,s=i;do{if(0===r)throw new Error("Failed to sanitize html because the input is unstable");r--,i=s,s=n.innerHTML,n=Br.getInertBodyElement(i)}while(i!==s);return rr((new Rr).sanitizeChildren(Pr(n)||n))}finally{if(n){const t=Pr(n)||n;for(;t.firstChild;)t.removeChild(t.firstChild)}}}function Pr(t){return"content"in t&&function(t){return t.nodeType===Node.ELEMENT_NODE&&"TEMPLATE"===t.nodeName}(t)?t.content:null}var Fr=function(t){return t[t.NONE=0]="NONE",t[t.HTML=1]="HTML",t[t.STYLE=2]="STYLE",t[t.SCRIPT=3]="SCRIPT",t[t.URL=4]="URL",t[t.RESOURCE_URL=5]="RESOURCE_URL",t}({});function $r(t){const e=function(){const t=mn();return t&&t[12]}();return e?sr(e.sanitize(Fr.HTML,t)||""):pr(t,"HTML")?sr(dr(t)):Or(Ke(),Ht(t))}function zr(t){return t.ngDebugContext}function Ur(t){return t.ngOriginalError}function Hr(t,...e){t.error(...e)}class Vr{constructor(){this._console=console}handleError(t){const e=this._findOriginalError(t),n=this._findContext(t),i=function(t){return t.ngErrorLogger||Hr}(t);i(this._console,"ERROR",t),e&&i(this._console,"ORIGINAL ERROR",e),n&&i(this._console,"ERROR CONTEXT",n)}_findContext(t){return t?zr(t)?zr(t):this._findContext(Ur(t)):null}_findOriginalError(t){let e=Ur(t);for(;e&&Ur(e);)e=Ur(e);return e}}function Gr(t,e){t.__ngContext__=e}const Wr=(()=>("undefined"!=typeof requestAnimationFrame&&requestAnimationFrame||setTimeout).bind(de))();function jr(t){return{name:"body",target:t.ownerDocument.body}}function Qr(t){return t instanceof Function?t():t}var qr=function(t){return t[t.Important=1]="Important",t[t.DashCase=2]="DashCase",t}({});function Xr(t,e){return(void 0)(t,e)}function Yr(t){const e=t[3];return Pe(e)?e[3]:e}function Kr(t){return Zr(t[13])}function Jr(t){return Zr(t[4])}function Zr(t){for(;null!==t&&!Pe(t);)t=t[4];return t}function ts(t,e,n,i,r){if(null!=i){let s,o=!1;Pe(i)?s=i:Oe(i)&&(o=!0,i=i[0]);const a=tn(i);0===t&&null!==n?null==r?ls(e,n,a):as(e,n,a,r||null,!0):1===t&&null!==n?as(e,n,a,r||null,!0):2===t?function(t,e,n){const i=us(t,e);i&&function(t,e,n,i){Je(t)?t.removeChild(e,n,i):e.removeChild(n)}(t,i,e,n)}(e,a,o):3===t&&e.destroyNode(a),null!=s&&function(t,e,n,i,r){const s=n[7];s!==tn(n)&&ts(e,t,i,s,r);for(let o=Be;o<n.length;o++){const r=n[o];vs(r[1],r,t,e,i,s)}}(e,t,s,n,r)}}function es(t,e,n){return Je(t)?t.createElement(e,n):null===n?t.createElement(e):t.createElementNS(n,e)}function ns(t,e){const n=t[9],i=n.indexOf(e),r=e[3];1024&e[2]&&(e[2]&=-1025,dn(r,-1)),n.splice(i,1)}function is(t,e){if(t.length<=Be)return;const n=Be+e,i=t[n];if(i){const s=i[17];null!==s&&s!==t&&ns(s,i),e>0&&(t[n-1][4]=i[4]);const o=Pi(t,Be+e);vs(i[1],r=i,r[11],2,null,null),r[0]=null,r[6]=null;const a=o[19];null!==a&&a.detachView(o[1]),i[3]=null,i[4]=null,i[2]&=-129}var r;return i}function rs(t,e){if(!(256&e[2])){const n=e[11];Je(n)&&n.destroyNode&&vs(t,e,n,3,null,null),function(t){let e=t[13];if(!e)return ss(t[1],t);for(;e;){let n=null;if(Oe(e))n=e[13];else{const t=e[10];t&&(n=t)}if(!n){for(;e&&!e[4]&&e!==t;)Oe(e)&&ss(e[1],e),e=e[3];null===e&&(e=t),Oe(e)&&ss(e[1],e),n=e&&e[4]}e=n}}(e)}}function ss(t,e){if(!(256&e[2])){e[2]&=-129,e[2]|=256,function(t,e){let n;if(null!=t&&null!=(n=t.destroyHooks))for(let i=0;i<n.length;i+=2){const t=e[n[i]];if(!(t instanceof Jn)){const e=n[i+1];if(Array.isArray(e))for(let n=0;n<e.length;n+=2){const i=t[e[n]],r=e[n+1];try{r.call(i)}finally{}}else try{e.call(t)}finally{}}}}(t,e),function(t,e){const n=t.cleanup,i=e[7];let r=-1;if(null!==n)for(let s=0;s<n.length-1;s+=2)if("string"==typeof n[s]){const t=n[s+1],o="function"==typeof t?t(e):tn(e[t]),a=i[r=n[s+2]],l=n[s+3];"boolean"==typeof l?o.removeEventListener(n[s],a,l):l>=0?i[r=l]():i[r=-l].unsubscribe(),s+=2}else{const t=i[r=n[s+1]];n[s].call(t)}if(null!==i){for(let t=r+1;t<i.length;t++)(0,i[t])();e[7]=null}}(t,e),1===e[1].type&&Je(e[11])&&e[11].destroy();const n=e[17];if(null!==n&&Pe(e[3])){n!==e[3]&&ns(n,e);const i=e[19];null!==i&&i.detachView(t)}}}function os(t,e,n){return function(t,e,n){let i=e;for(;null!==i&&40&i.type;)i=(e=i).parent;if(null===i)return n[0];if(2&i.flags){const e=t.data[i.directiveStart].encapsulation;if(e===ae.None||e===ae.Emulated)return null}return nn(i,n)}(t,e.parent,n)}function as(t,e,n,i,r){Je(t)?t.insertBefore(e,n,i,r):e.insertBefore(n,i,r)}function ls(t,e,n){Je(t)?t.appendChild(e,n):e.appendChild(n)}function cs(t,e,n,i,r){null!==i?as(t,e,n,i,r):ls(t,e,n)}function us(t,e){return Je(t)?t.parentNode(e):e.parentNode}function hs(t,e,n){return ds(t,e,n)}let ds=function(t,e,n){return 40&t.type?nn(t,n):null};function ps(t,e,n,i){const r=os(t,i,e),s=e[11],o=hs(i.parent||e[6],i,e);if(null!=r)if(Array.isArray(n))for(let a=0;a<n.length;a++)cs(s,r,n[a],o,!1);else cs(s,r,n,o,!1)}function fs(t,e){if(null!==e){const n=e.type;if(3&n)return nn(e,t);if(4&n)return gs(-1,t[e.index]);if(8&n){const n=e.child;if(null!==n)return fs(t,n);{const n=t[e.index];return Pe(n)?gs(-1,n):tn(n)}}if(32&n)return Xr(e,t)()||tn(t[e.index]);{const n=ms(t,e);return null!==n?Array.isArray(n)?n[0]:fs(Yr(t[16]),n):fs(t,e.next)}}return null}function ms(t,e){return null!==e?t[16][6].projection[e.projection]:null}function gs(t,e){const n=Be+t+1;if(n<e.length){const t=e[n],i=t[1].firstChild;if(null!==i)return fs(t,i)}return e[7]}function ys(t,e,n,i,r,s,o){for(;null!=n;){const a=i[n.index],l=n.type;if(o&&0===e&&(a&&Gr(tn(a),i),n.flags|=4),64!=(64&n.flags))if(8&l)ys(t,e,n.child,i,r,s,!1),ts(e,t,r,a,s);else if(32&l){const o=Xr(n,i);let l;for(;l=o();)ts(e,t,r,l,s);ts(e,t,r,a,s)}else 16&l?bs(t,e,i,n,r,s):ts(e,t,r,a,s);n=o?n.projectionNext:n.next}}function vs(t,e,n,i,r,s){ys(n,i,t.firstChild,e,r,s,!1)}function bs(t,e,n,i,r,s){const o=n[16],a=o[6].projection[i.projection];if(Array.isArray(a))for(let l=0;l<a.length;l++)ts(e,t,r,a[l],s);else ys(t,e,a,o[3],r,s,!0)}function As(t,e,n){Je(t)?t.setAttribute(e,"style",n):e.style.cssText=n}function xs(t,e,n){Je(t)?""===n?t.removeAttribute(e,"class"):t.setAttribute(e,"class",n):e.className=n}function ws(t,e,n){let i=t.length;for(;;){const r=t.indexOf(e,n);if(-1===r)return r;if(0===r||t.charCodeAt(r-1)<=32){const n=e.length;if(r+n===i||t.charCodeAt(r+n)<=32)return r}n=r+1}}const _s="ng-template";function Ss(t,e,n){let i=0;for(;i<t.length;){let r=t[i++];if(n&&"class"===r){if(r=t[i],-1!==ws(r.toLowerCase(),e,0))return!0}else if(1===r){for(;i<t.length&&"string"==typeof(r=t[i++]);)if(r.toLowerCase()===e)return!0;return!1}}return!1}function Es(t){return 4===t.type&&t.value!==_s}function Cs(t,e,n){return e===(4!==t.type||n?t.value:_s)}function Is(t,e,n){let i=4;const r=t.attrs||[],s=function(t){for(let e=0;e<t.length;e++)if(ti(t[e]))return e;return t.length}(r);let o=!1;for(let a=0;a<e.length;a++){const l=e[a];if("number"!=typeof l){if(!o)if(4&i){if(i=2|1&i,""!==l&&!Cs(t,l,n)||""===l&&1===e.length){if(Ts(i))return!1;o=!0}}else{const c=8&i?l:e[++a];if(8&i&&null!==t.attrs){if(!Ss(t.attrs,c,n)){if(Ts(i))return!1;o=!0}continue}const u=Ms(8&i?"class":l,r,Es(t),n);if(-1===u){if(Ts(i))return!1;o=!0;continue}if(""!==c){let t;t=u>s?"":r[u+1].toLowerCase();const e=8&i?t:null;if(e&&-1!==ws(e,c,0)||2&i&&c!==t){if(Ts(i))return!1;o=!0}}}}else{if(!o&&!Ts(i)&&!Ts(l))return!1;if(o&&Ts(l))continue;o=!1,i=l|1&i}}return Ts(i)||o}function Ts(t){return 0==(1&t)}function Ms(t,e,n,i){if(null===e)return-1;let r=0;if(i||!n){let n=!1;for(;r<e.length;){const i=e[r];if(i===t)return r;if(3===i||6===i)n=!0;else{if(1===i||2===i){let t=e[++r];for(;"string"==typeof t;)t=e[++r];continue}if(4===i)break;if(0===i){r+=4;continue}}r+=n?1:2}return-1}return function(t,e){let n=t.indexOf(4);if(n>-1)for(n++;n<t.length;){const i=t[n];if("number"==typeof i)return-1;if(i===e)return n;n++}return-1}(e,t)}function ks(t,e,n=!1){for(let i=0;i<e.length;i++)if(Is(t,e[i],n))return!0;return!1}function Rs(t,e){t:for(let n=0;n<e.length;n++){const i=e[n];if(t.length===i.length){for(let e=0;e<t.length;e++)if(t[e]!==i[e])continue t;return!0}}return!1}function Ns(t,e){return t?":not("+e.trim()+")":e}function Ls(t){let e=t[0],n=1,i=2,r="",s=!1;for(;n<t.length;){let o=t[n];if("string"==typeof o)if(2&i){const e=t[++n];r+="["+o+(e.length>0?'="'+e+'"':"")+"]"}else 8&i?r+="."+o:4&i&&(r+=" "+o);else""===r||Ts(o)||(e+=Ns(s,r),r=""),i=o,s=s||!Ts(i);n++}return""!==r&&(e+=Ns(s,r)),e}const Ds={};function Bs(t){Os(gn(),mn(),Hn()+t,_n())}function Os(t,e,n,i){if(!i)if(3==(3&e[2])){const i=t.preOrderCheckHooks;null!==i&&jn(e,i,n)}else{const i=t.preOrderHooks;null!==i&&Qn(e,i,0,n)}Vn(n)}function Ps(t,e){return t<<17|e<<2}function Fs(t){return t>>17&32767}function $s(t){return 2|t}function zs(t){return(131068&t)>>2}function Us(t,e){return-131069&t|e<<2}function Hs(t){return 1|t}function Vs(t,e){const n=t.contentQueries;if(null!==n)for(let i=0;i<n.length;i+=2){const r=n[i],s=n[i+1];if(-1!==s){const n=t.data[s];Ln(r),n.contentQueries(2,e[s],s)}}}function Gs(t,e,n,i,r,s,o,a,l,c){const u=e.blueprint.slice();return u[0]=r,u[2]=140|i,hn(u),u[3]=u[15]=t,u[8]=n,u[10]=o||t&&t[10],u[11]=a||t&&t[11],u[12]=l||t&&t[12]||null,u[9]=c||t&&t[9]||null,u[6]=s,u[16]=2==e.type?t[16]:u,u}function Ws(t,e,n,i,r){let s=t.data[e];if(null===s)s=function(t,e,n,i,r){const s=bn(),o=xn(),a=t.data[e]=function(t,e,n,i,r,s){return{type:n,index:i,insertBeforeIndex:null,injectorIndex:e?e.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,propertyBindings:null,flags:0,providerIndexes:0,value:r,attrs:s,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:e,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,o?s:s&&s.parent,n,e,i,r);return null===t.firstChild&&(t.firstChild=a),null!==s&&(o?null==s.child&&null!==a.parent&&(s.child=a):null===s.next&&(s.next=a)),a}(t,e,n,i,r),pn.lFrame.inI18n&&(s.flags|=64);else if(64&s.type){s.type=n,s.value=i,s.attrs=r;const t=function(){const t=pn.lFrame,e=t.currentTNode;return t.isParent?e:e.parent}();s.injectorIndex=null===t?-1:t.injectorIndex}return An(s,!0),s}function js(t,e,n,i){if(0===n)return-1;const r=e.length;for(let s=0;s<n;s++)e.push(i),t.blueprint.push(i),t.data.push(null);return r}function Qs(t,e,n){On(e);try{const i=t.viewQuery;null!==i&&So(1,i,n);const r=t.template;null!==r&&Ys(t,e,r,1,n),t.firstCreatePass&&(t.firstCreatePass=!1),t.staticContentQueries&&Vs(t,e),t.staticViewQueries&&So(2,t.viewQuery,n);const s=t.components;null!==s&&function(t,e){for(let n=0;n<e.length;n++)bo(t,e[n])}(e,s)}catch(i){throw t.firstCreatePass&&(t.incompleteFirstPass=!0),i}finally{e[2]&=-5,Un()}}function qs(t,e,n,i){const r=e[2];if(256==(256&r))return;On(e);const s=_n();try{hn(e),pn.lFrame.bindingIndex=t.bindingStartIndex,null!==n&&Ys(t,e,n,2,i);const o=3==(3&r);if(!s)if(o){const n=t.preOrderCheckHooks;null!==n&&jn(e,n,null)}else{const n=t.preOrderHooks;null!==n&&Qn(e,n,0,null),qn(e,0)}if(function(t){for(let e=Kr(t);null!==e;e=Jr(e)){if(!e[2])continue;const t=e[9];for(let e=0;e<t.length;e++){const n=t[e],i=n[3];0==(1024&n[2])&&dn(i,1),n[2]|=1024}}}(e),function(t){for(let e=Kr(t);null!==e;e=Jr(e))for(let t=Be;t<e.length;t++){const n=e[t],i=n[1];cn(n)&&qs(i,n,i.template,n[8])}}(e),null!==t.contentQueries&&Vs(t,e),!s)if(o){const n=t.contentCheckHooks;null!==n&&jn(e,n)}else{const n=t.contentHooks;null!==n&&Qn(e,n,1),qn(e,1)}!function(t,e){const n=t.hostBindingOpCodes;if(null!==n)try{for(let t=0;t<n.length;t++){const i=n[t];if(i<0)Vn(~i);else{const r=i,s=n[++t],o=n[++t];Mn(s,r),o(2,e[r])}}}finally{Vn(-1)}}(t,e);const a=t.components;null!==a&&function(t,e){for(let n=0;n<e.length;n++)yo(t,e[n])}(e,a);const l=t.viewQuery;if(null!==l&&So(2,l,i),!s)if(o){const n=t.viewCheckHooks;null!==n&&jn(e,n)}else{const n=t.viewHooks;null!==n&&Qn(e,n,2),qn(e,2)}!0===t.firstUpdatePass&&(t.firstUpdatePass=!1),s||(e[2]&=-73),1024&e[2]&&(e[2]&=-1025,dn(e[3],-1))}finally{Un()}}function Xs(t,e,n,i){const r=e[10],s=!_n(),o=ln(e);try{s&&!o&&r.begin&&r.begin(),o&&Qs(t,e,i),qs(t,e,n,i)}finally{s&&!o&&r.end&&r.end()}}function Ys(t,e,n,i,r){const s=Hn(),o=2&i;try{Vn(-1),o&&e.length>De&&Os(t,e,De,_n()),n(i,r)}finally{Vn(s)}}function Ks(t,e,n){if(Fe(e)){const i=e.directiveEnd;for(let r=e.directiveStart;r<i;r++){const e=t.data[r];e.contentQueries&&e.contentQueries(1,n[r],r)}}}function Js(t,e,n){fn()&&(function(t,e,n,i){const r=n.directiveStart,s=n.directiveEnd;t.firstCreatePass||ui(n,e),Gr(i,e);const o=n.initialInputs;for(let a=r;a<s;a++){const i=t.data[a],s=Ue(i);s&&po(e,n,i);const l=wi(e,t,a,n);Gr(l,e),null!==o&&fo(0,a-r,l,i,0,o),s&&(on(n.index,e)[8]=l)}}(t,e,n,nn(n,e)),128==(128&n.flags)&&function(t,e,n){const i=n.directiveStart,r=n.directiveEnd,s=n.index,o=pn.lFrame.currentDirectiveIndex;try{Vn(s);for(let n=i;n<r;n++){const i=t.data[n],r=e[n];kn(n),null===i.hostBindings&&0===i.hostVars&&null===i.hostAttrs||ao(i,r)}}finally{Vn(-1),kn(o)}}(t,e,n))}function Zs(t,e,n=nn){const i=e.localNames;if(null!==i){let r=e.index+1;for(let s=0;s<i.length;s+=2){const o=i[s+1],a=-1===o?n(e,t):t[o];t[r++]=a}}}function to(t){const e=t.tView;return null===e||e.incompleteFirstPass?t.tView=eo(1,null,t.template,t.decls,t.vars,t.directiveDefs,t.pipeDefs,t.viewQuery,t.schemas,t.consts):e}function eo(t,e,n,i,r,s,o,a,l,c){const u=De+i,h=u+r,d=function(t,e){const n=[];for(let i=0;i<e;i++)n.push(i<t?null:Ds);return n}(u,h),p="function"==typeof c?c():c;return d[1]={type:t,blueprint:d,template:n,queries:null,viewQuery:a,declTNode:e,data:d.slice().fill(null,u),bindingStartIndex:u,expandoStartIndex:h,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof s?s():s,pipeRegistry:"function"==typeof o?o():o,firstChild:null,schemas:l,consts:p,incompleteFirstPass:!1}}function no(t,e,n,i){const r=Co(e);null===n?r.push(i):(r.push(n),t.firstCreatePass&&Io(t).push(i,r.length-1))}function io(t,e,n){for(let i in t)if(t.hasOwnProperty(i)){const r=t[i];(n=null===n?{}:n).hasOwnProperty(i)?n[i].push(e,r):n[i]=[e,r]}return n}function ro(t,e,n,i,r,s,o,a){const l=nn(e,n);let c,u=e.inputs;var h;!a&&null!=u&&(c=u[i])?(ko(t,n,c,i,r),$e(e)&&function(t,e){const n=on(e,t);16&n[2]||(n[2]|=64)}(n,e.index)):3&e.type&&(i="class"===(h=i)?"className":"for"===h?"htmlFor":"formaction"===h?"formAction":"innerHtml"===h?"innerHTML":"readonly"===h?"readOnly":"tabindex"===h?"tabIndex":h,r=null!=o?o(r,e.value||"",i):r,Je(s)?s.setProperty(l,i,r):ei(i)||(l.setProperty?l.setProperty(i,r):l[i]=r))}function so(t,e,n,i){let r=!1;if(fn()){const s=function(t,e,n){const i=t.directiveRegistry;let r=null;if(i)for(let s=0;s<i.length;s++){const o=i[s];ks(n,o.selectors,!1)&&(r||(r=[]),fi(ui(n,e),t,o.type),Ue(o)?(lo(t,n),r.unshift(o)):r.push(o))}return r}(t,e,n),o=null===i?null:{"":-1};if(null!==s){r=!0,uo(n,t.data.length,s.length);for(let t=0;t<s.length;t++){const e=s[t];e.providersResolver&&e.providersResolver(e)}let i=!1,a=!1,l=js(t,e,s.length,null);for(let r=0;r<s.length;r++){const c=s[r];n.mergedAttrs=ni(n.mergedAttrs,c.hostAttrs),ho(t,n,e,l,c),co(l,c,o),null!==c.contentQueries&&(n.flags|=8),null===c.hostBindings&&null===c.hostAttrs&&0===c.hostVars||(n.flags|=128);const u=c.type.prototype;!i&&(u.ngOnChanges||u.ngOnInit||u.ngDoCheck)&&((t.preOrderHooks||(t.preOrderHooks=[])).push(n.index),i=!0),a||!u.ngOnChanges&&!u.ngDoCheck||((t.preOrderCheckHooks||(t.preOrderCheckHooks=[])).push(n.index),a=!0),l++}!function(t,e){const n=e.directiveEnd,i=t.data,r=e.attrs,s=[];let o=null,a=null;for(let l=e.directiveStart;l<n;l++){const t=i[l],n=t.inputs,c=null===r||Es(e)?null:mo(n,r);s.push(c),o=io(n,l,o),a=io(t.outputs,l,a)}null!==o&&(o.hasOwnProperty("class")&&(e.flags|=16),o.hasOwnProperty("style")&&(e.flags|=32)),e.initialInputs=s,e.inputs=o,e.outputs=a}(t,n)}o&&function(t,e,n){if(e){const i=t.localNames=[];for(let t=0;t<e.length;t+=2){const r=n[e[t+1]];if(null==r)throw new Ut("301",`Export of name '${e[t+1]}' not found!`);i.push(e[t],r)}}}(n,i,o)}return n.mergedAttrs=ni(n.mergedAttrs,n.attrs),r}function oo(t,e,n,i,r,s){const o=s.hostBindings;if(o){let n=t.hostBindingOpCodes;null===n&&(n=t.hostBindingOpCodes=[]);const s=~e.index;(function(t){let e=t.length;for(;e>0;){const n=t[--e];if("number"==typeof n&&n<0)return n}return 0})(n)!=s&&n.push(s),n.push(i,r,o)}}function ao(t,e){null!==t.hostBindings&&t.hostBindings(1,e)}function lo(t,e){e.flags|=2,(t.components||(t.components=[])).push(e.index)}function co(t,e,n){if(n){if(e.exportAs)for(let i=0;i<e.exportAs.length;i++)n[e.exportAs[i]]=t;Ue(e)&&(n[""]=t)}}function uo(t,e,n){t.flags|=1,t.directiveStart=e,t.directiveEnd=e+n,t.providerIndexes=e}function ho(t,e,n,i,r){t.data[i]=r;const s=r.factory||(r.factory=He(r.type)),o=new Jn(s,Ue(r),null);t.blueprint[i]=o,n[i]=o,oo(t,e,0,i,js(t,n,r.hostVars,Ds),r)}function po(t,e,n){const i=nn(e,t),r=to(n),s=t[10],o=Ao(t,Gs(t,r,null,n.onPush?64:16,i,e,s,s.createRenderer(i,n),null,null));t[e.index]=o}function fo(t,e,n,i,r,s){const o=s[e];if(null!==o){const t=i.setInput;for(let e=0;e<o.length;){const r=o[e++],s=o[e++],a=o[e++];null!==t?i.setInput(n,a,r,s):n[s]=a}}}function mo(t,e){let n=null,i=0;for(;i<e.length;){const r=e[i];if(0!==r)if(5!==r){if("number"==typeof r)break;t.hasOwnProperty(r)&&(null===n&&(n=[]),n.push(r,t[r],e[i+1])),i+=2}else i+=2;else i+=4}return n}function go(t,e,n,i){return new Array(t,!0,!1,e,null,0,i,n,null,null)}function yo(t,e){const n=on(e,t);if(cn(n)){const t=n[1];80&n[2]?qs(t,n,t.template,n[8]):n[5]>0&&vo(n)}}function vo(t){for(let n=Kr(t);null!==n;n=Jr(n))for(let t=Be;t<n.length;t++){const e=n[t];if(1024&e[2]){const t=e[1];qs(t,e,t.template,e[8])}else e[5]>0&&vo(e)}const e=t[1].components;if(null!==e)for(let n=0;n<e.length;n++){const i=on(e[n],t);cn(i)&&i[5]>0&&vo(i)}}function bo(t,e){const n=on(e,t),i=n[1];!function(t,e){for(let n=e.length;n<t.blueprint.length;n++)e.push(t.blueprint[n])}(i,n),Qs(i,n,n[8])}function Ao(t,e){return t[13]?t[14][4]=e:t[13]=e,t[14]=e,e}function xo(t){for(;t;){t[2]|=64;const e=Yr(t);if(0!=(512&t[2])&&!e)return t;t=e}return null}function wo(t,e,n){const i=e[10];i.begin&&i.begin();try{qs(t,e,t.template,n)}catch(r){throw Mo(e,r),r}finally{i.end&&i.end()}}function _o(t){!function(t){for(let e=0;e<t.components.length;e++){const n=t.components[e],i=an(n),r=i[1];Xs(r,i,r.template,n)}}(t[8])}function So(t,e,n){Ln(0),e(t,n)}const Eo=(()=>Promise.resolve(null))();function Co(t){return t[7]||(t[7]=[])}function Io(t){return t.cleanup||(t.cleanup=[])}function To(t,e,n){return(null===t||Ue(t))&&(n=function(t){for(;Array.isArray(t);){if("object"==typeof t[1])return t;t=t[0]}return null}(n[e.index])),n[11]}function Mo(t,e){const n=t[9],i=n?n.get(Vr,null):null;i&&i.handleError(e)}function ko(t,e,n,i,r){for(let s=0;s<n.length;){const o=n[s++],a=n[s++],l=e[o],c=t.data[o];null!==c.setInput?c.setInput(l,r,i,a):l[a]=r}}function Ro(t,e,n){const i=en(e,t);!function(t,e,n){Je(t)?t.setValue(e,n):e.textContent=n}(t[11],i,n)}function No(t,e,n){let i=n?t.styles:null,r=n?t.classes:null,s=0;if(null!==e)for(let o=0;o<e.length;o++){const t=e[o];"number"==typeof t?s=t:1==s?r=Ot(r,t):2==s&&(i=Ot(i,t+": "+e[++o]+";"))}n?t.styles=i:t.stylesWithoutHost=i,n?t.classes=r:t.classesWithoutHost=r}const Lo=new Ri("INJECTOR",-1);class Do{get(t,e=Hi){if(e===Hi){const e=new Error(`NullInjectorError: No provider for ${Bt(t)}!`);throw e.name="NullInjectorError",e}return e}}const Bo=new Ri("Set Injector scope."),Oo={},Po={},Fo=[];let $o;function zo(){return void 0===$o&&($o=new Do),$o}function Uo(t,e=null,n=null,i){return new Ho(t,n,e||zo(),i)}class Ho{constructor(t,e,n,i=null){this.parent=n,this.records=new Map,this.injectorDefTypes=new Set,this.onDestroy=new Set,this._destroyed=!1;const r=[];e&&Bi(e,n=>this.processProvider(n,t,e)),Bi([t],t=>this.processInjectorType(t,[],r)),this.records.set(Lo,Wo(void 0,this));const s=this.records.get(Bo);this.scope=null!=s?s.value:null,this.source=i||("object"==typeof t?null:Bt(t))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{this.onDestroy.forEach(t=>t.ngOnDestroy())}finally{this.records.clear(),this.onDestroy.clear(),this.injectorDefTypes.clear()}}get(t,e=Hi,n=ee.Default){this.assertNotDestroyed();const i=Qi(this);try{if(!(n&ee.SkipSelf)){let e=this.records.get(t);if(void 0===e){const n=("function"==typeof(r=t)||"object"==typeof r&&r instanceof Ri)&&qt(t);e=n&&this.injectableDefInScope(n)?Wo(Vo(t),Oo):null,this.records.set(t,e)}if(null!=e)return this.hydrate(t,e)}return(n&ee.Self?zo():this.parent).get(t,e=n&ee.Optional&&e===Hi?null:e)}catch(s){if("NullInjectorError"===s.name){if((s.ngTempTokenPath=s.ngTempTokenPath||[]).unshift(Bt(t)),i)throw s;return function(t,e,n,i){const r=t.ngTempTokenPath;throw e[Gi]&&r.unshift(e[Gi]),t.message=function(t,e,n,i=null){t=t&&"\n"===t.charAt(0)&&"\u0275"==t.charAt(1)?t.substr(2):t;let r=Bt(e);if(Array.isArray(e))r=e.map(Bt).join(" -> ");else if("object"==typeof e){let t=[];for(let n in e)if(e.hasOwnProperty(n)){let i=e[n];t.push(n+":"+("string"==typeof i?JSON.stringify(i):Bt(i)))}r=`{${t.join(", ")}}`}return`${n}${i?"("+i+")":""}[${r}]: ${t.replace(Vi,"\n  ")}`}("\n"+t.message,r,n,i),t.ngTokenPath=r,t.ngTempTokenPath=null,t}(s,t,"R3InjectorError",this.source)}throw s}finally{Qi(i)}var r}_resolveInjectorDefTypes(){this.injectorDefTypes.forEach(t=>this.get(t))}toString(){const t=[];return this.records.forEach((e,n)=>t.push(Bt(n))),`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Error("Injector has already been destroyed.")}processInjectorType(t,e,n){if(!(t=$t(t)))return!1;let i=Yt(t);const r=null==i&&t.ngModule||void 0,s=void 0===r?t:r,o=-1!==n.indexOf(s);if(void 0!==r&&(i=Yt(r)),null==i)return!1;if(null!=i.imports&&!o){let t;n.push(s);try{Bi(i.imports,i=>{this.processInjectorType(i,e,n)&&(void 0===t&&(t=[]),t.push(i))})}finally{}if(void 0!==t)for(let e=0;e<t.length;e++){const{ngModule:n,providers:i}=t[e];Bi(i,t=>this.processProvider(t,n,i||Fo))}}this.injectorDefTypes.add(s);const a=He(s)||(()=>new s);this.records.set(s,Wo(a,Oo));const l=i.providers;if(null!=l&&!o){const e=t;Bi(l,t=>this.processProvider(t,e,l))}return void 0!==r&&void 0!==t.providers}processProvider(t,e,n){let i=Qo(t=$t(t))?t:$t(t&&t.provide);const r=function(t,e,n){return jo(t)?Wo(void 0,t.useValue):Wo(Go(t),Oo)}(t);if(Qo(t)||!0!==t.multi)this.records.get(i);else{let e=this.records.get(i);e||(e=Wo(void 0,Oo,!0),e.factory=()=>Ki(e.multi),this.records.set(i,e)),i=t,e.multi.push(t)}this.records.set(i,r)}hydrate(t,e){var n;return e.value===Oo&&(e.value=Po,e.value=e.factory()),"object"==typeof e.value&&e.value&&null!==(n=e.value)&&"object"==typeof n&&"function"==typeof n.ngOnDestroy&&this.onDestroy.add(e.value),e.value}injectableDefInScope(t){return!!t.providedIn&&("string"==typeof t.providedIn?"any"===t.providedIn||t.providedIn===this.scope:this.injectorDefTypes.has(t.providedIn))}}function Vo(t){const e=qt(t),n=null!==e?e.factory:He(t);if(null!==n)return n;if(t instanceof Ri)throw new Error(`Token ${Bt(t)} is missing a \u0275prov definition.`);if(t instanceof Function)return function(t){const e=t.length;if(e>0){const n=Fi(e,"?");throw new Error(`Can't resolve all parameters for ${Bt(t)}: (${n.join(", ")}).`)}const n=function(t){const e=t&&(t[Kt]||t[Zt]);if(e){const n=function(t){if(t.hasOwnProperty("name"))return t.name;const e=(""+t).match(/^function\s*([^\s(]+)/);return null===e?"":e[1]}(t);return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`),e}return null}(t);return null!==n?()=>n.factory(t):()=>new t}(t);throw new Error("unreachable")}function Go(t,e,n){let i;if(Qo(t)){const e=$t(t);return He(e)||Vo(e)}if(jo(t))i=()=>$t(t.useValue);else if((r=t)&&r.useFactory)i=()=>t.useFactory(...Ki(t.deps||[]));else if(function(t){return!(!t||!t.useExisting)}(t))i=()=>Xi($t(t.useExisting));else{const e=$t(t&&(t.useClass||t.provide));if(!function(t){return!!t.deps}(t))return He(e)||Vo(e);i=()=>new e(...Ki(t.deps))}var r;return i}function Wo(t,e,n=!1){return{factory:t,value:e,multi:n?[]:void 0}}function jo(t){return null!==t&&"object"==typeof t&&Wi in t}function Qo(t){return"function"==typeof t}const qo=function(t,e,n){return function(t,e=null,n=null,i){const r=Uo(t,e,n,i);return r._resolveInjectorDefTypes(),r}({name:n},e,t,n)};let Xo=(()=>{class t{static create(t,e){return Array.isArray(t)?qo(t,e,""):qo(t.providers,t.parent,t.name||"")}}return t.THROW_IF_NOT_FOUND=Hi,t.NULL=new Do,t.\u0275prov=Wt({token:t,providedIn:"any",factory:()=>Xi(Lo)}),t.__NG_ELEMENT_ID__=-1,t})();function Yo(t,e){Wn(an(t)[1],vn())}function Ko(t){let e=Object.getPrototypeOf(t.type.prototype).constructor,n=!0;const i=[t];for(;e;){let r;if(Ue(t))r=e.\u0275cmp||e.\u0275dir;else{if(e.\u0275cmp)throw new Error("Directives cannot inherit Components");r=e.\u0275dir}if(r){if(n){i.push(r);const e=t;e.inputs=Jo(t.inputs),e.declaredInputs=Jo(t.declaredInputs),e.outputs=Jo(t.outputs);const n=r.hostBindings;n&&ea(t,n);const s=r.viewQuery,o=r.contentQueries;if(s&&Zo(t,s),o&&ta(t,o),Dt(t.inputs,r.inputs),Dt(t.declaredInputs,r.declaredInputs),Dt(t.outputs,r.outputs),Ue(r)&&r.data.animation){const e=t.data;e.animation=(e.animation||[]).concat(r.data.animation)}}const e=r.features;if(e)for(let i=0;i<e.length;i++){const r=e[i];r&&r.ngInherit&&r(t),r===Ko&&(n=!1)}}e=Object.getPrototypeOf(e)}!function(t){let e=0,n=null;for(let i=t.length-1;i>=0;i--){const r=t[i];r.hostVars=e+=r.hostVars,r.hostAttrs=ni(r.hostAttrs,n=ni(n,r.hostAttrs))}}(i)}function Jo(t){return t===pe?{}:t===me?[]:t}function Zo(t,e){const n=t.viewQuery;t.viewQuery=n?(t,i)=>{e(t,i),n(t,i)}:e}function ta(t,e){const n=t.contentQueries;t.contentQueries=n?(t,i,r)=>{e(t,i,r),n(t,i,r)}:e}function ea(t,e){const n=t.hostBindings;t.hostBindings=n?(t,i)=>{e(t,i),n(t,i)}:e}let na=null;function ia(){if(!na){const t=de.Symbol;if(t&&t.iterator)na=t.iterator;else{const t=Object.getOwnPropertyNames(Map.prototype);for(let e=0;e<t.length;++e){const n=t[e];"entries"!==n&&"size"!==n&&Map.prototype[n]===Map.prototype.entries&&(na=n)}}}return na}class ra{constructor(t){this.wrapped=t}static wrap(t){return new ra(t)}static unwrap(t){return ra.isWrapped(t)?t.wrapped:t}static isWrapped(t){return t instanceof ra}}function sa(t){return!!oa(t)&&(Array.isArray(t)||!(t instanceof Map)&&ia()in t)}function oa(t){return null!==t&&("function"==typeof t||"object"==typeof t)}function aa(t,e,n){return t[e]=n}function la(t,e,n){return!Object.is(t[e],n)&&(t[e]=n,!0)}function ca(t,e,n,i){const r=la(t,e,n);return la(t,e+1,i)||r}function ua(t,e,n,i){const r=mn();return la(r,In(),e)&&(gn(),function(t,e,n,i,r,s){const o=nn(t,e);!function(t,e,n,i,r,s,o){if(null==s)Je(t)?t.removeAttribute(e,r,n):e.removeAttribute(r);else{const a=null==o?Ht(s):o(s,i||"",r);Je(t)?t.setAttribute(e,r,a,n):n?e.setAttributeNS(n,r,a):e.setAttribute(r,a)}}(e[11],o,s,t.value,n,i,r)}(Gn(),r,t,e,n,i)),ua}function ha(t,e,n,i,r,s,o,a){const l=mn(),c=gn(),u=t+De,h=c.firstCreatePass?function(t,e,n,i,r,s,o,a,l){const c=e.consts,u=Ws(e,t,4,o||null,un(c,a));so(e,n,u,un(c,l)),Wn(e,u);const h=u.tViews=eo(2,u,i,r,s,e.directiveRegistry,e.pipeRegistry,null,e.schemas,c);return null!==e.queries&&(e.queries.template(e,u),h.queries=e.queries.embeddedTView(u)),u}(u,c,l,e,n,i,r,s,o):c.data[u];An(h,!1);const d=l[11].createComment("");ps(c,l,d,h),Gr(d,l),Ao(l,l[u]=go(d,l,d,h)),ze(h)&&Js(c,l,h),null!=o&&Zs(l,h,a)}function da(t){return sn(pn.lFrame.contextLView,De+t)}function pa(t,e=ee.Default){const n=mn();return null===n?Xi(t,e):yi(vn(),n,$t(t),e)}function fa(t,e,n){const i=mn();return la(i,In(),e)&&ro(gn(),Gn(),i,t,e,i[11],n,!1),fa}function ma(t,e,n,i,r){const s=r?"class":"style";ko(t,n,e.inputs[s],s,i)}function ga(t,e,n,i){const r=mn(),s=gn(),o=De+t,a=r[11],l=r[o]=es(a,e,pn.lFrame.currentNamespace),c=s.firstCreatePass?function(t,e,n,i,r,s,o){const a=e.consts,l=Ws(e,t,2,r,un(a,s));return so(e,n,l,un(a,o)),null!==l.attrs&&No(l,l.attrs,!1),null!==l.mergedAttrs&&No(l,l.mergedAttrs,!0),null!==e.queries&&e.queries.elementStart(e,l),l}(o,s,r,0,e,n,i):s.data[o];An(c,!0);const u=c.mergedAttrs;null!==u&&Zn(a,l,u);const h=c.classes;null!==h&&xs(a,l,h);const d=c.styles;null!==d&&As(a,l,d),64!=(64&c.flags)&&ps(s,r,l,c),0===pn.lFrame.elementDepthCount&&Gr(l,r),pn.lFrame.elementDepthCount++,ze(c)&&(Js(s,r,c),Ks(s,c,r)),null!==i&&Zs(r,c)}function ya(){let t=vn();xn()?wn():(t=t.parent,An(t,!1));const e=t;pn.lFrame.elementDepthCount--;const n=gn();n.firstCreatePass&&(Wn(n,t),Fe(t)&&n.queries.elementEnd(t)),null!=e.classesWithoutHost&&function(t){return 0!=(16&t.flags)}(e)&&ma(n,e,mn(),e.classesWithoutHost,!0),null!=e.stylesWithoutHost&&function(t){return 0!=(32&t.flags)}(e)&&ma(n,e,mn(),e.stylesWithoutHost,!1)}function va(t,e,n,i){ga(t,e,n,i),ya()}function ba(t,e,n){const i=mn(),r=gn(),s=t+De,o=r.firstCreatePass?function(t,e,n,i,r){const s=e.consts,o=un(s,i),a=Ws(e,t,8,"ng-container",o);return null!==o&&No(a,o,!0),so(e,n,a,un(s,r)),null!==e.queries&&e.queries.elementStart(e,a),a}(s,r,i,e,n):r.data[s];An(o,!0);const a=i[s]=i[11].createComment("");ps(r,i,a,o),Gr(a,i),ze(o)&&(Js(r,i,o),Ks(r,o,i)),null!=n&&Zs(i,o)}function Aa(){let t=vn();const e=gn();xn()?wn():(t=t.parent,An(t,!1)),e.firstCreatePass&&(Wn(e,t),Fe(t)&&e.queries.elementEnd(t))}function xa(){return mn()}function wa(t){return!!t&&"function"==typeof t.then}function _a(t){return!!t&&"function"==typeof t.subscribe}const Sa=_a;function Ea(t,e,n=!1,i){const r=mn(),s=gn(),o=vn();return Ia(s,r,r[11],o,t,e,n,i),Ea}function Ca(t,e,n=!1,i){const r=vn(),s=mn(),o=gn();return Ia(o,s,To(Rn(o.data),r,s),r,t,e,n,i),Ca}function Ia(t,e,n,i,r,s,o=!1,a){const l=ze(i),c=t.firstCreatePass&&Io(t),u=Co(e);let h=!0;if(3&i.type){const d=nn(i,e),p=a?a(d):pe,f=p.target||d,m=u.length,g=a?t=>a(tn(t[i.index])).target:i.index;if(Je(n)){let o=null;if(!a&&l&&(o=function(t,e,n,i){const r=t.cleanup;if(null!=r)for(let s=0;s<r.length-1;s+=2){const t=r[s];if(t===n&&r[s+1]===i){const t=e[7],n=r[s+2];return t.length>n?t[n]:null}"string"==typeof t&&(s+=2)}return null}(t,e,r,i.index)),null!==o)(o.__ngLastListenerFn__||o).__ngNextListenerFn__=s,o.__ngLastListenerFn__=s,h=!1;else{s=Ma(i,e,0,s,!1);const t=n.listen(p.name||f,r,s);u.push(s,t),c&&c.push(r,g,m,m+1)}}else s=Ma(i,e,0,s,!0),f.addEventListener(r,s,o),u.push(s),c&&c.push(r,g,m,o)}else s=Ma(i,e,0,s,!1);const d=i.outputs;let p;if(h&&null!==d&&(p=d[r])){const t=p.length;if(t)for(let n=0;n<t;n+=2){const t=e[p[n]][p[n+1]].subscribe(s),o=u.length;u.push(s,t),c&&c.push(r,i.index,o,-(o+1))}}}function Ta(t,e,n,i){try{return!1!==n(i)}catch(r){return Mo(t,r),!1}}function Ma(t,e,n,i,r){return function n(s){if(s===Function)return i;const o=2&t.flags?on(t.index,e):e;0==(32&e[2])&&xo(o);let a=Ta(e,0,i,s),l=n.__ngNextListenerFn__;for(;l;)a=Ta(e,0,l,s)&&a,l=l.__ngNextListenerFn__;return r&&!1===a&&(s.preventDefault(),s.returnValue=!1),a}}function ka(t=1){return function(t){return(pn.lFrame.contextLView=function(t,e){for(;t>0;)e=e[15],t--;return e}(t,pn.lFrame.contextLView))[8]}(t)}function Ra(t,e){let n=null;const i=function(t){const e=t.attrs;if(null!=e){const t=e.indexOf(5);if(0==(1&t))return e[t+1]}return null}(t);for(let r=0;r<e.length;r++){const s=e[r];if("*"!==s){if(null===i?ks(t,s,!0):Rs(i,s))return r}else n=r}return n}function Na(t){const e=mn()[16][6];if(!e.projection){const n=e.projection=Fi(t?t.length:1,null),i=n.slice();let r=e.child;for(;null!==r;){const e=t?Ra(r,t):0;null!==e&&(i[e]?i[e].projectionNext=r:n[e]=r,i[e]=r),r=r.next}}}function La(t,e=0,n){const i=mn(),r=gn(),s=Ws(r,De+t,16,null,n||null);null===s.projection&&(s.projection=e),wn(),64!=(64&s.flags)&&function(t,e,n){bs(e[11],0,e,n,os(t,n,e),hs(n.parent||e[6],n,e))}(r,i,s)}function Da(t,e,n,i,r){const s=t[n+1],o=null===e;let a=i?Fs(s):zs(s),l=!1;for(;0!==a&&(!1===l||o);){const n=t[a+1];Ba(t[a],e)&&(l=!0,t[a+1]=i?Hs(n):$s(n)),a=i?Fs(n):zs(n)}l&&(t[n+1]=i?$s(s):Hs(s))}function Ba(t,e){return null===t||null==e||(Array.isArray(t)?t[1]:t)===e||!(!Array.isArray(t)||"string"!=typeof e)&&Ui(t,e)>=0}const Oa={textEnd:0,key:0,keyEnd:0,value:0,valueEnd:0};function Pa(t){return t.substring(Oa.key,Oa.keyEnd)}function Fa(t,e){const n=Oa.textEnd;return n===e?-1:(e=Oa.keyEnd=function(t,e,n){for(;e<n&&t.charCodeAt(e)>32;)e++;return e}(t,Oa.key=e,n),$a(t,e,n))}function $a(t,e,n){for(;e<n&&t.charCodeAt(e)<=32;)e++;return e}function za(t,e,n){return Va(t,e,n,!1),za}function Ua(t,e){return Va(t,e,null,!0),Ua}function Ha(t,e){for(let n=function(t){return function(t){Oa.key=0,Oa.keyEnd=0,Oa.value=0,Oa.valueEnd=0,Oa.textEnd=t.length}(t),Fa(t,$a(t,0,Oa.textEnd))}(e);n>=0;n=Fa(e,n))$i(t,Pa(e),!0)}function Va(t,e,n,i){const r=mn(),s=gn(),o=Tn(2);s.firstUpdatePass&&Wa(s,t,o,i),e!==Ds&&la(r,o,e)&&qa(s,s.data[Hn()],r,r[11],t,r[o+1]=function(t,e){return null==t||("string"==typeof e?t+=e:"object"==typeof t&&(t=Bt(dr(t)))),t}(e,n),i,o)}function Ga(t,e){return e>=t.expandoStartIndex}function Wa(t,e,n,i){const r=t.data;if(null===r[n+1]){const s=r[Hn()],o=Ga(t,n);Ka(s,i)&&null===e&&!o&&(e=!1),e=function(t,e,n,i){const r=Rn(t);let s=i?e.residualClasses:e.residualStyles;if(null===r)0===(i?e.classBindings:e.styleBindings)&&(n=Qa(n=ja(null,t,e,n,i),e.attrs,i),s=null);else{const o=e.directiveStylingLast;if(-1===o||t[o]!==r)if(n=ja(r,t,e,n,i),null===s){let n=function(t,e,n){const i=n?e.classBindings:e.styleBindings;if(0!==zs(i))return t[Fs(i)]}(t,e,i);void 0!==n&&Array.isArray(n)&&(n=ja(null,t,e,n[1],i),n=Qa(n,e.attrs,i),function(t,e,n,i){t[Fs(n?e.classBindings:e.styleBindings)]=i}(t,e,i,n))}else s=function(t,e,n){let i;const r=e.directiveEnd;for(let s=1+e.directiveStylingLast;s<r;s++)i=Qa(i,t[s].hostAttrs,n);return Qa(i,e.attrs,n)}(t,e,i)}return void 0!==s&&(i?e.residualClasses=s:e.residualStyles=s),n}(r,s,e,i),function(t,e,n,i,r,s){let o=s?e.classBindings:e.styleBindings,a=Fs(o),l=zs(o);t[i]=n;let c,u=!1;if(Array.isArray(n)){const t=n;c=t[1],(null===c||Ui(t,c)>0)&&(u=!0)}else c=n;if(r)if(0!==l){const e=Fs(t[a+1]);t[i+1]=Ps(e,a),0!==e&&(t[e+1]=Us(t[e+1],i)),t[a+1]=131071&t[a+1]|i<<17}else t[i+1]=Ps(a,0),0!==a&&(t[a+1]=Us(t[a+1],i)),a=i;else t[i+1]=Ps(l,0),0===a?a=i:t[l+1]=Us(t[l+1],i),l=i;u&&(t[i+1]=$s(t[i+1])),Da(t,c,i,!0),Da(t,c,i,!1),function(t,e,n,i,r){const s=r?t.residualClasses:t.residualStyles;null!=s&&"string"==typeof e&&Ui(s,e)>=0&&(n[i+1]=Hs(n[i+1]))}(e,c,t,i,s),o=Ps(a,l),s?e.classBindings=o:e.styleBindings=o}(r,s,e,n,o,i)}}function ja(t,e,n,i,r){let s=null;const o=n.directiveEnd;let a=n.directiveStylingLast;for(-1===a?a=n.directiveStart:a++;a<o&&(s=e[a],i=Qa(i,s.hostAttrs,r),s!==t);)a++;return null!==t&&(n.directiveStylingLast=a),i}function Qa(t,e,n){const i=n?1:2;let r=-1;if(null!==e)for(let s=0;s<e.length;s++){const o=e[s];"number"==typeof o?r=o:r===i&&(Array.isArray(t)||(t=void 0===t?[]:["",t]),$i(t,o,!!n||e[++s]))}return void 0===t?null:t}function qa(t,e,n,i,r,s,o,a){if(!(3&e.type))return;const l=t.data,c=l[a+1];Ya(1==(1&c)?Xa(l,e,n,r,zs(c),o):void 0)||(Ya(s)||2==(2&c)&&(s=Xa(l,null,n,r,a,o)),function(t,e,n,i,r){const s=Je(t);if(e)r?s?t.addClass(n,i):n.classList.add(i):s?t.removeClass(n,i):n.classList.remove(i);else{let e=-1===i.indexOf("-")?void 0:qr.DashCase;if(null==r)s?t.removeStyle(n,i,e):n.style.removeProperty(i);else{const o="string"==typeof r&&r.endsWith("!important");o&&(r=r.slice(0,-10),e|=qr.Important),s?t.setStyle(n,i,r,e):n.style.setProperty(i,r,o?"important":"")}}}(i,o,en(Hn(),n),r,s))}function Xa(t,e,n,i,r,s){const o=null===e;let a;for(;r>0;){const e=t[r],s=Array.isArray(e),l=s?e[1]:e,c=null===l;let u=n[r+1];u===Ds&&(u=c?fe:void 0);let h=c?zi(u,i):l===i?u:void 0;if(s&&!Ya(h)&&(h=zi(e,i)),Ya(h)&&(a=h,o))return a;const d=t[r+1];r=o?Fs(d):zs(d)}if(null!==e){let t=s?e.residualClasses:e.residualStyles;null!=t&&(a=zi(t,i))}return a}function Ya(t){return void 0!==t}function Ka(t,e){return 0!=(t.flags&(e?16:32))}function Ja(t,e=""){const n=mn(),i=gn(),r=t+De,s=i.firstCreatePass?Ws(i,r,1,e,null):i.data[r],o=n[r]=function(t,e){return Je(t)?t.createText(e):t.createTextNode(e)}(n[11],e);ps(i,n,o,s),An(s,!1)}function Za(t){return tl("",t,""),Za}function tl(t,e,n){const i=mn(),r=function(t,e,n,i){return la(t,In(),n)?e+Ht(n)+i:Ds}(i,t,e,n);return r!==Ds&&Ro(i,Hn(),r),tl}function el(t,e,n,i,r){const s=mn(),o=function(t,e,n,i,r,s){const o=ca(t,Cn(),n,r);return Tn(2),o?e+Ht(n)+i+Ht(r)+s:Ds}(s,t,e,n,i,r);return o!==Ds&&Ro(s,Hn(),o),el}function nl(t,e,n){const i=mn();if(la(i,In(),e)){const r=gn(),s=Gn();ro(r,s,i,t,e,To(Rn(r.data),s,i),n,!0)}return nl}const il=void 0;var rl=["en",[["a","p"],["AM","PM"],il],[["AM","PM"],il,il],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],il,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],il,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",il,"{1} 'at' {0}",il],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function(t){let e=Math.floor(Math.abs(t)),n=t.toString().replace(/^[^.]*\.?/,"").length;return 1===e&&0===n?1:5}];let sl={};function ol(t){const e=function(t){return t.toLowerCase().replace(/_/g,"-")}(t);let n=al(e);if(n)return n;const i=e.split("-")[0];if(n=al(i),n)return n;if("en"===i)return rl;throw new Error(`Missing locale data for the locale "${t}".`)}function al(t){return t in sl||(sl[t]=de.ng&&de.ng.common&&de.ng.common.locales&&de.ng.common.locales[t]),sl[t]}var ll=function(t){return t[t.LocaleId=0]="LocaleId",t[t.DayPeriodsFormat=1]="DayPeriodsFormat",t[t.DayPeriodsStandalone=2]="DayPeriodsStandalone",t[t.DaysFormat=3]="DaysFormat",t[t.DaysStandalone=4]="DaysStandalone",t[t.MonthsFormat=5]="MonthsFormat",t[t.MonthsStandalone=6]="MonthsStandalone",t[t.Eras=7]="Eras",t[t.FirstDayOfWeek=8]="FirstDayOfWeek",t[t.WeekendRange=9]="WeekendRange",t[t.DateFormat=10]="DateFormat",t[t.TimeFormat=11]="TimeFormat",t[t.DateTimeFormat=12]="DateTimeFormat",t[t.NumberSymbols=13]="NumberSymbols",t[t.NumberFormats=14]="NumberFormats",t[t.CurrencyCode=15]="CurrencyCode",t[t.CurrencySymbol=16]="CurrencySymbol",t[t.CurrencyName=17]="CurrencyName",t[t.Currencies=18]="Currencies",t[t.Directionality=19]="Directionality",t[t.PluralCase=20]="PluralCase",t[t.ExtraData=21]="ExtraData",t}({});const cl="en-US";let ul=cl;function hl(t){var e,n;n="Expected localeId to be defined",null==(e=t)&&function(t,e,n,i){throw new Error(`ASSERTION ERROR: ${t} [Expected=> null != ${e} <=Actual]`)}(n,e),"string"==typeof t&&(ul=t.toLowerCase().replace(/_/g,"-"))}function dl(t,e,n,i,r){if(t=$t(t),Array.isArray(t))for(let s=0;s<t.length;s++)dl(t[s],e,n,i,r);else{const s=gn(),o=mn();let a=Qo(t)?t:$t(t.provide),l=Go(t);const c=vn(),u=1048575&c.providerIndexes,h=c.directiveStart,d=c.providerIndexes>>20;if(Qo(t)||!t.multi){const i=new Jn(l,r,pa),p=ml(a,e,r?u:u+d,h);-1===p?(fi(ui(c,o),s,a),pl(s,t,e.length),e.push(a),c.directiveStart++,c.directiveEnd++,r&&(c.providerIndexes+=1048576),n.push(i),o.push(i)):(n[p]=i,o[p]=i)}else{const p=ml(a,e,u+d,h),f=ml(a,e,u,u+d),m=p>=0&&n[p],g=f>=0&&n[f];if(r&&!g||!r&&!m){fi(ui(c,o),s,a);const u=function(t,e,n,i,r){const s=new Jn(t,n,pa);return s.multi=[],s.index=e,s.componentProviders=0,fl(s,r,i&&!n),s}(r?yl:gl,n.length,r,i,l);!r&&g&&(n[f].providerFactory=u),pl(s,t,e.length,0),e.push(a),c.directiveStart++,c.directiveEnd++,r&&(c.providerIndexes+=1048576),n.push(u),o.push(u)}else pl(s,t,p>-1?p:f,fl(n[r?f:p],l,!r&&i));!r&&i&&g&&n[f].componentProviders++}}}function pl(t,e,n,i){const r=Qo(e);if(r||e.useClass){const s=(e.useClass||e).prototype.ngOnDestroy;if(s){const o=t.destroyHooks||(t.destroyHooks=[]);if(!r&&e.multi){const t=o.indexOf(n);-1===t?o.push(n,[i,s]):o[t+1].push(i,s)}else o.push(n,s)}}}function fl(t,e,n){return n&&t.componentProviders++,t.multi.push(e)-1}function ml(t,e,n,i){for(let r=n;r<i;r++)if(e[r]===t)return r;return-1}function gl(t,e,n,i){return vl(this.multi,[])}function yl(t,e,n,i){const r=this.multi;let s;if(this.providerFactory){const t=this.providerFactory.componentProviders,e=wi(n,n[1],this.providerFactory.index,i);s=e.slice(0,t),vl(r,s);for(let n=t;n<e.length;n++)s.push(e[n])}else s=[],vl(r,s);return s}function vl(t,e){for(let n=0;n<t.length;n++)e.push((0,t[n])());return e}function bl(t,e=[]){return n=>{n.providersResolver=(n,i)=>function(t,e,n){const i=gn();if(i.firstCreatePass){const r=Ue(t);dl(n,i.data,i.blueprint,r,!0),dl(e,i.data,i.blueprint,r,!1)}}(n,i?i(t):t,e)}}class Al{}class xl{resolveComponentFactory(t){throw function(t){const e=Error(`No component factory found for ${Bt(t)}. Did you add it to @NgModule.entryComponents?`);return e.ngComponent=t,e}(t)}}let wl=(()=>{class t{}return t.NULL=new xl,t})();function _l(...t){}function Sl(t,e){return new Cl(nn(t,e))}const El=function(){return Sl(vn(),mn())};let Cl=(()=>{class t{constructor(t){this.nativeElement=t}}return t.__NG_ELEMENT_ID__=El,t})();function Il(t){return t instanceof Cl?t.nativeElement:t}class Tl{}let Ml=(()=>{class t{}return t.__NG_ELEMENT_ID__=()=>kl(),t})();const kl=function(){const t=mn(),e=on(vn().index,t);return function(t){return t[11]}(Oe(e)?e:t)};let Rl=(()=>{class t{}return t.\u0275prov=Wt({token:t,providedIn:"root",factory:()=>null}),t})();class Nl{constructor(t){this.full=t,this.major=t.split(".")[0],this.minor=t.split(".")[1],this.patch=t.split(".").slice(2).join(".")}}const Ll=new Nl("11.2.14");class Dl{constructor(){}supports(t){return sa(t)}create(t){return new Ol(t)}}const Bl=(t,e)=>e;class Ol{constructor(t){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=t||Bl}forEachItem(t){let e;for(e=this._itHead;null!==e;e=e._next)t(e)}forEachOperation(t){let e=this._itHead,n=this._removalsHead,i=0,r=null;for(;e||n;){const s=!n||e&&e.currentIndex<zl(n,i,r)?e:n,o=zl(s,i,r),a=s.currentIndex;if(s===n)i--,n=n._nextRemoved;else if(e=e._next,null==s.previousIndex)i++;else{r||(r=[]);const t=o-i,e=a-i;if(t!=e){for(let n=0;n<t;n++){const i=n<r.length?r[n]:r[n]=0,s=i+n;e<=s&&s<t&&(r[n]=i+1)}r[s.previousIndex]=e-t}}o!==a&&t(s,o,a)}}forEachPreviousItem(t){let e;for(e=this._previousItHead;null!==e;e=e._nextPrevious)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachMovedItem(t){let e;for(e=this._movesHead;null!==e;e=e._nextMoved)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}forEachIdentityChange(t){let e;for(e=this._identityChangesHead;null!==e;e=e._nextIdentityChange)t(e)}diff(t){if(null==t&&(t=[]),!sa(t))throw new Error(`Error trying to diff '${Bt(t)}'. Only arrays and iterables are allowed`);return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e,n,i,r=this._itHead,s=!1;if(Array.isArray(t)){this.length=t.length;for(let e=0;e<this.length;e++)n=t[e],i=this._trackByFn(e,n),null!==r&&Object.is(r.trackById,i)?(s&&(r=this._verifyReinsertion(r,n,i,e)),Object.is(r.item,n)||this._addIdentityChange(r,n)):(r=this._mismatch(r,n,i,e),s=!0),r=r._next}else e=0,function(t,e){if(Array.isArray(t))for(let n=0;n<t.length;n++)e(t[n]);else{const n=t[ia()]();let i;for(;!(i=n.next()).done;)e(i.value)}}(t,t=>{i=this._trackByFn(e,t),null!==r&&Object.is(r.trackById,i)?(s&&(r=this._verifyReinsertion(r,t,i,e)),Object.is(r.item,t)||this._addIdentityChange(r,t)):(r=this._mismatch(r,t,i,e),s=!0),r=r._next,e++}),this.length=e;return this._truncate(r),this.collection=t,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let t;for(t=this._previousItHead=this._itHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._additionsHead;null!==t;t=t._nextAdded)t.previousIndex=t.currentIndex;for(this._additionsHead=this._additionsTail=null,t=this._movesHead;null!==t;t=t._nextMoved)t.previousIndex=t.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(t,e,n,i){let r;return null===t?r=this._itTail:(r=t._prev,this._remove(t)),null!==(t=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._reinsertAfter(t,r,i)):null!==(t=null===this._linkedRecords?null:this._linkedRecords.get(n,i))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._moveAfter(t,r,i)):t=this._addAfter(new Pl(e,n),r,i),t}_verifyReinsertion(t,e,n,i){let r=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null);return null!==r?t=this._reinsertAfter(r,t._prev,i):t.currentIndex!=i&&(t.currentIndex=i,this._addToMoves(t,i)),t}_truncate(t){for(;null!==t;){const e=t._next;this._addToRemovals(this._unlink(t)),t=e}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(t,e,n){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(t);const i=t._prevRemoved,r=t._nextRemoved;return null===i?this._removalsHead=r:i._nextRemoved=r,null===r?this._removalsTail=i:r._prevRemoved=i,this._insertAfter(t,e,n),this._addToMoves(t,n),t}_moveAfter(t,e,n){return this._unlink(t),this._insertAfter(t,e,n),this._addToMoves(t,n),t}_addAfter(t,e,n){return this._insertAfter(t,e,n),this._additionsTail=null===this._additionsTail?this._additionsHead=t:this._additionsTail._nextAdded=t,t}_insertAfter(t,e,n){const i=null===e?this._itHead:e._next;return t._next=i,t._prev=e,null===i?this._itTail=t:i._prev=t,null===e?this._itHead=t:e._next=t,null===this._linkedRecords&&(this._linkedRecords=new $l),this._linkedRecords.put(t),t.currentIndex=n,t}_remove(t){return this._addToRemovals(this._unlink(t))}_unlink(t){null!==this._linkedRecords&&this._linkedRecords.remove(t);const e=t._prev,n=t._next;return null===e?this._itHead=n:e._next=n,null===n?this._itTail=e:n._prev=e,t}_addToMoves(t,e){return t.previousIndex===e||(this._movesTail=null===this._movesTail?this._movesHead=t:this._movesTail._nextMoved=t),t}_addToRemovals(t){return null===this._unlinkedRecords&&(this._unlinkedRecords=new $l),this._unlinkedRecords.put(t),t.currentIndex=null,t._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=t,t._prevRemoved=null):(t._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=t),t}_addIdentityChange(t,e){return t.item=e,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=t:this._identityChangesTail._nextIdentityChange=t,t}}class Pl{constructor(t,e){this.item=t,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class Fl{constructor(){this._head=null,this._tail=null}add(t){null===this._head?(this._head=this._tail=t,t._nextDup=null,t._prevDup=null):(this._tail._nextDup=t,t._prevDup=this._tail,t._nextDup=null,this._tail=t)}get(t,e){let n;for(n=this._head;null!==n;n=n._nextDup)if((null===e||e<=n.currentIndex)&&Object.is(n.trackById,t))return n;return null}remove(t){const e=t._prevDup,n=t._nextDup;return null===e?this._head=n:e._nextDup=n,null===n?this._tail=e:n._prevDup=e,null===this._head}}class $l{constructor(){this.map=new Map}put(t){const e=t.trackById;let n=this.map.get(e);n||(n=new Fl,this.map.set(e,n)),n.add(t)}get(t,e){const n=this.map.get(t);return n?n.get(t,e):null}remove(t){const e=t.trackById;return this.map.get(e).remove(t)&&this.map.delete(e),t}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function zl(t,e,n){const i=t.previousIndex;if(null===i)return i;let r=0;return n&&i<n.length&&(r=n[i]),i+e+r}class Ul{constructor(){}supports(t){return t instanceof Map||oa(t)}create(){return new Hl}}class Hl{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(t){let e;for(e=this._mapHead;null!==e;e=e._next)t(e)}forEachPreviousItem(t){let e;for(e=this._previousMapHead;null!==e;e=e._nextPrevious)t(e)}forEachChangedItem(t){let e;for(e=this._changesHead;null!==e;e=e._nextChanged)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}diff(t){if(t){if(!(t instanceof Map||oa(t)))throw new Error(`Error trying to diff '${Bt(t)}'. Only maps and objects are allowed`)}else t=new Map;return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e=this._mapHead;if(this._appendAfter=null,this._forEach(t,(t,n)=>{if(e&&e.key===n)this._maybeAddToChanges(e,t),this._appendAfter=e,e=e._next;else{const i=this._getOrCreateRecordForKey(n,t);e=this._insertBeforeOrAppend(e,i)}}),e){e._prev&&(e._prev._next=null),this._removalsHead=e;for(let t=e;null!==t;t=t._nextRemoved)t===this._mapHead&&(this._mapHead=null),this._records.delete(t.key),t._nextRemoved=t._next,t.previousValue=t.currentValue,t.currentValue=null,t._prev=null,t._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(t,e){if(t){const n=t._prev;return e._next=t,e._prev=n,t._prev=e,n&&(n._next=e),t===this._mapHead&&(this._mapHead=e),this._appendAfter=t,t}return this._appendAfter?(this._appendAfter._next=e,e._prev=this._appendAfter):this._mapHead=e,this._appendAfter=e,null}_getOrCreateRecordForKey(t,e){if(this._records.has(t)){const n=this._records.get(t);this._maybeAddToChanges(n,e);const i=n._prev,r=n._next;return i&&(i._next=r),r&&(r._prev=i),n._next=null,n._prev=null,n}const n=new Vl(t);return this._records.set(t,n),n.currentValue=e,this._addToAdditions(n),n}_reset(){if(this.isDirty){let t;for(this._previousMapHead=this._mapHead,t=this._previousMapHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._changesHead;null!==t;t=t._nextChanged)t.previousValue=t.currentValue;for(t=this._additionsHead;null!=t;t=t._nextAdded)t.previousValue=t.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(t,e){Object.is(e,t.currentValue)||(t.previousValue=t.currentValue,t.currentValue=e,this._addToChanges(t))}_addToAdditions(t){null===this._additionsHead?this._additionsHead=this._additionsTail=t:(this._additionsTail._nextAdded=t,this._additionsTail=t)}_addToChanges(t){null===this._changesHead?this._changesHead=this._changesTail=t:(this._changesTail._nextChanged=t,this._changesTail=t)}_forEach(t,e){t instanceof Map?t.forEach(e):Object.keys(t).forEach(n=>e(t[n],n))}}class Vl{constructor(t){this.key=t,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function Gl(){return new Wl([new Dl])}let Wl=(()=>{class t{constructor(t){this.factories=t}static create(e,n){if(null!=n){const t=n.factories.slice();e=e.concat(t)}return new t(e)}static extend(e){return{provide:t,useFactory:n=>t.create(e,n||Gl()),deps:[[t,new er,new tr]]}}find(t){const e=this.factories.find(e=>e.supports(t));if(null!=e)return e;throw new Error(`Cannot find a differ supporting object '${t}' of type '${n=t,n.name||typeof n}'`);var n}}return t.\u0275prov=Wt({token:t,providedIn:"root",factory:Gl}),t})();function jl(){return new Ql([new Ul])}let Ql=(()=>{class t{constructor(t){this.factories=t}static create(e,n){if(n){const t=n.factories.slice();e=e.concat(t)}return new t(e)}static extend(e){return{provide:t,useFactory:n=>t.create(e,n||jl()),deps:[[t,new er,new tr]]}}find(t){const e=this.factories.find(e=>e.supports(t));if(e)return e;throw new Error(`Cannot find a differ supporting object '${t}'`)}}return t.\u0275prov=Wt({token:t,providedIn:"root",factory:jl}),t})();function ql(t,e,n,i,r=!1){for(;null!==n;){const s=e[n.index];if(null!==s&&i.push(tn(s)),Pe(s))for(let t=Be;t<s.length;t++){const e=s[t],n=e[1].firstChild;null!==n&&ql(e[1],e,n,i)}const o=n.type;if(8&o)ql(t,e,n.child,i);else if(32&o){const t=Xr(n,e);let r;for(;r=t();)i.push(r)}else if(16&o){const t=ms(e,n);if(Array.isArray(t))i.push(...t);else{const n=Yr(e[16]);ql(n[1],n,t,i,!0)}}n=r?n.projectionNext:n.next}return i}class Xl{constructor(t,e){this._lView=t,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const t=this._lView,e=t[1];return ql(e,t,e.firstChild,[])}get context(){return this._lView[8]}get destroyed(){return 256==(256&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const t=this._lView[3];if(Pe(t)){const e=t[8],n=e?e.indexOf(this):-1;n>-1&&(is(t,n),Pi(e,n))}this._attachedToViewContainer=!1}rs(this._lView[1],this._lView)}onDestroy(t){no(this._lView[1],this._lView,null,t)}markForCheck(){xo(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-129}reattach(){this._lView[2]|=128}detectChanges(){wo(this._lView[1],this._lView,this.context)}checkNoChanges(){!function(t,e,n){Sn(!0);try{wo(t,e,n)}finally{Sn(!1)}}(this._lView[1],this._lView,this.context)}attachToViewContainerRef(){if(this._appRef)throw new Error("This view is already attached directly to the ApplicationRef!");this._attachedToViewContainer=!0}detachFromAppRef(){var t;this._appRef=null,vs(this._lView[1],t=this._lView,t[11],2,null,null)}attachToAppRef(t){if(this._attachedToViewContainer)throw new Error("This view is already attached to a ViewContainer!");this._appRef=t}}class Yl extends Xl{constructor(t){super(t),this._view=t}detectChanges(){_o(this._view)}checkNoChanges(){!function(t){Sn(!0);try{_o(t)}finally{Sn(!1)}}(this._view)}get context(){return null}}const Kl=Zl;let Jl=(()=>{class t{}return t.__NG_ELEMENT_ID__=Kl,t.__ChangeDetectorRef__=!0,t})();function Zl(t=!1){return function(t,e,n){if(!n&&$e(t)){const n=on(t.index,e);return new Xl(n,n)}return 47&t.type?new Xl(e[16],e):null}(vn(),mn(),t)}const tc=[new Ul],ec=new Wl([new Dl]),nc=new Ql(tc),ic=function(){return ac(vn(),mn())};let rc=(()=>{class t{}return t.__NG_ELEMENT_ID__=ic,t})();const sc=rc,oc=class extends sc{constructor(t,e,n){super(),this._declarationLView=t,this._declarationTContainer=e,this.elementRef=n}createEmbeddedView(t){const e=this._declarationTContainer.tViews,n=Gs(this._declarationLView,e,t,16,null,e.declTNode,null,null,null,null);n[17]=this._declarationLView[this._declarationTContainer.index];const i=this._declarationLView[19];return null!==i&&(n[19]=i.createEmbeddedView(e)),Qs(e,n,t),new Xl(n)}};function ac(t,e){return 4&t.type?new oc(e,t,Sl(t,e)):null}class lc{}class cc{}const uc=function(){return gc(vn(),mn())};let hc=(()=>{class t{}return t.__NG_ELEMENT_ID__=uc,t})();const dc=hc,pc=class extends dc{constructor(t,e,n){super(),this._lContainer=t,this._hostTNode=e,this._hostLView=n}get element(){return Sl(this._hostTNode,this._hostLView)}get injector(){return new Ei(this._hostTNode,this._hostLView)}get parentInjector(){const t=pi(this._hostTNode,this._hostLView);if(ri(t)){const e=oi(t,this._hostLView),n=si(t);return new Ei(e[1].data[n+8],e)}return new Ei(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){const e=fc(this._lContainer);return null!==e&&e[t]||null}get length(){return this._lContainer.length-Be}createEmbeddedView(t,e,n){const i=t.createEmbeddedView(e||{});return this.insert(i,n),i}createComponent(t,e,n,i,r){const s=n||this.parentInjector;if(!r&&null==t.ngModule&&s){const t=s.get(lc,null);t&&(r=t)}const o=t.create(s,i,void 0,r);return this.insert(o.hostView,e),o}insert(t,e){const n=t._lView,i=n[1];if(Pe(n[3])){const e=this.indexOf(t);if(-1!==e)this.detach(e);else{const e=n[3],i=new pc(e,e[6],e[3]);i.detach(i.indexOf(t))}}const r=this._adjustIndex(e),s=this._lContainer;!function(t,e,n,i){const r=Be+i,s=n.length;i>0&&(n[r-1][4]=e),i<s-Be?(e[4]=n[r],Oi(n,Be+i,e)):(n.push(e),e[4]=null),e[3]=n;const o=e[17];null!==o&&n!==o&&function(t,e){const n=t[9];e[16]!==e[3][3][16]&&(t[2]=!0),null===n?t[9]=[e]:n.push(e)}(o,e);const a=e[19];null!==a&&a.insertView(t),e[2]|=128}(i,n,s,r);const o=gs(r,s),a=n[11],l=us(a,s[7]);return null!==l&&function(t,e,n,i,r,s){i[0]=r,i[6]=e,vs(t,i,n,1,r,s)}(i,s[6],a,n,l,o),t.attachToViewContainerRef(),Oi(mc(s),r,t),t}move(t,e){return this.insert(t,e)}indexOf(t){const e=fc(this._lContainer);return null!==e?e.indexOf(t):-1}remove(t){const e=this._adjustIndex(t,-1),n=is(this._lContainer,e);n&&(Pi(mc(this._lContainer),e),rs(n[1],n))}detach(t){const e=this._adjustIndex(t,-1),n=is(this._lContainer,e);return n&&null!=Pi(mc(this._lContainer),e)?new Xl(n):null}_adjustIndex(t,e=0){return null==t?this.length+e:t}};function fc(t){return t[8]}function mc(t){return t[8]||(t[8]=[])}function gc(t,e){let n;const i=e[t.index];if(Pe(i))n=i;else{let r;if(8&t.type)r=tn(i);else{const n=e[11];r=n.createComment("");const i=nn(t,e);as(n,us(n,i),r,function(t,e){return Je(t)?t.nextSibling(e):e.nextSibling}(n,i),!1)}e[t.index]=n=go(i,e,r,t),Ao(e,n)}return new pc(n,t,e)}const yc={};class vc extends wl{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){const e=Ne(t);return new xc(e,this.ngModule)}}function bc(t){const e=[];for(let n in t)t.hasOwnProperty(n)&&e.push({propName:t[n],templateName:n});return e}const Ac=new Ri("SCHEDULER_TOKEN",{providedIn:"root",factory:()=>Wr});class xc extends Al{constructor(t,e){super(),this.componentDef=t,this.ngModule=e,this.componentType=t.type,this.selector=t.selectors.map(Ls).join(","),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!e}get inputs(){return bc(this.componentDef.inputs)}get outputs(){return bc(this.componentDef.outputs)}create(t,e,n,i){const r=(i=i||this.ngModule)?function(t,e){return{get:(n,i,r)=>{const s=t.get(n,yc,r);return s!==yc||i===yc?s:e.get(n,i,r)}}}(t,i.injector):t,s=r.get(Tl,Ze),o=r.get(Rl,null),a=s.createRenderer(null,this.componentDef),l=this.componentDef.selectors[0][0]||"div",c=n?function(t,e,n){if(Je(t))return t.selectRootElement(e,n===ae.ShadowDom);let i="string"==typeof e?t.querySelector(e):e;return i.textContent="",i}(a,n,this.componentDef.encapsulation):es(s.createRenderer(null,this.componentDef),l,function(t){const e=t.toLowerCase();return"svg"===e?Xe:"math"===e?"http://www.w3.org/1998/MathML/":null}(l)),u=this.componentDef.onPush?576:528,h={components:[],scheduler:Wr,clean:Eo,playerHandler:null,flags:0},d=eo(0,null,null,1,0,null,null,null,null,null),p=Gs(null,d,h,u,null,null,s,a,o,r);let f,m;On(p);try{const t=function(t,e,n,i,r,s){const o=n[1];n[20]=t;const a=Ws(o,20,2,"#host",null),l=a.mergedAttrs=e.hostAttrs;null!==l&&(No(a,l,!0),null!==t&&(Zn(r,t,l),null!==a.classes&&xs(r,t,a.classes),null!==a.styles&&As(r,t,a.styles)));const c=i.createRenderer(t,e),u=Gs(n,to(e),null,e.onPush?64:16,n[20],a,i,c,null,null);return o.firstCreatePass&&(fi(ui(a,n),o,e.type),lo(o,a),uo(a,n.length,1)),Ao(n,u),n[20]=u}(c,this.componentDef,p,s,a);if(c)if(n)Zn(a,c,["ng-version",Ll.full]);else{const{attrs:t,classes:e}=function(t){const e=[],n=[];let i=1,r=2;for(;i<t.length;){let s=t[i];if("string"==typeof s)2===r?""!==s&&e.push(s,t[++i]):8===r&&n.push(s);else{if(!Ts(r))break;r=s}i++}return{attrs:e,classes:n}}(this.componentDef.selectors[0]);t&&Zn(a,c,t),e&&e.length>0&&xs(a,c,e.join(" "))}if(m=rn(d,De),void 0!==e){const t=m.projection=[];for(let n=0;n<this.ngContentSelectors.length;n++){const i=e[n];t.push(null!=i?Array.from(i):null)}}f=function(t,e,n,i,r){const s=n[1],o=function(t,e,n){const i=vn();t.firstCreatePass&&(n.providersResolver&&n.providersResolver(n),ho(t,i,e,js(t,e,1,null),n));const r=wi(e,t,i.directiveStart,i);Gr(r,e);const s=nn(i,e);return s&&Gr(s,e),r}(s,n,e);if(i.components.push(o),t[8]=o,r&&r.forEach(t=>t(o,e)),e.contentQueries){const t=vn();e.contentQueries(1,o,t.directiveStart)}const a=vn();return!s.firstCreatePass||null===e.hostBindings&&null===e.hostAttrs||(Vn(a.index),oo(n[1],a,0,a.directiveStart,a.directiveEnd,e),ao(e,o)),o}(t,this.componentDef,p,h,[Yo]),Qs(d,p,null)}finally{Un()}return new wc(this.componentType,f,Sl(m,p),p,m)}}class wc extends class{}{constructor(t,e,n,i,r){super(),this.location=n,this._rootLView=i,this._tNode=r,this.instance=e,this.hostView=this.changeDetectorRef=new Yl(i),this.componentType=t}get injector(){return new Ei(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}}const _c=new Map;class Sc extends lc{constructor(t,e){super(),this._parent=e,this._bootstrapComponents=[],this.injector=this,this.destroyCbs=[],this.componentFactoryResolver=new vc(this);const n=Le(t),i=t[Ae]||null;i&&hl(i),this._bootstrapComponents=Qr(n.bootstrap),this._r3Injector=Uo(t,e,[{provide:lc,useValue:this},{provide:wl,useValue:this.componentFactoryResolver}],Bt(t)),this._r3Injector._resolveInjectorDefTypes(),this.instance=this.get(t)}get(t,e=Xo.THROW_IF_NOT_FOUND,n=ee.Default){return t===Xo||t===lc||t===Lo?this:this._r3Injector.get(t,e,n)}destroy(){const t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(t=>t()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}}class Ec extends cc{constructor(t){super(),this.moduleType=t,null!==Le(t)&&function(t){const e=new Set;!function t(n){const i=Le(n,!0),r=i.id;null!==r&&(function(t,e,n){if(e&&e!==n)throw new Error(`Duplicate module registered for ${t} - ${Bt(e)} vs ${Bt(e.name)}`)}(r,_c.get(r),n),_c.set(r,n));const s=Qr(i.imports);for(const o of s)e.has(o)||(e.add(o),t(o))}(t)}(t)}create(t){return new Sc(this.moduleType,t)}}function Cc(t,e,n,i){return Tc(mn(),En(),t,e,n,i)}function Ic(t,e){const n=t[e];return n===Ds?void 0:n}function Tc(t,e,n,i,r,s){const o=e+n;return la(t,o,r)?aa(t,o+1,s?i.call(s,r):i(r)):Ic(t,o+1)}function Mc(t,e){const n=gn();let i;const r=t+De;n.firstCreatePass?(i=function(t,e){if(e)for(let n=e.length-1;n>=0;n--){const i=e[n];if(t===i.name)return i}throw new Ut("302",`The pipe '${t}' could not be found!`)}(e,n.pipeRegistry),n.data[r]=i,i.onDestroy&&(n.destroyHooks||(n.destroyHooks=[])).push(r,i.onDestroy)):i=n.data[r];const s=i.factory||(i.factory=He(i.type)),o=ie(pa);try{const t=li(!1),e=s();return li(t),function(t,e,n,i){n>=t.data.length&&(t.data[n]=null,t.blueprint[n]=null),e[n]=i}(n,mn(),r,e),e}finally{ie(o)}}function kc(t,e,n){const i=t+De,r=mn(),s=sn(r,i);return function(t,e){return ra.isWrapped(e)&&(e=ra.unwrap(e),t[Cn()]=Ds),e}(r,function(t,e){return t[1].data[e].pure}(r,i)?Tc(r,En(),e,s.transform,n,s):s.transform(n))}function Rc(t){return e=>{setTimeout(t,void 0,e)}}const Nc=class extends tt{constructor(t=!1){super(),this.__isAsync=t}emit(t){super.next(t)}subscribe(t,e,n){var i,r,s;let o=t,a=e||(()=>null),l=n;if(t&&"object"==typeof t){const e=t;o=null===(i=e.next)||void 0===i?void 0:i.bind(e),a=null===(r=e.error)||void 0===r?void 0:r.bind(e),l=null===(s=e.complete)||void 0===s?void 0:s.bind(e)}this.__isAsync&&(a=Rc(a),o&&(o=Rc(o)),l&&(l=Rc(l)));const c=super.subscribe({next:o,error:a,complete:l});return t instanceof H&&t.add(c),c}};function Lc(){return this._results[ia()]()}class Dc{constructor(t=!1){this._emitDistinctChangesOnly=t,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=ia(),n=Dc.prototype;n[e]||(n[e]=Lc)}get changes(){return this._changes||(this._changes=new Nc)}get(t){return this._results[t]}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,e){return this._results.reduce(t,e)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t,e){const n=this;n.dirty=!1;const i=Di(t);(this._changesDetected=!function(t,e,n){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++){let r=t[i],s=e[i];if(n&&(r=n(r),s=n(s)),s!==r)return!1}return!0}(n._results,i,e))&&(n._results=i,n.length=i.length,n.last=i[this.length-1],n.first=i[0])}notifyOnChanges(){!this._changes||!this._changesDetected&&this._emitDistinctChangesOnly||this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}class Bc{constructor(t){this.queryList=t,this.matches=null}clone(){return new Bc(this.queryList)}setDirty(){this.queryList.setDirty()}}class Oc{constructor(t=[]){this.queries=t}createEmbeddedView(t){const e=t.queries;if(null!==e){const n=null!==t.contentQueries?t.contentQueries[0]:e.length,i=[];for(let t=0;t<n;t++){const n=e.getByIndex(t);i.push(this.queries[n.indexInDeclarationView].clone())}return new Oc(i)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let e=0;e<this.queries.length;e++)null!==Yc(t,e).matches&&this.queries[e].setDirty()}}class Pc{constructor(t,e,n=null){this.predicate=t,this.flags=e,this.read=n}}class Fc{constructor(t=[]){this.queries=t}elementStart(t,e){for(let n=0;n<this.queries.length;n++)this.queries[n].elementStart(t,e)}elementEnd(t){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(t)}embeddedTView(t){let e=null;for(let n=0;n<this.length;n++){const i=null!==e?e.length:0,r=this.getByIndex(n).embeddedTView(t,i);r&&(r.indexInDeclarationView=n,null!==e?e.push(r):e=[r])}return null!==e?new Fc(e):null}template(t,e){for(let n=0;n<this.queries.length;n++)this.queries[n].template(t,e)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}}class $c{constructor(t,e=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(t,e){this.isApplyingToNode(e)&&this.matchTNode(t,e)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,e){this.elementStart(t,e)}embeddedTView(t,e){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,e),new $c(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let n=t.parent;for(;null!==n&&8&n.type&&n.index!==e;)n=n.parent;return e===(null!==n?n.index:-1)}return this._appliesToNextNode}matchTNode(t,e){const n=this.metadata.predicate;if(Array.isArray(n))for(let i=0;i<n.length;i++){const r=n[i];this.matchTNodeWithReadOption(t,e,zc(e,r)),this.matchTNodeWithReadOption(t,e,xi(e,t,r,!1,!1))}else n===rc?4&e.type&&this.matchTNodeWithReadOption(t,e,-1):this.matchTNodeWithReadOption(t,e,xi(e,t,n,!1,!1))}matchTNodeWithReadOption(t,e,n){if(null!==n){const i=this.metadata.read;if(null!==i)if(i===Cl||i===hc||i===rc&&4&e.type)this.addMatch(e.index,-2);else{const n=xi(e,t,i,!1,!1);null!==n&&this.addMatch(e.index,n)}else this.addMatch(e.index,n)}}addMatch(t,e){null===this.matches?this.matches=[t,e]:this.matches.push(t,e)}}function zc(t,e){const n=t.localNames;if(null!==n)for(let i=0;i<n.length;i+=2)if(n[i]===e)return n[i+1];return null}function Uc(t,e,n,i){return-1===n?function(t,e){return 11&t.type?Sl(t,e):4&t.type?ac(t,e):null}(e,t):-2===n?function(t,e,n){return n===Cl?Sl(e,t):n===rc?ac(e,t):n===hc?gc(e,t):void 0}(t,e,i):wi(t,t[1],n,e)}function Hc(t,e,n,i){const r=e[19].queries[i];if(null===r.matches){const i=t.data,s=n.matches,o=[];for(let t=0;t<s.length;t+=2){const r=s[t];o.push(r<0?null:Uc(e,i[r],s[t+1],n.metadata.read))}r.matches=o}return r.matches}function Vc(t,e,n,i){const r=t.queries.getByIndex(n),s=r.matches;if(null!==s){const o=Hc(t,e,r,n);for(let t=0;t<s.length;t+=2){const n=s[t];if(n>0)i.push(o[t/2]);else{const r=s[t+1],o=e[-n];for(let t=Be;t<o.length;t++){const e=o[t];e[17]===e[3]&&Vc(e[1],e,r,i)}if(null!==o[9]){const t=o[9];for(let e=0;e<t.length;e++){const n=t[e];Vc(n[1],n,r,i)}}}}}return i}function Gc(t){const e=mn(),n=gn(),i=Nn();Ln(i+1);const r=Yc(n,i);if(t.dirty&&ln(e)===(2==(2&r.metadata.flags))){if(null===r.matches)t.reset([]);else{const s=r.crossesNgTemplate?Vc(n,e,i,[]):Hc(n,e,r,i);t.reset(s,Il),t.notifyOnChanges()}return!0}return!1}function Wc(t,e,n){const i=gn();i.firstCreatePass&&(Xc(i,new Pc(t,e,n),-1),2==(2&e)&&(i.staticViewQueries=!0)),qc(i,mn(),e)}function jc(t,e,n,i){const r=gn();if(r.firstCreatePass){const s=vn();Xc(r,new Pc(e,n,i),s.index),function(t,e){const n=t.contentQueries||(t.contentQueries=[]);e!==(n.length?n[n.length-1]:-1)&&n.push(t.queries.length-1,e)}(r,t),2==(2&n)&&(r.staticContentQueries=!0)}qc(r,mn(),n)}function Qc(){return t=mn(),e=Nn(),t[19].queries[e].queryList;var t,e}function qc(t,e,n){const i=new Dc(4==(4&n));no(t,e,i,i.destroy),null===e[19]&&(e[19]=new Oc),e[19].queries.push(new Bc(i))}function Xc(t,e,n){null===t.queries&&(t.queries=new Fc),t.queries.track(new $c(e,n))}function Yc(t,e){return t.queries.getByIndex(e)}function Kc(t=ee.Default){const e=Zl(!0);if(null!=e||t&ee.Optional)return e;Gt("ChangeDetectorRef")}const Jc=new Ri("Application Initializer");let Zc=(()=>{class t{constructor(t){this.appInits=t,this.resolve=_l,this.reject=_l,this.initialized=!1,this.done=!1,this.donePromise=new Promise((t,e)=>{this.resolve=t,this.reject=e})}runInitializers(){if(this.initialized)return;const t=[],e=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let n=0;n<this.appInits.length;n++){const e=this.appInits[n]();wa(e)&&t.push(e)}Promise.all(t).then(()=>{e()}).catch(t=>{this.reject(t)}),0===t.length&&e(),this.initialized=!0}}return t.\u0275fac=function(e){return new(e||t)(Xi(Jc,8))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();const tu=new Ri("AppId"),eu={provide:tu,useFactory:function(){return`${nu()}${nu()}${nu()}`},deps:[]};function nu(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const iu=new Ri("Platform Initializer"),ru=new Ri("Platform ID"),su=new Ri("appBootstrapListener");let ou=(()=>{class t{log(t){console.log(t)}warn(t){console.warn(t)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();const au=new Ri("LocaleId"),lu=new Ri("DefaultCurrencyCode");class cu{constructor(t,e){this.ngModuleFactory=t,this.componentFactories=e}}const uu=function(t){return new Ec(t)},hu=uu,du=function(t){return Promise.resolve(uu(t))},pu=function(t){const e=uu(t),n=Qr(Le(t).declarations).reduce((t,e)=>{const n=Ne(e);return n&&t.push(new xc(n)),t},[]);return new cu(e,n)},fu=pu,mu=function(t){return Promise.resolve(pu(t))};let gu=(()=>{class t{constructor(){this.compileModuleSync=hu,this.compileModuleAsync=du,this.compileModuleAndAllComponentsSync=fu,this.compileModuleAndAllComponentsAsync=mu}clearCache(){}clearCacheFor(t){}getModuleId(t){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();const yu=new Ri("compilerOptions"),vu=(()=>Promise.resolve(0))();function bu(t){"undefined"==typeof Zone?vu.then(()=>{t&&t.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",t)}class Au{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:n=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new Nc(!1),this.onMicrotaskEmpty=new Nc(!1),this.onStable=new Nc(!1),this.onError=new Nc(!1),"undefined"==typeof Zone)throw new Error("In this configuration Angular requires Zone.js");Zone.assertZonePatched();const i=this;i._nesting=0,i._outer=i._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(i._inner=i._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(i._inner=i._inner.fork(Zone.longStackTraceZoneSpec)),i.shouldCoalesceEventChangeDetection=!n&&e,i.shouldCoalesceRunChangeDetection=n,i.lastRequestAnimationFrameId=-1,i.nativeRequestAnimationFrame=function(){let t=de.requestAnimationFrame,e=de.cancelAnimationFrame;if("undefined"!=typeof Zone&&t&&e){const n=t[Zone.__symbol__("OriginalDelegate")];n&&(t=n);const i=e[Zone.__symbol__("OriginalDelegate")];i&&(e=i)}return{nativeRequestAnimationFrame:t,nativeCancelAnimationFrame:e}}().nativeRequestAnimationFrame,function(t){const e=()=>{!function(t){-1===t.lastRequestAnimationFrameId&&(t.lastRequestAnimationFrameId=t.nativeRequestAnimationFrame.call(de,()=>{t.fakeTopEventTask||(t.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{t.lastRequestAnimationFrameId=-1,_u(t),wu(t)},void 0,()=>{},()=>{})),t.fakeTopEventTask.invoke()}),_u(t))}(t)};t._inner=t._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(n,i,r,s,o,a)=>{try{return Su(t),n.invokeTask(r,s,o,a)}finally{(t.shouldCoalesceEventChangeDetection&&"eventTask"===s.type||t.shouldCoalesceRunChangeDetection)&&e(),Eu(t)}},onInvoke:(n,i,r,s,o,a,l)=>{try{return Su(t),n.invoke(r,s,o,a,l)}finally{t.shouldCoalesceRunChangeDetection&&e(),Eu(t)}},onHasTask:(e,n,i,r)=>{e.hasTask(i,r),n===i&&("microTask"==r.change?(t._hasPendingMicrotasks=r.microTask,_u(t),wu(t)):"macroTask"==r.change&&(t.hasPendingMacrotasks=r.macroTask))},onHandleError:(e,n,i,r)=>(e.handleError(i,r),t.runOutsideAngular(()=>t.onError.emit(r)),!1)})}(i)}static isInAngularZone(){return!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!Au.isInAngularZone())throw new Error("Expected to be in Angular Zone, but it is not!")}static assertNotInAngularZone(){if(Au.isInAngularZone())throw new Error("Expected to not be in Angular Zone, but it is!")}run(t,e,n){return this._inner.run(t,e,n)}runTask(t,e,n,i){const r=this._inner,s=r.scheduleEventTask("NgZoneEvent: "+i,t,xu,_l,_l);try{return r.runTask(s,e,n)}finally{r.cancelTask(s)}}runGuarded(t,e,n){return this._inner.runGuarded(t,e,n)}runOutsideAngular(t){return this._outer.run(t)}}const xu={};function wu(t){if(0==t._nesting&&!t.hasPendingMicrotasks&&!t.isStable)try{t._nesting++,t.onMicrotaskEmpty.emit(null)}finally{if(t._nesting--,!t.hasPendingMicrotasks)try{t.runOutsideAngular(()=>t.onStable.emit(null))}finally{t.isStable=!0}}}function _u(t){t.hasPendingMicrotasks=!!(t._hasPendingMicrotasks||(t.shouldCoalesceEventChangeDetection||t.shouldCoalesceRunChangeDetection)&&-1!==t.lastRequestAnimationFrameId)}function Su(t){t._nesting++,t.isStable&&(t.isStable=!1,t.onUnstable.emit(null))}function Eu(t){t._nesting--,wu(t)}class Cu{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new Nc,this.onMicrotaskEmpty=new Nc,this.onStable=new Nc,this.onError=new Nc}run(t,e,n){return t.apply(e,n)}runGuarded(t,e,n){return t.apply(e,n)}runOutsideAngular(t){return t()}runTask(t,e,n,i){return t.apply(e,n)}}let Iu=(()=>{class t{constructor(t){this._ngZone=t,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,this._watchAngularEvents(),t.run(()=>{this.taskTrackingZone="undefined"==typeof Zone?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{Au.assertNotInAngularZone(),bu(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())bu(()=>{for(;0!==this._callbacks.length;){let t=this._callbacks.pop();clearTimeout(t.timeoutId),t.doneCb(this._didWork)}this._didWork=!1});else{let t=this.getPendingTasks();this._callbacks=this._callbacks.filter(e=>!e.updateCb||!e.updateCb(t)||(clearTimeout(e.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(t=>({source:t.source,creationLocation:t.creationLocation,data:t.data})):[]}addCallback(t,e,n){let i=-1;e&&e>0&&(i=setTimeout(()=>{this._callbacks=this._callbacks.filter(t=>t.timeoutId!==i),t(this._didWork,this.getPendingTasks())},e)),this._callbacks.push({doneCb:t,timeoutId:i,updateCb:n})}whenStable(t,e,n){if(n&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?');this.addCallback(t,e,n),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}findProviders(t,e,n){return[]}}return t.\u0275fac=function(e){return new(e||t)(Xi(Au))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})(),Tu=(()=>{class t{constructor(){this._applications=new Map,Ru.addToWindow(this)}registerApplication(t,e){this._applications.set(t,e)}unregisterApplication(t){this._applications.delete(t)}unregisterAllApplications(){this._applications.clear()}getTestability(t){return this._applications.get(t)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(t,e=!0){return Ru.findTestabilityInTree(this,t,e)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();class Mu{addToWindow(t){}findTestabilityInTree(t,e,n){return null}}let ku,Ru=new Mu,Nu=!0,Lu=!1;function Du(){return Lu=!0,Nu}const Bu=new Ri("AllowMultipleToken");class Ou{constructor(t,e){this.name=t,this.token=e}}function Pu(t,e,n=[]){const i=`Platform: ${e}`,r=new Ri(i);return(e=[])=>{let s=Fu();if(!s||s.injector.get(Bu,!1))if(t)t(n.concat(e).concat({provide:r,useValue:!0}));else{const t=n.concat(e).concat({provide:r,useValue:!0},{provide:Bo,useValue:"platform"});!function(t){if(ku&&!ku.destroyed&&!ku.injector.get(Bu,!1))throw new Error("There can be only one platform. Destroy the previous one to create a new one.");ku=t.get($u);const e=t.get(iu,null);e&&e.forEach(t=>t())}(Xo.create({providers:t,name:i}))}return function(t){const e=Fu();if(!e)throw new Error("No platform exists!");if(!e.injector.get(t,null))throw new Error("A platform with a different configuration has been created. Please destroy it first.");return e}(r)}}function Fu(){return ku&&!ku.destroyed?ku:null}let $u=(()=>{class t{constructor(t){this._injector=t,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(t,e){const n=function(t,e){let n;return n="noop"===t?new Cu:("zone.js"===t?void 0:t)||new Au({enableLongStackTrace:Du(),shouldCoalesceEventChangeDetection:!!(null==e?void 0:e.ngZoneEventCoalescing),shouldCoalesceRunChangeDetection:!!(null==e?void 0:e.ngZoneRunCoalescing)}),n}(e?e.ngZone:void 0,{ngZoneEventCoalescing:e&&e.ngZoneEventCoalescing||!1,ngZoneRunCoalescing:e&&e.ngZoneRunCoalescing||!1}),i=[{provide:Au,useValue:n}];return n.run(()=>{const e=Xo.create({providers:i,parent:this.injector,name:t.moduleType.name}),r=t.create(e),s=r.injector.get(Vr,null);if(!s)throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?");return n.runOutsideAngular(()=>{const t=n.onError.subscribe({next:t=>{s.handleError(t)}});r.onDestroy(()=>{Hu(this._modules,r),t.unsubscribe()})}),function(t,e,n){try{const i=n();return wa(i)?i.catch(n=>{throw e.runOutsideAngular(()=>t.handleError(n)),n}):i}catch(i){throw e.runOutsideAngular(()=>t.handleError(i)),i}}(s,n,()=>{const t=r.injector.get(Zc);return t.runInitializers(),t.donePromise.then(()=>(hl(r.injector.get(au,cl)||cl),this._moduleDoBootstrap(r),r))})})}bootstrapModule(t,e=[]){const n=zu({},e);return function(t,e,n){const i=new Ec(n);return Promise.resolve(i)}(0,0,t).then(t=>this.bootstrapModuleFactory(t,n))}_moduleDoBootstrap(t){const e=t.injector.get(Uu);if(t._bootstrapComponents.length>0)t._bootstrapComponents.forEach(t=>e.bootstrap(t));else{if(!t.instance.ngDoBootstrap)throw new Error(`The module ${Bt(t.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);t.instance.ngDoBootstrap(e)}this._modules.push(t)}onDestroy(t){this._destroyListeners.push(t)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Error("The platform has already been destroyed!");this._modules.slice().forEach(t=>t.destroy()),this._destroyListeners.forEach(t=>t()),this._destroyed=!0}get destroyed(){return this._destroyed}}return t.\u0275fac=function(e){return new(e||t)(Xi(Xo))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();function zu(t,e){return Array.isArray(e)?e.reduce(zu,t):Object.assign(Object.assign({},t),e)}let Uu=(()=>{class t{constructor(t,e,n,i,r){this._zone=t,this._injector=e,this._exceptionHandler=n,this._componentFactoryResolver=i,this._initStatus=r,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const s=new X(t=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{t.next(this._stable),t.complete()})}),o=new X(t=>{let e;this._zone.runOutsideAngular(()=>{e=this._zone.onStable.subscribe(()=>{Au.assertNotInAngularZone(),bu(()=>{this._stable||this._zone.hasPendingMacrotasks||this._zone.hasPendingMicrotasks||(this._stable=!0,t.next(!0))})})});const n=this._zone.onUnstable.subscribe(()=>{Au.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{t.next(!1)}))});return()=>{e.unsubscribe(),n.unsubscribe()}});this.isStable=wt(s,o.pipe(Nt()))}bootstrap(t,e){if(!this._initStatus.done)throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.");let n;n=t instanceof Al?t:this._componentFactoryResolver.resolveComponentFactory(t),this.componentTypes.push(n.componentType);const i=n.isBoundToModule?void 0:this._injector.get(lc),r=n.create(Xo.NULL,[],e||n.selector,i),s=r.location.nativeElement,o=r.injector.get(Iu,null),a=o&&r.injector.get(Tu);return o&&a&&a.registerApplication(s,o),r.onDestroy(()=>{this.detachView(r.hostView),Hu(this.components,r),a&&a.unregisterApplication(s)}),this._loadComponent(r),r}tick(){if(this._runningTick)throw new Error("ApplicationRef.tick is called recursively");try{this._runningTick=!0;for(let t of this._views)t.detectChanges()}catch(t){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(t))}finally{this._runningTick=!1}}attachView(t){const e=t;this._views.push(e),e.attachToAppRef(this)}detachView(t){const e=t;Hu(this._views,e),e.detachFromAppRef()}_loadComponent(t){this.attachView(t.hostView),this.tick(),this.components.push(t),this._injector.get(su,[]).concat(this._bootstrapListeners).forEach(e=>e(t))}ngOnDestroy(){this._views.slice().forEach(t=>t.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}get viewCount(){return this._views.length}}return t.\u0275fac=function(e){return new(e||t)(Xi(Au),Xi(Xo),Xi(Vr),Xi(wl),Xi(Zc))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();function Hu(t,e){const n=t.indexOf(e);n>-1&&t.splice(n,1)}class Vu{}class Gu{}const Wu={factoryPathPrefix:"",factoryPathSuffix:".ngfactory"};let ju=(()=>{class t{constructor(t,e){this._compiler=t,this._config=e||Wu}load(t){return this.loadAndCompile(t)}loadAndCompile(t){let[e,i]=t.split("#");return void 0===i&&(i="default"),n("zn8P")(e).then(t=>t[i]).then(t=>Qu(t,e,i)).then(t=>this._compiler.compileModuleAsync(t))}loadFactory(t){let[e,i]=t.split("#"),r="NgFactory";return void 0===i&&(i="default",r=""),n("zn8P")(this._config.factoryPathPrefix+e+this._config.factoryPathSuffix).then(t=>t[i+r]).then(t=>Qu(t,e,i))}}return t.\u0275fac=function(e){return new(e||t)(Xi(gu),Xi(Gu,8))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();function Qu(t,e,n){if(!t)throw new Error(`Cannot find '${n}' in '${e}'`);return t}const qu=Pu(null,"core",[{provide:ru,useValue:"unknown"},{provide:$u,deps:[Xo]},{provide:Tu,deps:[]},{provide:ou,deps:[]}]),Xu=[{provide:Uu,useClass:Uu,deps:[Au,Xo,Vr,wl,Zc]},{provide:Ac,deps:[Au],useFactory:function(t){let e=[];return t.onStable.subscribe(()=>{for(;e.length;)e.pop()()}),function(t){e.push(t)}}},{provide:Zc,useClass:Zc,deps:[[new tr,Jc]]},{provide:gu,useClass:gu,deps:[]},eu,{provide:Wl,useFactory:function(){return ec},deps:[]},{provide:Ql,useFactory:function(){return nc},deps:[]},{provide:au,useFactory:function(t){return hl(t=t||"undefined"!=typeof $localize&&$localize.locale||cl),t},deps:[[new Zi(au),new tr,new er]]},{provide:lu,useValue:"USD"}];let Yu=(()=>{class t{constructor(t){}}return t.\u0275fac=function(e){return new(e||t)(Xi(Uu))},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({providers:Xu}),t})(),Ku=null;function Ju(){return Ku}const Zu=new Ri("DocumentToken");let th=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({factory:eh,token:t,providedIn:"platform"}),t})();function eh(){return Xi(ih)}const nh=new Ri("Location Initialized");let ih=(()=>{class t extends th{constructor(t){super(),this._doc=t,this._init()}_init(){this.location=Ju().getLocation(),this._history=Ju().getHistory()}getBaseHrefFromDOM(){return Ju().getBaseHref(this._doc)}onPopState(t){Ju().getGlobalEventTarget(this._doc,"window").addEventListener("popstate",t,!1)}onHashChange(t){Ju().getGlobalEventTarget(this._doc,"window").addEventListener("hashchange",t,!1)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(t){this.location.pathname=t}pushState(t,e,n){rh()?this._history.pushState(t,e,n):this.location.hash=n}replaceState(t,e,n){rh()?this._history.replaceState(t,e,n):this.location.hash=n}forward(){this._history.forward()}back(){this._history.back()}getState(){return this._history.state}}return t.\u0275fac=function(e){return new(e||t)(Xi(Zu))},t.\u0275prov=Wt({factory:sh,token:t,providedIn:"platform"}),t})();function rh(){return!!window.history.pushState}function sh(){return new ih(Xi(Zu))}function oh(t,e){if(0==t.length)return e;if(0==e.length)return t;let n=0;return t.endsWith("/")&&n++,e.startsWith("/")&&n++,2==n?t+e.substring(1):1==n?t+e:t+"/"+e}function ah(t){const e=t.match(/#|\?|$/),n=e&&e.index||t.length;return t.slice(0,n-("/"===t[n-1]?1:0))+t.slice(n)}function lh(t){return t&&"?"!==t[0]?"?"+t:t}let ch=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({factory:uh,token:t,providedIn:"root"}),t})();function uh(t){const e=Xi(Zu).location;return new dh(Xi(th),e&&e.origin||"")}const hh=new Ri("appBaseHref");let dh=(()=>{class t extends ch{constructor(t,e){if(super(),this._platformLocation=t,null==e&&(e=this._platformLocation.getBaseHrefFromDOM()),null==e)throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");this._baseHref=e}onPopState(t){this._platformLocation.onPopState(t),this._platformLocation.onHashChange(t)}getBaseHref(){return this._baseHref}prepareExternalUrl(t){return oh(this._baseHref,t)}path(t=!1){const e=this._platformLocation.pathname+lh(this._platformLocation.search),n=this._platformLocation.hash;return n&&t?`${e}${n}`:e}pushState(t,e,n,i){const r=this.prepareExternalUrl(n+lh(i));this._platformLocation.pushState(t,e,r)}replaceState(t,e,n,i){const r=this.prepareExternalUrl(n+lh(i));this._platformLocation.replaceState(t,e,r)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}}return t.\u0275fac=function(e){return new(e||t)(Xi(th),Xi(hh,8))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})(),ph=(()=>{class t extends ch{constructor(t,e){super(),this._platformLocation=t,this._baseHref="",null!=e&&(this._baseHref=e)}onPopState(t){this._platformLocation.onPopState(t),this._platformLocation.onHashChange(t)}getBaseHref(){return this._baseHref}path(t=!1){let e=this._platformLocation.hash;return null==e&&(e="#"),e.length>0?e.substring(1):e}prepareExternalUrl(t){const e=oh(this._baseHref,t);return e.length>0?"#"+e:e}pushState(t,e,n,i){let r=this.prepareExternalUrl(n+lh(i));0==r.length&&(r=this._platformLocation.pathname),this._platformLocation.pushState(t,e,r)}replaceState(t,e,n,i){let r=this.prepareExternalUrl(n+lh(i));0==r.length&&(r=this._platformLocation.pathname),this._platformLocation.replaceState(t,e,r)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}}return t.\u0275fac=function(e){return new(e||t)(Xi(th),Xi(hh,8))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})(),fh=(()=>{class t{constructor(t,e){this._subject=new Nc,this._urlChangeListeners=[],this._platformStrategy=t;const n=this._platformStrategy.getBaseHref();this._platformLocation=e,this._baseHref=ah(gh(n)),this._platformStrategy.onPopState(t=>{this._subject.emit({url:this.path(!0),pop:!0,state:t.state,type:t.type})})}path(t=!1){return this.normalize(this._platformStrategy.path(t))}getState(){return this._platformLocation.getState()}isCurrentPathEqualTo(t,e=""){return this.path()==this.normalize(t+lh(e))}normalize(e){return t.stripTrailingSlash(function(t,e){return t&&e.startsWith(t)?e.substring(t.length):e}(this._baseHref,gh(e)))}prepareExternalUrl(t){return t&&"/"!==t[0]&&(t="/"+t),this._platformStrategy.prepareExternalUrl(t)}go(t,e="",n=null){this._platformStrategy.pushState(n,"",t,e),this._notifyUrlChangeListeners(this.prepareExternalUrl(t+lh(e)),n)}replaceState(t,e="",n=null){this._platformStrategy.replaceState(n,"",t,e),this._notifyUrlChangeListeners(this.prepareExternalUrl(t+lh(e)),n)}forward(){this._platformStrategy.forward()}back(){this._platformStrategy.back()}onUrlChange(t){this._urlChangeListeners.push(t),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(t=>{this._notifyUrlChangeListeners(t.url,t.state)}))}_notifyUrlChangeListeners(t="",e){this._urlChangeListeners.forEach(n=>n(t,e))}subscribe(t,e,n){return this._subject.subscribe({next:t,error:e,complete:n})}}return t.\u0275fac=function(e){return new(e||t)(Xi(ch),Xi(th))},t.normalizeQueryParams=lh,t.joinWithSlash=oh,t.stripTrailingSlash=ah,t.\u0275prov=Wt({factory:mh,token:t,providedIn:"root"}),t})();function mh(){return new fh(Xi(ch),Xi(th))}function gh(t){return t.replace(/\/index.html$/,"")}var yh=function(t){return t[t.Decimal=0]="Decimal",t[t.Percent=1]="Percent",t[t.Currency=2]="Currency",t[t.Scientific=3]="Scientific",t}({}),vh=function(t){return t[t.Zero=0]="Zero",t[t.One=1]="One",t[t.Two=2]="Two",t[t.Few=3]="Few",t[t.Many=4]="Many",t[t.Other=5]="Other",t}({}),bh=function(t){return t[t.Decimal=0]="Decimal",t[t.Group=1]="Group",t[t.List=2]="List",t[t.PercentSign=3]="PercentSign",t[t.PlusSign=4]="PlusSign",t[t.MinusSign=5]="MinusSign",t[t.Exponential=6]="Exponential",t[t.SuperscriptingExponent=7]="SuperscriptingExponent",t[t.PerMille=8]="PerMille",t[t[1/0]=9]="Infinity",t[t.NaN=10]="NaN",t[t.TimeSeparator=11]="TimeSeparator",t[t.CurrencyDecimal=12]="CurrencyDecimal",t[t.CurrencyGroup=13]="CurrencyGroup",t}({});function Ah(t,e){const n=ol(t),i=n[ll.NumberSymbols][e];if(void 0===i){if(e===bh.CurrencyDecimal)return n[ll.NumberSymbols][bh.Decimal];if(e===bh.CurrencyGroup)return n[ll.NumberSymbols][bh.Group]}return i}const xh=/^(\d+)?\.((\d+)(-(\d+))?)?$/,wh=".",_h="0";function Sh(t){const e=parseInt(t);if(isNaN(e))throw new Error("Invalid integer literal when parsing "+t);return e}class Eh{}let Ch=(()=>{class t extends Eh{constructor(t){super(),this.locale=t}getPluralCategory(t,e){switch(function(t){return ol(t)[ll.PluralCase]}(e||this.locale)(t)){case vh.Zero:return"zero";case vh.One:return"one";case vh.Two:return"two";case vh.Few:return"few";case vh.Many:return"many";default:return"other"}}}return t.\u0275fac=function(e){return new(e||t)(Xi(au))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();function Ih(t,e){e=encodeURIComponent(e);for(const n of t.split(";")){const t=n.indexOf("="),[i,r]=-1==t?[n,""]:[n.slice(0,t),n.slice(t+1)];if(i.trim()===e)return decodeURIComponent(r)}return null}let Th=(()=>{class t{constructor(t,e,n,i){this._iterableDiffers=t,this._keyValueDiffers=e,this._ngEl=n,this._renderer=i,this._iterableDiffer=null,this._keyValueDiffer=null,this._initialClasses=[],this._rawClass=null}set klass(t){this._removeClasses(this._initialClasses),this._initialClasses="string"==typeof t?t.split(/\s+/):[],this._applyClasses(this._initialClasses),this._applyClasses(this._rawClass)}set ngClass(t){this._removeClasses(this._rawClass),this._applyClasses(this._initialClasses),this._iterableDiffer=null,this._keyValueDiffer=null,this._rawClass="string"==typeof t?t.split(/\s+/):t,this._rawClass&&(sa(this._rawClass)?this._iterableDiffer=this._iterableDiffers.find(this._rawClass).create():this._keyValueDiffer=this._keyValueDiffers.find(this._rawClass).create())}ngDoCheck(){if(this._iterableDiffer){const t=this._iterableDiffer.diff(this._rawClass);t&&this._applyIterableChanges(t)}else if(this._keyValueDiffer){const t=this._keyValueDiffer.diff(this._rawClass);t&&this._applyKeyValueChanges(t)}}_applyKeyValueChanges(t){t.forEachAddedItem(t=>this._toggleClass(t.key,t.currentValue)),t.forEachChangedItem(t=>this._toggleClass(t.key,t.currentValue)),t.forEachRemovedItem(t=>{t.previousValue&&this._toggleClass(t.key,!1)})}_applyIterableChanges(t){t.forEachAddedItem(t=>{if("string"!=typeof t.item)throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${Bt(t.item)}`);this._toggleClass(t.item,!0)}),t.forEachRemovedItem(t=>this._toggleClass(t.item,!1))}_applyClasses(t){t&&(Array.isArray(t)||t instanceof Set?t.forEach(t=>this._toggleClass(t,!0)):Object.keys(t).forEach(e=>this._toggleClass(e,!!t[e])))}_removeClasses(t){t&&(Array.isArray(t)||t instanceof Set?t.forEach(t=>this._toggleClass(t,!1)):Object.keys(t).forEach(t=>this._toggleClass(t,!1)))}_toggleClass(t,e){(t=t.trim())&&t.split(/\s+/g).forEach(t=>{e?this._renderer.addClass(this._ngEl.nativeElement,t):this._renderer.removeClass(this._ngEl.nativeElement,t)})}}return t.\u0275fac=function(e){return new(e||t)(pa(Wl),pa(Ql),pa(Cl),pa(Ml))},t.\u0275dir=ke({type:t,selectors:[["","ngClass",""]],inputs:{klass:["class","klass"],ngClass:"ngClass"}}),t})();class Mh{constructor(t,e,n,i){this.$implicit=t,this.ngForOf=e,this.index=n,this.count=i}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let kh=(()=>{class t{constructor(t,e,n){this._viewContainer=t,this._template=e,this._differs=n,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForOf(t){this._ngForOf=t,this._ngForOfDirty=!0}set ngForTrackBy(t){this._trackByFn=t}get ngForTrackBy(){return this._trackByFn}set ngForTemplate(t){t&&(this._template=t)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const n=this._ngForOf;if(!this._differ&&n)try{this._differ=this._differs.find(n).create(this.ngForTrackBy)}catch(e){throw new Error(`Cannot find a differ supporting object '${n}' of type '${t=n,t.name||typeof t}'. NgFor only supports binding to Iterables such as Arrays.`)}}var t;if(this._differ){const t=this._differ.diff(this._ngForOf);t&&this._applyChanges(t)}}_applyChanges(t){const e=[];t.forEachOperation((t,n,i)=>{if(null==t.previousIndex){const n=this._viewContainer.createEmbeddedView(this._template,new Mh(null,this._ngForOf,-1,-1),null===i?void 0:i),r=new Rh(t,n);e.push(r)}else if(null==i)this._viewContainer.remove(null===n?void 0:n);else if(null!==n){const r=this._viewContainer.get(n);this._viewContainer.move(r,i);const s=new Rh(t,r);e.push(s)}});for(let n=0;n<e.length;n++)this._perViewChange(e[n].view,e[n].record);for(let n=0,i=this._viewContainer.length;n<i;n++){const t=this._viewContainer.get(n);t.context.index=n,t.context.count=i,t.context.ngForOf=this._ngForOf}t.forEachIdentityChange(t=>{this._viewContainer.get(t.currentIndex).context.$implicit=t.item})}_perViewChange(t,e){t.context.$implicit=e.item}static ngTemplateContextGuard(t,e){return!0}}return t.\u0275fac=function(e){return new(e||t)(pa(hc),pa(rc),pa(Wl))},t.\u0275dir=ke({type:t,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"}}),t})();class Rh{constructor(t,e){this.record=t,this.view=e}}let Nh=(()=>{class t{constructor(t,e){this._viewContainer=t,this._context=new Lh,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=e}set ngIf(t){this._context.$implicit=this._context.ngIf=t,this._updateView()}set ngIfThen(t){Dh("ngIfThen",t),this._thenTemplateRef=t,this._thenViewRef=null,this._updateView()}set ngIfElse(t){Dh("ngIfElse",t),this._elseTemplateRef=t,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(t,e){return!0}}return t.\u0275fac=function(e){return new(e||t)(pa(hc),pa(rc))},t.\u0275dir=ke({type:t,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"}}),t})();class Lh{constructor(){this.$implicit=null,this.ngIf=null}}function Dh(t,e){if(e&&!e.createEmbeddedView)throw new Error(`${t} must be a TemplateRef, but received '${Bt(e)}'.`)}class Bh{constructor(t,e){this._viewContainerRef=t,this._templateRef=e,this._created=!1}create(){this._created=!0,this._viewContainerRef.createEmbeddedView(this._templateRef)}destroy(){this._created=!1,this._viewContainerRef.clear()}enforceState(t){t&&!this._created?this.create():!t&&this._created&&this.destroy()}}let Oh=(()=>{class t{constructor(){this._defaultUsed=!1,this._caseCount=0,this._lastCaseCheckIndex=0,this._lastCasesMatched=!1}set ngSwitch(t){this._ngSwitch=t,0===this._caseCount&&this._updateDefaultCases(!0)}_addCase(){return this._caseCount++}_addDefault(t){this._defaultViews||(this._defaultViews=[]),this._defaultViews.push(t)}_matchCase(t){const e=t==this._ngSwitch;return this._lastCasesMatched=this._lastCasesMatched||e,this._lastCaseCheckIndex++,this._lastCaseCheckIndex===this._caseCount&&(this._updateDefaultCases(!this._lastCasesMatched),this._lastCaseCheckIndex=0,this._lastCasesMatched=!1),e}_updateDefaultCases(t){if(this._defaultViews&&t!==this._defaultUsed){this._defaultUsed=t;for(let e=0;e<this._defaultViews.length;e++)this._defaultViews[e].enforceState(t)}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=ke({type:t,selectors:[["","ngSwitch",""]],inputs:{ngSwitch:"ngSwitch"}}),t})(),Ph=(()=>{class t{constructor(t,e,n){this.ngSwitch=n,n._addCase(),this._view=new Bh(t,e)}ngDoCheck(){this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase))}}return t.\u0275fac=function(e){return new(e||t)(pa(hc),pa(rc),pa(Oh,9))},t.\u0275dir=ke({type:t,selectors:[["","ngSwitchCase",""]],inputs:{ngSwitchCase:"ngSwitchCase"}}),t})(),Fh=(()=>{class t{constructor(t,e,n){this._ngEl=t,this._differs=e,this._renderer=n,this._ngStyle=null,this._differ=null}set ngStyle(t){this._ngStyle=t,!this._differ&&t&&(this._differ=this._differs.find(t).create())}ngDoCheck(){if(this._differ){const t=this._differ.diff(this._ngStyle);t&&this._applyChanges(t)}}_setStyle(t,e){const[n,i]=t.split(".");null!=(e=null!=e&&i?`${e}${i}`:e)?this._renderer.setStyle(this._ngEl.nativeElement,n,e):this._renderer.removeStyle(this._ngEl.nativeElement,n)}_applyChanges(t){t.forEachRemovedItem(t=>this._setStyle(t.key,null)),t.forEachAddedItem(t=>this._setStyle(t.key,t.currentValue)),t.forEachChangedItem(t=>this._setStyle(t.key,t.currentValue))}}return t.\u0275fac=function(e){return new(e||t)(pa(Cl),pa(Ql),pa(Ml))},t.\u0275dir=ke({type:t,selectors:[["","ngStyle",""]],inputs:{ngStyle:"ngStyle"}}),t})();function $h(t,e){return Error(`InvalidPipeArgument: '${e}' for pipe '${Bt(t)}'`)}class zh{createSubscription(t,e){return t.subscribe({next:e,error:t=>{throw t}})}dispose(t){t.unsubscribe()}onDestroy(t){t.unsubscribe()}}class Uh{createSubscription(t,e){return t.then(e,t=>{throw t})}dispose(t){}onDestroy(t){}}const Hh=new Uh,Vh=new zh;let Gh=(()=>{class t{constructor(t){this._ref=t,this._latestValue=null,this._subscription=null,this._obj=null,this._strategy=null}ngOnDestroy(){this._subscription&&this._dispose()}transform(t){return this._obj?t!==this._obj?(this._dispose(),this.transform(t)):this._latestValue:(t&&this._subscribe(t),this._latestValue)}_subscribe(t){this._obj=t,this._strategy=this._selectStrategy(t),this._subscription=this._strategy.createSubscription(t,e=>this._updateLatestValue(t,e))}_selectStrategy(e){if(wa(e))return Hh;if(_a(e))return Vh;throw $h(t,e)}_dispose(){this._strategy.dispose(this._subscription),this._latestValue=null,this._subscription=null,this._obj=null}_updateLatestValue(t,e){t===this._obj&&(this._latestValue=e,this._ref.markForCheck())}}return t.\u0275fac=function(e){return new(e||t)(Kc())},t.\u0275pipe=Re({name:"async",type:t,pure:!1}),t})(),Wh=(()=>{class t{constructor(t){this._locale=t}transform(e,n,i){if(!function(t){return!(null==t||""===t||t!=t)}(e))return null;i=i||this._locale;try{return function(t,e,n){return function(t,e,n,i,r,s,o=!1){let a="",l=!1;if(isFinite(t)){let c=function(t){let e,n,i,r,s,o=Math.abs(t)+"",a=0;for((n=o.indexOf(wh))>-1&&(o=o.replace(wh,"")),(i=o.search(/e/i))>0?(n<0&&(n=i),n+=+o.slice(i+1),o=o.substring(0,i)):n<0&&(n=o.length),i=0;o.charAt(i)===_h;i++);if(i===(s=o.length))e=[0],n=1;else{for(s--;o.charAt(s)===_h;)s--;for(n-=i,e=[],r=0;i<=s;i++,r++)e[r]=Number(o.charAt(i))}return n>22&&(e=e.splice(0,21),a=n-1,n=1),{digits:e,exponent:a,integerLen:n}}(t);o&&(c=function(t){if(0===t.digits[0])return t;const e=t.digits.length-t.integerLen;return t.exponent?t.exponent+=2:(0===e?t.digits.push(0,0):1===e&&t.digits.push(0),t.integerLen+=2),t}(c));let u=e.minInt,h=e.minFrac,d=e.maxFrac;if(s){const t=s.match(xh);if(null===t)throw new Error(`${s} is not a valid digit info`);const e=t[1],n=t[3],i=t[5];null!=e&&(u=Sh(e)),null!=n&&(h=Sh(n)),null!=i?d=Sh(i):null!=n&&h>d&&(d=h)}!function(t,e,n){if(e>n)throw new Error(`The minimum number of digits after fraction (${e}) is higher than the maximum (${n}).`);let i=t.digits,r=i.length-t.integerLen;const s=Math.min(Math.max(e,r),n);let o=s+t.integerLen,a=i[o];if(o>0){i.splice(Math.max(t.integerLen,o));for(let t=o;t<i.length;t++)i[t]=0}else{r=Math.max(0,r),t.integerLen=1,i.length=Math.max(1,o=s+1),i[0]=0;for(let t=1;t<o;t++)i[t]=0}if(a>=5)if(o-1<0){for(let e=0;e>o;e--)i.unshift(0),t.integerLen++;i.unshift(1),t.integerLen++}else i[o-1]++;for(;r<Math.max(0,s);r++)i.push(0);let l=0!==s;const c=e+t.integerLen,u=i.reduceRight(function(t,e,n,i){return i[n]=(e+=t)<10?e:e-10,l&&(0===i[n]&&n>=c?i.pop():l=!1),e>=10?1:0},0);u&&(i.unshift(u),t.integerLen++)}(c,h,d);let p=c.digits,f=c.integerLen;const m=c.exponent;let g=[];for(l=p.every(t=>!t);f<u;f++)p.unshift(0);for(;f<0;f++)p.unshift(0);f>0?g=p.splice(f,p.length):(g=p,p=[0]);const y=[];for(p.length>=e.lgSize&&y.unshift(p.splice(-e.lgSize,p.length).join(""));p.length>e.gSize;)y.unshift(p.splice(-e.gSize,p.length).join(""));p.length&&y.unshift(p.join("")),a=y.join(Ah(n,i)),g.length&&(a+=Ah(n,r)+g.join("")),m&&(a+=Ah(n,bh.Exponential)+"+"+m)}else a=Ah(n,bh.Infinity);return a=t<0&&!l?e.negPre+a+e.negSuf:e.posPre+a+e.posSuf,a}(t,function(t,e="-"){const n={minInt:1,minFrac:0,maxFrac:0,posPre:"",posSuf:"",negPre:"",negSuf:"",gSize:0,lgSize:0},i=t.split(";"),r=i[0],s=i[1],o=-1!==r.indexOf(wh)?r.split(wh):[r.substring(0,r.lastIndexOf(_h)+1),r.substring(r.lastIndexOf(_h)+1)],a=o[0],l=o[1]||"";n.posPre=a.substr(0,a.indexOf("#"));for(let u=0;u<l.length;u++){const t=l.charAt(u);t===_h?n.minFrac=n.maxFrac=u+1:"#"===t?n.maxFrac=u+1:n.posSuf+=t}const c=a.split(",");if(n.gSize=c[1]?c[1].length:0,n.lgSize=c[2]||c[1]?(c[2]||c[1]).length:0,s){const t=r.length-n.posPre.length-n.posSuf.length,e=s.indexOf("#");n.negPre=s.substr(0,e).replace(/'/g,""),n.negSuf=s.substr(e+t).replace(/'/g,"")}else n.negPre=e+n.posPre,n.negSuf=n.posSuf;return n}(function(t,e){return ol(t)[ll.NumberFormats][e]}(e,yh.Decimal),Ah(e,bh.MinusSign)),e,bh.Group,bh.Decimal,n)}(function(t){if("string"==typeof t&&!isNaN(Number(t)-parseFloat(t)))return Number(t);if("number"!=typeof t)throw new Error(`${t} is not a number`);return t}(e),i,n)}catch(r){throw $h(t,r.message)}}}return t.\u0275fac=function(e){return new(e||t)(pa(au))},t.\u0275pipe=Re({name:"number",type:t,pure:!0}),t})(),jh=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({providers:[{provide:Eh,useClass:Ch}]}),t})();function Qh(t){return"browser"===t}let qh=(()=>{class t{}return t.\u0275prov=Wt({token:t,providedIn:"root",factory:()=>new Xh(Xi(Zu),window)}),t})();class Xh{constructor(t,e){this.document=t,this.window=e,this.offset=()=>[0,0]}setOffset(t){this.offset=Array.isArray(t)?()=>t:t}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(t){this.supportsScrolling()&&this.window.scrollTo(t[0],t[1])}scrollToAnchor(t){if(!this.supportsScrolling())return;const e=function(t,e){const n=t.getElementById(e)||t.getElementsByName(e)[0];if(n)return n;if("function"==typeof t.createTreeWalker&&t.body&&(t.body.createShadowRoot||t.body.attachShadow)){const n=t.createTreeWalker(t.body,NodeFilter.SHOW_ELEMENT);let i=n.currentNode;for(;i;){const t=i.shadowRoot;if(t){const n=t.getElementById(e)||t.querySelector(`[name="${e}"]`);if(n)return n}i=n.nextNode()}}return null}(this.document,t);e&&(this.scrollToElement(e),this.attemptFocus(e))}setHistoryScrollRestoration(t){if(this.supportScrollRestoration()){const e=this.window.history;e&&e.scrollRestoration&&(e.scrollRestoration=t)}}scrollToElement(t){const e=t.getBoundingClientRect(),n=e.left+this.window.pageXOffset,i=e.top+this.window.pageYOffset,r=this.offset();this.window.scrollTo(n-r[0],i-r[1])}attemptFocus(t){return t.focus(),this.document.activeElement===t}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const t=Yh(this.window.history)||Yh(Object.getPrototypeOf(this.window.history));return!(!t||!t.writable&&!t.set)}catch(t){return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch(t){return!1}}}function Yh(t){return Object.getOwnPropertyDescriptor(t,"scrollRestoration")}class Kh extends class extends class{}{constructor(){super()}supportsDOMEvents(){return!0}}{static makeCurrent(){var t;t=new Kh,Ku||(Ku=t)}getProperty(t,e){return t[e]}log(t){window.console&&window.console.log&&window.console.log(t)}logGroup(t){window.console&&window.console.group&&window.console.group(t)}logGroupEnd(){window.console&&window.console.groupEnd&&window.console.groupEnd()}onAndCancel(t,e,n){return t.addEventListener(e,n,!1),()=>{t.removeEventListener(e,n,!1)}}dispatchEvent(t,e){t.dispatchEvent(e)}remove(t){return t.parentNode&&t.parentNode.removeChild(t),t}getValue(t){return t.value}createElement(t,e){return(e=e||this.getDefaultDocument()).createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,e){return"window"===e?window:"document"===e?t:"body"===e?t.body:null}getHistory(){return window.history}getLocation(){return window.location}getBaseHref(t){const e=Zh||(Zh=document.querySelector("base"),Zh)?Zh.getAttribute("href"):null;return null==e?null:(n=e,Jh||(Jh=document.createElement("a")),Jh.setAttribute("href",n),"/"===Jh.pathname.charAt(0)?Jh.pathname:"/"+Jh.pathname);var n}resetBaseElement(){Zh=null}getUserAgent(){return window.navigator.userAgent}performanceNow(){return window.performance&&window.performance.now?window.performance.now():(new Date).getTime()}supportsCookies(){return!0}getCookie(t){return Ih(document.cookie,t)}}let Jh,Zh=null;const td=new Ri("TRANSITION_ID"),ed=[{provide:Jc,useFactory:function(t,e,n){return()=>{n.get(Zc).donePromise.then(()=>{const n=Ju();Array.prototype.slice.apply(e.querySelectorAll("style[ng-transition]")).filter(e=>e.getAttribute("ng-transition")===t).forEach(t=>n.remove(t))})}},deps:[td,Zu,Xo],multi:!0}];class nd{static init(){var t;t=new nd,Ru=t}addToWindow(t){de.getAngularTestability=(e,n=!0)=>{const i=t.findTestabilityInTree(e,n);if(null==i)throw new Error("Could not find testability for element.");return i},de.getAllAngularTestabilities=()=>t.getAllTestabilities(),de.getAllAngularRootElements=()=>t.getAllRootElements(),de.frameworkStabilizers||(de.frameworkStabilizers=[]),de.frameworkStabilizers.push(t=>{const e=de.getAllAngularTestabilities();let n=e.length,i=!1;const r=function(e){i=i||e,n--,0==n&&t(i)};e.forEach(function(t){t.whenStable(r)})})}findTestabilityInTree(t,e,n){if(null==e)return null;const i=t.getTestability(e);return null!=i?i:n?Ju().isShadowRoot(e)?this.findTestabilityInTree(t,e.host,!0):this.findTestabilityInTree(t,e.parentElement,!0):null}}const id=new Ri("EventManagerPlugins");let rd=(()=>{class t{constructor(t,e){this._zone=e,this._eventNameToPlugin=new Map,t.forEach(t=>t.manager=this),this._plugins=t.slice().reverse()}addEventListener(t,e,n){return this._findPluginFor(e).addEventListener(t,e,n)}addGlobalEventListener(t,e,n){return this._findPluginFor(e).addGlobalEventListener(t,e,n)}getZone(){return this._zone}_findPluginFor(t){const e=this._eventNameToPlugin.get(t);if(e)return e;const n=this._plugins;for(let i=0;i<n.length;i++){const e=n[i];if(e.supports(t))return this._eventNameToPlugin.set(t,e),e}throw new Error(`No event manager plugin found for event ${t}`)}}return t.\u0275fac=function(e){return new(e||t)(Xi(id),Xi(Au))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();class sd{constructor(t){this._doc=t}addGlobalEventListener(t,e,n){const i=Ju().getGlobalEventTarget(this._doc,t);if(!i)throw new Error(`Unsupported event target ${i} for event ${e}`);return this.addEventListener(i,e,n)}}let od=(()=>{class t{constructor(){this._stylesSet=new Set}addStyles(t){const e=new Set;t.forEach(t=>{this._stylesSet.has(t)||(this._stylesSet.add(t),e.add(t))}),this.onStylesAdded(e)}onStylesAdded(t){}getAllStyles(){return Array.from(this._stylesSet)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})(),ad=(()=>{class t extends od{constructor(t){super(),this._doc=t,this._hostNodes=new Map,this._hostNodes.set(t.head,[])}_addStylesToHost(t,e,n){t.forEach(t=>{const i=this._doc.createElement("style");i.textContent=t,n.push(e.appendChild(i))})}addHost(t){const e=[];this._addStylesToHost(this._stylesSet,t,e),this._hostNodes.set(t,e)}removeHost(t){const e=this._hostNodes.get(t);e&&e.forEach(ld),this._hostNodes.delete(t)}onStylesAdded(t){this._hostNodes.forEach((e,n)=>{this._addStylesToHost(t,n,e)})}ngOnDestroy(){this._hostNodes.forEach(t=>t.forEach(ld))}}return t.\u0275fac=function(e){return new(e||t)(Xi(Zu))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();function ld(t){Ju().remove(t)}const cd={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"},ud=/%COMP%/g;function hd(t,e,n){for(let i=0;i<e.length;i++){let r=e[i];Array.isArray(r)?hd(t,r,n):(r=r.replace(ud,t),n.push(r))}return n}function dd(t){return e=>{if("__ngUnwrap__"===e)return t;!1===t(e)&&(e.preventDefault(),e.returnValue=!1)}}let pd=(()=>{class t{constructor(t,e,n){this.eventManager=t,this.sharedStylesHost=e,this.appId=n,this.rendererByCompId=new Map,this.defaultRenderer=new fd(t)}createRenderer(t,e){if(!t||!e)return this.defaultRenderer;switch(e.encapsulation){case ae.Emulated:{let n=this.rendererByCompId.get(e.id);return n||(n=new md(this.eventManager,this.sharedStylesHost,e,this.appId),this.rendererByCompId.set(e.id,n)),n.applyToHost(t),n}case 1:case ae.ShadowDom:return new gd(this.eventManager,this.sharedStylesHost,t,e);default:if(!this.rendererByCompId.has(e.id)){const t=hd(e.id,e.styles,[]);this.sharedStylesHost.addStyles(t),this.rendererByCompId.set(e.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return t.\u0275fac=function(e){return new(e||t)(Xi(rd),Xi(ad),Xi(tu))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();class fd{constructor(t){this.eventManager=t,this.data=Object.create(null)}destroy(){}createElement(t,e){return e?document.createElementNS(cd[e]||e,t):document.createElement(t)}createComment(t){return document.createComment(t)}createText(t){return document.createTextNode(t)}appendChild(t,e){t.appendChild(e)}insertBefore(t,e,n){t&&t.insertBefore(e,n)}removeChild(t,e){t&&t.removeChild(e)}selectRootElement(t,e){let n="string"==typeof t?document.querySelector(t):t;if(!n)throw new Error(`The selector "${t}" did not match any elements`);return e||(n.textContent=""),n}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,e,n,i){if(i){e=i+":"+e;const r=cd[i];r?t.setAttributeNS(r,e,n):t.setAttribute(e,n)}else t.setAttribute(e,n)}removeAttribute(t,e,n){if(n){const i=cd[n];i?t.removeAttributeNS(i,e):t.removeAttribute(`${n}:${e}`)}else t.removeAttribute(e)}addClass(t,e){t.classList.add(e)}removeClass(t,e){t.classList.remove(e)}setStyle(t,e,n,i){i&(qr.DashCase|qr.Important)?t.style.setProperty(e,n,i&qr.Important?"important":""):t.style[e]=n}removeStyle(t,e,n){n&qr.DashCase?t.style.removeProperty(e):t.style[e]=""}setProperty(t,e,n){t[e]=n}setValue(t,e){t.nodeValue=e}listen(t,e,n){return"string"==typeof t?this.eventManager.addGlobalEventListener(t,e,dd(n)):this.eventManager.addEventListener(t,e,dd(n))}}class md extends fd{constructor(t,e,n,i){super(t),this.component=n;const r=hd(i+"-"+n.id,n.styles,[]);e.addStyles(r),this.contentAttr="_ngcontent-%COMP%".replace(ud,i+"-"+n.id),this.hostAttr="_nghost-%COMP%".replace(ud,i+"-"+n.id)}applyToHost(t){super.setAttribute(t,this.hostAttr,"")}createElement(t,e){const n=super.createElement(t,e);return super.setAttribute(n,this.contentAttr,""),n}}class gd extends fd{constructor(t,e,n,i){super(t),this.sharedStylesHost=e,this.hostEl=n,this.shadowRoot=n.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const r=hd(i.id,i.styles,[]);for(let s=0;s<r.length;s++){const t=document.createElement("style");t.textContent=r[s],this.shadowRoot.appendChild(t)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(t,e){return super.appendChild(this.nodeOrShadowRoot(t),e)}insertBefore(t,e,n){return super.insertBefore(this.nodeOrShadowRoot(t),e,n)}removeChild(t,e){return super.removeChild(this.nodeOrShadowRoot(t),e)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}}let yd=(()=>{class t extends sd{constructor(t){super(t)}supports(t){return!0}addEventListener(t,e,n){return t.addEventListener(e,n,!1),()=>this.removeEventListener(t,e,n)}removeEventListener(t,e,n){return t.removeEventListener(e,n)}}return t.\u0275fac=function(e){return new(e||t)(Xi(Zu))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();const vd=["alt","control","meta","shift"],bd={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},Ad={A:"1",B:"2",C:"3",D:"4",E:"5",F:"6",G:"7",H:"8",I:"9",J:"*",K:"+",M:"-",N:".",O:"/","`":"0","\x90":"NumLock"},xd={alt:t=>t.altKey,control:t=>t.ctrlKey,meta:t=>t.metaKey,shift:t=>t.shiftKey};let wd=(()=>{class t extends sd{constructor(t){super(t)}supports(e){return null!=t.parseEventName(e)}addEventListener(e,n,i){const r=t.parseEventName(n),s=t.eventCallback(r.fullKey,i,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>Ju().onAndCancel(e,r.domEventName,s))}static parseEventName(e){const n=e.toLowerCase().split("."),i=n.shift();if(0===n.length||"keydown"!==i&&"keyup"!==i)return null;const r=t._normalizeKey(n.pop());let s="";if(vd.forEach(t=>{const e=n.indexOf(t);e>-1&&(n.splice(e,1),s+=t+".")}),s+=r,0!=n.length||0===r.length)return null;const o={};return o.domEventName=i,o.fullKey=s,o}static getEventFullKey(t){let e="",n=function(t){let e=t.key;if(null==e){if(e=t.keyIdentifier,null==e)return"Unidentified";e.startsWith("U+")&&(e=String.fromCharCode(parseInt(e.substring(2),16)),3===t.location&&Ad.hasOwnProperty(e)&&(e=Ad[e]))}return bd[e]||e}(t);return n=n.toLowerCase()," "===n?n="space":"."===n&&(n="dot"),vd.forEach(i=>{i!=n&&(0,xd[i])(t)&&(e+=i+".")}),e+=n,e}static eventCallback(e,n,i){return r=>{t.getEventFullKey(r)===e&&i.runGuarded(()=>n(r))}}static _normalizeKey(t){switch(t){case"esc":return"escape";default:return t}}}return t.\u0275fac=function(e){return new(e||t)(Xi(Zu))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})(),_d=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({factory:function(){return Xi(Sd)},token:t,providedIn:"root"}),t})(),Sd=(()=>{class t extends _d{constructor(t){super(),this._doc=t}sanitize(t,e){if(null==e)return null;switch(t){case Fr.NONE:return e;case Fr.HTML:return pr(e,"HTML")?dr(e):Or(this._doc,String(e)).toString();case Fr.STYLE:return pr(e,"Style")?dr(e):e;case Fr.SCRIPT:if(pr(e,"Script"))return dr(e);throw new Error("unsafe value used in a script context");case Fr.URL:return fr(e),pr(e,"URL")?dr(e):br(String(e));case Fr.RESOURCE_URL:if(pr(e,"ResourceURL"))return dr(e);throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)");default:throw new Error(`Unexpected SecurityContext ${t} (see https://g.co/ng/security#xss)`)}}bypassSecurityTrustHtml(t){return new ar(t)}bypassSecurityTrustStyle(t){return new lr(t)}bypassSecurityTrustScript(t){return new cr(t)}bypassSecurityTrustUrl(t){return new ur(t)}bypassSecurityTrustResourceUrl(t){return new hr(t)}}return t.\u0275fac=function(e){return new(e||t)(Xi(Zu))},t.\u0275prov=Wt({factory:function(){return t=Xi(Lo),new Sd(t.get(Zu));var t},token:t,providedIn:"root"}),t})();const Ed=Pu(qu,"browser",[{provide:ru,useValue:"browser"},{provide:iu,useValue:function(){Kh.makeCurrent(),nd.init()},multi:!0},{provide:Zu,useFactory:function(){return function(t){Ye=t}(document),document},deps:[]}]),Cd=[[],{provide:Bo,useValue:"root"},{provide:Vr,useFactory:function(){return new Vr},deps:[]},{provide:id,useClass:yd,multi:!0,deps:[Zu,Au,ru]},{provide:id,useClass:wd,multi:!0,deps:[Zu]},[],{provide:pd,useClass:pd,deps:[rd,ad,tu]},{provide:Tl,useExisting:pd},{provide:od,useExisting:ad},{provide:ad,useClass:ad,deps:[Zu]},{provide:Iu,useClass:Iu,deps:[Au]},{provide:rd,useClass:rd,deps:[id,Au]},[]];let Id=(()=>{class t{constructor(t){if(t)throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.")}static withServerTransition(e){return{ngModule:t,providers:[{provide:tu,useValue:e.appId},{provide:td,useExisting:tu},ed]}}}return t.\u0275fac=function(e){return new(e||t)(Xi(t,12))},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({providers:Cd,imports:[jh,Yu]}),t})();"undefined"!=typeof window&&window;var Td=n("DZm5"),Md=n("sZor"),kd=n("W4f/");function Rd(...t){let e=t[t.length-1];return nt(e)?(t.pop(),dt(t,e)):xt(t)}class Nd extends tt{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){const e=super._subscribe(t);return e&&!e.closed&&t.next(this._value),e}getValue(){if(this.hasError)throw this.thrownError;if(this.closed)throw new K;return this._value}next(t){super.next(this._value=t)}}class Ld extends W{notifyNext(t,e,n,i,r){this.destination.next(e)}notifyError(t,e){this.destination.error(t)}notifyComplete(t){this.destination.complete()}}class Dd extends W{constructor(t,e,n){super(),this.parent=t,this.outerValue=e,this.outerIndex=n,this.index=0}_next(t){this.parent.notifyNext(this.outerValue,t,this.outerIndex,this.index++,this)}_error(t){this.parent.notifyError(t,this),this.unsubscribe()}_complete(){this.parent.notifyComplete(this),this.unsubscribe()}}function Bd(t,e,n,i,r=new Dd(t,n,i)){if(!r.closed)return e instanceof X?e.subscribe(r):ht(e)(r)}const Od={};function Pd(...t){let e,n;return nt(t[t.length-1])&&(n=t.pop()),"function"==typeof t[t.length-1]&&(e=t.pop()),1===t.length&&$(t[0])&&(t=t[0]),xt(t,n).lift(new Fd(e))}class Fd{constructor(t){this.resultSelector=t}call(t,e){return e.subscribe(new $d(t,this.resultSelector))}}class $d extends Ld{constructor(t,e){super(t),this.resultSelector=e,this.active=0,this.values=[],this.observables=[]}_next(t){this.values.push(Od),this.observables.push(t)}_complete(){const t=this.observables,e=t.length;if(0===e)this.destination.complete();else{this.active=e,this.toRespond=e;for(let n=0;n<e;n++)this.add(Bd(this,t[n],void 0,n))}}notifyComplete(t){0==(this.active-=1)&&this.destination.complete()}notifyNext(t,e,n){const i=this.values,r=this.toRespond?i[n]===Od?--this.toRespond:this.toRespond:0;i[n]=e,0===r&&(this.resultSelector?this._tryResultSelector(i):this.destination.next(i.slice()))}_tryResultSelector(t){let e;try{e=this.resultSelector.apply(this,t)}catch(n){return void this.destination.error(n)}this.destination.next(e)}}const zd=(()=>{function t(){return Error.call(this),this.message="no elements in sequence",this.name="EmptyError",this}return t.prototype=Object.create(Error.prototype),t})();function Ud(...t){return At(1)(Rd(...t))}const Hd=new X(t=>t.complete());function Vd(t){return t?function(t){return new X(e=>t.schedule(()=>e.complete()))}(t):Hd}function Gd(t){return new X(e=>{let n;try{n=t()}catch(i){return void e.error(i)}return(n?pt(n):Vd()).subscribe(e)})}function Wd(t,e){return"function"==typeof e?n=>n.pipe(Wd((n,i)=>pt(t(n,i)).pipe(it((t,r)=>e(n,t,i,r))))):e=>e.lift(new jd(t))}class jd{constructor(t){this.project=t}call(t,e){return e.subscribe(new Qd(t,this.project))}}class Qd extends mt{constructor(t,e){super(t),this.project=e,this.index=0}_next(t){let e;const n=this.index++;try{e=this.project(t,n)}catch(i){return void this.destination.error(i)}this._innerSub(e)}_innerSub(t){const e=this.innerSubscription;e&&e.unsubscribe();const n=new ft(this),i=this.destination;i.add(n),this.innerSubscription=gt(t,n),this.innerSubscription!==n&&i.add(this.innerSubscription)}_complete(){const{innerSubscription:t}=this;t&&!t.closed||super._complete(),this.unsubscribe()}_unsubscribe(){this.innerSubscription=void 0}notifyComplete(){this.innerSubscription=void 0,this.isStopped&&super._complete()}notifyNext(t){this.destination.next(t)}}const qd=(()=>{function t(){return Error.call(this),this.message="argument out of range",this.name="ArgumentOutOfRangeError",this}return t.prototype=Object.create(Error.prototype),t})();function Xd(t){return e=>0===t?Vd():e.lift(new Yd(t))}class Yd{constructor(t){if(this.total=t,this.total<0)throw new qd}call(t,e){return e.subscribe(new Kd(t,this.total))}}class Kd extends W{constructor(t,e){super(t),this.total=e,this.count=0}_next(t){const e=this.total,n=++this.count;n<=e&&(this.destination.next(t),n===e&&(this.destination.complete(),this.unsubscribe()))}}function Jd(...t){const e=t[t.length-1];return nt(e)?(t.pop(),n=>Ud(t,n,e)):e=>Ud(t,e)}function Zd(t,e){let n=!1;return arguments.length>=2&&(n=!0),function(i){return i.lift(new tp(t,e,n))}}class tp{constructor(t,e,n=!1){this.accumulator=t,this.seed=e,this.hasSeed=n}call(t,e){return e.subscribe(new ep(t,this.accumulator,this.seed,this.hasSeed))}}class ep extends W{constructor(t,e,n,i){super(t),this.accumulator=e,this._seed=n,this.hasSeed=i,this.index=0}get seed(){return this._seed}set seed(t){this.hasSeed=!0,this._seed=t}_next(t){if(this.hasSeed)return this._tryNext(t);this.seed=t,this.destination.next(t)}_tryNext(t){const e=this.index++;let n;try{n=this.accumulator(this.seed,t,e)}catch(i){this.destination.error(i)}this.seed=n,this.destination.next(n)}}function np(t,e){return function(n){return n.lift(new ip(t,e))}}class ip{constructor(t,e){this.predicate=t,this.thisArg=e}call(t,e){return e.subscribe(new rp(t,this.predicate,this.thisArg))}}class rp extends W{constructor(t,e,n){super(t),this.predicate=e,this.thisArg=n,this.count=0}_next(t){let e;try{e=this.predicate.call(this.thisArg,t,this.count++)}catch(n){return void this.destination.error(n)}e&&this.destination.next(t)}}function sp(t){return function(e){const n=new op(t),i=e.lift(n);return n.caught=i}}class op{constructor(t){this.selector=t}call(t,e){return e.subscribe(new ap(t,this.selector,this.caught))}}class ap extends mt{constructor(t,e,n){super(t),this.selector=e,this.caught=n}error(t){if(!this.isStopped){let n;try{n=this.selector(t,this.caught)}catch(e){return void super.error(e)}this._unsubscribeAndRecycle();const i=new ft(this);this.add(i);const r=gt(n,i);r!==i&&this.add(r)}}}function lp(t,e){return yt(t,e,1)}function cp(t){return function(e){return 0===t?Vd():e.lift(new up(t))}}class up{constructor(t){if(this.total=t,this.total<0)throw new qd}call(t,e){return e.subscribe(new hp(t,this.total))}}class hp extends W{constructor(t,e){super(t),this.total=e,this.ring=new Array,this.count=0}_next(t){const e=this.ring,n=this.total,i=this.count++;e.length<n?e.push(t):e[i%n]=t}_complete(){const t=this.destination;let e=this.count;if(e>0){const n=this.count>=this.total?this.total:this.count,i=this.ring;for(let r=0;r<n;r++){const r=e++%n;t.next(i[r])}}t.complete()}}function dp(t=mp){return e=>e.lift(new pp(t))}class pp{constructor(t){this.errorFactory=t}call(t,e){return e.subscribe(new fp(t,this.errorFactory))}}class fp extends W{constructor(t,e){super(t),this.errorFactory=e,this.hasValue=!1}_next(t){this.hasValue=!0,this.destination.next(t)}_complete(){if(this.hasValue)return this.destination.complete();{let e;try{e=this.errorFactory()}catch(t){e=t}this.destination.error(e)}}}function mp(){return new zd}function gp(t=null){return e=>e.lift(new yp(t))}class yp{constructor(t){this.defaultValue=t}call(t,e){return e.subscribe(new vp(t,this.defaultValue))}}class vp extends W{constructor(t,e){super(t),this.defaultValue=e,this.isEmpty=!0}_next(t){this.isEmpty=!1,this.destination.next(t)}_complete(){this.isEmpty&&this.destination.next(this.defaultValue),this.destination.complete()}}function bp(t,e){const n=arguments.length>=2;return i=>i.pipe(t?np((e,n)=>t(e,n,i)):q,Xd(1),n?gp(e):dp(()=>new zd))}function Ap(){}function xp(t,e,n){return function(i){return i.lift(new wp(t,e,n))}}class wp{constructor(t,e,n){this.nextOrObserver=t,this.error=e,this.complete=n}call(t,e){return e.subscribe(new _p(t,this.nextOrObserver,this.error,this.complete))}}class _p extends W{constructor(t,e,n,i){super(t),this._tapNext=Ap,this._tapError=Ap,this._tapComplete=Ap,this._tapError=n||Ap,this._tapComplete=i||Ap,D(e)?(this._context=this,this._tapNext=e):e&&(this._context=e,this._tapNext=e.next||Ap,this._tapError=e.error||Ap,this._tapComplete=e.complete||Ap)}_next(t){try{this._tapNext.call(this._context,t)}catch(e){return void this.destination.error(e)}this.destination.next(t)}_error(t){try{this._tapError.call(this._context,t)}catch(t){return void this.destination.error(t)}this.destination.error(t)}_complete(){try{this._tapComplete.call(this._context)}catch(t){return void this.destination.error(t)}return this.destination.complete()}}function Sp(t){return e=>e.lift(new Ep(t))}class Ep{constructor(t){this.callback=t}call(t,e){return e.subscribe(new Cp(t,this.callback))}}class Cp extends W{constructor(t,e){super(t),this.add(new H(e))}}class Ip{constructor(t,e){this.id=t,this.url=e}}class Tp extends Ip{constructor(t,e,n="imperative",i=null){super(t,e),this.navigationTrigger=n,this.restoredState=i}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class Mp extends Ip{constructor(t,e,n){super(t,e),this.urlAfterRedirects=n}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class kp extends Ip{constructor(t,e,n){super(t,e),this.reason=n}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class Rp extends Ip{constructor(t,e,n){super(t,e),this.error=n}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class Np extends Ip{constructor(t,e,n,i){super(t,e),this.urlAfterRedirects=n,this.state=i}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Lp extends Ip{constructor(t,e,n,i){super(t,e),this.urlAfterRedirects=n,this.state=i}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Dp extends Ip{constructor(t,e,n,i,r){super(t,e),this.urlAfterRedirects=n,this.state=i,this.shouldActivate=r}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class Bp extends Ip{constructor(t,e,n,i){super(t,e),this.urlAfterRedirects=n,this.state=i}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Op extends Ip{constructor(t,e,n,i){super(t,e),this.urlAfterRedirects=n,this.state=i}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Pp{constructor(t){this.route=t}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class Fp{constructor(t){this.route=t}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class $p{constructor(t){this.snapshot=t}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class zp{constructor(t){this.snapshot=t}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Up{constructor(t){this.snapshot=t}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Hp{constructor(t){this.snapshot=t}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Vp{constructor(t,e,n){this.routerEvent=t,this.position=e,this.anchor=n}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}const Gp="primary";class Wp{constructor(t){this.params=t||{}}has(t){return Object.prototype.hasOwnProperty.call(this.params,t)}get(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e[0]:e}return null}getAll(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function jp(t){return new Wp(t)}function Qp(t){const e=Error("NavigationCancelingError: "+t);return e.ngNavigationCancelingError=!0,e}function qp(t,e,n){const i=n.path.split("/");if(i.length>t.length)return null;if("full"===n.pathMatch&&(e.hasChildren()||i.length<t.length))return null;const r={};for(let s=0;s<i.length;s++){const e=i[s],n=t[s];if(e.startsWith(":"))r[e.substring(1)]=n;else if(e!==n.path)return null}return{consumed:t.slice(0,i.length),posParams:r}}function Xp(t,e){const n=t?Object.keys(t):void 0,i=e?Object.keys(e):void 0;if(!n||!i||n.length!=i.length)return!1;let r;for(let s=0;s<n.length;s++)if(r=n[s],!Yp(t[r],e[r]))return!1;return!0}function Yp(t,e){if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;const n=[...t].sort(),i=[...e].sort();return n.every((t,e)=>i[e]===t)}return t===e}function Kp(t){return Array.prototype.concat.apply([],t)}function Jp(t){return t.length>0?t[t.length-1]:null}function Zp(t,e){for(const n in t)t.hasOwnProperty(n)&&e(t[n],n)}function tf(t){return Sa(t)?t:wa(t)?pt(Promise.resolve(t)):Rd(t)}function ef(t,e,n){return n?function(t,e){return Xp(t,e)}(t.queryParams,e.queryParams)&&nf(t.root,e.root):function(t,e){return Object.keys(e).length<=Object.keys(t).length&&Object.keys(e).every(n=>Yp(t[n],e[n]))}(t.queryParams,e.queryParams)&&rf(t.root,e.root)}function nf(t,e){if(!cf(t.segments,e.segments))return!1;if(t.numberOfChildren!==e.numberOfChildren)return!1;for(const n in e.children){if(!t.children[n])return!1;if(!nf(t.children[n],e.children[n]))return!1}return!0}function rf(t,e){return sf(t,e,e.segments)}function sf(t,e,n){if(t.segments.length>n.length)return!!cf(t.segments.slice(0,n.length),n)&&!e.hasChildren();if(t.segments.length===n.length){if(!cf(t.segments,n))return!1;for(const n in e.children){if(!t.children[n])return!1;if(!rf(t.children[n],e.children[n]))return!1}return!0}{const i=n.slice(0,t.segments.length),r=n.slice(t.segments.length);return!!cf(t.segments,i)&&!!t.children.primary&&sf(t.children.primary,e,r)}}class of{constructor(t,e,n){this.root=t,this.queryParams=e,this.fragment=n}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=jp(this.queryParams)),this._queryParamMap}toString(){return df.serialize(this)}}class af{constructor(t,e){this.segments=t,this.children=e,this.parent=null,Zp(e,(t,e)=>t.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return pf(this)}}class lf{constructor(t,e){this.path=t,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=jp(this.parameters)),this._parameterMap}toString(){return Af(this)}}function cf(t,e){return t.length===e.length&&t.every((t,n)=>t.path===e[n].path)}class uf{}class hf{parse(t){const e=new Ef(t);return new of(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(t){var e;return`/${ff(t.root,!0)}${function(t){const e=Object.keys(t).map(e=>{const n=t[e];return Array.isArray(n)?n.map(t=>`${gf(e)}=${gf(t)}`).join("&"):`${gf(e)}=${gf(n)}`});return e.length?`?${e.join("&")}`:""}(t.queryParams)}${"string"==typeof t.fragment?`#${e=t.fragment,encodeURI(e)}`:""}`}}const df=new hf;function pf(t){return t.segments.map(t=>Af(t)).join("/")}function ff(t,e){if(!t.hasChildren())return pf(t);if(e){const e=t.children.primary?ff(t.children.primary,!1):"",n=[];return Zp(t.children,(t,e)=>{e!==Gp&&n.push(`${e}:${ff(t,!1)}`)}),n.length>0?`${e}(${n.join("//")})`:e}{const e=function(t,e){let n=[];return Zp(t.children,(t,i)=>{i===Gp&&(n=n.concat(e(t,i)))}),Zp(t.children,(t,i)=>{i!==Gp&&(n=n.concat(e(t,i)))}),n}(t,(e,n)=>n===Gp?[ff(t.children.primary,!1)]:[`${n}:${ff(e,!1)}`]);return 1===Object.keys(t.children).length&&null!=t.children.primary?`${pf(t)}/${e[0]}`:`${pf(t)}/(${e.join("//")})`}}function mf(t){return encodeURIComponent(t).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function gf(t){return mf(t).replace(/%3B/gi,";")}function yf(t){return mf(t).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function vf(t){return decodeURIComponent(t)}function bf(t){return vf(t.replace(/\+/g,"%20"))}function Af(t){return`${yf(t.path)}${e=t.parameters,Object.keys(e).map(t=>`;${yf(t)}=${yf(e[t])}`).join("")}`;var e}const xf=/^[^\/()?;=#]+/;function wf(t){const e=t.match(xf);return e?e[0]:""}const _f=/^[^=?&#]+/,Sf=/^[^?&#]+/;class Ef{constructor(t){this.url=t,this.remaining=t}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new af([],{}):new af([],this.parseChildren())}parseQueryParams(){const t={};if(this.consumeOptional("?"))do{this.parseQueryParam(t)}while(this.consumeOptional("&"));return t}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const t=[];for(this.peekStartsWith("(")||t.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),t.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let n={};return this.peekStartsWith("(")&&(n=this.parseParens(!1)),(t.length>0||Object.keys(e).length>0)&&(n.primary=new af(t,e)),n}parseSegment(){const t=wf(this.remaining);if(""===t&&this.peekStartsWith(";"))throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`);return this.capture(t),new lf(vf(t),this.parseMatrixParams())}parseMatrixParams(){const t={};for(;this.consumeOptional(";");)this.parseParam(t);return t}parseParam(t){const e=wf(this.remaining);if(!e)return;this.capture(e);let n="";if(this.consumeOptional("=")){const t=wf(this.remaining);t&&(n=t,this.capture(n))}t[vf(e)]=vf(n)}parseQueryParam(t){const e=function(t){const e=t.match(_f);return e?e[0]:""}(this.remaining);if(!e)return;this.capture(e);let n="";if(this.consumeOptional("=")){const t=function(t){const e=t.match(Sf);return e?e[0]:""}(this.remaining);t&&(n=t,this.capture(n))}const i=bf(e),r=bf(n);if(t.hasOwnProperty(i)){let e=t[i];Array.isArray(e)||(e=[e],t[i]=e),e.push(r)}else t[i]=r}parseParens(t){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const n=wf(this.remaining),i=this.remaining[n.length];if("/"!==i&&")"!==i&&";"!==i)throw new Error(`Cannot parse url '${this.url}'`);let r;n.indexOf(":")>-1?(r=n.substr(0,n.indexOf(":")),this.capture(r),this.capture(":")):t&&(r=Gp);const s=this.parseChildren();e[r]=1===Object.keys(s).length?s.primary:new af([],s),this.consumeOptional("//")}return e}peekStartsWith(t){return this.remaining.startsWith(t)}consumeOptional(t){return!!this.peekStartsWith(t)&&(this.remaining=this.remaining.substring(t.length),!0)}capture(t){if(!this.consumeOptional(t))throw new Error(`Expected "${t}".`)}}class Cf{constructor(t){this._root=t}get root(){return this._root.value}parent(t){const e=this.pathFromRoot(t);return e.length>1?e[e.length-2]:null}children(t){const e=If(t,this._root);return e?e.children.map(t=>t.value):[]}firstChild(t){const e=If(t,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(t){const e=Tf(t,this._root);return e.length<2?[]:e[e.length-2].children.map(t=>t.value).filter(e=>e!==t)}pathFromRoot(t){return Tf(t,this._root).map(t=>t.value)}}function If(t,e){if(t===e.value)return e;for(const n of e.children){const e=If(t,n);if(e)return e}return null}function Tf(t,e){if(t===e.value)return[e];for(const n of e.children){const i=Tf(t,n);if(i.length)return i.unshift(e),i}return[]}class Mf{constructor(t,e){this.value=t,this.children=e}toString(){return`TreeNode(${this.value})`}}function kf(t){const e={};return t&&t.children.forEach(t=>e[t.value.outlet]=t),e}class Rf extends Cf{constructor(t,e){super(t),this.snapshot=e,Pf(this,t)}toString(){return this.snapshot.toString()}}function Nf(t,e){const n=function(t,e){const n=new Bf([],{},{},"",{},Gp,e,null,t.root,-1,{});return new Of("",new Mf(n,[]))}(t,e),i=new Nd([new lf("",{})]),r=new Nd({}),s=new Nd({}),o=new Nd({}),a=new Nd(""),l=new Lf(i,r,o,a,s,Gp,e,n.root);return l.snapshot=n.root,new Rf(new Mf(l,[]),n)}class Lf{constructor(t,e,n,i,r,s,o,a){this.url=t,this.params=e,this.queryParams=n,this.fragment=i,this.data=r,this.outlet=s,this.component=o,this._futureSnapshot=a}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(it(t=>jp(t)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(it(t=>jp(t)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function Df(t,e="emptyOnly"){const n=t.pathFromRoot;let i=0;if("always"!==e)for(i=n.length-1;i>=1;){const t=n[i],e=n[i-1];if(t.routeConfig&&""===t.routeConfig.path)i--;else{if(e.component)break;i--}}return function(t){return t.reduce((t,e)=>({params:Object.assign(Object.assign({},t.params),e.params),data:Object.assign(Object.assign({},t.data),e.data),resolve:Object.assign(Object.assign({},t.resolve),e._resolvedData)}),{params:{},data:{},resolve:{}})}(n.slice(i))}class Bf{constructor(t,e,n,i,r,s,o,a,l,c,u){this.url=t,this.params=e,this.queryParams=n,this.fragment=i,this.data=r,this.outlet=s,this.component=o,this.routeConfig=a,this._urlSegment=l,this._lastPathIndex=c,this._resolve=u}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=jp(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=jp(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(t=>t.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class Of extends Cf{constructor(t,e){super(e),this.url=t,Pf(this,e)}toString(){return Ff(this._root)}}function Pf(t,e){e.value._routerState=t,e.children.forEach(e=>Pf(t,e))}function Ff(t){const e=t.children.length>0?` { ${t.children.map(Ff).join(", ")} } `:"";return`${t.value}${e}`}function $f(t){if(t.snapshot){const e=t.snapshot,n=t._futureSnapshot;t.snapshot=n,Xp(e.queryParams,n.queryParams)||t.queryParams.next(n.queryParams),e.fragment!==n.fragment&&t.fragment.next(n.fragment),Xp(e.params,n.params)||t.params.next(n.params),function(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;++n)if(!Xp(t[n],e[n]))return!1;return!0}(e.url,n.url)||t.url.next(n.url),Xp(e.data,n.data)||t.data.next(n.data)}else t.snapshot=t._futureSnapshot,t.data.next(t._futureSnapshot.data)}function zf(t,e){return Xp(t.params,e.params)&&function(t,e){return cf(t,e)&&t.every((t,n)=>Xp(t.parameters,e[n].parameters))}(t.url,e.url)&&!(!t.parent!=!e.parent)&&(!t.parent||zf(t.parent,e.parent))}function Uf(t,e,n){if(n&&t.shouldReuseRoute(e.value,n.value.snapshot)){const i=n.value;i._futureSnapshot=e.value;const r=function(t,e,n){return e.children.map(e=>{for(const i of n.children)if(t.shouldReuseRoute(e.value,i.value.snapshot))return Uf(t,e,i);return Uf(t,e)})}(t,e,n);return new Mf(i,r)}{if(t.shouldAttach(e.value)){const n=t.retrieve(e.value);if(null!==n){const t=n.route;return Hf(e,t),t}}const n=new Lf(new Nd((i=e.value).url),new Nd(i.params),new Nd(i.queryParams),new Nd(i.fragment),new Nd(i.data),i.outlet,i.component,i),r=e.children.map(e=>Uf(t,e));return new Mf(n,r)}var i}function Hf(t,e){if(t.value.routeConfig!==e.value.routeConfig)throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route");if(t.children.length!==e.children.length)throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children");e.value._futureSnapshot=t.value;for(let n=0;n<t.children.length;++n)Hf(t.children[n],e.children[n])}function Vf(t){return"object"==typeof t&&null!=t&&!t.outlets&&!t.segmentPath}function Gf(t){return"object"==typeof t&&null!=t&&t.outlets}function Wf(t,e,n,i,r){let s={};return i&&Zp(i,(t,e)=>{s[e]=Array.isArray(t)?t.map(t=>`${t}`):`${t}`}),new of(n.root===t?e:jf(n.root,t,e),s,r)}function jf(t,e,n){const i={};return Zp(t.children,(t,r)=>{i[r]=t===e?n:jf(t,e,n)}),new af(t.segments,i)}class Qf{constructor(t,e,n){if(this.isAbsolute=t,this.numberOfDoubleDots=e,this.commands=n,t&&n.length>0&&Vf(n[0]))throw new Error("Root segment cannot have matrix parameters");const i=n.find(Gf);if(i&&i!==Jp(n))throw new Error("{outlets:{}} has to be the last command")}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class qf{constructor(t,e,n){this.segmentGroup=t,this.processChildren=e,this.index=n}}function Xf(t,e,n){if(t||(t=new af([],{})),0===t.segments.length&&t.hasChildren())return Yf(t,e,n);const i=function(t,e,n){let i=0,r=e;const s={match:!1,pathIndex:0,commandIndex:0};for(;r<t.segments.length;){if(i>=n.length)return s;const e=t.segments[r],o=n[i];if(Gf(o))break;const a=`${o}`,l=i<n.length-1?n[i+1]:null;if(r>0&&void 0===a)break;if(a&&l&&"object"==typeof l&&void 0===l.outlets){if(!tm(a,l,e))return s;i+=2}else{if(!tm(a,{},e))return s;i++}r++}return{match:!0,pathIndex:r,commandIndex:i}}(t,e,n),r=n.slice(i.commandIndex);if(i.match&&i.pathIndex<t.segments.length){const e=new af(t.segments.slice(0,i.pathIndex),{});return e.children.primary=new af(t.segments.slice(i.pathIndex),t.children),Yf(e,0,r)}return i.match&&0===r.length?new af(t.segments,{}):i.match&&!t.hasChildren()?Kf(t,e,n):i.match?Yf(t,0,r):Kf(t,e,n)}function Yf(t,e,n){if(0===n.length)return new af(t.segments,{});{const i=function(t){return Gf(t[0])?t[0].outlets:{[Gp]:t}}(n),r={};return Zp(i,(n,i)=>{"string"==typeof n&&(n=[n]),null!==n&&(r[i]=Xf(t.children[i],e,n))}),Zp(t.children,(t,e)=>{void 0===i[e]&&(r[e]=t)}),new af(t.segments,r)}}function Kf(t,e,n){const i=t.segments.slice(0,e);let r=0;for(;r<n.length;){const s=n[r];if(Gf(s)){const t=Jf(s.outlets);return new af(i,t)}if(0===r&&Vf(n[0])){i.push(new lf(t.segments[e].path,Zf(n[0]))),r++;continue}const o=Gf(s)?s.outlets.primary:`${s}`,a=r<n.length-1?n[r+1]:null;o&&a&&Vf(a)?(i.push(new lf(o,Zf(a))),r+=2):(i.push(new lf(o,{})),r++)}return new af(i,{})}function Jf(t){const e={};return Zp(t,(t,n)=>{"string"==typeof t&&(t=[t]),null!==t&&(e[n]=Kf(new af([],{}),0,t))}),e}function Zf(t){const e={};return Zp(t,(t,n)=>e[n]=`${t}`),e}function tm(t,e,n){return t==n.path&&Xp(e,n.parameters)}class em{constructor(t,e,n,i){this.routeReuseStrategy=t,this.futureState=e,this.currState=n,this.forwardEvent=i}activate(t){const e=this.futureState._root,n=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,n,t),$f(this.futureState.root),this.activateChildRoutes(e,n,t)}deactivateChildRoutes(t,e,n){const i=kf(e);t.children.forEach(t=>{const e=t.value.outlet;this.deactivateRoutes(t,i[e],n),delete i[e]}),Zp(i,(t,e)=>{this.deactivateRouteAndItsChildren(t,n)})}deactivateRoutes(t,e,n){const i=t.value,r=e?e.value:null;if(i===r)if(i.component){const r=n.getContext(i.outlet);r&&this.deactivateChildRoutes(t,e,r.children)}else this.deactivateChildRoutes(t,e,n);else r&&this.deactivateRouteAndItsChildren(e,n)}deactivateRouteAndItsChildren(t,e){this.routeReuseStrategy.shouldDetach(t.value.snapshot)?this.detachAndStoreRouteSubtree(t,e):this.deactivateRouteAndOutlet(t,e)}detachAndStoreRouteSubtree(t,e){const n=e.getContext(t.value.outlet);if(n&&n.outlet){const e=n.outlet.detach(),i=n.children.onOutletDeactivated();this.routeReuseStrategy.store(t.value.snapshot,{componentRef:e,route:t,contexts:i})}}deactivateRouteAndOutlet(t,e){const n=e.getContext(t.value.outlet),i=n&&t.value.component?n.children:e,r=kf(t);for(const s of Object.keys(r))this.deactivateRouteAndItsChildren(r[s],i);n&&n.outlet&&(n.outlet.deactivate(),n.children.onOutletDeactivated(),n.attachRef=null,n.resolver=null,n.route=null)}activateChildRoutes(t,e,n){const i=kf(e);t.children.forEach(t=>{this.activateRoutes(t,i[t.value.outlet],n),this.forwardEvent(new Hp(t.value.snapshot))}),t.children.length&&this.forwardEvent(new zp(t.value.snapshot))}activateRoutes(t,e,n){const i=t.value,r=e?e.value:null;if($f(i),i===r)if(i.component){const r=n.getOrCreateContext(i.outlet);this.activateChildRoutes(t,e,r.children)}else this.activateChildRoutes(t,e,n);else if(i.component){const e=n.getOrCreateContext(i.outlet);if(this.routeReuseStrategy.shouldAttach(i.snapshot)){const t=this.routeReuseStrategy.retrieve(i.snapshot);this.routeReuseStrategy.store(i.snapshot,null),e.children.onOutletReAttached(t.contexts),e.attachRef=t.componentRef,e.route=t.route.value,e.outlet&&e.outlet.attach(t.componentRef,t.route.value),nm(t.route)}else{const n=function(t){for(let e=t.parent;e;e=e.parent){const t=e.routeConfig;if(t&&t._loadedConfig)return t._loadedConfig;if(t&&t.component)return null}return null}(i.snapshot),r=n?n.module.componentFactoryResolver:null;e.attachRef=null,e.route=i,e.resolver=r,e.outlet&&e.outlet.activateWith(i,r),this.activateChildRoutes(t,null,e.children)}}else this.activateChildRoutes(t,null,n)}}function nm(t){$f(t.value),t.children.forEach(nm)}class im{constructor(t,e){this.routes=t,this.module=e}}function rm(t){return"function"==typeof t}function sm(t){return t instanceof of}const om=Symbol("INITIAL_VALUE");function am(){return Wd(t=>Pd(t.map(t=>t.pipe(Xd(1),Jd(om)))).pipe(Zd((t,e)=>{let n=!1;return e.reduce((t,i,r)=>{if(t!==om)return t;if(i===om&&(n=!0),!n){if(!1===i)return i;if(r===e.length-1||sm(i))return i}return t},t)},om),np(t=>t!==om),it(t=>sm(t)?t:!0===t),Xd(1)))}let lm=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=Se({type:t,selectors:[["ng-component"]],decls:1,vars:0,template:function(t,e){1&t&&va(0,"router-outlet")},directives:function(){return[tg]},encapsulation:2}),t})();function cm(t,e=""){for(let n=0;n<t.length;n++){const i=t[n];um(i,hm(e,i))}}function um(t,e){t.children&&cm(t.children,e)}function hm(t,e){return e?t||e.path?t&&!e.path?`${t}/`:!t&&e.path?e.path:`${t}/${e.path}`:"":t}function dm(t){const e=t.children&&t.children.map(dm),n=e?Object.assign(Object.assign({},t),{children:e}):Object.assign({},t);return!n.component&&(e||n.loadChildren)&&n.outlet&&n.outlet!==Gp&&(n.component=lm),n}function pm(t){return t.outlet||Gp}function fm(t,e){const n=t.filter(t=>pm(t)===e);return n.push(...t.filter(t=>pm(t)!==e)),n}const mm={matched:!1,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};function gm(t,e,n){var i;if(""===e.path)return"full"===e.pathMatch&&(t.hasChildren()||n.length>0)?Object.assign({},mm):{matched:!0,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};const r=(e.matcher||qp)(n,t,e);if(!r)return Object.assign({},mm);const s={};Zp(r.posParams,(t,e)=>{s[e]=t.path});const o=r.consumed.length>0?Object.assign(Object.assign({},s),r.consumed[r.consumed.length-1].parameters):s;return{matched:!0,consumedSegments:r.consumed,lastChild:r.consumed.length,parameters:o,positionalParamSegments:null!==(i=r.posParams)&&void 0!==i?i:{}}}function ym(t,e,n,i,r="corrected"){if(n.length>0&&function(t,e,n){return n.some(n=>vm(t,e,n)&&pm(n)!==Gp)}(t,n,i)){const r=new af(e,function(t,e,n,i){const r={};r.primary=i,i._sourceSegment=t,i._segmentIndexShift=e.length;for(const s of n)if(""===s.path&&pm(s)!==Gp){const n=new af([],{});n._sourceSegment=t,n._segmentIndexShift=e.length,r[pm(s)]=n}return r}(t,e,i,new af(n,t.children)));return r._sourceSegment=t,r._segmentIndexShift=e.length,{segmentGroup:r,slicedSegments:[]}}if(0===n.length&&function(t,e,n){return n.some(n=>vm(t,e,n))}(t,n,i)){const s=new af(t.segments,function(t,e,n,i,r,s){const o={};for(const a of i)if(vm(t,n,a)&&!r[pm(a)]){const n=new af([],{});n._sourceSegment=t,n._segmentIndexShift="legacy"===s?t.segments.length:e.length,o[pm(a)]=n}return Object.assign(Object.assign({},r),o)}(t,e,n,i,t.children,r));return s._sourceSegment=t,s._segmentIndexShift=e.length,{segmentGroup:s,slicedSegments:n}}const s=new af(t.segments,t.children);return s._sourceSegment=t,s._segmentIndexShift=e.length,{segmentGroup:s,slicedSegments:n}}function vm(t,e,n){return(!(t.hasChildren()||e.length>0)||"full"!==n.pathMatch)&&""===n.path}function bm(t,e,n,i){return!!(pm(t)===i||i!==Gp&&vm(e,n,t))&&("**"===t.path||gm(e,t,n).matched)}function Am(t,e,n){return 0===e.length&&!t.children[n]}class xm{constructor(t){this.segmentGroup=t||null}}class wm{constructor(t){this.urlTree=t}}function _m(t){return new X(e=>e.error(new xm(t)))}function Sm(t){return new X(e=>e.error(new wm(t)))}function Em(t){return new X(e=>e.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${t}'`)))}class Cm{constructor(t,e,n,i,r){this.configLoader=e,this.urlSerializer=n,this.urlTree=i,this.config=r,this.allowRedirects=!0,this.ngModule=t.get(lc)}apply(){const t=ym(this.urlTree.root,[],[],this.config).segmentGroup,e=new af(t.segments,t.children);return this.expandSegmentGroup(this.ngModule,this.config,e,Gp).pipe(it(t=>this.createUrlTree(Im(t),this.urlTree.queryParams,this.urlTree.fragment))).pipe(sp(t=>{if(t instanceof wm)return this.allowRedirects=!1,this.match(t.urlTree);if(t instanceof xm)throw this.noMatchError(t);throw t}))}match(t){return this.expandSegmentGroup(this.ngModule,this.config,t.root,Gp).pipe(it(e=>this.createUrlTree(Im(e),t.queryParams,t.fragment))).pipe(sp(t=>{if(t instanceof xm)throw this.noMatchError(t);throw t}))}noMatchError(t){return new Error(`Cannot match any routes. URL Segment: '${t.segmentGroup}'`)}createUrlTree(t,e,n){const i=t.segments.length>0?new af([],{[Gp]:t}):t;return new of(i,e,n)}expandSegmentGroup(t,e,n,i){return 0===n.segments.length&&n.hasChildren()?this.expandChildren(t,e,n).pipe(it(t=>new af([],t))):this.expandSegment(t,n,e,n.segments,i,!0)}expandChildren(t,e,n){const i=[];for(const r of Object.keys(n.children))"primary"===r?i.unshift(r):i.push(r);return pt(i).pipe(lp(i=>{const r=n.children[i],s=fm(e,i);return this.expandSegmentGroup(t,s,r,i).pipe(it(t=>({segment:t,outlet:i})))}),Zd((t,e)=>(t[e.outlet]=e.segment,t),{}),function(t,e){const n=arguments.length>=2;return i=>i.pipe(t?np((e,n)=>t(e,n,i)):q,cp(1),n?gp(e):dp(()=>new zd))}())}expandSegment(t,e,n,i,r,s){return pt(n).pipe(lp(o=>this.expandSegmentAgainstRoute(t,e,n,o,i,r,s).pipe(sp(t=>{if(t instanceof xm)return Rd(null);throw t}))),bp(t=>!!t),sp((t,n)=>{if(t instanceof zd||"EmptyError"===t.name){if(Am(e,i,r))return Rd(new af([],{}));throw new xm(e)}throw t}))}expandSegmentAgainstRoute(t,e,n,i,r,s,o){return bm(i,e,r,s)?void 0===i.redirectTo?this.matchSegmentAgainstRoute(t,e,i,r,s):o&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(t,e,n,i,r,s):_m(e):_m(e)}expandSegmentAgainstRouteUsingRedirect(t,e,n,i,r,s){return"**"===i.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(t,n,i,s):this.expandRegularSegmentAgainstRouteUsingRedirect(t,e,n,i,r,s)}expandWildCardWithParamsAgainstRouteUsingRedirect(t,e,n,i){const r=this.applyRedirectCommands([],n.redirectTo,{});return n.redirectTo.startsWith("/")?Sm(r):this.lineralizeSegments(n,r).pipe(yt(n=>{const r=new af(n,{});return this.expandSegment(t,r,e,n,i,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(t,e,n,i,r,s){const{matched:o,consumedSegments:a,lastChild:l,positionalParamSegments:c}=gm(e,i,r);if(!o)return _m(e);const u=this.applyRedirectCommands(a,i.redirectTo,c);return i.redirectTo.startsWith("/")?Sm(u):this.lineralizeSegments(i,u).pipe(yt(i=>this.expandSegment(t,e,n,i.concat(r.slice(l)),s,!1)))}matchSegmentAgainstRoute(t,e,n,i,r){if("**"===n.path)return n.loadChildren?(n._loadedConfig?Rd(n._loadedConfig):this.configLoader.load(t.injector,n)).pipe(it(t=>(n._loadedConfig=t,new af(i,{})))):Rd(new af(i,{}));const{matched:s,consumedSegments:o,lastChild:a}=gm(e,n,i);if(!s)return _m(e);const l=i.slice(a);return this.getChildConfig(t,n,i).pipe(yt(t=>{const i=t.module,s=t.routes,{segmentGroup:a,slicedSegments:c}=ym(e,o,l,s),u=new af(a.segments,a.children);if(0===c.length&&u.hasChildren())return this.expandChildren(i,s,u).pipe(it(t=>new af(o,t)));if(0===s.length&&0===c.length)return Rd(new af(o,{}));const h=pm(n)===r;return this.expandSegment(i,u,s,c,h?Gp:r,!0).pipe(it(t=>new af(o.concat(t.segments),t.children)))}))}getChildConfig(t,e,n){return e.children?Rd(new im(e.children,t)):e.loadChildren?void 0!==e._loadedConfig?Rd(e._loadedConfig):this.runCanLoadGuards(t.injector,e,n).pipe(yt(n=>n?this.configLoader.load(t.injector,e).pipe(it(t=>(e._loadedConfig=t,t))):function(t){return new X(e=>e.error(Qp(`Cannot load children because the guard of the route "path: '${t.path}'" returned false`)))}(e))):Rd(new im([],t))}runCanLoadGuards(t,e,n){const i=e.canLoad;return i&&0!==i.length?Rd(i.map(i=>{const r=t.get(i);let s;if(function(t){return t&&rm(t.canLoad)}(r))s=r.canLoad(e,n);else{if(!rm(r))throw new Error("Invalid CanLoad guard");s=r(e,n)}return tf(s)})).pipe(am(),xp(t=>{if(!sm(t))return;const e=Qp(`Redirecting to "${this.urlSerializer.serialize(t)}"`);throw e.url=t,e}),it(t=>!0===t)):Rd(!0)}lineralizeSegments(t,e){let n=[],i=e.root;for(;;){if(n=n.concat(i.segments),0===i.numberOfChildren)return Rd(n);if(i.numberOfChildren>1||!i.children.primary)return Em(t.redirectTo);i=i.children.primary}}applyRedirectCommands(t,e,n){return this.applyRedirectCreatreUrlTree(e,this.urlSerializer.parse(e),t,n)}applyRedirectCreatreUrlTree(t,e,n,i){const r=this.createSegmentGroup(t,e.root,n,i);return new of(r,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(t,e){const n={};return Zp(t,(t,i)=>{if("string"==typeof t&&t.startsWith(":")){const r=t.substring(1);n[i]=e[r]}else n[i]=t}),n}createSegmentGroup(t,e,n,i){const r=this.createSegments(t,e.segments,n,i);let s={};return Zp(e.children,(e,r)=>{s[r]=this.createSegmentGroup(t,e,n,i)}),new af(r,s)}createSegments(t,e,n,i){return e.map(e=>e.path.startsWith(":")?this.findPosParam(t,e,i):this.findOrReturn(e,n))}findPosParam(t,e,n){const i=n[e.path.substring(1)];if(!i)throw new Error(`Cannot redirect to '${t}'. Cannot find '${e.path}'.`);return i}findOrReturn(t,e){let n=0;for(const i of e){if(i.path===t.path)return e.splice(n),i;n++}return t}}function Im(t){const e={};for(const n of Object.keys(t.children)){const i=Im(t.children[n]);(i.segments.length>0||i.hasChildren())&&(e[n]=i)}return function(t){if(1===t.numberOfChildren&&t.children.primary){const e=t.children.primary;return new af(t.segments.concat(e.segments),e.children)}return t}(new af(t.segments,e))}class Tm{constructor(t){this.path=t,this.route=this.path[this.path.length-1]}}class Mm{constructor(t,e){this.component=t,this.route=e}}function km(t,e,n){const i=t._root;return Nm(i,e?e._root:null,n,[i.value])}function Rm(t,e,n){const i=function(t){if(!t)return null;for(let e=t.parent;e;e=e.parent){const t=e.routeConfig;if(t&&t._loadedConfig)return t._loadedConfig}return null}(e);return(i?i.module.injector:n).get(t)}function Nm(t,e,n,i,r={canDeactivateChecks:[],canActivateChecks:[]}){const s=kf(e);return t.children.forEach(t=>{!function(t,e,n,i,r={canDeactivateChecks:[],canActivateChecks:[]}){const s=t.value,o=e?e.value:null,a=n?n.getContext(t.value.outlet):null;if(o&&s.routeConfig===o.routeConfig){const l=function(t,e,n){if("function"==typeof n)return n(t,e);switch(n){case"pathParamsChange":return!cf(t.url,e.url);case"pathParamsOrQueryParamsChange":return!cf(t.url,e.url)||!Xp(t.queryParams,e.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!zf(t,e)||!Xp(t.queryParams,e.queryParams);case"paramsChange":default:return!zf(t,e)}}(o,s,s.routeConfig.runGuardsAndResolvers);l?r.canActivateChecks.push(new Tm(i)):(s.data=o.data,s._resolvedData=o._resolvedData),Nm(t,e,s.component?a?a.children:null:n,i,r),l&&a&&a.outlet&&a.outlet.isActivated&&r.canDeactivateChecks.push(new Mm(a.outlet.component,o))}else o&&Lm(e,a,r),r.canActivateChecks.push(new Tm(i)),Nm(t,null,s.component?a?a.children:null:n,i,r)}(t,s[t.value.outlet],n,i.concat([t.value]),r),delete s[t.value.outlet]}),Zp(s,(t,e)=>Lm(t,n.getContext(e),r)),r}function Lm(t,e,n){const i=kf(t),r=t.value;Zp(i,(t,i)=>{Lm(t,r.component?e?e.children.getContext(i):null:e,n)}),n.canDeactivateChecks.push(new Mm(r.component&&e&&e.outlet&&e.outlet.isActivated?e.outlet.component:null,r))}class Dm{}function Bm(t){return new X(e=>e.error(t))}class Om{constructor(t,e,n,i,r,s){this.rootComponentType=t,this.config=e,this.urlTree=n,this.url=i,this.paramsInheritanceStrategy=r,this.relativeLinkResolution=s}recognize(){const t=ym(this.urlTree.root,[],[],this.config.filter(t=>void 0===t.redirectTo),this.relativeLinkResolution).segmentGroup,e=this.processSegmentGroup(this.config,t,Gp);if(null===e)return null;const n=new Bf([],Object.freeze({}),Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,{},Gp,this.rootComponentType,null,this.urlTree.root,-1,{}),i=new Mf(n,e),r=new Of(this.url,i);return this.inheritParamsAndData(r._root),r}inheritParamsAndData(t){const e=t.value,n=Df(e,this.paramsInheritanceStrategy);e.params=Object.freeze(n.params),e.data=Object.freeze(n.data),t.children.forEach(t=>this.inheritParamsAndData(t))}processSegmentGroup(t,e,n){return 0===e.segments.length&&e.hasChildren()?this.processChildren(t,e):this.processSegment(t,e,e.segments,n)}processChildren(t,e){const n=[];for(const r of Object.keys(e.children)){const i=e.children[r],s=fm(t,r),o=this.processSegmentGroup(s,i,r);if(null===o)return null;n.push(...o)}const i=Fm(n);return i.sort((t,e)=>t.value.outlet===Gp?-1:e.value.outlet===Gp?1:t.value.outlet.localeCompare(e.value.outlet)),i}processSegment(t,e,n,i){for(const r of t){const t=this.processSegmentAgainstRoute(r,e,n,i);if(null!==t)return t}return Am(e,n,i)?[]:null}processSegmentAgainstRoute(t,e,n,i){if(t.redirectTo||!bm(t,e,n,i))return null;let r,s=[],o=[];if("**"===t.path){const i=n.length>0?Jp(n).parameters:{};r=new Bf(n,i,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,Um(t),pm(t),t.component,t,$m(e),zm(e)+n.length,Hm(t))}else{const i=gm(e,t,n);if(!i.matched)return null;s=i.consumedSegments,o=n.slice(i.lastChild),r=new Bf(s,i.parameters,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,Um(t),pm(t),t.component,t,$m(e),zm(e)+s.length,Hm(t))}const a=function(t){return t.children?t.children:t.loadChildren?t._loadedConfig.routes:[]}(t),{segmentGroup:l,slicedSegments:c}=ym(e,s,o,a.filter(t=>void 0===t.redirectTo),this.relativeLinkResolution);if(0===c.length&&l.hasChildren()){const t=this.processChildren(a,l);return null===t?null:[new Mf(r,t)]}if(0===a.length&&0===c.length)return[new Mf(r,[])];const u=pm(t)===i,h=this.processSegment(a,l,c,u?Gp:i);return null===h?null:[new Mf(r,h)]}}function Pm(t){const e=t.value.routeConfig;return e&&""===e.path&&void 0===e.redirectTo}function Fm(t){const e=[],n=new Set;for(const i of t){if(!Pm(i)){e.push(i);continue}const t=e.find(t=>i.value.routeConfig===t.value.routeConfig);void 0!==t?(t.children.push(...i.children),n.add(t)):e.push(i)}for(const i of n){const t=Fm(i.children);e.push(new Mf(i.value,t))}return e.filter(t=>!n.has(t))}function $m(t){let e=t;for(;e._sourceSegment;)e=e._sourceSegment;return e}function zm(t){let e=t,n=e._segmentIndexShift?e._segmentIndexShift:0;for(;e._sourceSegment;)e=e._sourceSegment,n+=e._segmentIndexShift?e._segmentIndexShift:0;return n-1}function Um(t){return t.data||{}}function Hm(t){return t.resolve||{}}function Vm(t){return Wd(e=>{const n=t(e);return n?pt(n).pipe(it(()=>e)):Rd(e)})}class Gm extends class{shouldDetach(t){return!1}store(t,e){}shouldAttach(t){return!1}retrieve(t){return null}shouldReuseRoute(t,e){return t.routeConfig===e.routeConfig}}{}const Wm=new Ri("ROUTES");class jm{constructor(t,e,n,i){this.loader=t,this.compiler=e,this.onLoadStartListener=n,this.onLoadEndListener=i}load(t,e){if(e._loader$)return e._loader$;this.onLoadStartListener&&this.onLoadStartListener(e);const n=this.loadModuleFactory(e.loadChildren).pipe(it(n=>{this.onLoadEndListener&&this.onLoadEndListener(e);const i=n.create(t);return new im(Kp(i.injector.get(Wm,void 0,ee.Self|ee.Optional)).map(dm),i)}),sp(t=>{throw e._loader$=void 0,t}));return e._loader$=new Ct(n,()=>new tt).pipe(_t()),e._loader$}loadModuleFactory(t){return"string"==typeof t?pt(this.loader.load(t)):tf(t()).pipe(yt(t=>t instanceof cc?Rd(t):pt(this.compiler.compileModuleAsync(t))))}}class Qm{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.children=new qm,this.attachRef=null}}class qm{constructor(){this.contexts=new Map}onChildOutletCreated(t,e){const n=this.getOrCreateContext(t);n.outlet=e,this.contexts.set(t,n)}onChildOutletDestroyed(t){const e=this.getContext(t);e&&(e.outlet=null)}onOutletDeactivated(){const t=this.contexts;return this.contexts=new Map,t}onOutletReAttached(t){this.contexts=t}getOrCreateContext(t){let e=this.getContext(t);return e||(e=new Qm,this.contexts.set(t,e)),e}getContext(t){return this.contexts.get(t)||null}}class Xm{shouldProcessUrl(t){return!0}extract(t){return t}merge(t,e){return t}}function Ym(t){throw t}function Km(t,e,n){return e.parse("/")}function Jm(t,e){return Rd(null)}let Zm=(()=>{class t{constructor(t,e,n,i,r,s,o,a){this.rootComponentType=t,this.urlSerializer=e,this.rootContexts=n,this.location=i,this.config=a,this.lastSuccessfulNavigation=null,this.currentNavigation=null,this.disposed=!1,this.lastLocationChangeInfo=null,this.navigationId=0,this.isNgZoneEnabled=!1,this.events=new tt,this.errorHandler=Ym,this.malformedUriErrorHandler=Km,this.navigated=!1,this.lastSuccessfulId=-1,this.hooks={beforePreactivation:Jm,afterPreactivation:Jm},this.urlHandlingStrategy=new Xm,this.routeReuseStrategy=new Gm,this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.relativeLinkResolution="corrected",this.ngModule=r.get(lc),this.console=r.get(ou);const l=r.get(Au);this.isNgZoneEnabled=l instanceof Au&&Au.isInAngularZone(),this.resetConfig(a),this.currentUrlTree=new of(new af([],{}),{},null),this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.configLoader=new jm(s,o,t=>this.triggerEvent(new Pp(t)),t=>this.triggerEvent(new Fp(t))),this.routerState=Nf(this.currentUrlTree,this.rootComponentType),this.transitions=new Nd({id:0,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.setupNavigations(this.transitions),this.processNavigations()}setupNavigations(t){const e=this.events;return t.pipe(np(t=>0!==t.id),it(t=>Object.assign(Object.assign({},t),{extractedUrl:this.urlHandlingStrategy.extract(t.rawUrl)})),Wd(t=>{let n=!1,i=!1;return Rd(t).pipe(xp(t=>{this.currentNavigation={id:t.id,initialUrl:t.currentRawUrl,extractedUrl:t.extractedUrl,trigger:t.source,extras:t.extras,previousNavigation:this.lastSuccessfulNavigation?Object.assign(Object.assign({},this.lastSuccessfulNavigation),{previousNavigation:null}):null}}),Wd(t=>{const n=!this.navigated||t.extractedUrl.toString()!==this.browserUrlTree.toString();if(("reload"===this.onSameUrlNavigation||n)&&this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl))return Rd(t).pipe(Wd(t=>{const n=this.transitions.getValue();return e.next(new Tp(t.id,this.serializeUrl(t.extractedUrl),t.source,t.restoredState)),n!==this.transitions.getValue()?Hd:Promise.resolve(t)}),(i=this.ngModule.injector,r=this.configLoader,s=this.urlSerializer,o=this.config,Wd(t=>function(t,e,n,i,r){return new Cm(t,e,n,i,r).apply()}(i,r,s,t.extractedUrl,o).pipe(it(e=>Object.assign(Object.assign({},t),{urlAfterRedirects:e}))))),xp(t=>{this.currentNavigation=Object.assign(Object.assign({},this.currentNavigation),{finalUrl:t.urlAfterRedirects})}),function(t,e,n,i,r){return yt(s=>function(t,e,n,i,r="emptyOnly",s="legacy"){try{const o=new Om(t,e,n,i,r,s).recognize();return null===o?Bm(new Dm):Rd(o)}catch(o){return Bm(o)}}(t,e,s.urlAfterRedirects,n(s.urlAfterRedirects),i,r).pipe(it(t=>Object.assign(Object.assign({},s),{targetSnapshot:t}))))}(this.rootComponentType,this.config,t=>this.serializeUrl(t),this.paramsInheritanceStrategy,this.relativeLinkResolution),xp(t=>{"eager"===this.urlUpdateStrategy&&(t.extras.skipLocationChange||this.setBrowserUrl(t.urlAfterRedirects,!!t.extras.replaceUrl,t.id,t.extras.state),this.browserUrlTree=t.urlAfterRedirects);const n=new Np(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);e.next(n)}));var i,r,s,o;if(n&&this.rawUrlTree&&this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)){const{id:n,extractedUrl:i,source:r,restoredState:s,extras:o}=t,a=new Tp(n,this.serializeUrl(i),r,s);e.next(a);const l=Nf(i,this.rootComponentType).snapshot;return Rd(Object.assign(Object.assign({},t),{targetSnapshot:l,urlAfterRedirects:i,extras:Object.assign(Object.assign({},o),{skipLocationChange:!1,replaceUrl:!1})}))}return this.rawUrlTree=t.rawUrl,this.browserUrlTree=t.urlAfterRedirects,t.resolve(null),Hd}),Vm(t=>{const{targetSnapshot:e,id:n,extractedUrl:i,rawUrl:r,extras:{skipLocationChange:s,replaceUrl:o}}=t;return this.hooks.beforePreactivation(e,{navigationId:n,appliedUrlTree:i,rawUrlTree:r,skipLocationChange:!!s,replaceUrl:!!o})}),xp(t=>{const e=new Lp(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);this.triggerEvent(e)}),it(t=>Object.assign(Object.assign({},t),{guards:km(t.targetSnapshot,t.currentSnapshot,this.rootContexts)})),function(t,e){return yt(n=>{const{targetSnapshot:i,currentSnapshot:r,guards:{canActivateChecks:s,canDeactivateChecks:o}}=n;return 0===o.length&&0===s.length?Rd(Object.assign(Object.assign({},n),{guardsResult:!0})):function(t,e,n,i){return pt(t).pipe(yt(t=>function(t,e,n,i,r){const s=e&&e.routeConfig?e.routeConfig.canDeactivate:null;return s&&0!==s.length?Rd(s.map(s=>{const o=Rm(s,e,r);let a;if(function(t){return t&&rm(t.canDeactivate)}(o))a=tf(o.canDeactivate(t,e,n,i));else{if(!rm(o))throw new Error("Invalid CanDeactivate guard");a=tf(o(t,e,n,i))}return a.pipe(bp())})).pipe(am()):Rd(!0)}(t.component,t.route,n,e,i)),bp(t=>!0!==t,!0))}(o,i,r,t).pipe(yt(n=>n&&"boolean"==typeof n?function(t,e,n,i){return pt(e).pipe(lp(e=>Ud(function(t,e){return null!==t&&e&&e(new $p(t)),Rd(!0)}(e.route.parent,i),function(t,e){return null!==t&&e&&e(new Up(t)),Rd(!0)}(e.route,i),function(t,e,n){const i=e[e.length-1],r=e.slice(0,e.length-1).reverse().map(t=>function(t){const e=t.routeConfig?t.routeConfig.canActivateChild:null;return e&&0!==e.length?{node:t,guards:e}:null}(t)).filter(t=>null!==t).map(e=>Gd(()=>Rd(e.guards.map(r=>{const s=Rm(r,e.node,n);let o;if(function(t){return t&&rm(t.canActivateChild)}(s))o=tf(s.canActivateChild(i,t));else{if(!rm(s))throw new Error("Invalid CanActivateChild guard");o=tf(s(i,t))}return o.pipe(bp())})).pipe(am())));return Rd(r).pipe(am())}(t,e.path,n),function(t,e,n){const i=e.routeConfig?e.routeConfig.canActivate:null;return i&&0!==i.length?Rd(i.map(i=>Gd(()=>{const r=Rm(i,e,n);let s;if(function(t){return t&&rm(t.canActivate)}(r))s=tf(r.canActivate(e,t));else{if(!rm(r))throw new Error("Invalid CanActivate guard");s=tf(r(e,t))}return s.pipe(bp())}))).pipe(am()):Rd(!0)}(t,e.route,n))),bp(t=>!0!==t,!0))}(i,s,t,e):Rd(n)),it(t=>Object.assign(Object.assign({},n),{guardsResult:t})))})}(this.ngModule.injector,t=>this.triggerEvent(t)),xp(t=>{if(sm(t.guardsResult)){const e=Qp(`Redirecting to "${this.serializeUrl(t.guardsResult)}"`);throw e.url=t.guardsResult,e}const e=new Dp(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot,!!t.guardsResult);this.triggerEvent(e)}),np(t=>{if(!t.guardsResult){this.resetUrlToCurrentUrlTree();const n=new kp(t.id,this.serializeUrl(t.extractedUrl),"");return e.next(n),t.resolve(!1),!1}return!0}),Vm(t=>{if(t.guards.canActivateChecks.length)return Rd(t).pipe(xp(t=>{const e=new Bp(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);this.triggerEvent(e)}),Wd(t=>{let n=!1;return Rd(t).pipe((i=this.paramsInheritanceStrategy,r=this.ngModule.injector,yt(t=>{const{targetSnapshot:e,guards:{canActivateChecks:n}}=t;if(!n.length)return Rd(t);let s=0;return pt(n).pipe(lp(t=>function(t,e,n,i){return function(t,e,n,i){const r=Object.keys(t);if(0===r.length)return Rd({});const s={};return pt(r).pipe(yt(r=>function(t,e,n,i){const r=Rm(t,e,i);return tf(r.resolve?r.resolve(e,n):r(e,n))}(t[r],e,n,i).pipe(xp(t=>{s[r]=t}))),cp(1),yt(()=>Object.keys(s).length===r.length?Rd(s):Hd))}(t._resolve,t,e,i).pipe(it(e=>(t._resolvedData=e,t.data=Object.assign(Object.assign({},t.data),Df(t,n).resolve),null)))}(t.route,e,i,r)),xp(()=>s++),cp(1),yt(e=>s===n.length?Rd(t):Hd))})),xp({next:()=>n=!0,complete:()=>{if(!n){const n=new kp(t.id,this.serializeUrl(t.extractedUrl),"At least one route resolver didn't emit any value.");e.next(n),t.resolve(!1)}}}));var i,r}),xp(t=>{const e=new Op(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);this.triggerEvent(e)}))}),Vm(t=>{const{targetSnapshot:e,id:n,extractedUrl:i,rawUrl:r,extras:{skipLocationChange:s,replaceUrl:o}}=t;return this.hooks.afterPreactivation(e,{navigationId:n,appliedUrlTree:i,rawUrlTree:r,skipLocationChange:!!s,replaceUrl:!!o})}),it(t=>{const e=function(t,e,n){const i=Uf(t,e._root,n?n._root:void 0);return new Rf(i,e)}(this.routeReuseStrategy,t.targetSnapshot,t.currentRouterState);return Object.assign(Object.assign({},t),{targetRouterState:e})}),xp(t=>{this.currentUrlTree=t.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,t.rawUrl),this.routerState=t.targetRouterState,"deferred"===this.urlUpdateStrategy&&(t.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,!!t.extras.replaceUrl,t.id,t.extras.state),this.browserUrlTree=t.urlAfterRedirects)}),(r=this.rootContexts,s=this.routeReuseStrategy,o=t=>this.triggerEvent(t),it(t=>(new em(s,t.targetRouterState,t.currentRouterState,o).activate(r),t))),xp({next(){n=!0},complete(){n=!0}}),Sp(()=>{if(!n&&!i){this.resetUrlToCurrentUrlTree();const n=new kp(t.id,this.serializeUrl(t.extractedUrl),`Navigation ID ${t.id} is not equal to the current navigation id ${this.navigationId}`);e.next(n),t.resolve(!1)}this.currentNavigation=null}),sp(n=>{if(i=!0,(r=n)&&r.ngNavigationCancelingError){const i=sm(n.url);i||(this.navigated=!0,this.resetStateAndUrl(t.currentRouterState,t.currentUrlTree,t.rawUrl));const r=new kp(t.id,this.serializeUrl(t.extractedUrl),n.message);e.next(r),i?setTimeout(()=>{const e=this.urlHandlingStrategy.merge(n.url,this.rawUrlTree);this.scheduleNavigation(e,"imperative",null,{skipLocationChange:t.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy},{resolve:t.resolve,reject:t.reject,promise:t.promise})},0):t.resolve(!1)}else{this.resetStateAndUrl(t.currentRouterState,t.currentUrlTree,t.rawUrl);const i=new Rp(t.id,this.serializeUrl(t.extractedUrl),n);e.next(i);try{t.resolve(this.errorHandler(n))}catch(_dt){t.reject(_dt)}}var r;return Hd}));var r,s,o}))}resetRootComponentType(t){this.rootComponentType=t,this.routerState.root.component=this.rootComponentType}getTransition(){const t=this.transitions.value;return t.urlAfterRedirects=this.browserUrlTree,t}setTransition(t){this.transitions.next(Object.assign(Object.assign({},this.getTransition()),t))}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(t=>{const e=this.extractLocationChangeInfoFromEvent(t);this.shouldScheduleNavigation(this.lastLocationChangeInfo,e)&&setTimeout(()=>{const{source:t,state:n,urlTree:i}=e,r={replaceUrl:!0};if(n){const t=Object.assign({},n);delete t.navigationId,0!==Object.keys(t).length&&(r.state=t)}this.scheduleNavigation(i,t,n,r)},0),this.lastLocationChangeInfo=e}))}extractLocationChangeInfoFromEvent(t){var e;return{source:"popstate"===t.type?"popstate":"hashchange",urlTree:this.parseUrl(t.url),state:(null===(e=t.state)||void 0===e?void 0:e.navigationId)?t.state:null,transitionId:this.getTransition().id}}shouldScheduleNavigation(t,e){if(!t)return!0;const n=e.urlTree.toString()===t.urlTree.toString();return!(e.transitionId===t.transitionId&&n&&("hashchange"===e.source&&"popstate"===t.source||"popstate"===e.source&&"hashchange"===t.source))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.currentNavigation}triggerEvent(t){this.events.next(t)}resetConfig(t){cm(t),this.config=t.map(dm),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.transitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(t,e={}){const{relativeTo:n,queryParams:i,fragment:r,queryParamsHandling:s,preserveFragment:o}=e,a=n||this.routerState.root,l=o?this.currentUrlTree.fragment:r;let c=null;switch(s){case"merge":c=Object.assign(Object.assign({},this.currentUrlTree.queryParams),i);break;case"preserve":c=this.currentUrlTree.queryParams;break;default:c=i||null}return null!==c&&(c=this.removeEmptyProps(c)),function(t,e,n,i,r){if(0===n.length)return Wf(e.root,e.root,e,i,r);const s=function(t){if("string"==typeof t[0]&&1===t.length&&"/"===t[0])return new Qf(!0,0,t);let e=0,n=!1;const i=t.reduce((t,i,r)=>{if("object"==typeof i&&null!=i){if(i.outlets){const e={};return Zp(i.outlets,(t,n)=>{e[n]="string"==typeof t?t.split("/"):t}),[...t,{outlets:e}]}if(i.segmentPath)return[...t,i.segmentPath]}return"string"!=typeof i?[...t,i]:0===r?(i.split("/").forEach((i,r)=>{0==r&&"."===i||(0==r&&""===i?n=!0:".."===i?e++:""!=i&&t.push(i))}),t):[...t,i]},[]);return new Qf(n,e,i)}(n);if(s.toRoot())return Wf(e.root,new af([],{}),e,i,r);const o=function(t,e,n){if(t.isAbsolute)return new qf(e.root,!0,0);if(-1===n.snapshot._lastPathIndex){const t=n.snapshot._urlSegment;return new qf(t,t===e.root,0)}const i=Vf(t.commands[0])?0:1;return function(t,e,n){let i=t,r=e,s=n;for(;s>r;){if(s-=r,i=i.parent,!i)throw new Error("Invalid number of '../'");r=i.segments.length}return new qf(i,!1,r-s)}(n.snapshot._urlSegment,n.snapshot._lastPathIndex+i,t.numberOfDoubleDots)}(s,e,t),a=o.processChildren?Yf(o.segmentGroup,o.index,s.commands):Xf(o.segmentGroup,o.index,s.commands);return Wf(o.segmentGroup,a,e,i,r)}(a,this.currentUrlTree,t,c,l)}navigateByUrl(t,e={skipLocationChange:!1}){const n=sm(t)?t:this.parseUrl(t),i=this.urlHandlingStrategy.merge(n,this.rawUrlTree);return this.scheduleNavigation(i,"imperative",null,e)}navigate(t,e={skipLocationChange:!1}){return function(t){for(let e=0;e<t.length;e++){const n=t[e];if(null==n)throw new Error(`The requested path contains ${n} segment at index ${e}`)}}(t),this.navigateByUrl(this.createUrlTree(t,e),e)}serializeUrl(t){return this.urlSerializer.serialize(t)}parseUrl(t){let e;try{e=this.urlSerializer.parse(t)}catch(n){e=this.malformedUriErrorHandler(n,this.urlSerializer,t)}return e}isActive(t,e){if(sm(t))return ef(this.currentUrlTree,t,e);const n=this.parseUrl(t);return ef(this.currentUrlTree,n,e)}removeEmptyProps(t){return Object.keys(t).reduce((e,n)=>{const i=t[n];return null!=i&&(e[n]=i),e},{})}processNavigations(){this.navigations.subscribe(t=>{this.navigated=!0,this.lastSuccessfulId=t.id,this.events.next(new Mp(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.currentNavigation,t.resolve(!0)},t=>{this.console.warn("Unhandled Navigation Error: ")})}scheduleNavigation(t,e,n,i,r){if(this.disposed)return Promise.resolve(!1);const s=this.getTransition(),o="imperative"!==e&&"imperative"===(null==s?void 0:s.source),a=(this.lastSuccessfulId===s.id||this.currentNavigation?s.rawUrl:s.urlAfterRedirects).toString()===t.toString();if(o&&a)return Promise.resolve(!0);let l,c,u;r?(l=r.resolve,c=r.reject,u=r.promise):u=new Promise((t,e)=>{l=t,c=e});const h=++this.navigationId;return this.setTransition({id:h,source:e,restoredState:n,currentUrlTree:this.currentUrlTree,currentRawUrl:this.rawUrlTree,rawUrl:t,extras:i,resolve:l,reject:c,promise:u,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),u.catch(t=>Promise.reject(t))}setBrowserUrl(t,e,n,i){const r=this.urlSerializer.serialize(t);i=i||{},this.location.isCurrentPathEqualTo(r)||e?this.location.replaceState(r,"",Object.assign(Object.assign({},i),{navigationId:n})):this.location.go(r,"",Object.assign(Object.assign({},i),{navigationId:n}))}resetStateAndUrl(t,e,n){this.routerState=t,this.currentUrlTree=e,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,n),this.resetUrlToCurrentUrlTree()}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",{navigationId:this.lastSuccessfulId})}}return t.\u0275fac=function(e){return new(e||t)(Xi(Li),Xi(uf),Xi(qm),Xi(fh),Xi(Xo),Xi(Vu),Xi(gu),Xi(void 0))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})(),tg=(()=>{class t{constructor(t,e,n,i,r){this.parentContexts=t,this.location=e,this.resolver=n,this.changeDetector=r,this.activated=null,this._activatedRoute=null,this.activateEvents=new Nc,this.deactivateEvents=new Nc,this.name=i||Gp,t.onChildOutletCreated(this.name,this)}ngOnDestroy(){this.parentContexts.onChildOutletDestroyed(this.name)}ngOnInit(){if(!this.activated){const t=this.parentContexts.getContext(this.name);t&&t.route&&(t.attachRef?this.attach(t.attachRef,t.route):this.activateWith(t.route,t.resolver||null))}}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Error("Outlet is not activated");return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Error("Outlet is not activated");return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Error("Outlet is not activated");this.location.detach();const t=this.activated;return this.activated=null,this._activatedRoute=null,t}attach(t,e){this.activated=t,this._activatedRoute=e,this.location.insert(t.hostView)}deactivate(){if(this.activated){const t=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(t)}}activateWith(t,e){if(this.isActivated)throw new Error("Cannot activate an already activated outlet");this._activatedRoute=t;const n=(e=e||this.resolver).resolveComponentFactory(t._futureSnapshot.routeConfig.component),i=this.parentContexts.getOrCreateContext(this.name).children,r=new eg(t,i,this.location.injector);this.activated=this.location.createComponent(n,this.location.length,r),this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return t.\u0275fac=function(e){return new(e||t)(pa(qm),pa(hc),pa(wl),Ti("name"),pa(Jl))},t.\u0275dir=ke({type:t,selectors:[["router-outlet"]],outputs:{activateEvents:"activate",deactivateEvents:"deactivate"},exportAs:["outlet"]}),t})();class eg{constructor(t,e,n){this.route=t,this.childContexts=e,this.parent=n}get(t,e){return t===Lf?this.route:t===qm?this.childContexts:this.parent.get(t,e)}}class ng{}class ig{preload(t,e){return Rd(null)}}let rg=(()=>{class t{constructor(t,e,n,i,r){this.router=t,this.injector=i,this.preloadingStrategy=r,this.loader=new jm(e,n,e=>t.triggerEvent(new Pp(e)),e=>t.triggerEvent(new Fp(e)))}setUpPreloading(){this.subscription=this.router.events.pipe(np(t=>t instanceof Mp),lp(()=>this.preload())).subscribe(()=>{})}preload(){const t=this.injector.get(lc);return this.processRoutes(t,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(t,e){const n=[];for(const i of e)if(i.loadChildren&&!i.canLoad&&i._loadedConfig){const t=i._loadedConfig;n.push(this.processRoutes(t.module,t.routes))}else i.loadChildren&&!i.canLoad?n.push(this.preloadConfig(t,i)):i.children&&n.push(this.processRoutes(t,i.children));return pt(n).pipe(At(),it(t=>{}))}preloadConfig(t,e){return this.preloadingStrategy.preload(e,()=>(e._loadedConfig?Rd(e._loadedConfig):this.loader.load(t.injector,e)).pipe(yt(t=>(e._loadedConfig=t,this.processRoutes(t.module,t.routes)))))}}return t.\u0275fac=function(e){return new(e||t)(Xi(Zm),Xi(Vu),Xi(gu),Xi(Xo),Xi(ng))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})(),sg=(()=>{class t{constructor(t,e,n={}){this.router=t,this.viewportScroller=e,this.options=n,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},n.scrollPositionRestoration=n.scrollPositionRestoration||"disabled",n.anchorScrolling=n.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(t=>{t instanceof Tp?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=t.navigationTrigger,this.restoredId=t.restoredState?t.restoredState.navigationId:0):t instanceof Mp&&(this.lastId=t.id,this.scheduleScrollEvent(t,this.router.parseUrl(t.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(t=>{t instanceof Vp&&(t.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(t.position):t.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(t.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(t,e){this.router.triggerEvent(new Vp(t,"popstate"===this.lastSource?this.store[this.restoredId]:null,e))}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return t.\u0275fac=function(e){return new(e||t)(Xi(Zm),Xi(qh),Xi(void 0))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();const og=new Ri("ROUTER_CONFIGURATION"),ag=new Ri("ROUTER_FORROOT_GUARD"),lg=[fh,{provide:uf,useClass:hf},{provide:Zm,useFactory:function(t,e,n,i,r,s,o,a={},l,c){const u=new Zm(null,t,e,n,i,r,s,Kp(o));if(l&&(u.urlHandlingStrategy=l),c&&(u.routeReuseStrategy=c),function(t,e){t.errorHandler&&(e.errorHandler=t.errorHandler),t.malformedUriErrorHandler&&(e.malformedUriErrorHandler=t.malformedUriErrorHandler),t.onSameUrlNavigation&&(e.onSameUrlNavigation=t.onSameUrlNavigation),t.paramsInheritanceStrategy&&(e.paramsInheritanceStrategy=t.paramsInheritanceStrategy),t.relativeLinkResolution&&(e.relativeLinkResolution=t.relativeLinkResolution),t.urlUpdateStrategy&&(e.urlUpdateStrategy=t.urlUpdateStrategy)}(a,u),a.enableTracing){const t=Ju();u.events.subscribe(e=>{t.logGroup(`Router Event: ${e.constructor.name}`),t.log(e.toString()),t.log(e),t.logGroupEnd()})}return u},deps:[uf,qm,fh,Xo,Vu,gu,Wm,og,[class{},new tr],[class{},new tr]]},qm,{provide:Lf,useFactory:function(t){return t.routerState.root},deps:[Zm]},{provide:Vu,useClass:ju},rg,ig,class{preload(t,e){return e().pipe(sp(()=>Rd(null)))}},{provide:og,useValue:{enableTracing:!1}}];function cg(){return new Ou("Router",Zm)}let ug=(()=>{class t{constructor(t,e){}static forRoot(e,n){return{ngModule:t,providers:[lg,fg(e),{provide:ag,useFactory:pg,deps:[[Zm,new tr,new er]]},{provide:og,useValue:n||{}},{provide:ch,useFactory:dg,deps:[th,[new Zi(hh),new tr],og]},{provide:sg,useFactory:hg,deps:[Zm,qh,og]},{provide:ng,useExisting:n&&n.preloadingStrategy?n.preloadingStrategy:ig},{provide:Ou,multi:!0,useFactory:cg},[mg,{provide:Jc,multi:!0,useFactory:gg,deps:[mg]},{provide:vg,useFactory:yg,deps:[mg]},{provide:su,multi:!0,useExisting:vg}]]}}static forChild(e){return{ngModule:t,providers:[fg(e)]}}}return t.\u0275fac=function(e){return new(e||t)(Xi(ag,8),Xi(Zm,8))},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({}),t})();function hg(t,e,n){return n.scrollOffset&&e.setOffset(n.scrollOffset),new sg(t,e,n)}function dg(t,e,n={}){return n.useHash?new ph(t,e):new dh(t,e)}function pg(t){return"guarded"}function fg(t){return[{provide:Ni,multi:!0,useValue:t},{provide:Wm,multi:!0,useValue:t}]}let mg=(()=>{class t{constructor(t){this.injector=t,this.initNavigation=!1,this.resultOfPreactivationDone=new tt}appInitializer(){return this.injector.get(nh,Promise.resolve(null)).then(()=>{let t=null;const e=new Promise(e=>t=e),n=this.injector.get(Zm),i=this.injector.get(og);return"disabled"===i.initialNavigation?(n.setUpLocationChangeListener(),t(!0)):"enabled"===i.initialNavigation||"enabledBlocking"===i.initialNavigation?(n.hooks.afterPreactivation=()=>this.initNavigation?Rd(null):(this.initNavigation=!0,t(!0),this.resultOfPreactivationDone),n.initialNavigation()):t(!0),e})}bootstrapListener(t){const e=this.injector.get(og),n=this.injector.get(rg),i=this.injector.get(sg),r=this.injector.get(Zm),s=this.injector.get(Uu);t===s.components[0]&&("enabledNonBlocking"!==e.initialNavigation&&void 0!==e.initialNavigation||r.initialNavigation(),n.setUpPreloading(),i.init(),r.resetRootComponentType(s.componentTypes[0]),this.resultOfPreactivationDone.next(null),this.resultOfPreactivationDone.complete())}}return t.\u0275fac=function(e){return new(e||t)(Xi(Xo))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();function gg(t){return t.appInitializer.bind(t)}function yg(t){return t.bootstrapListener.bind(t)}const vg=new Ri("Router Initializer");let bg=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=Se({type:t,selectors:[["app-root"]],decls:1,vars:0,template:function(t,e){1&t&&va(0,"router-outlet")},directives:[tg],styles:[""]}),t})();function Ag(t,...e){return e.length?e.some(e=>t[e]):t.altKey||t.shiftKey||t.ctrlKey||t.metaKey}class xg extends H{constructor(t,e){super()}schedule(t,e=0){return this}}class wg extends xg{constructor(t,e){super(t,e),this.scheduler=t,this.work=e,this.pending=!1}schedule(t,e=0){if(this.closed)return this;this.state=t;const n=this.id,i=this.scheduler;return null!=n&&(this.id=this.recycleAsyncId(i,n,e)),this.pending=!0,this.delay=e,this.id=this.id||this.requestAsyncId(i,this.id,e),this}requestAsyncId(t,e,n=0){return setInterval(t.flush.bind(t,this),n)}recycleAsyncId(t,e,n=0){if(null!==n&&this.delay===n&&!1===this.pending)return e;clearInterval(e)}execute(t,e){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;const n=this._execute(t,e);if(n)return n;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(t,e){let n,i=!1;try{this.work(t)}catch(r){i=!0,n=!!r&&r||new Error(r)}if(i)return this.unsubscribe(),n}_unsubscribe(){const t=this.id,e=this.scheduler,n=e.actions,i=n.indexOf(this);this.work=null,this.state=null,this.pending=!1,this.scheduler=null,-1!==i&&n.splice(i,1),null!=t&&(this.id=this.recycleAsyncId(e,t,null)),this.delay=null}}let _g=(()=>{class t{constructor(e,n=t.now){this.SchedulerAction=e,this.now=n}schedule(t,e=0,n){return new this.SchedulerAction(this,t).schedule(n,e)}}return t.now=()=>Date.now(),t})();class Sg extends _g{constructor(t,e=_g.now){super(t,()=>Sg.delegate&&Sg.delegate!==this?Sg.delegate.now():e()),this.actions=[],this.active=!1,this.scheduled=void 0}schedule(t,e=0,n){return Sg.delegate&&Sg.delegate!==this?Sg.delegate.schedule(t,e,n):super.schedule(t,e,n)}flush(t){const{actions:e}=this;if(this.active)return void e.push(t);let n;this.active=!0;do{if(n=t.execute(t.state,t.delay))break}while(t=e.shift());if(this.active=!1,n){for(;t=e.shift();)t.unsubscribe();throw n}}}const Eg=new Sg(wg);function Cg(t,e=Eg){return n=>n.lift(new Ig(t,e))}class Ig{constructor(t,e){this.dueTime=t,this.scheduler=e}call(t,e){return e.subscribe(new Tg(t,this.dueTime,this.scheduler))}}class Tg extends W{constructor(t,e,n){super(t),this.dueTime=e,this.scheduler=n,this.debouncedSubscription=null,this.lastValue=null,this.hasValue=!1}_next(t){this.clearDebounce(),this.lastValue=t,this.hasValue=!0,this.add(this.debouncedSubscription=this.scheduler.schedule(Mg,this.dueTime,this))}_complete(){this.debouncedNext(),this.destination.complete()}debouncedNext(){if(this.clearDebounce(),this.hasValue){const{lastValue:t}=this;this.lastValue=null,this.hasValue=!1,this.destination.next(t)}}clearDebounce(){const t=this.debouncedSubscription;null!==t&&(this.remove(t),t.unsubscribe(),this.debouncedSubscription=null)}}function Mg(t){t.debouncedNext()}function kg(t){return null!=t&&"false"!=`${t}`}function Rg(t,e=0){return function(t){return!isNaN(parseFloat(t))&&!isNaN(Number(t))}(t)?Number(t):e}function Ng(t){return Array.isArray(t)?t:[t]}function Lg(t){return null==t?"":"string"==typeof t?t:`${t}px`}function Dg(t){return t instanceof Cl?t.nativeElement:t}let Bg;try{Bg="undefined"!=typeof Intl&&Intl.v8BreakIterator}catch(GTt){Bg=!1}let Og,Pg,Fg,$g,zg=(()=>{class t{constructor(t){this._platformId=t,this.isBrowser=this._platformId?Qh(this._platformId):"object"==typeof document&&!!document,this.EDGE=this.isBrowser&&/(edge)/i.test(navigator.userAgent),this.TRIDENT=this.isBrowser&&/(msie|trident)/i.test(navigator.userAgent),this.BLINK=this.isBrowser&&!(!window.chrome&&!Bg)&&"undefined"!=typeof CSS&&!this.EDGE&&!this.TRIDENT,this.WEBKIT=this.isBrowser&&/AppleWebKit/i.test(navigator.userAgent)&&!this.BLINK&&!this.EDGE&&!this.TRIDENT,this.IOS=this.isBrowser&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!("MSStream"in window),this.FIREFOX=this.isBrowser&&/(firefox|minefield)/i.test(navigator.userAgent),this.ANDROID=this.isBrowser&&/android/i.test(navigator.userAgent)&&!this.TRIDENT,this.SAFARI=this.isBrowser&&/safari/i.test(navigator.userAgent)&&this.WEBKIT}}return t.\u0275fac=function(e){return new(e||t)(Xi(ru))},t.\u0275prov=Wt({factory:function(){return new t(Xi(ru))},token:t,providedIn:"root"}),t})(),Ug=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({}),t})();function Hg(t){return function(){if(null==Og&&"undefined"!=typeof window)try{window.addEventListener("test",null,Object.defineProperty({},"passive",{get:()=>Og=!0}))}finally{Og=Og||!1}return Og}()?t:!!t.capture}function Vg(){if(null==Fg){if("object"!=typeof document||!document||"function"!=typeof Element||!Element)return Fg=!1,Fg;if("scrollBehavior"in document.documentElement.style)Fg=!0;else{const t=Element.prototype.scrollTo;Fg=!!t&&!/\{\s*\[native code\]\s*\}/.test(t.toString())}}return Fg}function Gg(){if("object"!=typeof document||!document)return 0;if(null==Pg){const t=document.createElement("div"),e=t.style;t.dir="rtl",e.width="1px",e.overflow="auto",e.visibility="hidden",e.pointerEvents="none",e.position="absolute";const n=document.createElement("div"),i=n.style;i.width="2px",i.height="1px",t.appendChild(n),document.body.appendChild(t),Pg=0,0===t.scrollLeft&&(t.scrollLeft=1,Pg=0===t.scrollLeft?1:2),t.parentNode.removeChild(t)}return Pg}let Wg=(()=>{class t{create(t){return"undefined"==typeof MutationObserver?null:new MutationObserver(t)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({factory:function(){return new t},token:t,providedIn:"root"}),t})(),jg=(()=>{class t{constructor(t){this._mutationObserverFactory=t,this._observedElements=new Map}ngOnDestroy(){this._observedElements.forEach((t,e)=>this._cleanupObserver(e))}observe(t){const e=Dg(t);return new X(t=>{const n=this._observeElement(e).subscribe(t);return()=>{n.unsubscribe(),this._unobserveElement(e)}})}_observeElement(t){if(this._observedElements.has(t))this._observedElements.get(t).count++;else{const e=new tt,n=this._mutationObserverFactory.create(t=>e.next(t));n&&n.observe(t,{characterData:!0,childList:!0,subtree:!0}),this._observedElements.set(t,{observer:n,stream:e,count:1})}return this._observedElements.get(t).stream}_unobserveElement(t){this._observedElements.has(t)&&(this._observedElements.get(t).count--,this._observedElements.get(t).count||this._cleanupObserver(t))}_cleanupObserver(t){if(this._observedElements.has(t)){const{observer:e,stream:n}=this._observedElements.get(t);e&&e.disconnect(),n.complete(),this._observedElements.delete(t)}}}return t.\u0275fac=function(e){return new(e||t)(Xi(Wg))},t.\u0275prov=Wt({factory:function(){return new t(Xi(Wg))},token:t,providedIn:"root"}),t})(),Qg=(()=>{class t{constructor(t,e,n){this._contentObserver=t,this._elementRef=e,this._ngZone=n,this.event=new Nc,this._disabled=!1,this._currentSubscription=null}get disabled(){return this._disabled}set disabled(t){this._disabled=kg(t),this._disabled?this._unsubscribe():this._subscribe()}get debounce(){return this._debounce}set debounce(t){this._debounce=Rg(t),this._subscribe()}ngAfterContentInit(){this._currentSubscription||this.disabled||this._subscribe()}ngOnDestroy(){this._unsubscribe()}_subscribe(){this._unsubscribe();const t=this._contentObserver.observe(this._elementRef);this._ngZone.runOutsideAngular(()=>{this._currentSubscription=(this.debounce?t.pipe(Cg(this.debounce)):t).subscribe(this.event)})}_unsubscribe(){var t;null===(t=this._currentSubscription)||void 0===t||t.unsubscribe()}}return t.\u0275fac=function(e){return new(e||t)(pa(jg),pa(Cl),pa(Au))},t.\u0275dir=ke({type:t,selectors:[["","cdkObserveContent",""]],inputs:{disabled:["cdkObserveContentDisabled","disabled"],debounce:"debounce"},outputs:{event:"cdkObserveContent"},exportAs:["cdkObserveContent"]}),t})(),qg=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({providers:[Wg]}),t})();function Xg(t,e){return(t.getAttribute(e)||"").match(/\S+/g)||[]}const Yg="cdk-describedby-message-container",Kg="cdk-describedby-host";let Jg=0;const Zg=new Map;let ty=null,ey=(()=>{class t{constructor(t){this._document=t}describe(t,e,n){if(!this._canBeDescribed(t,e))return;const i=ny(e,n);"string"!=typeof e?(iy(e),Zg.set(i,{messageElement:e,referenceCount:0})):Zg.has(i)||this._createMessageElement(e,n),this._isElementDescribedByMessage(t,i)||this._addMessageReference(t,i)}removeDescription(t,e,n){if(!e||!this._isElementNode(t))return;const i=ny(e,n);if(this._isElementDescribedByMessage(t,i)&&this._removeMessageReference(t,i),"string"==typeof e){const t=Zg.get(i);t&&0===t.referenceCount&&this._deleteMessageElement(i)}ty&&0===ty.childNodes.length&&this._deleteMessagesContainer()}ngOnDestroy(){const t=this._document.querySelectorAll("[cdk-describedby-host]");for(let e=0;e<t.length;e++)this._removeCdkDescribedByReferenceIds(t[e]),t[e].removeAttribute(Kg);ty&&this._deleteMessagesContainer(),Zg.clear()}_createMessageElement(t,e){const n=this._document.createElement("div");iy(n),n.textContent=t,e&&n.setAttribute("role",e),this._createMessagesContainer(),ty.appendChild(n),Zg.set(ny(t,e),{messageElement:n,referenceCount:0})}_deleteMessageElement(t){const e=Zg.get(t),n=e&&e.messageElement;ty&&n&&ty.removeChild(n),Zg.delete(t)}_createMessagesContainer(){if(!ty){const t=this._document.getElementById(Yg);t&&t.parentNode&&t.parentNode.removeChild(t),ty=this._document.createElement("div"),ty.id=Yg,ty.style.visibility="hidden",ty.classList.add("cdk-visually-hidden"),this._document.body.appendChild(ty)}}_deleteMessagesContainer(){ty&&ty.parentNode&&(ty.parentNode.removeChild(ty),ty=null)}_removeCdkDescribedByReferenceIds(t){const e=Xg(t,"aria-describedby").filter(t=>0!=t.indexOf("cdk-describedby-message"));t.setAttribute("aria-describedby",e.join(" "))}_addMessageReference(t,e){const n=Zg.get(e);!function(t,e,n){const i=Xg(t,e);i.some(t=>t.trim()==n.trim())||(i.push(n.trim()),t.setAttribute(e,i.join(" ")))}(t,"aria-describedby",n.messageElement.id),t.setAttribute(Kg,""),n.referenceCount++}_removeMessageReference(t,e){const n=Zg.get(e);n.referenceCount--,function(t,e,n){const i=Xg(t,e).filter(t=>t!=n.trim());i.length?t.setAttribute(e,i.join(" ")):t.removeAttribute(e)}(t,"aria-describedby",n.messageElement.id),t.removeAttribute(Kg)}_isElementDescribedByMessage(t,e){const n=Xg(t,"aria-describedby"),i=Zg.get(e),r=i&&i.messageElement.id;return!!r&&-1!=n.indexOf(r)}_canBeDescribed(t,e){if(!this._isElementNode(t))return!1;if(e&&"object"==typeof e)return!0;const n=null==e?"":`${e}`.trim(),i=t.getAttribute("aria-label");return!(!n||i&&i.trim()===n)}_isElementNode(t){return t.nodeType===this._document.ELEMENT_NODE}}return t.\u0275fac=function(e){return new(e||t)(Xi(Zu))},t.\u0275prov=Wt({factory:function(){return new t(Xi(Zu))},token:t,providedIn:"root"}),t})();function ny(t,e){return"string"==typeof t?`${e||""}/${t}`:t}function iy(t){t.id||(t.id="cdk-describedby-message-"+Jg++)}class ry extends class{constructor(t){this._items=t,this._activeItemIndex=-1,this._activeItem=null,this._wrap=!1,this._letterKeyStream=new tt,this._typeaheadSubscription=H.EMPTY,this._vertical=!0,this._allowedModifierKeys=[],this._homeAndEnd=!1,this._skipPredicateFn=t=>t.disabled,this._pressedLetters=[],this.tabOut=new tt,this.change=new tt,t instanceof Dc&&t.changes.subscribe(t=>{if(this._activeItem){const e=t.toArray().indexOf(this._activeItem);e>-1&&e!==this._activeItemIndex&&(this._activeItemIndex=e)}})}skipPredicate(t){return this._skipPredicateFn=t,this}withWrap(t=!0){return this._wrap=t,this}withVerticalOrientation(t=!0){return this._vertical=t,this}withHorizontalOrientation(t){return this._horizontal=t,this}withAllowedModifierKeys(t){return this._allowedModifierKeys=t,this}withTypeAhead(t=200){return this._typeaheadSubscription.unsubscribe(),this._typeaheadSubscription=this._letterKeyStream.pipe(xp(t=>this._pressedLetters.push(t)),Cg(t),np(()=>this._pressedLetters.length>0),it(()=>this._pressedLetters.join(""))).subscribe(t=>{const e=this._getItemsArray();for(let n=1;n<e.length+1;n++){const i=(this._activeItemIndex+n)%e.length,r=e[i];if(!this._skipPredicateFn(r)&&0===r.getLabel().toUpperCase().trim().indexOf(t)){this.setActiveItem(i);break}}this._pressedLetters=[]}),this}withHomeAndEnd(t=!0){return this._homeAndEnd=t,this}setActiveItem(t){const e=this._activeItem;this.updateActiveItem(t),this._activeItem!==e&&this.change.next(this._activeItemIndex)}onKeydown(t){const e=t.keyCode,n=["altKey","ctrlKey","metaKey","shiftKey"].every(e=>!t[e]||this._allowedModifierKeys.indexOf(e)>-1);switch(e){case 9:return void this.tabOut.next();case 40:if(this._vertical&&n){this.setNextItemActive();break}return;case 38:if(this._vertical&&n){this.setPreviousItemActive();break}return;case 39:if(this._horizontal&&n){"rtl"===this._horizontal?this.setPreviousItemActive():this.setNextItemActive();break}return;case 37:if(this._horizontal&&n){"rtl"===this._horizontal?this.setNextItemActive():this.setPreviousItemActive();break}return;case 36:if(this._homeAndEnd&&n){this.setFirstItemActive();break}return;case 35:if(this._homeAndEnd&&n){this.setLastItemActive();break}return;default:return void((n||Ag(t,"shiftKey"))&&(t.key&&1===t.key.length?this._letterKeyStream.next(t.key.toLocaleUpperCase()):(e>=65&&e<=90||e>=48&&e<=57)&&this._letterKeyStream.next(String.fromCharCode(e))))}this._pressedLetters=[],t.preventDefault()}get activeItemIndex(){return this._activeItemIndex}get activeItem(){return this._activeItem}isTyping(){return this._pressedLetters.length>0}setFirstItemActive(){this._setActiveItemByIndex(0,1)}setLastItemActive(){this._setActiveItemByIndex(this._items.length-1,-1)}setNextItemActive(){this._activeItemIndex<0?this.setFirstItemActive():this._setActiveItemByDelta(1)}setPreviousItemActive(){this._activeItemIndex<0&&this._wrap?this.setLastItemActive():this._setActiveItemByDelta(-1)}updateActiveItem(t){const e=this._getItemsArray(),n="number"==typeof t?t:e.indexOf(t),i=e[n];this._activeItem=null==i?null:i,this._activeItemIndex=n}_setActiveItemByDelta(t){this._wrap?this._setActiveInWrapMode(t):this._setActiveInDefaultMode(t)}_setActiveInWrapMode(t){const e=this._getItemsArray();for(let n=1;n<=e.length;n++){const i=(this._activeItemIndex+t*n+e.length)%e.length;if(!this._skipPredicateFn(e[i]))return void this.setActiveItem(i)}}_setActiveInDefaultMode(t){this._setActiveItemByIndex(this._activeItemIndex+t,t)}_setActiveItemByIndex(t,e){const n=this._getItemsArray();if(n[t]){for(;this._skipPredicateFn(n[t]);)if(!n[t+=e])return;this.setActiveItem(t)}}_getItemsArray(){return this._items instanceof Dc?this._items.toArray():this._items}}{constructor(){super(...arguments),this._origin="program"}setFocusOrigin(t){return this._origin=t,this}setActiveItem(t){super.setActiveItem(t),this.activeItem&&this.activeItem.focus(this._origin)}}let sy=(()=>{class t{constructor(t){this._platform=t}isDisabled(t){return t.hasAttribute("disabled")}isVisible(t){return function(t){return!!(t.offsetWidth||t.offsetHeight||"function"==typeof t.getClientRects&&t.getClientRects().length)}(t)&&"visible"===getComputedStyle(t).visibility}isTabbable(t){if(!this._platform.isBrowser)return!1;const e=function(t){try{return t.frameElement}catch(GTt){return null}}((n=t).ownerDocument&&n.ownerDocument.defaultView||window);var n;if(e){if(-1===ay(e))return!1;if(!this.isVisible(e))return!1}let i=t.nodeName.toLowerCase(),r=ay(t);return t.hasAttribute("contenteditable")?-1!==r:"iframe"!==i&&"object"!==i&&!(this._platform.WEBKIT&&this._platform.IOS&&!function(t){let e=t.nodeName.toLowerCase(),n="input"===e&&t.type;return"text"===n||"password"===n||"select"===e||"textarea"===e}(t))&&("audio"===i?!!t.hasAttribute("controls")&&-1!==r:"video"===i?-1!==r&&(null!==r||this._platform.FIREFOX||t.hasAttribute("controls")):t.tabIndex>=0)}isFocusable(t,e){return function(t){return!function(t){return function(t){return"input"==t.nodeName.toLowerCase()}(t)&&"hidden"==t.type}(t)&&(function(t){let e=t.nodeName.toLowerCase();return"input"===e||"select"===e||"button"===e||"textarea"===e}(t)||function(t){return function(t){return"a"==t.nodeName.toLowerCase()}(t)&&t.hasAttribute("href")}(t)||t.hasAttribute("contenteditable")||oy(t))}(t)&&!this.isDisabled(t)&&((null==e?void 0:e.ignoreVisibility)||this.isVisible(t))}}return t.\u0275fac=function(e){return new(e||t)(Xi(zg))},t.\u0275prov=Wt({factory:function(){return new t(Xi(zg))},token:t,providedIn:"root"}),t})();function oy(t){if(!t.hasAttribute("tabindex")||void 0===t.tabIndex)return!1;let e=t.getAttribute("tabindex");return"-32768"!=e&&!(!e||isNaN(parseInt(e,10)))}function ay(t){if(!oy(t))return null;const e=parseInt(t.getAttribute("tabindex")||"",10);return isNaN(e)?-1:e}class ly{constructor(t,e,n,i,r=!1){this._element=t,this._checker=e,this._ngZone=n,this._document=i,this._hasAttached=!1,this.startAnchorListener=()=>this.focusLastTabbableElement(),this.endAnchorListener=()=>this.focusFirstTabbableElement(),this._enabled=!0,r||this.attachAnchors()}get enabled(){return this._enabled}set enabled(t){this._enabled=t,this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}destroy(){const t=this._startAnchor,e=this._endAnchor;t&&(t.removeEventListener("focus",this.startAnchorListener),t.parentNode&&t.parentNode.removeChild(t)),e&&(e.removeEventListener("focus",this.endAnchorListener),e.parentNode&&e.parentNode.removeChild(e)),this._startAnchor=this._endAnchor=null,this._hasAttached=!1}attachAnchors(){return!!this._hasAttached||(this._ngZone.runOutsideAngular(()=>{this._startAnchor||(this._startAnchor=this._createAnchor(),this._startAnchor.addEventListener("focus",this.startAnchorListener)),this._endAnchor||(this._endAnchor=this._createAnchor(),this._endAnchor.addEventListener("focus",this.endAnchorListener))}),this._element.parentNode&&(this._element.parentNode.insertBefore(this._startAnchor,this._element),this._element.parentNode.insertBefore(this._endAnchor,this._element.nextSibling),this._hasAttached=!0),this._hasAttached)}focusInitialElementWhenReady(){return new Promise(t=>{this._executeOnStable(()=>t(this.focusInitialElement()))})}focusFirstTabbableElementWhenReady(){return new Promise(t=>{this._executeOnStable(()=>t(this.focusFirstTabbableElement()))})}focusLastTabbableElementWhenReady(){return new Promise(t=>{this._executeOnStable(()=>t(this.focusLastTabbableElement()))})}_getRegionBoundary(t){let e=this._element.querySelectorAll(`[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`);for(let n=0;n<e.length;n++)e[n].hasAttribute(`cdk-focus-${t}`)?console.warn(`Found use of deprecated attribute 'cdk-focus-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`,e[n]):e[n].hasAttribute(`cdk-focus-region-${t}`)&&console.warn(`Found use of deprecated attribute 'cdk-focus-region-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`,e[n]);return"start"==t?e.length?e[0]:this._getFirstTabbableElement(this._element):e.length?e[e.length-1]:this._getLastTabbableElement(this._element)}focusInitialElement(){const t=this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]");if(t){if(t.hasAttribute("cdk-focus-initial")&&console.warn("Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0",t),!this._checker.isFocusable(t)){const e=this._getFirstTabbableElement(t);return null==e||e.focus(),!!e}return t.focus(),!0}return this.focusFirstTabbableElement()}focusFirstTabbableElement(){const t=this._getRegionBoundary("start");return t&&t.focus(),!!t}focusLastTabbableElement(){const t=this._getRegionBoundary("end");return t&&t.focus(),!!t}hasAttached(){return this._hasAttached}_getFirstTabbableElement(t){if(this._checker.isFocusable(t)&&this._checker.isTabbable(t))return t;let e=t.children||t.childNodes;for(let n=0;n<e.length;n++){let t=e[n].nodeType===this._document.ELEMENT_NODE?this._getFirstTabbableElement(e[n]):null;if(t)return t}return null}_getLastTabbableElement(t){if(this._checker.isFocusable(t)&&this._checker.isTabbable(t))return t;let e=t.children||t.childNodes;for(let n=e.length-1;n>=0;n--){let t=e[n].nodeType===this._document.ELEMENT_NODE?this._getLastTabbableElement(e[n]):null;if(t)return t}return null}_createAnchor(){const t=this._document.createElement("div");return this._toggleAnchorTabIndex(this._enabled,t),t.classList.add("cdk-visually-hidden"),t.classList.add("cdk-focus-trap-anchor"),t.setAttribute("aria-hidden","true"),t}_toggleAnchorTabIndex(t,e){t?e.setAttribute("tabindex","0"):e.removeAttribute("tabindex")}toggleAnchors(t){this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}_executeOnStable(t){this._ngZone.isStable?t():this._ngZone.onStable.pipe(Xd(1)).subscribe(t)}}let cy=(()=>{class t{constructor(t,e,n){this._checker=t,this._ngZone=e,this._document=n}create(t,e=!1){return new ly(t,this._checker,this._ngZone,this._document,e)}}return t.\u0275fac=function(e){return new(e||t)(Xi(sy),Xi(Au),Xi(Zu))},t.\u0275prov=Wt({factory:function(){return new t(Xi(sy),Xi(Au),Xi(Zu))},token:t,providedIn:"root"}),t})();function uy(t){return 0===t.buttons}function hy(t){const e=t.touches&&t.touches[0]||t.changedTouches&&t.changedTouches[0];return!(!e||-1!==e.identifier||null!=e.radiusX&&1!==e.radiusX||null!=e.radiusY&&1!==e.radiusY)}"undefined"!=typeof Element&&Element;const dy=new Ri("cdk-focus-monitor-default-options"),py=Hg({passive:!0,capture:!0});let fy=(()=>{class t{constructor(t,e,n,i){this._ngZone=t,this._platform=e,this._origin=null,this._windowFocused=!1,this._elementInfo=new Map,this._monitoredElementCount=0,this._rootNodeFocusListenerCount=new Map,this._documentKeydownListener=()=>{this._lastTouchTarget=null,this._setOriginForCurrentEventQueue("keyboard")},this._documentMousedownListener=t=>{if(!this._lastTouchTarget){const e=uy(t)?"keyboard":"mouse";this._setOriginForCurrentEventQueue(e)}},this._documentTouchstartListener=t=>{hy(t)?this._lastTouchTarget||this._setOriginForCurrentEventQueue("keyboard"):(null!=this._touchTimeoutId&&clearTimeout(this._touchTimeoutId),this._lastTouchTarget=my(t),this._touchTimeoutId=setTimeout(()=>this._lastTouchTarget=null,650))},this._windowFocusListener=()=>{this._windowFocused=!0,this._windowFocusTimeoutId=setTimeout(()=>this._windowFocused=!1)},this._rootNodeFocusAndBlurListener=t=>{const e=my(t),n="focus"===t.type?this._onFocus:this._onBlur;for(let i=e;i;i=i.parentElement)n.call(this,t,i)},this._document=n,this._detectionMode=(null==i?void 0:i.detectionMode)||0}monitor(t,e=!1){const n=Dg(t);if(!this._platform.isBrowser||1!==n.nodeType)return Rd(null);const i=function(t){if(function(){if(null==$g){const t="undefined"!=typeof document?document.head:null;$g=!(!t||!t.createShadowRoot&&!t.attachShadow)}return $g}()){const e=t.getRootNode?t.getRootNode():null;if("undefined"!=typeof ShadowRoot&&ShadowRoot&&e instanceof ShadowRoot)return e}return null}(n)||this._getDocument(),r=this._elementInfo.get(n);if(r)return e&&(r.checkChildren=!0),r.subject;const s={checkChildren:e,subject:new tt,rootNode:i};return this._elementInfo.set(n,s),this._registerGlobalListeners(s),s.subject}stopMonitoring(t){const e=Dg(t),n=this._elementInfo.get(e);n&&(n.subject.complete(),this._setClasses(e),this._elementInfo.delete(e),this._removeGlobalListeners(n))}focusVia(t,e,n){const i=Dg(t);i===this._getDocument().activeElement?this._getClosestElementsInfo(i).forEach(([t,n])=>this._originChanged(t,e,n)):(this._setOriginForCurrentEventQueue(e),"function"==typeof i.focus&&i.focus(n))}ngOnDestroy(){this._elementInfo.forEach((t,e)=>this.stopMonitoring(e))}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_toggleClass(t,e,n){n?t.classList.add(e):t.classList.remove(e)}_getFocusOrigin(t){return this._origin?this._origin:this._windowFocused&&this._lastFocusOrigin?this._lastFocusOrigin:this._wasCausedByTouch(t)?"touch":"program"}_setClasses(t,e){this._toggleClass(t,"cdk-focused",!!e),this._toggleClass(t,"cdk-touch-focused","touch"===e),this._toggleClass(t,"cdk-keyboard-focused","keyboard"===e),this._toggleClass(t,"cdk-mouse-focused","mouse"===e),this._toggleClass(t,"cdk-program-focused","program"===e)}_setOriginForCurrentEventQueue(t){this._ngZone.runOutsideAngular(()=>{this._origin=t,0===this._detectionMode&&(this._originTimeoutId=setTimeout(()=>this._origin=null,1))})}_wasCausedByTouch(t){const e=my(t);return this._lastTouchTarget instanceof Node&&e instanceof Node&&(e===this._lastTouchTarget||e.contains(this._lastTouchTarget))}_onFocus(t,e){const n=this._elementInfo.get(e);n&&(n.checkChildren||e===my(t))&&this._originChanged(e,this._getFocusOrigin(t),n)}_onBlur(t,e){const n=this._elementInfo.get(e);!n||n.checkChildren&&t.relatedTarget instanceof Node&&e.contains(t.relatedTarget)||(this._setClasses(e),this._emitOrigin(n.subject,null))}_emitOrigin(t,e){this._ngZone.run(()=>t.next(e))}_registerGlobalListeners(t){if(!this._platform.isBrowser)return;const e=t.rootNode,n=this._rootNodeFocusListenerCount.get(e)||0;n||this._ngZone.runOutsideAngular(()=>{e.addEventListener("focus",this._rootNodeFocusAndBlurListener,py),e.addEventListener("blur",this._rootNodeFocusAndBlurListener,py)}),this._rootNodeFocusListenerCount.set(e,n+1),1==++this._monitoredElementCount&&this._ngZone.runOutsideAngular(()=>{const t=this._getDocument(),e=this._getWindow();t.addEventListener("keydown",this._documentKeydownListener,py),t.addEventListener("mousedown",this._documentMousedownListener,py),t.addEventListener("touchstart",this._documentTouchstartListener,py),e.addEventListener("focus",this._windowFocusListener)})}_removeGlobalListeners(t){const e=t.rootNode;if(this._rootNodeFocusListenerCount.has(e)){const t=this._rootNodeFocusListenerCount.get(e);t>1?this._rootNodeFocusListenerCount.set(e,t-1):(e.removeEventListener("focus",this._rootNodeFocusAndBlurListener,py),e.removeEventListener("blur",this._rootNodeFocusAndBlurListener,py),this._rootNodeFocusListenerCount.delete(e))}if(!--this._monitoredElementCount){const t=this._getDocument(),e=this._getWindow();t.removeEventListener("keydown",this._documentKeydownListener,py),t.removeEventListener("mousedown",this._documentMousedownListener,py),t.removeEventListener("touchstart",this._documentTouchstartListener,py),e.removeEventListener("focus",this._windowFocusListener),clearTimeout(this._windowFocusTimeoutId),clearTimeout(this._touchTimeoutId),clearTimeout(this._originTimeoutId)}}_originChanged(t,e,n){this._setClasses(t,e),this._emitOrigin(n.subject,e),this._lastFocusOrigin=e}_getClosestElementsInfo(t){const e=[];return this._elementInfo.forEach((n,i)=>{(i===t||n.checkChildren&&i.contains(t))&&e.push([i,n])}),e}}return t.\u0275fac=function(e){return new(e||t)(Xi(Au),Xi(zg),Xi(Zu,8),Xi(dy,8))},t.\u0275prov=Wt({factory:function(){return new t(Xi(Au),Xi(zg),Xi(Zu,8),Xi(dy,8))},token:t,providedIn:"root"}),t})();function my(t){return t.composedPath?t.composedPath()[0]:t.target}let gy=(()=>{class t{constructor(t,e){this._elementRef=t,this._focusMonitor=e,this.cdkFocusChange=new Nc}ngAfterViewInit(){const t=this._elementRef.nativeElement;this._monitorSubscription=this._focusMonitor.monitor(t,1===t.nodeType&&t.hasAttribute("cdkMonitorSubtreeFocus")).subscribe(t=>this.cdkFocusChange.emit(t))}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef),this._monitorSubscription&&this._monitorSubscription.unsubscribe()}}return t.\u0275fac=function(e){return new(e||t)(pa(Cl),pa(fy))},t.\u0275dir=ke({type:t,selectors:[["","cdkMonitorElementFocus",""],["","cdkMonitorSubtreeFocus",""]],outputs:{cdkFocusChange:"cdkFocusChange"}}),t})();const yy="cdk-high-contrast-black-on-white",vy="cdk-high-contrast-white-on-black",by="cdk-high-contrast-active";let Ay=(()=>{class t{constructor(t,e){this._platform=t,this._document=e}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const t=this._document.createElement("div");t.style.backgroundColor="rgb(1,2,3)",t.style.position="absolute",this._document.body.appendChild(t);const e=this._document.defaultView||window,n=e&&e.getComputedStyle?e.getComputedStyle(t):null,i=(n&&n.backgroundColor||"").replace(/ /g,"");switch(this._document.body.removeChild(t),i){case"rgb(0,0,0)":return 2;case"rgb(255,255,255)":return 1}return 0}_applyBodyHighContrastModeCssClasses(){if(this._platform.isBrowser&&this._document.body){const t=this._document.body.classList;t.remove(by),t.remove(yy),t.remove(vy);const e=this.getHighContrastMode();1===e?(t.add(by),t.add(yy)):2===e&&(t.add(by),t.add(vy))}}}return t.\u0275fac=function(e){return new(e||t)(Xi(zg),Xi(Zu))},t.\u0275prov=Wt({factory:function(){return new t(Xi(zg),Xi(Zu))},token:t,providedIn:"root"}),t})(),xy=(()=>{class t{constructor(t){t._applyBodyHighContrastModeCssClasses()}}return t.\u0275fac=function(e){return new(e||t)(Xi(Ay))},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[[Ug,qg]]}),t})();const wy=new Ri("cdk-dir-doc",{providedIn:"root",factory:function(){return Yi(Zu)}});let _y=(()=>{class t{constructor(t){if(this.value="ltr",this.change=new Nc,t){const e=t.documentElement?t.documentElement.dir:null,n=(t.body?t.body.dir:null)||e;this.value="ltr"===n||"rtl"===n?n:"ltr"}}ngOnDestroy(){this.change.complete()}}return t.\u0275fac=function(e){return new(e||t)(Xi(wy,8))},t.\u0275prov=Wt({factory:function(){return new t(Xi(wy,8))},token:t,providedIn:"root"}),t})(),Sy=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({}),t})();const Ey=new Nl("11.2.13");class Cy{}const Iy="*";function Ty(t,e){return{type:7,name:t,definitions:e,options:{}}}function My(t,e=null){return{type:4,styles:e,timings:t}}function ky(t,e=null){return{type:2,steps:t,options:e}}function Ry(t){return{type:6,styles:t,offset:null}}function Ny(t,e,n){return{type:0,name:t,styles:e,options:n}}function Ly(t){return{type:5,steps:t}}function Dy(t,e,n=null){return{type:1,expr:t,animation:e,options:n}}function By(t){Promise.resolve(null).then(t)}class Oy{constructor(t=0,e=0){this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._started=!1,this._destroyed=!1,this._finished=!1,this._position=0,this.parentPlayer=null,this.totalTime=t+e}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}init(){}play(){this.hasStarted()||(this._onStart(),this.triggerMicrotask()),this._started=!0}triggerMicrotask(){By(()=>this._onFinish())}_onStart(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}pause(){}restart(){}finish(){this._onFinish()}destroy(){this._destroyed||(this._destroyed=!0,this.hasStarted()||this._onStart(),this.finish(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){}setPosition(t){this._position=this.totalTime?t*this.totalTime:1}getPosition(){return this.totalTime?this._position/this.totalTime:1}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}}class Py{constructor(t){this._onDoneFns=[],this._onStartFns=[],this._finished=!1,this._started=!1,this._destroyed=!1,this._onDestroyFns=[],this.parentPlayer=null,this.totalTime=0,this.players=t;let e=0,n=0,i=0;const r=this.players.length;0==r?By(()=>this._onFinish()):this.players.forEach(t=>{t.onDone(()=>{++e==r&&this._onFinish()}),t.onDestroy(()=>{++n==r&&this._onDestroy()}),t.onStart(()=>{++i==r&&this._onStart()})}),this.totalTime=this.players.reduce((t,e)=>Math.max(t,e.totalTime),0)}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this.players.forEach(t=>t.init())}onStart(t){this._onStartFns.push(t)}_onStart(){this.hasStarted()||(this._started=!0,this._onStartFns.forEach(t=>t()),this._onStartFns=[])}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}play(){this.parentPlayer||this.init(),this._onStart(),this.players.forEach(t=>t.play())}pause(){this.players.forEach(t=>t.pause())}restart(){this.players.forEach(t=>t.restart())}finish(){this._onFinish(),this.players.forEach(t=>t.finish())}destroy(){this._onDestroy()}_onDestroy(){this._destroyed||(this._destroyed=!0,this._onFinish(),this.players.forEach(t=>t.destroy()),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this.players.forEach(t=>t.reset()),this._destroyed=!1,this._finished=!1,this._started=!1}setPosition(t){const e=t*this.totalTime;this.players.forEach(t=>{const n=t.totalTime?Math.min(1,e/t.totalTime):1;t.setPosition(n)})}getPosition(){const t=this.players.reduce((t,e)=>null===t||e.totalTime>t.totalTime?e:t,null);return null!=t?t.getPosition():0}beforeDestroy(){this.players.forEach(t=>{t.beforeDestroy&&t.beforeDestroy()})}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}}function Fy(){return"undefined"!=typeof process&&"[object process]"==={}.toString.call(process)}function $y(t){switch(t.length){case 0:return new Oy;case 1:return t[0];default:return new Py(t)}}function zy(t,e,n,i,r={},s={}){const o=[],a=[];let l=-1,c=null;if(i.forEach(t=>{const n=t.offset,i=n==l,u=i&&c||{};Object.keys(t).forEach(n=>{let i=n,a=t[n];if("offset"!==n)switch(i=e.normalizePropertyName(i,o),a){case"!":a=r[n];break;case Iy:a=s[n];break;default:a=e.normalizeStyleValue(n,i,a,o)}u[i]=a}),i||a.push(u),c=u,l=n}),o.length){const t="\n - ";throw new Error(`Unable to animate due to the following errors:${t}${o.join(t)}`)}return a}function Uy(t,e,n,i){switch(e){case"start":t.onStart(()=>i(n&&Hy(n,"start",t)));break;case"done":t.onDone(()=>i(n&&Hy(n,"done",t)));break;case"destroy":t.onDestroy(()=>i(n&&Hy(n,"destroy",t)))}}function Hy(t,e,n){const i=n.totalTime,r=Vy(t.element,t.triggerName,t.fromState,t.toState,e||t.phaseName,null==i?t.totalTime:i,!!n.disabled),s=t._data;return null!=s&&(r._data=s),r}function Vy(t,e,n,i,r="",s=0,o){return{element:t,triggerName:e,fromState:n,toState:i,phaseName:r,totalTime:s,disabled:!!o}}function Gy(t,e,n){let i;return t instanceof Map?(i=t.get(e),i||t.set(e,i=n)):(i=t[e],i||(i=t[e]=n)),i}function Wy(t){const e=t.indexOf(":");return[t.substring(1,e),t.substr(e+1)]}let jy=(t,e)=>!1,Qy=(t,e)=>!1,qy=(t,e,n)=>[];const Xy=Fy();(Xy||"undefined"!=typeof Element)&&(jy=(t,e)=>t.contains(e),Qy=(()=>{if(Xy||Element.prototype.matches)return(t,e)=>t.matches(e);{const t=Element.prototype,e=t.matchesSelector||t.mozMatchesSelector||t.msMatchesSelector||t.oMatchesSelector||t.webkitMatchesSelector;return e?(t,n)=>e.apply(t,[n]):Qy}})(),qy=(t,e,n)=>{let i=[];if(n){const n=t.querySelectorAll(e);for(let t=0;t<n.length;t++)i.push(n[t])}else{const n=t.querySelector(e);n&&i.push(n)}return i});let Yy=null,Ky=!1;function Jy(t){Yy||(Yy=("undefined"!=typeof document?document.body:null)||{},Ky=!!Yy.style&&"WebkitAppearance"in Yy.style);let e=!0;return Yy.style&&!function(t){return"ebkit"==t.substring(1,6)}(t)&&(e=t in Yy.style,!e&&Ky)&&(e="Webkit"+t.charAt(0).toUpperCase()+t.substr(1)in Yy.style),e}const Zy=Qy,tv=jy,ev=qy;function nv(t){const e={};return Object.keys(t).forEach(n=>{const i=n.replace(/([a-z])([A-Z])/g,"$1-$2");e[i]=t[n]}),e}let iv=(()=>{class t{validateStyleProperty(t){return Jy(t)}matchesElement(t,e){return Zy(t,e)}containsElement(t,e){return tv(t,e)}query(t,e,n){return ev(t,e,n)}computeStyle(t,e,n){return n||""}animate(t,e,n,i,r,s=[],o){return new Oy(n,i)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})(),rv=(()=>{class t{}return t.NOOP=new iv,t})();const sv="ng-enter",ov="ng-leave",av="ng-trigger",lv=".ng-trigger",cv="ng-animating",uv=".ng-animating";function hv(t){if("number"==typeof t)return t;const e=t.match(/^(-?[\.\d]+)(m?s)/);return!e||e.length<2?0:dv(parseFloat(e[1]),e[2])}function dv(t,e){switch(e){case"s":return 1e3*t;default:return t}}function pv(t,e,n){return t.hasOwnProperty("duration")?t:function(t,e,n){let i,r=0,s="";if("string"==typeof t){const n=t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);if(null===n)return e.push(`The provided timing value "${t}" is invalid.`),{duration:0,delay:0,easing:""};i=dv(parseFloat(n[1]),n[2]);const o=n[3];null!=o&&(r=dv(parseFloat(o),n[4]));const a=n[5];a&&(s=a)}else i=t;if(!n){let n=!1,s=e.length;i<0&&(e.push("Duration values below 0 are not allowed for this animation step."),n=!0),r<0&&(e.push("Delay values below 0 are not allowed for this animation step."),n=!0),n&&e.splice(s,0,`The provided timing value "${t}" is invalid.`)}return{duration:i,delay:r,easing:s}}(t,e,n)}function fv(t,e={}){return Object.keys(t).forEach(n=>{e[n]=t[n]}),e}function mv(t,e,n={}){if(e)for(let i in t)n[i]=t[i];else fv(t,n);return n}function gv(t,e,n){return n?e+":"+n+";":""}function yv(t){let e="";for(let n=0;n<t.style.length;n++){const i=t.style.item(n);e+=gv(0,i,t.style.getPropertyValue(i))}for(const n in t.style)t.style.hasOwnProperty(n)&&!n.startsWith("_")&&(e+=gv(0,n.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase(),t.style[n]));t.setAttribute("style",e)}function vv(t,e,n){t.style&&(Object.keys(e).forEach(i=>{const r=Cv(i);n&&!n.hasOwnProperty(i)&&(n[i]=t.style[r]),t.style[r]=e[i]}),Fy()&&yv(t))}function bv(t,e){t.style&&(Object.keys(e).forEach(e=>{const n=Cv(e);t.style[n]=""}),Fy()&&yv(t))}function Av(t){return Array.isArray(t)?1==t.length?t[0]:ky(t):t}const xv=new RegExp("{{\\s*(.+?)\\s*}}","g");function wv(t){let e=[];if("string"==typeof t){let n;for(;n=xv.exec(t);)e.push(n[1]);xv.lastIndex=0}return e}function _v(t,e,n){const i=t.toString(),r=i.replace(xv,(t,i)=>{let r=e[i];return e.hasOwnProperty(i)||(n.push(`Please provide a value for the animation param ${i}`),r=""),r.toString()});return r==i?t:r}function Sv(t){const e=[];let n=t.next();for(;!n.done;)e.push(n.value),n=t.next();return e}const Ev=/-+([a-z0-9])/g;function Cv(t){return t.replace(Ev,(...t)=>t[1].toUpperCase())}function Iv(t,e){return 0===t||0===e}function Tv(t,e,n){const i=Object.keys(n);if(i.length&&e.length){let s=e[0],o=[];if(i.forEach(t=>{s.hasOwnProperty(t)||o.push(t),s[t]=n[t]}),o.length)for(var r=1;r<e.length;r++){let n=e[r];o.forEach(function(e){n[e]=kv(t,e)})}}return e}function Mv(t,e,n){switch(e.type){case 7:return t.visitTrigger(e,n);case 0:return t.visitState(e,n);case 1:return t.visitTransition(e,n);case 2:return t.visitSequence(e,n);case 3:return t.visitGroup(e,n);case 4:return t.visitAnimate(e,n);case 5:return t.visitKeyframes(e,n);case 6:return t.visitStyle(e,n);case 8:return t.visitReference(e,n);case 9:return t.visitAnimateChild(e,n);case 10:return t.visitAnimateRef(e,n);case 11:return t.visitQuery(e,n);case 12:return t.visitStagger(e,n);default:throw new Error(`Unable to resolve animation metadata node #${e.type}`)}}function kv(t,e){return window.getComputedStyle(t)[e]}const Rv="*";function Nv(t,e){const n=[];return"string"==typeof t?t.split(/\s*,\s*/).forEach(t=>function(t,e,n){if(":"==t[0]){const i=function(t,e){switch(t){case":enter":return"void => *";case":leave":return"* => void";case":increment":return(t,e)=>parseFloat(e)>parseFloat(t);case":decrement":return(t,e)=>parseFloat(e)<parseFloat(t);default:return e.push(`The transition alias value "${t}" is not supported`),"* => *"}}(t,n);if("function"==typeof i)return void e.push(i);t=i}const i=t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);if(null==i||i.length<4)return n.push(`The provided transition expression "${t}" is not supported`),e;const r=i[1],s=i[2],o=i[3];e.push(Bv(r,o)),"<"!=s[0]||r==Rv&&o==Rv||e.push(Bv(o,r))}(t,n,e)):n.push(t),n}const Lv=new Set(["true","1"]),Dv=new Set(["false","0"]);function Bv(t,e){const n=Lv.has(t)||Dv.has(t),i=Lv.has(e)||Dv.has(e);return(r,s)=>{let o=t==Rv||t==r,a=e==Rv||e==s;return!o&&n&&"boolean"==typeof r&&(o=r?Lv.has(t):Dv.has(t)),!a&&i&&"boolean"==typeof s&&(a=s?Lv.has(e):Dv.has(e)),o&&a}}const Ov=new RegExp("s*:selfs*,?","g");function Pv(t,e,n){return new Fv(t).build(e,n)}class Fv{constructor(t){this._driver=t}build(t,e){const n=new $v(e);return this._resetContextStyleTimingState(n),Mv(this,Av(t),n)}_resetContextStyleTimingState(t){t.currentQuerySelector="",t.collectedStyles={},t.collectedStyles[""]={},t.currentTime=0}visitTrigger(t,e){let n=e.queryCount=0,i=e.depCount=0;const r=[],s=[];return"@"==t.name.charAt(0)&&e.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"),t.definitions.forEach(t=>{if(this._resetContextStyleTimingState(e),0==t.type){const n=t,i=n.name;i.toString().split(/\s*,\s*/).forEach(t=>{n.name=t,r.push(this.visitState(n,e))}),n.name=i}else if(1==t.type){const r=this.visitTransition(t,e);n+=r.queryCount,i+=r.depCount,s.push(r)}else e.errors.push("only state() and transition() definitions can sit inside of a trigger()")}),{type:7,name:t.name,states:r,transitions:s,queryCount:n,depCount:i,options:null}}visitState(t,e){const n=this.visitStyle(t.styles,e),i=t.options&&t.options.params||null;if(n.containsDynamicStyles){const r=new Set,s=i||{};if(n.styles.forEach(t=>{if(zv(t)){const e=t;Object.keys(e).forEach(t=>{wv(e[t]).forEach(t=>{s.hasOwnProperty(t)||r.add(t)})})}}),r.size){const n=Sv(r.values());e.errors.push(`state("${t.name}", ...) must define default values for all the following style substitutions: ${n.join(", ")}`)}}return{type:0,name:t.name,style:n,options:i?{params:i}:null}}visitTransition(t,e){e.queryCount=0,e.depCount=0;const n=Mv(this,Av(t.animation),e);return{type:1,matchers:Nv(t.expr,e.errors),animation:n,queryCount:e.queryCount,depCount:e.depCount,options:Uv(t.options)}}visitSequence(t,e){return{type:2,steps:t.steps.map(t=>Mv(this,t,e)),options:Uv(t.options)}}visitGroup(t,e){const n=e.currentTime;let i=0;const r=t.steps.map(t=>{e.currentTime=n;const r=Mv(this,t,e);return i=Math.max(i,e.currentTime),r});return e.currentTime=i,{type:3,steps:r,options:Uv(t.options)}}visitAnimate(t,e){const n=function(t,e){let n=null;if(t.hasOwnProperty("duration"))n=t;else if("number"==typeof t)return Hv(pv(t,e).duration,0,"");const i=t;if(i.split(/\s+/).some(t=>"{"==t.charAt(0)&&"{"==t.charAt(1))){const t=Hv(0,0,"");return t.dynamic=!0,t.strValue=i,t}return n=n||pv(i,e),Hv(n.duration,n.delay,n.easing)}(t.timings,e.errors);let i;e.currentAnimateTimings=n;let r=t.styles?t.styles:Ry({});if(5==r.type)i=this.visitKeyframes(r,e);else{let r=t.styles,s=!1;if(!r){s=!0;const t={};n.easing&&(t.easing=n.easing),r=Ry(t)}e.currentTime+=n.duration+n.delay;const o=this.visitStyle(r,e);o.isEmptyStep=s,i=o}return e.currentAnimateTimings=null,{type:4,timings:n,style:i,options:null}}visitStyle(t,e){const n=this._makeStyleAst(t,e);return this._validateStyleAst(n,e),n}_makeStyleAst(t,e){const n=[];Array.isArray(t.styles)?t.styles.forEach(t=>{"string"==typeof t?t==Iy?n.push(t):e.errors.push(`The provided style string value ${t} is not allowed.`):n.push(t)}):n.push(t.styles);let i=!1,r=null;return n.forEach(t=>{if(zv(t)){const e=t,n=e.easing;if(n&&(r=n,delete e.easing),!i)for(let t in e)if(e[t].toString().indexOf("{{")>=0){i=!0;break}}}),{type:6,styles:n,easing:r,offset:t.offset,containsDynamicStyles:i,options:null}}_validateStyleAst(t,e){const n=e.currentAnimateTimings;let i=e.currentTime,r=e.currentTime;n&&r>0&&(r-=n.duration+n.delay),t.styles.forEach(t=>{"string"!=typeof t&&Object.keys(t).forEach(n=>{if(!this._driver.validateStyleProperty(n))return void e.errors.push(`The provided animation property "${n}" is not a supported CSS property for animations`);const s=e.collectedStyles[e.currentQuerySelector],o=s[n];let a=!0;o&&(r!=i&&r>=o.startTime&&i<=o.endTime&&(e.errors.push(`The CSS property "${n}" that exists between the times of "${o.startTime}ms" and "${o.endTime}ms" is also being animated in a parallel animation between the times of "${r}ms" and "${i}ms"`),a=!1),r=o.startTime),a&&(s[n]={startTime:r,endTime:i}),e.options&&function(t,e,n){const i=e.params||{},r=wv(t);r.length&&r.forEach(t=>{i.hasOwnProperty(t)||n.push(`Unable to resolve the local animation param ${t} in the given list of values`)})}(t[n],e.options,e.errors)})})}visitKeyframes(t,e){const n={type:5,styles:[],options:null};if(!e.currentAnimateTimings)return e.errors.push("keyframes() must be placed inside of a call to animate()"),n;let i=0;const r=[];let s=!1,o=!1,a=0;const l=t.steps.map(t=>{const n=this._makeStyleAst(t,e);let l=null!=n.offset?n.offset:function(t){if("string"==typeof t)return null;let e=null;if(Array.isArray(t))t.forEach(t=>{if(zv(t)&&t.hasOwnProperty("offset")){const n=t;e=parseFloat(n.offset),delete n.offset}});else if(zv(t)&&t.hasOwnProperty("offset")){const n=t;e=parseFloat(n.offset),delete n.offset}return e}(n.styles),c=0;return null!=l&&(i++,c=n.offset=l),o=o||c<0||c>1,s=s||c<a,a=c,r.push(c),n});o&&e.errors.push("Please ensure that all keyframe offsets are between 0 and 1"),s&&e.errors.push("Please ensure that all keyframe offsets are in order");const c=t.steps.length;let u=0;i>0&&i<c?e.errors.push("Not all style() steps within the declared keyframes() contain offsets"):0==i&&(u=1/(c-1));const h=c-1,d=e.currentTime,p=e.currentAnimateTimings,f=p.duration;return l.forEach((t,i)=>{const s=u>0?i==h?1:u*i:r[i],o=s*f;e.currentTime=d+p.delay+o,p.duration=o,this._validateStyleAst(t,e),t.offset=s,n.styles.push(t)}),n}visitReference(t,e){return{type:8,animation:Mv(this,Av(t.animation),e),options:Uv(t.options)}}visitAnimateChild(t,e){return e.depCount++,{type:9,options:Uv(t.options)}}visitAnimateRef(t,e){return{type:10,animation:this.visitReference(t.animation,e),options:Uv(t.options)}}visitQuery(t,e){const n=e.currentQuerySelector,i=t.options||{};e.queryCount++,e.currentQuery=t;const[r,s]=function(t){const e=!!t.split(/\s*,\s*/).find(t=>":self"==t);return e&&(t=t.replace(Ov,"")),[t=t.replace(/@\*/g,lv).replace(/@\w+/g,t=>".ng-trigger-"+t.substr(1)).replace(/:animating/g,uv),e]}(t.selector);e.currentQuerySelector=n.length?n+" "+r:r,Gy(e.collectedStyles,e.currentQuerySelector,{});const o=Mv(this,Av(t.animation),e);return e.currentQuery=null,e.currentQuerySelector=n,{type:11,selector:r,limit:i.limit||0,optional:!!i.optional,includeSelf:s,animation:o,originalSelector:t.selector,options:Uv(t.options)}}visitStagger(t,e){e.currentQuery||e.errors.push("stagger() can only be used inside of query()");const n="full"===t.timings?{duration:0,delay:0,easing:"full"}:pv(t.timings,e.errors,!0);return{type:12,animation:Mv(this,Av(t.animation),e),timings:n,options:null}}}class $v{constructor(t){this.errors=t,this.queryCount=0,this.depCount=0,this.currentTransition=null,this.currentQuery=null,this.currentQuerySelector=null,this.currentAnimateTimings=null,this.currentTime=0,this.collectedStyles={},this.options=null}}function zv(t){return!Array.isArray(t)&&"object"==typeof t}function Uv(t){var e;return t?(t=fv(t)).params&&(t.params=(e=t.params)?fv(e):null):t={},t}function Hv(t,e,n){return{duration:t,delay:e,easing:n}}function Vv(t,e,n,i,r,s,o=null,a=!1){return{type:1,element:t,keyframes:e,preStyleProps:n,postStyleProps:i,duration:r,delay:s,totalTime:r+s,easing:o,subTimeline:a}}class Gv{constructor(){this._map=new Map}consume(t){let e=this._map.get(t);return e?this._map.delete(t):e=[],e}append(t,e){let n=this._map.get(t);n||this._map.set(t,n=[]),n.push(...e)}has(t){return this._map.has(t)}clear(){this._map.clear()}}const Wv=new RegExp(":enter","g"),jv=new RegExp(":leave","g");function Qv(t,e,n,i,r,s={},o={},a,l,c=[]){return(new qv).buildKeyframes(t,e,n,i,r,s,o,a,l,c)}class qv{buildKeyframes(t,e,n,i,r,s,o,a,l,c=[]){l=l||new Gv;const u=new Yv(t,e,l,i,r,c,[]);u.options=a,u.currentTimeline.setStyles([s],null,u.errors,a),Mv(this,n,u);const h=u.timelines.filter(t=>t.containsAnimation());if(h.length&&Object.keys(o).length){const t=h[h.length-1];t.allowOnlyTimelineStyles()||t.setStyles([o],null,u.errors,a)}return h.length?h.map(t=>t.buildKeyframes()):[Vv(e,[],[],[],0,0,"",!1)]}visitTrigger(t,e){}visitState(t,e){}visitTransition(t,e){}visitAnimateChild(t,e){const n=e.subInstructions.consume(e.element);if(n){const i=e.createSubContext(t.options),r=e.currentTimeline.currentTime,s=this._visitSubInstructions(n,i,i.options);r!=s&&e.transformIntoNewTimeline(s)}e.previousNode=t}visitAnimateRef(t,e){const n=e.createSubContext(t.options);n.transformIntoNewTimeline(),this.visitReference(t.animation,n),e.transformIntoNewTimeline(n.currentTimeline.currentTime),e.previousNode=t}_visitSubInstructions(t,e,n){let i=e.currentTimeline.currentTime;const r=null!=n.duration?hv(n.duration):null,s=null!=n.delay?hv(n.delay):null;return 0!==r&&t.forEach(t=>{const n=e.appendInstructionToTimeline(t,r,s);i=Math.max(i,n.duration+n.delay)}),i}visitReference(t,e){e.updateOptions(t.options,!0),Mv(this,t.animation,e),e.previousNode=t}visitSequence(t,e){const n=e.subContextCount;let i=e;const r=t.options;if(r&&(r.params||r.delay)&&(i=e.createSubContext(r),i.transformIntoNewTimeline(),null!=r.delay)){6==i.previousNode.type&&(i.currentTimeline.snapshotCurrentStyles(),i.previousNode=Xv);const t=hv(r.delay);i.delayNextStep(t)}t.steps.length&&(t.steps.forEach(t=>Mv(this,t,i)),i.currentTimeline.applyStylesToKeyframe(),i.subContextCount>n&&i.transformIntoNewTimeline()),e.previousNode=t}visitGroup(t,e){const n=[];let i=e.currentTimeline.currentTime;const r=t.options&&t.options.delay?hv(t.options.delay):0;t.steps.forEach(s=>{const o=e.createSubContext(t.options);r&&o.delayNextStep(r),Mv(this,s,o),i=Math.max(i,o.currentTimeline.currentTime),n.push(o.currentTimeline)}),n.forEach(t=>e.currentTimeline.mergeTimelineCollectedStyles(t)),e.transformIntoNewTimeline(i),e.previousNode=t}_visitTiming(t,e){if(t.dynamic){const n=t.strValue;return pv(e.params?_v(n,e.params,e.errors):n,e.errors)}return{duration:t.duration,delay:t.delay,easing:t.easing}}visitAnimate(t,e){const n=e.currentAnimateTimings=this._visitTiming(t.timings,e),i=e.currentTimeline;n.delay&&(e.incrementTime(n.delay),i.snapshotCurrentStyles());const r=t.style;5==r.type?this.visitKeyframes(r,e):(e.incrementTime(n.duration),this.visitStyle(r,e),i.applyStylesToKeyframe()),e.currentAnimateTimings=null,e.previousNode=t}visitStyle(t,e){const n=e.currentTimeline,i=e.currentAnimateTimings;!i&&n.getCurrentStyleProperties().length&&n.forwardFrame();const r=i&&i.easing||t.easing;t.isEmptyStep?n.applyEmptyStep(r):n.setStyles(t.styles,r,e.errors,e.options),e.previousNode=t}visitKeyframes(t,e){const n=e.currentAnimateTimings,i=e.currentTimeline.duration,r=n.duration,s=e.createSubContext().currentTimeline;s.easing=n.easing,t.styles.forEach(t=>{s.forwardTime((t.offset||0)*r),s.setStyles(t.styles,t.easing,e.errors,e.options),s.applyStylesToKeyframe()}),e.currentTimeline.mergeTimelineCollectedStyles(s),e.transformIntoNewTimeline(i+r),e.previousNode=t}visitQuery(t,e){const n=e.currentTimeline.currentTime,i=t.options||{},r=i.delay?hv(i.delay):0;r&&(6===e.previousNode.type||0==n&&e.currentTimeline.getCurrentStyleProperties().length)&&(e.currentTimeline.snapshotCurrentStyles(),e.previousNode=Xv);let s=n;const o=e.invokeQuery(t.selector,t.originalSelector,t.limit,t.includeSelf,!!i.optional,e.errors);e.currentQueryTotal=o.length;let a=null;o.forEach((n,i)=>{e.currentQueryIndex=i;const o=e.createSubContext(t.options,n);r&&o.delayNextStep(r),n===e.element&&(a=o.currentTimeline),Mv(this,t.animation,o),o.currentTimeline.applyStylesToKeyframe(),s=Math.max(s,o.currentTimeline.currentTime)}),e.currentQueryIndex=0,e.currentQueryTotal=0,e.transformIntoNewTimeline(s),a&&(e.currentTimeline.mergeTimelineCollectedStyles(a),e.currentTimeline.snapshotCurrentStyles()),e.previousNode=t}visitStagger(t,e){const n=e.parentContext,i=e.currentTimeline,r=t.timings,s=Math.abs(r.duration),o=s*(e.currentQueryTotal-1);let a=s*e.currentQueryIndex;switch(r.duration<0?"reverse":r.easing){case"reverse":a=o-a;break;case"full":a=n.currentStaggerTime}const l=e.currentTimeline;a&&l.delayNextStep(a);const c=l.currentTime;Mv(this,t.animation,e),e.previousNode=t,n.currentStaggerTime=i.currentTime-c+(i.startTime-n.currentTimeline.startTime)}}const Xv={};class Yv{constructor(t,e,n,i,r,s,o,a){this._driver=t,this.element=e,this.subInstructions=n,this._enterClassName=i,this._leaveClassName=r,this.errors=s,this.timelines=o,this.parentContext=null,this.currentAnimateTimings=null,this.previousNode=Xv,this.subContextCount=0,this.options={},this.currentQueryIndex=0,this.currentQueryTotal=0,this.currentStaggerTime=0,this.currentTimeline=a||new Kv(this._driver,e,0),o.push(this.currentTimeline)}get params(){return this.options.params}updateOptions(t,e){if(!t)return;const n=t;let i=this.options;null!=n.duration&&(i.duration=hv(n.duration)),null!=n.delay&&(i.delay=hv(n.delay));const r=n.params;if(r){let t=i.params;t||(t=this.options.params={}),Object.keys(r).forEach(n=>{e&&t.hasOwnProperty(n)||(t[n]=_v(r[n],t,this.errors))})}}_copyOptions(){const t={};if(this.options){const e=this.options.params;if(e){const n=t.params={};Object.keys(e).forEach(t=>{n[t]=e[t]})}}return t}createSubContext(t=null,e,n){const i=e||this.element,r=new Yv(this._driver,i,this.subInstructions,this._enterClassName,this._leaveClassName,this.errors,this.timelines,this.currentTimeline.fork(i,n||0));return r.previousNode=this.previousNode,r.currentAnimateTimings=this.currentAnimateTimings,r.options=this._copyOptions(),r.updateOptions(t),r.currentQueryIndex=this.currentQueryIndex,r.currentQueryTotal=this.currentQueryTotal,r.parentContext=this,this.subContextCount++,r}transformIntoNewTimeline(t){return this.previousNode=Xv,this.currentTimeline=this.currentTimeline.fork(this.element,t),this.timelines.push(this.currentTimeline),this.currentTimeline}appendInstructionToTimeline(t,e,n){const i={duration:null!=e?e:t.duration,delay:this.currentTimeline.currentTime+(null!=n?n:0)+t.delay,easing:""},r=new Jv(this._driver,t.element,t.keyframes,t.preStyleProps,t.postStyleProps,i,t.stretchStartingKeyframe);return this.timelines.push(r),i}incrementTime(t){this.currentTimeline.forwardTime(this.currentTimeline.duration+t)}delayNextStep(t){t>0&&this.currentTimeline.delayNextStep(t)}invokeQuery(t,e,n,i,r,s){let o=[];if(i&&o.push(this.element),t.length>0){t=(t=t.replace(Wv,"."+this._enterClassName)).replace(jv,"."+this._leaveClassName);let e=this._driver.query(this.element,t,1!=n);0!==n&&(e=n<0?e.slice(e.length+n,e.length):e.slice(0,n)),o.push(...e)}return r||0!=o.length||s.push(`\`query("${e}")\` returned zero elements. (Use \`query("${e}", { optional: true })\` if you wish to allow this.)`),o}}class Kv{constructor(t,e,n,i){this._driver=t,this.element=e,this.startTime=n,this._elementTimelineStylesLookup=i,this.duration=0,this._previousKeyframe={},this._currentKeyframe={},this._keyframes=new Map,this._styleSummary={},this._pendingStyles={},this._backFill={},this._currentEmptyStepKeyframe=null,this._elementTimelineStylesLookup||(this._elementTimelineStylesLookup=new Map),this._localTimelineStyles=Object.create(this._backFill,{}),this._globalTimelineStyles=this._elementTimelineStylesLookup.get(e),this._globalTimelineStyles||(this._globalTimelineStyles=this._localTimelineStyles,this._elementTimelineStylesLookup.set(e,this._localTimelineStyles)),this._loadKeyframe()}containsAnimation(){switch(this._keyframes.size){case 0:return!1;case 1:return this.getCurrentStyleProperties().length>0;default:return!0}}getCurrentStyleProperties(){return Object.keys(this._currentKeyframe)}get currentTime(){return this.startTime+this.duration}delayNextStep(t){const e=1==this._keyframes.size&&Object.keys(this._pendingStyles).length;this.duration||e?(this.forwardTime(this.currentTime+t),e&&this.snapshotCurrentStyles()):this.startTime+=t}fork(t,e){return this.applyStylesToKeyframe(),new Kv(this._driver,t,e||this.currentTime,this._elementTimelineStylesLookup)}_loadKeyframe(){this._currentKeyframe&&(this._previousKeyframe=this._currentKeyframe),this._currentKeyframe=this._keyframes.get(this.duration),this._currentKeyframe||(this._currentKeyframe=Object.create(this._backFill,{}),this._keyframes.set(this.duration,this._currentKeyframe))}forwardFrame(){this.duration+=1,this._loadKeyframe()}forwardTime(t){this.applyStylesToKeyframe(),this.duration=t,this._loadKeyframe()}_updateStyle(t,e){this._localTimelineStyles[t]=e,this._globalTimelineStyles[t]=e,this._styleSummary[t]={time:this.currentTime,value:e}}allowOnlyTimelineStyles(){return this._currentEmptyStepKeyframe!==this._currentKeyframe}applyEmptyStep(t){t&&(this._previousKeyframe.easing=t),Object.keys(this._globalTimelineStyles).forEach(t=>{this._backFill[t]=this._globalTimelineStyles[t]||Iy,this._currentKeyframe[t]=Iy}),this._currentEmptyStepKeyframe=this._currentKeyframe}setStyles(t,e,n,i){e&&(this._previousKeyframe.easing=e);const r=i&&i.params||{},s=function(t,e){const n={};let i;return t.forEach(t=>{"*"===t?(i=i||Object.keys(e),i.forEach(t=>{n[t]=Iy})):mv(t,!1,n)}),n}(t,this._globalTimelineStyles);Object.keys(s).forEach(t=>{const e=_v(s[t],r,n);this._pendingStyles[t]=e,this._localTimelineStyles.hasOwnProperty(t)||(this._backFill[t]=this._globalTimelineStyles.hasOwnProperty(t)?this._globalTimelineStyles[t]:Iy),this._updateStyle(t,e)})}applyStylesToKeyframe(){const t=this._pendingStyles,e=Object.keys(t);0!=e.length&&(this._pendingStyles={},e.forEach(e=>{this._currentKeyframe[e]=t[e]}),Object.keys(this._localTimelineStyles).forEach(t=>{this._currentKeyframe.hasOwnProperty(t)||(this._currentKeyframe[t]=this._localTimelineStyles[t])}))}snapshotCurrentStyles(){Object.keys(this._localTimelineStyles).forEach(t=>{const e=this._localTimelineStyles[t];this._pendingStyles[t]=e,this._updateStyle(t,e)})}getFinalKeyframe(){return this._keyframes.get(this.duration)}get properties(){const t=[];for(let e in this._currentKeyframe)t.push(e);return t}mergeTimelineCollectedStyles(t){Object.keys(t._styleSummary).forEach(e=>{const n=this._styleSummary[e],i=t._styleSummary[e];(!n||i.time>n.time)&&this._updateStyle(e,i.value)})}buildKeyframes(){this.applyStylesToKeyframe();const t=new Set,e=new Set,n=1===this._keyframes.size&&0===this.duration;let i=[];this._keyframes.forEach((r,s)=>{const o=mv(r,!0);Object.keys(o).forEach(n=>{const i=o[n];"!"==i?t.add(n):i==Iy&&e.add(n)}),n||(o.offset=s/this.duration),i.push(o)});const r=t.size?Sv(t.values()):[],s=e.size?Sv(e.values()):[];if(n){const t=i[0],e=fv(t);t.offset=0,e.offset=1,i=[t,e]}return Vv(this.element,i,r,s,this.duration,this.startTime,this.easing,!1)}}class Jv extends Kv{constructor(t,e,n,i,r,s,o=!1){super(t,e,s.delay),this.element=e,this.keyframes=n,this.preStyleProps=i,this.postStyleProps=r,this._stretchStartingKeyframe=o,this.timings={duration:s.duration,delay:s.delay,easing:s.easing}}containsAnimation(){return this.keyframes.length>1}buildKeyframes(){let t=this.keyframes,{delay:e,duration:n,easing:i}=this.timings;if(this._stretchStartingKeyframe&&e){const r=[],s=n+e,o=e/s,a=mv(t[0],!1);a.offset=0,r.push(a);const l=mv(t[0],!1);l.offset=Zv(o),r.push(l);const c=t.length-1;for(let i=1;i<=c;i++){let o=mv(t[i],!1);o.offset=Zv((e+o.offset*n)/s),r.push(o)}n=s,e=0,i="",t=r}return Vv(this.element,t,this.preStyleProps,this.postStyleProps,n,e,i,!0)}}function Zv(t,e=3){const n=Math.pow(10,e-1);return Math.round(t*n)/n}class tb{}class eb extends tb{normalizePropertyName(t,e){return Cv(t)}normalizeStyleValue(t,e,n,i){let r="";const s=n.toString().trim();if(nb[e]&&0!==n&&"0"!==n)if("number"==typeof n)r="px";else{const e=n.match(/^[+-]?[\d\.]+([a-z]*)$/);e&&0==e[1].length&&i.push(`Please provide a CSS unit value for ${t}:${n}`)}return s+r}}const nb=(()=>function(t){const e={};return t.forEach(t=>e[t]=!0),e}("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))();function ib(t,e,n,i,r,s,o,a,l,c,u,h,d){return{type:0,element:t,triggerName:e,isRemovalTransition:r,fromState:n,fromStyles:s,toState:i,toStyles:o,timelines:a,queriedElements:l,preStyleProps:c,postStyleProps:u,totalTime:h,errors:d}}const rb={};class sb{constructor(t,e,n){this._triggerName=t,this.ast=e,this._stateStyles=n}match(t,e,n,i){return function(t,e,n,i,r){return t.some(t=>t(e,n,i,r))}(this.ast.matchers,t,e,n,i)}buildStyles(t,e,n){const i=this._stateStyles["*"],r=this._stateStyles[t],s=i?i.buildStyles(e,n):{};return r?r.buildStyles(e,n):s}build(t,e,n,i,r,s,o,a,l,c){const u=[],h=this.ast.options&&this.ast.options.params||rb,d=this.buildStyles(n,o&&o.params||rb,u),p=a&&a.params||rb,f=this.buildStyles(i,p,u),m=new Set,g=new Map,y=new Map,v="void"===i,b={params:Object.assign(Object.assign({},h),p)},A=c?[]:Qv(t,e,this.ast.animation,r,s,d,f,b,l,u);let x=0;if(A.forEach(t=>{x=Math.max(t.duration+t.delay,x)}),u.length)return ib(e,this._triggerName,n,i,v,d,f,[],[],g,y,x,u);A.forEach(t=>{const n=t.element,i=Gy(g,n,{});t.preStyleProps.forEach(t=>i[t]=!0);const r=Gy(y,n,{});t.postStyleProps.forEach(t=>r[t]=!0),n!==e&&m.add(n)});const w=Sv(m.values());return ib(e,this._triggerName,n,i,v,d,f,A,w,g,y,x)}}class ob{constructor(t,e){this.styles=t,this.defaultParams=e}buildStyles(t,e){const n={},i=fv(this.defaultParams);return Object.keys(t).forEach(e=>{const n=t[e];null!=n&&(i[e]=n)}),this.styles.styles.forEach(t=>{if("string"!=typeof t){const r=t;Object.keys(r).forEach(t=>{let s=r[t];s.length>1&&(s=_v(s,i,e)),n[t]=s})}}),n}}class ab{constructor(t,e){this.name=t,this.ast=e,this.transitionFactories=[],this.states={},e.states.forEach(t=>{this.states[t.name]=new ob(t.style,t.options&&t.options.params||{})}),lb(this.states,"true","1"),lb(this.states,"false","0"),e.transitions.forEach(e=>{this.transitionFactories.push(new sb(t,e,this.states))}),this.fallbackTransition=new sb(t,{type:1,animation:{type:2,steps:[],options:null},matchers:[(t,e)=>!0],options:null,queryCount:0,depCount:0},this.states)}get containsQueries(){return this.ast.queryCount>0}matchTransition(t,e,n,i){return this.transitionFactories.find(r=>r.match(t,e,n,i))||null}matchStyles(t,e,n){return this.fallbackTransition.buildStyles(t,e,n)}}function lb(t,e,n){t.hasOwnProperty(e)?t.hasOwnProperty(n)||(t[n]=t[e]):t.hasOwnProperty(n)&&(t[e]=t[n])}const cb=new Gv;class ub{constructor(t,e,n){this.bodyNode=t,this._driver=e,this._normalizer=n,this._animations={},this._playersById={},this.players=[]}register(t,e){const n=[],i=Pv(this._driver,e,n);if(n.length)throw new Error(`Unable to build the animation due to the following errors: ${n.join("\n")}`);this._animations[t]=i}_buildPlayer(t,e,n){const i=t.element,r=zy(0,this._normalizer,0,t.keyframes,e,n);return this._driver.animate(i,r,t.duration,t.delay,t.easing,[],!0)}create(t,e,n={}){const i=[],r=this._animations[t];let s;const o=new Map;if(r?(s=Qv(this._driver,e,r,sv,ov,{},{},n,cb,i),s.forEach(t=>{const e=Gy(o,t.element,{});t.postStyleProps.forEach(t=>e[t]=null)})):(i.push("The requested animation doesn't exist or has already been destroyed"),s=[]),i.length)throw new Error(`Unable to create the animation due to the following errors: ${i.join("\n")}`);o.forEach((t,e)=>{Object.keys(t).forEach(n=>{t[n]=this._driver.computeStyle(e,n,Iy)})});const a=$y(s.map(t=>{const e=o.get(t.element);return this._buildPlayer(t,{},e)}));return this._playersById[t]=a,a.onDestroy(()=>this.destroy(t)),this.players.push(a),a}destroy(t){const e=this._getPlayer(t);e.destroy(),delete this._playersById[t];const n=this.players.indexOf(e);n>=0&&this.players.splice(n,1)}_getPlayer(t){const e=this._playersById[t];if(!e)throw new Error(`Unable to find the timeline player referenced by ${t}`);return e}listen(t,e,n,i){const r=Vy(e,"","","");return Uy(this._getPlayer(t),n,r,i),()=>{}}command(t,e,n,i){if("register"==n)return void this.register(t,i[0]);if("create"==n)return void this.create(t,e,i[0]||{});const r=this._getPlayer(t);switch(n){case"play":r.play();break;case"pause":r.pause();break;case"reset":r.reset();break;case"restart":r.restart();break;case"finish":r.finish();break;case"init":r.init();break;case"setPosition":r.setPosition(parseFloat(i[0]));break;case"destroy":this.destroy(t)}}}const hb="ng-animate-queued",db="ng-animate-disabled",pb=".ng-animate-disabled",fb=[],mb={namespaceId:"",setForRemoval:!1,setForMove:!1,hasAnimation:!1,removedBeforeQueried:!1},gb={namespaceId:"",setForMove:!1,setForRemoval:!1,hasAnimation:!1,removedBeforeQueried:!0};class yb{constructor(t,e=""){this.namespaceId=e;const n=t&&t.hasOwnProperty("value");if(this.value=null!=(i=n?t.value:t)?i:null,n){const e=fv(t);delete e.value,this.options=e}else this.options={};var i;this.options.params||(this.options.params={})}get params(){return this.options.params}absorbOptions(t){const e=t.params;if(e){const t=this.options.params;Object.keys(e).forEach(n=>{null==t[n]&&(t[n]=e[n])})}}}const vb="void",bb=new yb(vb);class Ab{constructor(t,e,n){this.id=t,this.hostElement=e,this._engine=n,this.players=[],this._triggers={},this._queue=[],this._elementListeners=new Map,this._hostClassName="ng-tns-"+t,Ib(e,this._hostClassName)}listen(t,e,n,i){if(!this._triggers.hasOwnProperty(e))throw new Error(`Unable to listen on the animation trigger event "${n}" because the animation trigger "${e}" doesn't exist!`);if(null==n||0==n.length)throw new Error(`Unable to listen on the animation trigger "${e}" because the provided event is undefined!`);if("start"!=(r=n)&&"done"!=r)throw new Error(`The provided animation trigger event "${n}" for the animation trigger "${e}" is not supported!`);var r;const s=Gy(this._elementListeners,t,[]),o={name:e,phase:n,callback:i};s.push(o);const a=Gy(this._engine.statesByElement,t,{});return a.hasOwnProperty(e)||(Ib(t,av),Ib(t,"ng-trigger-"+e),a[e]=bb),()=>{this._engine.afterFlush(()=>{const t=s.indexOf(o);t>=0&&s.splice(t,1),this._triggers[e]||delete a[e]})}}register(t,e){return!this._triggers[t]&&(this._triggers[t]=e,!0)}_getTrigger(t){const e=this._triggers[t];if(!e)throw new Error(`The provided animation trigger "${t}" has not been registered!`);return e}trigger(t,e,n,i=!0){const r=this._getTrigger(e),s=new wb(this.id,e,t);let o=this._engine.statesByElement.get(t);o||(Ib(t,av),Ib(t,"ng-trigger-"+e),this._engine.statesByElement.set(t,o={}));let a=o[e];const l=new yb(n,this.id);if(!(n&&n.hasOwnProperty("value"))&&a&&l.absorbOptions(a.options),o[e]=l,a||(a=bb),l.value!==vb&&a.value===l.value){if(!function(t,e){const n=Object.keys(t),i=Object.keys(e);if(n.length!=i.length)return!1;for(let r=0;r<n.length;r++){const i=n[r];if(!e.hasOwnProperty(i)||t[i]!==e[i])return!1}return!0}(a.params,l.params)){const e=[],n=r.matchStyles(a.value,a.params,e),i=r.matchStyles(l.value,l.params,e);e.length?this._engine.reportError(e):this._engine.afterFlush(()=>{bv(t,n),vv(t,i)})}return}const c=Gy(this._engine.playersByElement,t,[]);c.forEach(t=>{t.namespaceId==this.id&&t.triggerName==e&&t.queued&&t.destroy()});let u=r.matchTransition(a.value,l.value,t,l.params),h=!1;if(!u){if(!i)return;u=r.fallbackTransition,h=!0}return this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:e,transition:u,fromState:a,toState:l,player:s,isFallbackTransition:h}),h||(Ib(t,hb),s.onStart(()=>{Tb(t,hb)})),s.onDone(()=>{let e=this.players.indexOf(s);e>=0&&this.players.splice(e,1);const n=this._engine.playersByElement.get(t);if(n){let t=n.indexOf(s);t>=0&&n.splice(t,1)}}),this.players.push(s),c.push(s),s}deregister(t){delete this._triggers[t],this._engine.statesByElement.forEach((e,n)=>{delete e[t]}),this._elementListeners.forEach((e,n)=>{this._elementListeners.set(n,e.filter(e=>e.name!=t))})}clearElementCache(t){this._engine.statesByElement.delete(t),this._elementListeners.delete(t);const e=this._engine.playersByElement.get(t);e&&(e.forEach(t=>t.destroy()),this._engine.playersByElement.delete(t))}_signalRemovalForInnerTriggers(t,e){const n=this._engine.driver.query(t,lv,!0);n.forEach(t=>{if(t.__ng_removed)return;const n=this._engine.fetchNamespacesByElement(t);n.size?n.forEach(n=>n.triggerLeaveAnimation(t,e,!1,!0)):this.clearElementCache(t)}),this._engine.afterFlushAnimationsDone(()=>n.forEach(t=>this.clearElementCache(t)))}triggerLeaveAnimation(t,e,n,i){const r=this._engine.statesByElement.get(t);if(r){const s=[];if(Object.keys(r).forEach(e=>{if(this._triggers[e]){const n=this.trigger(t,e,vb,i);n&&s.push(n)}}),s.length)return this._engine.markElementAsRemoved(this.id,t,!0,e),n&&$y(s).onDone(()=>this._engine.processLeaveNode(t)),!0}return!1}prepareLeaveAnimationListeners(t){const e=this._elementListeners.get(t),n=this._engine.statesByElement.get(t);if(e&&n){const i=new Set;e.forEach(e=>{const r=e.name;if(i.has(r))return;i.add(r);const s=this._triggers[r].fallbackTransition,o=n[r]||bb,a=new yb(vb),l=new wb(this.id,r,t);this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:r,transition:s,fromState:o,toState:a,player:l,isFallbackTransition:!0})})}}removeNode(t,e){const n=this._engine;if(t.childElementCount&&this._signalRemovalForInnerTriggers(t,e),this.triggerLeaveAnimation(t,e,!0))return;let i=!1;if(n.totalAnimations){const e=n.players.length?n.playersByQueriedElement.get(t):[];if(e&&e.length)i=!0;else{let e=t;for(;e=e.parentNode;)if(n.statesByElement.get(e)){i=!0;break}}}if(this.prepareLeaveAnimationListeners(t),i)n.markElementAsRemoved(this.id,t,!1,e);else{const i=t.__ng_removed;i&&i!==mb||(n.afterFlush(()=>this.clearElementCache(t)),n.destroyInnerAnimations(t),n._onRemovalComplete(t,e))}}insertNode(t,e){Ib(t,this._hostClassName)}drainQueuedTransitions(t){const e=[];return this._queue.forEach(n=>{const i=n.player;if(i.destroyed)return;const r=n.element,s=this._elementListeners.get(r);s&&s.forEach(e=>{if(e.name==n.triggerName){const i=Vy(r,n.triggerName,n.fromState.value,n.toState.value);i._data=t,Uy(n.player,e.phase,i,e.callback)}}),i.markedForDestroy?this._engine.afterFlush(()=>{i.destroy()}):e.push(n)}),this._queue=[],e.sort((t,e)=>{const n=t.transition.ast.depCount,i=e.transition.ast.depCount;return 0==n||0==i?n-i:this._engine.driver.containsElement(t.element,e.element)?1:-1})}destroy(t){this.players.forEach(t=>t.destroy()),this._signalRemovalForInnerTriggers(this.hostElement,t)}elementContainsData(t){let e=!1;return this._elementListeners.has(t)&&(e=!0),e=!!this._queue.find(e=>e.element===t)||e,e}}class xb{constructor(t,e,n){this.bodyNode=t,this.driver=e,this._normalizer=n,this.players=[],this.newHostElements=new Map,this.playersByElement=new Map,this.playersByQueriedElement=new Map,this.statesByElement=new Map,this.disabledNodes=new Set,this.totalAnimations=0,this.totalQueuedPlayers=0,this._namespaceLookup={},this._namespaceList=[],this._flushFns=[],this._whenQuietFns=[],this.namespacesByHostElement=new Map,this.collectedEnterElements=[],this.collectedLeaveElements=[],this.onRemovalComplete=(t,e)=>{}}_onRemovalComplete(t,e){this.onRemovalComplete(t,e)}get queuedPlayers(){const t=[];return this._namespaceList.forEach(e=>{e.players.forEach(e=>{e.queued&&t.push(e)})}),t}createNamespace(t,e){const n=new Ab(t,e,this);return this.bodyNode&&this.driver.containsElement(this.bodyNode,e)?this._balanceNamespaceList(n,e):(this.newHostElements.set(e,n),this.collectEnterElement(e)),this._namespaceLookup[t]=n}_balanceNamespaceList(t,e){const n=this._namespaceList.length-1;if(n>=0){let i=!1;for(let r=n;r>=0;r--)if(this.driver.containsElement(this._namespaceList[r].hostElement,e)){this._namespaceList.splice(r+1,0,t),i=!0;break}i||this._namespaceList.splice(0,0,t)}else this._namespaceList.push(t);return this.namespacesByHostElement.set(e,t),t}register(t,e){let n=this._namespaceLookup[t];return n||(n=this.createNamespace(t,e)),n}registerTrigger(t,e,n){let i=this._namespaceLookup[t];i&&i.register(e,n)&&this.totalAnimations++}destroy(t,e){if(!t)return;const n=this._fetchNamespace(t);this.afterFlush(()=>{this.namespacesByHostElement.delete(n.hostElement),delete this._namespaceLookup[t];const e=this._namespaceList.indexOf(n);e>=0&&this._namespaceList.splice(e,1)}),this.afterFlushAnimationsDone(()=>n.destroy(e))}_fetchNamespace(t){return this._namespaceLookup[t]}fetchNamespacesByElement(t){const e=new Set,n=this.statesByElement.get(t);if(n){const t=Object.keys(n);for(let i=0;i<t.length;i++){const r=n[t[i]].namespaceId;if(r){const t=this._fetchNamespace(r);t&&e.add(t)}}}return e}trigger(t,e,n,i){if(_b(e)){const r=this._fetchNamespace(t);if(r)return r.trigger(e,n,i),!0}return!1}insertNode(t,e,n,i){if(!_b(e))return;const r=e.__ng_removed;if(r&&r.setForRemoval){r.setForRemoval=!1,r.setForMove=!0;const t=this.collectedLeaveElements.indexOf(e);t>=0&&this.collectedLeaveElements.splice(t,1)}if(t){const i=this._fetchNamespace(t);i&&i.insertNode(e,n)}i&&this.collectEnterElement(e)}collectEnterElement(t){this.collectedEnterElements.push(t)}markElementAsDisabled(t,e){e?this.disabledNodes.has(t)||(this.disabledNodes.add(t),Ib(t,db)):this.disabledNodes.has(t)&&(this.disabledNodes.delete(t),Tb(t,db))}removeNode(t,e,n,i){if(_b(e)){const r=t?this._fetchNamespace(t):null;if(r?r.removeNode(e,i):this.markElementAsRemoved(t,e,!1,i),n){const n=this.namespacesByHostElement.get(e);n&&n.id!==t&&n.removeNode(e,i)}}else this._onRemovalComplete(e,i)}markElementAsRemoved(t,e,n,i){this.collectedLeaveElements.push(e),e.__ng_removed={namespaceId:t,setForRemoval:i,hasAnimation:n,removedBeforeQueried:!1}}listen(t,e,n,i,r){return _b(e)?this._fetchNamespace(t).listen(e,n,i,r):()=>{}}_buildInstruction(t,e,n,i,r){return t.transition.build(this.driver,t.element,t.fromState.value,t.toState.value,n,i,t.fromState.options,t.toState.options,e,r)}destroyInnerAnimations(t){let e=this.driver.query(t,lv,!0);e.forEach(t=>this.destroyActiveAnimationsForElement(t)),0!=this.playersByQueriedElement.size&&(e=this.driver.query(t,uv,!0),e.forEach(t=>this.finishActiveQueriedAnimationOnElement(t)))}destroyActiveAnimationsForElement(t){const e=this.playersByElement.get(t);e&&e.forEach(t=>{t.queued?t.markedForDestroy=!0:t.destroy()})}finishActiveQueriedAnimationOnElement(t){const e=this.playersByQueriedElement.get(t);e&&e.forEach(t=>t.finish())}whenRenderingDone(){return new Promise(t=>{if(this.players.length)return $y(this.players).onDone(()=>t());t()})}processLeaveNode(t){const e=t.__ng_removed;if(e&&e.setForRemoval){if(t.__ng_removed=mb,e.namespaceId){this.destroyInnerAnimations(t);const n=this._fetchNamespace(e.namespaceId);n&&n.clearElementCache(t)}this._onRemovalComplete(t,e.setForRemoval)}this.driver.matchesElement(t,pb)&&this.markElementAsDisabled(t,!1),this.driver.query(t,pb,!0).forEach(t=>{this.markElementAsDisabled(t,!1)})}flush(t=-1){let e=[];if(this.newHostElements.size&&(this.newHostElements.forEach((t,e)=>this._balanceNamespaceList(t,e)),this.newHostElements.clear()),this.totalAnimations&&this.collectedEnterElements.length)for(let n=0;n<this.collectedEnterElements.length;n++)Ib(this.collectedEnterElements[n],"ng-star-inserted");if(this._namespaceList.length&&(this.totalQueuedPlayers||this.collectedLeaveElements.length)){const n=[];try{e=this._flushAnimations(n,t)}finally{for(let t=0;t<n.length;t++)n[t]()}}else for(let n=0;n<this.collectedLeaveElements.length;n++)this.processLeaveNode(this.collectedLeaveElements[n]);if(this.totalQueuedPlayers=0,this.collectedEnterElements.length=0,this.collectedLeaveElements.length=0,this._flushFns.forEach(t=>t()),this._flushFns=[],this._whenQuietFns.length){const t=this._whenQuietFns;this._whenQuietFns=[],e.length?$y(e).onDone(()=>{t.forEach(t=>t())}):t.forEach(t=>t())}}reportError(t){throw new Error(`Unable to process animations due to the following failed trigger transitions\n ${t.join("\n")}`)}_flushAnimations(t,e){const n=new Gv,i=[],r=new Map,s=[],o=new Map,a=new Map,l=new Map,c=new Set;this.disabledNodes.forEach(t=>{c.add(t);const e=this.driver.query(t,".ng-animate-queued",!0);for(let n=0;n<e.length;n++)c.add(e[n])});const u=this.bodyNode,h=Array.from(this.statesByElement.keys()),d=Cb(h,this.collectedEnterElements),p=new Map;let f=0;d.forEach((t,e)=>{const n=sv+f++;p.set(e,n),t.forEach(t=>Ib(t,n))});const m=[],g=new Set,y=new Set;for(let k=0;k<this.collectedLeaveElements.length;k++){const t=this.collectedLeaveElements[k],e=t.__ng_removed;e&&e.setForRemoval&&(m.push(t),g.add(t),e.hasAnimation?this.driver.query(t,".ng-star-inserted",!0).forEach(t=>g.add(t)):y.add(t))}const v=new Map,b=Cb(h,Array.from(g));b.forEach((t,e)=>{const n=ov+f++;v.set(e,n),t.forEach(t=>Ib(t,n))}),t.push(()=>{d.forEach((t,e)=>{const n=p.get(e);t.forEach(t=>Tb(t,n))}),b.forEach((t,e)=>{const n=v.get(e);t.forEach(t=>Tb(t,n))}),m.forEach(t=>{this.processLeaveNode(t)})});const A=[],x=[];for(let k=this._namespaceList.length-1;k>=0;k--)this._namespaceList[k].drainQueuedTransitions(e).forEach(t=>{const e=t.player,r=t.element;if(A.push(e),this.collectedEnterElements.length){const t=r.__ng_removed;if(t&&t.setForMove)return void e.destroy()}const c=!u||!this.driver.containsElement(u,r),h=v.get(r),d=p.get(r),f=this._buildInstruction(t,n,d,h,c);if(f.errors&&f.errors.length)x.push(f);else{if(c)return e.onStart(()=>bv(r,f.fromStyles)),e.onDestroy(()=>vv(r,f.toStyles)),void i.push(e);if(t.isFallbackTransition)return e.onStart(()=>bv(r,f.fromStyles)),e.onDestroy(()=>vv(r,f.toStyles)),void i.push(e);f.timelines.forEach(t=>t.stretchStartingKeyframe=!0),n.append(r,f.timelines),s.push({instruction:f,player:e,element:r}),f.queriedElements.forEach(t=>Gy(o,t,[]).push(e)),f.preStyleProps.forEach((t,e)=>{const n=Object.keys(t);if(n.length){let t=a.get(e);t||a.set(e,t=new Set),n.forEach(e=>t.add(e))}}),f.postStyleProps.forEach((t,e)=>{const n=Object.keys(t);let i=l.get(e);i||l.set(e,i=new Set),n.forEach(t=>i.add(t))})}});if(x.length){const t=[];x.forEach(e=>{t.push(`@${e.triggerName} has failed due to:\n`),e.errors.forEach(e=>t.push(`- ${e}\n`))}),A.forEach(t=>t.destroy()),this.reportError(t)}const w=new Map,_=new Map;s.forEach(t=>{const e=t.element;n.has(e)&&(_.set(e,e),this._beforeAnimationBuild(t.player.namespaceId,t.instruction,w))}),i.forEach(t=>{const e=t.element;this._getPreviousPlayers(e,!1,t.namespaceId,t.triggerName,null).forEach(t=>{Gy(w,e,[]).push(t),t.destroy()})});const S=m.filter(t=>Rb(t,a,l)),E=new Map;Eb(E,this.driver,y,l,Iy).forEach(t=>{Rb(t,a,l)&&S.push(t)});const C=new Map;d.forEach((t,e)=>{Eb(C,this.driver,new Set(t),a,"!")}),S.forEach(t=>{const e=E.get(t),n=C.get(t);E.set(t,Object.assign(Object.assign({},e),n))});const I=[],T=[],M={};s.forEach(t=>{const{element:e,player:s,instruction:o}=t;if(n.has(e)){if(c.has(e))return s.onDestroy(()=>vv(e,o.toStyles)),s.disabled=!0,s.overrideTotalTime(o.totalTime),void i.push(s);let t=M;if(_.size>1){let n=e;const i=[];for(;n=n.parentNode;){const e=_.get(n);if(e){t=e;break}i.push(n)}i.forEach(e=>_.set(e,t))}const n=this._buildAnimation(s.namespaceId,o,w,r,C,E);if(s.setRealPlayer(n),t===M)I.push(s);else{const e=this.playersByElement.get(t);e&&e.length&&(s.parentPlayer=$y(e)),i.push(s)}}else bv(e,o.fromStyles),s.onDestroy(()=>vv(e,o.toStyles)),T.push(s),c.has(e)&&i.push(s)}),T.forEach(t=>{const e=r.get(t.element);if(e&&e.length){const n=$y(e);t.setRealPlayer(n)}}),i.forEach(t=>{t.parentPlayer?t.syncPlayerEvents(t.parentPlayer):t.destroy()});for(let k=0;k<m.length;k++){const t=m[k],e=t.__ng_removed;if(Tb(t,ov),e&&e.hasAnimation)continue;let n=[];if(o.size){let e=o.get(t);e&&e.length&&n.push(...e);let i=this.driver.query(t,uv,!0);for(let t=0;t<i.length;t++){let e=o.get(i[t]);e&&e.length&&n.push(...e)}}const i=n.filter(t=>!t.destroyed);i.length?Mb(this,t,i):this.processLeaveNode(t)}return m.length=0,I.forEach(t=>{this.players.push(t),t.onDone(()=>{t.destroy();const e=this.players.indexOf(t);this.players.splice(e,1)}),t.play()}),I}elementContainsData(t,e){let n=!1;const i=e.__ng_removed;return i&&i.setForRemoval&&(n=!0),this.playersByElement.has(e)&&(n=!0),this.playersByQueriedElement.has(e)&&(n=!0),this.statesByElement.has(e)&&(n=!0),this._fetchNamespace(t).elementContainsData(e)||n}afterFlush(t){this._flushFns.push(t)}afterFlushAnimationsDone(t){this._whenQuietFns.push(t)}_getPreviousPlayers(t,e,n,i,r){let s=[];if(e){const e=this.playersByQueriedElement.get(t);e&&(s=e)}else{const e=this.playersByElement.get(t);if(e){const t=!r||r==vb;e.forEach(e=>{e.queued||(t||e.triggerName==i)&&s.push(e)})}}return(n||i)&&(s=s.filter(t=>!(n&&n!=t.namespaceId||i&&i!=t.triggerName))),s}_beforeAnimationBuild(t,e,n){const i=e.element,r=e.isRemovalTransition?void 0:t,s=e.isRemovalTransition?void 0:e.triggerName;for(const o of e.timelines){const t=o.element,a=t!==i,l=Gy(n,t,[]);this._getPreviousPlayers(t,a,r,s,e.toState).forEach(t=>{const e=t.getRealPlayer();e.beforeDestroy&&e.beforeDestroy(),t.destroy(),l.push(t)})}bv(i,e.fromStyles)}_buildAnimation(t,e,n,i,r,s){const o=e.triggerName,a=e.element,l=[],c=new Set,u=new Set,h=e.timelines.map(e=>{const h=e.element;c.add(h);const d=h.__ng_removed;if(d&&d.removedBeforeQueried)return new Oy(e.duration,e.delay);const p=h!==a,f=function(t){const e=[];return kb(t,e),e}((n.get(h)||fb).map(t=>t.getRealPlayer())).filter(t=>!!t.element&&t.element===h),m=r.get(h),g=s.get(h),y=zy(0,this._normalizer,0,e.keyframes,m,g),v=this._buildPlayer(e,y,f);if(e.subTimeline&&i&&u.add(h),p){const e=new wb(t,o,h);e.setRealPlayer(v),l.push(e)}return v});l.forEach(t=>{Gy(this.playersByQueriedElement,t.element,[]).push(t),t.onDone(()=>function(t,e,n){let i;if(t instanceof Map){if(i=t.get(e),i){if(i.length){const t=i.indexOf(n);i.splice(t,1)}0==i.length&&t.delete(e)}}else if(i=t[e],i){if(i.length){const t=i.indexOf(n);i.splice(t,1)}0==i.length&&delete t[e]}return i}(this.playersByQueriedElement,t.element,t))}),c.forEach(t=>Ib(t,cv));const d=$y(h);return d.onDestroy(()=>{c.forEach(t=>Tb(t,cv)),vv(a,e.toStyles)}),u.forEach(t=>{Gy(i,t,[]).push(d)}),d}_buildPlayer(t,e,n){return e.length>0?this.driver.animate(t.element,e,t.duration,t.delay,t.easing,n):new Oy(t.duration,t.delay)}}class wb{constructor(t,e,n){this.namespaceId=t,this.triggerName=e,this.element=n,this._player=new Oy,this._containsRealPlayer=!1,this._queuedCallbacks={},this.destroyed=!1,this.markedForDestroy=!1,this.disabled=!1,this.queued=!0,this.totalTime=0}setRealPlayer(t){this._containsRealPlayer||(this._player=t,Object.keys(this._queuedCallbacks).forEach(e=>{this._queuedCallbacks[e].forEach(n=>Uy(t,e,void 0,n))}),this._queuedCallbacks={},this._containsRealPlayer=!0,this.overrideTotalTime(t.totalTime),this.queued=!1)}getRealPlayer(){return this._player}overrideTotalTime(t){this.totalTime=t}syncPlayerEvents(t){const e=this._player;e.triggerCallback&&t.onStart(()=>e.triggerCallback("start")),t.onDone(()=>this.finish()),t.onDestroy(()=>this.destroy())}_queueEvent(t,e){Gy(this._queuedCallbacks,t,[]).push(e)}onDone(t){this.queued&&this._queueEvent("done",t),this._player.onDone(t)}onStart(t){this.queued&&this._queueEvent("start",t),this._player.onStart(t)}onDestroy(t){this.queued&&this._queueEvent("destroy",t),this._player.onDestroy(t)}init(){this._player.init()}hasStarted(){return!this.queued&&this._player.hasStarted()}play(){!this.queued&&this._player.play()}pause(){!this.queued&&this._player.pause()}restart(){!this.queued&&this._player.restart()}finish(){this._player.finish()}destroy(){this.destroyed=!0,this._player.destroy()}reset(){!this.queued&&this._player.reset()}setPosition(t){this.queued||this._player.setPosition(t)}getPosition(){return this.queued?0:this._player.getPosition()}triggerCallback(t){const e=this._player;e.triggerCallback&&e.triggerCallback(t)}}function _b(t){return t&&1===t.nodeType}function Sb(t,e){const n=t.style.display;return t.style.display=null!=e?e:"none",n}function Eb(t,e,n,i,r){const s=[];n.forEach(t=>s.push(Sb(t)));const o=[];i.forEach((n,i)=>{const s={};n.forEach(t=>{const n=s[t]=e.computeStyle(i,t,r);n&&0!=n.length||(i.__ng_removed=gb,o.push(i))}),t.set(i,s)});let a=0;return n.forEach(t=>Sb(t,s[a++])),o}function Cb(t,e){const n=new Map;if(t.forEach(t=>n.set(t,[])),0==e.length)return n;const i=new Set(e),r=new Map;function s(t){if(!t)return 1;let e=r.get(t);if(e)return e;const o=t.parentNode;return e=n.has(o)?o:i.has(o)?1:s(o),r.set(t,e),e}return e.forEach(t=>{const e=s(t);1!==e&&n.get(e).push(t)}),n}function Ib(t,e){if(t.classList)t.classList.add(e);else{let n=t.$$classes;n||(n=t.$$classes={}),n[e]=!0}}function Tb(t,e){if(t.classList)t.classList.remove(e);else{let n=t.$$classes;n&&delete n[e]}}function Mb(t,e,n){$y(n).onDone(()=>t.processLeaveNode(e))}function kb(t,e){for(let n=0;n<t.length;n++){const i=t[n];i instanceof Py?kb(i.players,e):e.push(i)}}function Rb(t,e,n){const i=n.get(t);if(!i)return!1;let r=e.get(t);return r?i.forEach(t=>r.add(t)):e.set(t,i),n.delete(t),!0}class Nb{constructor(t,e,n){this.bodyNode=t,this._driver=e,this._triggerCache={},this.onRemovalComplete=(t,e)=>{},this._transitionEngine=new xb(t,e,n),this._timelineEngine=new ub(t,e,n),this._transitionEngine.onRemovalComplete=(t,e)=>this.onRemovalComplete(t,e)}registerTrigger(t,e,n,i,r){const s=t+"-"+i;let o=this._triggerCache[s];if(!o){const t=[],e=Pv(this._driver,r,t);if(t.length)throw new Error(`The animation trigger "${i}" has failed to build due to the following errors:\n - ${t.join("\n - ")}`);o=function(t,e){return new ab(t,e)}(i,e),this._triggerCache[s]=o}this._transitionEngine.registerTrigger(e,i,o)}register(t,e){this._transitionEngine.register(t,e)}destroy(t,e){this._transitionEngine.destroy(t,e)}onInsert(t,e,n,i){this._transitionEngine.insertNode(t,e,n,i)}onRemove(t,e,n,i){this._transitionEngine.removeNode(t,e,i||!1,n)}disableAnimations(t,e){this._transitionEngine.markElementAsDisabled(t,e)}process(t,e,n,i){if("@"==n.charAt(0)){const[t,r]=Wy(n);this._timelineEngine.command(t,e,r,i)}else this._transitionEngine.trigger(t,e,n,i)}listen(t,e,n,i,r){if("@"==n.charAt(0)){const[t,i]=Wy(n);return this._timelineEngine.listen(t,e,i,r)}return this._transitionEngine.listen(t,e,n,i,r)}flush(t=-1){this._transitionEngine.flush(t)}get players(){return this._transitionEngine.players.concat(this._timelineEngine.players)}whenRenderingDone(){return this._transitionEngine.whenRenderingDone()}}function Lb(t,e){let n=null,i=null;return Array.isArray(e)&&e.length?(n=Bb(e[0]),e.length>1&&(i=Bb(e[e.length-1]))):e&&(n=Bb(e)),n||i?new Db(t,n,i):null}let Db=(()=>{class t{constructor(e,n,i){this._element=e,this._startStyles=n,this._endStyles=i,this._state=0;let r=t.initialStylesByElement.get(e);r||t.initialStylesByElement.set(e,r={}),this._initialStyles=r}start(){this._state<1&&(this._startStyles&&vv(this._element,this._startStyles,this._initialStyles),this._state=1)}finish(){this.start(),this._state<2&&(vv(this._element,this._initialStyles),this._endStyles&&(vv(this._element,this._endStyles),this._endStyles=null),this._state=1)}destroy(){this.finish(),this._state<3&&(t.initialStylesByElement.delete(this._element),this._startStyles&&(bv(this._element,this._startStyles),this._endStyles=null),this._endStyles&&(bv(this._element,this._endStyles),this._endStyles=null),vv(this._element,this._initialStyles),this._state=3)}}return t.initialStylesByElement=new WeakMap,t})();function Bb(t){let e=null;const n=Object.keys(t);for(let i=0;i<n.length;i++){const r=n[i];Ob(r)&&(e=e||{},e[r]=t[r])}return e}function Ob(t){return"display"===t||"position"===t}const Pb="animation",Fb="animationend";class $b{constructor(t,e,n,i,r,s,o){this._element=t,this._name=e,this._duration=n,this._delay=i,this._easing=r,this._fillMode=s,this._onDoneFn=o,this._finished=!1,this._destroyed=!1,this._startTime=0,this._position=0,this._eventFn=t=>this._handleCallback(t)}apply(){!function(t,e){const n=Wb(t,"").trim();n.length&&(function(t,e){let n=0;for(let i=0;i<t.length;i++)","===t.charAt(i)&&n++}(n),e=`${n}, ${e}`),Gb(t,"",e)}(this._element,`${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`),Vb(this._element,this._eventFn,!1),this._startTime=Date.now()}pause(){zb(this._element,this._name,"paused")}resume(){zb(this._element,this._name,"running")}setPosition(t){const e=Ub(this._element,this._name);this._position=t*this._duration,Gb(this._element,"Delay",`-${this._position}ms`,e)}getPosition(){return this._position}_handleCallback(t){const e=t._ngTestManualTimestamp||Date.now(),n=1e3*parseFloat(t.elapsedTime.toFixed(3));t.animationName==this._name&&Math.max(e-this._startTime,0)>=this._delay&&n>=this._duration&&this.finish()}finish(){this._finished||(this._finished=!0,this._onDoneFn(),Vb(this._element,this._eventFn,!0))}destroy(){this._destroyed||(this._destroyed=!0,this.finish(),function(t,e){const n=Wb(t,"").split(","),i=Hb(n,e);i>=0&&(n.splice(i,1),Gb(t,"",n.join(",")))}(this._element,this._name))}}function zb(t,e,n){Gb(t,"PlayState",n,Ub(t,e))}function Ub(t,e){const n=Wb(t,"");return n.indexOf(",")>0?Hb(n.split(","),e):Hb([n],e)}function Hb(t,e){for(let n=0;n<t.length;n++)if(t[n].indexOf(e)>=0)return n;return-1}function Vb(t,e,n){n?t.removeEventListener(Fb,e):t.addEventListener(Fb,e)}function Gb(t,e,n,i){const r=Pb+e;if(null!=i){const e=t.style[r];if(e.length){const t=e.split(",");t[i]=n,n=t.join(",")}}t.style[r]=n}function Wb(t,e){return t.style[Pb+e]||""}class jb{constructor(t,e,n,i,r,s,o,a){this.element=t,this.keyframes=e,this.animationName=n,this._duration=i,this._delay=r,this._finalStyles=o,this._specialStyles=a,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._started=!1,this.currentSnapshot={},this._state=0,this.easing=s||"linear",this.totalTime=i+r,this._buildStyler()}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}destroy(){this.init(),this._state>=4||(this._state=4,this._styler.destroy(),this._flushStartFns(),this._flushDoneFns(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}_flushDoneFns(){this._onDoneFns.forEach(t=>t()),this._onDoneFns=[]}_flushStartFns(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}finish(){this.init(),this._state>=3||(this._state=3,this._styler.finish(),this._flushStartFns(),this._specialStyles&&this._specialStyles.finish(),this._flushDoneFns())}setPosition(t){this._styler.setPosition(t)}getPosition(){return this._styler.getPosition()}hasStarted(){return this._state>=2}init(){this._state>=1||(this._state=1,this._styler.apply(),this._delay&&this._styler.pause())}play(){this.init(),this.hasStarted()||(this._flushStartFns(),this._state=2,this._specialStyles&&this._specialStyles.start()),this._styler.resume()}pause(){this.init(),this._styler.pause()}restart(){this.reset(),this.play()}reset(){this._styler.destroy(),this._buildStyler(),this._styler.apply()}_buildStyler(){this._styler=new $b(this.element,this.animationName,this._duration,this._delay,this.easing,"forwards",()=>this.finish())}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}beforeDestroy(){this.init();const t={};if(this.hasStarted()){const e=this._state>=3;Object.keys(this._finalStyles).forEach(n=>{"offset"!=n&&(t[n]=e?this._finalStyles[n]:kv(this.element,n))})}this.currentSnapshot=t}}class Qb extends Oy{constructor(t,e){super(),this.element=t,this._startingStyles={},this.__initialized=!1,this._styles=nv(e)}init(){!this.__initialized&&this._startingStyles&&(this.__initialized=!0,Object.keys(this._styles).forEach(t=>{this._startingStyles[t]=this.element.style[t]}),super.init())}play(){this._startingStyles&&(this.init(),Object.keys(this._styles).forEach(t=>this.element.style.setProperty(t,this._styles[t])),super.play())}destroy(){this._startingStyles&&(Object.keys(this._startingStyles).forEach(t=>{const e=this._startingStyles[t];e?this.element.style.setProperty(t,e):this.element.style.removeProperty(t)}),this._startingStyles=null,super.destroy())}}class qb{constructor(){this._count=0,this._head=document.querySelector("head")}validateStyleProperty(t){return Jy(t)}matchesElement(t,e){return Zy(t,e)}containsElement(t,e){return tv(t,e)}query(t,e,n){return ev(t,e,n)}computeStyle(t,e,n){return window.getComputedStyle(t)[e]}buildKeyframeElement(t,e,n){n=n.map(t=>nv(t));let i=`@keyframes ${e} {\n`,r="";n.forEach(t=>{r=" ";const e=parseFloat(t.offset);i+=`${r}${100*e}% {\n`,r+=" ",Object.keys(t).forEach(e=>{const n=t[e];switch(e){case"offset":return;case"easing":return void(n&&(i+=`${r}animation-timing-function: ${n};\n`));default:return void(i+=`${r}${e}: ${n};\n`)}}),i+=`${r}}\n`}),i+="}\n";const s=document.createElement("style");return s.textContent=i,s}animate(t,e,n,i,r,s=[],o){const a=s.filter(t=>t instanceof jb),l={};Iv(n,i)&&a.forEach(t=>{let e=t.currentSnapshot;Object.keys(e).forEach(t=>l[t]=e[t])});const c=function(t){let e={};return t&&(Array.isArray(t)?t:[t]).forEach(t=>{Object.keys(t).forEach(n=>{"offset"!=n&&"easing"!=n&&(e[n]=t[n])})}),e}(e=Tv(t,e,l));if(0==n)return new Qb(t,c);const u="gen_css_kf_"+this._count++,h=this.buildKeyframeElement(t,u,e);document.querySelector("head").appendChild(h);const d=Lb(t,e),p=new jb(t,e,u,n,i,r,c,d);return p.onDestroy(()=>{var t;(t=h).parentNode.removeChild(t)}),p}}class Xb{constructor(t,e,n,i){this.element=t,this.keyframes=e,this.options=n,this._specialStyles=i,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._initialized=!1,this._finished=!1,this._started=!1,this._destroyed=!1,this.time=0,this.parentPlayer=null,this.currentSnapshot={},this._duration=n.duration,this._delay=n.delay||0,this.time=this._duration+this._delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this._buildPlayer(),this._preparePlayerBeforeStart()}_buildPlayer(){if(this._initialized)return;this._initialized=!0;const t=this.keyframes;this.domPlayer=this._triggerWebAnimation(this.element,t,this.options),this._finalKeyframe=t.length?t[t.length-1]:{},this.domPlayer.addEventListener("finish",()=>this._onFinish())}_preparePlayerBeforeStart(){this._delay?this._resetDomPlayerState():this.domPlayer.pause()}_triggerWebAnimation(t,e,n){return t.animate(e,n)}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}play(){this._buildPlayer(),this.hasStarted()||(this._onStartFns.forEach(t=>t()),this._onStartFns=[],this._started=!0,this._specialStyles&&this._specialStyles.start()),this.domPlayer.play()}pause(){this.init(),this.domPlayer.pause()}finish(){this.init(),this._specialStyles&&this._specialStyles.finish(),this._onFinish(),this.domPlayer.finish()}reset(){this._resetDomPlayerState(),this._destroyed=!1,this._finished=!1,this._started=!1}_resetDomPlayerState(){this.domPlayer&&this.domPlayer.cancel()}restart(){this.reset(),this.play()}hasStarted(){return this._started}destroy(){this._destroyed||(this._destroyed=!0,this._resetDomPlayerState(),this._onFinish(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}setPosition(t){void 0===this.domPlayer&&this.init(),this.domPlayer.currentTime=t*this.time}getPosition(){return this.domPlayer.currentTime/this.time}get totalTime(){return this._delay+this._duration}beforeDestroy(){const t={};this.hasStarted()&&Object.keys(this._finalKeyframe).forEach(e=>{"offset"!=e&&(t[e]=this._finished?this._finalKeyframe[e]:kv(this.element,e))}),this.currentSnapshot=t}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}}class Yb{constructor(){this._isNativeImpl=/\{\s*\[native\s+code\]\s*\}/.test(Kb().toString()),this._cssKeyframesDriver=new qb}validateStyleProperty(t){return Jy(t)}matchesElement(t,e){return Zy(t,e)}containsElement(t,e){return tv(t,e)}query(t,e,n){return ev(t,e,n)}computeStyle(t,e,n){return window.getComputedStyle(t)[e]}overrideWebAnimationsSupport(t){this._isNativeImpl=t}animate(t,e,n,i,r,s=[],o){if(!o&&!this._isNativeImpl)return this._cssKeyframesDriver.animate(t,e,n,i,r,s);const a={duration:n,delay:i,fill:0==i?"both":"forwards"};r&&(a.easing=r);const l={},c=s.filter(t=>t instanceof Xb);Iv(n,i)&&c.forEach(t=>{let e=t.currentSnapshot;Object.keys(e).forEach(t=>l[t]=e[t])});const u=Lb(t,e=Tv(t,e=e.map(t=>mv(t,!1)),l));return new Xb(t,e,a,u)}}function Kb(){return"undefined"!=typeof window&&void 0!==window.document&&Element.prototype.animate||{}}let Jb=(()=>{class t extends Cy{constructor(t,e){super(),this._nextAnimationId=0,this._renderer=t.createRenderer(e.body,{id:"0",encapsulation:ae.None,styles:[],data:{animation:[]}})}build(t){const e=this._nextAnimationId.toString();this._nextAnimationId++;const n=Array.isArray(t)?ky(t):t;return eA(this._renderer,null,e,"register",[n]),new Zb(e,this._renderer)}}return t.\u0275fac=function(e){return new(e||t)(Xi(Tl),Xi(Zu))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();class Zb extends class{}{constructor(t,e){super(),this._id=t,this._renderer=e}create(t,e){return new tA(this._id,t,e||{},this._renderer)}}class tA{constructor(t,e,n,i){this.id=t,this.element=e,this._renderer=i,this.parentPlayer=null,this._started=!1,this.totalTime=0,this._command("create",n)}_listen(t,e){return this._renderer.listen(this.element,`@@${this.id}:${t}`,e)}_command(t,...e){return eA(this._renderer,this.element,this.id,t,e)}onDone(t){this._listen("done",t)}onStart(t){this._listen("start",t)}onDestroy(t){this._listen("destroy",t)}init(){this._command("init")}hasStarted(){return this._started}play(){this._command("play"),this._started=!0}pause(){this._command("pause")}restart(){this._command("restart")}finish(){this._command("finish")}destroy(){this._command("destroy")}reset(){this._command("reset")}setPosition(t){this._command("setPosition",t)}getPosition(){var t,e;return null!==(e=null===(t=this._renderer.engine.players[+this.id])||void 0===t?void 0:t.getPosition())&&void 0!==e?e:0}}function eA(t,e,n,i,r){return t.setProperty(e,`@@${n}:${i}`,r)}const nA="@",iA="@.disabled";let rA=(()=>{class t{constructor(t,e,n){this.delegate=t,this.engine=e,this._zone=n,this._currentId=0,this._microtaskId=1,this._animationCallbacksBuffer=[],this._rendererCache=new Map,this._cdRecurDepth=0,this.promise=Promise.resolve(0),e.onRemovalComplete=(t,e)=>{e&&e.parentNode(t)&&e.removeChild(t.parentNode,t)}}createRenderer(t,e){const n=this.delegate.createRenderer(t,e);if(!(t&&e&&e.data&&e.data.animation)){let t=this._rendererCache.get(n);return t||(t=new sA("",n,this.engine),this._rendererCache.set(n,t)),t}const i=e.id,r=e.id+"-"+this._currentId;this._currentId++,this.engine.register(r,t);const s=e=>{Array.isArray(e)?e.forEach(s):this.engine.registerTrigger(i,r,t,e.name,e)};return e.data.animation.forEach(s),new oA(this,r,n,this.engine)}begin(){this._cdRecurDepth++,this.delegate.begin&&this.delegate.begin()}_scheduleCountTask(){this.promise.then(()=>{this._microtaskId++})}scheduleListenerCallback(t,e,n){t>=0&&t<this._microtaskId?this._zone.run(()=>e(n)):(0==this._animationCallbacksBuffer.length&&Promise.resolve(null).then(()=>{this._zone.run(()=>{this._animationCallbacksBuffer.forEach(t=>{const[e,n]=t;e(n)}),this._animationCallbacksBuffer=[]})}),this._animationCallbacksBuffer.push([e,n]))}end(){this._cdRecurDepth--,0==this._cdRecurDepth&&this._zone.runOutsideAngular(()=>{this._scheduleCountTask(),this.engine.flush(this._microtaskId)}),this.delegate.end&&this.delegate.end()}whenRenderingDone(){return this.engine.whenRenderingDone()}}return t.\u0275fac=function(e){return new(e||t)(Xi(Tl),Xi(Nb),Xi(Au))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();class sA{constructor(t,e,n){this.namespaceId=t,this.delegate=e,this.engine=n,this.destroyNode=this.delegate.destroyNode?t=>e.destroyNode(t):null}get data(){return this.delegate.data}destroy(){this.engine.destroy(this.namespaceId,this.delegate),this.delegate.destroy()}createElement(t,e){return this.delegate.createElement(t,e)}createComment(t){return this.delegate.createComment(t)}createText(t){return this.delegate.createText(t)}appendChild(t,e){this.delegate.appendChild(t,e),this.engine.onInsert(this.namespaceId,e,t,!1)}insertBefore(t,e,n,i=!0){this.delegate.insertBefore(t,e,n),this.engine.onInsert(this.namespaceId,e,t,i)}removeChild(t,e,n){this.engine.onRemove(this.namespaceId,e,this.delegate,n)}selectRootElement(t,e){return this.delegate.selectRootElement(t,e)}parentNode(t){return this.delegate.parentNode(t)}nextSibling(t){return this.delegate.nextSibling(t)}setAttribute(t,e,n,i){this.delegate.setAttribute(t,e,n,i)}removeAttribute(t,e,n){this.delegate.removeAttribute(t,e,n)}addClass(t,e){this.delegate.addClass(t,e)}removeClass(t,e){this.delegate.removeClass(t,e)}setStyle(t,e,n,i){this.delegate.setStyle(t,e,n,i)}removeStyle(t,e,n){this.delegate.removeStyle(t,e,n)}setProperty(t,e,n){e.charAt(0)==nA&&e==iA?this.disableAnimations(t,!!n):this.delegate.setProperty(t,e,n)}setValue(t,e){this.delegate.setValue(t,e)}listen(t,e,n){return this.delegate.listen(t,e,n)}disableAnimations(t,e){this.engine.disableAnimations(t,e)}}class oA extends sA{constructor(t,e,n,i){super(e,n,i),this.factory=t,this.namespaceId=e}setProperty(t,e,n){e.charAt(0)==nA?"."==e.charAt(1)&&e==iA?this.disableAnimations(t,n=void 0===n||!!n):this.engine.process(this.namespaceId,t,e.substr(1),n):this.delegate.setProperty(t,e,n)}listen(t,e,n){if(e.charAt(0)==nA){const i=function(t){switch(t){case"body":return document.body;case"document":return document;case"window":return window;default:return t}}(t);let r=e.substr(1),s="";return r.charAt(0)!=nA&&([r,s]=function(t){const e=t.indexOf(".");return[t.substring(0,e),t.substr(e+1)]}(r)),this.engine.listen(this.namespaceId,i,r,s,t=>{this.factory.scheduleListenerCallback(t._data||-1,n,t)})}return this.delegate.listen(t,e,n)}}let aA=(()=>{class t extends Nb{constructor(t,e,n){super(t.body,e,n)}}return t.\u0275fac=function(e){return new(e||t)(Xi(Zu),Xi(rv),Xi(tb))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();const lA=new Ri("AnimationModuleType"),cA=[{provide:rv,useFactory:function(){return"function"==typeof Kb()?new Yb:new qb}},{provide:lA,useValue:"BrowserAnimations"},{provide:Cy,useClass:Jb},{provide:tb,useFactory:function(){return new eb}},{provide:Nb,useClass:aA},{provide:Tl,useFactory:function(t,e,n){return new rA(t,e,n)},deps:[pd,Nb,Au]}];let uA=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({providers:cA,imports:[Id]}),t})();const hA=new Nl("11.2.13"),dA=new Ri("mat-sanity-checks",{providedIn:"root",factory:function(){return!0}});let pA,fA=(()=>{class t{constructor(t,e,n){this._hasDoneGlobalChecks=!1,this._document=n,t._applyBodyHighContrastModeCssClasses(),this._sanityChecks=e,this._hasDoneGlobalChecks||(this._checkDoctypeIsDefined(),this._checkThemeIsPresent(),this._checkCdkVersionMatch(),this._hasDoneGlobalChecks=!0)}_getWindow(){const t=this._document.defaultView||window;return"object"==typeof t&&t?t:null}_checksAreEnabled(){return Du()&&!this._isTestEnv()}_isTestEnv(){const t=this._getWindow();return t&&(t.__karma__||t.jasmine)}_checkDoctypeIsDefined(){this._checksAreEnabled()&&(!0===this._sanityChecks||this._sanityChecks.doctype)&&!this._document.doctype&&console.warn("Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.")}_checkThemeIsPresent(){if(!this._checksAreEnabled()||!1===this._sanityChecks||!this._sanityChecks.theme||!this._document.body||"function"!=typeof getComputedStyle)return;const t=this._document.createElement("div");t.classList.add("mat-theme-loaded-marker"),this._document.body.appendChild(t);const e=getComputedStyle(t);e&&"none"!==e.display&&console.warn("Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming"),this._document.body.removeChild(t)}_checkCdkVersionMatch(){this._checksAreEnabled()&&(!0===this._sanityChecks||this._sanityChecks.version)&&hA.full!==Ey.full&&console.warn("The Angular Material version ("+hA.full+") does not match the Angular CDK version ("+Ey.full+").\nPlease ensure the versions of these two packages exactly match.")}}return t.\u0275fac=function(e){return new(e||t)(Xi(Ay),Xi(dA,8),Xi(Zu))},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[[Sy],Sy]}),t})();function mA(t){return class extends t{constructor(...t){super(...t),this._disabled=!1}get disabled(){return this._disabled}set disabled(t){this._disabled=kg(t)}}}function gA(t,e){return class extends t{constructor(...t){super(...t),this.defaultColor=e,this.color=e}get color(){return this._color}set color(t){const e=t||this.defaultColor;e!==this._color&&(this._color&&this._elementRef.nativeElement.classList.remove(`mat-${this._color}`),e&&this._elementRef.nativeElement.classList.add(`mat-${e}`),this._color=e)}}}function yA(t){return class extends t{constructor(...t){super(...t),this._disableRipple=!1}get disableRipple(){return this._disableRipple}set disableRipple(t){this._disableRipple=kg(t)}}}try{pA="undefined"!=typeof Intl}catch(GTt){pA=!1}let vA=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=ke({type:t,selectors:[["","mat-line",""],["","matLine",""]],hostAttrs:[1,"mat-line"]}),t})();function bA(t,e,n){const i=t.nativeElement.classList;n?i.add(e):i.remove(e)}let AA=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[[fA],fA]}),t})();class xA{constructor(t,e,n){this._renderer=t,this.element=e,this.config=n,this.state=3}fadeOut(){this._renderer.fadeOutRipple(this)}}const wA={enterDuration:450,exitDuration:400},_A=Hg({passive:!0}),SA=["mousedown","touchstart"],EA=["mouseup","mouseleave","touchend","touchcancel"];class CA{constructor(t,e,n,i){this._target=t,this._ngZone=e,this._isPointerDown=!1,this._activeRipples=new Set,this._pointerUpEventsRegistered=!1,i.isBrowser&&(this._containerElement=Dg(n))}fadeInRipple(t,e,n={}){const i=this._containerRect=this._containerRect||this._containerElement.getBoundingClientRect(),r=Object.assign(Object.assign({},wA),n.animation);n.centered&&(t=i.left+i.width/2,e=i.top+i.height/2);const s=n.radius||function(t,e,n){const i=Math.max(Math.abs(t-n.left),Math.abs(t-n.right)),r=Math.max(Math.abs(e-n.top),Math.abs(e-n.bottom));return Math.sqrt(i*i+r*r)}(t,e,i),o=t-i.left,a=e-i.top,l=r.enterDuration,c=document.createElement("div");c.classList.add("mat-ripple-element"),c.style.left=o-s+"px",c.style.top=a-s+"px",c.style.height=2*s+"px",c.style.width=2*s+"px",null!=n.color&&(c.style.backgroundColor=n.color),c.style.transitionDuration=`${l}ms`,this._containerElement.appendChild(c),window.getComputedStyle(c).getPropertyValue("opacity"),c.style.transform="scale(1)";const u=new xA(this,c,n);return u.state=0,this._activeRipples.add(u),n.persistent||(this._mostRecentTransientRipple=u),this._runTimeoutOutsideZone(()=>{const t=u===this._mostRecentTransientRipple;u.state=1,n.persistent||t&&this._isPointerDown||u.fadeOut()},l),u}fadeOutRipple(t){const e=this._activeRipples.delete(t);if(t===this._mostRecentTransientRipple&&(this._mostRecentTransientRipple=null),this._activeRipples.size||(this._containerRect=null),!e)return;const n=t.element,i=Object.assign(Object.assign({},wA),t.config.animation);n.style.transitionDuration=`${i.exitDuration}ms`,n.style.opacity="0",t.state=2,this._runTimeoutOutsideZone(()=>{t.state=3,n.parentNode.removeChild(n)},i.exitDuration)}fadeOutAll(){this._activeRipples.forEach(t=>t.fadeOut())}fadeOutAllNonPersistent(){this._activeRipples.forEach(t=>{t.config.persistent||t.fadeOut()})}setupTriggerEvents(t){const e=Dg(t);e&&e!==this._triggerElement&&(this._removeTriggerEvents(),this._triggerElement=e,this._registerEvents(SA))}handleEvent(t){"mousedown"===t.type?this._onMousedown(t):"touchstart"===t.type?this._onTouchStart(t):this._onPointerUp(),this._pointerUpEventsRegistered||(this._registerEvents(EA),this._pointerUpEventsRegistered=!0)}_onMousedown(t){const e=uy(t),n=this._lastTouchStartEvent&&Date.now()<this._lastTouchStartEvent+800;this._target.rippleDisabled||e||n||(this._isPointerDown=!0,this.fadeInRipple(t.clientX,t.clientY,this._target.rippleConfig))}_onTouchStart(t){if(!this._target.rippleDisabled&&!hy(t)){this._lastTouchStartEvent=Date.now(),this._isPointerDown=!0;const e=t.changedTouches;for(let t=0;t<e.length;t++)this.fadeInRipple(e[t].clientX,e[t].clientY,this._target.rippleConfig)}}_onPointerUp(){this._isPointerDown&&(this._isPointerDown=!1,this._activeRipples.forEach(t=>{!t.config.persistent&&(1===t.state||t.config.terminateOnPointerUp&&0===t.state)&&t.fadeOut()}))}_runTimeoutOutsideZone(t,e=0){this._ngZone.runOutsideAngular(()=>setTimeout(t,e))}_registerEvents(t){this._ngZone.runOutsideAngular(()=>{t.forEach(t=>{this._triggerElement.addEventListener(t,this,_A)})})}_removeTriggerEvents(){this._triggerElement&&(SA.forEach(t=>{this._triggerElement.removeEventListener(t,this,_A)}),this._pointerUpEventsRegistered&&EA.forEach(t=>{this._triggerElement.removeEventListener(t,this,_A)}))}}const IA=new Ri("mat-ripple-global-options");let TA=(()=>{class t{constructor(t,e,n,i,r){this._elementRef=t,this._animationMode=r,this.radius=0,this._disabled=!1,this._isInitialized=!1,this._globalOptions=i||{},this._rippleRenderer=new CA(this,e,t,n)}get disabled(){return this._disabled}set disabled(t){t&&this.fadeOutAllNonPersistent(),this._disabled=t,this._setupTriggerEventsIfEnabled()}get trigger(){return this._trigger||this._elementRef.nativeElement}set trigger(t){this._trigger=t,this._setupTriggerEventsIfEnabled()}ngOnInit(){this._isInitialized=!0,this._setupTriggerEventsIfEnabled()}ngOnDestroy(){this._rippleRenderer._removeTriggerEvents()}fadeOutAll(){this._rippleRenderer.fadeOutAll()}fadeOutAllNonPersistent(){this._rippleRenderer.fadeOutAllNonPersistent()}get rippleConfig(){return{centered:this.centered,radius:this.radius,color:this.color,animation:Object.assign(Object.assign(Object.assign({},this._globalOptions.animation),"NoopAnimations"===this._animationMode?{enterDuration:0,exitDuration:0}:{}),this.animation),terminateOnPointerUp:this._globalOptions.terminateOnPointerUp}}get rippleDisabled(){return this.disabled||!!this._globalOptions.disabled}_setupTriggerEventsIfEnabled(){!this.disabled&&this._isInitialized&&this._rippleRenderer.setupTriggerEvents(this.trigger)}launch(t,e=0,n){return"number"==typeof t?this._rippleRenderer.fadeInRipple(t,e,Object.assign(Object.assign({},this.rippleConfig),n)):this._rippleRenderer.fadeInRipple(0,0,Object.assign(Object.assign({},this.rippleConfig),t))}}return t.\u0275fac=function(e){return new(e||t)(pa(Cl),pa(Au),pa(zg),pa(IA,8),pa(lA,8))},t.\u0275dir=ke({type:t,selectors:[["","mat-ripple",""],["","matRipple",""]],hostAttrs:[1,"mat-ripple"],hostVars:2,hostBindings:function(t,e){2&t&&Ua("mat-ripple-unbounded",e.unbounded)},inputs:{radius:["matRippleRadius","radius"],disabled:["matRippleDisabled","disabled"],trigger:["matRippleTrigger","trigger"],color:["matRippleColor","color"],unbounded:["matRippleUnbounded","unbounded"],centered:["matRippleCentered","centered"],animation:["matRippleAnimation","animation"]},exportAs:["matRipple"]}),t})(),MA=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[[fA,Ug],fA]}),t})(),kA=(()=>{class t{constructor(t){this._animationMode=t,this.state="unchecked",this.disabled=!1}}return t.\u0275fac=function(e){return new(e||t)(pa(lA,8))},t.\u0275cmp=Se({type:t,selectors:[["mat-pseudo-checkbox"]],hostAttrs:[1,"mat-pseudo-checkbox"],hostVars:8,hostBindings:function(t,e){2&t&&Ua("mat-pseudo-checkbox-indeterminate","indeterminate"===e.state)("mat-pseudo-checkbox-checked","checked"===e.state)("mat-pseudo-checkbox-disabled",e.disabled)("_mat-animation-noopable","NoopAnimations"===e._animationMode)},inputs:{state:"state",disabled:"disabled"},decls:0,vars:0,template:function(t,e){},styles:['.mat-pseudo-checkbox{width:16px;height:16px;border:2px solid;border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1),background-color 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:"";border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox.mat-pseudo-checkbox-indeterminate{border-color:transparent}._mat-animation-noopable.mat-pseudo-checkbox{transition:none;animation:none}._mat-animation-noopable.mat-pseudo-checkbox::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{top:5px;left:1px;width:10px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{top:2.4px;left:1px;width:8px;height:3px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}\n'],encapsulation:2,changeDetection:0}),t})(),RA=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[[fA]]}),t})();const NA=["*",[["mat-toolbar-row"]]],LA=["*","mat-toolbar-row"];class DA{constructor(t){this._elementRef=t}}const BA=gA(DA);let OA=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=ke({type:t,selectors:[["mat-toolbar-row"]],hostAttrs:[1,"mat-toolbar-row"],exportAs:["matToolbarRow"]}),t})(),PA=(()=>{class t extends BA{constructor(t,e,n){super(t),this._platform=e,this._document=n}ngAfterViewInit(){this._platform.isBrowser&&(this._checkToolbarMixedModes(),this._toolbarRows.changes.subscribe(()=>this._checkToolbarMixedModes()))}_checkToolbarMixedModes(){}}return t.\u0275fac=function(e){return new(e||t)(pa(Cl),pa(zg),pa(Zu))},t.\u0275cmp=Se({type:t,selectors:[["mat-toolbar"]],contentQueries:function(t,e,n){if(1&t&&jc(n,OA,1),2&t){let t;Gc(t=Qc())&&(e._toolbarRows=t)}},hostAttrs:[1,"mat-toolbar"],hostVars:4,hostBindings:function(t,e){2&t&&Ua("mat-toolbar-multiple-rows",e._toolbarRows.length>0)("mat-toolbar-single-row",0===e._toolbarRows.length)},inputs:{color:"color"},exportAs:["matToolbar"],features:[Ko],ngContentSelectors:LA,decls:2,vars:0,template:function(t,e){1&t&&(Na(NA),La(0),La(1,1))},styles:[".cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}\n"],encapsulation:2,changeDetection:0}),t})(),FA=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[[fA],fA]}),t})();const $A=["mat-button",""],zA=["*"],UA=["mat-button","mat-flat-button","mat-icon-button","mat-raised-button","mat-stroked-button","mat-mini-fab","mat-fab"];class HA{constructor(t){this._elementRef=t}}const VA=gA(mA(yA(HA)));let GA=(()=>{class t extends VA{constructor(t,e,n){super(t),this._focusMonitor=e,this._animationMode=n,this.isRoundButton=this._hasHostAttributes("mat-fab","mat-mini-fab"),this.isIconButton=this._hasHostAttributes("mat-icon-button");for(const i of UA)this._hasHostAttributes(i)&&this._getHostElement().classList.add(i);t.nativeElement.classList.add("mat-button-base"),this.isRoundButton&&(this.color="accent")}ngAfterViewInit(){this._focusMonitor.monitor(this._elementRef,!0)}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef)}focus(t,e){t?this._focusMonitor.focusVia(this._getHostElement(),t,e):this._getHostElement().focus(e)}_getHostElement(){return this._elementRef.nativeElement}_isRippleDisabled(){return this.disableRipple||this.disabled}_hasHostAttributes(...t){return t.some(t=>this._getHostElement().hasAttribute(t))}}return t.\u0275fac=function(e){return new(e||t)(pa(Cl),pa(fy),pa(lA,8))},t.\u0275cmp=Se({type:t,selectors:[["button","mat-button",""],["button","mat-raised-button",""],["button","mat-icon-button",""],["button","mat-fab",""],["button","mat-mini-fab",""],["button","mat-stroked-button",""],["button","mat-flat-button",""]],viewQuery:function(t,e){if(1&t&&Wc(TA,1),2&t){let t;Gc(t=Qc())&&(e.ripple=t.first)}},hostAttrs:[1,"mat-focus-indicator"],hostVars:5,hostBindings:function(t,e){2&t&&(ua("disabled",e.disabled||null),Ua("_mat-animation-noopable","NoopAnimations"===e._animationMode)("mat-button-disabled",e.disabled))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color"},exportAs:["matButton"],features:[Ko],attrs:$A,ngContentSelectors:zA,decls:4,vars:5,consts:[[1,"mat-button-wrapper"],["matRipple","",1,"mat-button-ripple",3,"matRippleDisabled","matRippleCentered","matRippleTrigger"],[1,"mat-button-focus-overlay"]],template:function(t,e){1&t&&(Na(),ga(0,"span",0),La(1),ya(),va(2,"span",1),va(3,"span",2)),2&t&&(Bs(2),Ua("mat-button-ripple-round",e.isRoundButton||e.isIconButton),fa("matRippleDisabled",e._isRippleDisabled())("matRippleCentered",e.isIconButton)("matRippleTrigger",e._getHostElement()))},directives:[TA],styles:[".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:inline-flex;justify-content:center;align-items:center;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}\n"],encapsulation:2,changeDetection:0}),t})(),WA=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[[MA,fA],fA]}),t})();function jA(t,e){return new X(e?n=>e.schedule(QA,0,{error:t,subscriber:n}):e=>e.error(t))}function QA({error:t,subscriber:e}){e.error(t)}function qA(...t){if(1===t.length){const e=t[0];if($(e))return XA(e,null);if(z(e)&&Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);return XA(t.map(t=>e[t]),t)}}if("function"==typeof t[t.length-1]){const e=t.pop();return XA(t=1===t.length&&$(t[0])?t[0]:t,null).pipe(it(t=>e(...t)))}return XA(t,null)}function XA(t,e){return new X(n=>{const i=t.length;if(0===i)return void n.complete();const r=new Array(i);let s=0,o=0;for(let a=0;a<i;a++){const l=pt(t[a]);let c=!1;n.add(l.subscribe({next:t=>{c||(c=!0,o++),r[a]=t},error:t=>n.error(t),complete:()=>{s++,s!==i&&c||(o===i&&n.next(e?e.reduce((t,e,n)=>(t[e]=r[n],t),{}):r),n.complete())}}))}})}class YA{}class KA{}class JA{constructor(t){this.normalizedNames=new Map,this.lazyUpdate=null,t?this.lazyInit="string"==typeof t?()=>{this.headers=new Map,t.split("\n").forEach(t=>{const e=t.indexOf(":");if(e>0){const n=t.slice(0,e),i=n.toLowerCase(),r=t.slice(e+1).trim();this.maybeSetNormalizedName(n,i),this.headers.has(i)?this.headers.get(i).push(r):this.headers.set(i,[r])}})}:()=>{this.headers=new Map,Object.keys(t).forEach(e=>{let n=t[e];const i=e.toLowerCase();"string"==typeof n&&(n=[n]),n.length>0&&(this.headers.set(i,n),this.maybeSetNormalizedName(e,i))})}:this.headers=new Map}has(t){return this.init(),this.headers.has(t.toLowerCase())}get(t){this.init();const e=this.headers.get(t.toLowerCase());return e&&e.length>0?e[0]:null}keys(){return this.init(),Array.from(this.normalizedNames.values())}getAll(t){return this.init(),this.headers.get(t.toLowerCase())||null}append(t,e){return this.clone({name:t,value:e,op:"a"})}set(t,e){return this.clone({name:t,value:e,op:"s"})}delete(t,e){return this.clone({name:t,value:e,op:"d"})}maybeSetNormalizedName(t,e){this.normalizedNames.has(e)||this.normalizedNames.set(e,t)}init(){this.lazyInit&&(this.lazyInit instanceof JA?this.copyFrom(this.lazyInit):this.lazyInit(),this.lazyInit=null,this.lazyUpdate&&(this.lazyUpdate.forEach(t=>this.applyUpdate(t)),this.lazyUpdate=null))}copyFrom(t){t.init(),Array.from(t.headers.keys()).forEach(e=>{this.headers.set(e,t.headers.get(e)),this.normalizedNames.set(e,t.normalizedNames.get(e))})}clone(t){const e=new JA;return e.lazyInit=this.lazyInit&&this.lazyInit instanceof JA?this.lazyInit:this,e.lazyUpdate=(this.lazyUpdate||[]).concat([t]),e}applyUpdate(t){const e=t.name.toLowerCase();switch(t.op){case"a":case"s":let n=t.value;if("string"==typeof n&&(n=[n]),0===n.length)return;this.maybeSetNormalizedName(t.name,e);const i=("a"===t.op?this.headers.get(e):void 0)||[];i.push(...n),this.headers.set(e,i);break;case"d":const r=t.value;if(r){let t=this.headers.get(e);if(!t)return;t=t.filter(t=>-1===r.indexOf(t)),0===t.length?(this.headers.delete(e),this.normalizedNames.delete(e)):this.headers.set(e,t)}else this.headers.delete(e),this.normalizedNames.delete(e)}}forEach(t){this.init(),Array.from(this.normalizedNames.keys()).forEach(e=>t(this.normalizedNames.get(e),this.headers.get(e)))}}class ZA{encodeKey(t){return tx(t)}encodeValue(t){return tx(t)}decodeKey(t){return decodeURIComponent(t)}decodeValue(t){return decodeURIComponent(t)}}function tx(t){return encodeURIComponent(t).replace(/%40/gi,"@").replace(/%3A/gi,":").replace(/%24/gi,"$").replace(/%2C/gi,",").replace(/%3B/gi,";").replace(/%2B/gi,"+").replace(/%3D/gi,"=").replace(/%3F/gi,"?").replace(/%2F/gi,"/")}class ex{constructor(t={}){if(this.updates=null,this.cloneFrom=null,this.encoder=t.encoder||new ZA,t.fromString){if(t.fromObject)throw new Error("Cannot specify both fromString and fromObject.");this.map=function(t,e){const n=new Map;return t.length>0&&t.replace(/^\?/,"").split("&").forEach(t=>{const i=t.indexOf("="),[r,s]=-1==i?[e.decodeKey(t),""]:[e.decodeKey(t.slice(0,i)),e.decodeValue(t.slice(i+1))],o=n.get(r)||[];o.push(s),n.set(r,o)}),n}(t.fromString,this.encoder)}else t.fromObject?(this.map=new Map,Object.keys(t.fromObject).forEach(e=>{const n=t.fromObject[e];this.map.set(e,Array.isArray(n)?n:[n])})):this.map=null}has(t){return this.init(),this.map.has(t)}get(t){this.init();const e=this.map.get(t);return e?e[0]:null}getAll(t){return this.init(),this.map.get(t)||null}keys(){return this.init(),Array.from(this.map.keys())}append(t,e){return this.clone({param:t,value:e,op:"a"})}appendAll(t){const e=[];return Object.keys(t).forEach(n=>{const i=t[n];Array.isArray(i)?i.forEach(t=>{e.push({param:n,value:t,op:"a"})}):e.push({param:n,value:i,op:"a"})}),this.clone(e)}set(t,e){return this.clone({param:t,value:e,op:"s"})}delete(t,e){return this.clone({param:t,value:e,op:"d"})}toString(){return this.init(),this.keys().map(t=>{const e=this.encoder.encodeKey(t);return this.map.get(t).map(t=>e+"="+this.encoder.encodeValue(t)).join("&")}).filter(t=>""!==t).join("&")}clone(t){const e=new ex({encoder:this.encoder});return e.cloneFrom=this.cloneFrom||this,e.updates=(this.updates||[]).concat(t),e}init(){null===this.map&&(this.map=new Map),null!==this.cloneFrom&&(this.cloneFrom.init(),this.cloneFrom.keys().forEach(t=>this.map.set(t,this.cloneFrom.map.get(t))),this.updates.forEach(t=>{switch(t.op){case"a":case"s":const e=("a"===t.op?this.map.get(t.param):void 0)||[];e.push(t.value),this.map.set(t.param,e);break;case"d":if(void 0===t.value){this.map.delete(t.param);break}{let e=this.map.get(t.param)||[];const n=e.indexOf(t.value);-1!==n&&e.splice(n,1),e.length>0?this.map.set(t.param,e):this.map.delete(t.param)}}}),this.cloneFrom=this.updates=null)}}function nx(t){return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer}function ix(t){return"undefined"!=typeof Blob&&t instanceof Blob}function rx(t){return"undefined"!=typeof FormData&&t instanceof FormData}class sx{constructor(t,e,n,i){let r;if(this.url=e,this.body=null,this.reportProgress=!1,this.withCredentials=!1,this.responseType="json",this.method=t.toUpperCase(),function(t){switch(t){case"DELETE":case"GET":case"HEAD":case"OPTIONS":case"JSONP":return!1;default:return!0}}(this.method)||i?(this.body=void 0!==n?n:null,r=i):r=n,r&&(this.reportProgress=!!r.reportProgress,this.withCredentials=!!r.withCredentials,r.responseType&&(this.responseType=r.responseType),r.headers&&(this.headers=r.headers),r.params&&(this.params=r.params)),this.headers||(this.headers=new JA),this.params){const t=this.params.toString();if(0===t.length)this.urlWithParams=e;else{const n=e.indexOf("?");this.urlWithParams=e+(-1===n?"?":n<e.length-1?"&":"")+t}}else this.params=new ex,this.urlWithParams=e}serializeBody(){return null===this.body?null:nx(this.body)||ix(this.body)||rx(this.body)||"string"==typeof this.body?this.body:this.body instanceof ex?this.body.toString():"object"==typeof this.body||"boolean"==typeof this.body||Array.isArray(this.body)?JSON.stringify(this.body):this.body.toString()}detectContentTypeHeader(){return null===this.body||rx(this.body)?null:ix(this.body)?this.body.type||null:nx(this.body)?null:"string"==typeof this.body?"text/plain":this.body instanceof ex?"application/x-www-form-urlencoded;charset=UTF-8":"object"==typeof this.body||"number"==typeof this.body||"boolean"==typeof this.body?"application/json":null}clone(t={}){const e=t.method||this.method,n=t.url||this.url,i=t.responseType||this.responseType,r=void 0!==t.body?t.body:this.body,s=void 0!==t.withCredentials?t.withCredentials:this.withCredentials,o=void 0!==t.reportProgress?t.reportProgress:this.reportProgress;let a=t.headers||this.headers,l=t.params||this.params;return void 0!==t.setHeaders&&(a=Object.keys(t.setHeaders).reduce((e,n)=>e.set(n,t.setHeaders[n]),a)),t.setParams&&(l=Object.keys(t.setParams).reduce((e,n)=>e.set(n,t.setParams[n]),l)),new sx(e,n,r,{params:l,headers:a,reportProgress:o,responseType:i,withCredentials:s})}}var ox=function(t){return t[t.Sent=0]="Sent",t[t.UploadProgress=1]="UploadProgress",t[t.ResponseHeader=2]="ResponseHeader",t[t.DownloadProgress=3]="DownloadProgress",t[t.Response=4]="Response",t[t.User=5]="User",t}({});class ax{constructor(t,e=200,n="OK"){this.headers=t.headers||new JA,this.status=void 0!==t.status?t.status:e,this.statusText=t.statusText||n,this.url=t.url||null,this.ok=this.status>=200&&this.status<300}}class lx extends ax{constructor(t={}){super(t),this.type=ox.ResponseHeader}clone(t={}){return new lx({headers:t.headers||this.headers,status:void 0!==t.status?t.status:this.status,statusText:t.statusText||this.statusText,url:t.url||this.url||void 0})}}class cx extends ax{constructor(t={}){super(t),this.type=ox.Response,this.body=void 0!==t.body?t.body:null}clone(t={}){return new cx({body:void 0!==t.body?t.body:this.body,headers:t.headers||this.headers,status:void 0!==t.status?t.status:this.status,statusText:t.statusText||this.statusText,url:t.url||this.url||void 0})}}class ux extends ax{constructor(t){super(t,0,"Unknown Error"),this.name="HttpErrorResponse",this.ok=!1,this.message=this.status>=200&&this.status<300?`Http failure during parsing for ${t.url||"(unknown url)"}`:`Http failure response for ${t.url||"(unknown url)"}: ${t.status} ${t.statusText}`,this.error=t.error||null}}function hx(t,e){return{body:e,headers:t.headers,observe:t.observe,params:t.params,reportProgress:t.reportProgress,responseType:t.responseType,withCredentials:t.withCredentials}}let dx=(()=>{class t{constructor(t){this.handler=t}request(t,e,n={}){let i;if(t instanceof sx)i=t;else{let r,s;r=n.headers instanceof JA?n.headers:new JA(n.headers),n.params&&(s=n.params instanceof ex?n.params:new ex({fromObject:n.params})),i=new sx(t,e,void 0!==n.body?n.body:null,{headers:r,params:s,reportProgress:n.reportProgress,responseType:n.responseType||"json",withCredentials:n.withCredentials})}const r=Rd(i).pipe(lp(t=>this.handler.handle(t)));if(t instanceof sx||"events"===n.observe)return r;const s=r.pipe(np(t=>t instanceof cx));switch(n.observe||"body"){case"body":switch(i.responseType){case"arraybuffer":return s.pipe(it(t=>{if(null!==t.body&&!(t.body instanceof ArrayBuffer))throw new Error("Response is not an ArrayBuffer.");return t.body}));case"blob":return s.pipe(it(t=>{if(null!==t.body&&!(t.body instanceof Blob))throw new Error("Response is not a Blob.");return t.body}));case"text":return s.pipe(it(t=>{if(null!==t.body&&"string"!=typeof t.body)throw new Error("Response is not a string.");return t.body}));case"json":default:return s.pipe(it(t=>t.body))}case"response":return s;default:throw new Error(`Unreachable: unhandled observe type ${n.observe}}`)}}delete(t,e={}){return this.request("DELETE",t,e)}get(t,e={}){return this.request("GET",t,e)}head(t,e={}){return this.request("HEAD",t,e)}jsonp(t,e){return this.request("JSONP",t,{params:(new ex).append(e,"JSONP_CALLBACK"),observe:"body",responseType:"json"})}options(t,e={}){return this.request("OPTIONS",t,e)}patch(t,e,n={}){return this.request("PATCH",t,hx(n,e))}post(t,e,n={}){return this.request("POST",t,hx(n,e))}put(t,e,n={}){return this.request("PUT",t,hx(n,e))}}return t.\u0275fac=function(e){return new(e||t)(Xi(YA))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();class px{constructor(t,e){this.next=t,this.interceptor=e}handle(t){return this.interceptor.intercept(t,this.next)}}const fx=new Ri("HTTP_INTERCEPTORS");let mx=(()=>{class t{intercept(t,e){return e.handle(t)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();const gx=/^\)\]\}',?\n/;class yx{}let vx=(()=>{class t{constructor(){}build(){return new XMLHttpRequest}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})(),bx=(()=>{class t{constructor(t){this.xhrFactory=t}handle(t){if("JSONP"===t.method)throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed.");return new X(e=>{const n=this.xhrFactory.build();if(n.open(t.method,t.urlWithParams),t.withCredentials&&(n.withCredentials=!0),t.headers.forEach((t,e)=>n.setRequestHeader(t,e.join(","))),t.headers.has("Accept")||n.setRequestHeader("Accept","application/json, text/plain, */*"),!t.headers.has("Content-Type")){const e=t.detectContentTypeHeader();null!==e&&n.setRequestHeader("Content-Type",e)}if(t.responseType){const e=t.responseType.toLowerCase();n.responseType="json"!==e?e:"text"}const i=t.serializeBody();let r=null;const s=()=>{if(null!==r)return r;const e=1223===n.status?204:n.status,i=n.statusText||"OK",s=new JA(n.getAllResponseHeaders()),o=function(t){return"responseURL"in t&&t.responseURL?t.responseURL:/^X-Request-URL:/m.test(t.getAllResponseHeaders())?t.getResponseHeader("X-Request-URL"):null}(n)||t.url;return r=new lx({headers:s,status:e,statusText:i,url:o}),r},o=()=>{let{headers:i,status:r,statusText:o,url:a}=s(),l=null;204!==r&&(l=void 0===n.response?n.responseText:n.response),0===r&&(r=l?200:0);let c=r>=200&&r<300;if("json"===t.responseType&&"string"==typeof l){const t=l;l=l.replace(gx,"");try{l=""!==l?JSON.parse(l):null}catch(u){l=t,c&&(c=!1,l={error:u,text:l})}}c?(e.next(new cx({body:l,headers:i,status:r,statusText:o,url:a||void 0})),e.complete()):e.error(new ux({error:l,headers:i,status:r,statusText:o,url:a||void 0}))},a=t=>{const{url:i}=s(),r=new ux({error:t,status:n.status||0,statusText:n.statusText||"Unknown Error",url:i||void 0});e.error(r)};let l=!1;const c=i=>{l||(e.next(s()),l=!0);let r={type:ox.DownloadProgress,loaded:i.loaded};i.lengthComputable&&(r.total=i.total),"text"===t.responseType&&n.responseText&&(r.partialText=n.responseText),e.next(r)},u=t=>{let n={type:ox.UploadProgress,loaded:t.loaded};t.lengthComputable&&(n.total=t.total),e.next(n)};return n.addEventListener("load",o),n.addEventListener("error",a),n.addEventListener("timeout",a),n.addEventListener("abort",a),t.reportProgress&&(n.addEventListener("progress",c),null!==i&&n.upload&&n.upload.addEventListener("progress",u)),n.send(i),e.next({type:ox.Sent}),()=>{n.removeEventListener("error",a),n.removeEventListener("abort",a),n.removeEventListener("load",o),n.removeEventListener("timeout",a),t.reportProgress&&(n.removeEventListener("progress",c),null!==i&&n.upload&&n.upload.removeEventListener("progress",u)),n.readyState!==n.DONE&&n.abort()}})}}return t.\u0275fac=function(e){return new(e||t)(Xi(yx))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();const Ax=new Ri("XSRF_COOKIE_NAME"),xx=new Ri("XSRF_HEADER_NAME");class wx{}let _x=(()=>{class t{constructor(t,e,n){this.doc=t,this.platform=e,this.cookieName=n,this.lastCookieString="",this.lastToken=null,this.parseCount=0}getToken(){if("server"===this.platform)return null;const t=this.doc.cookie||"";return t!==this.lastCookieString&&(this.parseCount++,this.lastToken=Ih(t,this.cookieName),this.lastCookieString=t),this.lastToken}}return t.\u0275fac=function(e){return new(e||t)(Xi(Zu),Xi(ru),Xi(Ax))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})(),Sx=(()=>{class t{constructor(t,e){this.tokenService=t,this.headerName=e}intercept(t,e){const n=t.url.toLowerCase();if("GET"===t.method||"HEAD"===t.method||n.startsWith("http://")||n.startsWith("https://"))return e.handle(t);const i=this.tokenService.getToken();return null===i||t.headers.has(this.headerName)||(t=t.clone({headers:t.headers.set(this.headerName,i)})),e.handle(t)}}return t.\u0275fac=function(e){return new(e||t)(Xi(wx),Xi(xx))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})(),Ex=(()=>{class t{constructor(t,e){this.backend=t,this.injector=e,this.chain=null}handle(t){if(null===this.chain){const t=this.injector.get(fx,[]);this.chain=t.reduceRight((t,e)=>new px(t,e),this.backend)}return this.chain.handle(t)}}return t.\u0275fac=function(e){return new(e||t)(Xi(KA),Xi(Xo))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})(),Cx=(()=>{class t{static disable(){return{ngModule:t,providers:[{provide:Sx,useClass:mx}]}}static withOptions(e={}){return{ngModule:t,providers:[e.cookieName?{provide:Ax,useValue:e.cookieName}:[],e.headerName?{provide:xx,useValue:e.headerName}:[]]}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({providers:[Sx,{provide:fx,useExisting:Sx,multi:!0},{provide:wx,useClass:_x},{provide:Ax,useValue:"XSRF-TOKEN"},{provide:xx,useValue:"X-XSRF-TOKEN"}]}),t})(),Ix=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({providers:[dx,{provide:YA,useClass:Ex},bx,{provide:KA,useExisting:bx},vx,{provide:yx,useExisting:vx}],imports:[[Cx.withOptions({cookieName:"XSRF-TOKEN",headerName:"X-XSRF-TOKEN"})]]}),t})();const Tx=["*"];function Mx(t){return Error(`Unable to find icon with the name "${t}"`)}function kx(t){return Error(`The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${t}".`)}function Rx(t){return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${t}".`)}class Nx{constructor(t,e,n){this.url=t,this.svgText=e,this.options=n}}let Lx=(()=>{class t{constructor(t,e,n,i){this._httpClient=t,this._sanitizer=e,this._errorHandler=i,this._svgIconConfigs=new Map,this._iconSetConfigs=new Map,this._cachedIconsByUrl=new Map,this._inProgressUrlFetches=new Map,this._fontCssClassesByAlias=new Map,this._resolvers=[],this._defaultFontSetClass="material-icons",this._document=n}addSvgIcon(t,e,n){return this.addSvgIconInNamespace("",t,e,n)}addSvgIconLiteral(t,e,n){return this.addSvgIconLiteralInNamespace("",t,e,n)}addSvgIconInNamespace(t,e,n,i){return this._addSvgIconConfig(t,e,new Nx(n,null,i))}addSvgIconResolver(t){return this._resolvers.push(t),this}addSvgIconLiteralInNamespace(t,e,n,i){const r=this._sanitizer.sanitize(Fr.HTML,n);if(!r)throw Rx(n);return this._addSvgIconConfig(t,e,new Nx("",r,i))}addSvgIconSet(t,e){return this.addSvgIconSetInNamespace("",t,e)}addSvgIconSetLiteral(t,e){return this.addSvgIconSetLiteralInNamespace("",t,e)}addSvgIconSetInNamespace(t,e,n){return this._addSvgIconSetConfig(t,new Nx(e,null,n))}addSvgIconSetLiteralInNamespace(t,e,n){const i=this._sanitizer.sanitize(Fr.HTML,e);if(!i)throw Rx(e);return this._addSvgIconSetConfig(t,new Nx("",i,n))}registerFontClassAlias(t,e=t){return this._fontCssClassesByAlias.set(t,e),this}classNameForFontAlias(t){return this._fontCssClassesByAlias.get(t)||t}setDefaultFontSetClass(t){return this._defaultFontSetClass=t,this}getDefaultFontSetClass(){return this._defaultFontSetClass}getSvgIconFromUrl(t){const e=this._sanitizer.sanitize(Fr.RESOURCE_URL,t);if(!e)throw kx(t);const n=this._cachedIconsByUrl.get(e);return n?Rd(Dx(n)):this._loadSvgIconFromConfig(new Nx(t,null)).pipe(xp(t=>this._cachedIconsByUrl.set(e,t)),it(t=>Dx(t)))}getNamedSvgIcon(t,e=""){const n=Bx(e,t);let i=this._svgIconConfigs.get(n);if(i)return this._getSvgFromConfig(i);if(i=this._getIconConfigFromResolvers(e,t),i)return this._svgIconConfigs.set(n,i),this._getSvgFromConfig(i);const r=this._iconSetConfigs.get(e);return r?this._getSvgFromIconSetConfigs(t,r):jA(Mx(n))}ngOnDestroy(){this._resolvers=[],this._svgIconConfigs.clear(),this._iconSetConfigs.clear(),this._cachedIconsByUrl.clear()}_getSvgFromConfig(t){return t.svgText?Rd(Dx(this._svgElementFromConfig(t))):this._loadSvgIconFromConfig(t).pipe(it(t=>Dx(t)))}_getSvgFromIconSetConfigs(t,e){const n=this._extractIconWithNameFromAnySet(t,e);return n?Rd(n):qA(e.filter(t=>!t.svgText).map(t=>this._loadSvgIconSetFromConfig(t).pipe(sp(e=>{const n=this._sanitizer.sanitize(Fr.RESOURCE_URL,t.url);return this._errorHandler.handleError(new Error(`Loading icon set URL: ${n} failed: ${e.message}`)),Rd(null)})))).pipe(it(()=>{const n=this._extractIconWithNameFromAnySet(t,e);if(!n)throw Mx(t);return n}))}_extractIconWithNameFromAnySet(t,e){for(let n=e.length-1;n>=0;n--){const i=e[n];if(i.svgText&&i.svgText.indexOf(t)>-1){const e=this._svgElementFromConfig(i),n=this._extractSvgIconFromSet(e,t,i.options);if(n)return n}}return null}_loadSvgIconFromConfig(t){return this._fetchIcon(t).pipe(xp(e=>t.svgText=e),it(()=>this._svgElementFromConfig(t)))}_loadSvgIconSetFromConfig(t){return t.svgText?Rd(null):this._fetchIcon(t).pipe(xp(e=>t.svgText=e))}_extractSvgIconFromSet(t,e,n){const i=t.querySelector(`[id="${e}"]`);if(!i)return null;const r=i.cloneNode(!0);if(r.removeAttribute("id"),"svg"===r.nodeName.toLowerCase())return this._setSvgAttributes(r,n);if("symbol"===r.nodeName.toLowerCase())return this._setSvgAttributes(this._toSvgElement(r),n);const s=this._svgElementFromString("<svg></svg>");return s.appendChild(r),this._setSvgAttributes(s,n)}_svgElementFromString(t){const e=this._document.createElement("DIV");e.innerHTML=t;const n=e.querySelector("svg");if(!n)throw Error("<svg> tag not found");return n}_toSvgElement(t){const e=this._svgElementFromString("<svg></svg>"),n=t.attributes;for(let i=0;i<n.length;i++){const{name:t,value:r}=n[i];"id"!==t&&e.setAttribute(t,r)}for(let i=0;i<t.childNodes.length;i++)t.childNodes[i].nodeType===this._document.ELEMENT_NODE&&e.appendChild(t.childNodes[i].cloneNode(!0));return e}_setSvgAttributes(t,e){return t.setAttribute("fit",""),t.setAttribute("height","100%"),t.setAttribute("width","100%"),t.setAttribute("preserveAspectRatio","xMidYMid meet"),t.setAttribute("focusable","false"),e&&e.viewBox&&t.setAttribute("viewBox",e.viewBox),t}_fetchIcon(t){var e;const{url:n,options:i}=t,r=null!==(e=null==i?void 0:i.withCredentials)&&void 0!==e&&e;if(!this._httpClient)throw Error("Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports.");if(null==n)throw Error(`Cannot fetch icon from URL "${n}".`);const s=this._sanitizer.sanitize(Fr.RESOURCE_URL,n);if(!s)throw kx(n);const o=this._inProgressUrlFetches.get(s);if(o)return o;const a=this._httpClient.get(s,{responseType:"text",withCredentials:r}).pipe(Sp(()=>this._inProgressUrlFetches.delete(s)),Nt());return this._inProgressUrlFetches.set(s,a),a}_addSvgIconConfig(t,e,n){return this._svgIconConfigs.set(Bx(t,e),n),this}_addSvgIconSetConfig(t,e){const n=this._iconSetConfigs.get(t);return n?n.push(e):this._iconSetConfigs.set(t,[e]),this}_svgElementFromConfig(t){if(!t.svgElement){const e=this._svgElementFromString(t.svgText);this._setSvgAttributes(e,t.options),t.svgElement=e}return t.svgElement}_getIconConfigFromResolvers(t,e){for(let i=0;i<this._resolvers.length;i++){const r=this._resolvers[i](e,t);if(r)return(n=r).url&&n.options?new Nx(r.url,null,r.options):new Nx(r,null)}var n}}return t.\u0275fac=function(e){return new(e||t)(Xi(dx,8),Xi(_d),Xi(Zu,8),Xi(Vr))},t.\u0275prov=Wt({factory:function(){return new t(Xi(dx,8),Xi(_d),Xi(Zu,8),Xi(Vr))},token:t,providedIn:"root"}),t})();function Dx(t){return t.cloneNode(!0)}function Bx(t,e){return t+":"+e}class Ox{constructor(t){this._elementRef=t}}const Px=gA(Ox),Fx=new Ri("mat-icon-location",{providedIn:"root",factory:function(){const t=Yi(Zu),e=t?t.location:null;return{getPathname:()=>e?e.pathname+e.search:""}}}),$x=["clip-path","color-profile","src","cursor","fill","filter","marker","marker-start","marker-mid","marker-end","mask","stroke"],zx=$x.map(t=>`[${t}]`).join(", "),Ux=/^url\(['"]?#(.*?)['"]?\)$/;let Hx=(()=>{class t extends Px{constructor(t,e,n,i,r){super(t),this._iconRegistry=e,this._location=i,this._errorHandler=r,this._inline=!1,this._currentIconFetch=H.EMPTY,n||t.nativeElement.setAttribute("aria-hidden","true")}get inline(){return this._inline}set inline(t){this._inline=kg(t)}get svgIcon(){return this._svgIcon}set svgIcon(t){t!==this._svgIcon&&(t?this._updateSvgIcon(t):this._svgIcon&&this._clearSvgElement(),this._svgIcon=t)}get fontSet(){return this._fontSet}set fontSet(t){const e=this._cleanupFontValue(t);e!==this._fontSet&&(this._fontSet=e,this._updateFontIconClasses())}get fontIcon(){return this._fontIcon}set fontIcon(t){const e=this._cleanupFontValue(t);e!==this._fontIcon&&(this._fontIcon=e,this._updateFontIconClasses())}_splitIconName(t){if(!t)return["",""];const e=t.split(":");switch(e.length){case 1:return["",e[0]];case 2:return e;default:throw Error(`Invalid icon name: "${t}"`)}}ngOnInit(){this._updateFontIconClasses()}ngAfterViewChecked(){const t=this._elementsWithExternalReferences;if(t&&t.size){const t=this._location.getPathname();t!==this._previousPath&&(this._previousPath=t,this._prependPathToReferences(t))}}ngOnDestroy(){this._currentIconFetch.unsubscribe(),this._elementsWithExternalReferences&&this._elementsWithExternalReferences.clear()}_usingFontIcon(){return!this.svgIcon}_setSvgElement(t){this._clearSvgElement();const e=t.querySelectorAll("style");for(let i=0;i<e.length;i++)e[i].textContent+=" ";const n=this._location.getPathname();this._previousPath=n,this._cacheChildrenWithExternalReferences(t),this._prependPathToReferences(n),this._elementRef.nativeElement.appendChild(t)}_clearSvgElement(){const t=this._elementRef.nativeElement;let e=t.childNodes.length;for(this._elementsWithExternalReferences&&this._elementsWithExternalReferences.clear();e--;){const n=t.childNodes[e];1===n.nodeType&&"svg"!==n.nodeName.toLowerCase()||t.removeChild(n)}}_updateFontIconClasses(){if(!this._usingFontIcon())return;const t=this._elementRef.nativeElement,e=this.fontSet?this._iconRegistry.classNameForFontAlias(this.fontSet):this._iconRegistry.getDefaultFontSetClass();e!=this._previousFontSetClass&&(this._previousFontSetClass&&t.classList.remove(this._previousFontSetClass),e&&t.classList.add(e),this._previousFontSetClass=e),this.fontIcon!=this._previousFontIconClass&&(this._previousFontIconClass&&t.classList.remove(this._previousFontIconClass),this.fontIcon&&t.classList.add(this.fontIcon),this._previousFontIconClass=this.fontIcon)}_cleanupFontValue(t){return"string"==typeof t?t.trim().split(" ")[0]:t}_prependPathToReferences(t){const e=this._elementsWithExternalReferences;e&&e.forEach((e,n)=>{e.forEach(e=>{n.setAttribute(e.name,`url('${t}#${e.value}')`)})})}_cacheChildrenWithExternalReferences(t){const e=t.querySelectorAll(zx),n=this._elementsWithExternalReferences=this._elementsWithExternalReferences||new Map;for(let i=0;i<e.length;i++)$x.forEach(t=>{const r=e[i],s=r.getAttribute(t),o=s?s.match(Ux):null;if(o){let e=n.get(r);e||(e=[],n.set(r,e)),e.push({name:t,value:o[1]})}})}_updateSvgIcon(t){if(this._svgNamespace=null,this._svgName=null,this._currentIconFetch.unsubscribe(),t){const[e,n]=this._splitIconName(t);e&&(this._svgNamespace=e),n&&(this._svgName=n),this._currentIconFetch=this._iconRegistry.getNamedSvgIcon(n,e).pipe(Xd(1)).subscribe(t=>this._setSvgElement(t),t=>{this._errorHandler.handleError(new Error(`Error retrieving icon ${e}:${n}! ${t.message}`))})}}}return t.\u0275fac=function(e){return new(e||t)(pa(Cl),pa(Lx),Ti("aria-hidden"),pa(Fx),pa(Vr))},t.\u0275cmp=Se({type:t,selectors:[["mat-icon"]],hostAttrs:["role","img",1,"mat-icon","notranslate"],hostVars:7,hostBindings:function(t,e){2&t&&(ua("data-mat-icon-type",e._usingFontIcon()?"font":"svg")("data-mat-icon-name",e._svgName||e.fontIcon)("data-mat-icon-namespace",e._svgNamespace||e.fontSet),Ua("mat-icon-inline",e.inline)("mat-icon-no-color","primary"!==e.color&&"accent"!==e.color&&"warn"!==e.color))},inputs:{color:"color",inline:"inline",svgIcon:"svgIcon",fontSet:"fontSet",fontIcon:"fontIcon"},exportAs:["matIcon"],features:[Ko],ngContentSelectors:Tx,decls:1,vars:0,template:function(t,e){1&t&&(Na(),La(0))},styles:[".mat-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\n"],encapsulation:2,changeDetection:0}),t})(),Vx=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[[fA],fA]}),t})(),Gx=1;const Wx=(()=>Promise.resolve())(),jx={};function Qx(t){return t in jx&&(delete jx[t],!0)}const qx={setImmediate(t){const e=Gx++;return jx[e]=!0,Wx.then(()=>Qx(e)&&t()),e},clearImmediate(t){Qx(t)}};class Xx extends wg{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}requestAsyncId(t,e,n=0){return null!==n&&n>0?super.requestAsyncId(t,e,n):(t.actions.push(this),t.scheduled||(t.scheduled=qx.setImmediate(t.flush.bind(t,null))))}recycleAsyncId(t,e,n=0){if(null!==n&&n>0||null===n&&this.delay>0)return super.recycleAsyncId(t,e,n);0===t.actions.length&&(qx.clearImmediate(e),t.scheduled=void 0)}}class Yx extends Sg{flush(t){this.active=!0,this.scheduled=void 0;const{actions:e}=this;let n,i=-1,r=e.length;t=t||e.shift();do{if(n=t.execute(t.state,t.delay))break}while(++i<r&&(t=e.shift()));if(this.active=!1,n){for(;++i<r&&(t=e.shift());)t.unsubscribe();throw n}}}const Kx=new Yx(Xx);function Jx(t){return e=>e.lift(new Zx(t))}class Zx{constructor(t){this.notifier=t}call(t,e){const n=new tw(t),i=gt(this.notifier,new ft(n));return i&&!n.seenValue?(n.add(i),e.subscribe(n)):n}}class tw extends mt{constructor(t){super(t),this.seenValue=!1}notifyNext(){this.seenValue=!0,this.complete()}notifyComplete(){}}let ew=(()=>{class t{constructor(t,e,n){this.kind=t,this.value=e,this.error=n,this.hasValue="N"===t}observe(t){switch(this.kind){case"N":return t.next&&t.next(this.value);case"E":return t.error&&t.error(this.error);case"C":return t.complete&&t.complete()}}do(t,e,n){switch(this.kind){case"N":return t&&t(this.value);case"E":return e&&e(this.error);case"C":return n&&n()}}accept(t,e,n){return t&&"function"==typeof t.next?this.observe(t):this.do(t,e,n)}toObservable(){switch(this.kind){case"N":return Rd(this.value);case"E":return jA(this.error);case"C":return Vd()}throw new Error("unexpected notification kind value")}static createNext(e){return void 0!==e?new t("N",e):t.undefinedValueNotification}static createError(e){return new t("E",void 0,e)}static createComplete(){return t.completeNotification}}return t.completeNotification=new t("C"),t.undefinedValueNotification=new t("N",void 0),t})();function nw(t,e=Eg){var n;const i=(n=t)instanceof Date&&!isNaN(+n)?+t-e.now():Math.abs(t);return t=>t.lift(new iw(i,e))}class iw{constructor(t,e){this.delay=t,this.scheduler=e}call(t,e){return e.subscribe(new rw(t,this.delay,this.scheduler))}}class rw extends W{constructor(t,e,n){super(t),this.delay=e,this.scheduler=n,this.queue=[],this.active=!1,this.errored=!1}static dispatch(t){const e=t.source,n=e.queue,i=t.scheduler,r=t.destination;for(;n.length>0&&n[0].time-i.now()<=0;)n.shift().notification.observe(r);if(n.length>0){const e=Math.max(0,n[0].time-i.now());this.schedule(t,e)}else this.unsubscribe(),e.active=!1}_schedule(t){this.active=!0,this.destination.add(t.schedule(rw.dispatch,this.delay,{source:this,destination:this.destination,scheduler:t}))}scheduleNotification(t){if(!0===this.errored)return;const e=this.scheduler,n=new sw(e.now()+this.delay,t);this.queue.push(n),!1===this.active&&this._schedule(e)}_next(t){this.scheduleNotification(ew.createNext(t))}_error(t){this.errored=!0,this.queue=[],this.destination.error(t),this.unsubscribe()}_complete(){this.scheduleNotification(ew.createComplete()),this.unsubscribe()}}class sw{constructor(t,e){this.time=t,this.notification=e}}class ow{attach(t){return this._attachedHost=t,t.attach(this)}detach(){let t=this._attachedHost;null!=t&&(this._attachedHost=null,t.detach())}get isAttached(){return null!=this._attachedHost}setAttachedHost(t){this._attachedHost=t}}class aw extends ow{constructor(t,e,n,i){super(),this.component=t,this.viewContainerRef=e,this.injector=n,this.componentFactoryResolver=i}}class lw extends ow{constructor(t,e,n){super(),this.templateRef=t,this.viewContainerRef=e,this.context=n}get origin(){return this.templateRef.elementRef}attach(t,e=this.context){return this.context=e,super.attach(t)}detach(){return this.context=void 0,super.detach()}}class cw extends ow{constructor(t){super(),this.element=t instanceof Cl?t.nativeElement:t}}class uw{constructor(){this._isDisposed=!1,this.attachDomPortal=null}hasAttached(){return!!this._attachedPortal}attach(t){return t instanceof aw?(this._attachedPortal=t,this.attachComponentPortal(t)):t instanceof lw?(this._attachedPortal=t,this.attachTemplatePortal(t)):this.attachDomPortal&&t instanceof cw?(this._attachedPortal=t,this.attachDomPortal(t)):void 0}detach(){this._attachedPortal&&(this._attachedPortal.setAttachedHost(null),this._attachedPortal=null),this._invokeDisposeFn()}dispose(){this.hasAttached()&&this.detach(),this._invokeDisposeFn(),this._isDisposed=!0}setDisposeFn(t){this._disposeFn=t}_invokeDisposeFn(){this._disposeFn&&(this._disposeFn(),this._disposeFn=null)}}class hw extends uw{constructor(t,e,n,i,r){super(),this.outletElement=t,this._componentFactoryResolver=e,this._appRef=n,this._defaultInjector=i,this.attachDomPortal=t=>{const e=t.element,n=this._document.createComment("dom-portal");e.parentNode.insertBefore(n,e),this.outletElement.appendChild(e),this._attachedPortal=t,super.setDisposeFn(()=>{n.parentNode&&n.parentNode.replaceChild(e,n)})},this._document=r}attachComponentPortal(t){const e=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component);let n;return t.viewContainerRef?(n=t.viewContainerRef.createComponent(e,t.viewContainerRef.length,t.injector||t.viewContainerRef.injector),this.setDisposeFn(()=>n.destroy())):(n=e.create(t.injector||this._defaultInjector),this._appRef.attachView(n.hostView),this.setDisposeFn(()=>{this._appRef.detachView(n.hostView),n.destroy()})),this.outletElement.appendChild(this._getComponentRootNode(n)),this._attachedPortal=t,n}attachTemplatePortal(t){let e=t.viewContainerRef,n=e.createEmbeddedView(t.templateRef,t.context);return n.rootNodes.forEach(t=>this.outletElement.appendChild(t)),n.detectChanges(),this.setDisposeFn(()=>{let t=e.indexOf(n);-1!==t&&e.remove(t)}),this._attachedPortal=t,n}dispose(){super.dispose(),null!=this.outletElement.parentNode&&this.outletElement.parentNode.removeChild(this.outletElement)}_getComponentRootNode(t){return t.hostView.rootNodes[0]}}let dw=(()=>{class t extends lw{constructor(t,e){super(t,e)}}return t.\u0275fac=function(e){return new(e||t)(pa(rc),pa(hc))},t.\u0275dir=ke({type:t,selectors:[["","cdkPortal",""]],exportAs:["cdkPortal"],features:[Ko]}),t})(),pw=(()=>{class t extends uw{constructor(t,e,n){super(),this._componentFactoryResolver=t,this._viewContainerRef=e,this._isInitialized=!1,this.attached=new Nc,this.attachDomPortal=t=>{const e=t.element,n=this._document.createComment("dom-portal");t.setAttachedHost(this),e.parentNode.insertBefore(n,e),this._getRootNode().appendChild(e),this._attachedPortal=t,super.setDisposeFn(()=>{n.parentNode&&n.parentNode.replaceChild(e,n)})},this._document=n}get portal(){return this._attachedPortal}set portal(t){(!this.hasAttached()||t||this._isInitialized)&&(this.hasAttached()&&super.detach(),t&&super.attach(t),this._attachedPortal=t)}get attachedRef(){return this._attachedRef}ngOnInit(){this._isInitialized=!0}ngOnDestroy(){super.dispose(),this._attachedPortal=null,this._attachedRef=null}attachComponentPortal(t){t.setAttachedHost(this);const e=null!=t.viewContainerRef?t.viewContainerRef:this._viewContainerRef,n=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component),i=e.createComponent(n,e.length,t.injector||e.injector);return e!==this._viewContainerRef&&this._getRootNode().appendChild(i.hostView.rootNodes[0]),super.setDisposeFn(()=>i.destroy()),this._attachedPortal=t,this._attachedRef=i,this.attached.emit(i),i}attachTemplatePortal(t){t.setAttachedHost(this);const e=this._viewContainerRef.createEmbeddedView(t.templateRef,t.context);return super.setDisposeFn(()=>this._viewContainerRef.clear()),this._attachedPortal=t,this._attachedRef=e,this.attached.emit(e),e}_getRootNode(){const t=this._viewContainerRef.element.nativeElement;return t.nodeType===t.ELEMENT_NODE?t:t.parentNode}}return t.\u0275fac=function(e){return new(e||t)(pa(wl),pa(hc),pa(Zu))},t.\u0275dir=ke({type:t,selectors:[["","cdkPortalOutlet",""]],inputs:{portal:["cdkPortalOutlet","portal"]},outputs:{attached:"attached"},exportAs:["cdkPortalOutlet"],features:[Ko]}),t})(),fw=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({}),t})();function mw(t,e,n,i){return D(n)&&(i=n,n=void 0),i?mw(t,e,n).pipe(it(t=>$(t)?i(...t):i(t))):new X(i=>{gw(t,e,function(t){i.next(arguments.length>1?Array.prototype.slice.call(arguments):t)},i,n)})}function gw(t,e,n,i,r){let s;if(function(t){return t&&"function"==typeof t.addEventListener&&"function"==typeof t.removeEventListener}(t)){const i=t;t.addEventListener(e,n,r),s=()=>i.removeEventListener(e,n,r)}else if(function(t){return t&&"function"==typeof t.on&&"function"==typeof t.off}(t)){const i=t;t.on(e,n),s=()=>i.off(e,n)}else if(function(t){return t&&"function"==typeof t.addListener&&"function"==typeof t.removeListener}(t)){const i=t;t.addListener(e,n),s=()=>i.removeListener(e,n)}else{if(!t||!t.length)throw new TypeError("Invalid event target");for(let s=0,o=t.length;s<o;s++)gw(t[s],e,n,i,r)}i.add(s)}function yw(t,e){return n=>n.lift(new vw(t,e))}class vw{constructor(t,e){this.compare=t,this.keySelector=e}call(t,e){return e.subscribe(new bw(t,this.compare,this.keySelector))}}class bw extends W{constructor(t,e,n){super(t),this.keySelector=n,this.hasKey=!1,"function"==typeof e&&(this.compare=e)}compare(t,e){return t===e}_next(t){let e;try{const{keySelector:n}=this;e=n?n(t):t}catch(i){return this.destination.error(i)}let n=!1;if(this.hasKey)try{const{compare:t}=this;n=t(this.key,e)}catch(i){return this.destination.error(i)}else this.hasKey=!0;n||(this.key=e,this.destination.next(t))}}class Aw{constructor(t){this.durationSelector=t}call(t,e){return e.subscribe(new xw(t,this.durationSelector))}}class xw extends mt{constructor(t,e){super(t),this.durationSelector=e,this.hasValue=!1}_next(t){if(this.value=t,this.hasValue=!0,!this.throttled){let n;try{const{durationSelector:e}=this;n=e(t)}catch(e){return this.destination.error(e)}const i=gt(n,new ft(this));!i||i.closed?this.clearThrottle():this.add(this.throttled=i)}}clearThrottle(){const{value:t,hasValue:e,throttled:n}=this;n&&(this.remove(n),this.throttled=void 0,n.unsubscribe()),e&&(this.value=void 0,this.hasValue=!1,this.destination.next(t))}notifyNext(){this.clearThrottle()}notifyComplete(){this.clearThrottle()}}function ww(t){return!$(t)&&t-parseFloat(t)+1>=0}function _w(t=0,e,n){let i=-1;return ww(e)?i=Number(e)<1?1:Number(e):nt(e)&&(n=e),nt(n)||(n=Eg),new X(e=>{const r=ww(t)?t:+t-n.now();return n.schedule(Sw,r,{index:0,period:i,subscriber:e})})}function Sw(t){const{index:e,period:n,subscriber:i}=t;if(i.next(e),!i.closed){if(-1===n)return i.complete();t.index=e+1,this.schedule(t,n)}}function Ew(t,e=Eg){return n=()=>_w(t,e),function(t){return t.lift(new Aw(n))};var n}class Cw extends wg{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}schedule(t,e=0){return e>0?super.schedule(t,e):(this.delay=e,this.state=t,this.scheduler.flush(this),this)}execute(t,e){return e>0||this.closed?super.execute(t,e):this._execute(t,e)}requestAsyncId(t,e,n=0){return null!==n&&n>0||null===n&&this.delay>0?super.requestAsyncId(t,e,n):t.flush(this)}}class Iw extends Sg{}const Tw=new Iw(Cw);class Mw extends W{constructor(t,e,n=0){super(t),this.scheduler=e,this.delay=n}static dispatch(t){const{notification:e,destination:n}=t;e.observe(n),this.unsubscribe()}scheduleMessage(t){this.destination.add(this.scheduler.schedule(Mw.dispatch,this.delay,new kw(t,this.destination)))}_next(t){this.scheduleMessage(ew.createNext(t))}_error(t){this.scheduleMessage(ew.createError(t)),this.unsubscribe()}_complete(){this.scheduleMessage(ew.createComplete()),this.unsubscribe()}}class kw{constructor(t,e){this.notification=t,this.destination=e}}class Rw extends tt{constructor(t=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,n){super(),this.scheduler=n,this._events=[],this._infiniteTimeWindow=!1,this._bufferSize=t<1?1:t,this._windowTime=e<1?1:e,e===Number.POSITIVE_INFINITY?(this._infiniteTimeWindow=!0,this.next=this.nextInfiniteTimeWindow):this.next=this.nextTimeWindow}nextInfiniteTimeWindow(t){if(!this.isStopped){const e=this._events;e.push(t),e.length>this._bufferSize&&e.shift()}super.next(t)}nextTimeWindow(t){this.isStopped||(this._events.push(new Nw(this._getNow(),t)),this._trimBufferThenGetEvents()),super.next(t)}_subscribe(t){const e=this._infiniteTimeWindow,n=e?this._events:this._trimBufferThenGetEvents(),i=this.scheduler,r=n.length;let s;if(this.closed)throw new K;if(this.isStopped||this.hasError?s=H.EMPTY:(this.observers.push(t),s=new J(this,t)),i&&t.add(t=new Mw(t,i)),e)for(let o=0;o<r&&!t.closed;o++)t.next(n[o]);else for(let o=0;o<r&&!t.closed;o++)t.next(n[o].value);return this.hasError?t.error(this.thrownError):this.isStopped&&t.complete(),s}_getNow(){return(this.scheduler||Tw).now()}_trimBufferThenGetEvents(){const t=this._getNow(),e=this._bufferSize,n=this._windowTime,i=this._events,r=i.length;let s=0;for(;s<r&&!(t-i[s].time<n);)s++;return r>e&&(s=Math.max(s,r-e)),s>0&&i.splice(0,s),i}}class Nw{constructor(t,e){this.time=t,this.value=e}}function Lw(t,e,n){let i;return i=t&&"object"==typeof t?t:{bufferSize:t,windowTime:e,refCount:!1,scheduler:n},t=>t.lift(function({bufferSize:t=Number.POSITIVE_INFINITY,windowTime:e=Number.POSITIVE_INFINITY,refCount:n,scheduler:i}){let r,s,o=0,a=!1,l=!1;return function(c){let u;o++,!r||a?(a=!1,r=new Rw(t,e,i),u=r.subscribe(this),s=c.subscribe({next(t){r.next(t)},error(t){a=!0,r.error(t)},complete(){l=!0,s=void 0,r.complete()}}),l&&(s=void 0)):u=r.subscribe(this),this.add(()=>{o--,u.unsubscribe(),u=void 0,s&&!l&&n&&0===o&&(s.unsubscribe(),s=void 0,r=void 0)})}}(i))}class Dw{constructor(t=!1,e,n=!0){this._multiple=t,this._emitChanges=n,this._selection=new Set,this._deselectedToEmit=[],this._selectedToEmit=[],this.changed=new tt,e&&e.length&&(t?e.forEach(t=>this._markSelected(t)):this._markSelected(e[0]),this._selectedToEmit.length=0)}get selected(){return this._selected||(this._selected=Array.from(this._selection.values())),this._selected}select(...t){this._verifyValueAssignment(t),t.forEach(t=>this._markSelected(t)),this._emitChangeEvent()}deselect(...t){this._verifyValueAssignment(t),t.forEach(t=>this._unmarkSelected(t)),this._emitChangeEvent()}toggle(t){this.isSelected(t)?this.deselect(t):this.select(t)}clear(){this._unmarkAll(),this._emitChangeEvent()}isSelected(t){return this._selection.has(t)}isEmpty(){return 0===this._selection.size}hasValue(){return!this.isEmpty()}sort(t){this._multiple&&this.selected&&this._selected.sort(t)}isMultipleSelection(){return this._multiple}_emitChangeEvent(){this._selected=null,(this._selectedToEmit.length||this._deselectedToEmit.length)&&(this.changed.next({source:this,added:this._selectedToEmit,removed:this._deselectedToEmit}),this._deselectedToEmit=[],this._selectedToEmit=[])}_markSelected(t){this.isSelected(t)||(this._multiple||this._unmarkAll(),this._selection.add(t),this._emitChanges&&this._selectedToEmit.push(t))}_unmarkSelected(t){this.isSelected(t)&&(this._selection.delete(t),this._emitChanges&&this._deselectedToEmit.push(t))}_unmarkAll(){this.isEmpty()||this._selection.forEach(t=>this._unmarkSelected(t))}_verifyValueAssignment(t){}}let Bw=(()=>{class t{constructor(t,e,n){this._ngZone=t,this._platform=e,this._scrolled=new tt,this._globalSubscription=null,this._scrolledCount=0,this.scrollContainers=new Map,this._document=n}register(t){this.scrollContainers.has(t)||this.scrollContainers.set(t,t.elementScrolled().subscribe(()=>this._scrolled.next(t)))}deregister(t){const e=this.scrollContainers.get(t);e&&(e.unsubscribe(),this.scrollContainers.delete(t))}scrolled(t=20){return this._platform.isBrowser?new X(e=>{this._globalSubscription||this._addGlobalListener();const n=t>0?this._scrolled.pipe(Ew(t)).subscribe(e):this._scrolled.subscribe(e);return this._scrolledCount++,()=>{n.unsubscribe(),this._scrolledCount--,this._scrolledCount||this._removeGlobalListener()}}):Rd()}ngOnDestroy(){this._removeGlobalListener(),this.scrollContainers.forEach((t,e)=>this.deregister(e)),this._scrolled.complete()}ancestorScrolled(t,e){const n=this.getAncestorScrollContainers(t);return this.scrolled(e).pipe(np(t=>!t||n.indexOf(t)>-1))}getAncestorScrollContainers(t){const e=[];return this.scrollContainers.forEach((n,i)=>{this._scrollableContainsElement(i,t)&&e.push(i)}),e}_getWindow(){return this._document.defaultView||window}_scrollableContainsElement(t,e){let n=Dg(e),i=t.getElementRef().nativeElement;do{if(n==i)return!0}while(n=n.parentElement);return!1}_addGlobalListener(){this._globalSubscription=this._ngZone.runOutsideAngular(()=>mw(this._getWindow().document,"scroll").subscribe(()=>this._scrolled.next()))}_removeGlobalListener(){this._globalSubscription&&(this._globalSubscription.unsubscribe(),this._globalSubscription=null)}}return t.\u0275fac=function(e){return new(e||t)(Xi(Au),Xi(zg),Xi(Zu,8))},t.\u0275prov=Wt({factory:function(){return new t(Xi(Au),Xi(zg),Xi(Zu,8))},token:t,providedIn:"root"}),t})(),Ow=(()=>{class t{constructor(t,e,n,i){this.elementRef=t,this.scrollDispatcher=e,this.ngZone=n,this.dir=i,this._destroyed=new tt,this._elementScrolled=new X(t=>this.ngZone.runOutsideAngular(()=>mw(this.elementRef.nativeElement,"scroll").pipe(Jx(this._destroyed)).subscribe(t)))}ngOnInit(){this.scrollDispatcher.register(this)}ngOnDestroy(){this.scrollDispatcher.deregister(this),this._destroyed.next(),this._destroyed.complete()}elementScrolled(){return this._elementScrolled}getElementRef(){return this.elementRef}scrollTo(t){const e=this.elementRef.nativeElement,n=this.dir&&"rtl"==this.dir.value;null==t.left&&(t.left=n?t.end:t.start),null==t.right&&(t.right=n?t.start:t.end),null!=t.bottom&&(t.top=e.scrollHeight-e.clientHeight-t.bottom),n&&0!=Gg()?(null!=t.left&&(t.right=e.scrollWidth-e.clientWidth-t.left),2==Gg()?t.left=t.right:1==Gg()&&(t.left=t.right?-t.right:t.right)):null!=t.right&&(t.left=e.scrollWidth-e.clientWidth-t.right),this._applyScrollToOptions(t)}_applyScrollToOptions(t){const e=this.elementRef.nativeElement;Vg()?e.scrollTo(t):(null!=t.top&&(e.scrollTop=t.top),null!=t.left&&(e.scrollLeft=t.left))}measureScrollOffset(t){const e="left",n="right",i=this.elementRef.nativeElement;if("top"==t)return i.scrollTop;if("bottom"==t)return i.scrollHeight-i.clientHeight-i.scrollTop;const r=this.dir&&"rtl"==this.dir.value;return"start"==t?t=r?n:e:"end"==t&&(t=r?e:n),r&&2==Gg()?t==e?i.scrollWidth-i.clientWidth-i.scrollLeft:i.scrollLeft:r&&1==Gg()?t==e?i.scrollLeft+i.scrollWidth-i.clientWidth:-i.scrollLeft:t==e?i.scrollLeft:i.scrollWidth-i.clientWidth-i.scrollLeft}}return t.\u0275fac=function(e){return new(e||t)(pa(Cl),pa(Bw),pa(Au),pa(_y,8))},t.\u0275dir=ke({type:t,selectors:[["","cdk-scrollable",""],["","cdkScrollable",""]]}),t})(),Pw=(()=>{class t{constructor(t,e,n){this._platform=t,this._change=new tt,this._changeListener=t=>{this._change.next(t)},this._document=n,e.runOutsideAngular(()=>{if(t.isBrowser){const t=this._getWindow();t.addEventListener("resize",this._changeListener),t.addEventListener("orientationchange",this._changeListener)}this.change().subscribe(()=>this._updateViewportSize())})}ngOnDestroy(){if(this._platform.isBrowser){const t=this._getWindow();t.removeEventListener("resize",this._changeListener),t.removeEventListener("orientationchange",this._changeListener)}this._change.complete()}getViewportSize(){this._viewportSize||this._updateViewportSize();const t={width:this._viewportSize.width,height:this._viewportSize.height};return this._platform.isBrowser||(this._viewportSize=null),t}getViewportRect(){const t=this.getViewportScrollPosition(),{width:e,height:n}=this.getViewportSize();return{top:t.top,left:t.left,bottom:t.top+n,right:t.left+e,height:n,width:e}}getViewportScrollPosition(){if(!this._platform.isBrowser)return{top:0,left:0};const t=this._document,e=this._getWindow(),n=t.documentElement,i=n.getBoundingClientRect();return{top:-i.top||t.body.scrollTop||e.scrollY||n.scrollTop||0,left:-i.left||t.body.scrollLeft||e.scrollX||n.scrollLeft||0}}change(t=20){return t>0?this._change.pipe(Ew(t)):this._change}_getWindow(){return this._document.defaultView||window}_updateViewportSize(){const t=this._getWindow();this._viewportSize=this._platform.isBrowser?{width:t.innerWidth,height:t.innerHeight}:{width:0,height:0}}}return t.\u0275fac=function(e){return new(e||t)(Xi(zg),Xi(Au),Xi(Zu,8))},t.\u0275prov=Wt({factory:function(){return new t(Xi(zg),Xi(Au),Xi(Zu,8))},token:t,providedIn:"root"}),t})(),Fw=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({}),t})(),$w=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[[Sy,Ug,Fw],Sy,Fw]}),t})();const zw=Vg();class Uw{constructor(t,e){this._viewportRuler=t,this._previousHTMLStyles={top:"",left:""},this._isEnabled=!1,this._document=e}attach(){}enable(){if(this._canBeEnabled()){const t=this._document.documentElement;this._previousScrollPosition=this._viewportRuler.getViewportScrollPosition(),this._previousHTMLStyles.left=t.style.left||"",this._previousHTMLStyles.top=t.style.top||"",t.style.left=Lg(-this._previousScrollPosition.left),t.style.top=Lg(-this._previousScrollPosition.top),t.classList.add("cdk-global-scrollblock"),this._isEnabled=!0}}disable(){if(this._isEnabled){const t=this._document.documentElement,e=t.style,n=this._document.body.style,i=e.scrollBehavior||"",r=n.scrollBehavior||"";this._isEnabled=!1,e.left=this._previousHTMLStyles.left,e.top=this._previousHTMLStyles.top,t.classList.remove("cdk-global-scrollblock"),zw&&(e.scrollBehavior=n.scrollBehavior="auto"),window.scroll(this._previousScrollPosition.left,this._previousScrollPosition.top),zw&&(e.scrollBehavior=i,n.scrollBehavior=r)}}_canBeEnabled(){if(this._document.documentElement.classList.contains("cdk-global-scrollblock")||this._isEnabled)return!1;const t=this._document.body,e=this._viewportRuler.getViewportSize();return t.scrollHeight>e.height||t.scrollWidth>e.width}}class Hw{constructor(t,e,n,i){this._scrollDispatcher=t,this._ngZone=e,this._viewportRuler=n,this._config=i,this._scrollSubscription=null,this._detach=()=>{this.disable(),this._overlayRef.hasAttached()&&this._ngZone.run(()=>this._overlayRef.detach())}}attach(t){this._overlayRef=t}enable(){if(this._scrollSubscription)return;const t=this._scrollDispatcher.scrolled(0);this._config&&this._config.threshold&&this._config.threshold>1?(this._initialScrollPosition=this._viewportRuler.getViewportScrollPosition().top,this._scrollSubscription=t.subscribe(()=>{const t=this._viewportRuler.getViewportScrollPosition().top;Math.abs(t-this._initialScrollPosition)>this._config.threshold?this._detach():this._overlayRef.updatePosition()})):this._scrollSubscription=t.subscribe(this._detach)}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}class Vw{enable(){}disable(){}attach(){}}function Gw(t,e){return e.some(e=>t.bottom<e.top||t.top>e.bottom||t.right<e.left||t.left>e.right)}function Ww(t,e){return e.some(e=>t.top<e.top||t.bottom>e.bottom||t.left<e.left||t.right>e.right)}class jw{constructor(t,e,n,i){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=n,this._config=i,this._scrollSubscription=null}attach(t){this._overlayRef=t}enable(){this._scrollSubscription||(this._scrollSubscription=this._scrollDispatcher.scrolled(this._config?this._config.scrollThrottle:0).subscribe(()=>{if(this._overlayRef.updatePosition(),this._config&&this._config.autoClose){const t=this._overlayRef.overlayElement.getBoundingClientRect(),{width:e,height:n}=this._viewportRuler.getViewportSize();Gw(t,[{width:e,height:n,bottom:n,right:e,top:0,left:0}])&&(this.disable(),this._ngZone.run(()=>this._overlayRef.detach()))}}))}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}let Qw=(()=>{class t{constructor(t,e,n,i){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=n,this.noop=()=>new Vw,this.close=t=>new Hw(this._scrollDispatcher,this._ngZone,this._viewportRuler,t),this.block=()=>new Uw(this._viewportRuler,this._document),this.reposition=t=>new jw(this._scrollDispatcher,this._viewportRuler,this._ngZone,t),this._document=i}}return t.\u0275fac=function(e){return new(e||t)(Xi(Bw),Xi(Pw),Xi(Au),Xi(Zu))},t.\u0275prov=Wt({factory:function(){return new t(Xi(Bw),Xi(Pw),Xi(Au),Xi(Zu))},token:t,providedIn:"root"}),t})();class qw{constructor(t){if(this.scrollStrategy=new Vw,this.panelClass="",this.hasBackdrop=!1,this.backdropClass="cdk-overlay-dark-backdrop",this.disposeOnNavigation=!1,t){const e=Object.keys(t);for(const n of e)void 0!==t[n]&&(this[n]=t[n])}}}class Xw{constructor(t,e,n,i,r){this.offsetX=n,this.offsetY=i,this.panelClass=r,this.originX=t.originX,this.originY=t.originY,this.overlayX=e.overlayX,this.overlayY=e.overlayY}}class Yw{constructor(t,e){this.connectionPair=t,this.scrollableViewProperties=e}}let Kw=(()=>{class t{constructor(t){this._attachedOverlays=[],this._document=t}ngOnDestroy(){this.detach()}add(t){this.remove(t),this._attachedOverlays.push(t)}remove(t){const e=this._attachedOverlays.indexOf(t);e>-1&&this._attachedOverlays.splice(e,1),0===this._attachedOverlays.length&&this.detach()}}return t.\u0275fac=function(e){return new(e||t)(Xi(Zu))},t.\u0275prov=Wt({factory:function(){return new t(Xi(Zu))},token:t,providedIn:"root"}),t})(),Jw=(()=>{class t extends Kw{constructor(t){super(t),this._keydownListener=t=>{const e=this._attachedOverlays;for(let n=e.length-1;n>-1;n--)if(e[n]._keydownEvents.observers.length>0){e[n]._keydownEvents.next(t);break}}}add(t){super.add(t),this._isAttached||(this._document.body.addEventListener("keydown",this._keydownListener),this._isAttached=!0)}detach(){this._isAttached&&(this._document.body.removeEventListener("keydown",this._keydownListener),this._isAttached=!1)}}return t.\u0275fac=function(e){return new(e||t)(Xi(Zu))},t.\u0275prov=Wt({factory:function(){return new t(Xi(Zu))},token:t,providedIn:"root"}),t})(),Zw=(()=>{class t extends Kw{constructor(t,e){super(t),this._platform=e,this._cursorStyleIsSet=!1,this._clickListener=t=>{const e=t.composedPath?t.composedPath()[0]:t.target,n=this._attachedOverlays.slice();for(let i=n.length-1;i>-1;i--){const r=n[i];if(!(r._outsidePointerEvents.observers.length<1)&&r.hasAttached()){if(r.overlayElement.contains(e))break;r._outsidePointerEvents.next(t)}}}}add(t){if(super.add(t),!this._isAttached){const t=this._document.body;t.addEventListener("click",this._clickListener,!0),t.addEventListener("auxclick",this._clickListener,!0),t.addEventListener("contextmenu",this._clickListener,!0),this._platform.IOS&&!this._cursorStyleIsSet&&(this._cursorOriginalValue=t.style.cursor,t.style.cursor="pointer",this._cursorStyleIsSet=!0),this._isAttached=!0}}detach(){if(this._isAttached){const t=this._document.body;t.removeEventListener("click",this._clickListener,!0),t.removeEventListener("auxclick",this._clickListener,!0),t.removeEventListener("contextmenu",this._clickListener,!0),this._platform.IOS&&this._cursorStyleIsSet&&(t.style.cursor=this._cursorOriginalValue,this._cursorStyleIsSet=!1),this._isAttached=!1}}}return t.\u0275fac=function(e){return new(e||t)(Xi(Zu),Xi(zg))},t.\u0275prov=Wt({factory:function(){return new t(Xi(Zu),Xi(zg))},token:t,providedIn:"root"}),t})();const t_=!("undefined"==typeof window||!window||!window.__karma__&&!window.jasmine);let e_=(()=>{class t{constructor(t,e){this._platform=e,this._document=t}ngOnDestroy(){const t=this._containerElement;t&&t.parentNode&&t.parentNode.removeChild(t)}getContainerElement(){return this._containerElement||this._createContainer(),this._containerElement}_createContainer(){const t="cdk-overlay-container";if(this._platform.isBrowser||t_){const e=this._document.querySelectorAll(`.${t}[platform="server"], .${t}[platform="test"]`);for(let t=0;t<e.length;t++)e[t].parentNode.removeChild(e[t])}const e=this._document.createElement("div");e.classList.add(t),t_?e.setAttribute("platform","test"):this._platform.isBrowser||e.setAttribute("platform","server"),this._document.body.appendChild(e),this._containerElement=e}}return t.\u0275fac=function(e){return new(e||t)(Xi(Zu),Xi(zg))},t.\u0275prov=Wt({factory:function(){return new t(Xi(Zu),Xi(zg))},token:t,providedIn:"root"}),t})();class n_{constructor(t,e,n,i,r,s,o,a,l){this._portalOutlet=t,this._host=e,this._pane=n,this._config=i,this._ngZone=r,this._keyboardDispatcher=s,this._document=o,this._location=a,this._outsideClickDispatcher=l,this._backdropElement=null,this._backdropClick=new tt,this._attachments=new tt,this._detachments=new tt,this._locationChanges=H.EMPTY,this._backdropClickHandler=t=>this._backdropClick.next(t),this._keydownEvents=new tt,this._outsidePointerEvents=new tt,i.scrollStrategy&&(this._scrollStrategy=i.scrollStrategy,this._scrollStrategy.attach(this)),this._positionStrategy=i.positionStrategy}get overlayElement(){return this._pane}get backdropElement(){return this._backdropElement}get hostElement(){return this._host}attach(t){let e=this._portalOutlet.attach(t);return!this._host.parentElement&&this._previousHostParent&&this._previousHostParent.appendChild(this._host),this._positionStrategy&&this._positionStrategy.attach(this),this._updateStackingOrder(),this._updateElementSize(),this._updateElementDirection(),this._scrollStrategy&&this._scrollStrategy.enable(),this._ngZone.onStable.pipe(Xd(1)).subscribe(()=>{this.hasAttached()&&this.updatePosition()}),this._togglePointerEvents(!0),this._config.hasBackdrop&&this._attachBackdrop(),this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!0),this._attachments.next(),this._keyboardDispatcher.add(this),this._config.disposeOnNavigation&&(this._locationChanges=this._location.subscribe(()=>this.dispose())),this._outsideClickDispatcher.add(this),e}detach(){if(!this.hasAttached())return;this.detachBackdrop(),this._togglePointerEvents(!1),this._positionStrategy&&this._positionStrategy.detach&&this._positionStrategy.detach(),this._scrollStrategy&&this._scrollStrategy.disable();const t=this._portalOutlet.detach();return this._detachments.next(),this._keyboardDispatcher.remove(this),this._detachContentWhenStable(),this._locationChanges.unsubscribe(),this._outsideClickDispatcher.remove(this),t}dispose(){const t=this.hasAttached();this._positionStrategy&&this._positionStrategy.dispose(),this._disposeScrollStrategy(),this.detachBackdrop(),this._locationChanges.unsubscribe(),this._keyboardDispatcher.remove(this),this._portalOutlet.dispose(),this._attachments.complete(),this._backdropClick.complete(),this._keydownEvents.complete(),this._outsidePointerEvents.complete(),this._outsideClickDispatcher.remove(this),this._host&&this._host.parentNode&&(this._host.parentNode.removeChild(this._host),this._host=null),this._previousHostParent=this._pane=null,t&&this._detachments.next(),this._detachments.complete()}hasAttached(){return this._portalOutlet.hasAttached()}backdropClick(){return this._backdropClick}attachments(){return this._attachments}detachments(){return this._detachments}keydownEvents(){return this._keydownEvents}outsidePointerEvents(){return this._outsidePointerEvents}getConfig(){return this._config}updatePosition(){this._positionStrategy&&this._positionStrategy.apply()}updatePositionStrategy(t){t!==this._positionStrategy&&(this._positionStrategy&&this._positionStrategy.dispose(),this._positionStrategy=t,this.hasAttached()&&(t.attach(this),this.updatePosition()))}updateSize(t){this._config=Object.assign(Object.assign({},this._config),t),this._updateElementSize()}setDirection(t){this._config=Object.assign(Object.assign({},this._config),{direction:t}),this._updateElementDirection()}addPanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!0)}removePanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!1)}getDirection(){const t=this._config.direction;return t?"string"==typeof t?t:t.value:"ltr"}updateScrollStrategy(t){t!==this._scrollStrategy&&(this._disposeScrollStrategy(),this._scrollStrategy=t,this.hasAttached()&&(t.attach(this),t.enable()))}_updateElementDirection(){this._host.setAttribute("dir",this.getDirection())}_updateElementSize(){if(!this._pane)return;const t=this._pane.style;t.width=Lg(this._config.width),t.height=Lg(this._config.height),t.minWidth=Lg(this._config.minWidth),t.minHeight=Lg(this._config.minHeight),t.maxWidth=Lg(this._config.maxWidth),t.maxHeight=Lg(this._config.maxHeight)}_togglePointerEvents(t){this._pane.style.pointerEvents=t?"":"none"}_attachBackdrop(){const t="cdk-overlay-backdrop-showing";this._backdropElement=this._document.createElement("div"),this._backdropElement.classList.add("cdk-overlay-backdrop"),this._config.backdropClass&&this._toggleClasses(this._backdropElement,this._config.backdropClass,!0),this._host.parentElement.insertBefore(this._backdropElement,this._host),this._backdropElement.addEventListener("click",this._backdropClickHandler),"undefined"!=typeof requestAnimationFrame?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>{this._backdropElement&&this._backdropElement.classList.add(t)})}):this._backdropElement.classList.add(t)}_updateStackingOrder(){this._host.nextSibling&&this._host.parentNode.appendChild(this._host)}detachBackdrop(){let t,e=this._backdropElement;if(!e)return;let n=()=>{e&&(e.removeEventListener("click",this._backdropClickHandler),e.removeEventListener("transitionend",n),e.parentNode&&e.parentNode.removeChild(e)),this._backdropElement==e&&(this._backdropElement=null),this._config.backdropClass&&this._toggleClasses(e,this._config.backdropClass,!1),clearTimeout(t)};e.classList.remove("cdk-overlay-backdrop-showing"),this._ngZone.runOutsideAngular(()=>{e.addEventListener("transitionend",n)}),e.style.pointerEvents="none",t=this._ngZone.runOutsideAngular(()=>setTimeout(n,500))}_toggleClasses(t,e,n){const i=t.classList;Ng(e).forEach(t=>{t&&(n?i.add(t):i.remove(t))})}_detachContentWhenStable(){this._ngZone.runOutsideAngular(()=>{const t=this._ngZone.onStable.pipe(Jx(wt(this._attachments,this._detachments))).subscribe(()=>{this._pane&&this._host&&0!==this._pane.children.length||(this._pane&&this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!1),this._host&&this._host.parentElement&&(this._previousHostParent=this._host.parentElement,this._previousHostParent.removeChild(this._host)),t.unsubscribe())})})}_disposeScrollStrategy(){const t=this._scrollStrategy;t&&(t.disable(),t.detach&&t.detach())}}const i_="cdk-overlay-connected-position-bounding-box",r_=/([A-Za-z%]+)$/;class s_{constructor(t,e,n,i,r){this._viewportRuler=e,this._document=n,this._platform=i,this._overlayContainer=r,this._lastBoundingBoxSize={width:0,height:0},this._isPushed=!1,this._canPush=!0,this._growAfterOpen=!1,this._hasFlexibleDimensions=!0,this._positionLocked=!1,this._viewportMargin=0,this._scrollables=[],this._preferredPositions=[],this._positionChanges=new tt,this._resizeSubscription=H.EMPTY,this._offsetX=0,this._offsetY=0,this._appliedPanelClasses=[],this.positionChanges=this._positionChanges,this.setOrigin(t)}get positions(){return this._preferredPositions}attach(t){this._validatePositions(),t.hostElement.classList.add(i_),this._overlayRef=t,this._boundingBox=t.hostElement,this._pane=t.overlayElement,this._isDisposed=!1,this._isInitialRender=!0,this._lastPosition=null,this._resizeSubscription.unsubscribe(),this._resizeSubscription=this._viewportRuler.change().subscribe(()=>{this._isInitialRender=!0,this.apply()})}apply(){if(this._isDisposed||!this._platform.isBrowser)return;if(!this._isInitialRender&&this._positionLocked&&this._lastPosition)return void this.reapplyLastPosition();this._clearPanelClasses(),this._resetOverlayElementStyles(),this._resetBoundingBoxStyles(),this._viewportRect=this._getNarrowedViewportRect(),this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect();const t=this._originRect,e=this._overlayRect,n=this._viewportRect,i=[];let r;for(let s of this._preferredPositions){let o=this._getOriginPoint(t,s),a=this._getOverlayPoint(o,e,s),l=this._getOverlayFit(a,e,n,s);if(l.isCompletelyWithinViewport)return this._isPushed=!1,void this._applyPosition(s,o);this._canFitWithFlexibleDimensions(l,a,n)?i.push({position:s,origin:o,overlayRect:e,boundingBoxRect:this._calculateBoundingBoxRect(o,s)}):(!r||r.overlayFit.visibleArea<l.visibleArea)&&(r={overlayFit:l,overlayPoint:a,originPoint:o,position:s,overlayRect:e})}if(i.length){let t=null,e=-1;for(const n of i){const i=n.boundingBoxRect.width*n.boundingBoxRect.height*(n.position.weight||1);i>e&&(e=i,t=n)}return this._isPushed=!1,void this._applyPosition(t.position,t.origin)}if(this._canPush)return this._isPushed=!0,void this._applyPosition(r.position,r.originPoint);this._applyPosition(r.position,r.originPoint)}detach(){this._clearPanelClasses(),this._lastPosition=null,this._previousPushAmount=null,this._resizeSubscription.unsubscribe()}dispose(){this._isDisposed||(this._boundingBox&&o_(this._boundingBox.style,{top:"",left:"",right:"",bottom:"",height:"",width:"",alignItems:"",justifyContent:""}),this._pane&&this._resetOverlayElementStyles(),this._overlayRef&&this._overlayRef.hostElement.classList.remove(i_),this.detach(),this._positionChanges.complete(),this._overlayRef=this._boundingBox=null,this._isDisposed=!0)}reapplyLastPosition(){if(!this._isDisposed&&(!this._platform||this._platform.isBrowser)){this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._viewportRect=this._getNarrowedViewportRect();const t=this._lastPosition||this._preferredPositions[0],e=this._getOriginPoint(this._originRect,t);this._applyPosition(t,e)}}withScrollableContainers(t){return this._scrollables=t,this}withPositions(t){return this._preferredPositions=t,-1===t.indexOf(this._lastPosition)&&(this._lastPosition=null),this._validatePositions(),this}withViewportMargin(t){return this._viewportMargin=t,this}withFlexibleDimensions(t=!0){return this._hasFlexibleDimensions=t,this}withGrowAfterOpen(t=!0){return this._growAfterOpen=t,this}withPush(t=!0){return this._canPush=t,this}withLockedPosition(t=!0){return this._positionLocked=t,this}setOrigin(t){return this._origin=t,this}withDefaultOffsetX(t){return this._offsetX=t,this}withDefaultOffsetY(t){return this._offsetY=t,this}withTransformOriginOn(t){return this._transformOriginSelector=t,this}_getOriginPoint(t,e){let n,i;if("center"==e.originX)n=t.left+t.width/2;else{const i=this._isRtl()?t.right:t.left,r=this._isRtl()?t.left:t.right;n="start"==e.originX?i:r}return i="center"==e.originY?t.top+t.height/2:"top"==e.originY?t.top:t.bottom,{x:n,y:i}}_getOverlayPoint(t,e,n){let i,r;return i="center"==n.overlayX?-e.width/2:"start"===n.overlayX?this._isRtl()?-e.width:0:this._isRtl()?0:-e.width,r="center"==n.overlayY?-e.height/2:"top"==n.overlayY?0:-e.height,{x:t.x+i,y:t.y+r}}_getOverlayFit(t,e,n,i){const r=l_(e);let{x:s,y:o}=t,a=this._getOffset(i,"x"),l=this._getOffset(i,"y");a&&(s+=a),l&&(o+=l);let c=0-o,u=o+r.height-n.height,h=this._subtractOverflows(r.width,0-s,s+r.width-n.width),d=this._subtractOverflows(r.height,c,u),p=h*d;return{visibleArea:p,isCompletelyWithinViewport:r.width*r.height===p,fitsInViewportVertically:d===r.height,fitsInViewportHorizontally:h==r.width}}_canFitWithFlexibleDimensions(t,e,n){if(this._hasFlexibleDimensions){const i=n.bottom-e.y,r=n.right-e.x,s=a_(this._overlayRef.getConfig().minHeight),o=a_(this._overlayRef.getConfig().minWidth),a=t.fitsInViewportHorizontally||null!=o&&o<=r;return(t.fitsInViewportVertically||null!=s&&s<=i)&&a}return!1}_pushOverlayOnScreen(t,e,n){if(this._previousPushAmount&&this._positionLocked)return{x:t.x+this._previousPushAmount.x,y:t.y+this._previousPushAmount.y};const i=l_(e),r=this._viewportRect,s=Math.max(t.x+i.width-r.width,0),o=Math.max(t.y+i.height-r.height,0),a=Math.max(r.top-n.top-t.y,0),l=Math.max(r.left-n.left-t.x,0);let c=0,u=0;return c=i.width<=r.width?l||-s:t.x<this._viewportMargin?r.left-n.left-t.x:0,u=i.height<=r.height?a||-o:t.y<this._viewportMargin?r.top-n.top-t.y:0,this._previousPushAmount={x:c,y:u},{x:t.x+c,y:t.y+u}}_applyPosition(t,e){if(this._setTransformOrigin(t),this._setOverlayElementStyles(e,t),this._setBoundingBoxStyles(e,t),t.panelClass&&this._addPanelClasses(t.panelClass),this._lastPosition=t,this._positionChanges.observers.length){const e=this._getScrollVisibility(),n=new Yw(t,e);this._positionChanges.next(n)}this._isInitialRender=!1}_setTransformOrigin(t){if(!this._transformOriginSelector)return;const e=this._boundingBox.querySelectorAll(this._transformOriginSelector);let n,i=t.overlayY;n="center"===t.overlayX?"center":this._isRtl()?"start"===t.overlayX?"right":"left":"start"===t.overlayX?"left":"right";for(let r=0;r<e.length;r++)e[r].style.transformOrigin=`${n} ${i}`}_calculateBoundingBoxRect(t,e){const n=this._viewportRect,i=this._isRtl();let r,s,o,a,l,c;if("top"===e.overlayY)s=t.y,r=n.height-s+this._viewportMargin;else if("bottom"===e.overlayY)o=n.height-t.y+2*this._viewportMargin,r=n.height-o+this._viewportMargin;else{const e=Math.min(n.bottom-t.y+n.top,t.y),i=this._lastBoundingBoxSize.height;r=2*e,s=t.y-e,r>i&&!this._isInitialRender&&!this._growAfterOpen&&(s=t.y-i/2)}if("end"===e.overlayX&&!i||"start"===e.overlayX&&i)c=n.width-t.x+this._viewportMargin,a=t.x-this._viewportMargin;else if("start"===e.overlayX&&!i||"end"===e.overlayX&&i)l=t.x,a=n.right-t.x;else{const e=Math.min(n.right-t.x+n.left,t.x),i=this._lastBoundingBoxSize.width;a=2*e,l=t.x-e,a>i&&!this._isInitialRender&&!this._growAfterOpen&&(l=t.x-i/2)}return{top:s,left:l,bottom:o,right:c,width:a,height:r}}_setBoundingBoxStyles(t,e){const n=this._calculateBoundingBoxRect(t,e);this._isInitialRender||this._growAfterOpen||(n.height=Math.min(n.height,this._lastBoundingBoxSize.height),n.width=Math.min(n.width,this._lastBoundingBoxSize.width));const i={};if(this._hasExactPosition())i.top=i.left="0",i.bottom=i.right=i.maxHeight=i.maxWidth="",i.width=i.height="100%";else{const t=this._overlayRef.getConfig().maxHeight,r=this._overlayRef.getConfig().maxWidth;i.height=Lg(n.height),i.top=Lg(n.top),i.bottom=Lg(n.bottom),i.width=Lg(n.width),i.left=Lg(n.left),i.right=Lg(n.right),i.alignItems="center"===e.overlayX?"center":"end"===e.overlayX?"flex-end":"flex-start",i.justifyContent="center"===e.overlayY?"center":"bottom"===e.overlayY?"flex-end":"flex-start",t&&(i.maxHeight=Lg(t)),r&&(i.maxWidth=Lg(r))}this._lastBoundingBoxSize=n,o_(this._boundingBox.style,i)}_resetBoundingBoxStyles(){o_(this._boundingBox.style,{top:"0",left:"0",right:"0",bottom:"0",height:"",width:"",alignItems:"",justifyContent:""})}_resetOverlayElementStyles(){o_(this._pane.style,{top:"",left:"",bottom:"",right:"",position:"",transform:""})}_setOverlayElementStyles(t,e){const n={},i=this._hasExactPosition(),r=this._hasFlexibleDimensions,s=this._overlayRef.getConfig();if(i){const i=this._viewportRuler.getViewportScrollPosition();o_(n,this._getExactOverlayY(e,t,i)),o_(n,this._getExactOverlayX(e,t,i))}else n.position="static";let o="",a=this._getOffset(e,"x"),l=this._getOffset(e,"y");a&&(o+=`translateX(${a}px) `),l&&(o+=`translateY(${l}px)`),n.transform=o.trim(),s.maxHeight&&(i?n.maxHeight=Lg(s.maxHeight):r&&(n.maxHeight="")),s.maxWidth&&(i?n.maxWidth=Lg(s.maxWidth):r&&(n.maxWidth="")),o_(this._pane.style,n)}_getExactOverlayY(t,e,n){let i={top:"",bottom:""},r=this._getOverlayPoint(e,this._overlayRect,t);this._isPushed&&(r=this._pushOverlayOnScreen(r,this._overlayRect,n));let s=this._overlayContainer.getContainerElement().getBoundingClientRect().top;return r.y-=s,"bottom"===t.overlayY?i.bottom=this._document.documentElement.clientHeight-(r.y+this._overlayRect.height)+"px":i.top=Lg(r.y),i}_getExactOverlayX(t,e,n){let i,r={left:"",right:""},s=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(s=this._pushOverlayOnScreen(s,this._overlayRect,n)),i=this._isRtl()?"end"===t.overlayX?"left":"right":"end"===t.overlayX?"right":"left","right"===i?r.right=this._document.documentElement.clientWidth-(s.x+this._overlayRect.width)+"px":r.left=Lg(s.x),r}_getScrollVisibility(){const t=this._getOriginRect(),e=this._pane.getBoundingClientRect(),n=this._scrollables.map(t=>t.getElementRef().nativeElement.getBoundingClientRect());return{isOriginClipped:Ww(t,n),isOriginOutsideView:Gw(t,n),isOverlayClipped:Ww(e,n),isOverlayOutsideView:Gw(e,n)}}_subtractOverflows(t,...e){return e.reduce((t,e)=>t-Math.max(e,0),t)}_getNarrowedViewportRect(){const t=this._document.documentElement.clientWidth,e=this._document.documentElement.clientHeight,n=this._viewportRuler.getViewportScrollPosition();return{top:n.top+this._viewportMargin,left:n.left+this._viewportMargin,right:n.left+t-this._viewportMargin,bottom:n.top+e-this._viewportMargin,width:t-2*this._viewportMargin,height:e-2*this._viewportMargin}}_isRtl(){return"rtl"===this._overlayRef.getDirection()}_hasExactPosition(){return!this._hasFlexibleDimensions||this._isPushed}_getOffset(t,e){return"x"===e?null==t.offsetX?this._offsetX:t.offsetX:null==t.offsetY?this._offsetY:t.offsetY}_validatePositions(){}_addPanelClasses(t){this._pane&&Ng(t).forEach(t=>{""!==t&&-1===this._appliedPanelClasses.indexOf(t)&&(this._appliedPanelClasses.push(t),this._pane.classList.add(t))})}_clearPanelClasses(){this._pane&&(this._appliedPanelClasses.forEach(t=>{this._pane.classList.remove(t)}),this._appliedPanelClasses=[])}_getOriginRect(){const t=this._origin;if(t instanceof Cl)return t.nativeElement.getBoundingClientRect();if(t instanceof Element)return t.getBoundingClientRect();const e=t.width||0,n=t.height||0;return{top:t.y,bottom:t.y+n,left:t.x,right:t.x+e,height:n,width:e}}}function o_(t,e){for(let n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}function a_(t){if("number"!=typeof t&&null!=t){const[e,n]=t.split(r_);return n&&"px"!==n?null:parseFloat(e)}return t||null}function l_(t){return{top:Math.floor(t.top),right:Math.floor(t.right),bottom:Math.floor(t.bottom),left:Math.floor(t.left),width:Math.floor(t.width),height:Math.floor(t.height)}}class c_{constructor(t,e,n,i,r,s,o){this._preferredPositions=[],this._positionStrategy=new s_(n,i,r,s,o).withFlexibleDimensions(!1).withPush(!1).withViewportMargin(0),this.withFallbackPosition(t,e),this.onPositionChange=this._positionStrategy.positionChanges}get positions(){return this._preferredPositions}attach(t){this._overlayRef=t,this._positionStrategy.attach(t),this._direction&&(t.setDirection(this._direction),this._direction=null)}dispose(){this._positionStrategy.dispose()}detach(){this._positionStrategy.detach()}apply(){this._positionStrategy.apply()}recalculateLastPosition(){this._positionStrategy.reapplyLastPosition()}withScrollableContainers(t){this._positionStrategy.withScrollableContainers(t)}withFallbackPosition(t,e,n,i){const r=new Xw(t,e,n,i);return this._preferredPositions.push(r),this._positionStrategy.withPositions(this._preferredPositions),this}withDirection(t){return this._overlayRef?this._overlayRef.setDirection(t):this._direction=t,this}withOffsetX(t){return this._positionStrategy.withDefaultOffsetX(t),this}withOffsetY(t){return this._positionStrategy.withDefaultOffsetY(t),this}withLockedPosition(t){return this._positionStrategy.withLockedPosition(t),this}withPositions(t){return this._preferredPositions=t.slice(),this._positionStrategy.withPositions(this._preferredPositions),this}setOrigin(t){return this._positionStrategy.setOrigin(t),this}}const u_="cdk-global-overlay-wrapper";class h_{constructor(){this._cssPosition="static",this._topOffset="",this._bottomOffset="",this._leftOffset="",this._rightOffset="",this._alignItems="",this._justifyContent="",this._width="",this._height=""}attach(t){const e=t.getConfig();this._overlayRef=t,this._width&&!e.width&&t.updateSize({width:this._width}),this._height&&!e.height&&t.updateSize({height:this._height}),t.hostElement.classList.add(u_),this._isDisposed=!1}top(t=""){return this._bottomOffset="",this._topOffset=t,this._alignItems="flex-start",this}left(t=""){return this._rightOffset="",this._leftOffset=t,this._justifyContent="flex-start",this}bottom(t=""){return this._topOffset="",this._bottomOffset=t,this._alignItems="flex-end",this}right(t=""){return this._leftOffset="",this._rightOffset=t,this._justifyContent="flex-end",this}width(t=""){return this._overlayRef?this._overlayRef.updateSize({width:t}):this._width=t,this}height(t=""){return this._overlayRef?this._overlayRef.updateSize({height:t}):this._height=t,this}centerHorizontally(t=""){return this.left(t),this._justifyContent="center",this}centerVertically(t=""){return this.top(t),this._alignItems="center",this}apply(){if(!this._overlayRef||!this._overlayRef.hasAttached())return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement.style,n=this._overlayRef.getConfig(),{width:i,height:r,maxWidth:s,maxHeight:o}=n,a=!("100%"!==i&&"100vw"!==i||s&&"100%"!==s&&"100vw"!==s),l=!("100%"!==r&&"100vh"!==r||o&&"100%"!==o&&"100vh"!==o);t.position=this._cssPosition,t.marginLeft=a?"0":this._leftOffset,t.marginTop=l?"0":this._topOffset,t.marginBottom=this._bottomOffset,t.marginRight=this._rightOffset,a?e.justifyContent="flex-start":"center"===this._justifyContent?e.justifyContent="center":"rtl"===this._overlayRef.getConfig().direction?"flex-start"===this._justifyContent?e.justifyContent="flex-end":"flex-end"===this._justifyContent&&(e.justifyContent="flex-start"):e.justifyContent=this._justifyContent,e.alignItems=l?"flex-start":this._alignItems}dispose(){if(this._isDisposed||!this._overlayRef)return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement,n=e.style;e.classList.remove(u_),n.justifyContent=n.alignItems=t.marginTop=t.marginBottom=t.marginLeft=t.marginRight=t.position="",this._overlayRef=null,this._isDisposed=!0}}let d_=(()=>{class t{constructor(t,e,n,i){this._viewportRuler=t,this._document=e,this._platform=n,this._overlayContainer=i}global(){return new h_}connectedTo(t,e,n){return new c_(e,n,t,this._viewportRuler,this._document,this._platform,this._overlayContainer)}flexibleConnectedTo(t){return new s_(t,this._viewportRuler,this._document,this._platform,this._overlayContainer)}}return t.\u0275fac=function(e){return new(e||t)(Xi(Pw),Xi(Zu),Xi(zg),Xi(e_))},t.\u0275prov=Wt({factory:function(){return new t(Xi(Pw),Xi(Zu),Xi(zg),Xi(e_))},token:t,providedIn:"root"}),t})(),p_=0,f_=(()=>{class t{constructor(t,e,n,i,r,s,o,a,l,c,u){this.scrollStrategies=t,this._overlayContainer=e,this._componentFactoryResolver=n,this._positionBuilder=i,this._keyboardDispatcher=r,this._injector=s,this._ngZone=o,this._document=a,this._directionality=l,this._location=c,this._outsideClickDispatcher=u}create(t){const e=this._createHostElement(),n=this._createPaneElement(e),i=this._createPortalOutlet(n),r=new qw(t);return r.direction=r.direction||this._directionality.value,new n_(i,e,n,r,this._ngZone,this._keyboardDispatcher,this._document,this._location,this._outsideClickDispatcher)}position(){return this._positionBuilder}_createPaneElement(t){const e=this._document.createElement("div");return e.id="cdk-overlay-"+p_++,e.classList.add("cdk-overlay-pane"),t.appendChild(e),e}_createHostElement(){const t=this._document.createElement("div");return this._overlayContainer.getContainerElement().appendChild(t),t}_createPortalOutlet(t){return this._appRef||(this._appRef=this._injector.get(Uu)),new hw(t,this._componentFactoryResolver,this._appRef,this._injector,this._document)}}return t.\u0275fac=function(e){return new(e||t)(Xi(Qw),Xi(e_),Xi(wl),Xi(d_),Xi(Jw),Xi(Xo),Xi(Au),Xi(Zu),Xi(_y),Xi(fh),Xi(Zw))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();const m_={provide:new Ri("cdk-connected-overlay-scroll-strategy"),deps:[f_],useFactory:function(t){return()=>t.scrollStrategies.reposition()}};let g_=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({providers:[f_,m_],imports:[[Sy,fw,$w],$w]}),t})();const y_=["mat-menu-item",""],v_=["*"];function b_(t,e){if(1&t){const t=xa();ga(0,"div",0),Ea("keydown",function(e){return yn(t),ka()._handleKeydown(e)})("click",function(){return yn(t),ka().closed.emit("click")})("@transformMenu.start",function(e){return yn(t),ka()._onAnimationStart(e)})("@transformMenu.done",function(e){return yn(t),ka()._onAnimationDone(e)}),ga(1,"div",1),La(2),ya(),ya()}if(2&t){const t=ka();fa("id",t.panelId)("ngClass",t._classList)("@transformMenu",t._panelAnimationState),ua("aria-label",t.ariaLabel||null)("aria-labelledby",t.ariaLabelledby||null)("aria-describedby",t.ariaDescribedby||null)}}const A_={transformMenu:Ty("transformMenu",[Ny("void",Ry({opacity:0,transform:"scale(0.8)"})),Dy("void => enter",My("120ms cubic-bezier(0, 0, 0.2, 1)",Ry({opacity:1,transform:"scale(1)"}))),Dy("* => void",My("100ms 25ms linear",Ry({opacity:0})))]),fadeInItems:Ty("fadeInItems",[Ny("showing",Ry({opacity:1})),Dy("void => *",[Ry({opacity:0}),My("400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)")])])},x_=new Ri("MatMenuContent"),w_=new Ri("MAT_MENU_PANEL");class __{}const S_=yA(mA(__));let E_=(()=>{class t extends S_{constructor(t,e,n,i){super(),this._elementRef=t,this._focusMonitor=n,this._parentMenu=i,this.role="menuitem",this._hovered=new tt,this._focused=new tt,this._highlighted=!1,this._triggersSubmenu=!1,i&&i.addItem&&i.addItem(this)}focus(t,e){this._focusMonitor&&t?this._focusMonitor.focusVia(this._getHostElement(),t,e):this._getHostElement().focus(e),this._focused.next(this)}ngAfterViewInit(){this._focusMonitor&&this._focusMonitor.monitor(this._elementRef,!1)}ngOnDestroy(){this._focusMonitor&&this._focusMonitor.stopMonitoring(this._elementRef),this._parentMenu&&this._parentMenu.removeItem&&this._parentMenu.removeItem(this),this._hovered.complete(),this._focused.complete()}_getTabIndex(){return this.disabled?"-1":"0"}_getHostElement(){return this._elementRef.nativeElement}_checkDisabled(t){this.disabled&&(t.preventDefault(),t.stopPropagation())}_handleMouseEnter(){this._hovered.next(this)}getLabel(){var t,e;const n=this._elementRef.nativeElement.cloneNode(!0),i=n.querySelectorAll("mat-icon, .material-icons");for(let r=0;r<i.length;r++){const e=i[r];null===(t=e.parentNode)||void 0===t||t.removeChild(e)}return(null===(e=n.textContent)||void 0===e?void 0:e.trim())||""}}return t.\u0275fac=function(e){return new(e||t)(pa(Cl),pa(Zu),pa(fy),pa(w_,8))},t.\u0275cmp=Se({type:t,selectors:[["","mat-menu-item",""]],hostAttrs:[1,"mat-focus-indicator"],hostVars:10,hostBindings:function(t,e){1&t&&Ea("click",function(t){return e._checkDisabled(t)})("mouseenter",function(){return e._handleMouseEnter()}),2&t&&(ua("role",e.role)("tabindex",e._getTabIndex())("aria-disabled",e.disabled.toString())("disabled",e.disabled||null),Ua("mat-menu-item",!0)("mat-menu-item-highlighted",e._highlighted)("mat-menu-item-submenu-trigger",e._triggersSubmenu))},inputs:{disabled:"disabled",disableRipple:"disableRipple",role:"role"},exportAs:["matMenuItem"],features:[Ko],attrs:y_,ngContentSelectors:v_,decls:2,vars:2,consts:[["matRipple","",1,"mat-menu-ripple",3,"matRippleDisabled","matRippleTrigger"]],template:function(t,e){1&t&&(Na(),La(0),va(1,"div",0)),2&t&&(Bs(1),fa("matRippleDisabled",e.disableRipple||e.disabled)("matRippleTrigger",e._getHostElement()))},directives:[TA],encapsulation:2,changeDetection:0}),t})();const C_=new Ri("mat-menu-default-options",{providedIn:"root",factory:function(){return{overlapTrigger:!1,xPosition:"after",yPosition:"below",backdropClass:"cdk-overlay-transparent-backdrop"}}});let I_=0,T_=(()=>{class t{constructor(t,e,n){this._elementRef=t,this._ngZone=e,this._defaultOptions=n,this._xPosition=this._defaultOptions.xPosition,this._yPosition=this._defaultOptions.yPosition,this._directDescendantItems=new Dc,this._tabSubscription=H.EMPTY,this._classList={},this._panelAnimationState="void",this._animationDone=new tt,this.overlayPanelClass=this._defaultOptions.overlayPanelClass||"",this.backdropClass=this._defaultOptions.backdropClass,this._overlapTrigger=this._defaultOptions.overlapTrigger,this._hasBackdrop=this._defaultOptions.hasBackdrop,this.closed=new Nc,this.close=this.closed,this.panelId="mat-menu-panel-"+I_++}get xPosition(){return this._xPosition}set xPosition(t){this._xPosition=t,this.setPositionClasses()}get yPosition(){return this._yPosition}set yPosition(t){this._yPosition=t,this.setPositionClasses()}get overlapTrigger(){return this._overlapTrigger}set overlapTrigger(t){this._overlapTrigger=kg(t)}get hasBackdrop(){return this._hasBackdrop}set hasBackdrop(t){this._hasBackdrop=kg(t)}set panelClass(t){const e=this._previousPanelClass;e&&e.length&&e.split(" ").forEach(t=>{this._classList[t]=!1}),this._previousPanelClass=t,t&&t.length&&(t.split(" ").forEach(t=>{this._classList[t]=!0}),this._elementRef.nativeElement.className="")}get classList(){return this.panelClass}set classList(t){this.panelClass=t}ngOnInit(){this.setPositionClasses()}ngAfterContentInit(){this._updateDirectDescendants(),this._keyManager=new ry(this._directDescendantItems).withWrap().withTypeAhead().withHomeAndEnd(),this._tabSubscription=this._keyManager.tabOut.subscribe(()=>this.closed.emit("tab")),this._directDescendantItems.changes.pipe(Jd(this._directDescendantItems),Wd(t=>wt(...t.map(t=>t._focused)))).subscribe(t=>this._keyManager.updateActiveItem(t))}ngOnDestroy(){this._directDescendantItems.destroy(),this._tabSubscription.unsubscribe(),this.closed.complete()}_hovered(){return this._directDescendantItems.changes.pipe(Jd(this._directDescendantItems),Wd(t=>wt(...t.map(t=>t._hovered))))}addItem(t){}removeItem(t){}_handleKeydown(t){const e=t.keyCode,n=this._keyManager;switch(e){case 27:Ag(t)||(t.preventDefault(),this.closed.emit("keydown"));break;case 37:this.parentMenu&&"ltr"===this.direction&&this.closed.emit("keydown");break;case 39:this.parentMenu&&"rtl"===this.direction&&this.closed.emit("keydown");break;default:38!==e&&40!==e||n.setFocusOrigin("keyboard"),n.onKeydown(t)}}focusFirstItem(t="program"){this.lazyContent?this._ngZone.onStable.pipe(Xd(1)).subscribe(()=>this._focusFirstItem(t)):this._focusFirstItem(t)}_focusFirstItem(t){const e=this._keyManager;if(e.setFocusOrigin(t).setFirstItemActive(),!e.activeItem&&this._directDescendantItems.length){let t=this._directDescendantItems.first._getHostElement().parentElement;for(;t;){if("menu"===t.getAttribute("role")){t.focus();break}t=t.parentElement}}}resetActiveItem(){this._keyManager.setActiveItem(-1)}setElevation(t){const e=`mat-elevation-z${Math.min(4+t,24)}`,n=Object.keys(this._classList).find(t=>t.startsWith("mat-elevation-z"));n&&n!==this._previousElevation||(this._previousElevation&&(this._classList[this._previousElevation]=!1),this._classList[e]=!0,this._previousElevation=e)}setPositionClasses(t=this.xPosition,e=this.yPosition){const n=this._classList;n["mat-menu-before"]="before"===t,n["mat-menu-after"]="after"===t,n["mat-menu-above"]="above"===e,n["mat-menu-below"]="below"===e}_startAnimation(){this._panelAnimationState="enter"}_resetAnimation(){this._panelAnimationState="void"}_onAnimationDone(t){this._animationDone.next(t),this._isAnimating=!1}_onAnimationStart(t){this._isAnimating=!0,"enter"===t.toState&&0===this._keyManager.activeItemIndex&&(t.element.scrollTop=0)}_updateDirectDescendants(){this._allItems.changes.pipe(Jd(this._allItems)).subscribe(t=>{this._directDescendantItems.reset(t.filter(t=>t._parentMenu===this)),this._directDescendantItems.notifyOnChanges()})}}return t.\u0275fac=function(e){return new(e||t)(pa(Cl),pa(Au),pa(C_))},t.\u0275dir=ke({type:t,contentQueries:function(t,e,n){if(1&t&&(jc(n,x_,1),jc(n,E_,1),jc(n,E_,0)),2&t){let t;Gc(t=Qc())&&(e.lazyContent=t.first),Gc(t=Qc())&&(e._allItems=t),Gc(t=Qc())&&(e.items=t)}},viewQuery:function(t,e){if(1&t&&Wc(rc,1),2&t){let t;Gc(t=Qc())&&(e.templateRef=t.first)}},inputs:{backdropClass:"backdropClass",xPosition:"xPosition",yPosition:"yPosition",overlapTrigger:"overlapTrigger",hasBackdrop:"hasBackdrop",panelClass:["class","panelClass"],classList:"classList",ariaLabel:["aria-label","ariaLabel"],ariaLabelledby:["aria-labelledby","ariaLabelledby"],ariaDescribedby:["aria-describedby","ariaDescribedby"]},outputs:{closed:"closed",close:"close"}}),t})(),M_=(()=>{class t extends T_{constructor(t,e,n){super(t,e,n)}}return t.\u0275fac=function(e){return new(e||t)(pa(Cl),pa(Au),pa(C_))},t.\u0275cmp=Se({type:t,selectors:[["mat-menu"]],hostVars:3,hostBindings:function(t,e){2&t&&ua("aria-label",null)("aria-labelledby",null)("aria-describedby",null)},exportAs:["matMenu"],features:[bl([{provide:w_,useExisting:t}]),Ko],ngContentSelectors:v_,decls:1,vars:0,consts:[["tabindex","-1","role","menu",1,"mat-menu-panel",3,"id","ngClass","keydown","click"],[1,"mat-menu-content"]],template:function(t,e){1&t&&(Na(),ha(0,b_,3,6,"ng-template"))},directives:[Th],styles:['mat-menu{display:none}.mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:4px;outline:0;min-height:64px}.mat-menu-panel.ng-animating{pointer-events:none}.cdk-high-contrast-active .mat-menu-panel{outline:solid 1px}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}.mat-menu-item[disabled]{pointer-events:none}.cdk-high-contrast-active .mat-menu-item{margin-top:1px}.cdk-high-contrast-active .mat-menu-item.cdk-program-focused,.cdk-high-contrast-active .mat-menu-item.cdk-keyboard-focused,.cdk-high-contrast-active .mat-menu-item-highlighted{outline:dotted 1px}.mat-menu-item-submenu-trigger{padding-right:32px}.mat-menu-item-submenu-trigger::after{width:0;height:0;border-style:solid;border-width:5px 0 5px 5px;border-color:transparent transparent transparent currentColor;content:"";display:inline-block;position:absolute;top:50%;right:16px;transform:translateY(-50%)}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}[dir=rtl] .mat-menu-item-submenu-trigger::after{right:auto;left:16px;transform:rotateY(180deg) translateY(-50%)}button.mat-menu-item{width:100%}.mat-menu-item .mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\n'],encapsulation:2,data:{animation:[A_.transformMenu,A_.fadeInItems]},changeDetection:0}),t})();const k_=new Ri("mat-menu-scroll-strategy"),R_={provide:k_,deps:[f_],useFactory:function(t){return()=>t.scrollStrategies.reposition()}},N_=Hg({passive:!0});let L_=(()=>{class t{constructor(t,e,n,i,r,s,o,a){this._overlay=t,this._element=e,this._viewContainerRef=n,this._menuItemInstance=s,this._dir=o,this._focusMonitor=a,this._overlayRef=null,this._menuOpen=!1,this._closingActionsSubscription=H.EMPTY,this._hoverSubscription=H.EMPTY,this._menuCloseSubscription=H.EMPTY,this._handleTouchStart=t=>{hy(t)||(this._openedBy="touch")},this._openedBy=void 0,this.restoreFocus=!0,this.menuOpened=new Nc,this.onMenuOpen=this.menuOpened,this.menuClosed=new Nc,this.onMenuClose=this.menuClosed,this._scrollStrategy=i,this._parentMaterialMenu=r instanceof T_?r:void 0,e.nativeElement.addEventListener("touchstart",this._handleTouchStart,N_),s&&(s._triggersSubmenu=this.triggersSubmenu())}get _deprecatedMatMenuTriggerFor(){return this.menu}set _deprecatedMatMenuTriggerFor(t){this.menu=t}get menu(){return this._menu}set menu(t){t!==this._menu&&(this._menu=t,this._menuCloseSubscription.unsubscribe(),t&&(this._menuCloseSubscription=t.close.subscribe(t=>{this._destroyMenu(t),"click"!==t&&"tab"!==t||!this._parentMaterialMenu||this._parentMaterialMenu.closed.emit(t)})))}ngAfterContentInit(){this._checkMenu(),this._handleHover()}ngOnDestroy(){this._overlayRef&&(this._overlayRef.dispose(),this._overlayRef=null),this._element.nativeElement.removeEventListener("touchstart",this._handleTouchStart,N_),this._menuCloseSubscription.unsubscribe(),this._closingActionsSubscription.unsubscribe(),this._hoverSubscription.unsubscribe()}get menuOpen(){return this._menuOpen}get dir(){return this._dir&&"rtl"===this._dir.value?"rtl":"ltr"}triggersSubmenu(){return!(!this._menuItemInstance||!this._parentMaterialMenu)}toggleMenu(){return this._menuOpen?this.closeMenu():this.openMenu()}openMenu(){if(this._menuOpen)return;this._checkMenu();const t=this._createOverlay(),e=t.getConfig();this._setPosition(e.positionStrategy),e.hasBackdrop=null==this.menu.hasBackdrop?!this.triggersSubmenu():this.menu.hasBackdrop,t.attach(this._getPortal()),this.menu.lazyContent&&this.menu.lazyContent.attach(this.menuData),this._closingActionsSubscription=this._menuClosingActions().subscribe(()=>this.closeMenu()),this._initMenu(),this.menu instanceof T_&&this.menu._startAnimation()}closeMenu(){this.menu.close.emit()}focus(t,e){this._focusMonitor&&t?this._focusMonitor.focusVia(this._element,t,e):this._element.nativeElement.focus(e)}_destroyMenu(t){if(!this._overlayRef||!this.menuOpen)return;const e=this.menu;this._closingActionsSubscription.unsubscribe(),this._overlayRef.detach(),!this.restoreFocus||"keydown"!==t&&this._openedBy&&this.triggersSubmenu()||this.focus(this._openedBy),this._openedBy=void 0,e instanceof T_?(e._resetAnimation(),e.lazyContent?e._animationDone.pipe(np(t=>"void"===t.toState),Xd(1),Jx(e.lazyContent._attached)).subscribe({next:()=>e.lazyContent.detach(),complete:()=>this._setIsMenuOpen(!1)}):this._setIsMenuOpen(!1)):(this._setIsMenuOpen(!1),e.lazyContent&&e.lazyContent.detach())}_initMenu(){this.menu.parentMenu=this.triggersSubmenu()?this._parentMaterialMenu:void 0,this.menu.direction=this.dir,this._setMenuElevation(),this.menu.focusFirstItem(this._openedBy||"program"),this._setIsMenuOpen(!0)}_setMenuElevation(){if(this.menu.setElevation){let t=0,e=this.menu.parentMenu;for(;e;)t++,e=e.parentMenu;this.menu.setElevation(t)}}_setIsMenuOpen(t){this._menuOpen=t,this._menuOpen?this.menuOpened.emit():this.menuClosed.emit(),this.triggersSubmenu()&&(this._menuItemInstance._highlighted=t)}_checkMenu(){}_createOverlay(){if(!this._overlayRef){const t=this._getOverlayConfig();this._subscribeToPositions(t.positionStrategy),this._overlayRef=this._overlay.create(t),this._overlayRef.keydownEvents().subscribe()}return this._overlayRef}_getOverlayConfig(){return new qw({positionStrategy:this._overlay.position().flexibleConnectedTo(this._element).withLockedPosition().withGrowAfterOpen().withTransformOriginOn(".mat-menu-panel, .mat-mdc-menu-panel"),backdropClass:this.menu.backdropClass||"cdk-overlay-transparent-backdrop",panelClass:this.menu.overlayPanelClass,scrollStrategy:this._scrollStrategy(),direction:this._dir})}_subscribeToPositions(t){this.menu.setPositionClasses&&t.positionChanges.subscribe(t=>{this.menu.setPositionClasses("start"===t.connectionPair.overlayX?"after":"before","top"===t.connectionPair.overlayY?"below":"above")})}_setPosition(t){let[e,n]="before"===this.menu.xPosition?["end","start"]:["start","end"],[i,r]="above"===this.menu.yPosition?["bottom","top"]:["top","bottom"],[s,o]=[i,r],[a,l]=[e,n],c=0;this.triggersSubmenu()?(l=e="before"===this.menu.xPosition?"start":"end",n=a="end"===e?"start":"end",c="bottom"===i?8:-8):this.menu.overlapTrigger||(s="top"===i?"bottom":"top",o="top"===r?"bottom":"top"),t.withPositions([{originX:e,originY:s,overlayX:a,overlayY:i,offsetY:c},{originX:n,originY:s,overlayX:l,overlayY:i,offsetY:c},{originX:e,originY:o,overlayX:a,overlayY:r,offsetY:-c},{originX:n,originY:o,overlayX:l,overlayY:r,offsetY:-c}])}_menuClosingActions(){const t=this._overlayRef.backdropClick(),e=this._overlayRef.detachments();return wt(t,this._parentMaterialMenu?this._parentMaterialMenu.closed:Rd(),this._parentMaterialMenu?this._parentMaterialMenu._hovered().pipe(np(t=>t!==this._menuItemInstance),np(()=>this._menuOpen)):Rd(),e)}_handleMousedown(t){uy(t)||(this._openedBy=0===t.button?"mouse":void 0,this.triggersSubmenu()&&t.preventDefault())}_handleKeydown(t){const e=t.keyCode;13!==e&&32!==e||(this._openedBy="keyboard"),this.triggersSubmenu()&&(39===e&&"ltr"===this.dir||37===e&&"rtl"===this.dir)&&(this._openedBy="keyboard",this.openMenu())}_handleClick(t){this.triggersSubmenu()?(t.stopPropagation(),this.openMenu()):this.toggleMenu()}_handleHover(){this.triggersSubmenu()&&this._parentMaterialMenu&&(this._hoverSubscription=this._parentMaterialMenu._hovered().pipe(np(t=>t===this._menuItemInstance&&!t.disabled),nw(0,Kx)).subscribe(()=>{this._openedBy="mouse",this.menu instanceof T_&&this.menu._isAnimating?this.menu._animationDone.pipe(Xd(1),nw(0,Kx),Jx(this._parentMaterialMenu._hovered())).subscribe(()=>this.openMenu()):this.openMenu()}))}_getPortal(){return this._portal&&this._portal.templateRef===this.menu.templateRef||(this._portal=new lw(this.menu.templateRef,this._viewContainerRef)),this._portal}}return t.\u0275fac=function(e){return new(e||t)(pa(f_),pa(Cl),pa(hc),pa(k_),pa(w_,8),pa(E_,10),pa(_y,8),pa(fy))},t.\u0275dir=ke({type:t,selectors:[["","mat-menu-trigger-for",""],["","matMenuTriggerFor",""]],hostAttrs:["aria-haspopup","true",1,"mat-menu-trigger"],hostVars:2,hostBindings:function(t,e){1&t&&Ea("mousedown",function(t){return e._handleMousedown(t)})("keydown",function(t){return e._handleKeydown(t)})("click",function(t){return e._handleClick(t)}),2&t&&ua("aria-expanded",e.menuOpen||null)("aria-controls",e.menuOpen?e.menu.panelId:null)},inputs:{restoreFocus:["matMenuTriggerRestoreFocus","restoreFocus"],_deprecatedMatMenuTriggerFor:["mat-menu-trigger-for","_deprecatedMatMenuTriggerFor"],menu:["matMenuTriggerFor","menu"],menuData:["matMenuTriggerData","menuData"]},outputs:{menuOpened:"menuOpened",onMenuOpen:"onMenuOpen",menuClosed:"menuClosed",onMenuClose:"onMenuClose"},exportAs:["matMenuTrigger"]}),t})(),D_=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({providers:[R_],imports:[fA]}),t})(),B_=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({providers:[R_],imports:[[jh,fA,MA,g_,D_],Fw,fA,D_]}),t})();function O_(t){return e=>e.lift(new P_(t))}class P_{constructor(t){this.value=t}call(t,e){return e.subscribe(new F_(t,this.value))}}class F_ extends W{constructor(t,e){super(t),this.value=e}_next(t){this.destination.next(this.value)}}const $_=["*"];function z_(t,e){if(1&t){const t=xa();ga(0,"div",2),Ea("click",function(){return yn(t),ka()._onBackdropClicked()}),ya()}2&t&&Ua("mat-drawer-shown",ka()._isShowingBackdrop())}function U_(t,e){1&t&&(ga(0,"mat-drawer-content"),La(1,2),ya())}const H_=[[["mat-drawer"]],[["mat-drawer-content"]],"*"],V_=["mat-drawer","mat-drawer-content","*"],G_={transformDrawer:Ty("transform",[Ny("open, open-instant",Ry({transform:"none",visibility:"visible"})),Ny("void",Ry({"box-shadow":"none",visibility:"hidden"})),Dy("void => open-instant",My("0ms")),Dy("void <=> open, open-instant => void",My("400ms cubic-bezier(0.25, 0.8, 0.25, 1)"))])},W_=new Ri("MAT_DRAWER_DEFAULT_AUTOSIZE",{providedIn:"root",factory:function(){return!1}}),j_=new Ri("MAT_DRAWER_CONTAINER");let Q_=(()=>{class t extends Ow{constructor(t,e,n,i,r){super(n,i,r),this._changeDetectorRef=t,this._container=e}ngAfterContentInit(){this._container._contentMarginChanges.subscribe(()=>{this._changeDetectorRef.markForCheck()})}}return t.\u0275fac=function(e){return new(e||t)(pa(Jl),pa(Ft(()=>X_)),pa(Cl),pa(Bw),pa(Au))},t.\u0275cmp=Se({type:t,selectors:[["mat-drawer-content"]],hostAttrs:[1,"mat-drawer-content"],hostVars:4,hostBindings:function(t,e){2&t&&za("margin-left",e._container._contentMargins.left,"px")("margin-right",e._container._contentMargins.right,"px")},features:[Ko],ngContentSelectors:$_,decls:1,vars:0,template:function(t,e){1&t&&(Na(),La(0))},encapsulation:2,changeDetection:0}),t})(),q_=(()=>{class t{constructor(t,e,n,i,r,s,o){this._elementRef=t,this._focusTrapFactory=e,this._focusMonitor=n,this._platform=i,this._ngZone=r,this._doc=s,this._container=o,this._elementFocusedBeforeDrawerWasOpened=null,this._enableAnimations=!1,this._position="start",this._mode="over",this._disableClose=!1,this._opened=!1,this._animationStarted=new tt,this._animationEnd=new tt,this._animationState="void",this.openedChange=new Nc(!0),this._openedStream=this.openedChange.pipe(np(t=>t),it(()=>{})),this.openedStart=this._animationStarted.pipe(np(t=>t.fromState!==t.toState&&0===t.toState.indexOf("open")),O_(void 0)),this._closedStream=this.openedChange.pipe(np(t=>!t),it(()=>{})),this.closedStart=this._animationStarted.pipe(np(t=>t.fromState!==t.toState&&"void"===t.toState),O_(void 0)),this._destroyed=new tt,this.onPositionChanged=new Nc,this._modeChanged=new tt,this.openedChange.subscribe(t=>{t?(this._doc&&(this._elementFocusedBeforeDrawerWasOpened=this._doc.activeElement),this._takeFocus()):this._isFocusWithinDrawer()&&this._restoreFocus()}),this._ngZone.runOutsideAngular(()=>{mw(this._elementRef.nativeElement,"keydown").pipe(np(t=>27===t.keyCode&&!this.disableClose&&!Ag(t)),Jx(this._destroyed)).subscribe(t=>this._ngZone.run(()=>{this.close(),t.stopPropagation(),t.preventDefault()}))}),this._animationEnd.pipe(yw((t,e)=>t.fromState===e.fromState&&t.toState===e.toState)).subscribe(t=>{const{fromState:e,toState:n}=t;(0===n.indexOf("open")&&"void"===e||"void"===n&&0===e.indexOf("open"))&&this.openedChange.emit(this._opened)})}get position(){return this._position}set position(t){(t="end"===t?"end":"start")!=this._position&&(this._position=t,this.onPositionChanged.emit())}get mode(){return this._mode}set mode(t){this._mode=t,this._updateFocusTrapState(),this._modeChanged.next()}get disableClose(){return this._disableClose}set disableClose(t){this._disableClose=kg(t)}get autoFocus(){const t=this._autoFocus;return null==t?"side"!==this.mode:t}set autoFocus(t){this._autoFocus=kg(t)}get opened(){return this._opened}set opened(t){this.toggle(kg(t))}_takeFocus(){this.autoFocus&&this._focusTrap&&this._focusTrap.focusInitialElementWhenReady().then(t=>{t||"function"!=typeof this._elementRef.nativeElement.focus||this._elementRef.nativeElement.focus()})}_restoreFocus(){this.autoFocus&&(this._elementFocusedBeforeDrawerWasOpened?this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened,this._openedVia):this._elementRef.nativeElement.blur(),this._elementFocusedBeforeDrawerWasOpened=null,this._openedVia=null)}_isFocusWithinDrawer(){var t;const e=null===(t=this._doc)||void 0===t?void 0:t.activeElement;return!!e&&this._elementRef.nativeElement.contains(e)}ngAfterContentInit(){this._focusTrap=this._focusTrapFactory.create(this._elementRef.nativeElement),this._updateFocusTrapState()}ngAfterContentChecked(){this._platform.isBrowser&&(this._enableAnimations=!0)}ngOnDestroy(){this._focusTrap&&this._focusTrap.destroy(),this._animationStarted.complete(),this._animationEnd.complete(),this._modeChanged.complete(),this._destroyed.next(),this._destroyed.complete()}open(t){return this.toggle(!0,t)}close(){return this.toggle(!1)}_closeViaBackdropClick(){return this._setOpen(!1,!0)}toggle(t=!this.opened,e){return this._setOpen(t,!t&&this._isFocusWithinDrawer(),e)}_setOpen(t,e,n="program"){return this._opened=t,t?(this._animationState=this._enableAnimations?"open":"open-instant",this._openedVia=n):(this._animationState="void",e&&this._restoreFocus()),this._updateFocusTrapState(),new Promise(t=>{this.openedChange.pipe(Xd(1)).subscribe(e=>t(e?"open":"close"))})}_getWidth(){return this._elementRef.nativeElement&&this._elementRef.nativeElement.offsetWidth||0}_updateFocusTrapState(){this._focusTrap&&(this._focusTrap.enabled=this.opened&&"side"!==this.mode)}_animationStartListener(t){this._animationStarted.next(t)}_animationDoneListener(t){this._animationEnd.next(t)}}return t.\u0275fac=function(e){return new(e||t)(pa(Cl),pa(cy),pa(fy),pa(zg),pa(Au),pa(Zu,8),pa(j_,8))},t.\u0275cmp=Se({type:t,selectors:[["mat-drawer"]],hostAttrs:["tabIndex","-1",1,"mat-drawer"],hostVars:12,hostBindings:function(t,e){1&t&&Ca("@transform.start",function(t){return e._animationStartListener(t)})("@transform.done",function(t){return e._animationDoneListener(t)}),2&t&&(ua("align",null),nl("@transform",e._animationState),Ua("mat-drawer-end","end"===e.position)("mat-drawer-over","over"===e.mode)("mat-drawer-push","push"===e.mode)("mat-drawer-side","side"===e.mode)("mat-drawer-opened",e.opened))},inputs:{position:"position",mode:"mode",disableClose:"disableClose",autoFocus:"autoFocus",opened:"opened"},outputs:{openedChange:"openedChange",_openedStream:"opened",openedStart:"openedStart",_closedStream:"closed",closedStart:"closedStart",onPositionChanged:"positionChanged"},exportAs:["matDrawer"],ngContentSelectors:$_,decls:2,vars:0,consts:[["cdkScrollable","",1,"mat-drawer-inner-container"]],template:function(t,e){1&t&&(Na(),ga(0,"div",0),La(1),ya())},directives:[Ow],encapsulation:2,data:{animation:[G_.transformDrawer]},changeDetection:0}),t})(),X_=(()=>{class t{constructor(t,e,n,i,r,s=!1,o){this._dir=t,this._element=e,this._ngZone=n,this._changeDetectorRef=i,this._animationMode=o,this._drawers=new Dc,this.backdropClick=new Nc,this._destroyed=new tt,this._doCheckSubject=new tt,this._contentMargins={left:null,right:null},this._contentMarginChanges=new tt,t&&t.change.pipe(Jx(this._destroyed)).subscribe(()=>{this._validateDrawers(),this.updateContentMargins()}),r.change().pipe(Jx(this._destroyed)).subscribe(()=>this.updateContentMargins()),this._autosize=s}get start(){return this._start}get end(){return this._end}get autosize(){return this._autosize}set autosize(t){this._autosize=kg(t)}get hasBackdrop(){return null==this._backdropOverride?!this._start||"side"!==this._start.mode||!this._end||"side"!==this._end.mode:this._backdropOverride}set hasBackdrop(t){this._backdropOverride=null==t?null:kg(t)}get scrollable(){return this._userContent||this._content}ngAfterContentInit(){this._allDrawers.changes.pipe(Jd(this._allDrawers),Jx(this._destroyed)).subscribe(t=>{this._drawers.reset(t.filter(t=>!t._container||t._container===this)),this._drawers.notifyOnChanges()}),this._drawers.changes.pipe(Jd(null)).subscribe(()=>{this._validateDrawers(),this._drawers.forEach(t=>{this._watchDrawerToggle(t),this._watchDrawerPosition(t),this._watchDrawerMode(t)}),(!this._drawers.length||this._isDrawerOpen(this._start)||this._isDrawerOpen(this._end))&&this.updateContentMargins(),this._changeDetectorRef.markForCheck()}),this._ngZone.runOutsideAngular(()=>{this._doCheckSubject.pipe(Cg(10),Jx(this._destroyed)).subscribe(()=>this.updateContentMargins())})}ngOnDestroy(){this._contentMarginChanges.complete(),this._doCheckSubject.complete(),this._drawers.destroy(),this._destroyed.next(),this._destroyed.complete()}open(){this._drawers.forEach(t=>t.open())}close(){this._drawers.forEach(t=>t.close())}updateContentMargins(){let t=0,e=0;if(this._left&&this._left.opened)if("side"==this._left.mode)t+=this._left._getWidth();else if("push"==this._left.mode){const n=this._left._getWidth();t+=n,e-=n}if(this._right&&this._right.opened)if("side"==this._right.mode)e+=this._right._getWidth();else if("push"==this._right.mode){const n=this._right._getWidth();e+=n,t-=n}t=t||null,e=e||null,t===this._contentMargins.left&&e===this._contentMargins.right||(this._contentMargins={left:t,right:e},this._ngZone.run(()=>this._contentMarginChanges.next(this._contentMargins)))}ngDoCheck(){this._autosize&&this._isPushed()&&this._ngZone.runOutsideAngular(()=>this._doCheckSubject.next())}_watchDrawerToggle(t){t._animationStarted.pipe(np(t=>t.fromState!==t.toState),Jx(this._drawers.changes)).subscribe(t=>{"open-instant"!==t.toState&&"NoopAnimations"!==this._animationMode&&this._element.nativeElement.classList.add("mat-drawer-transition"),this.updateContentMargins(),this._changeDetectorRef.markForCheck()}),"side"!==t.mode&&t.openedChange.pipe(Jx(this._drawers.changes)).subscribe(()=>this._setContainerClass(t.opened))}_watchDrawerPosition(t){t&&t.onPositionChanged.pipe(Jx(this._drawers.changes)).subscribe(()=>{this._ngZone.onMicrotaskEmpty.pipe(Xd(1)).subscribe(()=>{this._validateDrawers()})})}_watchDrawerMode(t){t&&t._modeChanged.pipe(Jx(wt(this._drawers.changes,this._destroyed))).subscribe(()=>{this.updateContentMargins(),this._changeDetectorRef.markForCheck()})}_setContainerClass(t){const e=this._element.nativeElement.classList,n="mat-drawer-container-has-open";t?e.add(n):e.remove(n)}_validateDrawers(){this._start=this._end=null,this._drawers.forEach(t=>{"end"==t.position?this._end=t:this._start=t}),this._right=this._left=null,this._dir&&"rtl"===this._dir.value?(this._left=this._end,this._right=this._start):(this._left=this._start,this._right=this._end)}_isPushed(){return this._isDrawerOpen(this._start)&&"over"!=this._start.mode||this._isDrawerOpen(this._end)&&"over"!=this._end.mode}_onBackdropClicked(){this.backdropClick.emit(),this._closeModalDrawersViaBackdrop()}_closeModalDrawersViaBackdrop(){[this._start,this._end].filter(t=>t&&!t.disableClose&&this._canHaveBackdrop(t)).forEach(t=>t._closeViaBackdropClick())}_isShowingBackdrop(){return this._isDrawerOpen(this._start)&&this._canHaveBackdrop(this._start)||this._isDrawerOpen(this._end)&&this._canHaveBackdrop(this._end)}_canHaveBackdrop(t){return"side"!==t.mode||!!this._backdropOverride}_isDrawerOpen(t){return null!=t&&t.opened}}return t.\u0275fac=function(e){return new(e||t)(pa(_y,8),pa(Cl),pa(Au),pa(Jl),pa(Pw),pa(W_),pa(lA,8))},t.\u0275cmp=Se({type:t,selectors:[["mat-drawer-container"]],contentQueries:function(t,e,n){if(1&t&&(jc(n,Q_,1),jc(n,q_,1)),2&t){let t;Gc(t=Qc())&&(e._content=t.first),Gc(t=Qc())&&(e._allDrawers=t)}},viewQuery:function(t,e){if(1&t&&Wc(Q_,1),2&t){let t;Gc(t=Qc())&&(e._userContent=t.first)}},hostAttrs:[1,"mat-drawer-container"],hostVars:2,hostBindings:function(t,e){2&t&&Ua("mat-drawer-container-explicit-backdrop",e._backdropOverride)},inputs:{autosize:"autosize",hasBackdrop:"hasBackdrop"},outputs:{backdropClick:"backdropClick"},exportAs:["matDrawerContainer"],features:[bl([{provide:j_,useExisting:t}])],ngContentSelectors:V_,decls:4,vars:2,consts:[["class","mat-drawer-backdrop",3,"mat-drawer-shown","click",4,"ngIf"],[4,"ngIf"],[1,"mat-drawer-backdrop",3,"click"]],template:function(t,e){1&t&&(Na(H_),ha(0,z_,1,2,"div",0),La(1),La(2,1),ha(3,U_,2,0,"mat-drawer-content",1)),2&t&&(fa("ngIf",e.hasBackdrop),Bs(3),fa("ngIf",!e._content))},directives:[Nh,Q_],styles:[".mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}.cdk-high-contrast-active .mat-drawer-backdrop{opacity:.5}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}.cdk-high-contrast-active .mat-drawer,.cdk-high-contrast-active [dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}.cdk-high-contrast-active [dir=rtl] .mat-drawer,.cdk-high-contrast-active .mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer{transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}\n"],encapsulation:2,changeDetection:0}),t})(),Y_=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[[jh,fA,Ug,Fw],Fw,fA]}),t})();const K_=new Ri("NgValueAccessor"),J_={provide:K_,useExisting:Ft(()=>tS),multi:!0},Z_=new Ri("CompositionEventMode");let tS=(()=>{class t{constructor(t,e,n){this._renderer=t,this._elementRef=e,this._compositionMode=n,this.onChange=t=>{},this.onTouched=()=>{},this._composing=!1,null==this._compositionMode&&(this._compositionMode=!function(){const t=Ju()?Ju().getUserAgent():"";return/android (\d+)/.test(t.toLowerCase())}())}writeValue(t){this._renderer.setProperty(this._elementRef.nativeElement,"value",null==t?"":t)}registerOnChange(t){this.onChange=t}registerOnTouched(t){this.onTouched=t}setDisabledState(t){this._renderer.setProperty(this._elementRef.nativeElement,"disabled",t)}_handleInput(t){(!this._compositionMode||this._compositionMode&&!this._composing)&&this.onChange(t)}_compositionStart(){this._composing=!0}_compositionEnd(t){this._composing=!1,this._compositionMode&&this.onChange(t)}}return t.\u0275fac=function(e){return new(e||t)(pa(Ml),pa(Cl),pa(Z_,8))},t.\u0275dir=ke({type:t,selectors:[["input","formControlName","",3,"type","checkbox"],["textarea","formControlName",""],["input","formControl","",3,"type","checkbox"],["textarea","formControl",""],["input","ngModel","",3,"type","checkbox"],["textarea","ngModel",""],["","ngDefaultControl",""]],hostBindings:function(t,e){1&t&&Ea("input",function(t){return e._handleInput(t.target.value)})("blur",function(){return e.onTouched()})("compositionstart",function(){return e._compositionStart()})("compositionend",function(t){return e._compositionEnd(t.target.value)})},features:[bl([J_])]}),t})();const eS=new Ri("NgValidators"),nS=new Ri("NgAsyncValidators");function iS(t){return null!=t}function rS(t){const e=wa(t)?pt(t):t;return Sa(e),e}function sS(t){let e={};return t.forEach(t=>{e=null!=t?Object.assign(Object.assign({},e),t):e}),0===Object.keys(e).length?null:e}function oS(t,e){return e.map(e=>e(t))}function aS(t){return t.map(t=>function(t){return!t.validate}(t)?t:e=>t.validate(e))}function lS(t){return null!=t?function(t){if(!t)return null;const e=t.filter(iS);return 0==e.length?null:function(t){return sS(oS(t,e))}}(aS(t)):null}function cS(t){return null!=t?function(t){if(!t)return null;const e=t.filter(iS);return 0==e.length?null:function(t){return qA(oS(t,e).map(rS)).pipe(it(sS))}}(aS(t)):null}function uS(t,e){return null===t?[e]:Array.isArray(t)?[...t,e]:[t,e]}function hS(t){return t._rawValidators}function dS(t){return t._rawAsyncValidators}let pS=(()=>{class t{constructor(){this._rawValidators=[],this._rawAsyncValidators=[],this._onDestroyCallbacks=[]}get value(){return this.control?this.control.value:null}get valid(){return this.control?this.control.valid:null}get invalid(){return this.control?this.control.invalid:null}get pending(){return this.control?this.control.pending:null}get disabled(){return this.control?this.control.disabled:null}get enabled(){return this.control?this.control.enabled:null}get errors(){return this.control?this.control.errors:null}get pristine(){return this.control?this.control.pristine:null}get dirty(){return this.control?this.control.dirty:null}get touched(){return this.control?this.control.touched:null}get status(){return this.control?this.control.status:null}get untouched(){return this.control?this.control.untouched:null}get statusChanges(){return this.control?this.control.statusChanges:null}get valueChanges(){return this.control?this.control.valueChanges:null}get path(){return null}_setValidators(t){this._rawValidators=t||[],this._composedValidatorFn=lS(this._rawValidators)}_setAsyncValidators(t){this._rawAsyncValidators=t||[],this._composedAsyncValidatorFn=cS(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn||null}get asyncValidator(){return this._composedAsyncValidatorFn||null}_registerOnDestroy(t){this._onDestroyCallbacks.push(t)}_invokeOnDestroyCallbacks(){this._onDestroyCallbacks.forEach(t=>t()),this._onDestroyCallbacks=[]}reset(t){this.control&&this.control.reset(t)}hasError(t,e){return!!this.control&&this.control.hasError(t,e)}getError(t,e){return this.control?this.control.getError(t,e):null}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=ke({type:t}),t})(),fS=(()=>{class t extends pS{get formDirective(){return null}get path(){return null}}return t.\u0275fac=function(e){return mS(e||t)},t.\u0275dir=ke({type:t,features:[Ko]}),t})();const mS=Ci(fS);class gS extends pS{constructor(){super(...arguments),this._parent=null,this.name=null,this.valueAccessor=null}}let yS=(()=>{class t extends class{constructor(t){this._cd=t}is(t){var e,n;return!!(null===(n=null===(e=this._cd)||void 0===e?void 0:e.control)||void 0===n?void 0:n[t])}}{constructor(t){super(t)}}return t.\u0275fac=function(e){return new(e||t)(pa(gS,2))},t.\u0275dir=ke({type:t,selectors:[["","formControlName",""],["","ngModel",""],["","formControl",""]],hostVars:14,hostBindings:function(t,e){2&t&&Ua("ng-untouched",e.is("untouched"))("ng-touched",e.is("touched"))("ng-pristine",e.is("pristine"))("ng-dirty",e.is("dirty"))("ng-valid",e.is("valid"))("ng-invalid",e.is("invalid"))("ng-pending",e.is("pending"))},features:[Ko]}),t})();function vS(t,e){(function(t,e,n){const i=hS(t);null!==e.validator?t.setValidators(uS(i,e.validator)):"function"==typeof i&&t.setValidators([i]);const r=dS(t);null!==e.asyncValidator?t.setAsyncValidators(uS(r,e.asyncValidator)):"function"==typeof r&&t.setAsyncValidators([r]);{const n=()=>t.updateValueAndValidity();AS(e._rawValidators,n),AS(e._rawAsyncValidators,n)}})(t,e),e.valueAccessor.writeValue(t.value),function(t,e){e.valueAccessor.registerOnChange(n=>{t._pendingValue=n,t._pendingChange=!0,t._pendingDirty=!0,"change"===t.updateOn&&xS(t,e)})}(t,e),function(t,e){const n=(t,n)=>{e.valueAccessor.writeValue(t),n&&e.viewToModelUpdate(t)};t.registerOnChange(n),e._registerOnDestroy(()=>{t._unregisterOnChange(n)})}(t,e),function(t,e){e.valueAccessor.registerOnTouched(()=>{t._pendingTouched=!0,"blur"===t.updateOn&&t._pendingChange&&xS(t,e),"submit"!==t.updateOn&&t.markAsTouched()})}(t,e),function(t,e){if(e.valueAccessor.setDisabledState){const n=t=>{e.valueAccessor.setDisabledState(t)};t.registerOnDisabledChange(n),e._registerOnDestroy(()=>{t._unregisterOnDisabledChange(n)})}}(t,e)}function bS(t,e,n=!0){const i=()=>{};e.valueAccessor&&(e.valueAccessor.registerOnChange(i),e.valueAccessor.registerOnTouched(i)),function(t,e,n){let i=!1;if(null!==t){if(null!==e.validator){const n=hS(t);if(Array.isArray(n)&&n.length>0){const r=n.filter(t=>t!==e.validator);r.length!==n.length&&(i=!0,t.setValidators(r))}}if(null!==e.asyncValidator){const n=dS(t);if(Array.isArray(n)&&n.length>0){const r=n.filter(t=>t!==e.asyncValidator);r.length!==n.length&&(i=!0,t.setAsyncValidators(r))}}}{const t=()=>{};AS(e._rawValidators,t),AS(e._rawAsyncValidators,t)}}(t,e),t&&(e._invokeOnDestroyCallbacks(),t._registerOnCollectionChange(()=>{}))}function AS(t,e){t.forEach(t=>{t.registerOnValidatorChange&&t.registerOnValidatorChange(e)})}function xS(t,e){t._pendingDirty&&t.markAsDirty(),t.setValue(t._pendingValue,{emitModelToViewChange:!1}),e.viewToModelUpdate(t._pendingValue),t._pendingChange=!1}function wS(t,e){if(!t.hasOwnProperty("model"))return!1;const n=t.model;return!!n.isFirstChange()||!Object.is(e,n.currentValue)}function _S(t,e){if(!e)return null;let n,i,r;return Array.isArray(e),e.forEach(t=>{t.constructor===tS?n=t:Object.getPrototypeOf(t.constructor)===class{}?i=t:r=t}),r||i||n||null}function SS(t,e){const n=t.indexOf(e);n>-1&&t.splice(n,1)}const ES="VALID",CS="INVALID",IS="PENDING",TS="DISABLED";function MS(t){return(LS(t)?t.validators:t)||null}function kS(t){return Array.isArray(t)?lS(t):t||null}function RS(t,e){return(LS(e)?e.asyncValidators:t)||null}function NS(t){return Array.isArray(t)?cS(t):t||null}function LS(t){return null!=t&&!Array.isArray(t)&&"object"==typeof t}class DS{constructor(t,e){this._hasOwnPendingAsyncValidator=!1,this._onCollectionChange=()=>{},this._parent=null,this.pristine=!0,this.touched=!1,this._onDisabledChange=[],this._rawValidators=t,this._rawAsyncValidators=e,this._composedValidatorFn=kS(this._rawValidators),this._composedAsyncValidatorFn=NS(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn}set validator(t){this._rawValidators=this._composedValidatorFn=t}get asyncValidator(){return this._composedAsyncValidatorFn}set asyncValidator(t){this._rawAsyncValidators=this._composedAsyncValidatorFn=t}get parent(){return this._parent}get valid(){return this.status===ES}get invalid(){return this.status===CS}get pending(){return this.status==IS}get disabled(){return this.status===TS}get enabled(){return this.status!==TS}get dirty(){return!this.pristine}get untouched(){return!this.touched}get updateOn(){return this._updateOn?this._updateOn:this.parent?this.parent.updateOn:"change"}setValidators(t){this._rawValidators=t,this._composedValidatorFn=kS(t)}setAsyncValidators(t){this._rawAsyncValidators=t,this._composedAsyncValidatorFn=NS(t)}clearValidators(){this.validator=null}clearAsyncValidators(){this.asyncValidator=null}markAsTouched(t={}){this.touched=!0,this._parent&&!t.onlySelf&&this._parent.markAsTouched(t)}markAllAsTouched(){this.markAsTouched({onlySelf:!0}),this._forEachChild(t=>t.markAllAsTouched())}markAsUntouched(t={}){this.touched=!1,this._pendingTouched=!1,this._forEachChild(t=>{t.markAsUntouched({onlySelf:!0})}),this._parent&&!t.onlySelf&&this._parent._updateTouched(t)}markAsDirty(t={}){this.pristine=!1,this._parent&&!t.onlySelf&&this._parent.markAsDirty(t)}markAsPristine(t={}){this.pristine=!0,this._pendingDirty=!1,this._forEachChild(t=>{t.markAsPristine({onlySelf:!0})}),this._parent&&!t.onlySelf&&this._parent._updatePristine(t)}markAsPending(t={}){this.status=IS,!1!==t.emitEvent&&this.statusChanges.emit(this.status),this._parent&&!t.onlySelf&&this._parent.markAsPending(t)}disable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status=TS,this.errors=null,this._forEachChild(e=>{e.disable(Object.assign(Object.assign({},t),{onlySelf:!0}))}),this._updateValue(),!1!==t.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._updateAncestors(Object.assign(Object.assign({},t),{skipPristineCheck:e})),this._onDisabledChange.forEach(t=>t(!0))}enable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status=ES,this._forEachChild(e=>{e.enable(Object.assign(Object.assign({},t),{onlySelf:!0}))}),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent}),this._updateAncestors(Object.assign(Object.assign({},t),{skipPristineCheck:e})),this._onDisabledChange.forEach(t=>t(!1))}_updateAncestors(t){this._parent&&!t.onlySelf&&(this._parent.updateValueAndValidity(t),t.skipPristineCheck||this._parent._updatePristine(),this._parent._updateTouched())}setParent(t){this._parent=t}updateValueAndValidity(t={}){this._setInitialStatus(),this._updateValue(),this.enabled&&(this._cancelExistingSubscription(),this.errors=this._runValidator(),this.status=this._calculateStatus(),this.status!==ES&&this.status!==IS||this._runAsyncValidator(t.emitEvent)),!1!==t.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._parent&&!t.onlySelf&&this._parent.updateValueAndValidity(t)}_updateTreeValidity(t={emitEvent:!0}){this._forEachChild(e=>e._updateTreeValidity(t)),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent})}_setInitialStatus(){this.status=this._allControlsDisabled()?TS:ES}_runValidator(){return this.validator?this.validator(this):null}_runAsyncValidator(t){if(this.asyncValidator){this.status=IS,this._hasOwnPendingAsyncValidator=!0;const e=rS(this.asyncValidator(this));this._asyncValidationSubscription=e.subscribe(e=>{this._hasOwnPendingAsyncValidator=!1,this.setErrors(e,{emitEvent:t})})}}_cancelExistingSubscription(){this._asyncValidationSubscription&&(this._asyncValidationSubscription.unsubscribe(),this._hasOwnPendingAsyncValidator=!1)}setErrors(t,e={}){this.errors=t,this._updateControlsErrors(!1!==e.emitEvent)}get(t){return function(t,e,n){if(null==e)return null;if(Array.isArray(e)||(e=e.split(".")),Array.isArray(e)&&0===e.length)return null;let i=t;return e.forEach(t=>{i=i instanceof OS?i.controls.hasOwnProperty(t)?i.controls[t]:null:i instanceof PS&&i.at(t)||null}),i}(this,t)}getError(t,e){const n=e?this.get(e):this;return n&&n.errors?n.errors[t]:null}hasError(t,e){return!!this.getError(t,e)}get root(){let t=this;for(;t._parent;)t=t._parent;return t}_updateControlsErrors(t){this.status=this._calculateStatus(),t&&this.statusChanges.emit(this.status),this._parent&&this._parent._updateControlsErrors(t)}_initObservables(){this.valueChanges=new Nc,this.statusChanges=new Nc}_calculateStatus(){return this._allControlsDisabled()?TS:this.errors?CS:this._hasOwnPendingAsyncValidator||this._anyControlsHaveStatus(IS)?IS:this._anyControlsHaveStatus(CS)?CS:ES}_anyControlsHaveStatus(t){return this._anyControls(e=>e.status===t)}_anyControlsDirty(){return this._anyControls(t=>t.dirty)}_anyControlsTouched(){return this._anyControls(t=>t.touched)}_updatePristine(t={}){this.pristine=!this._anyControlsDirty(),this._parent&&!t.onlySelf&&this._parent._updatePristine(t)}_updateTouched(t={}){this.touched=this._anyControlsTouched(),this._parent&&!t.onlySelf&&this._parent._updateTouched(t)}_isBoxedValue(t){return"object"==typeof t&&null!==t&&2===Object.keys(t).length&&"value"in t&&"disabled"in t}_registerOnCollectionChange(t){this._onCollectionChange=t}_setUpdateStrategy(t){LS(t)&&null!=t.updateOn&&(this._updateOn=t.updateOn)}_parentMarkedDirty(t){return!t&&!(!this._parent||!this._parent.dirty)&&!this._parent._anyControlsDirty()}}class BS extends DS{constructor(t=null,e,n){super(MS(e),RS(n,e)),this._onChange=[],this._applyFormState(t),this._setUpdateStrategy(e),this._initObservables(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!n})}setValue(t,e={}){this.value=this._pendingValue=t,this._onChange.length&&!1!==e.emitModelToViewChange&&this._onChange.forEach(t=>t(this.value,!1!==e.emitViewToModelChange)),this.updateValueAndValidity(e)}patchValue(t,e={}){this.setValue(t,e)}reset(t=null,e={}){this._applyFormState(t),this.markAsPristine(e),this.markAsUntouched(e),this.setValue(this.value,e),this._pendingChange=!1}_updateValue(){}_anyControls(t){return!1}_allControlsDisabled(){return this.disabled}registerOnChange(t){this._onChange.push(t)}_unregisterOnChange(t){SS(this._onChange,t)}registerOnDisabledChange(t){this._onDisabledChange.push(t)}_unregisterOnDisabledChange(t){SS(this._onDisabledChange,t)}_forEachChild(t){}_syncPendingControls(){return!("submit"!==this.updateOn||(this._pendingDirty&&this.markAsDirty(),this._pendingTouched&&this.markAsTouched(),!this._pendingChange)||(this.setValue(this._pendingValue,{onlySelf:!0,emitModelToViewChange:!1}),0))}_applyFormState(t){this._isBoxedValue(t)?(this.value=this._pendingValue=t.value,t.disabled?this.disable({onlySelf:!0,emitEvent:!1}):this.enable({onlySelf:!0,emitEvent:!1})):this.value=this._pendingValue=t}}class OS extends DS{constructor(t,e,n){super(MS(e),RS(n,e)),this.controls=t,this._initObservables(),this._setUpdateStrategy(e),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!n})}registerControl(t,e){return this.controls[t]?this.controls[t]:(this.controls[t]=e,e.setParent(this),e._registerOnCollectionChange(this._onCollectionChange),e)}addControl(t,e){this.registerControl(t,e),this.updateValueAndValidity(),this._onCollectionChange()}removeControl(t){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),delete this.controls[t],this.updateValueAndValidity(),this._onCollectionChange()}setControl(t,e){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),delete this.controls[t],e&&this.registerControl(t,e),this.updateValueAndValidity(),this._onCollectionChange()}contains(t){return this.controls.hasOwnProperty(t)&&this.controls[t].enabled}setValue(t,e={}){this._checkAllValuesPresent(t),Object.keys(t).forEach(n=>{this._throwIfControlMissing(n),this.controls[n].setValue(t[n],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e)}patchValue(t,e={}){null!=t&&(Object.keys(t).forEach(n=>{this.controls[n]&&this.controls[n].patchValue(t[n],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e))}reset(t={},e={}){this._forEachChild((n,i)=>{n.reset(t[i],{onlySelf:!0,emitEvent:e.emitEvent})}),this._updatePristine(e),this._updateTouched(e),this.updateValueAndValidity(e)}getRawValue(){return this._reduceChildren({},(t,e,n)=>(t[n]=e instanceof BS?e.value:e.getRawValue(),t))}_syncPendingControls(){let t=this._reduceChildren(!1,(t,e)=>!!e._syncPendingControls()||t);return t&&this.updateValueAndValidity({onlySelf:!0}),t}_throwIfControlMissing(t){if(!Object.keys(this.controls).length)throw new Error("\n        There are no form controls registered with this group yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");if(!this.controls[t])throw new Error(`Cannot find form control with name: ${t}.`)}_forEachChild(t){Object.keys(this.controls).forEach(e=>{const n=this.controls[e];n&&t(n,e)})}_setUpControls(){this._forEachChild(t=>{t.setParent(this),t._registerOnCollectionChange(this._onCollectionChange)})}_updateValue(){this.value=this._reduceValue()}_anyControls(t){for(const e of Object.keys(this.controls)){const n=this.controls[e];if(this.contains(e)&&t(n))return!0}return!1}_reduceValue(){return this._reduceChildren({},(t,e,n)=>((e.enabled||this.disabled)&&(t[n]=e.value),t))}_reduceChildren(t,e){let n=t;return this._forEachChild((t,i)=>{n=e(n,t,i)}),n}_allControlsDisabled(){for(const t of Object.keys(this.controls))if(this.controls[t].enabled)return!1;return Object.keys(this.controls).length>0||this.disabled}_checkAllValuesPresent(t){this._forEachChild((e,n)=>{if(void 0===t[n])throw new Error(`Must supply a value for form control with name: '${n}'.`)})}}class PS extends DS{constructor(t,e,n){super(MS(e),RS(n,e)),this.controls=t,this._initObservables(),this._setUpdateStrategy(e),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!n})}at(t){return this.controls[t]}push(t){this.controls.push(t),this._registerControl(t),this.updateValueAndValidity(),this._onCollectionChange()}insert(t,e){this.controls.splice(t,0,e),this._registerControl(e),this.updateValueAndValidity()}removeAt(t){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),this.controls.splice(t,1),this.updateValueAndValidity()}setControl(t,e){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),this.controls.splice(t,1),e&&(this.controls.splice(t,0,e),this._registerControl(e)),this.updateValueAndValidity(),this._onCollectionChange()}get length(){return this.controls.length}setValue(t,e={}){this._checkAllValuesPresent(t),t.forEach((t,n)=>{this._throwIfControlMissing(n),this.at(n).setValue(t,{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e)}patchValue(t,e={}){null!=t&&(t.forEach((t,n)=>{this.at(n)&&this.at(n).patchValue(t,{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e))}reset(t=[],e={}){this._forEachChild((n,i)=>{n.reset(t[i],{onlySelf:!0,emitEvent:e.emitEvent})}),this._updatePristine(e),this._updateTouched(e),this.updateValueAndValidity(e)}getRawValue(){return this.controls.map(t=>t instanceof BS?t.value:t.getRawValue())}clear(){this.controls.length<1||(this._forEachChild(t=>t._registerOnCollectionChange(()=>{})),this.controls.splice(0),this.updateValueAndValidity())}_syncPendingControls(){let t=this.controls.reduce((t,e)=>!!e._syncPendingControls()||t,!1);return t&&this.updateValueAndValidity({onlySelf:!0}),t}_throwIfControlMissing(t){if(!this.controls.length)throw new Error("\n        There are no form controls registered with this array yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");if(!this.at(t))throw new Error(`Cannot find form control at index ${t}`)}_forEachChild(t){this.controls.forEach((e,n)=>{t(e,n)})}_updateValue(){this.value=this.controls.filter(t=>t.enabled||this.disabled).map(t=>t.value)}_anyControls(t){return this.controls.some(e=>e.enabled&&t(e))}_setUpControls(){this._forEachChild(t=>this._registerControl(t))}_checkAllValuesPresent(t){this._forEachChild((e,n)=>{if(void 0===t[n])throw new Error(`Must supply a value for form control at index: ${n}.`)})}_allControlsDisabled(){for(const t of this.controls)if(t.enabled)return!1;return this.controls.length>0||this.disabled}_registerControl(t){t.setParent(this),t._registerOnCollectionChange(this._onCollectionChange)}}const FS={provide:gS,useExisting:Ft(()=>zS)},$S=(()=>Promise.resolve(null))();let zS=(()=>{class t extends gS{constructor(t,e,n,i){super(),this.control=new BS,this._registered=!1,this.update=new Nc,this._parent=t,this._setValidators(e),this._setAsyncValidators(n),this.valueAccessor=_S(0,i)}ngOnChanges(t){this._checkForErrors(),this._registered||this._setUpControl(),"isDisabled"in t&&this._updateDisabled(t),wS(t,this.viewModel)&&(this._updateValue(this.model),this.viewModel=this.model)}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}get path(){return this._parent?[...this._parent.path,this.name]:[this.name]}get formDirective(){return this._parent?this._parent.formDirective:null}viewToModelUpdate(t){this.viewModel=t,this.update.emit(t)}_setUpControl(){this._setUpdateStrategy(),this._isStandalone()?this._setUpStandalone():this.formDirective.addControl(this),this._registered=!0}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.control._updateOn=this.options.updateOn)}_isStandalone(){return!this._parent||!(!this.options||!this.options.standalone)}_setUpStandalone(){vS(this.control,this),this.control.updateValueAndValidity({emitEvent:!1})}_checkForErrors(){this._isStandalone()||this._checkParentType(),this._checkName()}_checkParentType(){}_checkName(){this.options&&this.options.name&&(this.name=this.options.name),this._isStandalone()}_updateValue(t){$S.then(()=>{this.control.setValue(t,{emitViewToModelChange:!1})})}_updateDisabled(t){const e=t.isDisabled.currentValue,n=""===e||e&&"false"!==e;$S.then(()=>{n&&!this.control.disabled?this.control.disable():!n&&this.control.disabled&&this.control.enable()})}}return t.\u0275fac=function(e){return new(e||t)(pa(fS,9),pa(eS,10),pa(nS,10),pa(K_,10))},t.\u0275dir=ke({type:t,selectors:[["","ngModel","",3,"formControlName","",3,"formControl",""]],inputs:{name:"name",isDisabled:["disabled","isDisabled"],model:["ngModel","model"],options:["ngModelOptions","options"]},outputs:{update:"ngModelChange"},exportAs:["ngModel"],features:[bl([FS]),Ko,Ge]}),t})(),US=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({}),t})();const HS=new Ri("NgModelWithFormControlWarning"),VS={provide:gS,useExisting:Ft(()=>GS)};let GS=(()=>{class t extends gS{constructor(t,e,n,i){super(),this._ngModelWarningConfig=i,this.update=new Nc,this._ngModelWarningSent=!1,this._setValidators(t),this._setAsyncValidators(e),this.valueAccessor=_S(0,n)}set isDisabled(t){}ngOnChanges(t){if(this._isControlChanged(t)){const e=t.form.previousValue;e&&bS(e,this,!1),vS(this.form,this),this.control.disabled&&this.valueAccessor.setDisabledState&&this.valueAccessor.setDisabledState(!0),this.form.updateValueAndValidity({emitEvent:!1})}wS(t,this.viewModel)&&(this.form.setValue(this.model),this.viewModel=this.model)}ngOnDestroy(){this.form&&bS(this.form,this,!1)}get path(){return[]}get control(){return this.form}viewToModelUpdate(t){this.viewModel=t,this.update.emit(t)}_isControlChanged(t){return t.hasOwnProperty("form")}}return t.\u0275fac=function(e){return new(e||t)(pa(eS,10),pa(nS,10),pa(K_,10),pa(HS,8))},t.\u0275dir=ke({type:t,selectors:[["","formControl",""]],inputs:{isDisabled:["disabled","isDisabled"],form:["formControl","form"],model:["ngModel","model"]},outputs:{update:"ngModelChange"},exportAs:["ngForm"],features:[bl([VS]),Ko,Ge]}),t._ngModelWarningSentOnce=!1,t})(),WS=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[[US]]}),t})(),jS=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[WS]}),t})(),QS=(()=>{class t{static withConfig(e){return{ngModule:t,providers:[{provide:HS,useValue:e.warnOnNgModelWithFormControl}]}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[WS]}),t})(),qS=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[[fA],fA]}),t})();const XS=["*"],YS=["text"];function KS(t,e){if(1&t&&va(0,"mat-pseudo-checkbox",5),2&t){const t=ka();fa("state",t.selected?"checked":"unchecked")("disabled",t.disabled)}}const JS=["*",[["","mat-list-avatar",""],["","mat-list-icon",""],["","matListAvatar",""],["","matListIcon",""]]],ZS=["*","[mat-list-avatar], [mat-list-icon], [matListAvatar], [matListIcon]"];let tE=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=ke({type:t,selectors:[["","mat-list-avatar",""],["","matListAvatar",""]],hostAttrs:[1,"mat-list-avatar"]}),t})(),eE=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=ke({type:t,selectors:[["","mat-list-icon",""],["","matListIcon",""]],hostAttrs:[1,"mat-list-icon"]}),t})();class nE{}const iE=yA(nE);class rE{}const sE=yA(rE),oE={provide:K_,useExisting:Ft(()=>cE),multi:!0};class aE{constructor(t,e,n){this.source=t,this.option=e,this.options=n}}let lE=(()=>{class t extends sE{constructor(t,e,n){super(),this._element=t,this._changeDetector=e,this.selectionList=n,this._selected=!1,this._disabled=!1,this._hasFocus=!1,this.checkboxPosition="after",this._inputsInitialized=!1}get color(){return this._color||this.selectionList.color}set color(t){this._color=t}get value(){return this._value}set value(t){this.selected&&!this.selectionList.compareWith(t,this.value)&&this._inputsInitialized&&(this.selected=!1),this._value=t}get disabled(){return this._disabled||this.selectionList&&this.selectionList.disabled}set disabled(t){const e=kg(t);e!==this._disabled&&(this._disabled=e,this._changeDetector.markForCheck())}get selected(){return this.selectionList.selectedOptions.isSelected(this)}set selected(t){const e=kg(t);e!==this._selected&&(this._setSelected(e),(e||this.selectionList.multiple)&&this.selectionList._reportValueChange())}ngOnInit(){const t=this.selectionList;t._value&&t._value.some(e=>t.compareWith(e,this._value))&&this._setSelected(!0);const e=this._selected;Promise.resolve().then(()=>{(this._selected||e)&&(this.selected=!0,this._changeDetector.markForCheck())}),this._inputsInitialized=!0}ngAfterContentInit(){!function(t,e,n="mat"){t.changes.pipe(Jd(t)).subscribe(({length:t})=>{bA(e,`${n}-2-line`,!1),bA(e,`${n}-3-line`,!1),bA(e,`${n}-multi-line`,!1),2===t||3===t?bA(e,`${n}-${t}-line`,!0):t>3&&bA(e,`${n}-multi-line`,!0)})}(this._lines,this._element)}ngOnDestroy(){this.selected&&Promise.resolve().then(()=>{this.selected=!1});const t=this._hasFocus,e=this.selectionList._removeOptionFromList(this);t&&e&&e.focus()}toggle(){this.selected=!this.selected}focus(){this._element.nativeElement.focus()}getLabel(){return this._text&&this._text.nativeElement.textContent||""}_isRippleDisabled(){return this.disabled||this.disableRipple||this.selectionList.disableRipple}_handleClick(){this.disabled||!this.selectionList.multiple&&this.selected||(this.toggle(),this.selectionList._emitChangeEvent([this]))}_handleFocus(){this.selectionList._setFocusedOption(this),this._hasFocus=!0}_handleBlur(){this.selectionList._onTouched(),this._hasFocus=!1}_getHostElement(){return this._element.nativeElement}_setSelected(t){return t!==this._selected&&(this._selected=t,t?this.selectionList.selectedOptions.select(this):this.selectionList.selectedOptions.deselect(this),this._changeDetector.markForCheck(),!0)}_markForCheck(){this._changeDetector.markForCheck()}}return t.\u0275fac=function(e){return new(e||t)(pa(Cl),pa(Jl),pa(Ft(()=>cE)))},t.\u0275cmp=Se({type:t,selectors:[["mat-list-option"]],contentQueries:function(t,e,n){if(1&t&&(jc(n,tE,1),jc(n,eE,1),jc(n,vA,1)),2&t){let t;Gc(t=Qc())&&(e._avatar=t.first),Gc(t=Qc())&&(e._icon=t.first),Gc(t=Qc())&&(e._lines=t)}},viewQuery:function(t,e){if(1&t&&Wc(YS,1),2&t){let t;Gc(t=Qc())&&(e._text=t.first)}},hostAttrs:["role","option",1,"mat-list-item","mat-list-option","mat-focus-indicator"],hostVars:15,hostBindings:function(t,e){1&t&&Ea("focus",function(){return e._handleFocus()})("blur",function(){return e._handleBlur()})("click",function(){return e._handleClick()}),2&t&&(ua("aria-selected",e.selected)("aria-disabled",e.disabled)("tabindex",-1),Ua("mat-list-item-disabled",e.disabled)("mat-list-item-with-avatar",e._avatar||e._icon)("mat-primary","primary"===e.color)("mat-accent","primary"!==e.color&&"warn"!==e.color)("mat-warn","warn"===e.color)("mat-list-single-selected-option",e.selected&&!e.selectionList.multiple))},inputs:{disableRipple:"disableRipple",checkboxPosition:"checkboxPosition",color:"color",value:"value",selected:"selected",disabled:"disabled"},exportAs:["matListOption"],features:[Ko],ngContentSelectors:ZS,decls:7,vars:5,consts:[[1,"mat-list-item-content"],["mat-ripple","",1,"mat-list-item-ripple",3,"matRippleTrigger","matRippleDisabled"],[3,"state","disabled",4,"ngIf"],[1,"mat-list-text"],["text",""],[3,"state","disabled"]],template:function(t,e){1&t&&(Na(JS),ga(0,"div",0),va(1,"div",1),ha(2,KS,1,2,"mat-pseudo-checkbox",2),ga(3,"div",3,4),La(5),ya(),La(6,1),ya()),2&t&&(Ua("mat-list-item-content-reverse","after"==e.checkboxPosition),Bs(1),fa("matRippleTrigger",e._getHostElement())("matRippleDisabled",e._isRippleDisabled()),Bs(1),fa("ngIf",e.selectionList.multiple))},directives:[TA,Nh,kA],encapsulation:2,changeDetection:0}),t})(),cE=(()=>{class t extends iE{constructor(t,e,n,i){super(),this._element=t,this._changeDetector=n,this._focusMonitor=i,this._multiple=!0,this._contentInitialized=!1,this.selectionChange=new Nc,this.tabIndex=0,this.color="accent",this.compareWith=(t,e)=>t===e,this._disabled=!1,this.selectedOptions=new Dw(this._multiple),this._tabIndex=-1,this._onChange=t=>{},this._destroyed=new tt,this._onTouched=()=>{}}get disabled(){return this._disabled}set disabled(t){this._disabled=kg(t),this._markOptionsForCheck()}get multiple(){return this._multiple}set multiple(t){const e=kg(t);e!==this._multiple&&(this._multiple=e,this.selectedOptions=new Dw(this._multiple,this.selectedOptions.selected))}ngAfterContentInit(){var t;this._contentInitialized=!0,this._keyManager=new ry(this.options).withWrap().withTypeAhead().withHomeAndEnd().skipPredicate(()=>!1).withAllowedModifierKeys(["shiftKey"]),this._value&&this._setOptionsFromValues(this._value),this._keyManager.tabOut.pipe(Jx(this._destroyed)).subscribe(()=>{this._allowFocusEscape()}),this.options.changes.pipe(Jd(null),Jx(this._destroyed)).subscribe(()=>{this._updateTabIndex()}),this.selectedOptions.changed.pipe(Jx(this._destroyed)).subscribe(t=>{if(t.added)for(let e of t.added)e.selected=!0;if(t.removed)for(let e of t.removed)e.selected=!1}),null===(t=this._focusMonitor)||void 0===t||t.monitor(this._element).pipe(Jx(this._destroyed)).subscribe(t=>{if("keyboard"===t||"program"===t){const t=this._keyManager.activeItemIndex;t&&-1!==t?this._keyManager.setActiveItem(t):this._keyManager.setFirstItemActive()}})}ngOnChanges(t){const e=t.disableRipple,n=t.color;(e&&!e.firstChange||n&&!n.firstChange)&&this._markOptionsForCheck()}ngOnDestroy(){var t;null===(t=this._focusMonitor)||void 0===t||t.stopMonitoring(this._element),this._destroyed.next(),this._destroyed.complete(),this._isDestroyed=!0}focus(t){this._element.nativeElement.focus(t)}selectAll(){this._setAllOptionsSelected(!0)}deselectAll(){this._setAllOptionsSelected(!1)}_setFocusedOption(t){this._keyManager.updateActiveItem(t)}_removeOptionFromList(t){const e=this._getOptionIndex(t);return e>-1&&this._keyManager.activeItemIndex===e&&(e>0?this._keyManager.updateActiveItem(e-1):0===e&&this.options.length>1&&this._keyManager.updateActiveItem(Math.min(e+1,this.options.length-1))),this._keyManager.activeItem}_keydown(t){const e=t.keyCode,n=this._keyManager,i=n.activeItemIndex,r=Ag(t);switch(e){case 32:case 13:r||n.isTyping()||(this._toggleFocusedOption(),t.preventDefault());break;default:if(65===e&&this.multiple&&Ag(t,"ctrlKey")&&!n.isTyping()){const e=this.options.some(t=>!t.disabled&&!t.selected);this._setAllOptionsSelected(e,!0,!0),t.preventDefault()}else n.onKeydown(t)}this.multiple&&(38===e||40===e)&&t.shiftKey&&n.activeItemIndex!==i&&this._toggleFocusedOption()}_reportValueChange(){if(this.options&&!this._isDestroyed){const t=this._getSelectedOptionValues();this._onChange(t),this._value=t}}_emitChangeEvent(t){this.selectionChange.emit(new aE(this,t[0],t))}writeValue(t){this._value=t,this.options&&this._setOptionsFromValues(t||[])}setDisabledState(t){this.disabled=t}registerOnChange(t){this._onChange=t}registerOnTouched(t){this._onTouched=t}_setOptionsFromValues(t){this.options.forEach(t=>t._setSelected(!1)),t.forEach(t=>{const e=this.options.find(e=>!e.selected&&this.compareWith(e.value,t));e&&e._setSelected(!0)})}_getSelectedOptionValues(){return this.options.filter(t=>t.selected).map(t=>t.value)}_toggleFocusedOption(){let t=this._keyManager.activeItemIndex;if(null!=t&&this._isValidIndex(t)){let e=this.options.toArray()[t];!e||e.disabled||!this._multiple&&e.selected||(e.toggle(),this._emitChangeEvent([e]))}}_setAllOptionsSelected(t,e,n){const i=[];this.options.forEach(n=>{e&&n.disabled||!n._setSelected(t)||i.push(n)}),i.length&&(this._reportValueChange(),n&&this._emitChangeEvent(i))}_isValidIndex(t){return t>=0&&t<this.options.length}_getOptionIndex(t){return this.options.toArray().indexOf(t)}_markOptionsForCheck(){this.options&&this.options.forEach(t=>t._markForCheck())}_allowFocusEscape(){this._tabIndex=-1,setTimeout(()=>{this._tabIndex=0,this._changeDetector.markForCheck()})}_updateTabIndex(){this._tabIndex=0===this.options.length?-1:0}}return t.\u0275fac=function(e){return new(e||t)(pa(Cl),Ti("tabindex"),pa(Jl),pa(fy))},t.\u0275cmp=Se({type:t,selectors:[["mat-selection-list"]],contentQueries:function(t,e,n){if(1&t&&jc(n,lE,1),2&t){let t;Gc(t=Qc())&&(e.options=t)}},hostAttrs:["role","listbox",1,"mat-selection-list","mat-list-base"],hostVars:3,hostBindings:function(t,e){1&t&&Ea("keydown",function(t){return e._keydown(t)}),2&t&&ua("aria-multiselectable",e.multiple)("aria-disabled",e.disabled.toString())("tabindex",e._tabIndex)},inputs:{disableRipple:"disableRipple",tabIndex:"tabIndex",color:"color",compareWith:"compareWith",disabled:"disabled",multiple:"multiple"},outputs:{selectionChange:"selectionChange"},exportAs:["matSelectionList"],features:[bl([oE]),Ko,Ge],ngContentSelectors:XS,decls:1,vars:0,template:function(t,e){1&t&&(Na(),La(0))},styles:['.mat-subheader{display:flex;box-sizing:border-box;padding:16px;align-items:center}.mat-list-base .mat-subheader{margin:0}.mat-list-base{padding-top:8px;display:block;-webkit-tap-highlight-color:transparent}.mat-list-base .mat-subheader{height:48px;line-height:16px}.mat-list-base .mat-subheader:first-child{margin-top:-8px}.mat-list-base .mat-list-item,.mat-list-base .mat-list-option{display:block;height:48px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base .mat-list-item .mat-list-item-content,.mat-list-base .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base .mat-list-item .mat-list-item-content-reverse,.mat-list-base .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base .mat-list-item .mat-list-item-ripple,.mat-list-base .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar,.mat-list-base .mat-list-option.mat-list-item-with-avatar{height:56px}.mat-list-base .mat-list-item.mat-2-line,.mat-list-base .mat-list-option.mat-2-line{height:72px}.mat-list-base .mat-list-item.mat-3-line,.mat-list-base .mat-list-option.mat-3-line{height:88px}.mat-list-base .mat-list-item.mat-multi-line,.mat-list-base .mat-list-option.mat-multi-line{height:auto}.mat-list-base .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base .mat-list-item .mat-list-text,.mat-list-base .mat-list-option .mat-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base .mat-list-item .mat-list-text>*,.mat-list-base .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-list-base .mat-list-item .mat-list-text:empty,.mat-list-base .mat-list-option .mat-list-text:empty{display:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base .mat-list-item .mat-list-avatar,.mat-list-base .mat-list-option .mat-list-avatar{flex-shrink:0;width:40px;height:40px;border-radius:50%;object-fit:cover}.mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:72px;width:calc(100% - 72px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:72px}.mat-list-base .mat-list-item .mat-list-icon,.mat-list-base .mat-list-option .mat-list-icon{flex-shrink:0;width:24px;height:24px;font-size:24px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:64px;width:calc(100% - 64px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:64px}.mat-list-base .mat-list-item .mat-divider,.mat-list-base .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base .mat-list-item .mat-divider,[dir=rtl] .mat-list-base .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-list-base[dense]{padding-top:4px;display:block}.mat-list-base[dense] .mat-subheader{height:40px;line-height:8px}.mat-list-base[dense] .mat-subheader:first-child{margin-top:-4px}.mat-list-base[dense] .mat-list-item,.mat-list-base[dense] .mat-list-option{display:block;height:40px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-item-content,.mat-list-base[dense] .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base[dense] .mat-list-item .mat-list-item-content-reverse,.mat-list-base[dense] .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base[dense] .mat-list-item .mat-list-item-ripple,.mat-list-base[dense] .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar{height:48px}.mat-list-base[dense] .mat-list-item.mat-2-line,.mat-list-base[dense] .mat-list-option.mat-2-line{height:60px}.mat-list-base[dense] .mat-list-item.mat-3-line,.mat-list-base[dense] .mat-list-option.mat-3-line{height:76px}.mat-list-base[dense] .mat-list-item.mat-multi-line,.mat-list-base[dense] .mat-list-option.mat-multi-line{height:auto}.mat-list-base[dense] .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base[dense] .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base[dense] .mat-list-item .mat-list-text,.mat-list-base[dense] .mat-list-option .mat-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-text>*,.mat-list-base[dense] .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-list-base[dense] .mat-list-item .mat-list-text:empty,.mat-list-base[dense] .mat-list-option .mat-list-text:empty{display:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base[dense] .mat-list-item .mat-list-avatar,.mat-list-base[dense] .mat-list-option .mat-list-avatar{flex-shrink:0;width:36px;height:36px;border-radius:50%;object-fit:cover}.mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:68px;width:calc(100% - 68px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:68px}.mat-list-base[dense] .mat-list-item .mat-list-icon,.mat-list-base[dense] .mat-list-option .mat-list-icon{flex-shrink:0;width:20px;height:20px;font-size:20px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:60px;width:calc(100% - 60px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:60px}.mat-list-base[dense] .mat-list-item .mat-divider,.mat-list-base[dense] .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-divider,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base[dense] .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-nav-list a{text-decoration:none;color:inherit}.mat-nav-list .mat-list-item{cursor:pointer;outline:none}mat-action-list button{background:none;color:inherit;border:none;font:inherit;outline:inherit;-webkit-tap-highlight-color:transparent;text-align:left}[dir=rtl] mat-action-list button{text-align:right}mat-action-list button::-moz-focus-inner{border:0}mat-action-list .mat-list-item{cursor:pointer;outline:inherit}.mat-list-option:not(.mat-list-item-disabled){cursor:pointer;outline:none}.mat-list-item-disabled{pointer-events:none}.cdk-high-contrast-active .mat-list-item-disabled{opacity:.5}.cdk-high-contrast-active :host .mat-list-item-disabled{opacity:.5}.cdk-high-contrast-active .mat-selection-list:focus{outline-style:dotted}.cdk-high-contrast-active .mat-list-option:hover,.cdk-high-contrast-active .mat-list-option:focus,.cdk-high-contrast-active .mat-nav-list .mat-list-item:hover,.cdk-high-contrast-active .mat-nav-list .mat-list-item:focus,.cdk-high-contrast-active mat-action-list .mat-list-item:hover,.cdk-high-contrast-active mat-action-list .mat-list-item:focus{outline:dotted 1px}.cdk-high-contrast-active .mat-list-single-selected-option::after{content:"";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}.cdk-high-contrast-active [dir=rtl] .mat-list-single-selected-option::after{right:auto;left:16px}@media(hover: none){.mat-list-option:not(.mat-list-single-selected-option):not(.mat-list-item-disabled):hover,.mat-nav-list .mat-list-item:not(.mat-list-item-disabled):hover,.mat-action-list .mat-list-item:not(.mat-list-item-disabled):hover{background:none}}\n'],encapsulation:2,changeDetection:0}),t})(),uE=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[[AA,MA,fA,RA,jh],AA,fA,RA,qS]}),t})(),hE=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[[jh,fA,qg],fA]}),t})(),dE=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({}),t})(),pE=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[[MA,fA,qg,dE],fA,dE]}),t})();class fE{constructor(t){this.total=t}call(t,e){return e.subscribe(new mE(t,this.total))}}class mE extends W{constructor(t,e){super(t),this.total=e,this.count=0}_next(t){++this.count>this.total&&this.destination.next(t)}}const gE=new Set;let yE,vE=(()=>{class t{constructor(t){this._platform=t,this._matchMedia=this._platform.isBrowser&&window.matchMedia?window.matchMedia.bind(window):bE}matchMedia(t){return this._platform.WEBKIT&&function(t){if(!gE.has(t))try{yE||(yE=document.createElement("style"),yE.setAttribute("type","text/css"),document.head.appendChild(yE)),yE.sheet&&(yE.sheet.insertRule(`@media ${t} {.fx-query-test{ }}`,0),gE.add(t))}catch(e){console.error(e)}}(t),this._matchMedia(t)}}return t.\u0275fac=function(e){return new(e||t)(Xi(zg))},t.\u0275prov=Wt({factory:function(){return new t(Xi(zg))},token:t,providedIn:"root"}),t})();function bE(t){return{matches:"all"===t||""===t,media:t,addListener:()=>{},removeListener:()=>{}}}let AE=(()=>{class t{constructor(t,e){this._mediaMatcher=t,this._zone=e,this._queries=new Map,this._destroySubject=new tt}ngOnDestroy(){this._destroySubject.next(),this._destroySubject.complete()}isMatched(t){return xE(Ng(t)).some(t=>this._registerQuery(t).mql.matches)}observe(t){let e=Pd(xE(Ng(t)).map(t=>this._registerQuery(t).observable));return e=Ud(e.pipe(Xd(1)),e.pipe(t=>t.lift(new fE(1)),Cg(0))),e.pipe(it(t=>{const e={matches:!1,breakpoints:{}};return t.forEach(({matches:t,query:n})=>{e.matches=e.matches||t,e.breakpoints[n]=t}),e}))}_registerQuery(t){if(this._queries.has(t))return this._queries.get(t);const e=this._mediaMatcher.matchMedia(t),n={observable:new X(t=>{const n=e=>this._zone.run(()=>t.next(e));return e.addListener(n),()=>{e.removeListener(n)}}).pipe(Jd(e),it(({matches:e})=>({query:t,matches:e})),Jx(this._destroySubject)),mql:e};return this._queries.set(t,n),n}}return t.\u0275fac=function(e){return new(e||t)(Xi(vE),Xi(Au))},t.\u0275prov=Wt({factory:function(){return new t(Xi(vE),Xi(Au))},token:t,providedIn:"root"}),t})();function xE(t){return t.map(t=>t.split(",")).reduce((t,e)=>t.concat(e)).map(t=>t.trim())}const wE={tooltipState:Ty("state",[Ny("initial, void, hidden",Ry({opacity:0,transform:"scale(0)"})),Ny("visible",Ry({transform:"scale(1)"})),Dy("* => visible",My("200ms cubic-bezier(0, 0, 0.2, 1)",Ly([Ry({opacity:0,transform:"scale(0)",offset:0}),Ry({opacity:.5,transform:"scale(0.99)",offset:.5}),Ry({opacity:1,transform:"scale(1)",offset:1})]))),Dy("* => hidden",My("100ms cubic-bezier(0, 0, 0.2, 1)",Ry({opacity:0})))])},_E=Hg({passive:!0}),SE=new Ri("mat-tooltip-scroll-strategy"),EE={provide:SE,deps:[f_],useFactory:function(t){return()=>t.scrollStrategies.reposition({scrollThrottle:20})}},CE=new Ri("mat-tooltip-default-options",{providedIn:"root",factory:function(){return{showDelay:0,hideDelay:0,touchendHideDelay:1500}}});let IE=(()=>{class t{constructor(t,e,n,i,r,s,o,a,l,c,u,h){this._overlay=t,this._elementRef=e,this._scrollDispatcher=n,this._viewContainerRef=i,this._ngZone=r,this._platform=s,this._ariaDescriber=o,this._focusMonitor=a,this._dir=c,this._defaultOptions=u,this._position="below",this._disabled=!1,this._viewInitialized=!1,this._pointerExitEventsInitialized=!1,this.showDelay=this._defaultOptions.showDelay,this.hideDelay=this._defaultOptions.hideDelay,this.touchGestures="auto",this._message="",this._passiveListeners=[],this._destroyed=new tt,this._handleKeydown=t=>{this._isTooltipVisible()&&27===t.keyCode&&!Ag(t)&&(t.preventDefault(),t.stopPropagation(),this._ngZone.run(()=>this.hide(0)))},this._scrollStrategy=l,u&&(u.position&&(this.position=u.position),u.touchGestures&&(this.touchGestures=u.touchGestures)),r.runOutsideAngular(()=>{e.nativeElement.addEventListener("keydown",this._handleKeydown)})}get position(){return this._position}set position(t){t!==this._position&&(this._position=t,this._overlayRef&&(this._updatePosition(),this._tooltipInstance&&this._tooltipInstance.show(0),this._overlayRef.updatePosition()))}get disabled(){return this._disabled}set disabled(t){this._disabled=kg(t),this._disabled?this.hide(0):this._setupPointerEnterEventsIfNeeded()}get message(){return this._message}set message(t){this._ariaDescriber.removeDescription(this._elementRef.nativeElement,this._message,"tooltip"),this._message=null!=t?String(t).trim():"",!this._message&&this._isTooltipVisible()?this.hide(0):(this._setupPointerEnterEventsIfNeeded(),this._updateTooltipMessage(),this._ngZone.runOutsideAngular(()=>{Promise.resolve().then(()=>{this._ariaDescriber.describe(this._elementRef.nativeElement,this.message,"tooltip")})}))}get tooltipClass(){return this._tooltipClass}set tooltipClass(t){this._tooltipClass=t,this._tooltipInstance&&this._setTooltipClass(this._tooltipClass)}ngAfterViewInit(){this._viewInitialized=!0,this._setupPointerEnterEventsIfNeeded(),this._focusMonitor.monitor(this._elementRef).pipe(Jx(this._destroyed)).subscribe(t=>{t?"keyboard"===t&&this._ngZone.run(()=>this.show()):this._ngZone.run(()=>this.hide(0))})}ngOnDestroy(){const t=this._elementRef.nativeElement;clearTimeout(this._touchstartTimeout),this._overlayRef&&(this._overlayRef.dispose(),this._tooltipInstance=null),t.removeEventListener("keydown",this._handleKeydown),this._passiveListeners.forEach(([e,n])=>{t.removeEventListener(e,n,_E)}),this._passiveListeners.length=0,this._destroyed.next(),this._destroyed.complete(),this._ariaDescriber.removeDescription(t,this.message,"tooltip"),this._focusMonitor.stopMonitoring(t)}show(t=this.showDelay){if(this.disabled||!this.message||this._isTooltipVisible()&&!this._tooltipInstance._showTimeoutId&&!this._tooltipInstance._hideTimeoutId)return;const e=this._createOverlay();this._detach(),this._portal=this._portal||new aw(TE,this._viewContainerRef),this._tooltipInstance=e.attach(this._portal).instance,this._tooltipInstance.afterHidden().pipe(Jx(this._destroyed)).subscribe(()=>this._detach()),this._setTooltipClass(this._tooltipClass),this._updateTooltipMessage(),this._tooltipInstance.show(t)}hide(t=this.hideDelay){this._tooltipInstance&&this._tooltipInstance.hide(t)}toggle(){this._isTooltipVisible()?this.hide():this.show()}_isTooltipVisible(){return!!this._tooltipInstance&&this._tooltipInstance.isVisible()}_createOverlay(){if(this._overlayRef)return this._overlayRef;const t=this._scrollDispatcher.getAncestorScrollContainers(this._elementRef),e=this._overlay.position().flexibleConnectedTo(this._elementRef).withTransformOriginOn(".mat-tooltip").withFlexibleDimensions(!1).withViewportMargin(8).withScrollableContainers(t);return e.positionChanges.pipe(Jx(this._destroyed)).subscribe(t=>{this._tooltipInstance&&t.scrollableViewProperties.isOverlayClipped&&this._tooltipInstance.isVisible()&&this._ngZone.run(()=>this.hide(0))}),this._overlayRef=this._overlay.create({direction:this._dir,positionStrategy:e,panelClass:"mat-tooltip-panel",scrollStrategy:this._scrollStrategy()}),this._updatePosition(),this._overlayRef.detachments().pipe(Jx(this._destroyed)).subscribe(()=>this._detach()),this._overlayRef}_detach(){this._overlayRef&&this._overlayRef.hasAttached()&&this._overlayRef.detach(),this._tooltipInstance=null}_updatePosition(){const t=this._overlayRef.getConfig().positionStrategy,e=this._getOrigin(),n=this._getOverlayPosition();t.withPositions([Object.assign(Object.assign({},e.main),n.main),Object.assign(Object.assign({},e.fallback),n.fallback)])}_getOrigin(){const t=!this._dir||"ltr"==this._dir.value,e=this.position;let n;"above"==e||"below"==e?n={originX:"center",originY:"above"==e?"top":"bottom"}:"before"==e||"left"==e&&t||"right"==e&&!t?n={originX:"start",originY:"center"}:("after"==e||"right"==e&&t||"left"==e&&!t)&&(n={originX:"end",originY:"center"});const{x:i,y:r}=this._invertPosition(n.originX,n.originY);return{main:n,fallback:{originX:i,originY:r}}}_getOverlayPosition(){const t=!this._dir||"ltr"==this._dir.value,e=this.position;let n;"above"==e?n={overlayX:"center",overlayY:"bottom"}:"below"==e?n={overlayX:"center",overlayY:"top"}:"before"==e||"left"==e&&t||"right"==e&&!t?n={overlayX:"end",overlayY:"center"}:("after"==e||"right"==e&&t||"left"==e&&!t)&&(n={overlayX:"start",overlayY:"center"});const{x:i,y:r}=this._invertPosition(n.overlayX,n.overlayY);return{main:n,fallback:{overlayX:i,overlayY:r}}}_updateTooltipMessage(){this._tooltipInstance&&(this._tooltipInstance.message=this.message,this._tooltipInstance._markForCheck(),this._ngZone.onMicrotaskEmpty.pipe(Xd(1),Jx(this._destroyed)).subscribe(()=>{this._tooltipInstance&&this._overlayRef.updatePosition()}))}_setTooltipClass(t){this._tooltipInstance&&(this._tooltipInstance.tooltipClass=t,this._tooltipInstance._markForCheck())}_invertPosition(t,e){return"above"===this.position||"below"===this.position?"top"===e?e="bottom":"bottom"===e&&(e="top"):"end"===t?t="start":"start"===t&&(t="end"),{x:t,y:e}}_setupPointerEnterEventsIfNeeded(){!this._disabled&&this.message&&this._viewInitialized&&!this._passiveListeners.length&&(this._platformSupportsMouseEvents()?this._passiveListeners.push(["mouseenter",()=>{this._setupPointerExitEventsIfNeeded(),this.show()}]):"off"!==this.touchGestures&&(this._disableNativeGesturesIfNecessary(),this._passiveListeners.push(["touchstart",()=>{this._setupPointerExitEventsIfNeeded(),clearTimeout(this._touchstartTimeout),this._touchstartTimeout=setTimeout(()=>this.show(),500)}])),this._addListeners(this._passiveListeners))}_setupPointerExitEventsIfNeeded(){if(this._pointerExitEventsInitialized)return;this._pointerExitEventsInitialized=!0;const t=[];if(this._platformSupportsMouseEvents())t.push(["mouseleave",()=>this.hide()],["wheel",t=>this._wheelListener(t)]);else if("off"!==this.touchGestures){this._disableNativeGesturesIfNecessary();const e=()=>{clearTimeout(this._touchstartTimeout),this.hide(this._defaultOptions.touchendHideDelay)};t.push(["touchend",e],["touchcancel",e])}this._addListeners(t),this._passiveListeners.push(...t)}_addListeners(t){t.forEach(([t,e])=>{this._elementRef.nativeElement.addEventListener(t,e,_E)})}_platformSupportsMouseEvents(){return!this._platform.IOS&&!this._platform.ANDROID}_wheelListener(t){if(this._isTooltipVisible()){const e=(this._document||document).elementFromPoint(t.clientX,t.clientY),n=this._elementRef.nativeElement;e===n||n.contains(e)||this.hide()}}_disableNativeGesturesIfNecessary(){const t=this.touchGestures;if("off"!==t){const e=this._elementRef.nativeElement,n=e.style;("on"===t||"INPUT"!==e.nodeName&&"TEXTAREA"!==e.nodeName)&&(n.userSelect=n.msUserSelect=n.webkitUserSelect=n.MozUserSelect="none"),"on"!==t&&e.draggable||(n.webkitUserDrag="none"),n.touchAction="none",n.webkitTapHighlightColor="transparent"}}}return t.\u0275fac=function(e){return new(e||t)(pa(f_),pa(Cl),pa(Bw),pa(hc),pa(Au),pa(zg),pa(ey),pa(fy),pa(SE),pa(_y,8),pa(CE,8),pa(Zu))},t.\u0275dir=ke({type:t,selectors:[["","matTooltip",""]],hostAttrs:[1,"mat-tooltip-trigger"],inputs:{showDelay:["matTooltipShowDelay","showDelay"],hideDelay:["matTooltipHideDelay","hideDelay"],touchGestures:["matTooltipTouchGestures","touchGestures"],position:["matTooltipPosition","position"],disabled:["matTooltipDisabled","disabled"],message:["matTooltip","message"],tooltipClass:["matTooltipClass","tooltipClass"]},exportAs:["matTooltip"]}),t})(),TE=(()=>{class t{constructor(t,e){this._changeDetectorRef=t,this._breakpointObserver=e,this._visibility="initial",this._closeOnInteraction=!1,this._onHide=new tt,this._isHandset=this._breakpointObserver.observe("(max-width: 599.98px) and (orientation: portrait), (max-width: 959.98px) and (orientation: landscape)")}show(t){this._hideTimeoutId&&(clearTimeout(this._hideTimeoutId),this._hideTimeoutId=null),this._closeOnInteraction=!0,this._showTimeoutId=setTimeout(()=>{this._visibility="visible",this._showTimeoutId=null,this._markForCheck()},t)}hide(t){this._showTimeoutId&&(clearTimeout(this._showTimeoutId),this._showTimeoutId=null),this._hideTimeoutId=setTimeout(()=>{this._visibility="hidden",this._hideTimeoutId=null,this._markForCheck()},t)}afterHidden(){return this._onHide}isVisible(){return"visible"===this._visibility}ngOnDestroy(){this._onHide.complete()}_animationStart(){this._closeOnInteraction=!1}_animationDone(t){const e=t.toState;"hidden"!==e||this.isVisible()||this._onHide.next(),"visible"!==e&&"hidden"!==e||(this._closeOnInteraction=!0)}_handleBodyInteraction(){this._closeOnInteraction&&this.hide(0)}_markForCheck(){this._changeDetectorRef.markForCheck()}}return t.\u0275fac=function(e){return new(e||t)(pa(Jl),pa(AE))},t.\u0275cmp=Se({type:t,selectors:[["mat-tooltip-component"]],hostAttrs:["aria-hidden","true"],hostVars:2,hostBindings:function(t,e){1&t&&Ea("click",function(){return e._handleBodyInteraction()},!1,jr)("auxclick",function(){return e._handleBodyInteraction()},!1,jr),2&t&&za("zoom","visible"===e._visibility?1:null)},decls:3,vars:7,consts:[[1,"mat-tooltip",3,"ngClass"]],template:function(t,e){if(1&t&&(ga(0,"div",0),Ea("@state.start",function(){return e._animationStart()})("@state.done",function(t){return e._animationDone(t)}),Mc(1,"async"),Ja(2),ya()),2&t){let t=null;Ua("mat-tooltip-handset",null==(t=kc(1,5,e._isHandset))?null:t.matches),fa("ngClass",e.tooltipClass)("@state",e._visibility),Bs(2),Za(e.message)}},directives:[Th],pipes:[Gh],styles:[".mat-tooltip-panel{pointer-events:none !important}.mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis}.cdk-high-contrast-active .mat-tooltip{outline:solid 1px}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}\n"],encapsulation:2,data:{animation:[wE.tooltipState]},changeDetection:0}),t})(),ME=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({providers:[EE],imports:[[xy,jh,g_,fA],fA,Fw]}),t})();function kE(t,e){1&t&&La(0)}const RE=["*"];function NE(t,e){}const LE=function(t){return{animationDuration:t}},DE=function(t,e){return{value:t,params:e}},BE=["tabBodyWrapper"],OE=["tabHeader"];function PE(t,e){}function FE(t,e){1&t&&ha(0,PE,0,0,"ng-template",9),2&t&&fa("cdkPortalOutlet",ka().$implicit.templateLabel)}function $E(t,e){1&t&&Ja(0),2&t&&Za(ka().$implicit.textLabel)}function zE(t,e){if(1&t){const t=xa();ga(0,"div",6),Ea("click",function(){yn(t);const n=e.$implicit,i=e.index,r=ka(),s=da(1);return r._handleClick(n,s,i)})("cdkFocusChange",function(n){yn(t);const i=e.index;return ka()._tabFocusChanged(n,i)}),ga(1,"div",7),ha(2,FE,1,1,"ng-template",8),ha(3,$E,1,1,"ng-template",8),ya(),ya()}if(2&t){const t=e.$implicit,n=e.index,i=ka();Ua("mat-tab-label-active",i.selectedIndex==n),fa("id",i._getTabLabelId(n))("disabled",t.disabled)("matRippleDisabled",t.disabled||i.disableRipple),ua("tabIndex",i._getTabIndex(t,n))("aria-posinset",n+1)("aria-setsize",i._tabs.length)("aria-controls",i._getTabContentId(n))("aria-selected",i.selectedIndex==n)("aria-label",t.ariaLabel||null)("aria-labelledby",!t.ariaLabel&&t.ariaLabelledby?t.ariaLabelledby:null),Bs(2),fa("ngIf",t.templateLabel),Bs(1),fa("ngIf",!t.templateLabel)}}function UE(t,e){if(1&t){const t=xa();ga(0,"mat-tab-body",10),Ea("_onCentered",function(){return yn(t),ka()._removeTabBodyWrapperHeight()})("_onCentering",function(e){return yn(t),ka()._setTabBodyWrapperHeight(e)}),ya()}if(2&t){const t=e.$implicit,n=e.index,i=ka();Ua("mat-tab-body-active",i.selectedIndex==n),fa("id",i._getTabContentId(n))("content",t.content)("position",t.position)("origin",t.origin)("animationDuration",i.animationDuration),ua("aria-labelledby",i._getTabLabelId(n))}}const HE=["tabListContainer"],VE=["tabList"],GE=["nextPaginator"],WE=["previousPaginator"],jE=new Ri("MatInkBarPositioner",{providedIn:"root",factory:function(){return t=>({left:t?(t.offsetLeft||0)+"px":"0",width:t?(t.offsetWidth||0)+"px":"0"})}});let QE=(()=>{class t{constructor(t,e,n,i){this._elementRef=t,this._ngZone=e,this._inkBarPositioner=n,this._animationMode=i}alignToElement(t){this.show(),"undefined"!=typeof requestAnimationFrame?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>this._setStyles(t))}):this._setStyles(t)}show(){this._elementRef.nativeElement.style.visibility="visible"}hide(){this._elementRef.nativeElement.style.visibility="hidden"}_setStyles(t){const e=this._inkBarPositioner(t),n=this._elementRef.nativeElement;n.style.left=e.left,n.style.width=e.width}}return t.\u0275fac=function(e){return new(e||t)(pa(Cl),pa(Au),pa(jE),pa(lA,8))},t.\u0275dir=ke({type:t,selectors:[["mat-ink-bar"]],hostAttrs:[1,"mat-ink-bar"],hostVars:2,hostBindings:function(t,e){2&t&&Ua("_mat-animation-noopable","NoopAnimations"===e._animationMode)}}),t})();const qE=new Ri("MatTabContent"),XE=new Ri("MatTabLabel");let YE=(()=>{class t extends dw{}return t.\u0275fac=function(e){return KE(e||t)},t.\u0275dir=ke({type:t,selectors:[["","mat-tab-label",""],["","matTabLabel",""]],features:[bl([{provide:XE,useExisting:t}]),Ko]}),t})();const KE=Ci(YE);class JE{}const ZE=mA(JE),tC=new Ri("MAT_TAB_GROUP");let eC=(()=>{class t extends ZE{constructor(t,e){super(),this._viewContainerRef=t,this._closestTabGroup=e,this.textLabel="",this._contentPortal=null,this._stateChanges=new tt,this.position=null,this.origin=null,this.isActive=!1}get templateLabel(){return this._templateLabel}set templateLabel(t){this._setTemplateLabelInput(t)}get content(){return this._contentPortal}ngOnChanges(t){(t.hasOwnProperty("textLabel")||t.hasOwnProperty("disabled"))&&this._stateChanges.next()}ngOnDestroy(){this._stateChanges.complete()}ngOnInit(){this._contentPortal=new lw(this._explicitContent||this._implicitContent,this._viewContainerRef)}_setTemplateLabelInput(t){t&&(this._templateLabel=t)}}return t.\u0275fac=function(e){return new(e||t)(pa(hc),pa(tC))},t.\u0275cmp=Se({type:t,selectors:[["mat-tab"]],contentQueries:function(t,e,n){if(1&t&&(jc(n,XE,1),jc(n,qE,3,rc)),2&t){let t;Gc(t=Qc())&&(e.templateLabel=t.first),Gc(t=Qc())&&(e._explicitContent=t.first)}},viewQuery:function(t,e){if(1&t&&Wc(rc,3),2&t){let t;Gc(t=Qc())&&(e._implicitContent=t.first)}},inputs:{disabled:"disabled",textLabel:["label","textLabel"],ariaLabel:["aria-label","ariaLabel"],ariaLabelledby:["aria-labelledby","ariaLabelledby"]},exportAs:["matTab"],features:[Ko,Ge],ngContentSelectors:RE,decls:1,vars:0,template:function(t,e){1&t&&(Na(),ha(0,kE,1,0,"ng-template"))},encapsulation:2}),t})();const nC={translateTab:Ty("translateTab",[Ny("center, void, left-origin-center, right-origin-center",Ry({transform:"none"})),Ny("left",Ry({transform:"translate3d(-100%, 0, 0)",minHeight:"1px"})),Ny("right",Ry({transform:"translate3d(100%, 0, 0)",minHeight:"1px"})),Dy("* => left, * => right, left => center, right => center",My("{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)")),Dy("void => left-origin-center",[Ry({transform:"translate3d(-100%, 0, 0)"}),My("{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)")]),Dy("void => right-origin-center",[Ry({transform:"translate3d(100%, 0, 0)"}),My("{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)")])])};let iC=(()=>{class t extends pw{constructor(t,e,n,i){super(t,e,i),this._host=n,this._centeringSub=H.EMPTY,this._leavingSub=H.EMPTY}ngOnInit(){super.ngOnInit(),this._centeringSub=this._host._beforeCentering.pipe(Jd(this._host._isCenterPosition(this._host._position))).subscribe(t=>{t&&!this.hasAttached()&&this.attach(this._host._content)}),this._leavingSub=this._host._afterLeavingCenter.subscribe(()=>{this.detach()})}ngOnDestroy(){super.ngOnDestroy(),this._centeringSub.unsubscribe(),this._leavingSub.unsubscribe()}}return t.\u0275fac=function(e){return new(e||t)(pa(wl),pa(hc),pa(Ft(()=>sC)),pa(Zu))},t.\u0275dir=ke({type:t,selectors:[["","matTabBodyHost",""]],features:[Ko]}),t})(),rC=(()=>{class t{constructor(t,e,n){this._elementRef=t,this._dir=e,this._dirChangeSubscription=H.EMPTY,this._translateTabComplete=new tt,this._onCentering=new Nc,this._beforeCentering=new Nc,this._afterLeavingCenter=new Nc,this._onCentered=new Nc(!0),this.animationDuration="500ms",e&&(this._dirChangeSubscription=e.change.subscribe(t=>{this._computePositionAnimationState(t),n.markForCheck()})),this._translateTabComplete.pipe(yw((t,e)=>t.fromState===e.fromState&&t.toState===e.toState)).subscribe(t=>{this._isCenterPosition(t.toState)&&this._isCenterPosition(this._position)&&this._onCentered.emit(),this._isCenterPosition(t.fromState)&&!this._isCenterPosition(this._position)&&this._afterLeavingCenter.emit()})}set position(t){this._positionIndex=t,this._computePositionAnimationState()}ngOnInit(){"center"==this._position&&null!=this.origin&&(this._position=this._computePositionFromOrigin(this.origin))}ngOnDestroy(){this._dirChangeSubscription.unsubscribe(),this._translateTabComplete.complete()}_onTranslateTabStarted(t){const e=this._isCenterPosition(t.toState);this._beforeCentering.emit(e),e&&this._onCentering.emit(this._elementRef.nativeElement.clientHeight)}_getLayoutDirection(){return this._dir&&"rtl"===this._dir.value?"rtl":"ltr"}_isCenterPosition(t){return"center"==t||"left-origin-center"==t||"right-origin-center"==t}_computePositionAnimationState(t=this._getLayoutDirection()){this._position=this._positionIndex<0?"ltr"==t?"left":"right":this._positionIndex>0?"ltr"==t?"right":"left":"center"}_computePositionFromOrigin(t){const e=this._getLayoutDirection();return"ltr"==e&&t<=0||"rtl"==e&&t>0?"left-origin-center":"right-origin-center"}}return t.\u0275fac=function(e){return new(e||t)(pa(Cl),pa(_y,8),pa(Jl))},t.\u0275dir=ke({type:t,inputs:{animationDuration:"animationDuration",position:"position",_content:["content","_content"],origin:"origin"},outputs:{_onCentering:"_onCentering",_beforeCentering:"_beforeCentering",_afterLeavingCenter:"_afterLeavingCenter",_onCentered:"_onCentered"}}),t})(),sC=(()=>{class t extends rC{constructor(t,e,n){super(t,e,n)}}return t.\u0275fac=function(e){return new(e||t)(pa(Cl),pa(_y,8),pa(Jl))},t.\u0275cmp=Se({type:t,selectors:[["mat-tab-body"]],viewQuery:function(t,e){if(1&t&&Wc(pw,1),2&t){let t;Gc(t=Qc())&&(e._portalHost=t.first)}},hostAttrs:[1,"mat-tab-body"],features:[Ko],decls:3,vars:6,consts:[["cdkScrollable","",1,"mat-tab-body-content"],["content",""],["matTabBodyHost",""]],template:function(t,e){var n,i,r,s,o;1&t&&(ga(0,"div",0,1),Ea("@translateTab.start",function(t){return e._onTranslateTabStarted(t)})("@translateTab.done",function(t){return e._translateTabComplete.next(t)}),ha(2,NE,0,0,"ng-template",2),ya()),2&t&&fa("@translateTab",(n=3,i=DE,r=e._position,s=Cc(1,LE,e.animationDuration),function(t,e,n,i,r,s,o){const a=e+n;return ca(t,a,r,s)?aa(t,a+2,o?i.call(o,r,s):i(r,s)):Ic(t,a+2)}(mn(),En(),n,i,r,s,o)))},directives:[iC],styles:[".mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}\n"],encapsulation:2,data:{animation:[nC.translateTab]}}),t})();const oC=new Ri("MAT_TABS_CONFIG");let aC=0;class lC{}class cC{constructor(t){this._elementRef=t}}const uC=gA(yA(cC),"primary");let hC=(()=>{class t extends uC{constructor(t,e,n,i){super(t),this._changeDetectorRef=e,this._animationMode=i,this._tabs=new Dc,this._indexToSelect=0,this._tabBodyWrapperHeight=0,this._tabsSubscription=H.EMPTY,this._tabLabelSubscription=H.EMPTY,this._selectedIndex=null,this.headerPosition="above",this.selectedIndexChange=new Nc,this.focusChange=new Nc,this.animationDone=new Nc,this.selectedTabChange=new Nc(!0),this._groupId=aC++,this.animationDuration=n&&n.animationDuration?n.animationDuration:"500ms",this.disablePagination=!(!n||null==n.disablePagination)&&n.disablePagination,this.dynamicHeight=!(!n||null==n.dynamicHeight)&&n.dynamicHeight}get dynamicHeight(){return this._dynamicHeight}set dynamicHeight(t){this._dynamicHeight=kg(t)}get selectedIndex(){return this._selectedIndex}set selectedIndex(t){this._indexToSelect=Rg(t,null)}get animationDuration(){return this._animationDuration}set animationDuration(t){this._animationDuration=/^\d+$/.test(t)?t+"ms":t}get backgroundColor(){return this._backgroundColor}set backgroundColor(t){const e=this._elementRef.nativeElement;e.classList.remove(`mat-background-${this.backgroundColor}`),t&&e.classList.add(`mat-background-${t}`),this._backgroundColor=t}ngAfterContentChecked(){const t=this._indexToSelect=this._clampTabIndex(this._indexToSelect);if(this._selectedIndex!=t){const e=null==this._selectedIndex;if(!e){this.selectedTabChange.emit(this._createChangeEvent(t));const e=this._tabBodyWrapper.nativeElement;e.style.minHeight=e.clientHeight+"px"}Promise.resolve().then(()=>{this._tabs.forEach((e,n)=>e.isActive=n===t),e||(this.selectedIndexChange.emit(t),this._tabBodyWrapper.nativeElement.style.minHeight="")})}this._tabs.forEach((e,n)=>{e.position=n-t,null==this._selectedIndex||0!=e.position||e.origin||(e.origin=t-this._selectedIndex)}),this._selectedIndex!==t&&(this._selectedIndex=t,this._changeDetectorRef.markForCheck())}ngAfterContentInit(){this._subscribeToAllTabChanges(),this._subscribeToTabLabels(),this._tabsSubscription=this._tabs.changes.subscribe(()=>{if(this._clampTabIndex(this._indexToSelect)===this._selectedIndex){const t=this._tabs.toArray();for(let e=0;e<t.length;e++)if(t[e].isActive){this._indexToSelect=this._selectedIndex=e;break}}this._changeDetectorRef.markForCheck()})}_subscribeToAllTabChanges(){this._allTabs.changes.pipe(Jd(this._allTabs)).subscribe(t=>{this._tabs.reset(t.filter(t=>t._closestTabGroup===this)),this._tabs.notifyOnChanges()})}ngOnDestroy(){this._tabs.destroy(),this._tabsSubscription.unsubscribe(),this._tabLabelSubscription.unsubscribe()}realignInkBar(){this._tabHeader&&this._tabHeader._alignInkBarToSelectedTab()}_focusChanged(t){this.focusChange.emit(this._createChangeEvent(t))}_createChangeEvent(t){const e=new lC;return e.index=t,this._tabs&&this._tabs.length&&(e.tab=this._tabs.toArray()[t]),e}_subscribeToTabLabels(){this._tabLabelSubscription&&this._tabLabelSubscription.unsubscribe(),this._tabLabelSubscription=wt(...this._tabs.map(t=>t._stateChanges)).subscribe(()=>this._changeDetectorRef.markForCheck())}_clampTabIndex(t){return Math.min(this._tabs.length-1,Math.max(t||0,0))}_getTabLabelId(t){return`mat-tab-label-${this._groupId}-${t}`}_getTabContentId(t){return`mat-tab-content-${this._groupId}-${t}`}_setTabBodyWrapperHeight(t){if(!this._dynamicHeight||!this._tabBodyWrapperHeight)return;const e=this._tabBodyWrapper.nativeElement;e.style.height=this._tabBodyWrapperHeight+"px",this._tabBodyWrapper.nativeElement.offsetHeight&&(e.style.height=t+"px")}_removeTabBodyWrapperHeight(){const t=this._tabBodyWrapper.nativeElement;this._tabBodyWrapperHeight=t.clientHeight,t.style.height="",this.animationDone.emit()}_handleClick(t,e,n){t.disabled||(this.selectedIndex=e.focusIndex=n)}_getTabIndex(t,e){return t.disabled?null:this.selectedIndex===e?0:-1}_tabFocusChanged(t,e){t&&(this._tabHeader.focusIndex=e)}}return t.\u0275fac=function(e){return new(e||t)(pa(Cl),pa(Jl),pa(oC,8),pa(lA,8))},t.\u0275dir=ke({type:t,inputs:{headerPosition:"headerPosition",animationDuration:"animationDuration",disablePagination:"disablePagination",dynamicHeight:"dynamicHeight",selectedIndex:"selectedIndex",backgroundColor:"backgroundColor"},outputs:{selectedIndexChange:"selectedIndexChange",focusChange:"focusChange",animationDone:"animationDone",selectedTabChange:"selectedTabChange"},features:[Ko]}),t})(),dC=(()=>{class t extends hC{constructor(t,e,n,i){super(t,e,n,i)}}return t.\u0275fac=function(e){return new(e||t)(pa(Cl),pa(Jl),pa(oC,8),pa(lA,8))},t.\u0275cmp=Se({type:t,selectors:[["mat-tab-group"]],contentQueries:function(t,e,n){if(1&t&&jc(n,eC,1),2&t){let t;Gc(t=Qc())&&(e._allTabs=t)}},viewQuery:function(t,e){if(1&t&&(Wc(BE,1),Wc(OE,1)),2&t){let t;Gc(t=Qc())&&(e._tabBodyWrapper=t.first),Gc(t=Qc())&&(e._tabHeader=t.first)}},hostAttrs:[1,"mat-tab-group"],hostVars:4,hostBindings:function(t,e){2&t&&Ua("mat-tab-group-dynamic-height",e.dynamicHeight)("mat-tab-group-inverted-header","below"===e.headerPosition)},inputs:{color:"color",disableRipple:"disableRipple"},exportAs:["matTabGroup"],features:[bl([{provide:tC,useExisting:t}]),Ko],decls:6,vars:7,consts:[[3,"selectedIndex","disableRipple","disablePagination","indexFocused","selectFocusedIndex"],["tabHeader",""],["class","mat-tab-label mat-focus-indicator","role","tab","matTabLabelWrapper","","mat-ripple","","cdkMonitorElementFocus","",3,"id","mat-tab-label-active","disabled","matRippleDisabled","click","cdkFocusChange",4,"ngFor","ngForOf"],[1,"mat-tab-body-wrapper"],["tabBodyWrapper",""],["role","tabpanel",3,"id","mat-tab-body-active","content","position","origin","animationDuration","_onCentered","_onCentering",4,"ngFor","ngForOf"],["role","tab","matTabLabelWrapper","","mat-ripple","","cdkMonitorElementFocus","",1,"mat-tab-label","mat-focus-indicator",3,"id","disabled","matRippleDisabled","click","cdkFocusChange"],[1,"mat-tab-label-content"],[3,"ngIf"],[3,"cdkPortalOutlet"],["role","tabpanel",3,"id","content","position","origin","animationDuration","_onCentered","_onCentering"]],template:function(t,e){1&t&&(ga(0,"mat-tab-header",0,1),Ea("indexFocused",function(t){return e._focusChanged(t)})("selectFocusedIndex",function(t){return e.selectedIndex=t}),ha(2,zE,4,14,"div",2),ya(),ga(3,"div",3,4),ha(5,UE,1,8,"mat-tab-body",5),ya()),2&t&&(fa("selectedIndex",e.selectedIndex||0)("disableRipple",e.disableRipple)("disablePagination",e.disablePagination),Bs(2),fa("ngForOf",e._tabs),Bs(1),Ua("_mat-animation-noopable","NoopAnimations"===e._animationMode),Bs(2),fa("ngForOf",e._tabs))},directives:function(){return[bC,kh,mC,TA,gy,Nh,pw,sC]},styles:[".mat-tab-group{display:flex;flex-direction:column}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{padding:0 12px}}@media(max-width: 959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height 500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-tab-body-wrapper{transition:none;animation:none}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}\n"],encapsulation:2}),t})();class pC{}const fC=mA(pC);let mC=(()=>{class t extends fC{constructor(t){super(),this.elementRef=t}focus(){this.elementRef.nativeElement.focus()}getOffsetLeft(){return this.elementRef.nativeElement.offsetLeft}getOffsetWidth(){return this.elementRef.nativeElement.offsetWidth}}return t.\u0275fac=function(e){return new(e||t)(pa(Cl))},t.\u0275dir=ke({type:t,selectors:[["","matTabLabelWrapper",""]],hostVars:3,hostBindings:function(t,e){2&t&&(ua("aria-disabled",!!e.disabled),Ua("mat-tab-disabled",e.disabled))},inputs:{disabled:"disabled"},features:[Ko]}),t})();const gC=Hg({passive:!0});let yC=(()=>{class t{constructor(t,e,n,i,r,s,o){this._elementRef=t,this._changeDetectorRef=e,this._viewportRuler=n,this._dir=i,this._ngZone=r,this._platform=s,this._animationMode=o,this._scrollDistance=0,this._selectedIndexChanged=!1,this._destroyed=new tt,this._showPaginationControls=!1,this._disableScrollAfter=!0,this._disableScrollBefore=!0,this._stopScrolling=new tt,this.disablePagination=!1,this._selectedIndex=0,this.selectFocusedIndex=new Nc,this.indexFocused=new Nc,r.runOutsideAngular(()=>{mw(t.nativeElement,"mouseleave").pipe(Jx(this._destroyed)).subscribe(()=>{this._stopInterval()})})}get selectedIndex(){return this._selectedIndex}set selectedIndex(t){t=Rg(t),this._selectedIndex!=t&&(this._selectedIndexChanged=!0,this._selectedIndex=t,this._keyManager&&this._keyManager.updateActiveItem(t))}ngAfterViewInit(){mw(this._previousPaginator.nativeElement,"touchstart",gC).pipe(Jx(this._destroyed)).subscribe(()=>{this._handlePaginatorPress("before")}),mw(this._nextPaginator.nativeElement,"touchstart",gC).pipe(Jx(this._destroyed)).subscribe(()=>{this._handlePaginatorPress("after")})}ngAfterContentInit(){const t=this._dir?this._dir.change:Rd(null),e=this._viewportRuler.change(150),n=()=>{this.updatePagination(),this._alignInkBarToSelectedTab()};this._keyManager=new ry(this._items).withHorizontalOrientation(this._getLayoutDirection()).withHomeAndEnd().withWrap(),this._keyManager.updateActiveItem(this._selectedIndex),"undefined"!=typeof requestAnimationFrame?requestAnimationFrame(n):n(),wt(t,e,this._items.changes).pipe(Jx(this._destroyed)).subscribe(()=>{this._ngZone.run(()=>Promise.resolve().then(n)),this._keyManager.withHorizontalOrientation(this._getLayoutDirection())}),this._keyManager.change.pipe(Jx(this._destroyed)).subscribe(t=>{this.indexFocused.emit(t),this._setTabFocus(t)})}ngAfterContentChecked(){this._tabLabelCount!=this._items.length&&(this.updatePagination(),this._tabLabelCount=this._items.length,this._changeDetectorRef.markForCheck()),this._selectedIndexChanged&&(this._scrollToLabel(this._selectedIndex),this._checkScrollingControls(),this._alignInkBarToSelectedTab(),this._selectedIndexChanged=!1,this._changeDetectorRef.markForCheck()),this._scrollDistanceChanged&&(this._updateTabScrollPosition(),this._scrollDistanceChanged=!1,this._changeDetectorRef.markForCheck())}ngOnDestroy(){this._destroyed.next(),this._destroyed.complete(),this._stopScrolling.complete()}_handleKeydown(t){if(!Ag(t))switch(t.keyCode){case 13:case 32:this.focusIndex!==this.selectedIndex&&(this.selectFocusedIndex.emit(this.focusIndex),this._itemSelected(t));break;default:this._keyManager.onKeydown(t)}}_onContentChanges(){const t=this._elementRef.nativeElement.textContent;t!==this._currentTextContent&&(this._currentTextContent=t||"",this._ngZone.run(()=>{this.updatePagination(),this._alignInkBarToSelectedTab(),this._changeDetectorRef.markForCheck()}))}updatePagination(){this._checkPaginationEnabled(),this._checkScrollingControls(),this._updateTabScrollPosition()}get focusIndex(){return this._keyManager?this._keyManager.activeItemIndex:0}set focusIndex(t){this._isValidIndex(t)&&this.focusIndex!==t&&this._keyManager&&this._keyManager.setActiveItem(t)}_isValidIndex(t){if(!this._items)return!0;const e=this._items?this._items.toArray()[t]:null;return!!e&&!e.disabled}_setTabFocus(t){if(this._showPaginationControls&&this._scrollToLabel(t),this._items&&this._items.length){this._items.toArray()[t].focus();const e=this._tabListContainer.nativeElement,n=this._getLayoutDirection();e.scrollLeft="ltr"==n?0:e.scrollWidth-e.offsetWidth}}_getLayoutDirection(){return this._dir&&"rtl"===this._dir.value?"rtl":"ltr"}_updateTabScrollPosition(){if(this.disablePagination)return;const t=this.scrollDistance,e="ltr"===this._getLayoutDirection()?-t:t;this._tabList.nativeElement.style.transform=`translateX(${Math.round(e)}px)`,(this._platform.TRIDENT||this._platform.EDGE)&&(this._tabListContainer.nativeElement.scrollLeft=0)}get scrollDistance(){return this._scrollDistance}set scrollDistance(t){this._scrollTo(t)}_scrollHeader(t){return this._scrollTo(this._scrollDistance+("before"==t?-1:1)*this._tabListContainer.nativeElement.offsetWidth/3)}_handlePaginatorClick(t){this._stopInterval(),this._scrollHeader(t)}_scrollToLabel(t){if(this.disablePagination)return;const e=this._items?this._items.toArray()[t]:null;if(!e)return;const n=this._tabListContainer.nativeElement.offsetWidth,{offsetLeft:i,offsetWidth:r}=e.elementRef.nativeElement;let s,o;"ltr"==this._getLayoutDirection()?(s=i,o=s+r):(o=this._tabList.nativeElement.offsetWidth-i,s=o-r);const a=this.scrollDistance,l=this.scrollDistance+n;s<a?this.scrollDistance-=a-s+60:o>l&&(this.scrollDistance+=o-l+60)}_checkPaginationEnabled(){if(this.disablePagination)this._showPaginationControls=!1;else{const t=this._tabList.nativeElement.scrollWidth>this._elementRef.nativeElement.offsetWidth;t||(this.scrollDistance=0),t!==this._showPaginationControls&&this._changeDetectorRef.markForCheck(),this._showPaginationControls=t}}_checkScrollingControls(){this.disablePagination?this._disableScrollAfter=this._disableScrollBefore=!0:(this._disableScrollBefore=0==this.scrollDistance,this._disableScrollAfter=this.scrollDistance==this._getMaxScrollDistance(),this._changeDetectorRef.markForCheck())}_getMaxScrollDistance(){return this._tabList.nativeElement.scrollWidth-this._tabListContainer.nativeElement.offsetWidth||0}_alignInkBarToSelectedTab(){const t=this._items&&this._items.length?this._items.toArray()[this.selectedIndex]:null,e=t?t.elementRef.nativeElement:null;e?this._inkBar.alignToElement(e):this._inkBar.hide()}_stopInterval(){this._stopScrolling.next()}_handlePaginatorPress(t,e){e&&null!=e.button&&0!==e.button||(this._stopInterval(),_w(650,100).pipe(Jx(wt(this._stopScrolling,this._destroyed))).subscribe(()=>{const{maxScrollDistance:e,distance:n}=this._scrollHeader(t);(0===n||n>=e)&&this._stopInterval()}))}_scrollTo(t){if(this.disablePagination)return{maxScrollDistance:0,distance:0};const e=this._getMaxScrollDistance();return this._scrollDistance=Math.max(0,Math.min(e,t)),this._scrollDistanceChanged=!0,this._checkScrollingControls(),{maxScrollDistance:e,distance:this._scrollDistance}}}return t.\u0275fac=function(e){return new(e||t)(pa(Cl),pa(Jl),pa(Pw),pa(_y,8),pa(Au),pa(zg),pa(lA,8))},t.\u0275dir=ke({type:t,inputs:{disablePagination:"disablePagination"}}),t})(),vC=(()=>{class t extends yC{constructor(t,e,n,i,r,s,o){super(t,e,n,i,r,s,o),this._disableRipple=!1}get disableRipple(){return this._disableRipple}set disableRipple(t){this._disableRipple=kg(t)}_itemSelected(t){t.preventDefault()}}return t.\u0275fac=function(e){return new(e||t)(pa(Cl),pa(Jl),pa(Pw),pa(_y,8),pa(Au),pa(zg),pa(lA,8))},t.\u0275dir=ke({type:t,inputs:{disableRipple:"disableRipple"},features:[Ko]}),t})(),bC=(()=>{class t extends vC{constructor(t,e,n,i,r,s,o){super(t,e,n,i,r,s,o)}}return t.\u0275fac=function(e){return new(e||t)(pa(Cl),pa(Jl),pa(Pw),pa(_y,8),pa(Au),pa(zg),pa(lA,8))},t.\u0275cmp=Se({type:t,selectors:[["mat-tab-header"]],contentQueries:function(t,e,n){if(1&t&&jc(n,mC,0),2&t){let t;Gc(t=Qc())&&(e._items=t)}},viewQuery:function(t,e){if(1&t&&(Wc(QE,3),Wc(HE,3),Wc(VE,3),Wc(GE,1),Wc(WE,1)),2&t){let t;Gc(t=Qc())&&(e._inkBar=t.first),Gc(t=Qc())&&(e._tabListContainer=t.first),Gc(t=Qc())&&(e._tabList=t.first),Gc(t=Qc())&&(e._nextPaginator=t.first),Gc(t=Qc())&&(e._previousPaginator=t.first)}},hostAttrs:[1,"mat-tab-header"],hostVars:4,hostBindings:function(t,e){2&t&&Ua("mat-tab-header-pagination-controls-enabled",e._showPaginationControls)("mat-tab-header-rtl","rtl"==e._getLayoutDirection())},inputs:{selectedIndex:"selectedIndex"},outputs:{selectFocusedIndex:"selectFocusedIndex",indexFocused:"indexFocused"},features:[Ko],ngContentSelectors:RE,decls:13,vars:8,consts:[["aria-hidden","true","mat-ripple","",1,"mat-tab-header-pagination","mat-tab-header-pagination-before","mat-elevation-z4",3,"matRippleDisabled","click","mousedown","touchend"],["previousPaginator",""],[1,"mat-tab-header-pagination-chevron"],[1,"mat-tab-label-container",3,"keydown"],["tabListContainer",""],["role","tablist",1,"mat-tab-list",3,"cdkObserveContent"],["tabList",""],[1,"mat-tab-labels"],["aria-hidden","true","mat-ripple","",1,"mat-tab-header-pagination","mat-tab-header-pagination-after","mat-elevation-z4",3,"matRippleDisabled","mousedown","click","touchend"],["nextPaginator",""]],template:function(t,e){1&t&&(Na(),ga(0,"div",0,1),Ea("click",function(){return e._handlePaginatorClick("before")})("mousedown",function(t){return e._handlePaginatorPress("before",t)})("touchend",function(){return e._stopInterval()}),va(2,"div",2),ya(),ga(3,"div",3,4),Ea("keydown",function(t){return e._handleKeydown(t)}),ga(5,"div",5,6),Ea("cdkObserveContent",function(){return e._onContentChanges()}),ga(7,"div",7),La(8),ya(),va(9,"mat-ink-bar"),ya(),ya(),ga(10,"div",8,9),Ea("mousedown",function(t){return e._handlePaginatorPress("after",t)})("click",function(){return e._handlePaginatorClick("after")})("touchend",function(){return e._stopInterval()}),va(12,"div",2),ya()),2&t&&(Ua("mat-tab-header-pagination-disabled",e._disableScrollBefore),fa("matRippleDisabled",e._disableScrollBefore||e.disableRipple),Bs(5),Ua("_mat-animation-noopable","NoopAnimations"===e._animationMode),Bs(5),Ua("mat-tab-header-pagination-disabled",e._disableScrollAfter),fa("matRippleDisabled",e._disableScrollAfter||e.disableRipple))},directives:[TA,Qg,QE],styles:['.mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:"";height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.cdk-high-contrast-active .mat-ink-bar{outline:solid 2px;height:0}.mat-tab-labels{display:flex}[mat-align-tabs=center]>.mat-tab-header .mat-tab-labels{justify-content:center}[mat-align-tabs=end]>.mat-tab-header .mat-tab-labels{justify-content:flex-end}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}._mat-animation-noopable.mat-tab-list{transition:none;animation:none}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{min-width:72px}}\n'],encapsulation:2}),t})(),AC=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[[jh,fA,fw,MA,qg,xy],fA]}),t})();const xC=["primaryValueBar"];class wC{constructor(t){this._elementRef=t}}const _C=gA(wC,"primary"),SC=new Ri("mat-progress-bar-location",{providedIn:"root",factory:function(){const t=Yi(Zu),e=t?t.location:null;return{getPathname:()=>e?e.pathname+e.search:""}}});let EC=0,CC=(()=>{class t extends _C{constructor(t,e,n,i){super(t),this._elementRef=t,this._ngZone=e,this._animationMode=n,this._isNoopAnimation=!1,this._value=0,this._bufferValue=0,this.animationEnd=new Nc,this._animationEndSubscription=H.EMPTY,this.mode="determinate",this.progressbarId="mat-progress-bar-"+EC++;const r=i?i.getPathname().split("#")[0]:"";this._rectangleFillValue=`url('${r}#${this.progressbarId}')`,this._isNoopAnimation="NoopAnimations"===n}get value(){return this._value}set value(t){this._value=IC(Rg(t)||0)}get bufferValue(){return this._bufferValue}set bufferValue(t){this._bufferValue=IC(t||0)}_primaryTransform(){return{transform:`scale3d(${this.value/100}, 1, 1)`}}_bufferTransform(){return"buffer"===this.mode?{transform:`scale3d(${this.bufferValue/100}, 1, 1)`}:null}ngAfterViewInit(){this._ngZone.runOutsideAngular(()=>{const t=this._primaryValueBar.nativeElement;this._animationEndSubscription=mw(t,"transitionend").pipe(np(e=>e.target===t)).subscribe(()=>{"determinate"!==this.mode&&"buffer"!==this.mode||this._ngZone.run(()=>this.animationEnd.next({value:this.value}))})})}ngOnDestroy(){this._animationEndSubscription.unsubscribe()}}return t.\u0275fac=function(e){return new(e||t)(pa(Cl),pa(Au),pa(lA,8),pa(SC,8))},t.\u0275cmp=Se({type:t,selectors:[["mat-progress-bar"]],viewQuery:function(t,e){if(1&t&&Wc(xC,1),2&t){let t;Gc(t=Qc())&&(e._primaryValueBar=t.first)}},hostAttrs:["role","progressbar","aria-valuemin","0","aria-valuemax","100","tabindex","-1",1,"mat-progress-bar"],hostVars:4,hostBindings:function(t,e){2&t&&(ua("aria-valuenow","indeterminate"===e.mode||"query"===e.mode?null:e.value)("mode",e.mode),Ua("_mat-animation-noopable",e._isNoopAnimation))},inputs:{color:"color",mode:"mode",value:"value",bufferValue:"bufferValue"},outputs:{animationEnd:"animationEnd"},exportAs:["matProgressBar"],features:[Ko],decls:10,vars:4,consts:[["aria-hidden","true"],["width","100%","height","4","focusable","false",1,"mat-progress-bar-background","mat-progress-bar-element"],["x","4","y","0","width","8","height","4","patternUnits","userSpaceOnUse",3,"id"],["cx","2","cy","2","r","2"],["width","100%","height","100%"],[1,"mat-progress-bar-buffer","mat-progress-bar-element",3,"ngStyle"],[1,"mat-progress-bar-primary","mat-progress-bar-fill","mat-progress-bar-element",3,"ngStyle"],["primaryValueBar",""],[1,"mat-progress-bar-secondary","mat-progress-bar-fill","mat-progress-bar-element"]],template:function(t,e){1&t&&(ga(0,"div",0),pn.lFrame.currentNamespace=Xe,ga(1,"svg",1),ga(2,"defs"),ga(3,"pattern",2),va(4,"circle",3),ya(),ya(),va(5,"rect",4),ya(),pn.lFrame.currentNamespace=null,va(6,"div",5),va(7,"div",6,7),va(9,"div",8),ya()),2&t&&(Bs(3),fa("id",e.progressbarId),Bs(2),ua("fill",e._rectangleFillValue),Bs(1),fa("ngStyle",e._bufferTransform()),Bs(1),fa("ngStyle",e._primaryTransform()))},directives:[Fh],styles:['.mat-progress-bar{display:block;height:4px;overflow:hidden;position:relative;transition:opacity 250ms linear;width:100%}._mat-animation-noopable.mat-progress-bar{transition:none;animation:none}.mat-progress-bar .mat-progress-bar-element,.mat-progress-bar .mat-progress-bar-fill::after{height:100%;position:absolute;width:100%}.mat-progress-bar .mat-progress-bar-background{width:calc(100% + 10px)}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-background{display:none}.mat-progress-bar .mat-progress-bar-buffer{transform-origin:top left;transition:transform 250ms ease}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-buffer{border-top:solid 5px;opacity:.5}.mat-progress-bar .mat-progress-bar-secondary{display:none}.mat-progress-bar .mat-progress-bar-fill{animation:none;transform-origin:top left;transition:transform 250ms ease}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-fill{border-top:solid 4px}.mat-progress-bar .mat-progress-bar-fill::after{animation:none;content:"";display:inline-block;left:0}.mat-progress-bar[dir=rtl],[dir=rtl] .mat-progress-bar{transform:rotateY(180deg)}.mat-progress-bar[mode=query]{transform:rotateZ(180deg)}.mat-progress-bar[mode=query][dir=rtl],[dir=rtl] .mat-progress-bar[mode=query]{transform:rotateZ(180deg) rotateY(180deg)}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-fill,.mat-progress-bar[mode=query] .mat-progress-bar-fill{transition:none}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary,.mat-progress-bar[mode=query] .mat-progress-bar-primary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-translate 2000ms infinite linear;left:-145.166611%}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-primary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-scale 2000ms infinite linear}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary,.mat-progress-bar[mode=query] .mat-progress-bar-secondary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-translate 2000ms infinite linear;left:-54.888891%;display:block}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-secondary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-scale 2000ms infinite linear}.mat-progress-bar[mode=buffer] .mat-progress-bar-background{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-background-scroll 250ms infinite linear;display:block}.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-buffer,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-background{animation:none;transition-duration:1ms}@keyframes mat-progress-bar-primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(83.67142%)}100%{transform:translateX(200.611057%)}}@keyframes mat-progress-bar-primary-indeterminate-scale{0%{transform:scaleX(0.08)}36.65%{animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);transform:scaleX(0.08)}69.15%{animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);transform:scaleX(0.661479)}100%{transform:scaleX(0.08)}}@keyframes mat-progress-bar-secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:translateX(37.651913%)}48.35%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:translateX(84.386165%)}100%{transform:translateX(160.277782%)}}@keyframes mat-progress-bar-secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:scaleX(0.08)}19.15%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:scaleX(0.457104)}44.15%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:scaleX(0.72796)}100%{transform:scaleX(0.08)}}@keyframes mat-progress-bar-background-scroll{to{transform:translateX(-8px)}}\n'],encapsulation:2,changeDetection:0}),t})();function IC(t,e=0,n=100){return Math.max(e,Math.min(n,t))}let TC=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[[jh,fA],fA]}),t})();const MC=[FA,WA,Vx,B_,ME,Y_,uE,hE,pE,uA,AC,TC];let kC=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[MC,FA,WA,Vx,B_,ME,Y_,uE,hE,pE,uA,AC,TC]}),t})();function RC(t,e){return t===e}function NC(t,e,n){if(null===e||null===n||e.length!==n.length)return!1;const i=e.length;for(let r=0;r<i;r++)if(!t(e[r],n[r]))return!1;return!0}function LC(t,e=RC){let n=null,i=null;function r(){return NC(e,n,arguments)||(i=t.apply(null,arguments)),n=arguments,i}return r.reset=function(){n=null,i=null},r}const DC=LC(function(){const t=Fu();if(!t)return!1;const e=t.injector.get(yu,null);return!!e&&e.some(t=>(t&&t.providers||[]).some(t=>t&&t.provide&&"MockNgModuleResolver"===t.provide.name||!1))});let BC=(()=>{class t{constructor(){this.bootstrap$=new Rw(1)}get appBootstrapped$(){return this.bootstrap$.asObservable()}bootstrap(){this.bootstrap$.next(!0),this.bootstrap$.complete()}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();const OC=new Ri("INITIAL_STATE_TOKEN");let PC=(()=>{class t{static set(t){this.value=t}static pop(){const t=this.value;return this.value={},t}}return t.value={},t})();const FC=new Ri("Internals.StateContextFactory"),$C=new Ri("Internals.StateFactory");function zC(t,e){return e?n=>n.pipe(zC((n,i)=>pt(t(n,i)).pipe(it((t,r)=>e(n,t,i,r))))):e=>e.lift(new UC(t))}class UC{constructor(t){this.project=t}call(t,e){return e.subscribe(new HC(t,this.project))}}class HC extends mt{constructor(t,e){super(t),this.project=e,this.hasSubscription=!1,this.hasCompleted=!1,this.index=0}_next(t){this.hasSubscription||this.tryNext(t)}tryNext(t){let e;const n=this.index++;try{e=this.project(t,n)}catch(i){return void this.destination.error(i)}this.hasSubscription=!0,this._innerSub(e)}_innerSub(t){const e=new ft(this),n=this.destination;n.add(e);const i=gt(t,e);i!==e&&n.add(i)}_complete(){this.hasCompleted=!0,this.hasSubscription||this.destination.complete(),this.unsubscribe()}notifyNext(t){this.destination.next(t)}notifyError(t){this.destination.error(t)}notifyComplete(){this.hasSubscription=!1,this.hasCompleted&&this.destination.complete()}}const VC={STATE_NAME:t=>`${t} is not a valid state name. It needs to be a valid object property name.`,STATE_NAME_PROPERTY:()=>"States must register a 'name' property",STATE_UNIQUE:(t,e,n)=>`State name '${t}' from ${e} already exists in ${n}`,STATE_DECORATOR:()=>"States must be decorated with @State() decorator",INCORRECT_PRODUCTION:()=>"Angular is running in production mode but NGXS is still running in the development mode!\nPlease set developmentMode to false on the NgxsModule options when in production mode.\nNgxsModule.forRoot(states, { developmentMode: !environment.production })",INCORRECT_DEVELOPMENT:()=>"RECOMMENDATION: Set developmentMode to true on the NgxsModule when Angular is running in development mode.\nNgxsModule.forRoot(states, { developmentMode: !environment.production })",SELECT_FACTORY_NOT_CONNECTED:()=>"You have forgotten to import the NGXS module!",ACTION_DECORATOR:()=>"@Action() decorator cannot be used with static methods",SELECTOR_DECORATOR:()=>"Selectors only work on methods",ZONE_WARNING:()=>"Your application was bootstrapped with nooped zone and your execution strategy requires an actual NgZone!\nPlease set the value of the executionStrategy property to NoopNgxsExecutionStrategy.\nNgxsModule.forRoot(states, { executionStrategy: NoopNgxsExecutionStrategy })",PATCHING_ARRAY:()=>"Patching arrays is not supported.",PATCHING_PRIMITIVE:()=>"Patching primitives is not supported.",UNDECORATED_STATE_IN_IVY:t=>`'${t}' class should be decorated with @Injectable() right after the @State() decorator`};let GC=(()=>{class t{constructor(t,e){this._ngZone=t,this._platformId=e,this.verifyZoneIsNotNooped(this._ngZone)}enter(t){return"server"===this._platformId?this.runInsideAngular(t):this.runOutsideAngular(t)}leave(t){return this.runInsideAngular(t)}runInsideAngular(t){return Au.isInAngularZone()?t():this._ngZone.run(t)}runOutsideAngular(t){return Au.isInAngularZone()?this._ngZone.runOutsideAngular(t):t()}verifyZoneIsNotNooped(t){t instanceof Au||console.warn(VC.ZONE_WARNING())}}return t.\u0275fac=function(e){return new(e||t)(Xi(Au),Xi(ru))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();const WC=new Ri("ROOT_STATE_TOKEN"),jC=new Ri("FEATURE_STATE_TOKEN"),QC=new Ri("NGXS_PLUGINS"),qC=new Ri("NG_TEST_MODE"),XC=new Ri("NG_DEV_MODE"),YC="NGXS_META";let KC=(()=>{class t{constructor(){this.defaultsState={},this.selectorOptions={injectContainerState:!0,suppressErrors:!0},this.compatibility={strictContentSecurityPolicy:!1},this.executionStrategy=GC}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();class JC{constructor(t,e,n){this.previousValue=t,this.currentValue=e,this.firstChange=n}}const ZC=new Ri("NGXS_EXECUTION_STRATEGY");function tI(t){return t.constructor&&t.constructor.type?t.constructor.type:t.type}const eI=(t,e,n)=>{t=Object.assign({},t);const i=e.split("."),r=i.length-1;return i.reduce((t,e,i)=>(t[e]=i===r?n:Array.isArray(t[e])?t[e].slice():Object.assign({},t[e]),t&&t[e]),t),t},nI=(t,e)=>e.split(".").reduce((t,e)=>t&&t[e],t),iI=t=>t&&"object"==typeof t&&!Array.isArray(t),rI=(t,...e)=>{if(!e.length)return t;const n=e.shift();if(iI(t)&&iI(n))for(const i in n)iI(n[i])?(t[i]||Object.assign(t,{[i]:{}}),rI(t[i],n[i])):Object.assign(t,{[i]:n[i]});return rI(t,...e)};function sI(t){if(!t.hasOwnProperty(YC)){const e={name:null,actions:{},defaults:{},path:null,makeRootSelector:t=>t.getStateGetter(e.name),children:[]};Object.defineProperty(t,YC,{value:e})}return oI(t)}function oI(t){return t.NGXS_META}function aI(t,e){return e&&e.compatibility&&e.compatibility.strictContentSecurityPolicy?function(t){const e=t.slice();return t=>e.reduce((t,e)=>t&&t[e],t)}(t):function(t){const e=t;let n="store."+e[0],i=0;const r=e.length;let s=n;for(;++i<r;)s=s+" && "+(n=n+"."+e[i]);return new Function("store","return "+s+";")}(t)}function lI(t,e){const n=nI(e.currentAppState,t.path),i=nI(e.newAppState,t.path);return new JC(n,i,!t.isInitialised)}function cI(...t){return function(t,e,n=uI){const i=t.reduce((t,e)=>(t[tI(e)]=!0,t),{}),r=e&&function(t){return t.reduce((t,e)=>(t[e]=!0,t),{})}(e);return function(t){return t.pipe(function(t,e){return np(n=>{const i=tI(n.action);return t[i]&&(!e||e[n.status])})}(i,r),n())}}(t,["DISPATCHED"])}function uI(){return it(t=>t.action)}function hI(t){return e=>new X(n=>e.subscribe({next(e){t.leave(()=>n.next(e))},error(e){t.leave(()=>n.error(e))},complete(){t.leave(()=>n.complete())}}))}let dI=(()=>{class t{constructor(t){this._executionStrategy=t}enter(t){return this._executionStrategy.enter(t)}leave(t){return this._executionStrategy.leave(t)}}return t.\u0275fac=function(e){return new(e||t)(Xi(ZC))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();class pI extends tt{constructor(){super(...arguments),this._itemQueue=[],this._busyPushingNext=!1}next(t){if(this._busyPushingNext)this._itemQueue.unshift(t);else{for(this._busyPushingNext=!0,super.next(t);this._itemQueue.length>0;){const t=this._itemQueue.pop();super.next(t)}this._busyPushingNext=!1}}}let fI=(()=>{class t extends pI{}return t.\u0275fac=function(e){return mI(e||t)},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();const mI=Ci(fI);let gI=(()=>{class t extends X{constructor(t,e){super(n=>{const i=t.pipe(hI(e)).subscribe({next:t=>n.next(t),error:t=>n.error(t),complete:()=>n.complete()});n.add(i)})}}return t.\u0275fac=function(e){return new(e||t)(Xi(fI),Xi(dI))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();const yI=t=>(...e)=>t.shift()(...e,(...e)=>yI(t)(...e));let vI=(()=>{class t extends Nd{constructor(){super({})}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})(),bI=(()=>{class t{constructor(t,e){this._parentManager=t,this._pluginHandlers=e,this.plugins=[],this.registerHandlers()}get rootPlugins(){return this._parentManager&&this._parentManager.plugins||this.plugins}registerHandlers(){const t=this.getPluginHandlers();this.rootPlugins.push(...t)}getPluginHandlers(){return(this._pluginHandlers||[]).map(t=>t.handle?t.handle.bind(t):t)}}return t.\u0275fac=function(e){return new(e||t)(Xi(t,12),Xi(QC,8))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})(),AI=(()=>{class t extends tt{}return t.\u0275fac=function(e){return xI(e||t)},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();const xI=Ci(AI);let wI=(()=>{class t{constructor(t,e,n,i,r,s){this._injector=t,this._actions=e,this._actionResults=n,this._pluginManager=i,this._stateStream=r,this._ngxsExecutionStrategy=s}dispatch(t){const e=this._ngxsExecutionStrategy.enter(()=>this.dispatchByEvents(t));return e.subscribe({error:t=>this._ngxsExecutionStrategy.leave(()=>{try{this._errorHandler=this._errorHandler||this._injector.get(Vr),this._errorHandler.handleError(t)}catch(GTt){}})}),e.pipe(hI(this._ngxsExecutionStrategy))}dispatchByEvents(t){return Array.isArray(t)?0===t.length?Rd(this._stateStream.getValue()):qA(t.map(t=>this.dispatchSingle(t))):this.dispatchSingle(t)}dispatchSingle(t){if(!tI(t))return jA(new Error(`This action doesn't have a type property: ${t.constructor.name}`));const e=this._stateStream.getValue();return yI([...this._pluginManager.plugins,(t,n)=>{t!==e&&this._stateStream.next(t);const i=this.getActionResultStream(n);return i.subscribe(t=>this._actions.next(t)),this._actions.next({action:n,status:"DISPATCHED"}),this.createDispatchObservable(i)}])(e,t).pipe(Lw())}getActionResultStream(t){return this._actionResults.pipe(np(e=>e.action===t&&"DISPATCHED"!==e.status),Xd(1),Lw())}createDispatchObservable(t){return t.pipe(zC(t=>{switch(t.status){case"SUCCESSFUL":return Rd(this._stateStream.getValue());case"ERRORED":return jA(t.error);default:return Hd}})).pipe(Lw())}}return t.\u0275fac=function(e){return new(e||t)(Xi(Xo),Xi(fI),Xi(AI),Xi(bI),Xi(vI),Xi(dI))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();const _I=t=>{Object.freeze(t);const e="function"==typeof t,n=Object.prototype.hasOwnProperty;return Object.getOwnPropertyNames(t).forEach(function(i){!n.call(t,i)||e&&("caller"===i||"callee"===i||"arguments"===i)||null===t[i]||"object"!=typeof t[i]&&"function"!=typeof t[i]||Object.isFrozen(t[i])||_I(t[i])}),t};let SI=(()=>{class t{constructor(t,e){this.isDevMode=t,this.isTestMode=e}}return t.\u0275fac=function(e){return new(e||t)(Xi(XC),Xi(qC))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})(),EI=(()=>{class t{constructor(t,e){this._host=t,this._config=e}get isIncorrectProduction(){return!this._host.isDevMode()&&this._config.developmentMode}get isIncorrectDevelopment(){return this._host.isDevMode()&&!this._config.developmentMode}verifyDevMode(){this._host.isTestMode()||(this.isIncorrectProduction?console.warn(VC.INCORRECT_PRODUCTION()):this.isIncorrectDevelopment&&console.warn(VC.INCORRECT_DEVELOPMENT()))}}return t.\u0275fac=function(e){return new(e||t)(Xi(SI),Xi(KC))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})(),CI=(()=>{class t{constructor(t,e,n,i){this._stateStream=t,this._dispatcher=e,this._config=n,i.verifyDevMode()}getRootStateOperations(){const t={getState:()=>this._stateStream.getValue(),setState:t=>this._stateStream.next(t),dispatch:t=>this._dispatcher.dispatch(t)};return this._config.developmentMode?this.ensureStateAndActionsAreImmutable(t):t}ensureStateAndActionsAreImmutable(t){return{getState:()=>t.getState(),setState:e=>{const n=_I(e);return t.setState(n)},dispatch:e=>t.dispatch(e)}}setStateToTheCurrentWithNew(t){const e=this.getRootStateOperations(),n=e.getState();e.setState(Object.assign({},n,t.defaults))}}return t.\u0275fac=function(e){return new(e||t)(Xi(vI),Xi(wI),Xi(KC),Xi(EI))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})(),II=(()=>{class t{constructor(t){this._internalStateOperations=t}createStateContext(t){const e=this._internalStateOperations.getRootStateOperations();function n(e){return nI(e,t.path)}function i(n,i){const r=eI(n,t.path,i),s=t.instance;if(s.ngxsOnChanges){const e=lI(t,{currentAppState:n,newAppState:r});s.ngxsOnChanges(e)}return e.setState(r),r}function r(t,e){return i(t,e(n(t)))}return{getState:()=>n(e.getState()),patchState:t=>r(e.getState(),function(t){return e=>{if(Array.isArray(t))throw new Error(VC.PATCHING_ARRAY());if("object"!=typeof t)throw new Error(VC.PATCHING_PRIMITIVE());const n=Object.assign({},e);for(const i in t)n[i]=t[i];return n}}(t)),setState(t){const n=e.getState();return"function"==typeof t?r(n,t):i(n,t)},dispatch:t=>e.dispatch(t)}}}return t.\u0275fac=function(e){return new(e||t)(Xi(CI))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})(),TI=(()=>{class t{static stateNameErrorMessage(t){return VC.STATE_NAME(t)}static checkCorrectStateName(t){if(!t)throw new Error(VC.STATE_NAME_PROPERTY());if(!this.stateNameRegex.test(t))throw new Error(this.stateNameErrorMessage(t))}static checkStateNameIsUnique(t,e){const n=this.getValidStateMeta(t).name,i=e[n];if(i&&i!==t)throw new Error(VC.STATE_UNIQUE(n,t.name,i.name));return n}static getValidStateMeta(t){const e=oI(t);if(!e)throw new Error(VC.STATE_DECORATOR());return e}}return t.stateNameRegex=new RegExp("^[a-zA-Z0-9_]+$"),t})(),MI=(()=>{class t{constructor(t,e,n,i,r,s,o){this._injector=t,this._config=e,this._parentFactory=n,this._actions=i,this._actionResults=r,this._stateContextFactory=s,this._initialState=o,this._actionsSubscription=null,this._states=[],this._statesByName={},this._statePaths={},this.getRuntimeSelectorContext=LC(()=>{const t=this;function e(e){const n=t.statePaths[e];return n?aI(n.split("."),t._config):null}return this._parentFactory?this._parentFactory.getRuntimeSelectorContext():{getStateGetter(t){let n=e(t);return n||((...i)=>(n||(n=e(t)),n?n(...i):void 0))},getSelectorOptions:e=>Object.assign({},t._config.selectorOptions,e||{})}})}get states(){return this._parentFactory?this._parentFactory.states:this._states}get statesByName(){return this._parentFactory?this._parentFactory.statesByName:this._statesByName}get statePaths(){return this._parentFactory?this._parentFactory.statePaths:this._statePaths}static cloneDefaults(t){let e={};var n;return e=Array.isArray(t)?t.slice():"object"==typeof(n=t)&&null!==n||"function"==typeof n?Object.assign({},t):void 0===t?{}:t,e}static checkStatesAreValid(t){t.forEach(TI.getValidStateMeta)}ngOnDestroy(){this._actionsSubscription.unsubscribe()}add(e){t.checkStatesAreValid(e);const{newStates:n}=this.addToStatesMap(e);if(!n.length)return[];const i=function(t){const e=e=>{const n=t.find(t=>t===e);if(!n)throw new Error(`Child state not found: ${e}. \r\nYou may have forgotten to add states to module`);return n.NGXS_META.name};return t.reduce((t,n)=>{const{name:i,children:r}=n.NGXS_META;return t[i]=(r||[]).map(e),t},{})}(n),r=function(t){const e=[],n={},i=(r,s=[])=>{Array.isArray(s)||(s=[]),s.push(r),n[r]=!0,t[r].forEach(t=>{if(s.indexOf(t)>=0)throw new Error(`Circular dependency '${t}' is required by '${r}': ${s.join(" -> ")}`);n[t]||i(t,s.slice(0))}),e.indexOf(r)<0&&e.push(r)};return Object.keys(t).forEach(t=>i(t)),e.reverse()}(i),s=function(t,e={}){const n=(t,e)=>{for(const i in t)if(t.hasOwnProperty(i)&&t[i].indexOf(e)>=0){const e=n(t,i);return null!==e?`${e}.${i}`:i}return null};for(const i in t)if(t.hasOwnProperty(i)){const r=n(t,i);e[i]=r?`${r}.${i}`:i}return e}(i),o=n.reduce((t,e)=>(t[e.NGXS_META.name]=e,t),{}),a=[];for(const l of r){const e=o[l],n=s[l],i=e.NGXS_META;this.addRuntimeInfoToMeta(i,n);const r={name:l,path:n,isInitialised:!1,actions:i.actions,instance:this._injector.get(e),defaults:t.cloneDefaults(i.defaults)};this.hasBeenMountedAndBootstrapped(l,n)||a.push(r),this.states.push(r)}return a}addAndReturnDefaults(t){const e=this.add(t||[]);return{defaults:e.reduce((t,e)=>eI(t,e.path,e.defaults),{}),states:e}}connectActionHandlers(){null===this._actionsSubscription&&(this._actionsSubscription=this._actions.pipe(np(t=>"DISPATCHED"===t.status),yt(({action:t})=>this.invokeActions(this._actions,t).pipe(it(()=>({action:t,status:"SUCCESSFUL"})),gp({action:t,status:"CANCELED"}),sp(e=>Rd({action:t,status:"ERRORED",error:e}))))).subscribe(t=>this._actionResults.next(t)))}invokeActions(t,e){const n=tI(e),i=[];for(const s of this.states){const o=s.actions[n];if(o)for(const n of o){const o=this._stateContextFactory.createStateContext(s);try{let r=s.instance[n.fn](o,e);r instanceof Promise&&(r=pt(r)),r instanceof X?(r=r.pipe(gp({})),n.options.cancelUncompleted&&(r=r.pipe(Jx(t.pipe(cI(e)))))):r=Rd({}).pipe(Lw()),i.push(r)}catch(r){i.push(jA(r))}}}return i.length||i.push(Rd({})),qA(i)}addToStatesMap(t){const e=[],n=this.statesByName;for(const i of t){const t=TI.checkStateNameIsUnique(i,n);!n[t]&&(e.push(i),n[t]=i)}return{newStates:e}}addRuntimeInfoToMeta(t,e){this.statePaths[t.name]=e,t.path=e}hasBeenMountedAndBootstrapped(t,e){const n=void 0!==nI(this._initialState,e);return this.statesByName[t]&&n}}return t.\u0275fac=function(e){return new(e||t)(Xi(Xo),Xi(KC),Xi(t,12),Xi(fI),Xi(AI),Xi(II),Xi(OC,8))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})(),kI=(()=>{class t{constructor(t,e,n){this.internalStateOperations=t,this.stateContextFactory=e,this.bootstrapper=n}ngxsBootstrap(t,e){this.internalStateOperations.getRootStateOperations().dispatch(t).pipe(np(()=>!!e),xp(()=>this.invokeInit(e.states)),yt(()=>this.bootstrapper.appBootstrapped$),np(t=>!!t)).subscribe(()=>this.invokeBootstrap(e.states))}invokeInit(t){for(const e of t){const t=e.instance;if(t.ngxsOnChanges){const n=lI(e,{currentAppState:{},newAppState:this.internalStateOperations.getRootStateOperations().getState()});t.ngxsOnChanges(n)}t.ngxsOnInit&&t.ngxsOnInit(this.getStateContext(e)),e.isInitialised=!0}}invokeBootstrap(t){for(const e of t){const t=e.instance;t.ngxsAfterBootstrap&&t.ngxsAfterBootstrap(this.getStateContext(e))}}getStateContext(t){return this.stateContextFactory.createStateContext(t)}}return t.\u0275fac=function(e){return new(e||t)(Xi(CI),Xi(II),Xi(BC))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})(),RI=(()=>{class t{constructor(t,e,n,i,r,s){this._stateStream=t,this._internalStateOperations=e,this._config=n,this._internalExecutionStrategy=i,this._stateFactory=r,this.initStateStream(s)}dispatch(t){return this._internalStateOperations.getRootStateOperations().dispatch(t)}select(t){const e=this.getStoreBoundSelectorFn(t);return this._stateStream.pipe(it(e),sp(t=>{const{suppressErrors:e}=this._config.selectorOptions;return t instanceof TypeError&&e?Rd(void 0):jA(t)}),yw(),hI(this._internalExecutionStrategy))}selectOnce(t){return this.select(t).pipe(Xd(1))}selectSnapshot(t){return this.getStoreBoundSelectorFn(t)(this._stateStream.getValue())}subscribe(t){return this._stateStream.pipe(hI(this._internalExecutionStrategy)).subscribe(t)}snapshot(){return this._internalStateOperations.getRootStateOperations().getState()}reset(t){return this._internalStateOperations.getRootStateOperations().setState(t)}getStoreBoundSelectorFn(t){return function(t){const e=t.NGXS_SELECTOR_META||oI(t);return e&&e.makeRootSelector||(()=>t)}(t)(this._stateFactory.getRuntimeSelectorContext())}initStateStream(t){const e=this._stateStream.value;if(!e||0===Object.keys(e).length){const e=Object.keys(this._config.defaultsState).length>0?Object.assign({},this._config.defaultsState,t):t;this._stateStream.next(e)}}}return t.\u0275fac=function(e){return new(e||t)(Xi(vI),Xi(CI),Xi(KC),Xi(dI),Xi(MI),Xi(OC,8))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})(),NI=(()=>{class t{constructor(e,n){t.store=e,t.config=n}ngOnDestroy(){t.store=null,t.config=null}}return t.\u0275fac=function(e){return new(e||t)(Xi(RI),Xi(KC))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t.store=null,t.config=null,t})();class LI{static get type(){return"@@INIT"}}class DI{constructor(t){this.addedStates=t}static get type(){return"@@UPDATE_STATE"}}const BI=new Rw(1);let OI=(()=>{class t{constructor(t,e,n,i,r=[],s){!function(){try{const t=window.ng,e=!(t.probe&&t.coreTokens)&&Du();BI.next(e)}catch(GTt){BI.next(!1)}finally{BI.complete()}}();const o=t.addAndReturnDefaults(r);e.setStateToTheCurrentWithNew(o),t.connectActionHandlers(),s.ngxsBootstrap(new LI,o)}}return t.\u0275fac=function(e){return new(e||t)(Xi(MI),Xi(CI),Xi(RI),Xi(NI),Xi(WC,8),Xi(kI))},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({}),t})(),PI=(()=>{class t{constructor(e,n,i,r=[],s){const o=t.flattenStates(r),a=i.addAndReturnDefaults(o);a.states.length&&(n.setStateToTheCurrentWithNew(a),s.ngxsBootstrap(new DI(a.defaults),a))}static flattenStates(t=[]){return t.reduce((t,e)=>t.concat(e),[])}}return t.\u0275fac=function(e){return new(e||t)(Xi(RI),Xi(CI),Xi(MI),Xi(jC,8),Xi(kI))},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({}),t})(),FI=(()=>{class t{static forRoot(e=[],n={}){return{ngModule:OI,providers:[MI,II,gI,fI,BC,EI,SI,kI,wI,AI,CI,dI,RI,vI,NI,bI,...e,...t.ngxsTokenProviders(e,n)]}}static forFeature(t=[]){return{ngModule:PI,providers:[MI,bI,...t,{provide:jC,multi:!0,useValue:t}]}}static ngxsTokenProviders(e,n){return[{provide:qC,useValue:DC},{provide:XC,useValue:Du},{provide:ZC,useClass:n.executionStrategy||GC},{provide:WC,useValue:e},{provide:t.ROOT_OPTIONS,useValue:n},{provide:KC,useFactory:t.ngxsConfigFactory,deps:[t.ROOT_OPTIONS]},{provide:su,useFactory:t.appBootstrapListenerFactory,multi:!0,deps:[BC]},{provide:OC,useFactory:t.getInitialState},{provide:FC,useExisting:II},{provide:$C,useExisting:MI}]}static ngxsConfigFactory(t){return rI(new KC,t)}static appBootstrapListenerFactory(t){return()=>t.bootstrap()}static getInitialState(){return PC.pop()}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({}),t.ROOT_OPTIONS=new Ri("ROOT_OPTIONS"),t})();function $I(t,e){return(n,i)=>{if(n.hasOwnProperty("prototype"))throw new Error(VC.ACTION_DECORATOR());const r=sI(n.constructor);Array.isArray(t)||(t=[t]);for(const s of t){const t=s.type;r.actions[t]||(r.actions[t]=[]),r.actions[t].push({fn:i,options:e||{},type:t})}}}function zI(t){return e=>{!function(t){BI.subscribe(e=>{e&&(t.\u0275prov||console.warn(VC.UNDECORATED_STATE_IN_IVY(t.name)))})}(e);const n=e,i=sI(n),r=Object.getPrototypeOf(n),s=function(e){return Object.assign({},e.NGXS_OPTIONS_META||{},t)}(r);!function(t){const{meta:e,inheritedStateClass:n,optionsWithInheritance:i}=t,{children:r,defaults:s,name:o}=i,a="string"==typeof o?o:o&&o.getName()||null;TI.checkCorrectStateName(a),n.hasOwnProperty(YC)&&(e.actions=Object.assign({},e.actions,(n.NGXS_META||{}).actions)),e.children=r,e.defaults=s,e.name=a}({meta:i,inheritedStateClass:r,optionsWithInheritance:s}),n.NGXS_OPTIONS_META=s}}function UI(t,...e){return function(n,i){const r=i.toString(),s=`__${r}__selector`,o=function(t,e,n=[]){return"string"==typeof(e=e||function(t){const e=t.length-1;return 36===t.charCodeAt(e)?t.slice(0,e):t}(t))?aI(n.length?[e,...n]:e.split("."),NI.config):e}(r,t,e);Object.defineProperties(n,{[s]:{writable:!0,enumerable:!1,configurable:!0},[r]:{enumerable:!0,configurable:!0,get(){return this[s]||(this[s]=function(t){if(!NI.store)throw new Error(VC.SELECT_FACTORY_NOT_CONNECTED());return NI.store.select(t)}(o))}}})}}function HI(t,e,n,i){var r,s=arguments.length,o=s<3?e:null===i?i=Object.getOwnPropertyDescriptor(e,n):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(t,e,n,i);else for(var a=t.length-1;a>=0;a--)(r=t[a])&&(o=(s<3?r(o):s>3?r(e,n,o):r(e,n))||o);return s>3&&o&&Object.defineProperty(e,n,o),o}function VI(t,e,n,i){return new(n||(n=Promise))(function(r,s){function o(t){try{l(i.next(t))}catch(e){s(e)}}function a(t){try{l(i.throw(t))}catch(e){s(e)}}function l(t){var e;t.done?r(t.value):(e=t.value,e instanceof n?e:new n(function(t){t(e)})).then(o,a)}l((i=i.apply(t,e||[])).next())})}let GI=(()=>{class t{constructor(t,e){this.setting=t,this.value=e}}return t.type="[Settings] Set Setting",t})();const WI={receiveVideo:!1,detectSign:!0,animatePose:!1,drawVideo:!0,drawPose:!0,drawSignWriting:!0,humanizePose:!1};let jI=(()=>{let t=class{setSetting({patchState:t},{setting:e,value:n}){t({[e]:n})}};return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),HI([$I(GI)],t.prototype,"setSetting",null),t=HI([zI({name:"settings",defaults:WI})],t),t})(),QI=(()=>{class t{}return t.type="[Video] Start Camera",t})(),qI=(()=>{class t{constructor(t){this.src=t}}return t.type="[Video] Set Video",t})(),XI=(()=>{class t{}return t.type="[Video] Stop Video",t})(),YI=(()=>{class t{getCamera(t){return VI(this,void 0,void 0,function*(){try{return yield navigator.mediaDevices.getUserMedia({audio:!1,video:t})}catch(e){throw e.message.includes("Permission denied")?new Error("permissionDenied"):new Error("notConnected")}})}getMicrophone(){return VI(this,void 0,void 0,function*(){try{return yield navigator.mediaDevices.getUserMedia({audio:!0})}catch(t){throw t.message.includes("Permission denied")?new Error("permissionDenied"):new Error("notConnected")}})}getSpeaker(t){return VI(this,void 0,void 0,function*(){const e=(yield navigator.mediaDevices.enumerateDevices()).find(e=>"audiooutput"===e.kind&&t.has(e.label));if(!e)throw new Error("missingSpeaker");return e})}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const KI={camera:null,src:null,videoSettings:null,error:null};let JI=(()=>{let t=class{constructor(t){this.navigator=t}ngxsOnInit({dispatch:t}){this.receiveVideo$.pipe(np(t=>!t),xp(()=>t(XI))).subscribe()}stopVideo({patchState:t,getState:e}){const{camera:n,error:i}=e();n&&n.getTracks().forEach(t=>t.stop()),t(Object.assign(Object.assign({},KI),{error:i||"turnedOff"}))}startCamera(t){return VI(this,void 0,void 0,function*(){const{patchState:e,dispatch:n}=t;e({error:"starting"}),this.stopVideo(t);const i=()=>n(new GI("receiveVideo",!1));try{const t=yield this.navigator.getCamera({facingMode:"user",width:{min:1280},height:{min:720}});if(!t)throw new Error("notConnected");const n=t.getVideoTracks()[0],r=n.getSettings(),s={aspectRatio:this.aspectRatio(r.aspectRatio),frameRate:r.frameRate,width:r.width,height:r.height};n.addEventListener("ended",i),e({camera:t,videoSettings:s,error:null})}catch(r){e({error:r.message}),i()}})}setVideo(t,{src:e}){return VI(this,void 0,void 0,function*(){const{patchState:n}=t;n({error:null}),this.stopVideo(t);const i=document.createElement("video");i.addEventListener("loadedmetadata",()=>{const t=i.videoWidth,r=i.videoHeight,s={aspectRatio:this.aspectRatio(t/r),frameRate:null,width:t,height:r};n({src:e,videoSettings:s,error:null}),i.remove()}),i.src=e})}aspectRatio(t){return t>1.9?"2-1":t<1.5?"4-3":"16-9"}};return t.\u0275fac=function(e){return new(e||t)(Xi(YI))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),HI([UI(t=>t.settings.receiveVideo)],t.prototype,"receiveVideo$",void 0),HI([$I(XI)],t.prototype,"stopVideo",null),HI([$I(QI)],t.prototype,"startCamera",null),HI([$I(qI)],t.prototype,"setVideo",null),t=HI([zI({name:"video",defaults:KI})],t),t})();const ZI={developmentMode:!1,selectorOptions:{suppressErrors:!1,injectContainerState:!1},compatibility:{strictContentSecurityPolicy:!0}};let tT=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[[FI.forRoot([jI,JI],ZI)]]}),t})();var eT=n("EUkQ"),nT=n.n(eT);class iT{constructor(t,e){this.count=t,this.source=e}call(t,e){return e.subscribe(new rT(t,this.count,this.source))}}class rT extends W{constructor(t,e,n){super(t),this.count=e,this.source=n}error(t){if(!this.isStopped){const{source:e,count:n}=this;if(0===n)return super.error(t);n>-1&&(this.count=n-1),e.subscribe(this._unsubscribeAndRecycle())}}}class sT{constructor(t){this.translations=t}getTranslation(t){return Rd(this.translations.get(t)||{})}}const oT=new Ri("TRANSLOCO_LOADER");function aT(t,e){return t&&t.hasOwnProperty(e)?t[e]:e.split(".").reduce((t,e)=>t&&t[e],t)}function lT(t,e,n){t=Object.assign({},t);const i=e.split("."),r=i.length-1;return i.reduce((t,e,i)=>(t[e]=i===r?n:Array.isArray(t[e])?t[e].slice():Object.assign({},t[e]),t&&t[e]),t),t}function cT(t){return t?Array.isArray(t)?t.length:hT(t)?Object.keys(t).length:t?t.length:0:0}function uT(t){return"string"==typeof t}function hT(t){return t&&"object"==typeof t&&!Array.isArray(t)}function dT(t){return t.replace(/(?:^\w|[A-Z]|\b\w)/g,(t,e)=>0==e?t.toLowerCase():t.toUpperCase()).replace(/\s+|_|-|\//g,"")}function pT(t){return null==t}function fT(t){return!1===pT(t)}function mT(t){return t&&"string"==typeof t.scope}function gT(t){return nT()(t,{safe:!0})}const yT=new Ri("TRANSLOCO_CONFIG",{providedIn:"root",factory:()=>({})}),vT={defaultLang:"en",reRenderOnLangChange:!1,prodMode:!1,failedRetries:2,availableLangs:[],missingHandler:{logMissingKey:!0,useFallbackTranslation:!1,allowEmpty:!1},flatten:{aot:!1},interpolation:["{{","}}"]},bT=new Ri("TRANSLOCO_TRANSPILER");class AT{constructor(t){this.interpolationMatcher=function(t){const[e,n]=t&&t.interpolation?t.interpolation:vT.interpolation;return new RegExp(`${e}(.*?)${n}`,"g")}(t)}transpile(t,e={},n){return uT(t)?t.replace(this.interpolationMatcher,(t,i)=>(i=i.trim(),fT(e[i])?e[i]:fT(n[i])?this.transpile(n[i],e,n):"")):(e&&(hT(t)?t=this.handleObject(t,e,n):Array.isArray(t)&&(t=this.handleArray(t,e,n))),t)}handleObject(t,e={},n){let i=t;return Object.keys(e).forEach(t=>{const r=aT(i,t),s=aT(e,t),o=this.transpile(r,s,n);i=lT(i,t,o)}),i}handleArray(t,e={},n){return t.map(t=>this.transpile(t,e,n))}}const xT=new Ri("TRANSLOCO_MISSING_HANDLER");let wT=(()=>{class t{handle(t,e){return e.missingHandler.logMissingKey&&!e.prodMode&&console.warn(`%c Missing translation for '${t}'`,"font-size: 12px; color: red"),t}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();const _T=new Ri("TRANSLOCO_INTERCEPTOR");let ST=(()=>{class t{preSaveTranslation(t,e){return t}preSaveTranslationKey(t,e,n){return e}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();const ET=new Ri("TRANSLOCO_FALLBACK_STRATEGY");function CT(t){if(!t)return"";const e=t.split("/");return e.pop(),e.join("/")}function IT(t){return t?t.split("/").pop():""}function TT(t,e,n="|"){if(uT(t)){const i=t.split(n),r=i.pop();return r===e?[!0,i.toString()]:[!1,r]}return[!1,""]}function MT(t,e){const[n]=TT(e,"static");return!1===n&&t.config.reRenderOnLangChange}function kT(t){return t?t=>t:Xd(1)}function RT(t,e){return(n=t)&&hT(n.loader)?function(t,e){return Object.keys(t).reduce((n,i)=>(n[`${e}/${i}`]=t[i],n),{})}(t.loader,e):null;var n}function NT(t){return{scope:CT(t)||null,langName:IT(t),lang:t}}function LT(t,e,n,i){if(n){if(0==("function"==typeof n[t]))throw`You're using an inline loader but didn't provide a loader for ${t}`;return n[t]().then(t=>t.default?t.default:t)}return e.getTranslation(t,i)}let DT,BT=(()=>{class t{constructor(t,e,n,i,r,s){this.loader=t,this.parser=e,this.missingHandler=n,this.interceptor=i,this.userConfig=r,this.fallbackStrategy=s,this.translations=new Map,this.cache=new Map,this.firstFallbackLang=null,this.availableLangs=[],this.isResolvedMissingOnce=!1,this.events=new tt,this.events$=this.events.asObservable(),this.failedLangs=new Set,this.loader||(this.loader=new sT(this.translations)),DT=this,this.mergedConfig=function(t,e){return Object.assign({},t,e,{missingHandler:Object.assign({},t.missingHandler,e.missingHandler),flatten:Object.assign({},t.flatten,e.flatten)})}(vT,r),this.setAvailableLangs(this.mergedConfig.availableLangs),this.setFallbackLangForMissingTranslation(this.mergedConfig),this.setDefaultLang(this.mergedConfig.defaultLang),this.lang=new Nd(this.getDefaultLang()),this.langChanges$=this.lang.asObservable(),this.subscription=this.events$.subscribe(t=>{if("translationLoadSuccess"===t.type&&t.wasFailure){const e=IT(t.payload.lang);this.setActiveLang(e)}})}get config(){return this.mergedConfig}getDefaultLang(){return this.defaultLang}setDefaultLang(t){this.defaultLang=t}getActiveLang(){return this.lang.getValue()}setActiveLang(t){return this.lang.next(t),this.parser.onLangChanged&&this.parser.onLangChanged(t),this}setAvailableLangs(t){this.availableLangs=t}getAvailableLangs(){return this.availableLangs}load(t,e={}){if(!1===this.cache.has(t)){let s;const o=this._isLangScoped(t),a=o?CT(t):null;s=this.useFallbackTranslation(t)?qA((n=this.loader,i=e.inlineLoader,r={scope:a},[t,o?`${a}/${this.firstFallbackLang}`:this.firstFallbackLang].map(t=>pt(LT(t,n,i,r)).pipe(it(e=>({translation:e,lang:t})))))):pt(LT(t,this.loader,e.inlineLoader,{scope:a}));const l=s.pipe(function(t=-1){return e=>e.lift(new iT(t,e))}(this.config.failedRetries),xp(e=>{Array.isArray(e)?e.forEach(e=>{this.handleSuccess(e.lang,e.translation),e.lang!==t&&this.cache.set(e.lang,Rd({}))}):this.handleSuccess(t,e)}),sp(()=>this.handleFailure(t,e)),Lw(1));this.cache.set(t,l)}var n,i,r;return this.cache.get(t)}translate(t,e={},n=this.getActiveLang()){if(!t)return t;const{scope:i,resolveLang:r}=this.resolveLangAndScope(n);if(Array.isArray(t))return t.map(t=>this.translate(i?`${i}.${t}`:t,e,r));t=i?`${i}.${t}`:t;const s=this.getTranslation(r),o=s[t];return o?this.parser.transpile(o,e,s):this._handleMissingKey(t,o,e)}selectTranslate(t,e,n,i=!1){let r=null;const s=(n,r)=>this.load(n,r).pipe(it(()=>i?this.translateObject(t,e,n):this.translate(t,e,n)));if(pT(n))return this.langChanges$.pipe(Wd(t=>s(t)));if(mT(n)){const t=n;n=t.scope,r=RT(t,t.scope)}if(this.isLang(n=n)||this.isScopeWithLang(n))return s(n);const o=n;return this.langChanges$.pipe(Wd(t=>s(`${o}/${t}`,{inlineLoader:r})))}isScopeWithLang(t){return this.isLang(IT(t))}translateObject(t,e,n=this.getActiveLang()){if(uT(t)||Array.isArray(t)){if(Array.isArray(t))return t.map(t=>this.translateObject(s?`${s}.${t}`:t,e,r));const{resolveLang:r,scope:s}=this.resolveLangAndScope(n),o=this.getTranslation(r),a=(i=this.getObjectByKey(o,t=s?`${s}.${t}`:t),nT.a.unflatten(i,{safe:!0}));return 0===cT(a)?this.translate(t,e,n):this.parser.transpile(a,e,o)}var i;const r=[];for(const[s,o]of this.getEntries(t))r.push(this.translateObject(s,o,n));return r}selectTranslateObject(t,e,n){if(uT(t)||Array.isArray(t))return this.selectTranslate(t,e,n,!0);const[[i,r],...s]=this.getEntries(t);return this.selectTranslateObject(i,r,n).pipe(it(t=>{const e=[t];for(const[i,r]of s)e.push(this.translateObject(i,r,n));return e}))}getTranslation(t){if(t){if(this.isLang(t))return this.translations.get(t)||{};{const{scope:e,resolveLang:n}=this.resolveLangAndScope(t),i=this.translations.get(n)||{};return this.getObjectByKey(i,e)}}return this.translations}selectTranslation(t){let e=this.langChanges$;if(t){const n=IT(t)!==t;e=this.isLang(t)||n?Rd(t):this.langChanges$.pipe(it(e=>`${t}/${e}`))}return e.pipe(Wd(t=>this.load(t).pipe(it(()=>this.getTranslation(t)))))}setTranslation(t,e=this.getActiveLang(),n={}){const i=Object.assign({},{merge:!0,emitChange:!0},n),r=CT(e);let s=t;r&&(s=gT({[this.getMappedScope(r)]:t}));const o=r?IT(e):e,a=Object.assign({},i.merge&&this.getTranslation(o),s),l=this.mergedConfig.flatten.aot?a:gT(a),c=this.interceptor.preSaveTranslation(l,o);this.translations.set(o,c),i.emitChange&&this.setActiveLang(this.getActiveLang())}setTranslationKey(t,e,n=this.getActiveLang(),i={}){const r=this.interceptor.preSaveTranslationKey(t,e,n);this.setTranslation({[t]:r},n,Object.assign({},i,{merge:!0}))}setFallbackLangForMissingTranslation({fallbackLang:t}){const e=Array.isArray(t)?t[0]:t;this.useFallbackTranslation(e)&&t&&(this.firstFallbackLang=e)}_handleMissingKey(t,e,n){if(this.config.missingHandler.allowEmpty&&""===e)return"";if(this.useFallbackTranslation()&&!this.isResolvedMissingOnce){this.isResolvedMissingOnce=!0;const e=this.translate(t,n,this.firstFallbackLang);return this.isResolvedMissingOnce=!1,e}return this.missingHandler.handle(t,this.getMissingHandlerData(),n)}_isLangScoped(t){return-1===this.getAvailableLangsIds().indexOf(t)}isLang(t){return-1!==this.getAvailableLangsIds().indexOf(t)}_loadDependencies(t,e){const n=IT(t);return this._isLangScoped(t)&&!this.isLoadedTranslation(n)?Pd(this.load(n),this.load(t,{inlineLoader:e})):this.load(t,{inlineLoader:e})}_completeScopeWithLang(t){return this._isLangScoped(t)&&!this.isLang(IT(t))?`${t}/${this.getActiveLang()}`:t}_setScopeAlias(t,e){this.mergedConfig.scopeMapping||(this.mergedConfig.scopeMapping={}),this.mergedConfig.scopeMapping[t]=e}ngOnDestroy(){this.subscription.unsubscribe()}isLoadedTranslation(t){return cT(this.getTranslation(t))}getAvailableLangsIds(){return uT(this.getAvailableLangs()[0])?this.getAvailableLangs():this.getAvailableLangs().map(t=>t.id)}getMissingHandlerData(){return Object.assign({},this.config,{activeLang:this.getActiveLang(),availableLangs:this.availableLangs,defaultLang:this.defaultLang})}useFallbackTranslation(t){return this.config.missingHandler.useFallbackTranslation&&t!==this.firstFallbackLang}handleSuccess(t,e){this.setTranslation(e,t,{emitChange:!1}),this.events.next({wasFailure:!!this.failedLangs.size,type:"translationLoadSuccess",payload:NT(t)}),this.failedLangs.forEach(t=>this.cache.delete(t)),this.failedLangs.clear()}handleFailure(t,e){pT(e.failedCounter)&&(e.failedCounter=0,e.fallbackLangs||(e.fallbackLangs=this.fallbackStrategy.getNextLangs(t)));const n=t.split("/"),i=e.fallbackLangs[e.failedCounter];if(this.failedLangs.add(t),this.cache.has(i))return this.handleSuccess(i,this.getTranslation(i)),Hd;if(!i||i===n[n.length-1]){let t="Unable to load translation and all the fallback languages";throw n.length>1&&(t+=", did you misspelled the scope name?"),new Error(t)}let r=i;return n.length>1&&(n[n.length-1]=i,r=n.join("/")),e.failedCounter++,this.events.next({type:"translationLoadFailure",payload:NT(t)}),this.load(r,e)}getMappedScope(t){const{scopeMapping:e={}}=this.config;return e[t]||dT(t)}resolveLangAndScope(t){let e,n=t;if(this._isLangScoped(t)){const i=IT(t),r=this.isLang(i);n=r?i:this.getActiveLang(),e=this.getMappedScope(r?CT(t):t)}return{scope:e,resolveLang:n}}getObjectByKey(t,e){const n={},i=`${e}.`;for(const r in t)r.startsWith(i)&&(n[r.replace(i,"")]=t[r]);return n}getEntries(t){return t instanceof Map?t.entries():Object.entries(t)}}return t.\u0275fac=function(e){return new(e||t)(Xi(oT,8),Xi(bT),Xi(xT),Xi(_T),Xi(yT),Xi(ET))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac,providedIn:"root"}),t.ngInjectableDef=jt({factory:function(){return new t(Yi(oT,8),Yi(bT),Yi(xT),Yi(_T),Yi(yT),Yi(ET))},token:t,providedIn:"root"}),t})(),OT=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=Se({type:t,selectors:[["ng-component"]],inputs:{html:"html"},decls:1,vars:1,consts:[[1,"transloco-loader-template",3,"innerHTML"]],template:function(t,e){1&t&&va(0,"div",0),2&t&&fa("innerHTML",e.html,$r)},encapsulation:2}),t})();class PT{constructor(t,e){this.view=t,this.vcr=e,this.injector=this.vcr.injector}attachView(){if(this.view instanceof rc)this.vcr.createEmbeddedView(this.view);else if(uT(this.view)){const t=this.createComponent(OT);t.instance.html=this.view,t.hostView.detectChanges()}else this.createComponent(this.view)}detachView(){this.vcr.clear()}createComponent(t){const e=this.injector.get(wl).resolveComponentFactory(t);return this.vcr.createComponent(e)}}const FT=new Ri("TRANSLOCO_LANG"),$T=new Ri("TRANSLOCO_LOADING_TEMPLATE"),zT=new Ri("TRANSLOCO_SCOPE");class UT{constructor(){this.initialized=!1}resolve({inline:t,provider:e,active:n}={inline:void 0,provider:void 0,active:void 0}){let i=n;if(this.initialized)return i=n,i;if(e){const[t,n]=TT(e,"static");i=n}if(t){const[e,n]=TT(t,"static");i=n}return this.initialized=!0,i}resolveLangBasedOnScope(t){return CT(t)?IT(t):t}resolveLangPath(t,e){return e?`${e}/${t}`:t}}class HT{constructor(t){this.translocoService=t}resolve({inline:t,provider:e}={inline:void 0,provider:void 0}){if(t)return t;if(e){if(mT(e)){const{scope:t,alias:n=dT(t)}=e;return this.translocoService._setScopeAlias(t,n),t}return e}}}let VT=(()=>{class t{constructor(t,e,n,i,r,s,o,a){this.translocoService=t,this.tpl=e,this.providerScope=n,this.providerLang=i,this.providedLoadingTpl=r,this.vcr=s,this.cdr=o,this.host=a,this.translationMemo={},this.params={},this.loaderTplHandler=null,this.initialized=!1,this.langResolver=new UT,this.scopeResolver=new HT(this.translocoService)}ngOnInit(){const t=MT(this.translocoService,this.providerLang||this.inlineLang);this.subscription=this.translocoService.langChanges$.pipe(Wd(t=>{const e=this.langResolver.resolve({inline:this.inlineLang,provider:this.providerLang,active:t});return Array.isArray(this.providerScope)?qA(this.providerScope.map(t=>this.resolveScope(e,t))):this.resolveScope(e,this.providerScope)}),kT(t)).subscribe(()=>{this.currentLang=this.langResolver.resolveLangBasedOnScope(this.path),null===this.tpl?this.simpleStrategy():this.structuralStrategy(this.currentLang,this.inlineRead),this.cdr.markForCheck(),this.initialized=!0});const e=this.getLoadingTpl();!this.initialized&&e&&(this.loaderTplHandler=new PT(e,this.vcr),this.loaderTplHandler.attachView())}ngOnChanges(t){Object.keys(t).some(e=>!1===t[e].firstChange)&&this.simpleStrategy()}simpleStrategy(){this.detachLoader(),this.host.nativeElement.innerText=this.translocoService.translate(this.key,this.params,this.currentLang)}structuralStrategy(t,e){this.translationMemo={},this.view?(this.view.context.$implicit=this.getTranslateFn(t,e),this.view.context.currentLang=this.currentLang):(this.detachLoader(),this.view=this.vcr.createEmbeddedView(this.tpl,{$implicit:this.getTranslateFn(t,e),currentLang:this.currentLang}))}getTranslateFn(t,e){return(n,i)=>{const r=e?`${e}.${n}`:n,s=i?`${r}${JSON.stringify(i)}`:r;return this.translationMemo.hasOwnProperty(s)||(this.translationMemo[s]={params:i,value:this.translocoService.translate(r,i,t)}),this.translationMemo[s].value}}getLoadingTpl(){return this.inlineTpl||this.providedLoadingTpl}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}detachLoader(){this.loaderTplHandler&&this.loaderTplHandler.detachView()}resolveScope(t,e){let n=this.scopeResolver.resolve({inline:this.inlineScope,provider:e});this.path=this.langResolver.resolveLangPath(t,n);const i=RT(e,n);return this.translocoService._loadDependencies(this.path,i)}}return t.\u0275fac=function(e){return new(e||t)(pa(BT),pa(rc,8),pa(zT,8),pa(FT,8),pa($T,8),pa(hc),pa(Jl),pa(Cl))},t.\u0275dir=ke({type:t,selectors:[["","transloco",""]],inputs:{params:["translocoParams","params"],key:["transloco","key"],inlineScope:["translocoScope","inlineScope"],inlineRead:["translocoRead","inlineRead"],inlineLang:["translocoLang","inlineLang"],inlineTpl:["translocoLoadingTpl","inlineTpl"]},features:[Ge]}),t})(),GT=(()=>{class t{constructor(t,e,n,i){this.translocoService=t,this.providerScope=e,this.providerLang=n,this.cdr=i,this.subscription=null,this.lastValue="",this.langResolver=new UT,this.scopeResolver=new HT(this.translocoService),this.listenToLangChange=MT(this.translocoService,this.providerLang)}transform(t,e,n){if(!t)return t;const i=e?`${t}${JSON.stringify(e)}`:t;return i===this.lastKey||(this.lastKey=i,this.subscription&&this.subscription.unsubscribe(),this.subscription=this.translocoService.langChanges$.pipe(Wd(t=>{const e=this.langResolver.resolve({inline:n,provider:this.providerLang,active:t});return Array.isArray(this.providerScope)?qA(this.providerScope.map(t=>this.resolveScope(e,t))):this.resolveScope(e,this.providerScope)}),kT(this.listenToLangChange)).subscribe(()=>this.updateValue(t,e))),this.lastValue}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}updateValue(t,e){const n=this.langResolver.resolveLangBasedOnScope(this.path);this.lastValue=this.translocoService.translate(t,e,n),this.cdr.markForCheck()}resolveScope(t,e){let n=this.scopeResolver.resolve({inline:void 0,provider:e});this.path=this.langResolver.resolveLangPath(t,n);const i=RT(e,n);return this.translocoService._loadDependencies(this.path,i)}}return t.\u0275fac=function(e){return new(e||t)(pa(BT),pa(zT,8),pa(FT,8),Kc())},t.\u0275pipe=Re({name:"transloco",type:t,pure:!1}),t})();const WT=[{provide:bT,useClass:AT,deps:[yT]},{provide:xT,useClass:wT},{provide:_T,useClass:ST},{provide:ET,useClass:class{constructor(t){this.userConfig=t}getNextLangs(t){const e=this.userConfig.fallbackLang;if(!e)throw new Error("When using the default fallback, a fallback language must be provided in the config!");return Array.isArray(e)?e:[e]}},deps:[yT]}];let jT=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({providers:[WT]}),t})();new Ri("TRANSLOCO_TEST_LANGS - Available testing languages"),new Ri("TRANSLOCO_TEST_OPTIONS - Testing options");var QT=n("qkWt");const qT=new Ri("TRANSLOCO_MESSAGE_FORMAT_CONFIG");function XT(t,e){return new QT(t,e)}let YT=(()=>{class t extends AT{constructor(t,e){super(e);const n=t||{locales:void 0},{locales:i}=n,r=function(t,e){var n={};for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&e.indexOf(i)<0&&(n[i]=t[i]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(i=Object.getOwnPropertySymbols(t);r<i.length;r++)e.indexOf(i[r])<0&&Object.prototype.propertyIsEnumerable.call(t,i[r])&&(n[i[r]]=t[i[r]])}return n}(n,["locales"]);this.messageConfig=r,this.messageFormat=XT(i,r)}transpile(t,e={},n){if(!t)return t;if(hT(t)&&e)Object.keys(e).forEach(i=>{const r=aT(t,i),s=aT(e,i),o=super.transpile(r,s,n),a=this.messageFormat.compile(o);t=lT(t,i,a(e[i]))});else if(!Array.isArray(t)){const i=super.transpile(t,e,n);return this.messageFormat.compile(i)(e)}return t}onLangChanged(t){this.setLocale(t)}setLocale(t){this.messageFormat=XT(t,this.messageConfig)}}return t.\u0275fac=function(e){return new(e||t)(Xi(qT,8),Xi(yT,8))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})(),KT=(()=>{class t{constructor(){}static init(e){return{ngModule:t,providers:[{provide:qT,useValue:e},{provide:bT,useClass:YT}]}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({}),t})();const JT={provide:oT,useClass:(()=>{class t{constructor(t){this.http=t}getTranslation(t){return this.http.get(`assets/i18n/${t}.json`)}}return t.\u0275fac=function(e){return new(e||t)(Xi(dx))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})()};let ZT=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({providers:[{provide:yT,useValue:{availableLangs:["en","es"],defaultLang:"en",prodMode:true}},JT],imports:[[Ix,KT.init()],jT]}),t})();const tM=[tT,ZT,kC,jh];let eM=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[tM,tT,ZT,kC,jh]}),t})();var nM=n("EUiz"),iM=n("aOSE");const rM=[0,1,2,3,4,5,6,7,8,9,10,15,16,17,18,19,20,21,22];let sM=(()=>{class t{load(){return VI(this,void 0,void 0,function*(){this.model=new nM.Holistic({locateFile:t=>`assets/models/holistic/${t}`}),this.model.setOptions({upperBodyOnly:!1,modelComplexity:1})})}predict(t){return VI(this,void 0,void 0,function*(){if(!this.model)return Promise.resolve(null);yield this.model.send({image:t})})}drawBody(t,e){const n=Array.from(t);for(const i of rM)delete n[i];iM.drawConnectors(e,n,nM.POSE_CONNECTIONS,{color:"#00FF00"}),iM.drawLandmarks(e,n,{color:"#00FF00",fillColor:"#FF0000"})}drawHand(t,e,n,i,r){iM.drawConnectors(e,t,nM.HAND_CONNECTIONS,{color:n}),iM.drawLandmarks(e,t,{color:i,fillColor:r,lineWidth:2,radius:t=>iM.lerp(t.z,-.15,.1,10,1)})}drawFace(t,e){iM.drawConnectors(e,t,nM.FACEMESH_TESSELATION,{color:"#C0C0C070",lineWidth:1}),iM.drawConnectors(e,t,nM.FACEMESH_RIGHT_EYE,{color:"#FF3030"}),iM.drawConnectors(e,t,nM.FACEMESH_RIGHT_EYEBROW,{color:"#FF3030"}),iM.drawConnectors(e,t,nM.FACEMESH_LEFT_EYE,{color:"#30FF30"}),iM.drawConnectors(e,t,nM.FACEMESH_LEFT_EYEBROW,{color:"#30FF30"}),iM.drawConnectors(e,t,nM.FACEMESH_FACE_OVAL,{color:"#E0E0E0"}),iM.drawConnectors(e,t,nM.FACEMESH_LIPS,{color:"#E0E0E0"})}drawConnect(t,e){for(const n of t){const t=n[0],i=n[1];if(t&&i){if(t.visibility&&i.visibility&&(t.visibility<.1||i.visibility<.1))continue;e.beginPath(),e.moveTo(t.x*e.canvas.width,t.y*e.canvas.height),e.lineTo(i.x*e.canvas.width,i.y*e.canvas.height),e.stroke()}}}drawElbowHandsConnection(t,e){e.lineWidth=5,t.rightHandLandmarks&&(e.strokeStyle="#00FF00",this.drawConnect([[t.poseLandmarks[nM.POSE_LANDMARKS.RIGHT_ELBOW],t.rightHandLandmarks[0]]],e)),t.leftHandLandmarks&&(e.strokeStyle="#FF0000",this.drawConnect([[t.poseLandmarks[nM.POSE_LANDMARKS.LEFT_ELBOW],t.leftHandLandmarks[0]]],e))}draw(t,e){t.poseLandmarks&&(this.drawBody(t.poseLandmarks,e),this.drawElbowHandsConnection(t,e)),t.leftHandLandmarks&&this.drawHand(t.leftHandLandmarks,e,"#CC0000","#FF0000","#00FF00"),t.rightHandLandmarks&&this.drawHand(t.rightHandLandmarks,e,"#00CC00","#00FF00","#FF0000"),t.faceLandmarks&&this.drawFace(t.faceLandmarks,e),e.restore()}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})(),oM=(()=>{class t{}return t.type="[Pose] Load Pose Model",t})(),aM=(()=>{class t{constructor(t){this.video=t}}return t.type="[Pose] Pose Video Frame",t})(),lM=(()=>{class t{constructor(t){this.pose=t}}return t.type="[Pose] Store Frame Pose",t})();const cM={x:0,y:0,z:0},uM={isLoaded:!1,pose:null};let hM=(()=>{let t=class{constructor(t,e){this.poseService=t,this.store=e}ngxsOnInit(t){this.store.dispatch(oM)}load({patchState:t}){return VI(this,void 0,void 0,function*(){t({isLoaded:!1}),yield this.poseService.load(),this.poseService.model.onResults(t=>this.store.dispatch(new lM(t)))})}poseFrame({},{video:t}){return VI(this,void 0,void 0,function*(){yield this.poseService.predict(t)})}storePose({patchState:t},{pose:e}){t({isLoaded:!0,pose:e})}};return t.\u0275fac=function(e){return new(e||t)(Xi(sM),Xi(RI))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),HI([$I(oM)],t.prototype,"load",null),HI([$I(aM)],t.prototype,"poseFrame",null),HI([$I(lM)],t.prototype,"storePose",null),t=HI([zI({name:"pose",defaults:uM})],t),t})();class dM{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class pM{refCount(t){return fM("refCount")}incRef(t){return fM("incRef")}timerAvailable(){return!0}time(t){return fM("time")}read(t){return fM("read")}readSync(t){return fM("readSync")}numDataIds(){return fM("numDataIds")}disposeData(t,e){return fM("disposeData")}write(t,e,n){return fM("write")}move(t,e,n,i,r){return fM("move")}memory(){return fM("memory")}floatPrecision(){return fM("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return fM("dispose")}}function fM(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function mM(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,bM(t,e,n)}function gM(t,e){if(t.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${t.length}Second array length was ${e.length}`);let n=t.length,i=0;for(;n>0;)i=Math.random()*n|0,n--,bM(t,n,i),bM(e,n,i)}function yM(t,e,n){return Math.max(t,Math.min(e,n))}function vM(t){return t%2==0?t:t+1}function bM(t,e,n){const i=t[e];t[e]=t[n],t[n]=i}function AM(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function xM(t,e){const n=Math.random();return e*n+(1-n)*t}function wM(t,e){let n=0;for(let i=0;i<t.length;i++){const r=Number(t[i])-Number(e[i]);n+=r*r}return n}function _M(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function SM(t,e,n=""){_M(MM(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function EM(t){_M(null!=t,()=>"The input to the tensor constructor must be a non-null value.")}function CM(t,e=[],n=!1){if(null==e&&(e=[]),Array.isArray(t)||GM(t)&&!n)for(let i=0;i<t.length;++i)CM(t[i],e,n);else e.push(t);return e}function IM(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function TM(t){return 0===t.length}function MM(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function kM(t){return t%1==0}function RM(t){if(null!=Math.tanh)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{const e=Math.exp(2*t);return(e-1)/(e+1)}}function NM(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function LM(t){const e=new Uint32Array(t);for(let n=0;n<t;++n)e[n]=n;return mM(e),e}function DM(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function BM(t,e=(t=>0),n){return new Promise((i,r)=>{let s=0;const o=()=>{if(t())return void i();s++;const a=e(s);null!=n&&s>=n?r():setTimeout(o,a)};o()})}function OM(t,e){let n=1,i=-1;for(let s=0;s<t.length;++s)if(t[s]>=0)n*=t[s];else if(-1===t[s]){if(-1!==i)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${i} and dim ${s}`);i=s}else if(t[s]<0)throw Error(`Shapes can not be < 0. Found ${t[s]} at dim ${s}`);if(-1===i){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(0===n)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const r=t.slice();return r[i]=e/n,r}function PM(t,e){const n=e.length;return _M((t=null==t?e.map((t,e)=>e):[].concat(t)).every(t=>t>=-n&&t<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),_M(t.every(t=>kM(t)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(t=>t<0?n+t:t)}function FM(t,e){const n=[],i=[],r=null!=e&&Array.isArray(e)&&0===e.length,s=null==e||r?null:PM(e,t).sort();let o=0;for(let a=0;a<t.length;++a){if(null!=s){if(s[o]===a&&1!==t[a])throw new Error(`Can't squeeze axis ${a} since its dim '${t[a]}' is not 1`);(null==s[o]||s[o]>a)&&1===t[a]&&(n.push(t[a]),i.push(a)),s[o]<=a&&o++}1!==t[a]&&(n.push(t[a]),i.push(a))}return{newShape:n,keptDims:i}}function $M(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else{if("bool"!==t)throw new Error(`Unknown data type ${t}`);n=new Uint8Array(e)}return n}function zM(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error(`Unknown data type ${t}`);n=new Array(e)}return n}function UM(t,e){for(let n=0;n<t.length;n++){const i=t[n];if(isNaN(i)||!isFinite(i))throw Error(`A tensor of type ${e} being uploaded contains ${i}.`)}}function HM(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}function VM(t,e){return!("complex64"===e||"float32"===e&&"complex64"!==t||"int32"===e&&"float32"!==t&&"complex64"!==t||"bool"===e&&"bool"===t)}function GM(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function WM(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error(`Unknown dtype ${t}`)}function jM(t){if(null==t)return 0;let e=0;return t.forEach(t=>e+=t.length),e}function QM(t){return"string"==typeof t||t instanceof String}function qM(t){return"boolean"==typeof t}function XM(t){return"number"==typeof t}function YM(t){return Array.isArray(t)?YM(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array?"int32":XM(t)?"float32":QM(t)?"string":qM(t)?"bool":"float32"}function KM(t){return!!(t&&t.constructor&&t.call&&t.apply)}function JM(t,e){for(let n=e;n<t;++n)if(t%n==0)return n;return t}function ZM(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let i=e-3;i>=0;--i)n[i]=n[i+1]*t[i+1];return n}function tk(t,e,n,i=!1){const r=new Array;if(1===e.length){const s=e[0]*(i?2:1);for(let e=0;e<s;e++)r[e]=n[t+e]}else{const s=e[0],o=e.slice(1),a=o.reduce((t,e)=>t*e)*(i?2:1);for(let e=0;e<s;e++)r[e]=tk(t+e*a,o,n,i)}return r}function ek(t,e,n=!1){if(0===t.length)return e[0];const i=t.reduce((t,e)=>t*e)*(n?2:1);if(0===i)return[];if(i!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return tk(0,t,e,n)}function nk(t,e){const n=ik(t,e);for(let i=0;i<n.length;i++)n[i]=1;return n}function ik(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function rk(t,e){const n=t.reduce((t,e)=>t*e,1);if(null==e||"float32"===e)return ek(t,new Float32Array(n));if("int32"===e)return ek(t,new Int32Array(n));if("bool"===e)return ek(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function sk(t){t.forEach(e=>{_M(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function ok(t,e,n){if(0===e)return 0;if(1===e)return t[0];let i=t[t.length-1];for(let r=0;r<t.length-1;++r)i+=n[r]*t[r];return i}function ak(t,e,n){if(0===e)return[];if(1===e)return[t];const i=new Array(e);for(let r=0;r<i.length-1;++r)i[r]=Math.floor(t/n[r]),t-=i[r]*n[r];return i[i.length-1]=t,i}function lk(t){return t&&t.then&&"function"==typeof t.then}class ck{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=uk,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];console.warn(`Setting feature override from URL ${t}: ${e}.`),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(lk(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);"tfjsflags"in t&&t.tfjsflags.split(",").forEach(t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}(e,n)})}}function uk(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...n)=>(function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("="))),e}function hk(){return pk}let dk,pk=null;function fk(){if(null==dk){let t;if("undefined"!=typeof window)t=window;else if("undefined"!=typeof global)t=global;else if("undefined"!=typeof process)t=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}dk=t}return dk}function mk(t,e){const n=function(){const t=fk();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const i=e();return n.set(t,i),n.get(t)}}const gk="Abs",yk="Acos",vk="Acosh",bk="Add",Ak="AddN",xk="All",wk="Any",_k="ArgMax",Sk="ArgMin",Ek="Asin",Ck="Asinh",Ik="Atan",Tk="Atanh",Mk="Atan2",kk="AvgPool",Rk="AvgPoolGrad",Nk="AvgPool3D",Lk="AvgPool3DGrad",Dk="BatchMatMul",Bk="BatchToSpaceND",Ok="Bincount",Pk="Cast",Fk="Ceil",$k="ClipByValue",zk="Complex",Uk="ComplexAbs",Hk="Concat",Vk="Conv2D",Gk="Conv2DBackpropFilter",Wk="Conv2DBackpropInput",jk="Conv3D",Qk="Conv3DBackpropFilterV2",qk="Conv3DBackpropInputV2",Xk="Cos",Yk="Cosh",Kk="Cumsum",Jk="CropAndResize",Zk="DenseBincount",tR="DepthToSpace",eR="DepthwiseConv2dNative",nR="DepthwiseConv2dNativeBackpropFilter",iR="DepthwiseConv2dNativeBackpropInput",rR="Diag",sR="Dilation2D",oR="Dilation2DBackpropInput",aR="Dilation2DBackpropFilter",lR="RealDiv",cR="Einsum",uR="Elu",hR="EluGrad",dR="Erf",pR="Equal",fR="Exp",mR="ExpandDims",gR="Expm1",yR="FFT",vR="Fill",bR="FlipLeftRight",AR="Floor",xR="FloorDiv",wR="FusedBatchNorm",_R="GatherV2",SR="GatherNd",ER="Greater",CR="GreaterEqual",IR="Identity",TR="IFFT",MR="Imag",kR="IsFinite",RR="IsInf",NR="IsNan",LR="LeakyRelu",DR="Less",BR="LessEqual",OR="LinSpace",PR="Log",FR="Log1p",$R="LogicalAnd",zR="LogicalNot",UR="LogicalOr",HR="LRN",VR="LRNGrad",GR="Max",WR="Maximum",jR="MaxPool",QR="MaxPoolGrad",qR="MaxPool3D",XR="MaxPool3DGrad",YR="MaxPoolWithArgmax",KR="Mean",JR="Min",ZR="Minimum",tN="MirrorPad",eN="Mod",nN="Multinomial",iN="Multiply",rN="Neg",sN="NotEqual",oN="NonMaxSuppressionV3",aN="NonMaxSuppressionV4",lN="NonMaxSuppressionV5",cN="OnesLike",uN="OneHot",hN="Pack",dN="PadV2",pN="Pow",fN="Prelu",mN="Prod",gN="Range",yN="Real",vN="Reciprocal",bN="Relu",AN="Reshape",xN="ResizeNearestNeighbor",wN="ResizeNearestNeighborGrad",_N="ResizeBilinear",SN="ResizeBilinearGrad",EN="Relu6",CN="Reverse",IN="Round",TN="Rsqrt",MN="ScatterNd",kN="Select",RN="Selu",NN="Slice",LN="Sin",DN="Sinh",BN="Sign",ON="Sigmoid",PN="Softplus",FN="Sqrt",$N="Sum",zN="SpaceToBatchND",UN="SplitV",HN="Softmax",VN="SparseFillEmptyRows",GN="SparseReshape",WN="SparseSegmentMean",jN="SparseSegmentSum",QN="SparseToDense",qN="SquaredDifference",XN="Square",YN="StridedSlice",KN="StringNGrams",JN="StringSplit",ZN="StringToHashBucketFast",tL="Sub",eL="Tan",nL="Tanh",iL="Tile",rL="TopK",sL="Transform",oL="Transpose",aL="Unique",lL="Unpack",cL="UnsortedSegmentSum",uL="ZerosLike",hL="Step",dL="FromPixels",pL="RotateWithOffset",fL="_FusedMatMul",mL="FusedConv2D",gL="FusedDepthwiseConv2D",yL=mk("kernelRegistry",()=>new Map),vL=mk("gradRegistry",()=>new Map);function bL(t,e){const n=SL(t,e);return yL.get(n)}function AL(t){return vL.get(t)}function xL(t){const e=yL.entries(),n=[];for(;;){const{done:i,value:r}=e.next();if(i)break;const[s,o]=r,[a]=s.split("_");a===t&&n.push(o)}return n}function wL(t){const{kernelName:e,backendName:n}=t,i=SL(e,n);yL.has(i)&&console.warn(`The kernel '${e}' for backend '${n}' is already registered`),yL.set(i,t)}function _L(t){const{kernelName:e}=t;vL.has(e)&&hk().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${e}'`),vL.set(e,t)}function SL(t,e){return`${e}_${t}`}var EL=n("2lpH");const CL=n.n(EL).a||EL;function IL(t){return CL.fromString(t,!0,16)}const TL=IL("c3a5c85c97cb3127"),ML=IL("b492b66fbe98f273"),kL=IL("9ae16a3b2f90404f");function RL(t){return t.xor(t.shru(47))}function NL(t,e,n){const i=t.slice(e,e+n);return CL.fromBytes(Array.from(i),!0,!0)}function LL(t,e){return NL(t,e,8)}function DL(t,e){return NL(t,e,4)}function BL(t,e){return 0===e?t:t.shru(e).or(t.shl(64-e))}function OL(t,e,n=IL("9ddfea08eb382d69")){let i=t.xor(e).mul(n);i=i.xor(i.shru(47));let r=e.xor(i).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function PL(t,e,n,i){return function(t,e,n,i,r,s){r=r.add(t),s=BL(s.add(r).add(i),21);const o=r;return r=(r=r.add(e)).add(n),s=s.add(BL(r,44)),[r.add(i),s.add(o)]}(LL(t,e),LL(t,e+8),LL(t,e+16),LL(t,e+24),n,i)}function FL(t,e=t.length){const n=CL.fromNumber(81,!0);if(e<=32)return e<=16?function(t,e=t.length){if(e>=8){const n=kL.add(2*e),i=LL(t,0).add(kL),r=LL(t,e-8);return OL(BL(r,37).mul(n).add(i),BL(i,25).add(r).mul(n),n)}if(e>=4){const n=kL.add(2*e);return OL(DL(t,0).shl(3).add(e),DL(t,e-4),n)}if(e>0){const n=e+(t[e-1]<<2);return RL(kL.mul(t[0]+(t[e>>1]<<8)).xor(TL.mul(n))).mul(kL)}return kL}(t,e):function(t,e=t.length){const n=kL.add(2*e),i=LL(t,0).mul(ML),r=LL(t,8),s=LL(t,e-8).mul(n),o=LL(t,e-16).mul(kL);return OL(BL(i.add(r),43).add(BL(s,30)).add(o),i.add(BL(r.add(kL),18)).add(s),n)}(t,e);if(e<=64)return function(t,e=t.length){const n=kL.add(2*e),i=LL(t,0).mul(kL),r=LL(t,8),s=LL(t,e-8).mul(n),o=LL(t,e-16).mul(kL),a=BL(i.add(r),43).add(BL(s,30)).add(o),l=OL(a,i.add(BL(r.add(kL),18)).add(s),n),c=LL(t,16).mul(n),u=LL(t,24),h=a.add(LL(t,e-32)).mul(n),d=l.add(LL(t,e-24)).mul(n);return OL(BL(c.add(u),43).add(BL(h,30)).add(d),c.add(BL(u.add(i),18)).add(h),n)}(t,e);let i=n,r=n.mul(ML).add(113),s=RL(r.mul(kL).add(113)).mul(kL),o=[CL.UZERO,CL.UZERO],a=[CL.UZERO,CL.UZERO];i=i.mul(kL).add(LL(t,0));let l=0;const c=64*(e-1>>6),u=c+(e-1&63)-63;do{i=BL(i.add(r).add(o[0]).add(LL(t,l+8)),37).mul(ML),r=BL(r.add(o[1]).add(LL(t,l+48)),42).mul(ML),i=i.xor(a[1]),r=r.add(o[0]).add(LL(t,l+40)),s=BL(s.add(a[0]),33).mul(ML),o=PL(t,l,o[1].mul(ML),i.add(a[0])),a=PL(t,l+32,s.add(a[1]),r.add(LL(t,l+16))),[s,i]=[i,s],l+=64}while(l!==c);const h=ML.add(s.and(255).shl(1));return l=u,a[0]=a[0].add(e-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),i=BL(i.add(r).add(o[0]).add(LL(t,l+8)),37).mul(h),r=BL(r.add(o[1]).add(LL(t,l+48)),42).mul(h),i=i.xor(a[1].mul(9)),r=r.add(o[0].mul(9).add(LL(t,l+40))),s=BL(s.add(a[0]),33).mul(h),o=PL(t,l,o[1].mul(h),i.add(a[0])),a=PL(t,l+32,s.add(a[1]),r.add(LL(t,l+16))),[s,i]=[i,s],OL(OL(o[0],a[0],h).add(RL(r).mul(TL)).add(s),OL(o[1],a[1],h).add(i),h)}function $L(t,e){return"string"===e?VL(t):zL([t],e)}function zL(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=CM(t)),hk().getBool("DEBUG")&&UM(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error(`Unknown data type ${e}`)}function UL(){return hk().platform.now()}function HL(t,e){return hk().platform.fetch(t,e)}function VL(t,e="utf-8"){return e=e||"utf-8",hk().platform.encode(t,e)}function GL(t,e="utf-8"){return e=e||"utf-8",hk().platform.decode(t,e)}class WL{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new QL)}profileKernel(t,e,n){let i;const r=()=>{i=n()};let s;const o=UL();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(r);else{r();for(const t of i)t.dataSync();s=Promise.resolve({kernelMs:UL()-o})}if(hk().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let a=0;a<i.length;a++){const e=i[a];e.data().then(n=>{jL(n,e.dtype,t)})}return{kernelName:t,outputs:i,inputs:e,timeMs:s.then(t=>t.kernelMs),extraInfo:s.then(t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:i,inputs:r,extraInfo:s}=t;n.forEach(t=>{Promise.all([t.data(),i,s]).then(n=>{this.logger.logKernelProfile(e,t,n[0],n[1],r,n[2])})})}}function jL(t,e,n){if("float32"!==e)return!1;for(let i=0;i<t.length;i++){const e=t[i];if(isNaN(e)||!isFinite(e))return console.warn(`Found ${e} in the result of '${n}'`),!0}return!1}class QL{logKernelProfile(t,e,n,i,r,s){const o="number"==typeof i?DM(`${i}ms`,9):i.error,a=DM(t,25),l=e.rank,c=e.size,u=DM(e.shape.toString(),14);let h="";for(const d in r){const t=r[d];if(null!=t){const n=t.shape||e.shape,i=n.length;h+=`${d}: ${i}D ${i>0?n:""} `}}console.log(`%c${a}\t%c${o}\t%c${l}D ${u}\t%c${c}\t%c${h}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function qL(t,e,n,i){const r=ZM(e),s=function(t,e,n,i){const r=IM(e),s=i[i.length-1],o=new Array(s).fill(0),a=e.length,l="complex64"===n?JL(t):t;if(a>1)for(let c=0;c<r/s;c++){const t=c*s;for(let e=0;e<s;e++)o[e]=Math.max(o[e],XL(l[t+e],0,n).length)}return o}(t,e,n,r),o=e.length,a=KL(t,e,n,r,s),l=["Tensor"];return i&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(t=>"    "+t).join("\n")),l.join("\n")}function XL(t,e,n){let i;return i=Array.isArray(t)?`${parseFloat(t[0].toFixed(7))} + ${parseFloat(t[1].toFixed(7))}j`:QM(t)?`'${t}'`:"bool"===n?YL(t):parseFloat(t.toFixed(7)).toString(),DM(i,e)}function YL(t){return 0===t?"false":"true"}function KL(t,e,n,i,r,s=!0){const o="complex64"===n?2:1,a=e[0],l=e.length;if(0===l)return"complex64"===n?[XL(JL(t)[0],0,n)]:"bool"===n?[YL(t[0])]:[t[0].toString()];if(1===l){if(a>20){let e=Array.from(t.slice(0,3*o)),i=Array.from(t.slice((a-3)*o,a*o));return"complex64"===n&&(e=JL(e),i=JL(i)),["["+e.map((t,e)=>XL(t,r[e],n)).join(", ")+", ..., "+i.map((t,e)=>XL(t,r[a-3+e],n)).join(", ")+"]"]}return["["+("complex64"===n?JL(t):Array.from(t)).map((t,e)=>XL(t,r[e],n)).join(", ")+"]"]}const c=e.slice(1),u=i.slice(1),h=i[0]*o,d=[];if(a>20){for(let e=0;e<3;e++){const i=e*h;d.push(...KL(t.slice(i,i+h),c,n,u,r,!1))}d.push("...");for(let e=a-3;e<a;e++){const i=e*h;d.push(...KL(t.slice(i,i+h),c,n,u,r,e===a-1))}}else for(let m=0;m<a;m++){const e=m*h;d.push(...KL(t.slice(e,e+h),c,n,u,r,m===a-1))}const p=2===l?",":"";d[0]="["+d[0]+p;for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=",\n";for(let m=2;m<l;m++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":f),d}function JL(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class ZL{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=IM(t),null!=n){const t=n.length;_M(t===this.size,()=>`Length of values '${t}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||zM(e,this.size),this.strides=ZM(t)}set(t,...e){0===e.length&&(e=[0]),_M(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const n=this.locToIndex(e);this.values[n]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const i of t){if(i<0||i>=this.shape[e])throw new Error(`Requested out of range element at ${t}.   Buffer shape=${this.shape}`);e++}let n=t[t.length-1];for(let i=0;i<t.length-1;++i)n+=this.strides[i]*t[i];return this.values[n]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return tD().makeTensor(this.values,this.shape,this.dtype)}}let tD=null,eD=null,nD=null;class iD{constructor(t,e,n,i){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=IM(t),this.strides=ZM(t),this.dataId=n,this.id=i,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return eD.buffer(this.shape,this.dtype,t)}bufferSync(){return eD.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return ek(this.shape,t,"complex64"===this.dtype)}arraySync(){return ek(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const t=tD().read(this.dataId);if("string"===this.dtype){const e=await t;try{return e.map(t=>GL(t))}catch(GTt){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataSync(){this.throwIfDisposed();const t=tD().readSync(this.dataId);if("string"===this.dtype)try{return t.map(t=>GL(t))}catch(GTt){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await tD().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(tD().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return eD.print(this,t)}clone(){return this.throwIfDisposed(),eD.clone(this)}toString(t=!1){return qL(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),eD.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),tD().makeVariable(this,t,e,n)}}function rD(){return mk("Tensor",()=>iD)}Object.defineProperty(iD,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),rD();class sD extends iD{constructor(t,e,n,i){super(t.shape,t.dtype,t.dataId,i),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!MM(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);tD().disposeTensor(this),this.dataId=t.dataId,tD().incRef(this,null)}dispose(){tD().disposeVariable(this),this.isDisposedInternal=!0}}var oD,aD,lD,cD,uD;Object.defineProperty(sD,Symbol.hasInstance,{value:t=>t instanceof iD&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(oD||(oD={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(aD||(aD={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(lD||(lD={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(cD||(cD={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(uD||(uD={}));const hD={float32:cD,int32:aD,bool:lD,complex64:uD};function dD(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return hD[t][e]}function pD(t){return dD(t,"int32")}function fD(t,e){if(t.dtype===e.dtype)return[t,e];const n=dD(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function mD(t,e){_M(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function gD(t,e){return e.some(e=>e.id===t.id)}function yD(t){const e=[];return vD(t,e,new Set),e}function vD(t,e,n){if(null==t)return;if(t instanceof iD)return void e.push(t);if(i=t,!Array.isArray(i)&&"object"!=typeof i)return;var i;const r=t;for(const s in r){const t=r[s];n.has(t)||(n.add(t),vD(t,e,n))}}function bD(t){return null!=t.kernelName}class AD{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class xD{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new AD}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void(await this.setBackend(n))}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(console.warn(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new WL(this.backendInstance),!0}setupRegisteredKernels(){xL(this.backendName).forEach(t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){xL(t).forEach(e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])})}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const n=e.factory();if(!n||n instanceof pM||"function"!=typeof n.then)return this.registry[t]=n,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,i=n.then(n=>!(e<this.pendingBackendInitId||(this.registry[t]=n,this.pendingBackendInit=null,0))).catch(n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${t} failed`),console.warn(n.stack||n.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}}catch(n){return console.warn(`Initialization of backend ${t} failed`),console.warn(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:i,asyncInit:r}=this.initializeBackend(n);if(r||i)return{name:n,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),i=n.backend,r=this.readSync(e),s=i.refCount(e);i.disposeData(e,!0),n.backend=t,t.move(e,r,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,i=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");i=t}return this.scopedRun(()=>this.startScope(i),()=>this.endScope(n),()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(i){throw e(),i}}nextTensorId(){return xD.nextTensorId++}nextVariableId(){return xD.nextVariableId++}clone(t){const e=_D.runKernel(IR,{x:t});return this.addTapeNode(this.state.activeScope.name,{x:t},[e],t=>({x:()=>_D.runKernel(Pk,{x:t},{dtype:"float32"})}),[],{}),e}runKernel(t,e,n){if(null==bL(t,this.backendName))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const i=this.backend.numDataIds();let r=0;n.forEach(t=>{r+="complex64"===t.dtype?3:1});const s=i-e-r-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(s>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${s} data ids) after running '${t}'`)}runKernelFunc(t){let e,n=[];const i=this.isTapeOn(),r=this.state.numBytes,s=this.state.numTensors;let o,a;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const l=bD(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(bD(t)){const{kernelName:e,inputs:r,attrs:s}=t,l=bL(e,this.backendName);_M(null!=l,()=>`Cannot find registered kernel '${e}' for backend '${this.backendName}'`),o=()=>{const t=this.backend.numDataIds();a=l.kernelFunc({inputs:r,attrs:s,backend:this.backend});const o=Array.isArray(a)?a:[a];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(e,t,o);const c=o.map(t=>{if(null!=t.rank)return t;const{dataId:e,shape:n,dtype:i}=t;return this.makeTensorFromDataId(e,n,i)});if(i){const t=this.getTensorsForGradient(e,r,c);n=this.saveTensorsForBackwardMode(t)}return c}}else{const{forwardFunc:e}=t,r=t=>{i&&(n=t.map(t=>this.keep(this.clone(t))))};o=()=>{const t=this.backend.numDataIds();a=this.tidy(()=>e(this.backend,r));const n=Array.isArray(a)?a:[a];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,t,n),n}}const{inputs:c,attrs:u}=t,h=bD(t)?null:t.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(l,c,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),e=d.outputs):e=o()}),i&&this.addTapeNode(l,c,e,h,n,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(t=>null!=c[t]?c[t].shape:null),outputShapes:e.map(t=>t.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(a)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(t=>this.keep(this.clone(t)))}getTensorsForGradient(t,e,n){const i=AL(t);if(null!=i){const t=i.inputsToSave||[],r=i.outputsToSave||[];let s;i.saveAllInputs?(_M(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),s=Object.keys(e).map(t=>e[t])):s=t.map(t=>e[t]);const o=n.filter((t,e)=>r[e]);return s.concat(o)}return[]}makeTensor(t,e,n,i){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");i=i||this.backend;let r=t;"string"===(n=n||"float32")&&QM(t[0])&&(r=t.map(t=>VL(t)));const s=i.write(r,e,n),o=new iD(e,n,s,this.nextTensorId());if(this.trackTensor(o,i),"string"===n){const t=this.state.tensorInfo.get(s),e=jM(r);this.state.numBytes+=e-t.bytes,t.bytes=e}return o}makeTensorFromDataId(t,e,n,i){const r=new iD(e,n=n||"float32",t,this.nextTensorId());return this.trackTensor(r,i),r}makeVariable(t,e=!0,n,i){n=n||this.nextVariableId().toString(),null!=i&&i!==t.dtype&&(t=t.cast(i));const r=new sD(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[r.name])throw new Error(`Variable with name ${r.name} was already registered`);return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(t,e){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*WM(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof sD||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const e=t.size*WM(t.dtype);this.state.numBytes-=e}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[t])}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(t=>t.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const i of this.state.activeProfile.kernels)i.kernelTimeMs=await i.kernelTimeMs,i.extraInfo=await i.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,i,r,s){const o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:r},a=AL(t);null!=a&&(i=a.gradFunc),null!=i&&(o.gradient=t=>(t=t.map((t,e)=>{if(null==t){const t=n[e],i=ik(t.size,t.dtype);return this.makeTensor(i,t.shape,t.dtype)}return t}),i(t.length>1?t:t[0],r,s))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=yD(t),n=new Set(e.map(t=>t.id));for(let r=0;r<this.state.activeScope.track.length;r++){const t=this.state.activeScope.track[r];t.kept||n.has(t.id)||t.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(t=>{t.kept||t.scopeId!==i.id||this.track(t)})}gradients(t,e,n,i=!1){if(_M(e.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const r=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));_M(r instanceof iD,()=>"The result y returned by f() must be a tensor.");const s=function(t,e,n){const i={},r={};for(let l=0;l<e.length;l++)i[e[l].id]=!0;for(let l=0;l<t.length;l++){const n=t[l],s=n.inputs;for(const t in s){const o=s[t];let a=!1;for(let t=0;t<e.length;t++)if(i[o.id]){n.outputs.forEach(t=>i[t.id]=!0),a=!0,r[n.id]=!0;break}if(a)break}}const s={};s[n.id]=!0;const o={};for(let l=t.length-1;l>=0;l--){const e=t[l],n=e.inputs;for(let t=0;t<e.outputs.length;t++)if(s[e.outputs[t].id]){for(const t in n)s[n[t].id]=!0,o[e.id]=!0;break}}const a=[];for(let l=0;l<t.length;l++){const e=t[l];if(r[e.id]&&o[e.id]){const t={};for(const r in e.inputs){const n=e.inputs[r];i[n.id]&&(t[r]=n)}const n=Object.assign({},e);n.inputs=t,n.outputs=e.outputs,a.push(n)}}return a}(this.state.activeTape,e,r);if(!i&&0===s.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const t={};t[r.id]=null==n?function(t){const e=nk(IM(t),"float32");return _D.makeTensor(e,t,"float32")}(r.shape):n,function(t,e,n,i){for(let r=e.length-1;r>=0;r--){const s=e[r],o=[];if(s.outputs.forEach(e=>{const n=t[e.id];o.push(null!=n?n:null)}),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const a=s.gradient(o);for(const e in s.inputs){if(!(e in a))throw new Error(`Cannot backprop through input ${e}. Available gradients found: ${Object.keys(a)}.`);const r=n(()=>a[e]());if("float32"!==r.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${e} must have 'float32' dtype, but has '${r.dtype}'`);const o=s.inputs[e];if(!MM(r.shape,o.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${e}' has shape '${r.shape}', which does not match the shape of the input '${o.shape}'`);if(null==t[o.id])t[o.id]=r;else{const e=t[o.id];t[o.id]=i(e,r),e.dispose()}}}}(t,s,t=>this.tidy(t),SD);const i=e.map(e=>t[e.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(t=>{for(const e of t.saved)e.dispose()}),this.state.activeTape=null),{value:r,grads:i}})}customGrad(t){return _M(KM(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{let n;_M(e.every(t=>t instanceof iD),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const i={};return e.forEach((t,e)=>{i[e]=t}),this.runKernelFunc({forwardFunc:(i,r)=>(n=t(...e,r),_M(n.value instanceof iD,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),_M(KM(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),backwardsFunc:(t,i)=>{const r=n.gradFunc(t,i),s=Array.isArray(r)?r:[r];_M(s.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),_M(s.every(t=>t instanceof iD),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const o={};return s.forEach((t,e)=>{o[e]=()=>t}),o},inputs:i})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}async time(t){const e=UL(),n=await this.backend.time(t);return n.wallMs=UL()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new AD;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function wD(){const t=fk();if(null==t._tfengine){const e=new ck(t);t._tfengine=new xD(e)}return pk=t._tfengine.ENV,tD=()=>t._tfengine,t._tfengine}xD.nextTensorId=0,xD.nextVariableId=0;const _D=wD();function SD(t,e){return _D.runKernel(bk,{a:t,b:e})}function ED(t){if(t||"undefined"!=typeof navigator&&null!=navigator){if(t||(t=navigator),"ReactNative"===t.product)return!0;const e=t.userAgent||t.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function CD(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const ID=hk();function TD(t,e){let n=t;if(GM(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];const i=[];for(;Array.isArray(n)||GM(n)&&"string"!==e;)i.push(n.length),n=n[0];return Array.isArray(t)&&hk().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&MD(t,i,[]),i}function MD(t,e,n){if(n=n||[],!Array.isArray(t)&&!GM(t))return void _M(0===e.length,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);_M(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),_M(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const i=e.slice(1);for(let r=0;r<t.length;++r)MD(t[r],i,n.concat(r))}function kD(t,e,n,i){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==e||"numeric"===t&&"string"===e)throw new Error(`Argument '${n}' passed to '${i}' must be ${t} tensor, but got ${e} tensor`)}}function RD(t,e,n,i="numeric"){if(t instanceof iD)return kD(i,t.dtype,e,n),t;let r=YM(t);if("string"!==r&&["bool","int32","float32"].indexOf(i)>=0&&(r=i),kD(i,r,e,n),null==t||!GM(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${null==t?"null":t.constructor.name}'`);const s=TD(t,r);GM(t)||Array.isArray(t)||(t=[t]);const o="string"!==r?zL(t,r):CM(t,[],!0);return _D.makeTensor(o,s,r)}function ND(t,e,n,i="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((t,r)=>RD(t,`${e}[${r}]`,n,i))}function LD(t){const e=Object.keys(t);if(1!==e.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const i=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const r=(...t)=>{_D.startScope(n);try{const e=i(...t);return lk(e)&&console.error("Cannot return a Promise inside of tidy."),_D.endScope(e),e}catch(e){throw _D.endScope(null),e}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}ID.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),ID.registerFlag("IS_BROWSER",()=>CD()),ID.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),ID.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),ID.registerFlag("PROD",()=>!1),ID.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ID.getBool("DEBUG")),ID.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),ID.registerFlag("IS_TEST",()=>!1),ID.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),ID.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);const DD=LD({complex_:function(t,e){const n=RD(t,"real","complex"),i=RD(e,"imag","complex");return SM(n.shape,i.shape,`real and imag shapes, ${n.shape} and ${i.shape}, must match in call to tf.complex().`),_D.runKernel(zk,{real:n,imag:i})}});function BD(t,e,n,i){if(null==i&&(i=YM(t)),"complex64"===i)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!GM(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){sk(e);const t=IM(e),i=IM(n);_M(t===i,()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${i}`);for(let r=0;r<n.length;++r){const t=n[r],i=r!==n.length-1||t!==IM(e.slice(r));_M(n[r]===e[r]||!i,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return GM(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==i?zL(t,i):CM(t,[],!0),_D.makeTensor(t,e,i)}function OD(t,e,n){return BD(t,e,TD(t,n),n)}const PD={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};async function FD(t,e){const n=[],i=[],r=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);for(let s=0;s<r.length;++s){const o=r[s],a=Array.isArray(t)?t[s].tensor:t[o];if("float32"!==a.dtype&&"int32"!==a.dtype&&"bool"!==a.dtype&&"string"!==a.dtype&&"complex64"!==a.dtype)throw new Error(`Unsupported dtype in weight '${o}': ${a.dtype}`);const l={name:o,shape:a.shape,dtype:a.dtype};if("string"===a.dtype){const t=new Promise(async t=>{const e=await a.bytes(),n=e.reduce((t,e)=>t+e.length,0)+4*e.length,i=new Uint8Array(n);let r=0;for(let s=0;s<e.length;s++){const t=e[s],n=new Uint8Array(new Uint32Array([t.length]).buffer);i.set(n,r),r+=4,i.set(t,r),r+=t.length}t(i)});i.push(t)}else i.push(a.data());null!=e&&(l.group=e),n.push(l)}return{data:zD(await Promise.all(i)),specs:n}}function $D(t,e){const n={};let i,r=0;for(const s of e){const e=s.name,o=s.dtype,a=s.shape,l=IM(a);let c;if("quantization"in s){const n=s.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${s.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${s.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==o)throw new Error(`Weight ${s.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${o}.`)}const a=PD[n.dtype],u=t.slice(r,r+l*a),h="uint8"===n.dtype?new Uint8Array(u):new Uint16Array(u);if("float32"===o)if("uint8"===n.dtype||"uint16"===n.dtype){c=new Float32Array(h.length);for(let t=0;t<h.length;t++)c[t]=h[t]*n.scale+n.min}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===i&&(i=qD()),c=i(h)}else{if("int32"!==o)throw new Error(`Unsupported dtype in weight '${e}': ${o}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);c=new Int32Array(h.length);for(let t=0;t<h.length;t++)c[t]=Math.round(h[t]*n.scale+n.min)}r+=l*a}else if("string"===o){const e=IM(s.shape);c=[];for(let n=0;n<e;n++){const e=new Uint32Array(t.slice(r,r+4))[0];r+=4;const n=new Uint8Array(t.slice(r,r+e));c.push(n),r+=e}}else{const i=PD[o],s=t.slice(r,r+l*i);if("float32"===o)c=new Float32Array(s);else if("int32"===o)c=new Int32Array(s);else if("bool"===o)c=new Uint8Array(s);else{if("complex64"!==o)throw new Error(`Unsupported dtype in weight '${e}': ${o}`);{c=new Float32Array(s);const t=new Float32Array(c.length/2),i=new Float32Array(c.length/2);for(let e=0;e<t.length;e++)t[e]=c[2*e],i[e]=c[2*e+1];const r=OD(t,a,"float32"),o=OD(i,a,"float32");n[e]=DD(r,o),r.dispose(),o.dispose()}}r+=l*i}"complex64"!==o&&(n[e]=OD(c,a,o))}return n}function zD(t){if(null===t)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(t=>{if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${t.constructor.name}`)});const i=new Uint8Array(e);let r=0;return n.forEach(t=>{i.set(new Uint8Array(t.buffer),r),r+=t.byteLength}),i.buffer}const UD="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function HD(t){return UD?Buffer.byteLength(t):new Blob([t]).size}function VD(t){if(1===t.length)return t[0];let e=0;t.forEach(t=>{e+=t.byteLength});const n=new Uint8Array(e);let i=0;return t.forEach(t=>{n.set(new Uint8Array(t),i),i+=t.byteLength}),n.buffer}function GD(t){for(t=t.trim();t.endsWith("/");)t=t.slice(0,t.length-1);const e=t.split("/");return e[e.length-1]}function WD(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer),null!=t.trainingConfig&&(n.trainingConfig=t.trainingConfig),n}async function jD(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(null!=t.trainingConfig&&(n.trainingConfig=t.trainingConfig),null!=t.weightsManifest){const[i,r]=await e(t.weightsManifest);n.weightSpecs=i,n.weightData=r}return null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer),n}function QD(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:HD(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:HD(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}function qD(){const t=function(){const t=t=>{let e=t<<13,n=0;for(;0==(8388608&e);)n-=8388608,e<<=1;return e&=-8388609,n+=947912704,e|n},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}(),e=function(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}(),n=function(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}();return i=>{const r=new ArrayBuffer(4*i.length),s=new Uint32Array(r);for(let o=0;o<i.length;o++){const r=i[o];s[o]=t[n[r>>10]+(1023&r)]+e[r>>10]}return new Float32Array(r)}}class XD{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==XD.instance&&(XD.instance=new XD),XD.instance}static registerSaveRouter(t){XD.getInstance().saveRouters.push(t)}static registerLoadRouter(t){XD.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return XD.getHandlers(t,"save")}static getLoadHandlers(t,e){return XD.getHandlers(t,"load",e)}static getHandlers(t,e,n){const i=[];return("load"===e?XD.getInstance().loadRouters:XD.getInstance().saveRouters).forEach(e=>{const r=e(t,n);null!==r&&i.push(r)}),i}}const YD=t=>XD.registerSaveRouter(t),KD=t=>XD.registerLoadRouter(t),JD=t=>XD.getSaveHandlers(t),ZD=(t,e)=>XD.getLoadHandlers(t,e),tB="tensorflowjs",eB="models_store",nB="model_info_store";function iB(){if(!hk().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"==typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function rB(t){const e=t.result;e.createObjectStore(eB,{keyPath:"modelPath"}),e.createObjectStore(nB,{keyPath:"modelPath"})}class sB{constructor(t){if(this.indexedDB=iB(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((t,n)=>{const i=this.indexedDB.open(tB,1);i.onupgradeneeded=()=>rB(i),i.onsuccess=()=>{const r=i.result;if(null==e){const e=r.transaction(eB,"readonly"),i=e.objectStore(eB).get(this.modelPath);i.onsuccess=()=>{if(null==i.result)return r.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));t(i.result.modelArtifacts)},i.onerror=t=>(r.close(),n(i.error)),e.oncomplete=()=>r.close()}else{const i=QD(e),s=r.transaction(nB,"readwrite");let o=s.objectStore(nB);const a=o.put({modelPath:this.modelPath,modelArtifactsInfo:i});let l;a.onsuccess=()=>{l=r.transaction(eB,"readwrite");const a=l.objectStore(eB).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:i});a.onsuccess=()=>t({modelArtifactsInfo:i}),a.onerror=t=>{o=s.objectStore(nB);const e=o.delete(this.modelPath);e.onsuccess=()=>(r.close(),n(a.error)),e.onerror=t=>(r.close(),n(a.error))}},a.onerror=t=>(r.close(),n(a.error)),s.oncomplete=()=>{null==l?r.close():l.oncomplete=()=>r.close()}}},i.onerror=t=>n(i.error)})}}sB.URL_SCHEME="indexeddb://";const oB=t=>{return hk().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(sB.URL_SCHEME)?(e=t.slice(sB.URL_SCHEME.length),new sB(e)):null;var e};XD.registerSaveRouter(oB),XD.registerLoadRouter(oB);class aB{constructor(){this.indexedDB=iB()}async listModels(){return new Promise((t,e)=>{const n=this.indexedDB.open(tB,1);n.onupgradeneeded=()=>rB(n),n.onsuccess=()=>{const i=n.result,r=i.transaction(nB,"readonly"),s=r.objectStore(nB).getAll();s.onsuccess=()=>{const e={};for(const t of s.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},s.onerror=t=>(i.close(),e(s.error)),r.oncomplete=()=>i.close()},n.onerror=t=>e(n.error)})}async removeModel(t){var e;return t=(e=t).startsWith(sB.URL_SCHEME)?e.slice(sB.URL_SCHEME.length):e,new Promise((e,n)=>{const i=this.indexedDB.open(tB,1);i.onupgradeneeded=()=>rB(i),i.onsuccess=()=>{const r=i.result,s=r.transaction(nB,"readwrite"),o=s.objectStore(nB),a=o.get(t);let l;a.onsuccess=()=>{if(null==a.result)return r.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const i=o.delete(t),s=()=>{l=r.transaction(eB,"readwrite");const i=l.objectStore(eB).delete(t);i.onsuccess=()=>e(a.result.modelArtifactsInfo),i.onerror=t=>n(a.error)};i.onsuccess=s,i.onerror=t=>(s(),r.close(),n(a.error))}},a.onerror=t=>(r.close(),n(a.error)),s.oncomplete=()=>{null==l?r.close():l.oncomplete=()=>r.close()}},i.onerror=t=>n(i.error)})}}const lB="/",cB="tensorflowjs_models",uB="info",hB="model_topology",dB="weight_specs",pB="weight_data",fB="model_metadata";function mB(t){return{info:[cB,t,uB].join(lB),topology:[cB,t,hB].join(lB),weightSpecs:[cB,t,dB].join(lB),weightData:[cB,t,pB].join(lB),modelMetadata:[cB,t,fB].join(lB)}}function gB(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function yB(t){const e=t.split(lB);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(lB)}class vB{constructor(t){if(!hk().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=mB(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(t.modelTopology),i=JSON.stringify(t.weightSpecs),r=QD(t);try{return this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,i),this.LS.setItem(this.keys.weightData,function(t){if(UD)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let i=0,r=e.length;i<r;i++)n+=String.fromCharCode(e[i]);return btoa(n)}(t.weightData)),this.LS.setItem(this.keys.modelMetadata,JSON.stringify({format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:null!=t.signature?t.signature:void 0,userDefinedMetadata:null!=t.userDefinedMetadata?t.userDefinedMetadata:void 0,modelInitializer:null!=t.modelInitializer?t.modelInitializer:void 0,trainingConfig:null!=t.trainingConfig?t.trainingConfig:void 0})),{modelArtifactsInfo:r}}catch(e){throw gB(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(null==t)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;const i=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==i)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=i;const r=this.LS.getItem(this.keys.modelMetadata);if(null!=r){const t=JSON.parse(r);e.format=t.format,e.generatedBy=t.generatedBy,e.convertedBy=t.convertedBy,null!=t.signature&&(e.signature=t.signature),null!=t.userDefinedMetadata&&(e.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(e.modelInitializer=t.modelInitializer),null!=t.trainingConfig&&(e.trainingConfig=t.trainingConfig)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=function(t){if(UD){const e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let i=0;i<e.length;++i)n.set([e.charCodeAt(i)],i);return n.buffer}(s),e}}vB.URL_SCHEME="localstorage://";const bB=t=>{return hk().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(vB.URL_SCHEME)?(e=t.slice(vB.URL_SCHEME.length),new vB(e)):null;var e};XD.registerSaveRouter(bB),XD.registerLoadRouter(bB);class AB{constructor(){_M(hk().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),_M("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},e=cB+lB,n=lB+uB;for(let i=0;i<this.LS.length;++i){const r=this.LS.key(i);r.startsWith(e)&&r.endsWith(n)&&(t[yB(r)]=JSON.parse(this.LS.getItem(r)))}return t}async removeModel(t){var e;const n=mB(t=(e=t).startsWith(vB.URL_SCHEME)?e.slice(vB.URL_SCHEME.length):e);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${t}'`);const i=JSON.parse(this.LS.getItem(n.info));return gB(n),i}}const xB="://";class wB{constructor(){this.managers={}}static getInstance(){return null==wB.instance&&(wB.instance=new wB),wB.instance}static registerManager(t,e){_M(null!=t,()=>"scheme must not be undefined or null."),t.endsWith(xB)&&(t=t.slice(0,t.indexOf(xB))),_M(t.length>0,()=>"scheme must not be an empty string.");const n=wB.getInstance();_M(null==n.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),n.managers[t]=e}static getManager(t){const e=this.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}}function _B(t){if(-1===t.indexOf(xB))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${wB.getSchemes().join(",")}`);return{scheme:t.split(xB)[0],path:t.split(xB)[1]}}async function SB(t,e,n=!1){_M(t!==e,()=>`Old path and new path are the same: '${t}'`);const i=XD.getLoadHandlers(t);_M(i.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),_M(i.length<2,()=>`Copying failed because more than one (${i.length}) load handlers for source URL ${t}.`);const r=i[0],s=XD.getSaveHandlers(e);_M(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),_M(s.length<2,()=>`Copying failed because more than one (${i.length}) save handlers for destination URL ${e}.`);const o=s[0],a=_B(t).scheme,l=_B(t).path,c=a===_B(t).scheme,u=await r.load();n&&c&&await wB.getManager(a).removeModel(l);const h=await o.save(u);return n&&!c&&await wB.getManager(a).removeModel(l),h.modelArtifactsInfo}async function EB(){const t=wB.getSchemes(),e={};for(const n of t){const t=await wB.getManager(n).listModels();for(const i in t)e[n+xB+i]=t[i]}return e}async function CB(t){const e=_B(t);return wB.getManager(e.scheme).removeModel(e.path)}async function IB(t,e){return SB(t,e,!1)}async function TB(t,e){return SB(t,e,!0)}class MB{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}}if(hk().get("IS_BROWSER")){hk().setPlatform("browser",new MB);try{wB.registerManager(vB.URL_SCHEME,new AB)}catch(WTt){}try{wB.registerManager(sB.URL_SCHEME,new aB)}catch(WTt){}}let kB;function RB(t,e="float32",n){return e=e||"float32",sk(t),new ZL(t,e,n)}hk().get("IS_NODE")&&hk().setPlatform("node",new class{constructor(){this.util=n(2),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=hk().global.fetch?hk().global.fetch(t,e):(null==kB&&(kB=n(1)),kB(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}});const NB=LD({cast_:function(t,e){const n=RD(t,"x","cast");if(!HM(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");return _D.runKernel(Pk,{x:n},{dtype:e})}}),LB=LD({clone_:function(t){const e=RD(t,"x","clone","string_or_numeric");return _D.runKernel(IR,{x:e})}});function DB(t){return new Promise(t=>setTimeout(t)).then(t)}wD(),eD={buffer:RB,cast:NB,clone:LB,print:function(t,e=!1){console.log(t.toString(e))}};class BB{constructor(t){if(!hk().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(BB.URL_SCHEME)&&(t=t.slice(BB.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelJsonFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(t){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=WD(t,[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}]),i=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),r=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(r.download=this.modelJsonFileName,r.href=i,await DB(()=>r.dispatchEvent(new MouseEvent("click"))),null!=t.weightData){const t=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;t.download=this.weightDataFileName,t.href=e,await DB(()=>t.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:QD(t)}}}}BB.URL_SCHEME="downloads://";class OB{constructor(t){if(null==t||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}async load(){return new Promise((t,e)=>{const n=new FileReader;n.onload=n=>{const i=JSON.parse(n.target.result),r=i.modelTopology;if(null==r)return void e(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==i.weightsManifest)return void e(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void t({modelTopology:r});const s=jD(i,t=>this.loadWeights(t));t(s)},n.onerror=t=>e(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(t){const e=[],n=[];for(const s of t)e.push(...s.weights),n.push(...s.paths);const i=this.checkManifestAndWeightFiles(t),r=n.map(t=>this.loadWeightsFile(t,i[t]));return Promise.all(r).then(t=>[e,VD(t)])}loadWeightsFile(t,e){return new Promise((n,i)=>{const r=new FileReader;r.onload=t=>{n(t.target.result)},r.onerror=e=>i(`Failed to weights data from file of path '${t}'.`),r.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){const e=[],n=this.weightsFiles.map(t=>GD(t.name)),i={};for(const r of t)r.paths.forEach(t=>{const r=GD(t);if(-1!==e.indexOf(r))throw new Error(`Duplicate file basename found in weights manifest: '${r}'`);if(e.push(r),-1===n.indexOf(r))throw new Error(`Weight file with basename '${r}' is not provided.`);i[t]=this.weightsFiles[n.indexOf(r)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return i}}function PB(t){return new OB(t)}function FB(t,e,n,i){!function(t){_M(null!=t&&Array.isArray(t)&&t.length>0,()=>"promises must be a none empty array")}(t),function(t,e){_M(t>=0&&t<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${t}`),_M(e>=0&&e<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${e}`),_M(e>=t,()=>`startFraction must be no more than endFraction, but got startFraction ${t} and endFraction ${e}`)}(n=null==n?0:n,i=null==i?1:i);let r=0;return Promise.all(t.map(s=>(s.then(s=>{const o=n+ ++r/t.length*(i-n);return e(o),s}),s)))}async function $B(t,e){null==e&&(e={});const n=null==e.fetchFunc?hk().platform.fetch:e.fetchFunc,i=t.map(t=>n(t,e.requestInit,{isBinary:!0})),r=(null==e.onProgress?await Promise.all(i):await FB(i,e.onProgress,0,.5)).map(t=>t.arrayBuffer());return null==e.onProgress?await Promise.all(r):await FB(r,e.onProgress,.5,1)}async function zB(t,e="",n,i){return UB(t=>$B(t,{requestInit:i}))(t,e,n)}function UB(t){return async(e,n="",i)=>{const r=e.map(()=>!1),s={},o=null!=i?i.map(()=>!1):[],a=[];if(e.forEach((t,e)=>{let n=0;t.weights.forEach(t=>{const l=PD["quantization"in t?t.quantization.dtype:t.dtype]*IM(t.shape),c=()=>{r[e]=!0,null==s[e]&&(s[e]=[]),s[e].push({manifestEntry:t,groupOffset:n,sizeBytes:l})};null!=i?i.forEach((e,n)=>{e===t.name&&(c(),o[n]=!0)}):c(),a.push(t.name),n+=l})}),!o.every(t=>t)){const t=i.filter((t,e)=>!o[e]);throw new Error(`Could not find weights in manifest with names: ${t.join(", ")}. \nManifest JSON has weights with names: ${a.join(", ")}.`)}const l=r.reduce((t,e,n)=>(e&&t.push(n),t),[]),c=[];l.forEach(t=>{e[t].paths.forEach(t=>{const e=n+(n.endsWith("/")?"":"/")+t;c.push(e)})});const u=await t(c),h={};let d=0;return l.forEach(t=>{const n=e[t].paths.length;let i=0;for(let e=0;e<n;e++)i+=u[d+e].byteLength;const r=new ArrayBuffer(i),o=new Uint8Array(r);let a=0;for(let e=0;e<n;e++){const t=new Uint8Array(u[d+e]);o.set(t,a),a+=t.byteLength}s[t].forEach(t=>{const e=$D(r.slice(t.groupOffset,t.groupOffset+t.sizeBytes),[t.manifestEntry]);for(const n in e)h[n]=e[n]}),d+=n}),h}}XD.registerSaveRouter(t=>hk().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(BB.URL_SCHEME)?function(t="model"){return new BB(t)}(t.slice(BB.URL_SCHEME.length)):null);class HB{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,null!=e.fetchFunc?(_M("function"==typeof e.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=hk().platform.fetch,_M(null!=t&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&_M(2===t.length,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const n=WD(t,[{paths:["./model.weights.bin"],weights:t.weightSpecs}]);e.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=t.weightData&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin");const i=await this.fetch(this.path,e);if(i.ok)return{modelArtifactsInfo:QD(t),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch(n){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}if(null==e.modelTopology&&null==e.weightsManifest)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return jD(e,t=>this.loadWeights(t))}async loadWeights(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[n,i]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?");return[t.substring(0,e)+"/",n>e?t.substring(n):""]}(e),r=this.weightPathPrefix||n,s=[];for(const l of t)s.push(...l.weights);const o=[],a=[];for(const l of t)for(const t of l.paths)null!=this.weightUrlConverter?a.push(this.weightUrlConverter(t)):o.push(r+t+i);return this.weightUrlConverter&&o.push(...await Promise.all(a)),[s,VD(await $B(o,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function VB(t){return null!=t.match(HB.URL_SCHEME_REGEX)}HB.URL_SCHEME_REGEX=/^https?:\/\//;const GB=(t,e)=>{if("undefined"==typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every(t=>VB(t)):VB(t),n)return WB(t,e)}return null};function WB(t,e){return new HB(t,e)}function jB(t,e){return WB(t,e)}XD.registerSaveRouter(GB),XD.registerLoadRouter(GB);class QB{constructor(t){this.modelArtifacts=t}async load(){return this.modelArtifacts}}class qB{constructor(t){this.saveHandler=t}async save(t){return this.saveHandler(t)}}function XB(t,e,n,i){return 1===arguments.length?null!=t.modelTopology||null!=t.weightSpecs?new QB(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new QB({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new QB({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:i}))}function YB(t){return new qB(t)}let KB;function JB(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,i=!1,r=!1,s=!1,o=!1,a=!1;if(t.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&t instanceof ImageData)i=!0;else if("undefined"!=typeof HTMLVideoElement&&t instanceof HTMLVideoElement)r=!0;else if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement)s=!0;else if(null!=t.getContext)o=!0;else{if(!("undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);a=!0}if(r){const e=2;if(r&&t.readyState<e)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=bL(dL,_D.backendName))return _D.runKernel(dL,{pixels:t},{numChannels:e});const[l,c]=r?[t.videoWidth,t.videoHeight]:[t.width,t.height];let u,h;if(o?u=t.getContext("2d").getImageData(0,0,l,c).data:i||n?u=t.data:(s||r||a)&&(null==KB&&(KB=document.createElement("canvas").getContext("2d")),KB.canvas.width=l,KB.canvas.height=c,KB.drawImage(t,0,0,l,c),u=KB.getImageData(0,0,l,c).data),4===e)h=new Int32Array(u);else{const t=l*c;h=new Int32Array(t*e);for(let n=0;n<t;n++)for(let t=0;t<e;++t)h[n*e+t]=u[4*n+t]}return function(t,e,n){if(EM(t),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");const i=TD(t,n);if(3!==i.length&&1!==i.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===i.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return BD(t,e,i,n)}(h,[c,l,e],"int32")}async function ZB(t,e=3){let n=null;if(hk().getBool("WRAP_TO_IMAGEBITMAP")&&function(t){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(t instanceof ImageBitmap)&&function(t){return null!=t&&0!==t.width&&0!==t.height}(t)&&!function(t){return null!=t&&t.data instanceof Uint8Array}(t)}(t)){let e;try{e=await createImageBitmap(t,{premultiplyAlpha:"none"})}catch(i){e=null}n=null!=e&&e.width===t.width&&e.height===t.height?e:t}else n=t;return JB(n,e)}async function tO(t,e){let n=RD(t,"img","toPixels");if(!(t instanceof iD)){const t=n;n=NB(t,"int32"),t.dispose()}if(2!==n.rank&&3!==n.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const[i,r]=n.shape.slice(0,2),s=2===n.rank?1:n.shape[2];if(s>4||2===s)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if("float32"!==n.dtype&&"int32"!==n.dtype)throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);const o=await n.data(),a="float32"===n.dtype?255:1,l=new Uint8ClampedArray(r*i*4);for(let c=0;c<i*r;++c){const t=[0,0,0,255];for(let i=0;i<s;i++){const e=o[c*s+i];if("float32"===n.dtype){if(e<0||e>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${e}.`)}else if("int32"===n.dtype&&(e<0||e>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${e}.`);1===s?(t[0]=e*a,t[1]=e*a,t[2]=e*a):t[i]=e*a}const e=4*c;l[e+0]=Math.round(t[0]),l[e+1]=Math.round(t[1]),l[e+2]=Math.round(t[2]),l[e+3]=Math.round(t[3])}if(null!=e){e.width=r,e.height=i;const t=e.getContext("2d"),n=new ImageData(l,r,i);t.putImageData(n,0,0)}return n!==t&&n.dispose(),l}const eO=LD({fromPixels_:JB});function nO(t,e,n){const i=t.shape.length;_M(i===e.length,()=>`Error in slice${i}D: Length of begin ${e} must match the rank of the array (${i}).`),_M(i===n.length,()=>`Error in slice${i}D: Length of size ${n} must match the rank of the array (${i}).`);for(let r=0;r<i;++r)_M(e[r]+n[r]<=t.shape[r],()=>`Error in slice${i}D: begin[${r}] + size[${r}] (${e[r]+n[r]}) would overflow input.shape[${r}] (${t.shape[r]})`)}function iO(t){const e=[];let n=0;for(;t>0;)1&t&&e.push(n),t/=2,n++;return e}function rO(t,e,n){const i=[];for(let r=0;r<t.length;r++)i[r]=Math.ceil((e[r]-t[r])/n[r]);return i}function sO(t,e,n,i){const r=[...t];for(let s=r.length;s<i.length;s++)r.push(1);for(let s=0;s<n;s++)0===s?r[e]=1:(r.splice(e,0,1),r.pop());return r}function oO(t,e,n){return n<=t?n:n-(e-1)}function aO(t,e){const n=[];for(let i=0;i<t;i++)n.push(e+i);return n}function lO(t,e,n,i,r,s,o,a,l){const c=t.length;let u=new Array(c),h=new Array(c),d=new Array(c);if(e.length&&n>0){const l=e[0],c=n+1;u=cO(o,l,c,i,t),h=uO(a,l,c,r,t),d=sO(s,l,c,t)}else for(let p=0;p<c;p++)u[p]=dO(o,i,s,t,p,l),h[p]=pO(a,r,s,t,p,l),d[p]=hO(s,p,l);return{begin:u,end:h,strides:d}}function cO(t,e,n,i,r){const s=[...r],o=aO(n,e);for(let a=0;a<s.length;a++)if(o.indexOf(a)>-1)s[a]=0;else{const r=oO(e,n,a);let o=i[r];t&1<<r&&(o=0),s[a]=o}return s}function uO(t,e,n,i,r){const s=[...r],o=aO(n,e);for(let a=0;a<s.length;a++)if(o.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{const r=oO(e,n,a);let o=i[r];t&1<<r&&(o=Number.MAX_SAFE_INTEGER),s[a]=o}for(let a=0;a<s.length;a++){const t=r[a];s[a]<0&&(s[a]+=t),s[a]=yM(0,s[a],r[a])}return s}function hO(t,e,n){let i=t[e];return(n&1<<e||null==i)&&(i=1),i}function dO(t,e,n,i,r,s){let o=e[r];(t&1<<r||s&1<<r||null==o)&&(o=(n[r]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const a=i[r];return o<0&&(o+=a),o=yM(0,o,a-1),o}function pO(t,e,n,i,r,s){let o=e[r];const a=n[r]||1;(t&1<<r||s&1<<r||null==o)&&(o=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=i[r];return o<0&&(o+=l),o=a>0?yM(0,o,l):yM(-1,o,l-1),o}function fO(t,e,n){let i=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){i=r;break}for(let r=i+1;r<n.length;r++)if(e[r]>0||n[r]!==t[r])return!1;return!0}function mO(t,e){let n=t.length>0?t[t.length-1]:1;for(let i=0;i<t.length-1;i++)n+=t[i]*e[i];return n}function gO(t,e,n){let i;const r=t.shape.length;let s;return i="number"==typeof e?[e,...new Array(r-1).fill(0)]:e.length<r?e.concat(new Array(r-e.length).fill(0)):e.slice(),i.forEach(t=>{_M(-1!==t,()=>"slice() does not support negative begin indexing.")}),s=null==n?new Array(r).fill(-1):"number"==typeof n?[n,...new Array(r-1).fill(-1)]:n.length<r?n.concat(new Array(r-n.length).fill(-1)):n,s=s.map((e,n)=>e>=0?e:(_M(-1===e,()=>`Negative size values should be exactly -1 but got ${e} for the slice() size at index ${n}.`),t.shape[n]-i[n])),[i,s]}function yO(t,e,n,i,r,s,o,a,l){let c=e.slice(),u=n.slice(),h=i;null==i&&(h=new Array(c.length));const d=iO(o);if(d.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==o&&0!==a)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==o&&0!==l)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const p=t.length-c.length,f=iO(a),m=t.slice();f.forEach(t=>{c[t]=0,u[t]=1,m.splice(t,0,1)});const{begin:g,end:y,strides:v}=lO(m,d,p,c,u,h,r,s,o);c=g,u=y,h=v;const b=iO(l);b.forEach(t=>{u[t]=c[t]+1,h[t]=1});const A=rO(c,u,h),x=A.filter((t,e)=>-1===b.indexOf(e));return{nonStrided:h.every(t=>1===t),$begin:c,$end:u,$strides:h,size:A,newShape:m,outShape:x}}class vO{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class bO{constructor(){this.classNameMap={}}static getMap(){return null==bO.instance&&(bO.instance=new bO),bO.instance}static register(t){bO.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function AO(t){_M(null!=t.className,()=>"Class being registered does not have the static className property defined."),_M("string"==typeof t.className,()=>"className is required to be a string, but got type "+typeof t.className),_M(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),bO.register(t)}function xO(){return _D}function wO(){return _D.memory()}function _O(t,e){return _D.tidy(t,e)}function SO(t){yD(t).forEach(t=>t.dispose())}function EO(t){return _D.keep(t)}function CO(t,e,n=1){return _D.registerBackend(t,e,n)}function IO(t){return _D.customGrad(t)}function TO(t,e){if((GM(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&GM(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return BD(t,[],[],e)}nD=function(t){hk().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};class MO extends vO{minimize(t,e=!1,n){const{value:i,grads:r}=this.computeGradients(t,n);if(null!=n){const t=n.map(t=>({name:t.name,tensor:r[t.name]}));this.applyGradients(t)}else this.applyGradients(r);return SO(r),e?i:(i.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function(t,e){_M(KM(t),()=>"The f passed in variableGrads(f) must be a function"),_M(null==e||Array.isArray(e)&&e.every(t=>t instanceof sD),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=null!=e;if(!n){e=[];for(const t in _D.registeredVariables)e.push(_D.registeredVariables[t])}const i=n?e.filter(t=>!t.trainable):null,r=e.length;_M((e=e.filter(t=>t.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const{value:s,grads:o}=_D.gradients(t,e,null,!0);_M(o.some(t=>null!=t),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),_M(0===s.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`);const a={};return e.forEach((t,e)=>{null!=o[e]&&(a[t.name]=o[e])}),null!=i&&i.forEach(t=>a[t.name]=null),{value:s,grads:a}}(t,e)}dispose(){null!=this.iterations_&&SO(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:TO(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(MO,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});const kO=LD({abs_:function(t){const e=RD(t,"x","abs");return _D.runKernel("complex64"===e.dtype?Uk:gk,{x:e})}}),RO=LD({add_:function(t,e){let n=RD(t,"a","add"),i=RD(e,"b","add");return[n,i]=fD(n,i),_D.runKernel(bk,{a:n,b:i})}}),NO=LD({all_:function(t,e=null,n=!1){const i=RD(t,"x","all","bool");return _D.runKernel(xk,{x:i},{axis:e,keepDims:n})}}),LO=LD({any_:function(t,e=null,n=!1){const i=RD(t,"x","any","bool");return _D.runKernel(wk,{x:i},{axis:e,keepDims:n})}}),DO=LD({argMax_:function(t,e=0){const n=RD(t,"x","argMax");return _D.runKernel(_k,{x:n},{axis:e})}});function BO(t,e,n,i,r="NHWC",s){return FO(t,[...e,t[3]],n,s,i,null,null,QO(r))}function OO(t,e,n,i,r,s,o="channelsLast"){const[a,l]=UO(e);let c;if("channelsLast"===o)c=[a,l,t[3],t[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);c=[a,l,t[1],t[1]]}return FO(t,c,n,i,r,s,!1,o)}function PO(t,e,n,i,r,s,o="NDHWC"){const[a,l,c]=HO(e);let u,h;if("NDHWC"===o)h="channelsLast",u=[a,l,c,t[4],t[4]];else{if("NCDHW"!==o)throw new Error(`Unknown dataFormat ${o}`);h="channelsFirst",u=[a,l,c,t[1],t[1]]}return $O(t,u,n,i,r,!1,h,s)}function FO(t,e,n,i,r,s,o=!1,a="channelsLast"){let[l,c,u,h]=[-1,-1,-1,-1];if("channelsLast"===a)[l,c,u,h]=t;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,h,c,u]=t}const[d,p,,f]=e,[m,g]=UO(n),[y,v]=UO(i),b=VO(d,y),A=VO(p,v),{padInfo:x,outHeight:w,outWidth:_}=function(t,e,n,i,r,s,o,a,l){let c,u,h;if("number"==typeof t){c={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const r=function(t,e,n,i,r){null==i&&(i=zO(t,e,n));const s=t[1];return[GO((t[0]-e+2*i)/n+1,r),GO((s-e+2*i)/n+1,r)]}([e,n],s,i,t,a);u=r[0],h=r[1]}else if("same"===t){u=Math.ceil(e/i),h=Math.ceil(n/r);const t=Math.max(0,(u-1)*i+s-e),a=Math.max(0,(h-1)*r+o-n),l=Math.floor(t/2),d=t-l,p=Math.floor(a/2);c={top:l,bottom:d,left:p,right:a-p,type:"SAME"}}else if("valid"===t)c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-s+1)/i),h=Math.ceil((n-o+1)/r);else{if("object"!=typeof t)throw Error(`Unknown padding parameter: ${t}`);{const d="channelsLast"===l?t[1][0]:t[2][0],p="channelsLast"===l?t[1][1]:t[2][1],f="channelsLast"===l?t[2][0]:t[3][0],m="channelsLast"===l?t[2][1]:t[3][1];c={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},u=GO((e-s+d+p)/i+1,a),h=GO((n-o+f+m)/r+1,a)}}return{padInfo:c,outHeight:u,outWidth:h}}(r,c,u,m,g,b,A,s,a),S=o?f*h:f;let E;return"channelsFirst"===a?E=[l,S,w,_]:"channelsLast"===a&&(E=[l,w,_,S]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:u,inChannels:h,outHeight:w,outWidth:_,outChannels:S,padInfo:x,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:b,effectiveFilterWidth:A,dilationHeight:y,dilationWidth:v,inShape:t,outShape:E,filterShape:e}}function $O(t,e,n,i,r,s=!1,o="channelsLast",a){let[l,c,u,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[l,c,u,h,d]=t;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,d,c,u,h]=t}const[p,f,m,,g]=e,[y,v,b]=HO(n),[A,x,w]=HO(i),_=VO(p,A),S=VO(f,x),E=VO(m,w),{padInfo:C,outDepth:I,outHeight:T,outWidth:M}=function(t,e,n,i,r,s,o,a,l,c,u){let h,d,p,f;if("number"==typeof t){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const s=function(t,e,n,i,r,s){null==r&&(r=zO(t,e,i));const o=t[1],a=t[2];return[GO((t[0]-e+2*r)/i+1,s),GO((o-e+2*r)/i+1,s),GO((a-e+2*r)/i+1,s),1]}([e,n,i,1],a,0,r,t,u);d=s[0],p=s[1],f=s[2]}else if("same"===t){d=Math.ceil(e/r),p=Math.ceil(n/s),f=Math.ceil(i/o);const t=(d-1)*r+a-e,u=(p-1)*s+l-n,m=(f-1)*o+c-i,g=Math.floor(t/2),y=t-g,v=Math.floor(u/2),b=u-v,A=Math.floor(m/2);h={top:v,bottom:b,left:A,right:m-A,front:g,back:y,type:"SAME"}}else{if("valid"!==t)throw Error(`Unknown padding parameter: ${t}`);h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((e-a+1)/r),p=Math.ceil((n-l+1)/s),f=Math.ceil((i-c+1)/o)}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(r,c,u,h,y,v,b,_,S,E,a),k=s?g*d:g;let R;return"channelsFirst"===o?R=[l,k,I,T,M]:"channelsLast"===o&&(R=[l,I,T,M,k]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:u,inWidth:h,inChannels:d,outDepth:I,outHeight:T,outWidth:M,outChannels:k,padInfo:C,strideDepth:y,strideHeight:v,strideWidth:b,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:_,effectiveFilterHeight:S,effectiveFilterWidth:E,dilationDepth:A,dilationHeight:x,dilationWidth:w,inShape:t,outShape:R,filterShape:e}}function zO(t,e,n,i=1){const r=VO(e,i);return Math.floor((t[0]*(n-1)-n+r)/2)}function UO(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function HO(t){return"number"==typeof t?[t,t,t]:t}function VO(t,e){return e<=1?t:t+(t-1)*(e-1)}function GO(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function WO(t){const[e,n,i]=UO(t);return 1===e&&1===n&&1===i}function jO(t,e){return WO(t)||WO(e)}function QO(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}const qO=LD({reshape_:function(t,e){const n=RD(t,"x","reshape","string_or_numeric");return _D.runKernel(AN,{x:n},{shape:e})}}),XO=LD({avgPool_:function(t,e,n,i,r){const s=RD(t,"x","avgPool","float32");_M(jO(n,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`);let o=s,a=!1;3===s.rank&&(a=!0,o=qO(s,[1,s.shape[0],s.shape[1],s.shape[2]])),_M(4===o.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),null!=r&&_M(kM(i),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${r} but got pad ${i}.`);let l=_D.runKernel(kk,{x:o},{filterSize:e,strides:n,pad:i,dimRoundingMode:r});return l=NB(l,s.dtype),a?qO(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),YO=LD({avgPool3d_:function(t,e,n,i,r,s="NDHWC"){const o=RD(t,"x","avgPool3d","float32");let a=o,l=!1;4===o.rank&&(l=!0,a=qO(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),_M(5===a.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),_M("NDHWC"===s,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),null!=r&&_M(kM(i),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${r} but got pad ${i}.`);let c=_D.runKernel(Nk,{x:a},{filterSize:e,strides:n,pad:i,dimRoundingMode:r,dataFormat:s});return c=NB(c,a.dtype),l?qO(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),KO=LD({batchNorm_:function(t,e,n,i,r,s){null==s&&(s=.001);const o=RD(t,"x","batchNorm"),a=RD(e,"mean","batchNorm"),l=RD(n,"variance","batchNorm");let c,u;null!=r&&(c=RD(r,"scale","batchNorm")),null!=i&&(u=RD(i,"offset","batchNorm")),_M(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),_M(null==u||a.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),_M(null==c||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h=function(t){let e;return e=0===t.rank||1===t.rank?qO(t,[1,1,1,t.size]):2===t.rank?qO(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?qO(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,e}(o),d=_D.runKernel(wR,{x:h,scale:c,offset:u,mean:a,variance:l},{varianceEpsilon:s});return qO(d,o.shape)}}),JO=LD({batchNorm2d_:function(t,e,n,i,r,s){const o=RD(t,"x","batchNorm"),a=RD(e,"mean","batchNorm"),l=RD(n,"variance","batchNorm");let c,u;return null!=r&&(c=RD(r,"scale","batchNorm")),null!=i&&(u=RD(i,"offset","batchNorm")),_M(2===o.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),_M(2===a.rank||1===a.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),_M(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=c&&_M(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),null!=u&&_M(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),KO(o,a,l,u,c,s)}}),ZO=LD({batchNorm3d_:function(t,e,n,i,r,s){const o=RD(t,"x","batchNorm"),a=RD(e,"mean","batchNorm"),l=RD(n,"variance","batchNorm");let c,u;return null!=r&&(c=RD(r,"scale","batchNorm")),null!=i&&(u=RD(i,"offset","batchNorm")),_M(3===o.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),_M(3===a.rank||1===a.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),_M(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=c&&_M(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),null!=u&&_M(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),KO(o,a,l,u,c,s)}}),tP=LD({batchNorm4d_:function(t,e,n,i,r,s){const o=RD(t,"x","batchNorm"),a=RD(e,"mean","batchNorm"),l=RD(n,"variance","batchNorm");let c,u;return null!=r&&(c=RD(r,"scale","batchNorm")),null!=i&&(u=RD(i,"offset","batchNorm")),_M(4===o.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),_M(4===a.rank||1===a.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),_M(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=c&&_M(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),null!=u&&_M(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),KO(o,a,l,u,c,s)}}),eP=LD({clipByValue_:function(t,e,n){const i=RD(t,"x","clipByValue");return _M(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`),_D.runKernel($k,{x:i},{clipValueMin:e,clipValueMax:n})}}),nP=LD({concat_:function(t,e=0){_M(t.length>=1,()=>"Pass at least one tensor to concat");const n=ND(t,"tensors","concat","string_or_numeric");return"complex64"===n[0].dtype&&n.forEach(t=>{if("complex64"!==t.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${t.dtype}. `)}),1===n.length?LB(n[0]):_D.runKernel(Hk,n,{axis:e})}}),iP=LD({concat1d_:function(t){return nP(t,0)}}),rP=LD({concat2d_:function(t,e){return nP(t,e)}}),sP=LD({concat3d_:function(t,e){return nP(t,e)}}),oP=LD({concat4d_:function(t,e){return nP(t,e)}}),aP=LD({conv2d_:function(t,e,n,i,r="NHWC",s=[1,1],o){const a=RD(t,"x","conv2d"),l=RD(e,"filter","conv2d");let c=a,u=!1;3===a.rank&&(u=!0,c=qO(a,[1,a.shape[0],a.shape[1],a.shape[2]])),_M(4===c.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),_M(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),null!=o&&_M(kM(i),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${i}.`);const h="NHWC"===r?c.shape[3]:c.shape[1];_M(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),_M(jO(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`);const d=_D.runKernel(Vk,{x:c,filter:l},{strides:n,pad:i,dataFormat:r,dilations:s,dimRoundingMode:o});return u?qO(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),lP=LD({conv1d_:function(t,e,n,i,r="NWC",s=1,o){const a=RD(t,"x","conv1d"),l=RD(e,"filter","conv1d");let c=a,u=!1;2===a.rank&&(u=!0,c=qO(a,[1,a.shape[0],a.shape[1]])),_M(3===c.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),_M(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),null!=o&&_M(kM(i),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${i}.`),_M(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),_M(jO(n,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`),_M("NWC"===r,()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const h=qO(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=qO(c,[c.shape[0],1,c.shape[1],c.shape[2]]),p=aP(d,h,[1,n],i,"NHWC",[1,s],o);return qO(p,u?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}}),cP=LD({conv2DBackpropInput_:function(t,e,n,i,r,s="NHWC",o){_M(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let a=t,l=e,c=!1;3===e.rank&&(c=!0,l=qO(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,t[0],t[1],t[2]]),_M(4===a.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),_M(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),_M(4===n.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const u="NHWC"===s?a[3]:a[1],h="NHWC"===s?l.shape[3]:l.shape[1];_M(u===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[2]}.`),_M(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),null!=o&&_M(kM(r),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`);const d=_D.runKernel(Wk,{dy:l,filter:n},{strides:i,pad:r,dataFormat:s,dimRoundingMode:o,inputShape:a});return c?qO(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),uP=LD({conv2dTranspose_:function(t,e,n,i,r,s){const o=RD(t,"x","conv2dTranspose"),a=RD(e,"filter","conv2dTranspose");return cP(n,o,a,i,r,"NHWC",s)}}),hP=LD({conv3d_:function(t,e,n,i,r="NDHWC",s=[1,1,1]){const o=RD(t,"x","conv3d"),a=RD(e,"filter","conv3d");let l=o,c=!1;4===o.rank&&(c=!0,l=qO(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),_M(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),_M(5===a.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),_M(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),_M(jO(n,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),_M("NDHWC"===r,()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`);const u=_D.runKernel(jk,{x:l,filter:a},{strides:n,pad:i,dataFormat:r,dilations:s});return c?qO(u,[u.shape[1],u.shape[2],u.shape[3],u.shape[4]]):u}}),dP=LD({conv3DBackpropInput_:function(t,e,n,i,r){_M(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let s=t,o=e,a=!1;4===e.rank&&(a=!0,o=qO(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,t[0],t[1],t[2],t[3]]);const l=s[4],c=o.shape[4];_M(5===s.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),_M(5===o.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),_M(5===n.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),_M(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),_M(c===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[4]}.`);const u=_D.runKernel(qk,{dy:o,filter:n},{pad:r,strides:i,inputShape:s});return a?qO(u,[u.shape[1],u.shape[2],u.shape[3],u.shape[4]]):u}}),pP=LD({conv3dTranspose_:function(t,e,n,i,r){const s=RD(t,"x","conv3dTranspose"),o=RD(e,"filter","conv3dTranspose");return dP(n,s,o,i,r)}}),fP=LD({depthwiseConv2d_:function(t,e,n,i,r="NHWC",s=[1,1],o){const a=RD(t,"x","depthwiseConv2d"),l=RD(e,"filter","depthwiseConv2d");let c=a,u=!1;3===a.rank&&(u=!0,c=qO(a,[1,a.shape[0],a.shape[1],a.shape[2]])),_M(4===c.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),_M(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`),_M(c.shape[3]===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),null!=o&&_M(kM(i),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${i}.`);const h=_D.runKernel(eR,{x:c,filter:l},{strides:n,pad:i,dataFormat:r,dilations:s,dimRoundingMode:o});return u?qO(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),mP=LD({floorDiv_:function(t,e){let n=RD(t,"a","floorDiv"),i=RD(e,"b","floorDiv");return[n,i]=fD(n,i),_D.runKernel(xR,{a:n,b:i})}}),gP=LD({div_:function(t,e){let n=RD(t,"a","div"),i=RD(e,"b","div");return[n,i]=fD(n,i),"int32"===n.dtype&&"int32"===i.dtype?mP(n,i):_D.runKernel(lR,{a:n,b:i},{})}}),yP=LD({matMul_:function(t,e,n=!1,i=!1){let r=RD(t,"a","matMul"),s=RD(e,"b","matMul");return[r,s]=fD(r,s),_D.runKernel(Dk,{a:r,b:s},{transposeA:n,transposeB:i})}}),vP=LD({dot_:function(t,e){const n=RD(t,"t1","dot"),i=RD(e,"t2","dot");_M(!(1!==n.rank&&2!==n.rank||1!==i.rank&&2!==i.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${i.rank}.`);const r=1===n.rank?n.size:n.shape[1],s=1===i.rank?i.size:i.shape[0];if(_M(r===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${s}.`),1===n.rank&&1===i.rank){const t=qO(n,[1,-1]),e=qO(i,[-1,1]),r=yP(t,e);return qO(r,[])}if(1===n.rank&&2===i.rank){const t=qO(n,[1,-1]),e=qO(i,[i.shape[0],i.shape[1]]),r=yP(t,e);return qO(r,[r.size])}if(2===n.rank&&1===i.rank){const t=qO(i,[-1,1]),e=yP(n,t);return qO(e,[e.size])}{const t=qO(i,[i.shape[0],i.shape[1]]);return yP(n,t)}}}),bP=LD({elu_:function(t){const e=RD(t,"x","elu");return _D.runKernel(uR,{x:e})}});function AP(t,e){const n=t.length,i=[];for(let r=0;r<n;r++){const s=n-1-r,o=t[s]||1;(e[e.length-1-r]||1)>1&&1===o&&i.unshift(s)}return i}function xP(t,e){const n=[];for(let i=0;i<e.length;i++){const r=t[t.length-i-1],s=e.length-i-1,o=e[s];(null==r||1===r&&o>1)&&n.unshift(s)}return n}function wP(t,e){const n=[],i=Math.max(t.length,e.length);for(let r=0;r<i;r++){let i=t[t.length-r-1];null==i&&(i=1);let s=e[e.length-r-1];if(null==s&&(s=1),1===i)n.unshift(s);else if(1===s)n.unshift(i);else{if(i!==s)throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`);n.unshift(i)}}return n}const _P=LD({equal_:function(t,e){let n=RD(t,"a","equal","string_or_numeric"),i=RD(e,"b","equal","string_or_numeric");return[n,i]=fD(n,i),wP(n.shape,i.shape),_D.runKernel(pR,{a:n,b:i})}}),SP=LD({exp_:function(t){const e=RD(t,"x","exp");return _D.runKernel(fR,{x:e})}}),EP=LD({expandDims_:function(t,e=0){const n=RD(t,"x","expandDims","string_or_numeric");return _M(e<=n.rank,()=>"Axis must be <= rank of the tensor"),_D.runKernel(mR,{input:n},{dim:e})}}),CP=LD({tile_:function(t,e){const n=RD(t,"x","tile","string_or_numeric");return _M(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`),_D.runKernel(iL,{x:n},{reps:e})}}),IP=LD({eye_:function(t,e,n,i="float32"){null==e&&(e=t);const r=RB([t,e],i),s=t<=e?t:e;for(let a=0;a<s;++a)r.set(1,a,a);const o=qO(r.toTensor(),[t,e]);if(null==n)return o;if(1===n.length)return CP(EP(o,0),[n[0],1,1]);if(2===n.length)return CP(EP(EP(o,0),0),[n[0],n[1],1,1]);if(3===n.length)return CP(EP(EP(EP(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});function TP(t,e,n){return _D.runKernel(vR,{},{shape:t,value:e,dtype:n})}const MP=LD({floor_:function(t){const e=RD(t,"x","floor");return _D.runKernel(AR,{x:e})}}),kP=LD({gather_:function(t,e,n=0,i=0){const r=RD(t,"x","gather"),s=RD(e,"indices","gather","int32");return _D.runKernel(_R,{x:r,indices:s},{axis:n,batchDims:i})}}),RP=LD({greater_:function(t,e){let n=RD(t,"a","greater","string_or_numeric"),i=RD(e,"b","greater","string_or_numeric");return[n,i]=fD(n,i),wP(n.shape,i.shape),_D.runKernel(ER,{a:n,b:i})}}),NP=LD({greaterEqual_:function(t,e){let n=RD(t,"a","greaterEqual","string_or_numeric"),i=RD(e,"b","greaterEqual","string_or_numeric");return[n,i]=fD(n,i),wP(n.shape,i.shape),_D.runKernel(CR,{a:n,b:i})}}),LP=LD({isNaN_:function(t){const e=RD(t,"x","isNaN");return _D.runKernel(NR,{x:e})}}),DP=LD({leakyRelu_:function(t,e=.2){const n=RD(t,"x","leakyRelu");return _D.runKernel(LR,{x:n},{alpha:e})}}),BP=LD({log_:function(t){const e=RD(t,"x","log");return _D.runKernel(PR,{x:e})}}),OP=LD({log1p_:function(t){const e=RD(t,"x","log1p");return _D.runKernel(FR,{x:e})}}),PP=LD({max_:function(t,e=null,n=!1){const i=RD(t,"x","max");return _D.runKernel(GR,{x:i},{reductionIndices:e,keepDims:n})}}),FP=LD({mul_:function(t,e){let n=RD(t,"a","mul"),i=RD(e,"b","mul");return[n,i]=fD(n,i),_D.runKernel(iN,{a:n,b:i})}}),$P=LD({sub_:function(t,e){let n=RD(t,"a","sub"),i=RD(e,"b","sub");return[n,i]=fD(n,i),_D.runKernel(tL,{a:n,b:i})}}),zP=LD({sum_:function(t,e=null,n=!1){let i=RD(t,"x","sum");return"bool"===i.dtype&&(i=NB(i,"int32")),_D.runKernel($N,{x:i},{axis:e,keepDims:n})}}),UP=LD({logSoftmax_:function(t,e=-1){const n=RD(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return IO((t,n)=>{const i=PP(t,e,!0),r=$P(t,i),s=$P(NB(r,"float32"),BP(zP(SP(r),e,!0)));return n([s]),{value:s,gradFunc:(t,n)=>{const[i]=n,r=SP(i);return $P(t,FP(zP(t,e,!0),r))}}})(n)}}),HP=LD({logicalAnd_:function(t,e){const n=RD(t,"a","logicalAnd","bool"),i=RD(e,"b","logicalAnd","bool");return wP(n.shape,i.shape),_D.runKernel($R,{a:n,b:i})}}),VP=LD({maxPool_:function(t,e,n,i,r){const s=RD(t,"x","maxPool");let o=s,a=!1;3===s.rank&&(a=!0,o=qO(s,[1,s.shape[0],s.shape[1],s.shape[2]])),_M(4===o.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),_M(jO(n,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`),null!=r&&_M(kM(i),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${r} but got pad ${i}.`);const l=_D.runKernel(jR,{x:o},{filterSize:e,strides:n,pad:i,dimRoundingMode:r});return a?qO(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),GP=LD({maxPool3d_:function(t,e=[1,1,1],n,i,r,s="NDHWC"){const o=RD(t,"x","maxPool3d");let a=o,l=!1;4===o.rank&&(l=!0,a=qO(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),_M(5===a.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),_M("NDHWC"===s,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),null!=r&&_M(kM(i),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${r} but got pad ${i}.`);const c=_D.runKernel(qR,{x:a},{filterSize:e,strides:n,pad:i,dimRoundingMode:r,dataFormat:s});return l?qO(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),WP=LD({maximum_:function(t,e){let n=RD(t,"a","maximum"),i=RD(e,"b","maximum");return[n,i]=fD(n,i),"bool"===n.dtype&&(n=NB(n,"int32"),i=NB(i,"int32")),wP(n.shape,i.shape),_D.runKernel(WR,{a:n,b:i})}}),jP=LD({mean_:function(t,e=null,n=!1){const i=RD(t,"x","mean");return _D.runKernel(KR,{x:i},{axis:e,keepDims:n})}}),QP=LD({minimum_:function(t,e){let n=RD(t,"a","minimum"),i=RD(e,"b","minimum");return[n,i]=fD(n,i),"bool"===n.dtype&&(n=NB(n,"int32"),i=NB(i,"int32")),wP(n.shape,i.shape),_D.runKernel(ZR,{a:n,b:i})}});function qP(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function XP(t,e,n){const i=t.length+e.length,r=[];let s=0,o=0;for(let a=0;a<i;a++)-1===n.indexOf(a)?r.push(t[s++]):r.push(e[o++]);return r}function YP(t,e){const n=[],i=t.length;for(let r=0;r<i;r++)-1===e.indexOf(r)&&n.push(t[r]);return[n,e.map(e=>t[e])]}function KP(t,e){return XP(t,e.map(t=>1),e)}function JP(t,e,n){_M(qP(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function ZP(t,e){if(qP(t,e))return null;const n=[];for(let i=0;i<e;++i)-1===t.indexOf(i)&&n.push(i);return t.forEach(t=>n.push(t)),n}function tF(t){return t.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function eF(t,e){const n=[];for(let i=e-t;i<e;++i)n.push(i);return n}const nF=LD({square_:function(t){const e=RD(t,"x","square");return _D.runKernel("Square",{x:e},{})}}),iF=LD({moments_:function(t,e=null,n=!1){const i=PM(e,(t=RD(t,"x","moments")).shape),r=jP(t,i,n);let s=r.shape;n||(s=KP(r.shape,i));const o=nF($P(NB(t,"float32"),qO(r,s)));return{mean:r,variance:jP(o,i,n)}}}),rF=LD({neg_:function(t){const e=RD(t,"x","neg");return _D.runKernel(rN,{x:e})}}),sF=LD({notEqual_:function(t,e){let n=RD(t,"a","notEqual","string_or_numeric"),i=RD(e,"b","notEqual","string_or_numeric");return[n,i]=fD(n,i),wP(n.shape,i.shape),_D.runKernel(sN,{a:n,b:i})}}),oF=LD({oneHot_:function(t,e,n=1,i=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const r=RD(t,"indices","oneHot","int32");return _D.runKernel(uN,{indices:r},{depth:e,onValue:n,offValue:i})}});function aF(t,e="float32"){if("complex64"===e){const e=aF(t,"float32"),n=aF(t,"float32");return DD(e,n)}const n=ik(IM(t),e);return _D.makeTensor(n,t,e)}function lF(t,e="float32"){if("complex64"===e){const e=lF(t,"float32"),n=aF(t,"float32");return DD(e,n)}const n=nk(IM(t),e);return _D.makeTensor(n,t,e)}const cF=LD({onesLike_:function(t){const e=RD(t,"x","onesLike");return _D.runKernel(cN,{x:e})}}),uF=LD({pad_:function(t,e,n=0){const i=RD(t,"x","pad");if(0===i.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return _D.runKernel(dN,{x:i},{paddings:e,constantValue:n})}}),hF=LD({pow_:function(t,e){let n=RD(t,"base","pow"),i=RD(e,"exp","pow");return[n,i]=fD(n,i),_D.runKernel(pN,{a:n,b:i})}}),dF=LD({prelu_:function(t,e){const n=RD(t,"x","prelu"),i=RD(e,"alpha","prelu");return _D.runKernel(fN,{x:n,alpha:i})}});var pF=n("pDBr");class fF{constructor(t,e,n,i,r){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=i,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=r||Math.random();this.random=pF.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let i,r,s;do{i=2*this.random()-1,r=2*this.random()-1,s=i*i+r*r}while(s>=1||0===s);const o=Math.sqrt(-2*Math.log(s)/s);t=this.mean+this.stdDev*i*o,e=this.mean+this.stdDev*r*o,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class mF{constructor(t=0,e=1,n,i){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=n,null==i&&(i=Math.random()),"number"==typeof i&&(i=i.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=pF.alea(i)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const gF=LD({randomNormal_:function(t,e=0,n=1,i,r){if(null!=i&&"bool"===i)throw new Error(`Unsupported data type ${i}`);const s=new fF(e,n,i,!1,r),o=RB(t,i);for(let a=0;a<o.values.length;a++)o.values[a]=s.nextValue();return o.toTensor()}}),yF=LD({randomUniform_:function(t,e=0,n=1,i="float32",r){const s=RB(t,i),o=new mF(e,n,null,r);for(let a=0;a<s.values.length;a++)s.values[a]=o.nextValue();return s.toTensor()}}),vF=LD({relu_:function(t){const e=RD(t,"x","relu");return _D.runKernel(bN,{x:e})}}),bF=LD({reverse_:function(t,e){const n=RD(t,"x","reverse");return _D.runKernel(CN,{x:n},{dims:e})}}),AF=LD({selu_:function(t){const e=RD(t,"x","selu");return _D.runKernel(RN,{x:e})}}),xF=LD({separableConv2d_:function(t,e,n,i,r,s=[1,1],o="NHWC"){const a=RD(t,"x","separableConv2d"),l=RD(e,"depthwiseFilter","separableConv2d"),c=RD(n,"pointwiseFilter","separableConv2d");let u=a,h=!1;if(3===a.rank&&(h=!0,u=qO(a,[1,a.shape[0],a.shape[1],a.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");_M(4===u.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),_M(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),_M(4===c.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),_M(1===c.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),_M(1===c.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const d=l.shape[2],p=l.shape[3];_M(c.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${c.shape[2]}.`);const f=fP(u,l,i,r,o,s),m=aP(f,c,1,"valid",o);return h?qO(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),wF=LD({sigmoid_:function(t){const e=RD(t,"x","sigmoid");return _D.runKernel(ON,{x:e})}}),_F=LD({slice_:function(t,e,n){const i=RD(t,"x","slice","string_or_numeric");if(0===i.rank)throw new Error("Slicing scalar is not possible");return _D.runKernel(NN,{x:i},{begin:e,size:n})}}),SF=LD({slice1d_:function(t,e,n){const i=RD(t,"x","slice1d");return _M(1===i.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${i.rank} tensor`),_F(i,[e],[n])}}),EF=LD({slice2d_:function(t,e,n){const i=RD(t,"x","slice2d");return _M(2===i.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${i.rank} tensor`),_F(i,e,n)}}),CF=LD({slice3d_:function(t,e,n){const i=RD(t,"x","slice3d");return _M(3===i.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${i.rank} tensor`),_F(i,e,n)}}),IF=LD({slice4d_:function(t,e,n){const i=RD(t,"x","slice4d");return _M(4===i.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${i.rank} tensor`),_F(i,e,n)}}),TF=LD({softmax_:function(t,e=-1){const n=RD(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);return _D.runKernel(HN,{logits:n},{dim:e})}}),MF=LD({softplus_:function(t){const e=RD(t,"x","softplus");return _D.runKernel(PN,{x:e})}}),kF=LD({split_:function(t,e,n=0){const i=RD(t,"x","split");return _D.runKernel(UN,{x:i},{numOrSizeSplits:e,axis:n})}}),RF=LD({sqrt_:function(t){const e=RD(t,"x","sqrt");return _D.runKernel(FN,{x:e})}}),NF=LD({squeeze_:function(t,e){const n=RD(t,"x","squeeze");return qO(n,FM(n.shape,e).newShape)}}),LF=LD({stack_:function(t,e=0){const n=ND(t,"tensors","stack","string_or_numeric");return _M(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&_M(e<=n[0].rank,()=>"Axis must be <= rank of the tensor"),_D.runKernel(hN,n,{axis:e})}}),DF=LD({tanh_:function(t){const e=RD(t,"x","tanh");return _D.runKernel(nL,{x:e})}});function BF(t,e){EM(t);const n=TD(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return BD(t,null,n,e)}function OF(t,e,n){if(EM(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const i=TD(t,n);if(2!==i.length&&1!==i.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===i.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return BD(t,e,i,n)}const PF=LD({truncatedNormal_:function(t,e=0,n=1,i,r){if(null!=i&&"bool"===i)throw new Error("Unsupported data type $ { dtype }");const s=new fF(e,n,i,!0,r),o=RB(t,i);for(let a=0;a<o.values.length;a++)o.values[a]=s.nextValue();return o.toTensor()}}),FF=LD({unstack_:function(t,e=0){const n=RD(t,"x","unstack","string_or_numeric");return _M(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`),_D.runKernel(lL,{value:n},{axis:e})}}),$F=LD({broadcastTo_:function(t,e){let n=RD(t,"broadcastTo","x");const i=n.shape;if(e.some(t=>!(t>0)||t%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=qO(n,t)}const r=n.shape,s=Array.from(e);for(let o=e.length-1;o>=0;o--)if(r[o]===e[o])s[o]=1;else if(1!==n.shape[o])throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${e}].`);return 0===s.map((t,e)=>t>1?e:-1).filter(t=>t>=0).length?LB(n):_D.runKernel(iL,{x:n},{reps:s})}}),zF=LD({where_:function(t,e,n){const i=RD(e,"a","where"),r=RD(n,"b","where"),s=RD(t,"condition","where","bool"),o=wP(wP(s.shape,i.shape),r.shape),a=$F(s,o),l=$F(i,o),c=$F(r,o);return _D.runKernel(kN,{condition:a,t:l,e:c})}}),UF=LD({zerosLike_:function(t){const e=RD(t,"x","zerosLike");return _D.runKernel(uL,{x:e})}}),HF=LD({transpose_:function(t,e){const n=RD(t,"x","transpose");return null==e&&(e=n.shape.map((t,e)=>e).reverse()),_M(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`),e.forEach(t=>{_M(t>=0&&t<n.rank,()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${e}`)}),n.rank<=1?n.clone():_D.runKernel(oL,{x:n},{perm:e})}}),VF=LD({dropout_:function(t,e,n,i){const r=RD(t,"x","dropout");if(_M("float32"===r.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),_M(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),0===e)return t instanceof iD?r.clone():r;const s=function(t,e){if(null==e)return t.shape.slice();if(MM(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let i=0;i<t.shape.length;i++)n.push(null==e[i]&&null!=t.shape[i]?t.shape[i]:e[i]);return n}return e}(r,n),o=1-e,a=gP(MP(RO(yF(s,0,1,"float32",i),o)),o);return FP(r,a)}}),GF=LD({imag_:function(t){const e=RD(t,"input","imag");return _D.runKernel(MR,{input:e})}}),WF=LD({real_:function(t){const e=RD(t,"input","real");return _D.runKernel(yN,{input:e})}}),jF=LD({fft_:function(t){return _M("complex64"===t.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`),_D.runKernel(yR,{input:t})}}),QF=LD({rfft_:function(t,e){_M("float32"===t.dtype,()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const i=t.size/n;let r;if(null!=e&&e<n){const i=t.shape.map(t=>0),s=t.shape.map(t=>t);s[t.shape.length-1]=e,r=_F(t,i,s),n=e}else if(null!=e&&e>n){const i=t.shape.map(t=>t);i[t.shape.length-1]=e-n,r=nP([t,aF(i)],t.shape.length-1),n=e}else r=t;const s=UF(r),o=qO(DD(r,s),[i,n]),a=jF(o),l=Math.floor(n/2)+1,c=WF(a),u=GF(a),h=kF(c,[l,n-l],c.shape.length-1),d=kF(u,[l,n-l],u.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=l,qO(DD(h[0],d[0]),p)}}),qF=LD({ifft_:function(t){return _M("complex64"===t.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`),_D.runKernel(TR,{input:t})}}),XF=LD({irfft_:function(t){const e=t.shape[t.shape.length-1],n=t.size/e;let i;if(e<=2){const r=qO(t,[n,e]);i=qF(r)}else{const r=[n,2*(e-1)],s=qO(WF(t),[n,e]),o=qO(GF(t),[n,e]),a=bF(_F(s,[0,1],[n,e-2]),1),l=FP(bF(_F(o,[0,1],[n,e-2]),1),TO(-1)),c=nP([s,a],1),u=nP([o,l],1),h=qO(DD(c,u),[r[0],r[1]]);i=qF(h)}if(i=WF(i),3===t.rank&&0!==t.shape[0]){const e=i,n=t.shape[0];i=qO(i,[n,i.shape[0]/n,i.shape[1]]),e.dispose()}return i}}),YF=LD({conv2DBackpropFilter_:function(t,e,n,i,r,s="NHWC",o){let a=t;3===t.rank&&(a=qO(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=qO(e,[1,e.shape[0],e.shape[1],e.shape[2]])),_M(4===a.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),_M(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),_M(4===n.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const c="NHWC"===s?a.shape[3]:a.shape[1],u="NHWC"===s?l.shape[3]:l.shape[1];return _M(c===n[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${n[2]}.`),_M(u===n[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${n[3]}).`),null!=o&&_M(kM(r),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`),_D.runKernel(Gk,{x:a,dy:l},{strides:i,pad:r,dataFormat:s,dimRoundingMode:o,filterShape:n})}}),KF=LD({relu6_:function(t){const e=RD(t,"x","relu6");return _D.runKernel(EN,{x:e})}}),JF=LD({step_:function(t,e=0){const n=RD(t,"x","step");return _D.runKernel(hL,{x:n},{alpha:e})}});function ZF(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return FP(t,JF(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function t$(t,e){let n=e;const i=xP(t.shape,e.shape);return i.length>0&&(n=zP(n,i)),qO(n,t.shape)}function e$(t,e,n,i){if("linear"===e)return t;if("relu"===e)return vF(t);if("elu"===e)return bP(t);if("relu6"===e)return KF(t);if("prelu"===e)return dF(t,n);if("leakyrelu"===e)return DP(t,i);if("sigmoid"===e)return wF(t);throw new Error(`Unknown fused activation ${e}.`)}const n$=(t,e)=>!(t>0)||"linear"===e,i$=LD({fusedConv2d_:function({x:t,filter:e,strides:n,pad:i,dataFormat:r="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(!1===n$(_D.state.gradientDepth,l=l||"linear")){let h=aP(t,e,n,i,r,s,o);return null!=a&&(h=RO(h,a)),e$(h,l,c,u)}const h=RD(t,"x","conv2d"),d=RD(e,"filter","conv2d");let p=h,f=!1;3===h.rank&&(f=!0,p=qO(h,[1,h.shape[0],h.shape[1],h.shape[2]])),_M(4===p.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),_M(4===d.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),null!=o&&_M(kM(i),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${i}.`),_M(p.shape[3]===d.shape[2],()=>`Error in conv2d: depth of input (${p.shape[3]}) must match input depth for filter ${d.shape[2]}.`),_M(jO(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),_M("NHWC"===r,()=>`Error in conv2d: got dataFormat of ${r} but only NHWC is currently supported.`);const m=FO(p.shape,d.shape,n,s,i,o);let g,y;null!=a&&(g=RD(a,"bias","fused conv2d"),[g]=fD(g,h),wP(m.outShape,g.shape)),null!=c&&(y=RD(c,"prelu weights","fused conv2d"));const v=(t,e)=>{const[r,o,a,c]=e,u=ZF(t,a,l);_M(WO(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const h=[cP(o.shape,u,r,n,i),YF(o,u,r.shape,n,i)];if(null!=c){const t=t$(c,u);h.push(t)}return h},b={x:p,filter:d,bias:g,preluActivationWeights:y},A={strides:n,pad:i,dataFormat:r,dilations:s,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return null==a?IO((t,e,n)=>{let i=_D.runKernel(mL,b,A);return n([e,t,i]),f&&(i=qO(i,[i.shape[1],i.shape[2],i.shape[3]])),{value:i,gradFunc:v}})(p,d):IO((t,e,n,i)=>{let r=_D.runKernel(mL,b,A);return i([e,t,r,n]),f&&(r=qO(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}})(p,d,g)}}),r$=LD({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,i,r,s=[1,1],o){let a=t;3===t.rank&&(a=qO(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;return 3===l.rank&&(l=qO(e,[1,e.shape[0],e.shape[1],e.shape[2]])),_D.runKernel(nR,{x:a,dy:l},{strides:i,pad:r,dimRoundingMode:o,dilations:s,filterShape:n})}}),s$=LD({depthwiseConv2dNativeBackpropInput_:function(t,e,n,i,r,s=[1,1],o){let a=e,l=!1;3===e.rank&&(l=!0,a=qO(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c=_D.runKernel(iR,{dy:a,filter:n},{strides:i,pad:r,dimRoundingMode:o,dilations:s,inputShape:t});return l?qO(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),o$=LD({fusedDepthwiseConv2d_:function({x:t,filter:e,strides:n,pad:i,dataFormat:r="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(!1===n$(_D.state.gradientDepth,l)){let h=fP(t,e,n,i,r,s,o);return null!=a&&(h=RO(h,a)),e$(h,l,c,u)}const h=RD(t,"x","depthwiseConv2d"),d=RD(e,"filter","depthwiseConv2d");let p=h,f=!1;3===h.rank&&(f=!0,p=qO(h,[1,h.shape[0],h.shape[1],h.shape[2]])),_M(4===p.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),_M(4===d.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),_M(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),null==s&&(s=[1,1]),_M(jO(n,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),null!=o&&_M(kM(i),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${o} but got pad ${i}.`);const m=FO(p.shape,d.shape,n,s,i,o,!0);let g,y;null!=a&&(g=RD(a,"bias","fused conv2d"),[g]=fD(g,h),wP(m.outShape,g.shape)),null!=c&&(y=RD(c,"prelu weights","fused depthwiseConv2d"));const v=(t,e)=>{_M(WO(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);const[r,a,c,u]=e,h=ZF(t,c,l),d=s$(a.shape,h,r,n,i,s,o),p=r$(a,h,r.shape,n,i,s,o);return null!=u?[d,p,t$(g,h)]:[d,p]},b={x:p,filter:d,bias:g,preluActivationWeights:y},A={strides:n,pad:i,dataFormat:r,dilations:s,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return null==a?IO((t,e,n)=>{let i=_D.runKernel(gL,b,A);return n([e,t,i]),f&&(i=qO(i,[i.shape[1],i.shape[2],i.shape[3]])),{value:i,gradFunc:v}})(p,d):IO((t,e,n,i)=>{let r=_D.runKernel(gL,b,A);return i([e,t,r,n]),f&&(r=qO(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}})(p,d,g)}}),a$=LD({fusedMatMul_:function({a:t,b:e,transposeA:n=!1,transposeB:i=!1,bias:r,activation:s="linear",preluActivationWeights:o,leakyreluAlpha:a}){if(!1===n$(_D.state.gradientDepth,s)){let l=yP(t,e,n,i);return null!=r&&(l=RO(l,r)),e$(l,s,o,a)}let l=RD(t,"a","fused matMul"),c=RD(e,"b","fused matMul");[l,c]=fD(l,c);const u=n?l.shape[l.rank-2]:l.shape[l.rank-1],h=i?c.shape[c.rank-1]:c.shape[c.rank-2],d=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=i?c.shape[c.rank-2]:c.shape[c.rank-1],f=l.shape.slice(0,-2),m=c.shape.slice(0,-2),g=IM(f),y=IM(m);_M(l.rank>=2&&c.rank>=2&&l.rank===c.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${l.rank} and ${c.rank}.`),_M(MM(f,m),()=>`Error in fused matMul: outer dimensions (${f}) and (${m}) of Tensors with shapes ${l.shape} and ${c.shape} must match.`),_M(u===h,()=>`Error in fused matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${n} and transposeB=${i} must match.`);const v=l.shape.slice(0,-2).concat([d,p]),b=qO(l,n?[g,u,d]:[g,d,u]),A=qO(c,i?[y,p,h]:[y,h,p]);let x,w;null!=r&&(x=RD(r,"bias","fused matMul"),[x]=fD(x,l),wP(v,x.shape)),null!=o&&(w=RD(o,"prelu weights","fused matMul"));const _=(t,e)=>{const[o,a,l,c]=e,u=ZF(qO(t,l.shape),l,s);let h,d;return n||i?!n&&i?(h=yP(u,a,!1,!1),d=yP(u,o,!0,!1)):n&&!i?(h=yP(a,u,!1,!0),d=yP(o,u,!1,!1)):(h=yP(a,u,!0,!0),d=yP(u,o,!0,!0)):(h=yP(u,a,!1,!0),d=yP(o,u,!0,!1)),null!=r?[h,d,t$(c,u)]:[h,d]},S={a:b,b:A,bias:x,preluActivationWeights:w},E={transposeA:n,transposeB:i,activation:s,leakyreluAlpha:a};return null==r?IO((t,e,n)=>{const i=_D.runKernel(fL,S,E);return n([t,e,i]),{value:qO(i,v),gradFunc:_}})(b,A):IO((t,e,n,i)=>{const r=_D.runKernel(fL,S,E);return i([t,e,r,n]),{value:qO(r,v),gradFunc:_}})(b,A,x)}});function l$(t,e,n){const i=1-t%2,r=new Float32Array(t);for(let s=0;s<t;++s){const o=2*Math.PI*s/(t+i-1);r[s]=e-n*Math.cos(o)}return BF(r,"float32")}LD({hammingWindow_:function(t){return l$(t,.54,.46)}});const c$=LD({hannWindow_:function(t){return l$(t,.5,.5)}}),u$=LD({frame_:function(t,e,n,i=!1,r=0){let s=0;const o=[];for(;s+e<=t.size;)o.push(_F(t,s,e)),s+=n;if(i)for(;s<t.size;){const i=s+e-t.size,a=nP([_F(t,s,e-i),TP([i],r)]);o.push(a),s+=n}return 0===o.length?OF([],[0,e]):qO(nP(o),[o.length,e])}});LD({stft_:function(t,e,n,i,r=c$){null==i&&(i=Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2)))));const s=u$(t,e,n),o=FP(s,r(e));return QF(o,i)}});const h$=LD({cropAndResize_:function(t,e,n,i,r="bilinear",s=0){const o=RD(t,"image","cropAndResize"),a=RD(e,"boxes","cropAndResize","float32"),l=RD(n,"boxInd","cropAndResize","int32"),c=a.shape[0];return _M(4===o.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),_M(2===a.rank&&4===a.shape[1],()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),_M(1===l.rank&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),_M(2===i.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${i.length}.`),_M(i[0]>=1&&i[1]>=1,()=>`cropSize must be atleast [1,1], but was ${i}`),_M("bilinear"===r||"nearest"===r,()=>`method must be bilinear or nearest, but was ${r}`),_D.runKernel(Jk,{image:o,boxes:a,boxInd:l},{method:r,extrapolationValue:s,cropSize:i})}}),d$=LD({flipLeftRight_:function(t){const e=RD(t,"image","flipLeftRight","float32");return _M(4===e.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`),_D.runKernel(bR,{image:e},{})}}),p$=LD({rotateWithOffset_:function(t,e,n=0,i=.5){const r=RD(t,"image","rotateWithOffset","float32");return _M(4===r.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`),_D.runKernel(pL,{image:r},{radians:e,fillValue:n,center:i})}});function f$(t,e,n,i,r,s){null==i&&(i=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==s&&(s=0);const o=t.shape[0];return n=Math.min(n,o),_M(0<=i&&i<=1,()=>`iouThreshold must be in [0, 1], but was '${i}'`),_M(2===t.rank,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),_M(4===t.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),_M(1===e.rank,()=>"scores must be a 1D tensor"),_M(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),_M(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:n,iouThreshold:i,scoreThreshold:r,softNmsSigma:s}}const m$=LD({nonMaxSuppression_:function(t,e,n,i=.5,r=Number.NEGATIVE_INFINITY){const s=RD(t,"boxes","nonMaxSuppression"),o=RD(e,"scores","nonMaxSuppression"),a=f$(s,o,n,i,r);return _D.runKernel(oN,{boxes:s,scores:o},{maxOutputSize:n=a.maxOutputSize,iouThreshold:i=a.iouThreshold,scoreThreshold:r=a.scoreThreshold})}});function g$(t,e,n){const i=function(t,e,n){return function(t,e,n){let i=0,r=t.length,s=0,o=!1;for(;i<r;){s=i+(r-i>>>1);const a=n(e,t[s]);a>0?i=s+1:(r=s,o=!a)}return o?i:-i-1}(t,e,n||y$)}(t,e,n);t.splice(i<0?-(i+1):i,0,e)}function y$(t,e){return t>e?1:t<e?-1:0}function v$(t,e,n,i,r){return x$(t,e,n,i,r,0)}function b$(t,e,n,i,r,s){return x$(t,e,n,i,r,0,!1,s,!0)}function A$(t,e,n,i,r,s){return x$(t,e,n,i,r,s,!0)}function x$(t,e,n,i,r,s,o=!1,a=!1,l=!1){const c=[];for(let g=0;g<e.length;g++)e[g]>r&&c.push({score:e[g],boxIndex:g,suppressBeginIndex:0});c.sort(S$);const u=s>0?-.5/s:0,h=[],d=[];for(;h.length<n&&c.length>0;){const e=c.pop(),{score:n,boxIndex:s,suppressBeginIndex:o}=e;if(n<r)break;let a=!1;for(let l=h.length-1;l>=o;--l){const n=w$(t,s,h[l]);if(n>=i){a=!0;break}if(e.score=e.score*_$(i,u,n),e.score<=r)break}e.suppressBeginIndex=h.length,a||(e.score===n?(h.push(s),d.push(e.score)):e.score>r&&g$(c,e,S$))}const p=h.length,f=n-p;a&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return o&&(m.selectedScores=d),l&&(m.validOutputs=p),m}function w$(t,e,n){const i=t.subarray(4*e,4*e+4),r=t.subarray(4*n,4*n+4),s=Math.min(i[0],i[2]),o=Math.min(i[1],i[3]),a=Math.max(i[0],i[2]),l=Math.max(i[1],i[3]),c=Math.min(r[0],r[2]),u=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),p=(a-s)*(l-o),f=(h-c)*(d-u);if(p<=0||f<=0)return 0;const m=Math.max(s,c),g=Math.max(o,u),y=Math.min(a,h),v=Math.min(l,d),b=Math.max(y-m,0)*Math.max(v-g,0);return b/(p+f-b)}function _$(t,e,n){const i=Math.exp(e*n*n);return n<=t?i:0}function S$(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}const E$=LD({nonMaxSuppressionWithScore_:function(t,e,n,i=.5,r=Number.NEGATIVE_INFINITY,s=0){const o=RD(t,"boxes","nonMaxSuppression"),a=RD(e,"scores","nonMaxSuppression"),l=f$(o,a,n,i,r,s),c=_D.runKernel(lN,{boxes:o,scores:a},{maxOutputSize:n=l.maxOutputSize,iouThreshold:i=l.iouThreshold,scoreThreshold:r=l.scoreThreshold,softNmsSigma:s=l.softNmsSigma});return{selectedIndices:c[0],selectedScores:c[1]}}}),C$=LD({nonMaxSuppressionPadded_:function(t,e,n,i=.5,r=Number.NEGATIVE_INFINITY,s=!1){const o=RD(t,"boxes","nonMaxSuppression"),a=RD(e,"scores","nonMaxSuppression"),l=f$(o,a,n,i,r,null),c=_D.runKernel(aN,{boxes:o,scores:a},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:s});return{selectedIndices:c[0],validOutputs:c[1]}}}),I$=LD({resizeBilinear_:function(t,e,n=!1,i=!1){const r=RD(t,"images","resizeBilinear");_M(3===r.rank||4===r.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),_M(2===e.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),_M(!1===i||!1===n,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=r,o=!1;3===r.rank&&(o=!0,s=qO(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=e,a=_D.runKernel(_N,{images:s},{alignCorners:n,halfPixelCenters:i,size:e});return o?qO(a,[a.shape[1],a.shape[2],a.shape[3]]):a}}),T$=LD({resizeNearestNeighbor_:function(t,e,n=!1,i=!1){const r=RD(t,"images","resizeNearestNeighbor");_M(3===r.rank||4===r.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),_M(2===e.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),_M("float32"===r.dtype||"int32"===r.dtype,()=>"`images` must have `int32` or `float32` as dtype"),_M(!1===i||!1===n,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=r,o=!1;3===r.rank&&(o=!0,s=qO(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=e,a=_D.runKernel(xN,{images:s},{alignCorners:n,halfPixelCenters:i,size:e});return o?qO(a,[a.shape[1],a.shape[2],a.shape[3]]):a}}),M$=LD({bincount_:function(t,e,n){const i=RD(t,"x","bincount"),r=RD(e,"weights","bincount");return _M("int32"===i.dtype,()=>`Error in bincount: input dtype must be int32, but got ${i.dtype}`),_M(n>=0,()=>`size must be non-negative, but got ${n}.`),_M(r.size===i.size||0===r.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${i.shape}, weights shape: ${r.shape}.`),_D.runKernel(Ok,{x:i,weights:r},{size:n})}}),k$=LD({lessEqual_:function(t,e){let n=RD(t,"a","lessEqual","string_or_numeric"),i=RD(e,"b","lessEqual","string_or_numeric");return[n,i]=fD(n,i),wP(n.shape,i.shape),_D.runKernel(BR,{a:n,b:i})}}),R$=LD({round_:function(t){const e=RD(t,"x","round");return _D.runKernel(IN,{x:e})}});function N$(t,e,n=1,i="float32"){if(0===n)throw new Error("Cannot have a step of zero");return _D.runKernel(gN,{},{start:t,stop:e,step:n,dtype:i})}const L$=LD({threshold_:function(t,e="binary",n=!1,i=.5){const r=RD(t,"image","threshold"),s=r.shape[0]*r.shape[1];let o,a,l,c,u=FP(BF([i]),255);if(_M(3===r.rank,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),_M(3===r.shape[2]||1===r.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),_M("int32"===r.dtype||"float32"===r.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),_M("otsu"===e||"binary"===e,()=>`Method must be binary or otsu, but was ${e}`),3===r.shape[2]){[o,a,l]=kF(r,[1,1,1],-1);const t=FP(o,.2989),e=FP(a,.587),n=FP(l,.114);c=RO(RO(t,e),n)}else c=t;"otsu"===e&&(u=function(t,e){let n,i,r,s,o,a,l=BF([-1]),c=BF([0]),u=BF([0]);for(let h=0;h<t.size-1;h++){n=_F(t,0,h+1),i=_F(t,h+1),o=gP(zP(n),e),a=gP(zP(i),e);const d=zP(FP(n,N$(0,n.size)));r=gP(d,zP(n));const p=TP(i.shape,n.size),f=RO(N$(0,i.size),p),m=FP(i,f);s=gP(zP(m),zP(i));const g=$P(r,s),y=$P(r,s),v=FP(o,a);u=FP(FP(v,g),y);const b=RP(u,c);c=zF(b,u,c),l=zF(b,BF([h]),l)}return l}(M$(NB(R$(c),"int32"),OD([]),256),s));const h=n?k$(c,u):RP(c,u);return NB(FP(h,255),"int32")}}),D$=LD({transform_:function(t,e,n="nearest",i="constant",r=0,s){const o=RD(t,"image","transform","float32"),a=RD(e,"transforms","transform","float32");return _M(4===o.rank,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),_M(2===a.rank&&(a.shape[0]===o.shape[0]||1===a.shape[0])&&8===a.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),_M(null==s||2===s.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`),_D.runKernel(sL,{image:o,transforms:a},{interpolation:n,fillMode:i,fillValue:r,outputShape:s})}}),B$=LD({bandPart_:function(t,e,n){_M(e%1==0,()=>`bandPart(): numLower must be an integer, got ${e}.`),_M(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const i=RD(t,"a","bandPart");_M(i.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${i.rank}.`);const r=i.shape,[s,o]=i.shape.slice(-2);if(!(e<=s))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${s}).`);if(!(n<=o))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`);e<0&&(e=s),n<0&&(n=o);const a=qO(N$(0,s,1,"int32"),[-1,1]),l=N$(0,o,1,"int32"),c=$P(a,l),u=HP(k$(c,TO(+e,"int32")),NP(c,TO(-n,"int32"))),h=aF([s,o],i.dtype);return qO(LF(FF(qO(i,[-1,s,o])).map(t=>zF(u,t,h))),r)}}),O$=LD({min_:function(t,e=null,n=!1){const i=RD(t,"x","min");return _D.runKernel(JR,{x:i},{axis:e,keepDims:n})}});function P$(t,e,n=null){if(0===t.rank)return kO(t);if(1!==t.rank&&null===n)return P$(qO(t,[-1]),e,n);if(1===t.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===e)return zP(kO(t),n);if(e===1/0)return PP(kO(t),n);if(e===-1/0)return O$(kO(t),n);if("euclidean"===e||2===e)return RF(zP(hF(kO(t),TO(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&2===n.length){if(1===e)return PP(zP(kO(t),n[0]),n[1]-1);if(e===1/0)return PP(zP(kO(t),n[1]),n[0]);if(e===-1/0)return O$(zP(kO(t),n[1]),n[0]);if("fro"===e||"euclidean"===e)return RF(zP(nF(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const F$=LD({norm_:function(t,e="euclidean",n=null,i=!1){const r=P$(t=RD(t,"x","norm"),e,n);let s=r.shape;if(i){const e=PM(n,t.shape);s=KP(r.shape,e)}return qO(r,s)}}),$$=LD({gramSchmidt_:function(t){let e;if(Array.isArray(t)){e=!1,_M(null!=t&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const n=t[0].shape[0];for(let e=1;e<t.length;++e)_M(t[e].shape[0]===n,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[e].shape[0]} vs. ${n})`)}else e=!0,t=kF(t,t.shape[0],0).map(t=>NF(t,[0]));_M(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],i=t;for(let r=0;r<t.length;++r)n.push(_D.tidy(()=>{let t=i[r];if(r>0)for(let e=0;e<r;++e){const i=FP(zP(FP(n[e],t)),n[e]);t=$P(t,i)}return gP(t,F$(t,"euclidean"))}));return e?LF(n,0):n}});function z$(t,e=!1){return _D.tidy(()=>{_M(2===t.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],i=t.shape[1];let r=IP(n),s=LB(t);const o=OF([[1]],[1,1]);let a=LB(o);const l=n>=i?i:n;for(let t=0;t<l;++t){const e=s,l=a,c=r;[a,s,r]=_D.tidy(()=>{const e=_F(s,[t,t],[n-t,1]),l=F$(e),c=_F(s,[t,t],[1,1]),u=zF(RP(c,0),OF([[-1]]),OF([[1]])),h=$P(c,FP(u,l)),d=gP(e,h);a=1===d.shape[0]?LB(o):nP([o,_F(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=rF(gP(yP(u,h),l)),f=_F(s,[t,0],[n-t,i]),m=FP(p,a),g=HF(a);if(0===t)s=$P(f,yP(m,yP(g,f)));else{const e=$P(f,yP(m,yP(g,f)));s=nP([_F(s,[0,0],[t,i]),e],0)}const y=HF(m),v=_F(r,[0,t],[n,r.shape[1]-t]);if(0===t)r=$P(v,yP(yP(v,a),y));else{const e=$P(v,yP(yP(v,a),y));r=nP([_F(r,[0,0],[n,t]),e],1)}return[a,s,r]}),SO([e,l,c])}return!e&&n>i&&(r=_F(r,[0,0],[n,i]),s=_F(s,[0,0],[i,i])),[r,s]})}const U$=LD({qr_:function(t,e=!1){if(_M(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),2===t.rank)return z$(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((t,e)=>t*e),i=FF(qO(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),r=[],s=[];return i.forEach(t=>{const[n,i]=z$(t,e);r.push(n),s.push(i)}),[qO(LF(r,0),t.shape),qO(LF(s,0),t.shape)]}}});var H$;!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(H$||(H$={}));const V$=LD({computeWeightedLoss_:function(t,e,n=H$.SUM_BY_NONZERO_WEIGHTS){const i=RD(t,"losses","computeWeightedLoss");let r=null;null!=e&&(r=RD(e,"weights","computeWeightedLoss"));const s=null==r?i:FP(i,r);if(n===H$.NONE)return s;if(n===H$.SUM)return zP(s);if(n===H$.MEAN){if(null==r)return jP(s);{const t=i.size/r.size,e=gP(zP(s),zP(r));return t>1?gP(e,TO(t)):e}}if(n===H$.SUM_BY_NONZERO_WEIGHTS){if(null==r)return gP(zP(s),TO(i.size));{const t=FP(r,lF(i.shape)),e=NB(zP(sF(t,TO(0))),"float32");return gP(zP(s),e)}}throw Error(`Unknown reduction: ${n}`)}});LD({absoluteDifference_:function(t,e,n,i=H$.SUM_BY_NONZERO_WEIGHTS){const r=RD(t,"labels","absoluteDifference"),s=RD(e,"predictions","absoluteDifference");let o=null;null!=n&&(o=RD(n,"weights","absoluteDifference")),SM(r.shape,s.shape,"Error in absoluteDifference: ");const a=kO($P(r,s));return V$(a,o,i)}}),LD({cosineDistance_:function(t,e,n,i,r=H$.SUM_BY_NONZERO_WEIGHTS){const s=RD(t,"labels","cosineDistance"),o=RD(e,"predictions","cosineDistance");let a=null;null!=i&&(a=RD(i,"weights","cosineDistance")),SM(s.shape,o.shape,"Error in cosineDistance: ");const l=TO(1),c=$P(l,zP(FP(s,o),n,!0));return V$(c,a,r)}}),LD({hingeLoss_:function(t,e,n,i=H$.SUM_BY_NONZERO_WEIGHTS){let r=RD(t,"labels","hingeLoss");const s=RD(e,"predictions","hingeLoss");let o=null;null!=n&&(o=RD(n,"weights","hingeLoss")),SM(r.shape,s.shape,"Error in hingeLoss: ");const a=TO(1);r=$P(FP(TO(2),r),a);const l=vF($P(a,FP(r,s)));return V$(l,o,i)}}),LD({huberLoss_:function(t,e,n,i=1,r=H$.SUM_BY_NONZERO_WEIGHTS){const s=RD(t,"labels","huberLoss"),o=RD(e,"predictions","huberLoss");let a=null;null!=n&&(a=RD(n,"weights","huberLoss")),SM(s.shape,o.shape,"Error in huberLoss: ");const l=TO(i),c=kO($P(o,s)),u=QP(c,l),h=$P(c,u),d=RO(FP(TO(.5),nF(u)),FP(l,h));return V$(d,a,r)}}),LD({logLoss_:function(t,e,n,i=1e-7,r=H$.SUM_BY_NONZERO_WEIGHTS){const s=RD(t,"labels","logLoss"),o=RD(e,"predictions","logLoss");let a=null;null!=n&&(a=RD(n,"weights","logLoss")),SM(s.shape,o.shape,"Error in logLoss: ");const l=TO(1),c=TO(i),u=rF(FP(s,BP(RO(o,c)))),h=FP($P(l,s),BP(RO($P(l,o),c))),d=$P(u,h);return V$(d,a,r)}});const G$=LD({squaredDifference_:function(t,e){let n=RD(t,"a","squaredDifference"),i=RD(e,"b","squaredDifference");return[n,i]=fD(n,i),wP(n.shape,i.shape),_D.runKernel(qN,{a:n,b:i},{})}});LD({meanSquaredError_:function(t,e,n,i=H$.SUM_BY_NONZERO_WEIGHTS){const r=RD(t,"labels","meanSquaredError"),s=RD(e,"predictions","meanSquaredError");let o=null;null!=n&&(o=RD(n,"weights","meanSquaredError")),SM(r.shape,s.shape,"Error in meanSquaredError: ");const a=G$(r,s);return V$(a,o,i)}}),LD({sigmoidCrossEntropy_:function(t,e,n,i=0,r=H$.SUM_BY_NONZERO_WEIGHTS){let s=RD(t,"multiClassLabels","sigmoidCrossEntropy");const o=RD(e,"logits","sigmoidCrossEntropy");let a=null;if(null!=n&&(a=RD(n,"weights","sigmoidCrossEntropy")),SM(s.shape,o.shape,"Error in sigmoidCrossEntropy: "),i>0){const t=TO(i),e=TO(1),n=TO(.5);s=RO(FP(s,$P(e,t)),FP(n,t))}const l=function(t,e){const n=RD(t,"labels","sigmoidCrossEntropyWithLogits"),i=RD(e,"logits","sigmoidCrossEntropyWithLogits");SM(n.shape,i.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=vF(i),s=FP(i,n),o=OP(SP(rF(kO(i))));return RO($P(r,s),o)}(s,o);return V$(l,a,r)}});const W$=LD({logSumExp_:function(t,e=null,n=!1){const i=RD(t,"x","logSumExp"),r=PM(e,i.shape),s=PP(i,r,!0),o=$P(i,s),a=SP(o),l=zP(a,r),c=BP(l),u=RO(qO(s,c.shape),c);if(n){const t=KP(u.shape,r);return qO(u,t)}return u}});LD({softmaxCrossEntropy_:function(t,e,n,i=0,r=H$.SUM_BY_NONZERO_WEIGHTS){let s=RD(t,"onehotLabels","softmaxCrossEntropy");const o=RD(e,"logits","softmaxCrossEntropy");let a=null;if(null!=n&&(a=RD(n,"weights","softmaxCrossEntropy")),SM(s.shape,o.shape,"Error in softmaxCrossEntropy: "),i>0){const t=TO(i),e=TO(1),n=TO(s.shape[1]);s=RO(FP(s,$P(e,t)),gP(t,n))}const l=function(t,e,n=-1){if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return IO((t,e,i)=>{const r=W$(e,[n],!0),s=$P(NB(e,"float32"),r);i([t,s]);const o=rF(FP(s,t));return{value:zP(o,[n]),gradFunc:(t,e)=>{const[i,r]=e,s=KP(t.shape,[n]);return[FP(qO(t,s),$P(NB(i,"float32"),SP(r))),FP(qO(t,s),$P(SP(r),NB(i,"float32")))]}}})(t,e)}(s,o);return V$(l,a,r)}}),LD({sparseFillEmptyRows_:function(t,e,n,i){const r=RD(t,"indices","sparseFillEmptyRows"),s=RD(e,"values","sparseFillEmptyRows"),o=RD(n,"denseShape","sparseFillEmptyRows"),a=RD(i,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==r.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==o.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(0!==a.rank)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const l=_D.runKernel(VN,{indices:r,values:s,denseShape:o,defaultValue:a});return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}}),LD({sparseReshape_:function(t,e,n){const i=RD(t,"inputIndices","sparseReshape"),r=RD(e,"inputShape","sparseReshape"),s=RD(n,"newShape","sparseReshape");if(2!==i.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${i.shape}`);if(1!==r.rank)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(1!==s.rank)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);const o=_D.runKernel(GN,{inputIndices:i,inputShape:r,newShape:s});return{outputIndices:o[0],outputShape:o[1]}}}),LD({sparseSegmentMean_:function(t,e,n){const i=RD(t,"data","sparseSegmentMean"),r=RD(e,"indices","sparseSegmentMean"),s=RD(n,"segmentIds","sparseSegmentMean");if(i.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${r.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${s.shape}`);return _D.runKernel(WN,{data:i,indices:r,segmentIds:s})}}),LD({sparseSegmentSum_:function(t,e,n){const i=RD(t,"data","sparseSegmentSum"),r=RD(e,"indices","sparseSegmentSum"),s=RD(n,"segmentIds","sparseSegmentSum");if(i.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${r.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${s.shape}`);return _D.runKernel(jN,{data:i,indices:r,segmentIds:s})}}),LD({stringNGrams_:function(t,e,n,i,r,s,o,a){const l=RD(t,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=RD(e,"dataSplits","stringNGrams");if("int32"!==c.dtype)throw new Error("Data splits must be of datatype int32");const u=_D.runKernel(KN,{data:l,dataSplits:c},{separator:n,nGramWidths:i,leftPad:r,rightPad:s,padWidth:o,preserveShortSequences:a});return{nGrams:u[0],nGramsSplits:u[1]}}}),LD({stringSplit_:function(t,e,n=!0){const i=RD(t,"input","stringSplit","string"),r=RD(e,"delimiter","stringSplit","string");if(1!==i.rank)throw new Error(`Input should be Tensor1D but received shape ${i.shape}`);if(0!==r.rank)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const s=_D.runKernel(JN,{input:i,delimiter:r},{skipEmpty:n});return{indices:s[0],values:s[1],shape:s[2]}}}),LD({stringToHashBucketFast_:function(t,e){const n=RD(t,"input","stringToHashBucketFast","string"),i={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");return _D.runKernel(ZN,{input:n},i)}});const j$={flipLeftRight:d$,resizeNearestNeighbor:T$,resizeBilinear:I$,rotateWithOffset:p$,cropAndResize:h$,nonMaxSuppression:m$,nonMaxSuppressionAsync:async function(t,e,n,i=.5,r=Number.NEGATIVE_INFINITY){const s=RD(t,"boxes","nonMaxSuppressionAsync"),o=RD(e,"scores","nonMaxSuppressionAsync"),a=f$(s,o,n,i,r);n=a.maxOutputSize,i=a.iouThreshold,r=a.scoreThreshold;const l=await Promise.all([s.data(),o.data()]),c=l[0],u=l[1],{selectedIndices:h}=v$(c,u,n,i,r);return s!==t&&s.dispose(),o!==e&&o.dispose(),BF(h,"int32")},nonMaxSuppressionWithScore:E$,nonMaxSuppressionWithScoreAsync:async function(t,e,n,i=.5,r=Number.NEGATIVE_INFINITY,s=0){const o=RD(t,"boxes","nonMaxSuppressionAsync"),a=RD(e,"scores","nonMaxSuppressionAsync"),l=f$(o,a,n,i,r,s);n=l.maxOutputSize,i=l.iouThreshold,r=l.scoreThreshold,s=l.softNmsSigma;const c=await Promise.all([o.data(),a.data()]),u=c[0],h=c[1],{selectedIndices:d,selectedScores:p}=A$(u,h,n,i,r,s);return o!==t&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:BF(d,"int32"),selectedScores:BF(p)}},nonMaxSuppressionPadded:C$,nonMaxSuppressionPaddedAsync:async function(t,e,n,i=.5,r=Number.NEGATIVE_INFINITY,s=!1){const o=RD(t,"boxes","nonMaxSuppressionAsync"),a=RD(e,"scores","nonMaxSuppressionAsync"),l=f$(o,a,n,i,r,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([o.data(),a.data()]),{selectedIndices:f,validOutputs:m}=b$(d,p,c,u,h,s);return o!==t&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:BF(f,"int32"),validOutputs:TO(m,"int32")}},threshold:L$,transform:D$},Q$={bandPart:B$,gramSchmidt:$$,qr:U$};class q$ extends MO{constructor(t,e,n=null){super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=_D.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const i=_D.registeredVariables[e];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${e}/accum_grad`,variable:_O(()=>UF(i).variable(!1))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${e}/accum_var`,variable:_O(()=>UF(i).variable(!1))});const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const s=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;_O(()=>{const t=RO(FP(s,this.rho),FP(nF(r),1-this.rho)),e=FP(gP(RF(RO(o,this.epsilon)),RF(RO(s,this.epsilon))),r),n=RO(FP(o,this.rho),FP(nF(e),1-this.rho));s.assign(t),o.assign(n);const a=RO(FP(e,-this.learningRate),i);i.assign(a)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(SO(this.accumulatedGrads.map(t=>t.variable)),SO(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){const e=(t=await this.extractIterations(t)).length/2;this.accumulatedGrads=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.accumulatedUpdates=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}q$.className="Adadelta",AO(q$);class X$ extends MO{constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const i=_D.registeredVariables[e];if(null==this.accumulatedGrads[n]){const t=!1;this.accumulatedGrads[n]={originalName:`${e}/accumulator`,variable:_O(()=>TP(i.shape,this.initialAccumulatorValue).variable(t))}}const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const s=this.accumulatedGrads[n].variable;_O(()=>{const t=RO(s,nF(r));s.assign(t);const e=RO(FP(gP(r,RF(RO(t,_D.backend.epsilon()))),-this.learningRate),i);i.assign(e)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&SO(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),this.accumulatedGrads=t.map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}X$.className="Adagrad",AO(X$);class Y$ extends MO{constructor(t,e,n,i=null){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=i,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],_O(()=>{this.accBeta1=TO(e).variable(),this.accBeta2=TO(n).variable()}),null==i&&(this.epsilon=_D.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);_O(()=>{const n=$P(1,this.accBeta1),i=$P(1,this.accBeta2);e.forEach((e,r)=>{const s=_D.registeredVariables[e];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:`${e}/m`,variable:_O(()=>UF(s).variable(!1))}),null==this.accumulatedSecondMoment[r]&&(this.accumulatedSecondMoment[r]={originalName:`${e}/v`,variable:_O(()=>UF(s).variable(!1))});const o=Array.isArray(t)?t[r].tensor:t[e];if(null==o)return;const a=this.accumulatedFirstMoment[r].variable,l=this.accumulatedSecondMoment[r].variable,c=RO(FP(a,this.beta1),FP(o,1-this.beta1)),u=RO(FP(l,this.beta2),FP(nF(o),1-this.beta2)),h=gP(c,n),d=gP(u,i);a.assign(c),l.assign(u);const p=RO(FP(gP(h,RO(RF(d),this.epsilon)),-this.learningRate),s);s.assign(p)}),this.accBeta1.assign(FP(this.accBeta1,this.beta1)),this.accBeta2.assign(FP(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&SO(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedSecondMoment&&SO(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),_O(()=>{this.accBeta1.assign(hF(this.beta1,this.iterations_+1)),this.accBeta2.assign(hF(this.beta2,this.iterations_+1))});const e=t.length/2;this.accumulatedFirstMoment=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.accumulatedSecondMoment=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}Y$.className="Adam",AO(Y$);class K$ extends MO{constructor(t,e,n,i=null,r=0){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=i,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],_O(()=>{this.iteration=TO(0).variable(),this.accBeta1=TO(e).variable()}),null==i&&(this.epsilon=_D.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);_O(()=>{const n=$P(1,this.accBeta1),i=gP(-this.learningRate,RO(FP(this.iteration,this.decay),1));e.forEach((e,r)=>{const s=_D.registeredVariables[e];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:`${e}/m`,variable:UF(s).variable(!1)}),null==this.accumulatedWeightedInfNorm[r]&&(this.accumulatedWeightedInfNorm[r]={originalName:`${e}/v`,variable:UF(s).variable(!1)});const o=Array.isArray(t)?t[r].tensor:t[e];if(null==o)return;const a=this.accumulatedFirstMoment[r].variable,l=this.accumulatedWeightedInfNorm[r].variable,c=RO(FP(a,this.beta1),FP(o,1-this.beta1)),u=FP(l,this.beta2),h=kO(o),d=WP(u,h);a.assign(c),l.assign(d);const p=RO(FP(gP(i,n),gP(c,RO(d,this.epsilon))),s);s.assign(p)}),this.iteration.assign(RO(this.iteration,1)),this.accBeta1.assign(FP(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&SO(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedWeightedInfNorm&&SO(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}K$.className="Adamax",AO(K$);class J$ extends MO{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const i=Array.isArray(t)?t[n].tensor:t[e];if(null==i)return;const r=_D.registeredVariables[e];_O(()=>{const t=RO(FP(this.c,i),r);r.assign(t)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=EO(TO(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(0!==(t=await this.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}J$.className="SGD",AO(J$);class Z$ extends J${constructor(t,e,n=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=TO(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const i=_D.registeredVariables[e];if(null==this.accumulations[n]){const t=!1;this.accumulations[n]={originalName:`${e}/momentum`,variable:_O(()=>UF(i).variable(t))}}const r=this.accumulations[n].variable,s=Array.isArray(t)?t[n].tensor:t[e];null!=s&&_O(()=>{let t;const e=RO(FP(this.m,r),s);t=RO(FP(this.c,this.useNesterov?RO(s,FP(e,this.m)):e),i),r.assign(e),i.assign(t)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&SO(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),this.accumulations=t.map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}Z$.className="Momentum",AO(Z$);class tz extends MO{constructor(t,e=.9,n=0,i=null,r=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,null==i&&(this.epsilon=_D.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const i=_D.registeredVariables[e],r=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${e}/rms`,variable:_O(()=>UF(i).variable(r))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${e}/momentum`,variable:_O(()=>UF(i).variable(r))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${e}/mg`,variable:_O(()=>UF(i).variable(r))});const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const o=this.accumulatedMeanSquares[n].variable,a=this.accumulatedMoments[n].variable;_O(()=>{const t=RO(FP(o,this.decay),FP(nF(s),1-this.decay));if(this.centered){const e=this.accumulatedMeanGrads[n].variable,r=RO(FP(e,this.decay),FP(s,1-this.decay)),l=gP(FP(s,this.learningRate),RF($P(t,RO(nF(r),this.epsilon)))),c=RO(FP(a,this.momentum),l);o.assign(t),e.assign(r),a.assign(c);const u=$P(i,c);i.assign(u)}else{const t=RO(FP(o,this.decay),FP(nF(s),1-this.decay)),e=RO(FP(a,this.momentum),gP(FP(s,this.learningRate),RF(RO(t,this.epsilon))));o.assign(t),a.assign(e);const n=$P(i,e);i.assign(n)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&SO(this.accumulatedMeanSquares.map(t=>t.variable)),null!=this.accumulatedMeanGrads&&this.centered&&SO(this.accumulatedMeanGrads.map(t=>t.variable)),null!=this.accumulatedMoments&&SO(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,n=!1;this.accumulatedMeanSquares=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(n)})),this.accumulatedMoments=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=t.slice(2*e,3*e).map(t=>({originalName:t.name,variable:t.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}tz.className="RMSProp",AO(tz);class ez{static sgd(t){return new J$(t)}static momentum(t,e,n=!1){return new Z$(t,e,n)}static rmsprop(t,e=.9,n=0,i=null,r=!1){return new tz(t,e,n,i,r)}static adam(t=.001,e=.9,n=.999,i=null){return new Y$(t,e,n,i)}static adadelta(t=.001,e=.95,n=null){return new q$(t,e,n)}static adamax(t=.002,e=.9,n=.999,i=null,r=0){return new K$(t,e,n,i,r)}static adagrad(t,e=.1){return new X$(t,e)}}const nz={sgd:ez.sgd,momentum:ez.momentum,adadelta:ez.adadelta,adagrad:ez.adagrad,rmsprop:ez.rmsprop,adamax:ez.adamax,adam:ez.adam},iz="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:t=>t();function rz(){return new Promise(t=>iz(()=>t()))}function sz(t,e){const n=t[0].length;t.forEach((t,e)=>{_M(t.length===n,()=>`Error in concat${n}D: rank of tensors[${e}] must be the same as the rank of the rest (${n})`)}),_M(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const i=t[0];t.forEach((t,r)=>{for(let s=0;s<n;s++)_M(s===e||t[s]===i[s],()=>`Error in concat${n}D: Shape of tensors[${r}] (${t}) does not match the shape of the rest (${i}) along the non-concatenated axis ${r}.`)})}function oz(t,e){const n=t[0].slice();for(let i=1;i<t.length;i++)n[e]+=t[i][e];return n}const az=30;function lz(t){return t<=az?t:JM(t,Math.floor(Math.sqrt(t)))}function cz(t,e,n){return[n*("number"==typeof t?t:t[0]),e*("number"==typeof t?t:t[1])]}function uz(t,e,n,i=!0){let r=[];if(i)r=r.concat(e.slice(0)),r.push(t[0]/n),r=r.concat(t.slice(1));else{r=r.concat(t[0]);const n=e.length;for(let i=0;i<n;++i)r=r.concat([t[i+1]/e[i],e[i]]);r=r.concat(t.slice(n+1))}return r}function hz(t,e,n=!0){const i=[];if(n){i.push(e);for(let n=e+1;n<t;++n)n<=2*e?(i.push(n),i.push(n-(e+1))):i.push(n)}else{const n=[],r=[];for(let i=1;i<t;++i)i>=2*e+1||i%2==1?r.push(i):n.push(i);i.push(...n),i.push(0),i.push(...r)}return i}function dz(t,e,n,i=!0){const r=[];r.push(i?t[0]/n:t[0]*n);for(let s=1;s<t.length;++s)r.push(s<=e.length?i?e[s-1]*t[s]:t[s]/e[s-1]:t[s]);return r}function pz(t,e){const n=[0];for(let i=0;i<e;++i)n.push(t[i][0]);return n}function fz(t,e,n){const i=t.slice(0,1);for(let r=0;r<n;++r)i.push(t[r+1]-e[r][0]-e[r][1]);return i}function mz(t,e){const n=t.shape.length,i=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(i<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${i}.`);if("int32"!==e.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[i-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[i-1]} vs. ${n}`);if(0===IM(t.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const r=e.shape,s=r[r.length-1];let o=1;for(let h=0;h<r.length-1;++h)o*=r[h];const a=t.shape,l=r.slice();l.pop();let c=1;for(let h=s;h<n;++h)c*=a[h],l.push(a[h]);const u=[...ZM(t.shape).map(t=>t/c),1].slice(0,s);return[l,o,c,u]}function gz(t,e,n){const i=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${i}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(s+` update.rank < ${r}. `);if(t.length<i+(n.rank-r))throw new Error(s+` Output shape length < ${i+(n.rank-r)}`);if(n.rank!==r+t.length-i)throw new Error(s+" update.rank != "+(r+t.length-i));for(let o=0;o<r;++o)if(n.shape[o]!==e.shape[o])throw new Error(s+` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<n.rank-r;++o)if(n.shape[o+r]!==t[o+i])throw new Error(s+` updates.shape[${o+r}] (${n.shape[o+r]}) != shape[${o+r}] (${t[o+r]})`)}function yz(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==e.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===e.size)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(0===t.size)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}gz(n,e,t)}function vz(t,e,n){const i=e.shape.length,r=i>1?e.shape[i-1]:1,s=n.length;let o=1;for(let l=r;l<s;++l)o*=n[l];const a=r<1?1:r;return{sliceRank:r,numUpdates:IM(e.shape)/a,sliceSize:o,strides:[...ZM(n.slice(0,r)),1],outputSize:IM(n)}}const bz=1.7580993408473768,Az=1.0507009873554805,xz=.3275911,wz=.254829592,_z=-.284496736,Sz=1.421413741,Ez=-1.453152027,Cz=1.061405429;function Iz(...t){hk().getBool("IS_TEST")||console.warn(...t)}function Tz(...t){hk().getBool("IS_TEST")||console.log(...t)}function Mz(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(2*t.length);for(let i=0;i<n.length;i+=2)n[i]=t[i/2],n[i+1]=e[i/2];return n}function kz(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let i=0;i<t.length;i+=2)e[i/2]=t[i],n[i/2]=t[i+1];return{real:e,imag:n}}function Rz(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),i=new Float32Array(e);for(let r=0;r<t.length;r+=4)n[Math.floor(r/4)]=t[r],i[Math.floor(r/4)]=t[r+1];return{real:n,imag:i}}function Nz(t){const e=Math.floor(t.length/4),n=new Float32Array(e),i=new Float32Array(e);for(let r=2;r<t.length;r+=4)n[Math.floor(r/4)]=t[r],i[Math.floor(r/4)]=t[r+1];return{real:n,imag:i}}function Lz(t,e){return{real:t[2*e],imag:t[2*e+1]}}function Dz(t,e,n,i){t[2*i]=e,t[2*i+1]=n}function Bz(t,e){const n=new Float32Array(t/2),i=new Float32Array(t/2);for(let r=0;r<Math.ceil(t/2);r++){const s=(e?2:-2)*Math.PI*(r/t);n[r]=Math.cos(s),i[r]=Math.sin(s)}return{real:n,imag:i}}function Oz(t,e,n){const i=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(i),imag:Math.sin(i)}}const Pz=/->/g;function Fz(t,e){const n=((t=t.replace(/\s/g,"")).length-t.replace(Pz,"").length)/"->".length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("->").');const[i,r]=t.split("->");_M(-1===i.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');const s=i.split(","),o=s.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let h=0;h<r.length;++h){const t=r[h];if(!s.some(e=>-1!==e.indexOf(t)))throw new Error(`Output subscripts contain the label ${t} not present in the input subscripts.`);-1===a.indexOf(t)&&a.push(t)}for(let h=0;h<i.length;++h){const t=i[h];-1===a.indexOf(t)&&","!==t&&a.push(t)}const l=new Array(s.length);for(let h=0;h<o;++h){if(new Set(s[h].split("")).size!==s[h].length)throw new Error(`Found duplicate axes in input component ${s[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let t=0;t<s[h].length;++t)l[h].push(a.indexOf(s[h][t]))}const c=a.length,u=[];for(let h=r.length;h<c;++h)u.push(h);return{allDims:a,summedDims:u,idDims:l}}function $z(t,e){let n=new Array(t);n.fill(-1);for(let r=0;r<e.length;++r)n[e[r]]=r;const i=[];for(let r=0;r<t;++r)-1===n[r]&&i.push(r);return n=n.filter(t=>-1!==t),{permutationIndices:n,expandDims:i}}function zz(t,e,n){const i=new Array(t);for(let r=0;r<n.length;++r){const t=n[r].shape;for(let n=0;n<e[r].length;++n)void 0===i[e[r][n]]?i[e[r][n]]=t[n]:_M(i[e[r][n]]===t[n],()=>`Expected dimension ${i[e[r][n]]} at axis ${n} of input shaped ${JSON.stringify(t)}, but got dimension ${t[n]}`)}}function Uz(t,e){const n=t,i=[];let r=0;0===t.length&&n.push(-1),r=t.length+1;for(let o=0;o<r;++o)i.push([]);const s=[];for(let o=0;o<n.length;++o){const t=Vz(e,n[o]);for(const e of t)-1===s.indexOf(e)&&(i[o].push(e),s.push(e))}return{path:n,steps:i}}function Hz(t){return t.every((t,e)=>t===e)}function Vz(t,e){const n=[];for(let i=0;i<t.length;++i)0!==t[i].length&&-1===t[i].indexOf(e)&&-1!==e||n.push(i);return n}function Gz(t,e,n=0){let i=[];if("number"==typeof e)_M(t.shape[n]%e==0,()=>"Number of splits must evenly divide the axis."),i=new Array(e).fill(t.shape[n]/e);else{_M(e.reduce((t,e)=>(-1===e&&(t+=1),t),0)<=1,()=>"There should be only one negative value in split array.");const r=e.indexOf(-1);if(-1!==r){const i=e.reduce((t,e)=>e>0?t+e:t);e[r]=t.shape[n]-i}_M(t.shape[n]===e.reduce((t,e)=>t+e),()=>"The sum of sizes must match the size of the axis dimension."),i=e}return i}function Wz(t,e){let n,i=!1;for(t<=az?(n=t,i=!0):n=JM(t,Math.floor(Math.sqrt(t)));!i;)n>e||n===t?i=!0:n=JM(t,n+1);return n}function jz(t,e,n){const i=[],r=t.length;for(let s=0;s<r;s++)i.push(s!==e?t[s]:n);return i}function Qz(t,e,n,i){const r=e.shape.length,s=t.shape.length;if(0!==i&&(i<-r||i>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${i}`);if(i<0&&(i+=r),i>s)throw new Error(`batchDims (${i}) must be less than rank(x) (\n    ${s}).`);if(n<i)throw new Error(`batchDims (${i}) must be less than or equal to axis (${n}).`);for(let h=0;h<i;++h)if(t.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${t.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const o=t.shape[n],a=[];let l=1,c=1,u=1;for(let h=0;h<i;++h)a.push(t.shape[h]),l*=t.shape[h];for(let h=i;h<n;h++)a.push(t.shape[h]),c*=t.shape[h];for(let h=i;h<r;h++)a.push(e.shape[h]);for(let h=n+1;h<s;h++)a.push(t.shape[h]),u*=t.shape[h];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:o,outputShape:a}}function qz(t){try{return t.map(t=>GL(t))}catch(WTt){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${WTt}`)}}function Xz(t){return t.map(t=>VL(t))}function Yz(t,e){const n=[];for(let s=0;s<e.length;s++)e[s]&&n.push(s);const i=RB(t,"int32"),r=RB([n.length,t.length],"int32");for(let s=0;s<n.length;s++){const e=i.indexToLoc(n[s]);r.values.set(e,s*t.length)}return r.toTensor()}const Kz={kernelName:gk,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>FP(t,JF(NB(n,"float32"),-1))}}},Jz={kernelName:yk,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=nF(NB(n,"float32")),i=RF($P(TO(1),e));return rF(gP(t,i))}}}},Zz={kernelName:vk,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=RF($P(nF(NB(n,"float32")),1));return gP(t,e)}}}},tU={kernelName:bk,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,i]=e,r=wP(n.shape,i.shape);return{a:()=>{let e=t;const i=xP(n.shape,r);return i.length>0&&(e=zP(e,i)),qO(e,n.shape)},b:()=>{let e=t;const n=xP(i.shape,r);return n.length>0&&(e=zP(e,n)),qO(e,i.shape)}}}},eU={kernelName:Ak,saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach((e,i)=>{n[i]=()=>t.clone()}),n}},nU={kernelName:_k,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>UF(n)}}},iU={kernelName:Sk,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>UF(n)}}},rU={kernelName:Ek,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gP(t,RF($P(TO(1),nF(NB(n,"float32")))))}}},sU={kernelName:Ck,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=RF(RO(TO(1),nF(NB(n,"float32"))));return gP(t,e)}}}},oU={kernelName:Mk,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,i]=e,r=wP(n.shape,i.shape);return{a:()=>{const e=RO(nF(n),nF(i));let s=FP(t,gP(i,e));const o=xP(n.shape,r);return o.length>0&&(s=zP(s,o)),qO(s,n.shape)},b:()=>{const e=RO(nF(n),nF(i));let s=rF(FP(t,gP(n,e)));const o=xP(i.shape,r);return o.length>0&&(s=zP(s,o)),qO(s,i.shape)}}}},aU={kernelName:Ik,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gP(t,RO(nF(NB(n,"float32")),1))}}},lU={kernelName:Tk,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gP(t,$P(TO(1),nF(NB(n,"float32"))))}}},cU=LD({avgPool3dGrad_:function(t,e,n,i,r,s){const o=RD(t,"dy","avgPool3dGrad"),a=RD(e,"input","avgPool3dGrad");let l=o,c=a,u=!1;4===a.rank&&(u=!0,l=qO(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=qO(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),_M(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),_M(5===c.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),null!=s&&_M(kM(r),()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const h=_D.runKernel(Lk,{dy:l,input:c},{filterSize:n,strides:i,pad:r,dimRoundingMode:s});return u?qO(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),uU={kernelName:Nk,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[i]=e,{filterSize:r,strides:s,pad:o,dimRoundingMode:a}=n;return{x:()=>cU(t,i,r,s,o,a)}}},hU=LD({avgPoolGrad_:function(t,e,n,i,r){const s=RD(t,"dy","avgPoolGrad"),o=RD(e,"input","avgPoolGrad");_M(o.rank===s.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${s.rank})`);let a=o,l=s,c=!1;3===o.rank&&(c=!0,a=qO(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=qO(s,[1,s.shape[0],s.shape[1],s.shape[2]])),_M(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),_M(4===a.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const u=_D.runKernel(Rk,{dy:l,input:a},{filterSize:n,strides:i,pad:r});return c?qO(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),dU={kernelName:kk,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[i]=e,{filterSize:r,strides:s,pad:o}=n;return{x:()=>hU(t,i,r,s,o)}}},pU={kernelName:Dk,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[i,r]=e,{transposeA:s,transposeB:o}=n;return s||o?!s&&o?{a:()=>yP(t,r,!1,!1),b:()=>yP(t,i,!0,!1)}:s&&!o?{a:()=>yP(r,t,!1,!0),b:()=>yP(i,t,!1,!1)}:{a:()=>yP(r,t,!0,!0),b:()=>yP(t,i,!0,!0)}:{a:()=>yP(t,r,!1,!0),b:()=>yP(i,t,!0,!1)}}},fU=LD({spaceToBatchND_:function(t,e,n){const i=RD(t,"x","spaceToBatchND");return _M(i.rank>=1+e.length,()=>`input rank ${i.rank} should be > than [blockShape] ${e.length}`),_M(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),_M(i.shape.reduce((t,i,r)=>r>0&&r<=e.length?t&&(i+n[r-1][0]+n[r-1][1])%e[r-1]==0:t,!0),()=>`input spatial dimensions ${i.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`),_D.runKernel(zN,{x:i},{blockShape:e,paddings:n})}}),mU={kernelName:Bk,gradFunc:(t,e,n)=>{const{blockShape:i,crops:r}=n;return{x:()=>fU(t,i,r)}}},gU={kernelName:"BroadcastTo",gradFunc:(t,e,n)=>{const i=n.inputShape,r=n.shape,s=Array.from(r);for(let a=i.length-1;a>=0;a--)if(i[a]===r[a])s[a]=1;else if(1!==i[a])throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${r}].`);const o=[];for(let a=0;a<s.length;a++)s[a]>1&&o.push(a);return{x:()=>zP(t,o,!0)}}},yU={kernelName:Pk,gradFunc:t=>({x:()=>t.clone()})},vU={kernelName:Fk,gradFunc:t=>({x:()=>UF(t)})},bU={kernelName:$k,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[i]=e,{clipValueMin:r,clipValueMax:s}=n;return{x:()=>zF(HP(NP(i,r),k$(i,s)),t,UF(t))}}},AU={kernelName:Uk,inputsToSave:["x"],gradFunc:Kz.gradFunc},xU={kernelName:Hk,saveAllInputs:!0,gradFunc:(t,e,n)=>{const i=e.map(t=>t.shape),{axis:r}=n,s=PM(r,e[0].shape)[0],o=i.map(t=>t[s]);return kF(t,o,s).map(t=>()=>t)}},wU={kernelName:Vk,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[i,r]=e,{dilations:s,strides:o,pad:a,dataFormat:l}=n;return _M(WO(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>cP(i.shape,t,r,o,a,l),filter:()=>YF(i,t,r.shape,o,a,l)}}},_U={kernelName:Wk,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[i,r]=e,{strides:s,pad:o,dataFormat:a,dimRoundingMode:l}=n;return{dy:()=>aP(t,r,s,o,a,1,l),filter:()=>YF(t,i,r.shape,s,o,a,l)}}},SU=LD({conv3DBackpropFilter_:function(t,e,n,i,r){let s=t;4===t.rank&&(s=qO(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let o=e;return 4===o.rank&&(o=qO(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),_M(5===s.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),_M(5===o.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),_M(5===n.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),_M(s.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`),_M(o.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${n[4]}).`),_D.runKernel(Qk,{x:s,dy:o},{strides:i,pad:r,filterShape:n})}}),EU={kernelName:jk,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:i,strides:r,pad:s}=n;_M(WO(i),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const[o,a]=e;return{x:()=>dP(o.shape,t,a,r,s),filter:()=>SU(o,t,a.shape,r,s)}}},CU=LD({sin_:function(t){const e=RD(t,"x","sin");return _D.runKernel(LN,{x:e})}}),IU={kernelName:Xk,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>FP(rF(CU(NB(n,"float32"))),t)}}},TU=LD({sinh_:function(t){const e=RD(t,"x","sinh");return _D.runKernel(DN,{x:e})}}),MU={kernelName:Yk,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>FP(TU(NB(n,"float32")),t)}}},kU=LD({cumsum_:function(t,e=0,n=!1,i=!1){const r=RD(t,"x","cumsum");return _D.runKernel(Kk,{x:r},{axis:e,exclusive:n,reverse:i})}}),RU={kernelName:Kk,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[i]=e,{axis:r,exclusive:s,reverse:o}=n;return{x:()=>{const e=ZP([r],i.rank);let n=kU(t,r,s,!o);return null!=e&&(n=HF(n,e)),n}}}},NU={kernelName:eR,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:i,strides:r,pad:s,dimRoundingMode:o}=n,a=null==i?[1,1]:i;_M(WO(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,c]=e;return _M(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),_M(4===c.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),_M(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),_M(jO(r,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${a}'.`),null!=o&&_M(kM(s),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`),{x:()=>s$(l.shape,t,c,r,s,i,o),filter:()=>r$(l,t,c.shape,r,s,i,o)}}},LU={kernelName:sR,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[i,r]=e,s={x:i,filter:r,dy:t},o={x:i,filter:r,dy:t};return{x:()=>_D.runKernel(oR,s,n),filter:()=>_D.runKernel(aR,o,n)}}},DU={kernelName:uR,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,i={dy:t,y:n};return{x:()=>_D.runKernel(hR,i)}}},BU={kernelName:dR,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,i=FP(SP(rF(nF(n))),2/Math.sqrt(Math.PI));return{x:()=>FP(t,i)}}},OU={kernelName:fR,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>FP(t,n)}}},PU={kernelName:mR,inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>qO(t,n.shape)}}},FU={kernelName:gR,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>FP(t,SP(n))}}},$U={kernelName:AR,gradFunc:t=>({x:()=>UF(t)})},zU={kernelName:xR,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,i]=e,r=wP(n.shape,i.shape);return{a:()=>{const e=gP(t,NB(i,"float32")),s=xP(n.shape,r);return s.length>0?qO(zP(e,s),n.shape):e},b:()=>{let e=FP(t,NB(n,"float32"));const s=xP(i.shape,r);s.length>0&&(e=qO(zP(e,s),i.shape));const o=nF(i);return rF(gP(e,NB(o,"float32")))}}}},UU=LD({rsqrt_:function(t){const e=RD(t,"x","rsqrt");return _D.runKernel(TN,{x:e})}}),HU={kernelName:wR,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:i}=n,[r,s,o,a]=e,l=null==a?TO(1):a,c=xP(s.shape,r.shape),u=[];if(1===s.rank){for(let t=0;t<r.shape.length-1;++t)u.push(r.shape[t]);u.push(1)}const h=$P(r,s),d=FP(t,l),p=UU(RO(o,TO(i))),f=FP(FP(FP(p,p),p),TO(-.5));return{x:()=>qO(FP(FP(t,1===s.rank?CP(qO(p,[1,1,1,s.shape[0]]),u):p),l),r.shape),mean:()=>{let t=FP(FP(p,TO(-1)),d);return 1===s.rank&&(t=zP(t,c)),qO(t,s.shape)},variance:()=>{let t=FP(FP(f,h),d);return 1===s.rank&&(t=zP(t,c)),qO(t,s.shape)},scale:()=>{const e=FP(h,p);let n=FP(t,e);return 1===s.rank&&(n=zP(n,c)),qO(n,s.shape)},offset:()=>{let e=t;return 1===s.rank&&(e=zP(e,c)),qO(e,s.shape)}}}},VU=LD({unsortedSegmentSum_:function(t,e,n){const i=RD(t,"x","unsortedSegmentSum"),r=RD(e,"segmentIds","unsortedSegmentSum","int32");return _M(kM(n),()=>"numSegments must be of dtype int"),_D.runKernel(cL,{x:i,segmentIds:r},{numSegments:n})}}),GU={kernelName:_R,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[i,r]=e,{axis:s}=n,o=PM(s,i.shape)[0];return{x:()=>{const e=i.shape,n=r.size,a=e.slice(0,o),l=a.length,c=e.slice(s,e.length).slice(1),u=c.length,h=WU(0,l),d=WU(l+1,l+1+u),p=jU([a,[n],c]),f=qO(t,p),m=qO(r,[n]),g=jU([[l],h,d]),y=HF(f,g);let v=VU(y,m,i.shape[o]);const b=tF(g);return v=HF(v,b),v},indices:()=>r}}};function WU(t,e){const n=[];for(let i=t;i<e;++i)n.push(i);return n}function jU(t){const e=[];for(let n=0;n<t.length;++n)for(let i=0;i<t[n].length;++i)e.push(t[n][i]);return e}const QU={kernelName:CR,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,i]=e;return{a:()=>UF(n),b:()=>UF(i)}}},qU={kernelName:IR,gradFunc:t=>({x:()=>NB(t,"float32")})},XU={kernelName:kR,gradFunc:t=>({x:()=>UF(t)})},YU={kernelName:RR,gradFunc:t=>({x:()=>UF(t)})},KU={kernelName:NR,gradFunc:t=>({x:()=>UF(t)})},JU={kernelName:LR,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[i]=e,{alpha:r}=n,s=RP(i,0);return{x:()=>zF(s,t,FP(t,r))}}},ZU={kernelName:FR,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gP(t,RO(n,1))}}},tH={kernelName:PR,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gP(t,NB(n,"float32"))}}},eH={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[i]=e,{axis:r}=n;return{logits:()=>{const e=SP(i);return $P(t,FP(zP(t,r,!0),e))}}}},nH=LD({localResponseNormalizationBackprop_:function(t,e,n,i=5,r=1,s=1,o=.5){return _D.runKernel(VR,{x:t,y:e,dy:n},{depthRadius:i,bias:r,alpha:s,beta:o})}}),iH={kernelName:HR,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[i,r]=e,{depthRadius:s,bias:o,alpha:a,beta:l}=n;return{x:()=>nH(i,r,t,s,o,a,l)}}};function rH(t,e,n,i){return e.rank<n.rank&&(e=qO(e,KP(e.shape,i))),t.rank<n.rank&&(t=qO(t,KP(t.shape,i))),{x:()=>FP(t,NB(_P(n,e),t.dtype))}}const sH={kernelName:GR,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const i=n,{reductionIndices:r}=i,s=e[0],o=rH(t,e[1],s,PM(r,s.shape));return{x:()=>o.x()}}},oH=LD({less_:function(t,e){let n=RD(t,"a","less","string_or_numeric"),i=RD(e,"b","less","string_or_numeric");return[n,i]=fD(n,i),wP(n.shape,i.shape),_D.runKernel(DR,{a:n,b:i})}}),aH={kernelName:WR,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,i]=e;return{a:()=>FP(t,NB(NP(n,i),"float32")),b:()=>FP(t,NB(oH(n,i),"float32"))}}},lH=LD({maxPool3dGrad_:function(t,e,n,i,r,s,o){const a=RD(t,"dy","maxPool3dGrad"),l=RD(e,"input","maxPool3dGrad"),c=RD(n,"output","maxPool3dGrad");let u=a,h=l,d=c,p=!1;4===l.rank&&(p=!0,u=qO(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),h=qO(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=qO(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),_M(5===u.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),_M(5===h.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),_M(5===d.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),null!=o&&_M(kM(s),()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`);const f=_D.runKernel(XR,{dy:u,input:h,output:d},{filterSize:i,strides:r,pad:s,dimRoundingMode:o});return p?qO(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),cH={kernelName:qR,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[i,r]=e,{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=n;return{x:()=>lH(t,i,r,s,o,a,l)}}},uH=LD({maxPoolGrad_:function(t,e,n,i,r,s,o){const a=RD(t,"dy","maxPoolGrad"),l=RD(e,"input","maxPoolGrad"),c=RD(n,"output","maxPoolGrad");return _M(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),_M(4===a.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),_M(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),null!=o&&_M(kM(s),()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`),_D.runKernel(QR,{dy:a,input:l,output:c},{filterSize:i,strides:r,pad:s,dimRoundingMode:o})}}),hH={kernelName:jR,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[i,r]=e,{filterSize:s,strides:o,pad:a}=n;return{x:()=>uH(t,i,r,s,o,a)}}},dH={kernelName:KR,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[i]=e,{axis:r}=n,s=PM(r,i.shape),o=IM(YP(i.shape,s)[1]);return{x:()=>{const e=i.shape.slice();s.forEach(t=>{e[t]=1});const n=qO(t,e);return gP(FP(n,lF(i.shape,"float32")),o)}}}},pH={kernelName:JR,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const i=n,{axis:r}=i,[s,o]=e,a=rH(t,o,s,PM(r,s.shape));return{x:()=>a.x()}}},fH={kernelName:ZR,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,i]=e;return{a:()=>FP(t,NB(k$(n,i),"float32")),b:()=>FP(t,NB(RP(n,i),"float32"))}}},mH={kernelName:tN,inputsToSave:["x"],gradFunc:(t,e,n)=>{const i=e[0],{paddings:r}=n,s=r.map(t=>t[0]);return{x:()=>_F(t,s,i.shape)}}},gH={kernelName:eN,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,i]=e,r=wP(n.shape,i.shape);return{a:()=>{const e=xP(n.shape,r);return e.length>0?qO(zP(t,e),n.shape):t},b:()=>{const e=FP(t,rF(MP(gP(n,i)))),s=xP(i.shape,r);return s.length>0?qO(zP(e,s),i.shape):e}}}},yH={kernelName:iN,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,i]=e,r=wP(n.shape,i.shape);return{a:()=>{const e=FP(t,NB(i,"float32")),s=xP(n.shape,r);return s.length>0?qO(zP(e,s),n.shape):e},b:()=>{const e=FP(t,NB(n,"float32")),s=xP(i.shape,r);return s.length>0?qO(zP(e,s),i.shape):e}}}},vH={kernelName:rN,gradFunc:t=>({x:()=>rF(t)})},bH={kernelName:uN,inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>aF(n.shape,"float32")}}},AH={kernelName:cN,gradFunc:t=>({x:()=>UF(t)})},xH={kernelName:hN,saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:i}=n;return FF(t,i).map(t=>()=>t)}},wH={kernelName:dN,inputsToSave:["x"],gradFunc:(t,e,n)=>{const i=e[0],{paddings:r}=n,s=r.map(t=>t[0]);return{x:()=>_F(t,s,i.shape)}}},_H={kernelName:pN,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,i,r]=e,s=n,o=i,a=wP(s.shape,o.shape);return{a:()=>{const e=NB(o,"float32");let n=FP(t,FP(e,hF(s,$P(e,TO(1)))));const i=xP(s.shape,a);return i.length>0&&(n=zP(n,i)),qO(n,s.shape)},b:()=>{const e=RP(s,0),n=zF(e,BP(s),UF(s));let i=FP(t,FP(r,n));const l=xP(o.shape,a);return l.length>0&&(i=zP(i,l)),qO(i,o.shape)}}}},SH={kernelName:fN,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,i]=e,r=RP(n,0);return{x:()=>zF(r,t,FP(t,i)),alpha:()=>{let e=zF(r,UF(t),FP(t,n));const s=xP(i.shape,t.shape);return s.length>0&&(e=zP(e,s)),qO(e,i.shape)}}}},EH={kernelName:lR,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,i]=e,r=wP(n.shape,i.shape);return{a:()=>{const e=gP(t,NB(i,"float32")),s=xP(n.shape,r);return s.length>0?qO(zP(e,s),n.shape):e},b:()=>{let e=FP(t,NB(n,"float32"));const s=xP(i.shape,r);s.length>0&&(e=qO(zP(e,s),i.shape));const o=nF(i);return rF(gP(e,NB(o,"float32")))}}}},CH={kernelName:vN,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gP(t,rF(nF(n)))}}},IH={kernelName:EN,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,i=FP(k$(n,6),JF(n));return{x:()=>FP(t,NB(i,"float32"))}}},TH={kernelName:bN,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>FP(t,NB(JF(n),"float32"))}}},MH={kernelName:AN,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>qO(t,n.shape)}}},kH={kernelName:_N,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[i]=e,r={dy:t,images:i};return{images:()=>_D.runKernel(SN,r,n)}}},RH={kernelName:xN,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[i]=e,r={dy:t,images:i};return{images:()=>_D.runKernel(wN,r,n)}}},NH={kernelName:CN,gradFunc:(t,e,n)=>{const{dims:i}=n,r=PM(i,t.shape);return{x:()=>bF(t,r)}}},LH={kernelName:IN,gradFunc:t=>({x:()=>UF(t)})},DH={kernelName:TN,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>rF(gP(t,FP(hF(n,1.5),2)))}}},BH=LD({logicalNot_:function(t){const e=RD(t,"x","logicalNot","bool");return _D.runKernel(zR,{x:e})}}),OH={kernelName:kN,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>NB(UF(n),"float32"),t:()=>FP(t,NB(n,t.dtype)),e:()=>FP(t,NB(BH(n),t.dtype))}}},PH={kernelName:RN,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=RP(n,TO(0)),i=TO(bz),r=TO(Az),s=FP(t,r),o=FP(FP(t,i),SP(NB(n,"float32")));return zF(e,s,o)}}}},FH={kernelName:ON,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>FP(t,FP(n,$P(TO(1),n)))}}},$H={kernelName:BN,gradFunc:t=>({x:()=>UF(t)})},zH=LD({cos_:function(t){const e=RD(t,"x","cos");return _D.runKernel(Xk,{x:e})}}),UH={kernelName:LN,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>FP(zH(NB(n,"float32")),t)}}},HH=LD({cosh_:function(t){const e=RD(t,"x","cosh");return _D.runKernel(Yk,{x:e})}}),VH={kernelName:DN,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>FP(HH(NB(n,"float32")),t)}}},GH={kernelName:NN,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[i]=e,{begin:r,size:s}=n,o=i.shape,[a,l]=gO(i,r,s),c=[];for(let u=0;u<t.rank;u++)c.push([a[u],o[u]-a[u]-l[u]]);return{x:()=>uF(t,c)}}},WH={kernelName:HN,outputsToSave:[!0],gradFunc:(t,e,n)=>{const[i]=e,{dim:r}=n,s=FP(t,i);return{logits:()=>$P(s,FP(zP(s,[r],!0),i))}}},jH={kernelName:PN,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>FP(t,wF(n))}}},QH=LD({batchToSpaceND_:function(t,e,n){const i=RD(t,"x","batchToSpaceND"),r=e.reduce((t,e)=>t*e);return _M(i.rank>=1+e.length,()=>`input rank is ${i.rank} but should be > than blockShape.length ${e.length}`),_M(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),_M(i.shape[0]%r==0,()=>`input tensor batch is ${i.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`),_D.runKernel(Bk,{x:i},{blockShape:e,crops:n})}}),qH={kernelName:zN,gradFunc:(t,e,n)=>{const{blockShape:i,paddings:r}=n;return{x:()=>QH(t,i,r)}}},XH={kernelName:UN,gradFunc:(t,e,n)=>{const{axis:i}=n;return{x:()=>nP(t,i)}}},YH=[Kz,Jz,Zz,tU,eU,nU,iU,rU,sU,oU,aU,lU,uU,dU,pU,mU,gU,yU,vU,bU,AU,xU,_U,wU,EU,IU,MU,RU,NU,LU,EH,DU,BU,OU,PU,FU,zU,$U,HU,GU,QU,qU,XU,YU,KU,JU,ZU,tH,eH,iH,sH,sH,aH,cH,hH,dH,pH,fH,mH,gH,yH,vH,bH,AH,xH,wH,wH,_H,SH,CH,IH,TH,MH,kH,RH,NH,LH,DH,OH,PH,FH,$H,UH,VH,GH,WH,jH,qH,qH,XH,XH,{kernelName:FN,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gP(t,FP(RF(NB(n,"float32")),2))}}},{kernelName:qN,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,i]=e,r=TO(2);return{a:()=>FP(t,FP(r,$P(n,i))),b:()=>FP(t,FP(r,$P(i,n)))}}},{kernelName:XN,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>FP(t,FP(NB(n,"float32"),2))}}},{kernelName:hL,gradFunc:t=>({x:()=>UF(t)})},{kernelName:tL,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,i]=e,r=wP(n.shape,i.shape);return{a:()=>{let e=t;const i=xP(n.shape,r);return i.length>0&&(e=zP(e,i)),qO(e,n.shape)},b:()=>{let e=t;const n=xP(i.shape,r);return n.length>0&&(e=zP(e,n)),qO(rF(e),i.shape)}}}},{kernelName:$N,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[i]=e,r=i.shape.slice(),{axis:s}=n;PM(s,i.shape).forEach(t=>{r[t]=1});const o=qO(t,r),a=FP(o,lF(i.shape,"float32"));return{x:()=>a}}},{kernelName:eL,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gP(t,nF(zH(n)))}}},{kernelName:nL,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>FP($P(TO(1),nF(n)),t)}}},{kernelName:iL,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[i]=e,{reps:r}=n;return{x:()=>{let e=UF(i);if(1===i.rank)for(let n=0;n<r[0];++n)e=RO(e,_F(t,[n*i.shape[0]],[i.shape[0]]));else if(2===i.rank)for(let n=0;n<r[0];++n)for(let s=0;s<r[1];++s)e=RO(e,_F(t,[n*i.shape[0],s*i.shape[1]],[i.shape[0],i.shape[1]]));else if(3===i.rank)for(let n=0;n<r[0];++n)for(let s=0;s<r[1];++s)for(let o=0;o<r[2];++o)e=RO(e,_F(t,[n*i.shape[0],s*i.shape[1],o*i.shape[2]],[i.shape[0],i.shape[1],i.shape[2]]));else{if(4!==i.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${i.rank} tensors yet.`);for(let n=0;n<r[0];++n)for(let s=0;s<r[1];++s)for(let o=0;o<r[2];++o)for(let a=0;a<r[3];++a)e=RO(e,_F(t,[n*i.shape[0],s*i.shape[1],o*i.shape[2],a*i.shape[3]],[i.shape[0],i.shape[1],i.shape[2],i.shape[3]]))}return e}}}},{kernelName:oL,gradFunc:(t,e,n)=>{const i=n,{perm:r}=i,s=tF(r);return{x:()=>HF(t,s)}}},{kernelName:lL,gradFunc:(t,e,n)=>{const i=n,{axis:r}=i;return{value:()=>LF(t,r)}}},{kernelName:cL,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>function(t,e){const n=WP(e,UF(e)),i=kP(t,n);let r=NP(e,TO(0,"int32"));const s=i.rank-r.rank;for(let a=0;a<s;++a)r=EP(r,a+1);r=HP(r,lF(i.shape,"bool"));const o=UF(i);return zF(r,i,o)}(t,n)}}},{kernelName:uL,gradFunc:t=>({x:()=>UF(t)})}];for(const Set of YH)_L(Set);rD().prototype.abs=function(){return this.throwIfDisposed(),kO(this)};const KH=LD({acos_:function(t){const e=RD(t,"x","acos");return _D.runKernel(yk,{x:e})}});rD().prototype.acos=function(){return this.throwIfDisposed(),KH(this)};const JH=LD({acosh_:function(t){const e=RD(t,"x","acosh");return _D.runKernel(vk,{x:e})}});rD().prototype.acosh=function(){return this.throwIfDisposed(),JH(this)},rD().prototype.add=function(t){return this.throwIfDisposed(),RO(this,t)},rD().prototype.all=function(t,e){return this.throwIfDisposed(),NO(this,t,e)},rD().prototype.any=function(t,e){return this.throwIfDisposed(),LO(this,t,e)},rD().prototype.argMax=function(t){return this.throwIfDisposed(),DO(this,t)};const ZH=LD({argMin_:function(t,e=0){const n=RD(t,"x","argMin");return _D.runKernel(Sk,{x:n},{axis:e})}});rD().prototype.argMin=function(t){return this.throwIfDisposed(),ZH(this,t)},rD().prototype.asScalar=function(){return this.throwIfDisposed(),_M(1===this.size,()=>"The array must have only 1 element."),qO(this,[])},rD().prototype.asType=function(t){return this.throwIfDisposed(),NB(this,t)},rD().prototype.as1D=function(){return this.throwIfDisposed(),qO(this,[this.size])},rD().prototype.as2D=function(t,e){return this.throwIfDisposed(),qO(this,[t,e])},rD().prototype.as3D=function(t,e,n){return this.throwIfDisposed(),qO(this,[t,e,n])},rD().prototype.as4D=function(t,e,n,i){return this.throwIfDisposed(),qO(this,[t,e,n,i])},rD().prototype.as5D=function(t,e,n,i,r){return this.throwIfDisposed(),qO(this,[t,e,n,i,r])};const tV=LD({asin_:function(t){const e=RD(t,"x","asin");return _D.runKernel(Ek,{x:e})}});rD().prototype.asin=function(){return this.throwIfDisposed(),tV(this)};const eV=LD({asinh_:function(t){const e=RD(t,"x","asinh");return _D.runKernel(Ck,{x:e})}});rD().prototype.asinh=function(){return this.throwIfDisposed(),eV(this)};const nV=LD({atan_:function(t){const e=RD(t,"x","atan");return _D.runKernel(Ik,{x:e})}});rD().prototype.atan=function(){return this.throwIfDisposed(),nV(this)};const iV=LD({atan2_:function(t,e){let n=RD(t,"a","atan2"),i=RD(e,"b","atan2");return[n,i]=fD(n,i),_D.runKernel(Mk,{a:n,b:i})}});rD().prototype.atan2=function(t){return this.throwIfDisposed(),iV(this,t)};const rV=LD({atanh_:function(t){const e=RD(t,"x","atanh");return _D.runKernel(Tk,{x:e})}});rD().prototype.atanh=function(){return this.throwIfDisposed(),rV(this)},rD().prototype.avgPool=function(t,e,n,i){return this.throwIfDisposed(),XO(this,t,e,n,i)},rD().prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),QH(this,t,e)},rD().prototype.batchNorm=function(t,e,n,i,r){return this.throwIfDisposed(),KO(this,t,e,n,i,r)},rD().prototype.broadcastTo=function(t){return this.throwIfDisposed(),$F(this,t)},rD().prototype.cast=function(t){return this.throwIfDisposed(),NB(this,t)};const sV=LD({ceil_:function(t){const e=RD(t,"x","ceil");return _D.runKernel(Fk,{x:e})}});rD().prototype.ceil=function(){return this.throwIfDisposed(),sV(this)},rD().prototype.clipByValue=function(t,e){return this.throwIfDisposed(),eP(this,t,e)},rD().prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof iD&&(t=[t]),nP([this,...t],e)},rD().prototype.conv1d=function(t,e,n,i,r,s){return this.throwIfDisposed(),lP(this,t,e,n,i,r,s)},rD().prototype.conv2dTranspose=function(t,e,n,i,r){return this.throwIfDisposed(),uP(this,t,e,n,i,r)},rD().prototype.conv2d=function(t,e,n,i,r,s){return this.throwIfDisposed(),aP(this,t,e,n,i,r,s)},rD().prototype.cos=function(){return this.throwIfDisposed(),zH(this)},rD().prototype.cosh=function(){return this.throwIfDisposed(),HH(this)},rD().prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),kU(this,t,e,n)};const oV=LD({depthToSpace_:function(t,e,n="NHWC"){const i=RD(t,"x","depthToSpace"),r="NHWC"===n?i.shape[1]:i.shape[2],s="NHWC"===n?i.shape[2]:i.shape[3],o="NHWC"===n?i.shape[3]:i.shape[1];return _M(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${r} and ${e}  for depthToSpace with input shape\n    ${i.shape}`),_M(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${e} for depthToSpace with input shape\n        ${i.shape}`),_M(o%(e*e)==0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${i.shape}`),_D.runKernel(tR,{x:i},{blockSize:e,dataFormat:n})}});rD().prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),oV(this,t,e)},rD().prototype.depthwiseConv2d=function(t,e,n,i,r,s){return this.throwIfDisposed(),fP(this,t,e,n,i,r,s)};const aV=LD({dilation2d_:function(t,e,n,i,r=[1,1],s="NHWC"){const o=RD(t,"x","dilation2d"),a=RD(e,"filter","dilation2d");_M(3===o.rank||4===o.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),_M(3===a.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),_M("NHWC"===s,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=o,c=!1;3===o.rank&&(l=qO(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0);const u=_D.runKernel(sR,{x:l,filter:a},{strides:n,pad:i,dilations:r});return c?qO(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});rD().prototype.dilation2d=function(t,e,n,i,r){return this.throwIfDisposed(),aV(this,t,e,n,i,r)};const lV=LD({divNoNan_:function(t,e){let n=RD(t,"a","div"),i=RD(e,"b","div");[n,i]=fD(n,i);const r=gP(n,i),s=UF(r),o=_P(i,s);return zF(o,s,r)}});rD().prototype.divNoNan=function(t){return this.throwIfDisposed(),lV(this,t)},rD().prototype.div=function(t){return this.throwIfDisposed(),gP(this,t)},rD().prototype.dot=function(t){return this.throwIfDisposed(),vP(this,t)},rD().prototype.elu=function(){return this.throwIfDisposed(),bP(this)},rD().prototype.equal=function(t){return this.throwIfDisposed(),_P(this,t)};const cV=LD({erf_:function(t){let e=RD(t,"x","erf");return _M("int32"===e.dtype||"float32"===e.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===e.dtype&&(e=NB(e,"float32")),_D.runKernel(dR,{x:e})}});rD().prototype.erf=function(){return this.throwIfDisposed(),cV(this)},rD().prototype.exp=function(){return this.throwIfDisposed(),SP(this)},rD().prototype.expandDims=function(t){return this.throwIfDisposed(),EP(this,t)};const uV=LD({expm1_:function(t){const e=RD(t,"x","expm1");return _D.runKernel(gR,{x:e})}});rD().prototype.expm1=function(){return this.throwIfDisposed(),uV(this)},rD().prototype.fft=function(){return this.throwIfDisposed(),jF(this)},rD().prototype.flatten=function(){return this.throwIfDisposed(),qO(this,[this.size])},rD().prototype.floor=function(){return this.throwIfDisposed(),MP(this)},rD().prototype.floorDiv=function(t){return this.throwIfDisposed(),mP(this,t)},rD().prototype.gather=function(t,e){return this.throwIfDisposed(),kP(this,t,e)},rD().prototype.greaterEqual=function(t){return this.throwIfDisposed(),NP(this,t)},rD().prototype.greater=function(t){return this.throwIfDisposed(),RP(this,t)},rD().prototype.ifft=function(){return this.throwIfDisposed(),qF(this)},rD().prototype.irfft=function(){return this.throwIfDisposed(),XF(this)};const hV=LD({isFinite_:function(t){const e=RD(t,"x","isFinite");return _D.runKernel(kR,{x:e})}});rD().prototype.isFinite=function(){return this.throwIfDisposed(),hV(this)};const dV=LD({isInf_:function(t){const e=RD(t,"x","isInf");return _D.runKernel(RR,{x:e})}});rD().prototype.isInf=function(){return this.throwIfDisposed(),dV(this)},rD().prototype.isNaN=function(){return this.throwIfDisposed(),LP(this)},rD().prototype.leakyRelu=function(t){return this.throwIfDisposed(),DP(this,t)},rD().prototype.lessEqual=function(t){return this.throwIfDisposed(),k$(this,t)},rD().prototype.less=function(t){return this.throwIfDisposed(),oH(this,t)};const pV=LD({localResponseNormalization_:function(t,e=5,n=1,i=1,r=.5){const s=RD(t,"x","localResponseNormalization");_M(4===s.rank||3===s.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${s.rank}.`),_M(kM(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=s,a=!1;3===s.rank&&(a=!0,o=qO(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const l=_D.runKernel(HR,{x:o},{depthRadius:e,bias:n,alpha:i,beta:r});return a?qO(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});rD().prototype.localResponseNormalization=function(t,e,n,i){return this.throwIfDisposed(),pV(this,t,e,n,i)};const fV=LD({logSigmoid_:function(t){const e=RD(t,"x","logSigmoid");return IO(t=>({value:rF(MF(rF(t))),gradFunc:e=>FP(e,wF(rF(t)))}))(e)}});rD().prototype.logSigmoid=function(){return this.throwIfDisposed(),fV(this)},rD().prototype.logSoftmax=function(t){return this.throwIfDisposed(),UP(this,t)},rD().prototype.logSumExp=function(t,e){return this.throwIfDisposed(),W$(this,t,e)},rD().prototype.log=function(){return this.throwIfDisposed(),BP(this)},rD().prototype.log1p=function(){return this.throwIfDisposed(),OP(this)},rD().prototype.logicalAnd=function(t){return this.throwIfDisposed(),HP(this,t)},rD().prototype.logicalNot=function(){return this.throwIfDisposed(),BH(this)};const mV=LD({logicalOr_:function(t,e){const n=RD(t,"a","logicalOr","bool"),i=RD(e,"b","logicalOr","bool");return wP(n.shape,i.shape),_D.runKernel(UR,{a:n,b:i})}});rD().prototype.logicalOr=function(t){return this.throwIfDisposed(),mV(this,t)};const gV=LD({logicalXor_:function(t,e){const n=RD(t,"a","logicalXor","bool"),i=RD(e,"b","logicalXor","bool");return wP(n.shape,i.shape),HP(mV(t,e),BH(HP(t,e)))}});rD().prototype.logicalXor=function(t){return this.throwIfDisposed(),gV(this,t)},rD().prototype.matMul=function(t,e,n){return this.throwIfDisposed(),yP(this,t,e,n)},rD().prototype.maxPool=function(t,e,n,i){return this.throwIfDisposed(),VP(this,t,e,n,i)},rD().prototype.max=function(t,e){return this.throwIfDisposed(),PP(this,t,e)},rD().prototype.maximum=function(t){return this.throwIfDisposed(),WP(this,t)},rD().prototype.mean=function(t,e){return this.throwIfDisposed(),jP(this,t,e)},rD().prototype.min=function(t,e){return this.throwIfDisposed(),O$(this,t,e)},rD().prototype.minimum=function(t){return this.throwIfDisposed(),QP(this,t)};const yV=LD({mirrorPad_:function(t,e,n){_M("reflect"===n||"symmetric"===n,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const i=RD(t,"x","mirrorPad");if(0===i.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");_M(e.length===i.rank,()=>`Padding doesn't match input. Must be ${i.rank}. Got ${e.length}.`);const r="reflect"===n?1:0;for(let s=0;s<i.rank;s++)_M(2===e[s].length,()=>"Invalid number of paddings. Must be length of 2 each."),_M(e[s][0]>=0&&e[s][0]<=i.shape[s]-r&&e[s][1]>=0&&e[s][1]<=i.shape[s]-r,()=>`Padding in dimension ${s} cannot be greater than or equal to ${i.shape[s]-r} or less than 0 for input of shape ${i.shape}`);return _D.runKernel(tN,{x:i},{paddings:e,mode:n})}});rD().prototype.mirrorPad=function(t,e){return this.throwIfDisposed(),yV(this,t,e)};const vV=LD({mod_:function(t,e){let n=RD(t,"a","mod"),i=RD(e,"b","mod");return[n,i]=fD(n,i),_D.runKernel(eN,{a:n,b:i})}});rD().prototype.mod=function(t){return this.throwIfDisposed(),vV(this,t)},rD().prototype.mul=function(t){return this.throwIfDisposed(),FP(this,t)},rD().prototype.neg=function(){return this.throwIfDisposed(),rF(this)},rD().prototype.norm=function(t,e,n){return this.throwIfDisposed(),F$(this,t,e,n)},rD().prototype.notEqual=function(t){return this.throwIfDisposed(),sF(this,t)},rD().prototype.oneHot=function(t,e=1,n=0){return this.throwIfDisposed(),oF(this,t,e,n)},rD().prototype.onesLike=function(){return this.throwIfDisposed(),cF(this)},rD().prototype.pad=function(t,e){return this.throwIfDisposed(),uF(this,t,e)};const bV=LD({pool_:function(t,e,n,i,r,s){null==r&&(r=[1,1]),null==s&&(s=1),0===i&&(i="valid");const o=RD(t,"x","maxPool");let a=o,l=!1;3===o.rank&&(l=!0,a=qO(o,[1,o.shape[0],o.shape[1],o.shape[2]])),_M(jO(s,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${r}'`);const c=OO(a.shape,e,s,r,i),u=[c.dilationHeight,c.dilationWidth];let h;h="same"===i?function(t,e){const n=t.map((t,n)=>t+(t-1)*(e[n]-1)).map(t=>t-1),i=n.map(t=>Math.floor(t/2)),r=n.map((t,e)=>t-i[e]);return n.map((t,e)=>[i[e],r[e]])}([c.filterHeight,c.filterWidth],u):[[0,0],[0,0]];const d=1===u[0]&&1===u[1],[p,f]=function(t,e,n){const i=n.map(t=>t[0]),r=n.map(t=>t[1]),s=t.concat(i,r),o=e.map((t,e)=>(t-s[e]%t)%t),a=r.map((t,e)=>t+o[e]);return[e.map((t,e)=>[i[e],a[e]]),e.map((t,e)=>[0,o[e]])]}([c.inHeight,c.inWidth],u,h),m=d?i:"valid",g=d?a:fU(a,u,p),y=("avg"===n?()=>XO(g,e,s,m):()=>VP(g,e,s,m))(),v=d?y:QH(y,u,f);return l?qO(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});rD().prototype.pool=function(t,e,n,i,r){return this.throwIfDisposed(),bV(this,t,e,n,i,r)},rD().prototype.pow=function(t){return this.throwIfDisposed(),hF(this,t)},rD().prototype.prelu=function(t){return this.throwIfDisposed(),dF(this,t)};const AV=LD({prod_:function(t,e=null,n=!1){let i=RD(t,"x","prod");return"bool"===i.dtype&&(i=NB(i,"int32")),_D.runKernel(mN,{x:i},{axis:e,keepDims:n})}});rD().prototype.prod=function(t,e){return this.throwIfDisposed(),AV(this,t,e)};const xV=LD({reciprocal_:function(t){const e=RD(t,"x","reciprocal");return _D.runKernel(vN,{x:e})}});rD().prototype.reciprocal=function(){return this.throwIfDisposed(),xV(this)},rD().prototype.relu=function(){return this.throwIfDisposed(),vF(this)},rD().prototype.relu6=function(){return this.throwIfDisposed(),KF(this)},rD().prototype.reshapeAs=function(t){return this.throwIfDisposed(),qO(this,t.shape)},rD().prototype.reshape=function(t){return this.throwIfDisposed(),qO(this,t)},rD().prototype.resizeBilinear=function(t,e,n){return this.throwIfDisposed(),I$(this,t,e,n)},rD().prototype.resizeNearestNeighbor=function(t,e,n){return this.throwIfDisposed(),T$(this,t,e,n)},rD().prototype.reverse=function(t){return this.throwIfDisposed(),bF(this,t)},rD().prototype.rfft=function(){return this.throwIfDisposed(),QF(this)},rD().prototype.round=function(){return this.throwIfDisposed(),R$(this)},rD().prototype.rsqrt=function(){return this.throwIfDisposed(),UU(this)},rD().prototype.selu=function(){return this.throwIfDisposed(),AF(this)},rD().prototype.separableConv2d=function(t,e,n,i,r,s){return this.throwIfDisposed(),xF(this,t,e,n,i,r,s)},rD().prototype.sigmoid=function(){return this.throwIfDisposed(),wF(this)};const wV=LD({sign_:function(t){const e=RD(t,"x","sign");return _D.runKernel(BN,{x:e})}});rD().prototype.sign=function(){return this.throwIfDisposed(),wV(this)},rD().prototype.sin=function(){return this.throwIfDisposed(),CU(this)},rD().prototype.sinh=function(){return this.throwIfDisposed(),TU(this)},rD().prototype.slice=function(t,e){return this.throwIfDisposed(),_F(this,t,e)},rD().prototype.softmax=function(t){return this.throwIfDisposed(),TF(this,t)},rD().prototype.softplus=function(){return this.throwIfDisposed(),MF(this)},rD().prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),fU(this,t,e)},rD().prototype.split=function(t,e){return this.throwIfDisposed(),kF(this,t,e)},rD().prototype.sqrt=function(){return this.throwIfDisposed(),RF(this)},rD().prototype.square=function(){return this.throwIfDisposed(),nF(this)},rD().prototype.squaredDifference=function(t){return this.throwIfDisposed(),G$(this,t)},rD().prototype.squeeze=function(t){return this.throwIfDisposed(),NF(this,t)},rD().prototype.stack=function(t,e){this.throwIfDisposed();const n=t instanceof iD?[this,t]:[this,...t];return LF(n,e)},rD().prototype.step=function(t){return this.throwIfDisposed(),JF(this,t)};const _V=LD({stridedSlice_:function(t,e,n,i,r=0,s=0,o=0,a=0,l=0){const c=RD(t,"x","stridedSlice","string_or_numeric");return _D.runKernel(YN,{x:c},{begin:e,end:n,strides:i,beginMask:r,endMask:s,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l})}});rD().prototype.stridedSlice=function(t,e,n,i,r,s,o,a){return this.throwIfDisposed(),_V(this,t,e,n,i,r,s,o,a)},rD().prototype.sub=function(t){return this.throwIfDisposed(),$P(this,t)},rD().prototype.sum=function(t,e){return this.throwIfDisposed(),zP(this,t,e)};const SV=LD({tan_:function(t){const e=RD(t,"x","tan");return _D.runKernel(eL,{x:e})}});rD().prototype.tan=function(){return this.throwIfDisposed(),SV(this)},rD().prototype.tanh=function(){return this.throwIfDisposed(),DF(this)},rD().prototype.tile=function(t){return this.throwIfDisposed(),CP(this,t)},rD().prototype.toBool=function(){return this.throwIfDisposed(),NB(this,"bool")},rD().prototype.toFloat=function(){return this.throwIfDisposed(),NB(this,"float32")},rD().prototype.toInt=function(){return this.throwIfDisposed(),NB(this,"int32")};const EV=LD({topk_:function(t,e=1,n=!0){const i=RD(t,"x","topk");if(0===i.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const r=i.shape[i.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const s={x:i},o={k:e,sorted:n},[a,l]=_D.runKernel(rL,s,o);return{values:a,indices:l}}});rD().prototype.topk=function(t,e){return this.throwIfDisposed(),EV(this,t,e)},rD().prototype.transpose=function(t){return this.throwIfDisposed(),HF(this,t)};const CV=LD({unique_:function(t,e=0){const n=RD(t,"x","unique","string_or_numeric");_M(n.rank>0,()=>"The input tensor must be at least 1D");const i={x:n},r={axis:e},[s,o]=_D.runKernel(aL,i,r);return{values:s,indices:o}}});let IV;function TV(){return null==IV&&(IV=_D.backend.epsilon()),IV}rD().prototype.unique=function(t){return this.throwIfDisposed(),CV(this,t)},rD().prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),VU(this,t,e)},rD().prototype.unstack=function(t){return this.throwIfDisposed(),FF(this,t)},rD().prototype.where=function(t,e){return this.throwIfDisposed(),zF(t,this,e)},rD().prototype.zerosLike=function(){return this.throwIfDisposed(),UF(this)};class MV extends Error{constructor(t){super(t),Object.setPrototypeOf(this,MV.prototype)}}class kV extends Error{constructor(t){super(t),Object.setPrototypeOf(this,kV.prototype)}}class RV extends Error{constructor(t){super(t),Object.setPrototypeOf(this,RV.prototype)}}class NV extends Error{constructor(t){super(t),Object.setPrototypeOf(this,NV.prototype)}}class LV extends Error{constructor(t){super(t),Object.setPrototypeOf(this,LV.prototype)}}function DV(t,e){if(Array.isArray(t)){let n=[];for(let i=0;i<e;i++)n=n.concat(t);return n}{const n=new Array(e);return n.fill(t),n}}function BV(t,e){if(!t)throw new LV(e)}function OV(t,e){let n=0;for(const i of t)i===e&&n++;return n}function PV(t){return 1===t.length?t[0]:t}function FV(t){return Array.isArray(t)?t:[t]}function $V(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function zV(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}Error;let UV={};function HV(t){if(null==t)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function VV(t){if(null!=t&&"object"==typeof t)if(Array.isArray(t))t.forEach(t=>VV(t));else{const e=Object.keys(t);for(const n of e){const e=t[n];null!=e&&"object"==typeof e&&(Array.isArray(e)||"ndarray"!==e.type||"number"!=typeof e.value?VV(e):t[n]=e.value)}}}function GV(t,e={},n={},i="object",r=!1){if("string"==typeof t){const r=t;let s;if(r in n)s=n[r];else if(r in UV)s=UV[r];else if(s=e[r],null==s)throw new RV(`Unknown ${i}: ${t}. This may be due to one of the following reasons:\n1. The ${i} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${i} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return s}{const s=t;if(null==s.className||null==s.config)throw new RV(`${i}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);const o=s.className;let a,l;if(o in n?[a,l]=n[o]:o in UV?[a,l]=UV.className:o in e&&([a,l]=e[o]),null==a)throw new RV(`Unknown ${i}: ${o}. This may be due to one of the following reasons:\n1. The ${i} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${i} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const t={};for(const n of Object.keys(UV))t[n]=UV[n];for(const r of Object.keys(n))t[r]=n[r];s.config.customObjects=t;const e=Object.assign({},UV);for(const r of Object.keys(n))UV[r]=n[r];VV(s.config);const i=l(a,s.config,n,r);return UV=Object.assign({},e),i}{const t=Object.assign({},UV);for(const i of Object.keys(n))UV[i]=n[i];const e=new a(s.config);return UV=Object.assign({},t),e}}}function WV(t,e){return-1*function(t,e){return t<e?-1:t>e?1:0}(t,e)}function jV(t){if(null==t)return t;const e=[];for(const n of t)-1===e.indexOf(n)&&e.push(n);return e}function QV(t){if(null==t)throw new RV(`Invalid value in obj: ${JSON.stringify(t)}`);for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function qV(t,e,n){if(null!=n&&t.indexOf(n)<0)throw new RV(`${n} is not a valid ${e}.  Valid values are ${t} or null/undefined.`)}function XV(t,e,n=0,i=1/0){return BV(n>=0),BV(i>=n),Array.isArray(t)&&t.length>=n&&t.length<=i&&t.every(t=>typeof t===e)}function YV(t,e){Array.isArray(t)?(i.assert(t.length>0,()=>`${e} is unexpectedly an empty array.`),t.forEach((t,n)=>YV(t,`element ${n+1} of ${e}`))):i.assert(Number.isInteger(t)&&t>0,()=>`Expected ${e} to be a positive integer, but got ${KV(t)}.`)}function KV(t){return null===t?"null":Array.isArray(t)?"["+t.map(t=>KV(t)).join(",")+"]":"string"==typeof t?`"${t}"`:`${t}`}function JV(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}function ZV(t,e){return _O(()=>RF(zP(FP(t,t),e,!0)))}class tG extends c.Serializable{getConfig(){return{}}}class eG extends tG{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return _O(()=>{const e=ZV(t,this.axis),n=eP(e,0,this.maxValue);return FP(t,gP(n,RO(TV(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}eG.className="MaxNorm",c.registerClass(eG);class nG extends tG{constructor(t){super(),this.defaultAxis=0,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return _O(()=>gP(t,RO(TV(),ZV(t,this.axis))))}getConfig(){return{axis:this.axis}}}nG.className="UnitNorm",c.registerClass(nG);class iG extends tG{apply(t){return vF(t)}}iG.className="NonNeg",c.registerClass(iG);class rG extends tG{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=t.minValue?t.minValue:this.defaultMinValue,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.rate=null!=t.rate?t.rate:this.defaultRate,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return _O(()=>{const e=ZV(t,this.axis),n=RO(FP(this.rate,eP(e,this.minValue,this.maxValue)),FP(1-this.rate,e));return FP(t,gP(n,RO(TV(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}rG.className="MinMaxNorm",c.registerClass(rG);const sG={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function oG(t){return HV(t)}function aG(t,e={}){return GV(t,c.SerializationMap.getMap().classNameMap,e,"constraint")}function lG(t){return null==t?null:"string"==typeof t?aG({className:t in sG?sG[t]:t,config:{}}):t instanceof tG?t:aG(t)}const cG=["channelsFirst","channelsLast"],uG=["nearest","bilinear"],hG=["valid","same","causal"],dG=["max","avg"],pG=["sum","mul","concat","ave"],fG=new Map;function mG(t){qV(cG,"DataFormat",t)}function gG(t){qV(hG,"PaddingMode",t)}function yG(t){qV(dG,"PoolMode",t)}const vG=[];function bG(t,e){vG.push(t);try{const t=e();return vG.pop(),t}catch(n){throw vG.pop(),n}}function AG(t){if(!_G(t))throw new Error("Not a valid tensor name: '"+t+"'");return(0===vG.length?"":vG.join("/")+"/")+t}function xG(t){if(!_G(t))throw new Error("Not a valid tensor name: '"+t+"'");fG.has(t)||fG.set(t,0);const e=fG.get(t);if(fG.set(t,fG.get(t)+1),e>0){const n=`${t}_${e}`;return fG.set(n,1),n}return t}const wG=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function _G(t){return!!t.match(wG)}function SG(t,e,n){null==e&&(e=0),null==n&&(n=t.length);let i=1;for(let r=e;r<n;++r)i*=t[r];return i}function EG(t){if(0===t.length)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let n=0;n<t.length;n++){const i=t[n];i<e&&(e=i)}return e}function CG(t){if(0===t.length)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let n=0;n<t.length;n++){const i=t[n];i>e&&(e=i)}return e}function IG(t,e){if(e<t)throw new RV(`end (${e}) < begin (${t}) is forbidden.`);const n=[];for(let i=t;i<e;++i)n.push(i);return n}function TG(t,e){return NB(t,e)}function MG(t,e=-1){const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),qO(t,n)}function kG(t,e,n){return _O(()=>{switch(t.rank){case 1:return SF(t,e,n);case 2:return EF(t,[e,0],[n,t.shape[1]]);case 3:return CF(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return IF(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return _F(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return _F(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new RV(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}})}function RG(t,e,n){return _O(()=>{switch(t.rank){case 1:return SF(t,e,n);case 2:return EF(t,[0,e],[t.shape[0],n]);case 3:return CF(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return IF(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new RV(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function NG(t,e,n,i){return _O(()=>{switch(t.rank){case 1:return SF(t,e,n);case 2:switch(i){case 1:return kG(t,e,n);case 2:return RG(t,e,n);default:throw new RV(`The axis is not within the rank of the tensor ${i}`)}case 3:switch(i){case 1:return kG(t,e,n);case 2:return CF(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return RG(t,e,n);default:throw new RV(`The axis is not within the rank of the tensor ${i}`)}case 4:switch(i){case 1:return kG(t,e,n);case 2:return IF(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return IF(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return RG(t,e,n);default:throw new RV(`The axis is not within the rank of the tensor ${i}`)}default:throw new RV(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function LG(t,e=-1){let n;return e<0&&(n=t[0].rank,e=0!==n?n:0),e===t[0].rank&&(e=-1),nP(t,e)}function DG(t,e){switch(t.rank){case 1:return iP([t,e]);case 2:return rP([t,e],0);case 3:return sP([t,e],0);case 4:return oP([t,e],0);default:throw new RV(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function BG(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new RV(`The length of input n (${e.length}) does not match the number of dimensions in input x (${t.rank})`);return CP(t,e)}function OG(t,e=0,n=1,i,r){return gF(t,e,n,i,r)}function PG(t,e,n,i){if(t.rank<2||e.rank<2)throw new NV(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${e.shape}`);if(e.rank>=3&&t.shape.slice(-1)[0]!==e.shape.slice(-2)[0])throw new NV(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${e.shape}`);if(2===t.rank&&2===e.rank)return u.matMul({a:t,b:e,transposeA:!1,transposeB:!1,bias:i?zG(t.rank,i,"channelsLast"):null,activation:n});{const r=t.shape.slice(),s=r.pop();t=qO(t,[-1,s]);const o=e.shape.slice(),a=o.pop(),l=o.pop(),c=[...o,a],h=Array.from({length:e.rank},(t,n)=>0===n?e.rank-2:n<=e.rank-2?n-1:n);e=qO(HF(e,h),[l,-1]);const d=[...r,...c];return qO(u.matMul({a:t,b:e,transposeA:!1,transposeB:!1,bias:i?zG(t.rank,i,"channelsLast"):null,activation:n}),d)}}function FG(t,e,n){return _O(()=>(e=Array.isArray(e)?BF(e,"int32"):NB(e,"int32"),kP(t,e,n)))}function $G(t){return FP(t,t)}function zG(t,e,n){const i=e.shape;if(1!==e.rank&&e.rank!==t)throw new RV(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${t}`);if(5===t){if("channelsFirst"===n)return qO(e,1===i.length?[1,i[0],1,1,1]:[1,i[3],i[0],i[1],i[2]]);if("channelsLast"===n)return qO(e,1===i.length?[1,1,1,1,i[0]]:[1].concat(i))}else if(4===t){if("channelsFirst"===n)return qO(e,1===i.length?[1,i[0],1,1]:[1,i[2],i[0],i[1]]);if("channelsLast"===n)return qO(e,1===i.length?[1,1,1,i[0]]:[1].concat(i))}else if(3===t){if("channelsFirst"===n)return qO(e,1===i.length?[1,i[0],1]:[1,i[1],i[0]]);if("channelsLast"===n)return qO(e,1===i.length?[1,1,i[0]]:[1].concat(i))}else if(t<3)return e;throw new RV(`Unsupported input rank by biasAdd: ${e.rank}`)}function UG(t,e,n){return _O(()=>(null==n&&(n="channelsLast"),mG(n),RO(t,zG(t.rank,e,n))))}function HG(t,e,n,i){return _O(()=>VF(t,e,n,i))}function VG(t,e,n=!1){return n?t():e()}const GG=["fanIn","fanOut","fanAvg"],WG=["normal","uniform","truncatedNormal"];class jG extends c.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class QG extends jG{apply(t,e){return aF(t,e)}}QG.className="Zeros",c.registerClass(QG);class qG extends jG{apply(t,e){return lF(t,e)}}qG.className="Ones",c.registerClass(qG);class XG extends jG{constructor(t){if(super(),"object"!=typeof t)throw new RV(`Expected argument of type ConstantConfig but got ${t}`);if(void 0===t.value)throw new RV(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return _O(()=>FP(TO(this.value),lF(t,e)))}getConfig(){return{value:this.value}}}XG.className="Constant",c.registerClass(XG);class YG extends jG{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return yF(t,this.minval,this.maxval,e)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}YG.className="RandomUniform",c.registerClass(YG);class KG extends jG{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new NV(`randomNormal does not support dType ${e}.`);return OG(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}KG.className="RandomNormal",c.registerClass(KG);class JG extends jG{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new NV(`truncatedNormal does not support dType ${e}.`);return PF(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}JG.className="TruncatedNormal",c.registerClass(JG);class ZG extends jG{constructor(t){super(),this.gain=null!=t.gain?t.gain:1}apply(t,e){return _O(()=>{if(2!==t.length||t[0]!==t[1])throw new RV("Identity matrix initializer can only be used for 2D square matrices.");return FP(this.gain,IP(t[0]))})}getConfig(){return{gain:this.gain}}}ZG.className="Identity",c.registerClass(ZG);class tW extends jG{constructor(t){if(super(),t.scale<0)throw new RV(`scale must be a positive float. Got: ${t.scale}`);this.scale=null==t.scale?1:t.scale,this.mode=null==t.mode?"fanIn":t.mode,qV(GG,"FanMode",this.mode),this.distribution=null==t.distribution?"normal":t.distribution,qV(WG,"Distribution",this.distribution),this.seed=t.seed}apply(t,e){const n=function(t,e="channelsLast"){let n,i;if(mG(e),2===t.length)n=t[0],i=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===e){const e=SG(t,2);n=t[1]*e,i=t[0]*e}else if("channelsLast"===e){const e=SG(t,0,t.length-2);n=t[t.length-2]*e,i=t[t.length-1]*e}}else{const e=SG(t);n=Math.sqrt(e),i=Math.sqrt(e)}return[n,i]}(t),i=n[0],r=n[1];let s=this.scale;if(s/="fanIn"===this.mode?Math.max(1,i):"fanOut"===this.mode?Math.max(1,r):Math.max(1,(i+r)/2),"normal"===this.distribution){const n=Math.sqrt(s);if("float32"!==(e=e||"float32")&&"int32"!==e)throw new NV(`${this.getClassName()} does not support dType ${e}.`);return PF(t,0,n,e,this.seed)}{const n=Math.sqrt(3*s);return yF(t,-n,n,e)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}tW.className="VarianceScaling",c.registerClass(tW);class eW extends tW{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return tW.className}}eW.className="GlorotUniform",c.registerClass(eW);class nW extends tW{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return tW.className}}nW.className="GlorotNormal",c.registerClass(nW);class iW extends tW{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return tW.className}}iW.className="HeNormal",c.registerClass(iW);class rW extends tW{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return tW.className}}rW.className="HeUniform",c.registerClass(rW);class sW extends tW{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return tW.className}}sW.className="LeCunNormal",c.registerClass(sW);class oW extends tW{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return tW.className}}oW.className="LeCunNormal",c.registerClass(oW);class aW extends jG{constructor(t){if(super(),this.DEFAULT_GAIN=1,this.gain=null==t.gain?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,null!=this.seed)throw new NV("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,e){return _O(()=>{if(t.length<2)throw new NV("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);const e=OG(t[0]>t[1]?[t[1],t[0]]:t,0,1,"float32");let n=Q$.gramSchmidt(e);return t[0]>t[1]&&(n=HF(n)),FP(this.gain,n)})}getConfig(){return{gain:this.gain,seed:this.seed}}}aW.className="Orthogonal",c.registerClass(aW);const lW={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function cW(t,e={}){return GV(t,c.SerializationMap.getMap().classNameMap,e,"initializer")}function uW(t){return HV(t)}function hW(t){if("string"==typeof t){const e=t in lW?lW[t]:t;if("GlorotNormal"===e)return new nW;if("GlorotUniform"===e)return new eW;if("HeNormal"===e)return new iW;if("HeUniform"===e)return new rW;if("LeCunNormal"===e)return new sW;if("LeCunUniform"===e)return new oW;{const t={};return t.className=e,t.config={},cW(t)}}return t instanceof jG?t:cW(t)}let dW=0;function pW(){return dW++}const fW={};function mW(t=""){return t in fW||(fW[t]=0),fW[t]+=1,t+fW[t].toString()}function gW(t){return Array.isArray(t)&&Array.isArray(t[0])}function yW(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function vW(t){let e;if(Array.isArray(t)){if(1!==t.length)throw new RV(`Expected Tensor length to be 1; got ${t.length}`);e=t[0]}else e=t;return e}function bW(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return(t=t)[0];throw new RV(`Expected exactly 1 Shape; got ${t.length}`)}return t}function AW(t){let e=0;for(const n of t)e+=0===n.shape.length?1:n.shape.reduce((t,e)=>t*e);return e}class xW{constructor(t,e="float32",n="Variable",i=!0,r=null){this.dtype=null==e?"float32":e,this.shape=t.shape,this.id=pW(),this.originalName=AG(n=null==n?"Variable":n),this.name=xG(this.originalName),this.trainable_=i,this.constraint=r,this.val=function(t,e=!0,n,i){return _D.makeVariable(t,e,n,i)}(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function wW(t){return t.map(t=>t.read())}function _W(t){t.forEach(t=>{t[0].write(t[1])})}class SW{constructor(t){this.dtype=t.dtype,this.shape=t.shape,this.ndim=null!=t.shape?t.shape.length:t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class EW{constructor(t,e,n,i,r,s,o){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=i,this.callArgs=r,this.outputTensorIndex=o,this.id=pW(),null!=s&&(this.originalName=AG(s),this.name=xG(this.originalName)),this.rank=e.length}}let CW=0;class IW{constructor(t,e){this.callArgs=e,this.id=CW++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const n of t.inboundLayers)null!=n&&n.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)t.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let TW=0;class MW extends c.Serializable{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=TW++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const t=this.getClassName();e=$V(t)+"_"+mW(t)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let e;if(null!=t.batchInputShape)e=t.batchInputShape;else if(null!=t.inputShape){let n=null;null!=t.batchSize&&(n=t.batchSize),e=[n].concat(t.inputShape)}this.batchInputShape=e;let n=t.dtype;null==n&&(n=t.inputDType),null==n&&(n="float32"),this.dtype=n}this.initialWeights=null!=t.weights?t.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new kV(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new RV(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return PV(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return PV(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new MV(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new MV(`Layer ${this.name} is not connected, no input to return.`);return PV(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new MV(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new MV(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return PV(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=FV(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=FV(this.inputSpec);if(t.length!==e.length)throw new RV(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let n=0;n<t.length;n++){const i=t[n],r=e[n];if(null==r)continue;const s=i.rank;if(null!=r.ndim&&s!==r.ndim)throw new RV(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${r.ndim}, found ndim=${s}`);if(null!=r.maxNDim&&s>r.maxNDim)throw new RV(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${r.maxNDim}, found ndim=${s}`);if(null!=r.minNDim&&s<r.minNDim)throw new RV(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${r.minNDim}, found ndim=${s}.`);if(null!=r.dtype&&i.dtype!==r.dtype)throw new RV(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${r.dtype}, found dtype=${i.dtype}.`);if(r.axes){const t=i.shape;for(const e in r.axes){const i=Number(e),s=r.axes[e],o=i>=0?t[i]:t[t.length+i];if(null!=s&&-1===[s,null].indexOf(o))throw new RV(`Input ${n} is incompatible with layer ${this.name}: expected axis ${i} of input shape to have value ${s} but got shape ${t}.`)}}if(null!=r.shape)for(let t=0;t<r.shape.length;++t){const e=r.shape[t],s=i.shape[t];if(null!=e&&null!=s&&e!==s)throw new RV(`Input ${n} is incompatible with layer ${this.name}: expected shape=${r.shape}, found shape=${i.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const n=FV(t);let i=!0;for(const s of n)if(!(s instanceof EW)){i=!1;break}let r=!0;for(const s of n)if(s instanceof EW){r=!1;break}if(i===r)throw new RV("Arguments to apply() must be all SymbolicTensors or all Tensors");return bG(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const e=[];for(const n of FV(t))e.push(n.shape);this.build(PV(e)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&r&&(this._refCount=1)}if(this.assertInputCompatibility(t),r){let i=this.call(t,e);const r=FV(i),s=[];for(let t of r)-1!==n.indexOf(t)&&(t=t.clone()),s.push(t);if(i=PV(s),null!=this.activityRegularizer)throw new NV("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}{const n=function(t){t=FV(t);const e=[];for(const n of t)e.push(n.shape);return PV(e)}(t),i=this.computeOutputShape(n);let r;const s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?n[0]:n),r=null!=i&&i.length>0&&Array.isArray(i[0])?i.map((n,i)=>new EW(s,n,this,FV(t),e,this.name,i)):new EW(s,i,this,FV(t),e,this.name),this.addInboundNode(t,r,null,null,n,i,e),this._refCount++,null!=this.activityRegularizer)throw new NV("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}})}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((n,i)=>{null!=n&&null!=t[i]&&t[i]!==n&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new MV(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const n=JSON.stringify(e.outputShapes);-1===t.indexOf(n)&&t.push(n)}if(1===t.length){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&1===t.length?t[0]:t}throw new MV(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new kV(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return AW(this.weights)}build(t){this.built=!0}getWeights(t=!1){return wW(t?this.trainableWeights:this.weights)}setWeights(t){_O(()=>{const e=this.weights;if(e.length!==t.length)throw new RV(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const n=[],r=wW(e);for(let s=0;s<r.length;++s){const o=r[s],a=e[s],l=t[s];if(!i.arraysEqual(o.shape,l.shape))throw new RV(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);n.push([a,l])}_W(n)})}addWeight(t,e,n,i,r,s,o){if(-1!==this._addedWeightNames.indexOf(t))throw new RV(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(i=hW("zeros"));const a=i.apply(e,n),l=new xW(a,n,t,s,o);return a.dispose(),null!=r&&this.addLoss(()=>r.apply(l.read())),null==s&&(s=!0),s?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=FV(t),null!=this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(t=>{if(null!=t)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}addInboundNode(t,e,n,i,r,s,o=null){const a=FV(t);e=FV(e),n=FV(n),i=FV(i),r=yW(r),s=yW(s);const l=[],c=[],u=[];for(const h of a)l.push(h.sourceLayer),c.push(h.nodeIndex),u.push(h.tensorIndex);new IW({outboundLayer:this,inboundLayers:l,nodeIndices:c,tensorIndices:u,inputTensors:a,outputTensors:e,inputMasks:n,outputMasks:i,inputShapes:r,outputShapes:s},o);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function kW(t,e,n){if((null==e||null!=n&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),0===e.inboundNodes.length)return[t];{const t=e.inboundNodes[n];if(0===t.inboundLayers.length)return t.inputTensors;{const e=[];for(let n=0;n<t.inboundLayers.length;n++){const i=kW(t.inputTensors[n],t.inboundLayers[n],t.nodeIndices[n]);for(const t of i)-1===e.indexOf(t)&&e.push(t)}return e}}}class RW extends MW{constructor(t){if(super({dtype:t.dtype,name:null!=t.name?t.name:mW("input").toString()}),null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new RV("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(null==e){if(null==t.inputShape)throw new RV("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new RV("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];const i=new EW(this.dtype,this.batchInputShape,this,[],{},this.name);i.nodeIndex=0,i.tensorIndex=0,new IW({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[i],outputTensors:[i],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new RV(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}async function NW(t){if(null==t)return;const e=[],n=[],i=[];for(const r in t){const s=t[r];if("number"!=typeof s){const t=s;e.push(t.data()),n.push(r),i.push(t)}}if(e.length>0){const r=await Promise.all(e);for(let e=0;e<r.length;++e)t[n[e]]=r[e][0];SO(i)}}function LW(t){if(null!=t)for(const e in t){const n=t[e];"number"!=typeof n&&n.dispose()}}var DW;RW.className="InputLayer",c.registerClass(RW),function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"}(DW||(DW={}));class BW{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class OW{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochBegin(t,e)}async onEpochEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochEnd(t,e)}async onBatchBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchBegin(t,e)}async onBatchEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchEnd(t,e)}async onTrainBegin(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class PW extends BW{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){null==e&&(e={});const n=null==e.size?0:e.size;this.seen+=n;for(const i in e){const t=e[i];if("number"==typeof t)this.totals.hasOwnProperty(i)||(this.totals[i]=0),this.totals[i]=this.totals[i]+t*n;else{let e;i in this.totals?e=this.totals[i]:this.totals[i]=0;const r=_O(()=>RO(this.totals[i],FP(t,n)));this.totals[i]=r,null!=e&&e.dispose()}}}async onEpochEnd(t,e){if(null!=e)for(const n of this.params.metrics)null!=this.totals[n]&&("number"==typeof this.totals[n]?e[n]=this.totals[n]/this.seen:_O(()=>{const t=FP(gP(1,this.seen),this.totals[n]);e[n]=t,this.totals[n].dispose(),EO(e[n])}))}}class FW extends BW{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){null==e&&(e={}),this.epoch.push(t);for(const n in e)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(e[n])}async syncData(){const t=[],e=[],n=[];for(const r in this.history){const i=this.history[r];for(let s=0;s<i.length;++s)"number"!=typeof i[s]&&(t.push(i[s].data()),e.push(r),n.push(s))}const i=await Promise.all(t);for(let r=0;r<i.length;++r)this.history[e[r]][n[r]].dispose(),this.history[e[r]][n[r]]=i[r][0]}}class $W extends BW{constructor(t,e){if(super(),this.currentEpoch=0,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");i.isNumber(this.yieldEvery)&&(this.maybeWait=function(t,e){let n,r=i.now();return(...s)=>{const o=i.now();return o-r<e||(r=o,n=t(...s)),n}}(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,n){const i=[];null!=this.yield&&(await NW(n),i.push(this.yield(t,e,n))),i.push(rz()),await Promise.all(i)}async onEpochBegin(t,e){this.currentEpoch=t,null!=this.epochBegin&&(await NW(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const n=[];null!=this.epochEnd&&(await NW(e),n.push(this.epochEnd(t,e))),"epoch"===this.yieldEvery&&n.push(rz()),await Promise.all(n)}async onBatchBegin(t,e){null!=this.batchBegin&&(await NW(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const n=[];null!=this.batchEnd&&(await NW(e),n.push(this.batchEnd(t,e))),"batch"===this.yieldEvery?n.push(rz()):i.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(n)}async onTrainBegin(t){null!=this.trainBegin&&(await NW(t),await this.trainBegin(t))}async onTrainEnd(t){null!=this.trainEnd&&(await NW(t),await this.trainEnd(t))}}function zW(t,e){return null==t&&(t={}),t instanceof BW?[t]:Array.isArray(t)&&t[0]instanceof BW?t:FV(t).map(t=>new $W(t,e))}class UW{constructor(){}static registerCallbackConstructor(t,e){i.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),UW.checkForDuplicate(e),null==UW.constructors[t]&&(UW.constructors[t]=[]),UW.constructors[t].push(e)}static checkForDuplicate(t){for(const e in UW.constructors)UW.constructors[+e].forEach(e=>{if(e===t)throw new RV("Duplicate callback constructor.")})}static clear(){UW.constructors={}}static createCallbacks(t){const e=[];for(const n in UW.constructors){const i=+n;t>=i&&e.push(...UW.constructors[i])}return e.map(t=>new t)}}function HW(t,e,n,i,r,s,o,a,l){const c=new FW,u=[new PW,...UW.createCallbacks(e)];null!=t&&u.push(...t),u.push(c);const h=new OW(u);return h.setParams({epochs:n,initialEpoch:i,samples:r,steps:s,batchSize:o,verbose:e,doValidation:a,metrics:l}),{callbackList:h,history:c}}function VW(t,e={},n=!1){return GV(t,c.SerializationMap.getMap().classNameMap,e,"layer",n)}function GW(t,e){return _O(()=>{"float32"!==t.dtype&&(t=NB(t,"float32"));const n=zP($G(t),e,!0),i=TP(n.shape,TV()),r=RF(WP(n,i));return gP(t,r)})}function WW(t,e){return _O(()=>jP($G($P(e,t)),-1))}function jW(t,e){return _O(()=>jP(kO($P(e,t)),-1))}function QW(t,e){return _O(()=>{const n=$P(t,e),i=eP(kO(t),TV(),Number.MAX_VALUE),r=kO(gP(n,i));return FP(100,jP(r,-1))})}function qW(t,e,n=!1){return _O(()=>{if(n)e=TF(e);else{const t=zP(e,e.shape.length-1,!0);e=gP(e,t)}return e=eP(e,TV(),1-TV()),rF(zP(FP(NB(t,"float32"),BP(e)),e.shape.length-1))})}function XW(t,e,n=!1){return _O(()=>{const i=NB(MP(function(t){const e=[SG(t.shape)];return qO(t,e)}(t)),"int32"),r=(e=eP(e,TV(),1-TV())).shape;return qW(qO(oF(i,r[r.length-1]),r),e,n)})}function YW(t,e){return _O(()=>{let n;return n=eP(e,TV(),1-TV()),n=BP(gP(n,$P(1,n))),jP(function(t,e){if(!i.arraysEqual(t.shape,e.shape))throw new RV(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(e.shape)}`);return _O(()=>{const n=vF(e),i=rF(kO(e));return RO($P(n,FP(e,t)),OP(SP(i)))})}(t,n),-1)})}function KW(t,e){return _O(()=>{const n=GW(t,-1),i=GW(e,-1),r=FP(n,i);return rF(zP(r,-1))})}UW.constructors={};const JW={meanSquaredError:WW,meanAbsoluteError:jW,meanAbsolutePercentageError:QW,meanSquaredLogarithmicError:function(t,e){return _O(()=>{const n=eP(e,TV(),Number.MAX_VALUE),i=BP(RO(1,n)),r=eP(t,TV(),Number.MAX_VALUE),s=BP(RO(1,r));return jP($G($P(i,s)),-1)})},squaredHinge:function(t,e){return _O(()=>{const n=WP(0,$P(1,FP(t,e)));return jP($G(n),-1)})},hinge:function(t,e){return _O(()=>{const n=WP(0,$P(1,FP(t,e)));return jP(n,-1)})},categoricalHinge:function(t,e){return _O(()=>{const n=zP(FP(t,e),-1),i=PP(FP($P(1,t),e),-1);return WP(0,RO(1,$P(i,n)))})},logcosh:function(t,e){return _O(()=>{const n=Math.log(2),i=$P(e,t),r=$P(RO(i,MF(FP(-2,i))),n);return jP(r,-1)})},categoricalCrossentropy:qW,sparseCategoricalCrossentropy:XW,binaryCrossentropy:YW,kullbackLeiblerDivergence:function(t,e){return _O(()=>{const n=eP(t,TV(),1),i=eP(e,TV(),1);return zP(FP(t,BP(gP(n,i))),-1)})},poisson:function(t,e){return _O(()=>{const n=BP(RO(TV(),e));return jP($P(e,FP(t,n)),-1)})},cosineProximity:KW};function ZW(t){if("string"==typeof t){if(t in JW)return JW[t];let e=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new RV(e)}return t}function tj(t,e){return _O(()=>{const n=FP(.5,cF(e)),i=TG(RP(e,n),t.dtype);return jP(_P(t,i),-1)})}function ej(t,e){return _O(()=>TG(_P(DO(t,-1),DO(e,-1)),"float32"))}function nj(t,e){return YW(t,e)}function ij(t,e){return t.rank===e.rank&&(t=NF(t,[t.rank-1])),(e=DO(e,-1)).dtype!==t.dtype&&(e=NB(e,t.dtype)),NB(_P(t,e),"float32")}const rj=qW,sj=XW,oj={binaryAccuracy:tj,categoricalAccuracy:ej,precision:function(t,e){return _O(()=>{const n=function(t,e){return _O(()=>NB(zP(HP(_P(t,1),_P(e,1))),"float32"))}(t,e),i=function(t,e){return _O(()=>NB(zP(HP(_P(t,0),_P(e,1))),"float32"))}(t,e),r=RO(n,i);return NB(zF(RP(r,0),gP(n,r),0),"float32")})},categoricalCrossentropy:rj,sparseCategoricalCrossentropy:sj,mse:WW,MSE:WW,mae:jW,MAE:jW,mape:QW,MAPE:QW,cosine:KW};function aj(t){if("string"==typeof t&&t in oj)return oj[t];if("string"!=typeof t&&null!=t)return t;throw new RV(`Unknown metric ${t}`)}function lj(t){if(BV(null!==t,`Unknown LossOrMetricFn ${t}`),"string"==typeof t)return t;{let e;for(const n of Object.keys(JW))if(JW[n]===t){e=n;break}if(void 0!==e)return e;for(const n of Object.keys(oj))if(oj[n]===t){e=n;break}return void 0!==e?e:t.name}}function cj(t,e,n=!1){if(null==t||"object"!=typeof t||Object.getPrototypeOf(t)!==Object.prototype||!uj(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(t);n.length>1048576&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function uj(t){if(null===t)return!0;if("object"==typeof t){if(Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);for(const n of e){if("string"!=typeof n)return!1;if(!uj(t[n]))return!1}return!0}if(Array.isArray(t)){for(const e of t)if(!uj(e))return!1;return!0}return!1}{const e=typeof t;return"string"===e||"number"===e||"boolean"===e}}function hj(t,e,n=console.log){let i="";for(let r=0;r<t.length;++r)r>0&&(i=i.slice(0,i.length-1)+" "),i+=t[r],i=i.slice(0,e[r]),i+=" ".repeat(e[r]-i.length);n(i)}function dj(t,e,n){let i;try{i=JSON.stringify(t.outputShape)}catch(WTt){i="multiple"}hj([`${t.name} (${t.getClassName()})`,i,t.countParams().toString()],e,n)}function pj(t,e,n,i){let r;try{r=JSON.stringify(t.outputShape)}catch(WTt){r="multiple"}const s=[];for(const c of t.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(c)))for(let t=0;t<c.inboundLayers.length;++t)s.push(`${c.inboundLayers[t].name}[${c.nodeIndices[t]}][${c.tensorIndices[t]}]`);const o=t.name,a=t.getClassName(),l=0===s.length?"":s[0];hj([`${o} (${a})`,r,t.countParams().toString(),l],e,i);for(let c=1;c<s.length;++c)hj(["","","",s[c]],e,i)}function fj(t,e,n){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===e&&"string"==typeof n}function mj(t,e){if(null===t)return null;if("string"==typeof t)return zV(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const n=[],i=t.length;for(let r=0;r<i;++r){const i=t[r];fj(e,r,i)?n.push(i):n.push(mj(i,e))}return n}{const e={};for(const n of Object.keys(t)){const i=t[n];if("name"===n&&"string"==typeof i)e[n]=i;else{const t=zV(n);e[t]=mj(i,t)}}return e}}function gj(t,e){if(null==t)return null;if("string"==typeof t)return $V(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const n=[],i=t.length;for(let r=0;r<i;++r){const i=t[r];fj(e,r,i)?n.push(i):n.push(gj(i,e))}return n}{const e={};for(const n of Object.keys(t)){const i=t[n];e[$V(n)]="name"!==n&&"className"!==n||"string"!=typeof i?gj(i,n):i}return e}}class yj{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof yj)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,n){if(null!=this.id2Value[t.id])throw new RV(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function(t,e){if(null==t.dtype||t.dtype===e.dtype)return e;try{return NB(e,t.dtype)}catch(WTt){throw new RV(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=n&&(this.id2Mask[t.id]=n),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof EW){if(null==this.id2Value[t.id])throw new RV(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new RV(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof EW){if(null==this.id2Value[t.id])throw new RV(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new RV(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&SO(this.id2Mask)}}const vj={},bj={};function Aj(t,e,n,r){const s=null!=n&&n.training,o=Array.isArray(t),a=o?t:[t],l=a.map(t=>t.name),c=[],u=e.names();for(const i of l)-1!==u.indexOf(i)?c.push(e.getValue(i)):c.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const h=l.join(",")+"|"+e.names().join(",");let d,p;if(null==vj[h]){const t=function(t,e){i.assert(null!=t&&t.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(1===t.length){const i=wj(t[0],e);n=i.sorted,r=i.recipientMap}else{const i=new Set;for(const s of t){const{sorted:t,recipientMap:o}=wj(s,e);for(const e of t)i.has(e.name)||(n.push(e),i.add(e.name));for(const e in o)null==r[e]&&(r[e]=new Set),o[e].forEach(t=>r[e].add(t))}}return{sorted:n,recipientCounts:xj(r)}}(a,e);d=t.sorted,p=t.recipientCounts,vj[h]=d,bj[h]=p}d=vj[h],p={},s||Object.assign(p,bj[h]);const f=new yj(e);for(let i=0;i<d.length;++i){if(null!=r){const t=wO().numTensors;t>r.maxNumTensors&&(r.maxNumTensors=t),t<r.minNumTensors&&(r.minNumTensors=t)}const t=d[i],o=t.sourceLayer;if(o instanceof RW)continue;const a=[],u=[],h=[];let m=!1;for(const n of t.inputs){const t=f.getValue(n),i=f.getMask(n);a.push(t),u.push(i),null!=i&&(m=!0),s||(p[n.name]--,0!==p[n.name]||e.hasKey(n)||-1!==l.indexOf(n.name)||t.isDisposed||!0===n.sourceLayer.stateful||h.push(t))}m&&((n=n||{}).mask=u[0]);const g=FV(o.apply(a,n));let y=null;o.supportsMasking&&(y=o.computeMask(a,u));const v=_j(t),b=Array.isArray(v)?v:[v];for(let e=0;e<b.length;++e){f.hasKey(b[e])||f.add(b[e],g[e],Array.isArray(y)?y[0]:y);const t=l.indexOf(b[e].name);-1!==t&&(c[t]=g[e])}s||SO(h)}return f.disposeMasks(),o?c:c[0]}function xj(t){const e={};for(const n in t)e[n]=t[n].size;return e}function wj(t,e){const n=new Set,i=[],r={};for(const a of e.names())n.add(a);const s=[],o=[];for(s.push(t);s.length>0;){const t=s[s.length-1];if(n.has(t.name)){s.pop();continue}const e=o[o.length-1]===s.length-1;if(0===t.inputs.length||e)s.pop(),i.push(t),n.add(t.name),e&&o.pop();else{o.push(s.length-1);for(const e of t.inputs)null==r[e.name]&&(r[e.name]=new Set),r[e.name].add(t.name),n.has(e.name)||s.push(e)}}return{sorted:i,recipientMap:r}}function _j(t){let e;if(1===t.sourceLayer.inboundNodes.length)e=t.sourceLayer.output;else{let n=null;for(let e=0;e<t.sourceLayer.inboundNodes.length;++e)for(const i of t.sourceLayer.inboundNodes[e].outputTensors)if(i.id===t.id){n=e;break}e=t.sourceLayer.getOutputAt(n)}return e}class Sj extends MW{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const t=this.getClassName().toLowerCase();this.name=mW(t)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(t.inputs)?t.inputs.slice():[t.inputs],this.outputs=Array.isArray(t.outputs)?t.outputs.slice():[t.outputs],jV(this.inputs).length!==this.inputs.length)throw new RV(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(t=>t.name)}`);jV(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(t=>t.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const t=y.nodeIndex,e=y.tensorIndex;this.outputLayers.push(y.sourceLayer),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(e)}for(const y of this.inputs){const t=y.sourceLayer,e=y.nodeIndex,n=y.tensorIndex;BV(0===e,"input layer has >1 nodes"),BV(0===n,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(e),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const e=this.inputLayers[y];if(!(e instanceof RW))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${y} (0-based) originates from layer type ${e.getClassName()}.`);this.inputNames.push(e.name),this.feedInputShapes.push(e.batchInputShape),this.feedInputNames.push(e.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map(t=>t.shape),this.internalOutputShapes=this.outputs.map(t=>t.shape);const e={},n={},i={},r={},s={},o=[],a=(t,e,n,i,r,l)=>{null!=i&&null!=r&&null!=l||(i=t.sourceLayer,r=t.nodeIndex,l=t.tensorIndex);const c=i.inboundNodes[r];if(-1!==n.indexOf(c))throw new kV(`The tensor ${t.name} at layer "${i.name}" is part of a cycle.`);if(-1!==e.indexOf(c))return;this.containerNodes.add(Sj.nodeKey(i,r)),i.id in s||(s[i.id]=Object.keys(s).length),-1===n.indexOf(c)&&n.push(c);const u=c.inboundLayers.length;for(let s=0;s<u;s++)a(c.inputTensors[s],e,n,c.inboundLayers[s],c.nodeIndices[s],c.tensorIndices[s]);for(e.push(c);n.indexOf(c)>=0;)n.splice(n.indexOf(c),1);o.push(c)},l=[],c=[];for(const y of this.outputs)a(y,l,c);const u=o.slice().reverse();for(const y of u){n[y.id]=y,y.id in e||(e[y.id]=0);let t=e[y.id];t=Math.max(t,null==i[y.outboundLayer.id]?0:i[y.outboundLayer.id]),i[y.outboundLayer.id]=t,r[y.outboundLayer.id]=y.outboundLayer,e[y.id]=t;for(let i=0;i<y.inboundLayers.length;i++){const r=y.inboundLayers[i].inboundNodes[y.nodeIndices[i]];e[r.id]=Math.max(t+1,null==e[r.id]?0:e[r.id]),n[r.id]=r}}const h={};for(const y in e){const t=e[y];t in h||(h[t]=[]),h[t].push(n[y])}const d={};for(const y in i){const t=i[y];t in d||(d[t]=[]),d[t].push(r[y])}let p=Object.keys(d).map(t=>parseInt(t,10)).sort(WV);this.layers=[];for(const y of p){const t=d[y];t.sort((t,e)=>{const n=s[t.id],i=s[e.id];return n<i?-1:n>i?1:0});for(const e of t)e instanceof Sj&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=d,p=Object.keys(h).map(t=>parseInt(t,10)).sort(WV);const f=this.inputs.slice(),m=[];for(const y of p)for(const t of h[y]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===f.indexOf(n))throw new kV(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${m}`);for(const e of t.outputTensors)f.push(e);m.push(e.name)}}this.nodesByDepth=h;const g=this.layers.map(t=>t.name);for(const y of g){const t=g.filter(t=>t===y).length;if(1!==t)throw new kV(`The name "${y}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new IW({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(t=>null),outputMasks:this.outputs.map(t=>null),inputShapes:this.inputs.map(t=>t.shape),outputShapes:this.outputs.map(t=>t.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(e=>e.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new RV("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.layers)e.push(...t.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const n={};let i=0;for(const s of this.layers)for(const t of s.weights){if(null!=n[t.originalName])throw new RV(`Duplicate weight name: ${t.originalName}`);n[t.originalName]=t,i++}const r=[];for(const s in t){let i=s;if(null==n[s]){const t=s.split("/");i=t.slice(0,-2).concat([t[t.length-1]]).join("/")}if(null!=n[i])r.push([n[i],t[s]]);else if(e)throw new RV(`Provided weight data has no target variable: ${s}`);delete n[i]}if(e){const t=[];for(const e in n)t.push(e);if(t.length>0)throw new RV(`${t.length} of ${i} weights are not set: ${t}`)}_W(r)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers 3.8.0",e.backend="TensorFlow.js",e}toJSON(t,e=!0){const n=gj(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return _O(()=>{t=FV(t);const n=new yj;for(let e=0;e<this.inputs.length;++e)n.add(this.inputs[e],t[e]);return Aj(this.outputs,n,e)})}computeMask(t,e){return _O(()=>{let n;return t=FV(t),n=null==e?DV(null,t.length):FV(e),this.runInternalGraph(t,n)[1]})}computeOutputShape(t){const e=yW(t);if(e.length!==this.inputLayers.length)throw new RV(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let o=0;o<e.length;o++)n[this.inputLayers[o].name+"_0_0"]=e[o];const i=Object.keys(this.nodesByDepth).map(t=>parseInt(t,10)).sort(WV);if(i.length>1)for(const o of i){const t=this.nodesByDepth[o];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map(t=>t.id).indexOf(t.id))continue;const i=[];for(let o=0;o<e.inboundLayers.length;o++)i.push(n[`${e.inboundLayers[o].name}_${e.nodeIndices[o]}_${e.tensorIndices[o]}`]);const r=yW(t.computeOutputShape(PV(i))),s=t.inboundNodes.indexOf(e);for(let e=0;e<r.length;e++)n[`${t.name}_${s}_${e}`]=r[e]}}const r=[],s=[];for(let o=0;o<this.outputLayers.length;o++)s.push(`${this.outputLayers[o].name}_${this.outputLayersNodeIndices[o]}_${this.outputLayersTensorIndices[o]}`);for(let o=0;o<s.length;o++){const t=s[o];BV(t in n),r.push(n[t])}return PV(r)}runInternalGraph(t,e){null==e&&(e=DV(null,t.length));const n={};for(let a=0;a<this.inputs.length;++a)n[this.inputs[a].id]=[t[a],e[a]];const i=Object.keys(this.nodesByDepth).map(t=>parseInt(t,10)).sort(WV);for(const a of i){const t=this.nodesByDepth[a];for(const e of t){const t=e.outboundLayer,i=e.inputTensors,r=e.outputTensors,s=new Array;for(const e of i)e.id in n&&s.push(n[e.id]);if(s.length===i.length){let i,o,a,l,c={};if(null!=e.callArgs&&(c=e.callArgs),1===s.length){const[e,n]=s[0];null==c.mask&&(c.mask=n),a=FV(t.call(e,c)),l=FV(t.computeMask(e,n)),i=[e],o=[n]}else i=s.map(t=>t[0]),o=s.map(t=>t[1]),null==c.mask&&(c.mask=o),a=FV(t.call(i,c)),l=FV(t.computeMask(i,o));if(t.activityRegularizer)throw new NV("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let t=0;t<r.length;++t)n[r[t].id]=[a[t],l[t]]}}}const r=[],s=[],o=[];for(const a of this.outputs){BV(a.id in n,`Could not compute output ${a.name} : ${a.id}`);const[t,e]=n[a.id];o.push(t.shape),r.push(t),s.push(e)}return[r,s,o]}buildNodeConversionMap(t){const e={};let n;for(const i of this.layers){n=i instanceof Sj?1:0;for(let t=0;t<i.inboundNodes.length;t++){const r=Sj.nodeKey(i,t);this.containerNodes.has(r)&&(e[r]=n,n+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new RV(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==t)throw new RV("Provide either a layer name or layer index");for(const n of this.layers)if(n.name===t)return n;throw new RV(`No such layer: ${t}`)}calculateLosses(){return _O(()=>{const t=[];for(const e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){const i=Sj.nodeKey(e,n);this.containerNodes.has(i)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(const s of this.layers){const t=s.getClassName(),i=s.getConfig(),r=[];for(let n=0;n<s.inboundNodes.length;n++){const t=s.inboundNodes[n],i=Sj.nodeKey(s,n);let o={};if(this.containerNodes.has(i)){if(t.callArgs)try{JSON.stringify(t.callArgs),o=t.callArgs}catch(WTt){console.warn(`Layer ${s.name} was passed non-serializable keyword arguments: ${t.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),o={}}if(t.inboundLayers.length>0){const n=[];for(let i=0;i<t.inboundLayers.length;i++){const r=t.inboundLayers[i],s=t.tensorIndices[i];let a=e[Sj.nodeKey(r,t.nodeIndices[i])];null==a&&(a=0),n.push([r.name,a,s,o])}r.push(n)}}}const o={};o.name=s.name,o.className=t,o.config=i,o.inboundNodes=r,n.push(o)}t.layers=n;const i=[];for(let s=0;s<this.inputLayers.length;s++){const t=this.inputLayers[s],n=Sj.nodeKey(t,this.inputLayersNodeIndices[s]);if(!this.containerNodes.has(n))continue;let r=e[n];null==r&&(r=0),i.push([t.name,r,this.inputLayersTensorIndices[s]])}t.inputLayers=i;const r=[];for(let s=0;s<this.outputLayers.length;s++){const t=this.outputLayers[s],n=Sj.nodeKey(t,this.outputLayersNodeIndices[s]);if(!this.containerNodes.has(n))continue;let i=e[n];null==i&&(i=0),r.push([t.name,i,this.outputLayersTensorIndices[s]])}return t.outputLayers=r,t}static fromConfig(t,e,n={},i=!1){const r={},s={};function o(t,e){t.name in s?s[t.name].push(e):s[t.name]=[e]}function a(t,e){const n=[];let i;for(const s of e){const a=s[0],l=s[1],c=s[2];if(i=null==s[3]?{}:s[3],!(a in r))return void o(t,e);const u=r[a];if(u.inboundNodes.length<=l)return void o(t,e);n.push(u.inboundNodes[l].outputTensors[c])}n.length>0&&t.apply(PV(n),i)}function l(t){const n=t.name,s=VW(t,null!=e.customObjects?e.customObjects:{});s.setFastWeightInitDuringBuild(i),r[n]=s,t.inboundNodes.forEach(t=>{if(!(t instanceof Array))throw new RV(`Corrupted configuration, expected array for nodeData: ${t}`);o(s,t)})}const c=e.name,u=e.layers;for(const m of u)l(m);for(;!QV(s);)for(const t of u){const e=r[t.name];if(e.name in s){const t=s[e.name];delete s[e.name];for(const n of t)a(e,n)}}const h=[],d=[],p=e.inputLayers;for(const m of p){const t=m[0],e=m[1],n=m[2];BV(t in r),h.push(r[t].inboundNodes[e].outputTensors[n])}const f=e.outputLayers;for(const m of f){const t=m[0],e=m[1],n=m[2];BV(t in r),d.push(r[t].inboundNodes[e].outputTensors[n])}return new t({inputs:h,outputs:d,name:c})}get stateful(){if(this._stateful)throw new RV("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){_O(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function Ej(t,e){return function(t,e,n){const i=e.length;if(null==t||Array.isArray(t)&&0===t.length)return e.map(t=>null);if(1===i)return Array.isArray(t)&&1===t.length?t:"object"==typeof t&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==i)throw new Error(`Provided classWeight is an array of ${t.length} element(s), but the model has ${i} outputs. Make sure a set of weights is provided for each model output.`);return t}if("object"==typeof t&&Object.keys(t).length>0&&"object"==typeof t[Object.keys(t)[0]]){const n=[];return e.forEach(e=>{n.push(e in t?t[e]:null)}),n}throw new Error(`The model has multiple (${i}) outputs, so classWeight must be either an array with ${i} elements or an object with ${e} keys. Provided classWeight not understood: ${JSON.stringify(t)}`)}(t,e)}async function Cj(t,e,n,i){if(null!=e||null!=i)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const e=_O(()=>{if(1===t.shape.length)return LB(t);if(2===t.shape.length){if(t.shape[1]>1)return DO(t,1);if(1===t.shape[1])return qO(t,[t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await e.data());SO(e);const r=[];return i.forEach(t=>{if(null==n[t])throw new Error(`classWeight must contain all classes in the training data. The class ${t} exists in the data but not in classWeight`);r.push(n[t])}),BF(r,"float32")}return null}function Ij(t,e){return FP(t,e)}function Tj(t,e){let n,r;n=e.xs,r=e.ys,i.assert(null!=n&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const s=Mj("input",t.inputNames,n),o=Mj("output",t.outputNames,r),a=s[0].shape[0];i.assert(s.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`),i.assert(o.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`);for(let l=0;l<s.length;l++)i.assert(s[l].shape[0]===a,()=>`Batch size mismatch: input ${t.inputNames[l]} has ${s[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);for(let l=0;l<o.length;l++)i.assert(o[l].shape[0]===a,()=>`Batch size mismatch: output ${t.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);return{xs:s,ys:o}}function Mj(t,e,n){if(n instanceof iD)return[n];if(Array.isArray(n))return i.assert(n.length===e.length,()=>`Received an array of ${n.length} Tensors, but expected ${e.length} to match the ${t} keys ${e}.`),n;{const i=[];for(const r of e){if(null==n[r])throw new RV(`The feature data generated by the dataset lacks the required ${t} key '${r}'.`);i.push(n[r])}return i}}function kj(t){return"function"==typeof t.iterator}function Rj(t){i.assert(t>0&&Number.isInteger(t),()=>`batchSize is required to be a positive integer, but got ${t}`)}function Nj(t,e,n){return null==t?[null]:Array.isArray(t)?t.map(t=>kG(t,e,n-e)):kG(t,e,n-e)}function Lj(t,e){return _O(()=>null==t?null:Array.isArray(t)?t.map(t=>Lj(t,e)):FG(t,"int32"===e.dtype?e:NB(e,"int32")))}function Dj(t,e){const n=[];let i=0,r=null;for(;i<t;)r=i+e,r>=t&&(r=t),n.push([i,r]),i=r;return n}function Bj(t){const e=[];t instanceof iD&&(t=[t]);for(let n=0;n<t.length;++n){const i=t[n];if(1===i.rank)e.push(MG(i,1));else{if(0===i.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(i)}}return e}function Oj(t,e){if(null==t)return;const n=[];if(e instanceof iD)n.push(e.id);else if(Array.isArray(e))e.forEach(t=>n.push(t.id));else if(null!=e)for(const r in e)n.push(e[r].id);const i=[];if(t instanceof iD)-1===n.indexOf(t.id)&&i.push(t);else if(Array.isArray(t))t.forEach(t=>{-1===n.indexOf(t.id)&&i.push(t)});else if(null!=t)for(const r in t){const e=t[r];-1===n.indexOf(e.id)&&i.push(e)}i.forEach(t=>{t.isDisposed||t.dispose()})}function Pj(t){return Array.isArray(t)}function Fj(t){return!function(t){return t instanceof iD}(t)&&!Pj(t)}function $j(t,e,n,i=!0,r=""){if(null==e||0===e.length){if(null!=t){let e=!1;if(Pj(t)&&t.length>0)e=!0;else if(Fj(t)){for(const n in t)if(t.hasOwnProperty(n)){e=!0;break}}else e=!0;if(e)throw new RV(`Error when checking model ${r} expected no data, but got ${t}`)}return[]}if(null==t)return e.map(t=>null);let s;if(Fj(t)){t=t,s=[];for(const n of e){if(null==t[n])throw new RV(`No data provided for "${n}". Need data for each key in: ${e}`);s.push(t[n])}}else if(Pj(t)){if((t=t).length!==e.length)throw new RV(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);s=t}else{if(t=t,e.length>1)throw new RV(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);s=[t]}if(s=Bj(s),null!=n)for(let o=0;o<e.length;++o){if(null==n[o])continue;const t=s[o];if(t.shape.length!==n[o].length)throw new RV(`Error when checking ${r}: expected ${e[o]} to have ${n[o].length} dimension(s). but got array with shape ${t.shape}`);for(let s=0;s<n[o].length;++s){if(0===s&&!i)continue;const a=t.shape[s],l=n[o][s];if(null!=l&&l>=0&&a!==l)throw new RV(`Error when checking ${r}: expected ${e[o]} to have shape [${n[o]}], but got array with shape [${t.shape}].`)}}return s}function zj(t,e,n,i=!0,r=""){let s;if(Array.isArray(t)){if(t.length!==e.length)throw new RV(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${t.length} Tensors(s).`);s=t}else{if(e.length>1)throw new RV(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);s=[t]}if(null!=n)for(let o=0;o<e.length;++o){if(null==n[o])continue;const t=s[o];if(t.shape.length!==n[o].length)throw new RV(`Error when checking ${r}: expected ${e[o]} to have ${n[o].length} dimension(s), but got array with shape ${JSON.stringify(t.shape)}`);for(let s=0;s<n[o].length;++s){if(0===s&&!i)continue;const a=t.shape[s],l=n[o][s];if(null!=l&&l!==a)throw new RV(`Error when checking ${r}: expected ${e[o]} to have shape ${JSON.stringify(n[o])} but got array with shape ${JSON.stringify(t.shape)}.`)}}}class Uj extends Sj{constructor(t){super(t),this.isTraining=!1}summary(t,e,n=console.log){if(!this.built)throw new RV("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(t,e,n,i=console.log){const r=function(t){let e=!0;const n=[],i=[];for(const r in t.nodesByDepth)n.push(t.nodesByDepth[r]);for(const r of n){if(r.length>1||1===r.length&&r[0].inboundLayers.length>1){e=!1;break}i.push(...r)}if(e)for(const r of t.layers){let t=!1;for(const n of r.inboundNodes)if(-1!==i.indexOf(n)){if(t){e=!1;break}t=!0}if(!e)break}return e}(t),s=["Layer (type)","Output shape","Param #"];let o;if(r?(e=e||65,n=n||[.45,.85,1]):(e=e||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map(t=>Math.floor(e*t))),!r){s.push("Receives inputs"),o=[];for(const e in t.nodesByDepth)o.push(...t.nodesByDepth[e])}i("_".repeat(e)),hj(s,n,i),i("=".repeat(e));const a=t.layers;for(let u=0;u<a.length;++u)r?dj(a[u],n,i):pj(a[u],n,o,i),i((u===a.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const l=function(t){let e;return e=AW(null!=t.collectedTrainableWeights?t.collectedTrainableWeights:t.trainableWeights),e}(t),c=AW(t.nonTrainableWeights);i(`Total params: ${l+c}`),i(`Trainable params: ${l}`),i(`Non-trainable params: ${c}`),i("_".repeat(e))}(this,t,e,n)}compile(t){if(null==t.loss&&(t.loss=[]),this.loss=t.loss,"string"==typeof t.optimizer)this.optimizer_=function(t){const e={Adagrad:()=>nz.adagrad(.01),Adadelta:()=>nz.adadelta(1,.95,TV()),Adam:()=>nz.adam(.001,.9,.999,TV()),Adamax:()=>nz.adamax(.002,.9,.999,TV(),0),RMSProp:()=>nz.rmsprop(.001,.9,0,TV()),SGD:()=>nz.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new RV(`Unknown Optimizer ${t}`)}(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof MO))throw new RV("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(Array.isArray(t.loss)||"string"==typeof t.loss||"function"==typeof t.loss)if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new RV(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(t=>ZW(t))}else{const n=ZW(t.loss);this.outputs.forEach(t=>{e.push(n)})}else{t.loss=t.loss;for(const e in t.loss)if(-1===this.outputNames.indexOf(e))throw new RV(`Unknown entry in loss dictionary: "${e}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==t.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),e.push(ZW(t.loss[n]))}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){const t=this.internalOutputShapes[s];this.feedOutputNames.push(this.outputNames[s]),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[s])}const n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],bG("loss",()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;const e=this.lossFunctions[t];this.outputs.length>1&&(this.metricsTensors.push([e,t]),this.metricsNames.push(this.outputNames[t]+"_loss"))}});const i=function(t,e){if(null==t||Array.isArray(t)&&0===t.length)return e.map(t=>[]);let n;if("string"==typeof t||"function"==typeof t)n=[t];else{if(!Array.isArray(t)&&"object"!=typeof t)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);n=t}if(Array.isArray(n))return e.map(t=>n);{const t=[];for(const i of e){let e=n.hasOwnProperty(i)?n[i]:[];Array.isArray(e)||(e=[e]),t.push(e)}return t}}(t.metrics,this.outputNames),r=(t,e,n)=>{this.outputNames.length>1&&(e=this.outputNames[t]+"_"+e),this.metricsNames.push(e),this.metricsTensors.push([n,t])};bG("metric",()=>{for(let t=0;t<this.outputs.length;++t)-1===n.indexOf(t)&&(e=>{let n,i,s;for(const o of e){if("string"==typeof o&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(o)){const e=this.internalOutputShapes[t];let r;1===e[e.length-1]||this.lossFunctions[t]===YW?-1!==["accuracy","acc"].indexOf(o)?i=tj:-1!==["crossentropy","ce"].indexOf(o)&&(i=nj):this.lossFunctions[t]===XW?-1!==["accuracy","acc"].indexOf(o)?i=ij:-1!==["crossentropy","ce"].indexOf(o)&&(i=sj):-1!==["accuracy","acc"].indexOf(o)?i=ej:-1!==["crossentropy","ce"].indexOf(o)&&(i=rj),-1!==["accuracy","acc"].indexOf(o)?r="acc":-1!==["crossentropy","ce"].indexOf(o)&&(r="ce"),s=i,n=""+r}else{const t=aj(o);s=t,n=""+lj(o)}let e;bG(n,()=>{e=s}),r(t,n,e)}})(i[t])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,n={}){const i=null==n.batchSize?32:n.batchSize;Rj(i);const r=this.standardizeUserDataXY(t,e,!0,i);try{const s=r[0].concat(r[1]);return this.makeTestFunction(),PV(this.testLoop(this.testFunction,s,i,n.verbose,n.steps))}finally{Oj(r[0],t),Oj(r[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),async function(t,e,n){const r=null!=(n=n||{}).batches,s=t.testFunction;let o=[];if(n.verbose>0)throw new NV("Verbose mode is not implemented yet.");i.assert(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const a="function"==typeof e.next?e:await e.iterator();let l=0,c=0;for(;!r||c<n.batches;){const e=await a.next();if(o=_O(()=>{if(e.value){const{xs:n,ys:i}=Tj(t,e.value),r=n.concat(i),a=_O(()=>s(r));if(SO(r),0===c)for(let t=0;t<a.length;++t)o.push(TO(0));const u=r[0].shape[0];for(let t=0;t<a.length;++t){const e=a[t],n=o[t];o[t]=_O(()=>RO(o[t],FP(u,e))),c>0&&SO(n)}SO(a),l+=u,++c}return o}),e.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let i=0;i<o.length;++i){const t=o[i];o[i]=gP(o[i],l),SO(t)}return PV(o)}(this,t,e)}checkNumSamples(t,e,n,i="steps"){let r;if(null!=n){if(r=null,null!=e)throw new RV(`If ${i} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else{if(null==t)throw new RV(`Either the input data should have a defined shape, or ${i} shoud be specified.`);r=Array.isArray(t)?t[0].shape[0]:t.shape[0]}return r}execute(t,e){if(Array.isArray(e)&&0===e.length)throw new RV("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(e),i=this.retrieveSymbolicTensors(n?e:[e]),r=new yj;if(t instanceof iD&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new RV(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let e=0;e<this.inputs.length;++e)r.add(this.inputs[e],t[e])}else for(const o of this.inputs){const e=t[o.name];if(null==e)throw new RV(`No value is provided for the model's input ${o.name}`);r.add(o,e)}const s=Aj(i,r);return n?s:s[0]}retrieveSymbolicTensors(t){const e=DV(null,t.length);let n=t.length;for(const i of this.layers){const r=Array.isArray(i.output)?i.output:[i.output],s=r.map(t=>t.name);for(let i=0;i<t.length;++i){const o=s.indexOf(t[i]);if(-1!==o&&(e[i]=r[o],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw e.forEach((e,i)=>{null==e&&n.push(t[i])}),new RV(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return e}predictLoop(t,e=32,n=!1){return _O(()=>{const i=this.checkNumSamples(t);if(n)throw new NV("Verbose predictLoop() is not implemented yet.");const r=Dj(i,e),s=this.outputs.map(t=>[]);for(let e=0;e<r.length;++e)_O(()=>{const n=Nj(t,r[e][0],r[e][1]),i=[];if(Array.isArray(n))for(let t=0;t<n.length;++t)i.push({key:this.inputs[t],value:n[t]});else i.push({key:this.inputs[0],value:n});const s=new yj(i);return Aj(this.outputs,s)}).forEach((t,e)=>s[e].push(t));return PV(s.map(t=>nP(t,0)))})}predict(t,e={}){const n=Bj(t);zj(n,this.inputNames,this.feedInputShapes,!1);try{const i=null==e.batchSize?32:e.batchSize;return Rj(i),this.predictLoop(n,i)}finally{Oj(n,t)}}predictOnBatch(t){zj(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,n=!0,r){if(null==this.optimizer_)throw new kV("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const s=[];for(let i=0;i<this.feedOutputShapes.length;++i){const t=this.feedOutputShapes[i];s.push(this.feedLossFns[i]===XW?t.slice(0,t.length-1).concat([1]):t)}if(function(t,e,n){const r=jV(t.map(t=>t.shape[0]));r.sort();const s=jV(e.map(t=>t.shape[0]));if(s.sort(),r.length>1)throw new RV(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(t=>t.shape))}`);if(s.length>1)throw new RV(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(t=>t.shape))}`);if(r.length>0&&s.length>0&&!i.arraysEqual(r,s))throw new RV(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}(t=$j(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=$j(e,this.feedOutputNames,s,!1,"target")),function(t,e,n){const i=[WW,YW,qW];for(let r=0;r<t.length;++r){const s=t[r],o=e[r],a=n[r];if(null!=o){if(o===qW&&1===s.shape[s.shape.length-1])throw new RV(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==i.indexOf(o)){const t=s.shape.slice(1),e=a.slice(1);for(let n=0;n<t.length;++n){const i=t[n],r=e[n];if(null!=r&&i!==r)throw new RV(`A target Tensor with shape ${s.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&t[0].shape[0]%r!=0)throw new RV(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,n,i,r=!0,s){const[o,a]=this.standardizeUserDataXY(t,e,r,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=i){const t=Ej(i,this.outputNames);l=[];for(let e=0;e<t.length;++e)l.push(await Cj(a[e],null,t[e]))}return[o,a,l]}testLoop(t,e,n,i=0,r){return _O(()=>{const s=this.checkNumSamples(e,n,r,"steps"),o=[];if(i>0)throw new NV("Verbose mode is not implemented yet.");if(null!=r)throw new NV("steps mode in testLoop() is not implemented yet");{const i=Dj(s,n),r=BF(IG(0,s));for(let n=0;n<i.length;++n){const s=i[n][0],a=i[n][1],l=kG(r,s,a-s),c=Lj(e,l),u=t(c);if(0===n)for(let t=0;t<u.length;++t)o.push(TO(0));for(let t=0;t<u.length;++t)o[t]=RO(o[t],FP(a-s,u[t]))}for(let t=0;t<o.length;++t)o[t]=gP(o[t],s)}return o})}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){const i=t[n];let r=i;OV(t,i)>1&&(r+=`_${OV(t.slice(0,n),i)}`),e.push(r)}return e}makeTrainFunction(){return t=>{const e=[],n=t.slice(0,this.inputs.length),i=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],o=this.collectedTrainableWeights.map(t=>t.read());return[this.optimizer_.minimize(()=>{const t=[];for(let e=0;e<this.inputs.length;++e)t.push({key:this.inputs[e],value:n[e]});const o=new yj(t),a=Aj(this.outputs,o,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let t=(0,this.lossFunctions[n])(i[n],a[n]);null!=r[n]&&(t=Ij(t,r[n]));const s=jP(t);e.push(s),l=0===n?t:RO(l,t)}for(let n=0;n<this.metricsTensors.length;++n){let t;if(this.outputs.length>1&&n<this.outputs.length)t=e[n];else{const e=this.metricsTensors[n][1];t=jP((0,this.metricsTensors[n][0])(i[e],a[e]))}EO(t),s.push(t)}return l=jP(l),this.calculateLosses().forEach(t=>{l=RO(l,t)}),l},!0,o)].concat(s)}}makeTestFunction(){this.testFunction=t=>_O(()=>{const e=[];let n;const i=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let t=0;t<this.inputs.length;++t)s.push({key:this.inputs[t],value:i[t]});const o=new yj(s),a=Aj(this.outputs,o);for(let t=0;t<this.lossFunctions.length;++t){const i=jP((0,this.lossFunctions[t])(r[t],a[t]));n=0===t?i:RO(n,i),e.push(n)}for(let t=0;t<this.metricsTensors.length;++t){const n=this.metricsTensors[t][1],i=jP((0,this.metricsTensors[t][0])(r[n],a[n]));e.push(i)}return e})}async fit(t,e,n={}){return async function(t,e,n,r={}){if(t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let s,o,a,l,c,u,h;t.isTraining=!0;try{const d=null==r.batchSize?32:r.batchSize;Rj(d);const p=!1,f=await t.standardizeUserData(e,n,r.sampleWeight,r.classWeight,p,d);s=f[0],o=f[1],h=f[2];let m,g=!1;if(null!=r.validationData&&r.validationData.length>0){if(g=!0,2!==r.validationData.length)throw 3===r.validationData.length?new NV("validationData including sample weights is not supported yet."):new RV(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);a=r.validationData[0],l=r.validationData[1];const e=!0,n=await t.standardizeUserData(a,l,null,null,e,d);c=n[0],u=n[1],m=c.concat(u)}else if(null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1){g=!0;const t=Math.floor(s[0].shape[0]*(1-r.validationSplit)),e=s[0].shape[0];c=Nj(s,t,e),s=Nj(s,0,t),u=Nj(o,t,e),o=Nj(o,0,t),m=c.concat(u)}else null!=r.validationSteps&&(g=!0);const y=s.concat(o).concat(h);t.checkTrainableWeightsConsistency();const v=t.makeTrainFunction(),b=t.getDedupedMetricsNames();let A,x;g?(t.makeTestFunction(),A=t.testFunction,x=b.slice().concat(b.map(t=>"val_"+t))):(A=null,m=[],x=b.slice());const w=zW(r.callbacks,r.yieldEvery);return await async function(t,e,n,r,s,o,a,l,c,u,h,d,p,f,m){null==s&&(s=32),null==o&&(o=1),null==h&&(h=!0),null==p&&(p=0);let g=!1;null!=c&&null!=u&&(g=!0);const y=t.checkNumSamples(n,s,null,"steps_per_epoch");let v;null!=y&&(v=IG(0,y)),null==a&&(a=1);const{callbackList:b,history:A}=HW(l,a,o,p,y,null,s,g,d);b.setModel(t),t.history=A,await b.onTrainBegin(),t.stopTraining_=!1;for(let x=p;x<o;++x){await b.onEpochBegin(x);const o={};{if("batch"===h)throw new NV("batch shuffling is not implemneted yet");h&&i.shuffle(v);const a=BF(v),l=Dj(y,s);for(let i=0;i<l.length;++i){const h={};if(await b.onBatchBegin(i,h),_O(()=>{const d=l[i][0],p=l[i][1],f=kG(a,d,p-d);h.batch=i,h.size=p-d;const m=Lj(n,f),y=e(m);for(let t=0;t<r.length;++t){const e=y[t];h[r[t]]=e,EO(e)}if(i===l.length-1&&g){const e=t.testLoop(c,u,s);for(let t=0;t<r.length;++t){const n=r[t],i=e[t];EO(i),o["val_"+n]=i}}}),await b.onBatchEnd(i,h),LW(h),t.stopTraining_)break}a.dispose()}if(await b.onEpochEnd(x,o),t.stopTraining_)break}return await b.onTrainEnd(),await t.history.syncData(),t.history}(t,v,y,b,d,r.epochs,r.verbose,w,A,m,r.shuffle,x,r.initialEpoch)}finally{t.isTraining=!1,Oj(s,e),Oj(o,n),Oj(c,a),Oj(u,l),null!=h&&SO(h)}}(this,t,e,n)}async fitDataset(t,e){return async function(t,e,n){const r=null!=n.batchesPerEpoch;if(i.assert(null!=t.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),i.assert(null!=n,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),i.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),i.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),i.assert(null==n.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const s=null!=n.validationData;let o,a;if(s)if(kj(n.validationData))i.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const t=function(t){if(3===t.length)throw new NV("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}(n.validationData);o=t.xs,a=t.ys}const l=t.makeTrainFunction(),c=t.getDedupedMetricsNames();let u;u=s?c.slice().concat(c.map(t=>"val_"+t)):c.slice();const h=zW(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:p,history:f}=HW(h,d,n.epochs,null,null,function(t,e){let n=null;return null!=e.batchesPerEpoch?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size),n}(e,n),null,s,u);p.setModel(t),t.history=f,await p.onTrainBegin(),t.stopTraining_=!1;let m=null==n.initialEpoch?0:n.initialEpoch,g=await e.iterator();for(;m<n.epochs;){const i={};await p.onEpochBegin(m);let u=0,h=0;for(r||(g=await e.iterator());!r||u<n.batchesPerEpoch;){const e=await g.next();if(r&&e.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${u} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=e.value){const{xs:i,ys:r}=Tj(t,e.value),s={};s.batch=h,s.size=i[0].shape[0],await p.onBatchBegin(h,s);const o=[];if(null!=n.classWeight){const e=Ej(n.classWeight,t.outputNames);for(let t=0;t<e.length;++t)o.push(await Cj(r[t],null,e[t]))}const a=i.concat(r).concat(o),d=l(a);SO(a);for(let t=0;t<c.length;++t){const e=d[t];s[c[t]]=e,EO(e)}await p.onBatchEnd(h,s),LW(s),h++,u++}if(r?u>=n.batchesPerEpoch:e.done){if(s){let e;e=kj(n.validationData)?FV(await t.evaluateDataset(n.validationData,{batches:n.validationBatches})):FV(t.evaluate(o,a,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<t.metricsNames.length;++n)i[`val_${t.metricsNames[n]}`]=e[n]}break}if(t.stopTraining_)break}if(await p.onEpochEnd(m,i),m++,t.stopTraining_)break}return await p.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}(this,t,e)}async trainOnBatch(t,e){const n=await this.standardizeUserData(t,e),i=n[0],r=n[1],s=this.makeTrainFunction()(i.concat(r)),o=[];for(const a of s){const t=await a.data();o.push(t[0])}return SO(s),PV(o)}getNamedWeights(t){const e=[],n=null!=t&&t.trainableOnly,i=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let s=0;s<i.length;++s)n&&!i[s].trainable||e.push({name:i[s].originalName,tensor:r[s]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(0===t.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const e=wO().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-wO().numTensors}return t}getLossIdentifiers(){let t;if("string"==typeof this.loss)t=$V(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if("string"!=typeof t)throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(t=>$V(t))}else{const e=Object.keys(this.loss);t={};const n=this.loss;for(const i of e){if("string"!=typeof n[i])throw new Error("Serialization of non-string loss is not supported.");t[i]=$V(n[i])}}return t}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[$V(lj(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>$V(lj(t)));{const t={};for(const e in this.metrics)t[e]=$V(lj(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(null!=t.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=t.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=t.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const e=VW(mj(t.optimizer_config));let n,i;if("string"==typeof t.loss)n=zV(t.loss);else if(Array.isArray(t.loss))n=t.loss.map(t=>zV(t));else if(null!=t.loss){n={};for(const e in t.loss)n[e]=zV(t.loss[e])}if(Array.isArray(t.metrics))i=t.metrics.map(t=>zV(t));else if(null!=t.metrics){i={};for(const e in t.metrics)i[e]=zV(t.metrics[e])}this.compile({loss:n,metrics:i,optimizer:e})}async save(t,e){if("string"==typeof t){const e=o.getSaveHandlers(t);if(0===e.length)throw new RV(`Cannot find any save handlers for URL '${t}'`);if(e.length>1)throw new RV(`Found more than one (${e.length}) save handlers for URL '${t}'`);t=e[0]}if(null==t.save)throw new RV("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await o.encodeWeights(this.getNamedWeights(e)),i={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v3.8.0",convertedBy:null};if(null!=e&&e.includeOptimizer&&null!=this.optimizer){i.trainingConfig=this.getTrainingConfig();const t="optimizer",{data:e,specs:r}=await o.encodeWeights(await this.optimizer.getWeights(),t);n.specs.push(...r),n.data=o.concatenateArrayBuffers([n.data,e])}return null!=this.userDefinedMetadata&&(cj(this.userDefinedMetadata,this.name,!0),i.userDefinedMetadata=this.userDefinedMetadata),i.weightData=n.data,i.weightSpecs=n.specs,t.save(i)}setUserDefinedMetadata(t){cj(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}Uj.className="Model",c.registerClass(Uj);class Hj extends Uj{}Hj.className="Functional",c.registerClass(Hj);class Vj extends Uj{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=null!=t.name?t.name:mW("sequential_"),null!=t.layers)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(t=>t<0))throw new RV(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const e=t instanceof Vj||t instanceof Uj;let n;if(e){if(n=t,1!==n.outputs.length)throw new RV("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new RV("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new RV("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const e=function(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new RV("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;null!=t.shape&&null==e&&(e=[null].concat(t.shape));let n=t.dtype;return null==n&&(n="float32"),new RW({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(e)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==t.inboundNodes.length)throw new RV(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(1!==t.inboundNodes[0].outputTensors.length)throw new RV("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=kW(this.outputs[0])}this.inboundNodes=[],new IW({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:DV(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(t=>t.shape),outputShapes:this.outputs[0].shape})}else{const e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return null==this.model&&this.build(),this.model.call(t,e)}build(t){if(bW(t),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Uj({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,n=console.log){this.built||this.build(),super.summary(t,e,n)}setWeights(t){null==this.model&&this.build(),this.model.setWeights(t)}evaluate(t,e,n={}){if(!this.built)throw new kV("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)}async evaluateDataset(t,e){if(!this.built)throw new kV("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return null==this.model&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return null==this.model&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,n={}){if(!this.built)throw new kV("The model needs to be compiled before being used.");return this.model.fit(t,e,n)}async fitDataset(t,e){if(!this.built)throw new kV("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,n={},r=!1){let s,o={};if(e instanceof Array){if(null==e[0].className||"Merge"===e[0].className)throw new RV("Legacy serialization format not supported yet.");s=e}else i.assert(null!=e.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=e.layers,delete e.layers,o=e;const a=new t(o);if(!(a instanceof Vj))throw new NV(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const i of s){const t=VW(i,void 0,r);r&&t.setFastWeightInitDuringBuild(!0),a.add(t)}return a}set stopTraining(t){if(null==this.model)throw new RV("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(null==this.model)throw new RV("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const n={};n.className=e.getClassName(),n.config=e.getConfig(),t.push(n)}return{name:this.name,layers:t}}}function Gj(t,e){return null==e&&(e={}),async function(t,e){if(null==e&&(e={}),"string"==typeof t){const n=o.getLoadHandlers(t,e);if(0===n.length)n.push(o.browserHTTPRequest(t,e));else if(n.length>1)throw new RV(`Found more than one (${n.length}) load handlers for URL '${t}'`);t=n[0]}return async function(t,e,n){if(null==n&&(n={}),null==t.load)throw new RV("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const i=await t.load();let r=i.modelTopology;null!=r.model_config&&(r=r.model_config);const s=null==n.strict||n.strict,a=null!=i.weightData&&null!=i.weightSpecs&&s,l=VW(mj(r),void 0,a),c=i.trainingConfig;if(null!=c&&l.loadTrainingConfig(c),null!=i.userDefinedMetadata&&l.setUserDefinedMetadata(i.userDefinedMetadata),null!=i.weightData){if(null==i.weightSpecs)throw new RV("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:t,optimizerWeights:e}=function(t,e){const n=o.decodeWeights(t,e),i={},r=[];return e.forEach(t=>{"optimizer"===t.group?r.push({name:t.name,tensor:n[t.name]}):i[t.name]=n[t.name]}),{modelWeights:i,optimizerWeights:r}}(i.weightData,i.weightSpecs);l.loadWeights(t,s),null!=l.optimizer&&e.length>0&&await l.optimizer.setWeights(e),SO(t),SO(e.map(t=>t.tensor))}return l}(t,0,e)}(t,e)}Vj.className="Sequential",c.registerClass(Vj);class Wj extends c.Serializable{getConfig(){return{}}}class jj extends Wj{apply(t,e=1){return function(t,e=1){if(1!==e)throw new NV(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return bP(t)}(t,e)}}jj.className="elu",c.registerClass(jj);class Qj extends Wj{apply(t){return AF(t)}}Qj.className="selu",c.registerClass(Qj);class qj extends Wj{apply(t){return vF(t)}}qj.className="relu",c.registerClass(qj);class Xj extends Wj{apply(t){return _O(()=>QP(6,vF(t)))}}Xj.className="relu6",c.registerClass(Xj);class Yj extends Wj{apply(t){return t}}Yj.className="linear",c.registerClass(Yj);class Kj extends Wj{apply(t){return wF(t)}}Kj.className="sigmoid",c.registerClass(Kj);class Jj extends Wj{apply(t){return function(t){return _O(()=>{const e=RO(.5,FP(.2,t));return eP(e,0,1)})}(t)}}Jj.className="hardSigmoid",c.registerClass(Jj);class Zj extends Wj{apply(t){return MF(t)}}Zj.className="softplus",c.registerClass(Zj);class tQ extends Wj{apply(t){return function(t){return _O(()=>gP(t,RO(kO(t),1)))}(t)}}tQ.className="softsign",c.registerClass(tQ);class eQ extends Wj{apply(t){return DF(t)}}eQ.className="tanh",c.registerClass(eQ);class nQ extends Wj{apply(t,e=-1){return TF(t,e)}}nQ.className="softmax",c.registerClass(nQ);class iQ extends Wj{apply(t,e=-1){return UP(t,e)}}iQ.className="logSoftmax",c.registerClass(iQ);class rQ extends Wj{apply(t,e=1){return _O(()=>FP(wF(FP(t,e)),t))}}rQ.className="swish",c.registerClass(rQ);class sQ extends Wj{apply(t){return _O(()=>FP(t,DF(MF(t))))}}function oQ(t){return t.getClassName()}function aQ(t,e={}){return GV(t,c.SerializationMap.getMap().classNameMap,e,"activation")}function lQ(t){if(null==t)return aQ({className:"linear",config:{}});if("string"==typeof t){const e={};return e.className=t,e.config={},aQ(e)}return t instanceof Wj?t:aQ(t)}sQ.className="mish",c.registerClass(sQ);class cQ extends c.Serializable{}class uQ extends cQ{constructor(t){super(),function(t){if(null!=t&&"object"!=typeof t)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}(t),this.l1=null==t||null==t.l1?.01:t.l1,this.l2=null==t||null==t.l2?.01:t.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(t){return _O(()=>{let e=aF([1]);return this.hasL1&&(e=RO(e,zP(FP(this.l1,kO(t))))),this.hasL2&&(e=RO(e,zP(FP(this.l2,$G(t))))),qO(e,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}uQ.className="L1L2",c.registerClass(uQ);const hQ={l1l2:"L1L2"};function dQ(t){return HV(t)}function pQ(t,e={}){return GV(t,c.SerializationMap.getMap().classNameMap,e,"regularizer")}function fQ(t){return null==t?null:"string"==typeof t?pQ({className:t in hQ?hQ[t]:t,config:{}}):t instanceof cQ?t:pQ(t)}class mQ extends MW{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,null!=t&&(this.maxValue=t.maxValue)}call(t,e){t=vW(t);let n=vF(t);return null!=this.maxValue&&(n=eP(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}mQ.className="ReLU",c.registerClass(mQ);class gQ extends MW{constructor(t){super(null==t?{}:t),this.DEFAULT_ALPHA=.3,null==t&&(t={}),this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=vW(t);return DP(n,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}gQ.className="LeakyReLU",c.registerClass(gQ);class yQ extends MW{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),this.supportsMasking=!0,this.alphaInitializer=hW(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=fQ(t.alphaRegularizer),this.alphaConstraint=lG(t.alphaConstraint),null==t.sharedAxes)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else{if("number"!=typeof t.sharedAxes)throw new RV(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`);this.sharedAxes=[t.sharedAxes]}}build(t){const e=(t=bW(t)).slice(1);if(null!=this.sharedAxes)for(const i of this.sharedAxes)e[i-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let i=1;i<t.length;++i)n[i]=t[i];this.inputSpec=[new SW({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=vW(t),dF(t,this.alpha.read())}getConfig(){const t={alphaInitializer:uW(this.alphaInitializer),alphaRegularizer:dQ(this.alphaRegularizer),alphaConstraint:oG(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}yQ.className="PReLU",c.registerClass(yQ);class vQ extends MW{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==this.DEFAULT_ALPHA)throw new NV(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=vW(t);return bP(n)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}vQ.className="ELU",c.registerClass(vQ);class bQ extends MW{constructor(t){super(null==t?{}:t),this.DEFAULT_THETA=1,null==t&&(t={}),this.theta=null==t.theta?this.DEFAULT_THETA:t.theta}call(t,e){const n=vW(t);return FP(n,NB(RP(n,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}bQ.className="ThresholdedReLU",c.registerClass(bQ);class AQ extends MW{constructor(t){super(null==t?{}:t),this.DEFAULT_AXIS=1,null==t&&(t={}),this.softmax=(new nQ).apply,this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis}call(t,e){const n=vW(t);return this.softmax(n,this.axis)}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function xQ(t,e,n){if("number"==typeof t)return DV(t,e);if(t.length!==e)throw new RV(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${t.length} elements.`);for(let r=0;r<e;++r){const s=t[r];if((i=s)!==parseInt(i.toString(),10))throw new RV(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(t)} including a non-integer number ${s}`)}return t;var i}function wQ(t,e,n,i,r=1){if(null==t)return t;let s;return s="same"===n?t:t-(e+(e-1)*(r-1))+1,Math.floor((s+i-1)/i)}function _Q(t,e,n,i){if(null==t)return null;if("valid"===i)t=t*e+CG([n-e,0]);else{if("same"!==i)throw new RV(`Unsupport padding mode: ${i}.`);t*=e}return t}function SQ(t,e){return _O(()=>(mG(e),"channelsFirst"===e?HF(t,[0,2,3,1]):t))}function EQ(t,e){return _O(()=>(mG(e),"channelsFirst"===e?HF(t,[0,2,3,4,1]):t))}function CQ(t,e,n,i=[1,1],r="valid",s,o,a=null){return _O(()=>{if(null==s&&(s="channelsLast"),mG(s),3!==t.rank&&4!==t.rank)throw new RV(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(3!==e.rank&&4!==e.rank)throw new RV(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let l=SQ(t,s);if("causal"===r)throw new NV("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=u.conv2d({x:l,filter:e,strides:i,pad:"same"===r?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:a}),"channelsFirst"===s&&(l=HF(l,[0,3,1,2])),l})}AQ.className="Softmax",c.registerClass(AQ);class IQ extends MW{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",IQ.verifyArgs(e),this.rank=t,YV(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new NV(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=xQ(e.kernelSize,t,"kernelSize"),this.strides=xQ(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,gG(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,mG(this.dataFormat),this.activation=lQ(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=hW(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=lG(e.biasConstraint),this.biasRegularizer=fQ(e.biasRegularizer),this.activityRegularizer=fQ(e.activityRegularizer),this.dilationRate=xQ(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new RV(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new RV(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new RV(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(BV("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!XV(t.kernelSize,"number",1,3))throw new RV(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:oQ(this.activation),useBias:this.useBias,biasInitializer:uW(this.biasInitializer),biasRegularizer:dQ(this.biasRegularizer),activityRegularizer:dQ(this.activityRegularizer),biasConstraint:oG(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class TQ extends IQ{constructor(t,e){super(t,e),this.kernel=null,TQ.verifyArgs(e),this.filters=e.filters,YV(this.filters,"filters"),this.kernelInitializer=hW(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=lG(e.kernelConstraint),this.kernelRegularizer=fQ(e.kernelRegularizer)}build(t){t=bW(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new RV(`The channel dimension of the input should be defined. Found ${t[e]}`);const n=t[e],i=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return _O(()=>{let e;t=vW(t);const n=null==this.bias?null:this.bias.read(),i=JV(this.activation.getClassName());if(null!=i&&2===this.rank)e=CQ(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(1===this.rank)e=function(t,e,n,i=1,r="valid",s,o=1){return _O(()=>{if(null==s&&(s="channelsLast"),mG(s),3!==t.shape.length)throw new RV(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(3!==e.shape.length)throw new RV(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new RV(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if("channelsFirst"===s&&(t=HF(t,[0,2,1])),"causal"===r)throw new NV("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=lP(t,e,i,"same"===r?"same":"valid","NWC",o);return null!=n&&(a=UG(a,n)),a})}(t,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)e=CQ(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new NV("convolutions greater than 3D are not implemented yet.");e=function(t,e,n,i=[1,1,1],r="valid",s,o){return _O(()=>{if(null==s&&(s="channelsLast"),mG(s),4!==t.rank&&5!==t.rank)throw new RV(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(4!==e.rank&&5!==e.rank)throw new RV(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let a=EQ(t,s);if("causal"===r)throw new NV("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=hP(a,e,i,"same"===r?"same":"valid","NDHWC",o),null!=n&&(a=UG(a,n)),"channelsFirst"===s&&(a=HF(a,[0,4,1,2,3])),a})}(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(e=this.activation.apply(e))}return e})}computeOutputShape(t){t=bW(t);const e=[],n="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let r=0;r<n.length;++r){const t=wQ(n[r],this.kernelSize[r],this.padding,this.strides[r],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[r]);e.push(t)}let i=[t[0]];return"channelsLast"===this.dataFormat?(i=i.concat(e),i.push(this.filters)):(i.push(this.filters),i=i.concat(e)),i}getConfig(){const t={filters:this.filters,kernelInitializer:uW(this.kernelInitializer),kernelRegularizer:dQ(this.kernelRegularizer),kernelConstraint:oG(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new RV(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class MQ extends TQ{constructor(t){super(2,t),MQ.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!XV(t.kernelSize,"number",1,2))throw new RV(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}MQ.className="Conv2D",c.registerClass(MQ);class kQ extends TQ{constructor(t){super(3,t),kQ.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&(!Array.isArray(t.kernelSize)||1!==t.kernelSize.length&&3!==t.kernelSize.length))throw new RV(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}kQ.className="Conv3D",c.registerClass(kQ);class RQ extends MQ{constructor(t){if(super(t),this.inputSpec=[new SW({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new RV(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(4!==(t=bW(t)).length)throw new RV("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new RV("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],i=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new SW({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return _O(()=>{let e=vW(t);if(4!==e.shape.length)throw new RV(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${e.shape.length}`);const n=e.shape;let i,r;"channelsFirst"===this.dataFormat?(i=2,r=3):(i=1,r=2);const s=n[r],o=this.kernelSize[1],a=this.strides[1],l=[n[0],_Q(n[i],this.strides[0],this.kernelSize[0],this.padding),_Q(s,a,o,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=HF(e,[0,2,3,1]));let c=uP(e,this.kernel.read(),l,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(c=HF(c,[0,3,1,2])),null!=this.bias&&(c=UG(c,this.bias.read(),this.dataFormat)),null!=this.activation&&(c=this.activation.apply(c)),c})}computeOutputShape(t){const e=(t=bW(t)).slice();let n,i,r;"channelsFirst"===this.dataFormat?(n=1,i=2,r=3):(n=3,i=1,r=2);const s=this.kernelSize[0],o=this.kernelSize[1],a=this.strides[0],l=this.strides[1];return e[n]=this.filters,e[i]=_Q(e[i],a,s,this.padding),e[r]=_Q(e[r],l,o,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}RQ.className="Conv2DTranspose",c.registerClass(RQ);class NQ extends kQ{constructor(t){if(super(t),this.inputSpec=[new SW({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new RV(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(5!==(t=bW(t)).length)throw new RV("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new RV("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],i=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new SW({ndim:5,axes:{[e]:n}})],this.built=!0}call(t,e){return _O(()=>{let e=vW(t);if(5!==e.shape.length)throw new RV(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${e.shape.length}`);const n=e.shape;let i,r,s;"channelsFirst"===this.dataFormat?(s=2,i=3,r=4):(s=1,i=2,r=3);const o=n[i],a=n[r],l=this.kernelSize[1],c=this.kernelSize[2],u=this.strides[1],h=this.strides[2],d=[n[0],_Q(n[s],this.strides[0],this.kernelSize[0],this.padding),_Q(o,u,l,this.padding),_Q(a,h,c,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=HF(e,[0,2,3,4,1]));let p=pP(e,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=HF(p,[0,4,1,2,3])),null!==this.bias&&(p=UG(p,this.bias.read(),this.dataFormat)),null!==this.activation&&(p=this.activation.apply(p)),p})}computeOutputShape(t){const e=(t=bW(t)).slice();let n,i,r,s;"channelsFirst"===this.dataFormat?(n=1,i=2,r=3,s=4):(n=4,i=1,r=2,s=3);const o=this.kernelSize[0],a=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[0],u=this.strides[1],h=this.strides[2];return e[n]=this.filters,e[i]=_Q(e[i],c,o,this.padding),e[r]=_Q(e[r],u,a,this.padding),e[s]=_Q(e[s],h,l,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}NQ.className="Conv3DTranspose",c.registerClass(NQ);class LQ extends TQ{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==e.filters)throw new RV("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=e.kernelInitializer||null!=e.kernelRegularizer||null!=e.kernelConstraint)throw new RV("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=e.padding&&"same"!==e.padding&&"valid"!==e.padding)throw new RV(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=hW(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=fQ(e.depthwiseRegularizer),this.depthwiseConstraint=lG(e.depthwiseConstraint),this.pointwiseInitializer=hW(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=fQ(e.pointwiseRegularizer),this.pointwiseConstraint=lG(e.pointwiseConstraint)}build(t){if((t=bW(t)).length<this.rank+2)throw new RV(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e]||t[e]<0)throw new RV(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);const n=t[e],i=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let o=0;o<this.rank;++o)r.push(1);r.push(n*this.depthMultiplier,this.filters);const s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):null,this.inputSpec=[new SW({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return _O(()=>{let e;if(t=vW(t),1===this.rank)throw new NV("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(t=HF(t,[0,2,3,1])),e=xF(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(e=UG(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),"channelsFirst"===this.dataFormat&&(e=HF(e,[0,3,1,2])),e})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=uW(this.depthwiseInitializer),t.pointwiseInitializer=uW(this.pointwiseInitializer),t.depthwiseRegularizer=dQ(this.depthwiseRegularizer),t.pointwiseRegularizer=dQ(this.pointwiseRegularizer),t.depthwiseConstraint=oG(this.depthwiseConstraint),t.pointwiseConstraint=oG(this.pointwiseConstraint),t}}LQ.className="SeparableConv";class DQ extends LQ{constructor(t){super(2,t)}}DQ.className="SeparableConv2D",c.registerClass(DQ);class BQ extends TQ{constructor(t){super(1,t),BQ.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!XV(t.kernelSize,"number",1,1))throw new RV(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}BQ.className="Conv1D",c.registerClass(BQ);class OQ extends MW{constructor(t){super(t),this.cropping="number"==typeof t.cropping?[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"==typeof t.cropping[0]?[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:t.cropping,this.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return _O(()=>{if(t=vW(t),"channelsLast"===this.dataFormat){const e=NG(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return NG(e,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const e=NG(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return NG(e,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}OQ.className="Cropping2D",c.registerClass(OQ);class PQ extends MW{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==t.size?this.DEFAULT_SIZE:t.size,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,mG(this.dataFormat),this.interpolation=null==t.interpolation?"nearest":t.interpolation,qV(uG,"InterpolationFormat",this.interpolation)}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],null==t[2]?null:this.size[0]*t[2],null==t[3]?null:this.size[1]*t[3]]:[t[0],null==t[1]?null:this.size[0]*t[1],null==t[2]?null:this.size[1]*t[2],t[3]]}call(t,e){return _O(()=>{let e=vW(t);const n=e.shape;if("channelsFirst"===this.dataFormat){e=HF(e,[0,2,3,1]);const t=this.size[0]*n[2],i=this.size[1]*n[3],r="nearest"===this.interpolation?j$.resizeNearestNeighbor(e,[t,i]):j$.resizeBilinear(e,[t,i]);return HF(r,[0,3,1,2])}{const t=this.size[0]*n[1],i=this.size[1]*n[2];return"nearest"===this.interpolation?j$.resizeNearestNeighbor(e,[t,i]):j$.resizeBilinear(e,[t,i])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}PQ.className="UpSampling2D",c.registerClass(PQ);class FQ extends IQ{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=hW(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=lG(t.depthwiseConstraint),this.depthwiseRegularizer=fQ(t.depthwiseRegularizer)}build(t){if((t=bW(t)).length<4)throw new RV(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e="channelsFirst"===this.dataFormat?1:3;if(null==t[e]||t[e]<0)throw new RV(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const n=t[e];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return _O(()=>{let e=function(t,e,n=[1,1],i="valid",r,s){return _O(()=>{null==r&&(r="channelsLast"),mG(r);let o=SQ(t,r);if(4!==t.rank)throw new RV(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(4!==e.rank)throw new RV(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return o=fP(o,e,n,"same"===i?"same":"valid","NHWC",s),"channelsFirst"===r&&(o=HF(o,[0,3,1,2])),o})}(t=vW(t),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(e=UG(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),e})}computeOutputShape(t){t=bW(t);const e="channelsFirst"===this.dataFormat?t[3]:t[2],n="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,i=wQ("channelsFirst"===this.dataFormat?t[2]:t[1],this.kernelSize[0],this.padding,this.strides[0]),r=wQ(e,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],n,i,r]:[t[0],i,r,n]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=uW(this.depthwiseInitializer),t.depthwiseRegularizer=dQ(this.depthwiseRegularizer),t.depthwiseConstraint=oG(this.depthwiseRegularizer),t}}function $Q(t,e,n,i){if(Array.isArray(t)){if(null!=e||null!=n)throw new RV("When inputs is an array, neither initialState or constants should be provided");null!=i&&(n=t.slice(t.length-i,t.length),t=t.slice(0,t.length-i)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function r(t){return null==t||Array.isArray(t)?t:[t]}return{inputs:t,initialState:e=r(e),constants:n=r(n)}}function zQ(t,e,n,i=!1,r,s,o=!1,a=!1){return _O(()=>{const l=e.shape.length;if(l<3)throw new RV(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(IG(2,l));if(e=HF(e,c),null!=s)throw new NV("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=r&&((r=NB(NB(r,"bool"),"float32")).rank===l-1&&(r=EP(r,-1)),r=HF(r,c)),i&&(e=bF(e,0),null!=r&&(r=bF(r,0)));const u=[];let h,d=n;const p=e.shape[0],f=FF(e);let m,g;null!=r&&(m=FF(r));for(let e=0;e<p;++e){const n=f[e],i=_O(()=>t(n,d));if(null==r)h=i[0],d=i[1];else{const t=_O(()=>{const t=m[e],n=$P(cF(t),t);return{output:RO(FP(i[0],t),FP(d[0],n)),newStates:d.map((e,r)=>RO(FP(i[1][r],t),FP(e,n)))}});h=t.output,d=t.newStates}a&&u.push(h)}return a&&(g=LF(u,1)),[h,g,d]})}FQ.className="DepthwiseConv2D",c.registerClass(FQ);class UQ extends MW{constructor(t){let e;if(super(t),null==t.cell)throw new RV("cell property is missing for the constructor of RNN.");if(e=Array.isArray(t.cell)?new XQ({cells:t.cell}):t.cell,null==e.stateSize)throw new RV("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=null!=t.returnSequences&&t.returnSequences,this.returnState=null!=t.returnState&&t.returnState,this.goBackwards=null!=t.goBackwards&&t.goBackwards,this._stateful=null!=t.stateful&&t.stateful,this.unroll=null!=t.unroll&&t.unroll,this.supportsMasking=!0,this.inputSpec=[new SW({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?IG(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(t=>null):this.states_}setStates(t){this.states_=t}computeOutputShape(t){gW(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const n=e[0];let i;if(i=this.returnSequences?[t[0],t[1],n]:[t[0],n],this.returnState){const n=[];for(const i of e)n.push([t[0],i]);return[i].concat(n)}return i}computeMask(t,e){return _O(()=>{Array.isArray(e)&&(e=e[0]);const t=this.returnSequences?e:null;if(this.returnState){const e=this.states.map(t=>null);return[t].concat(e)}return t})}get states(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let n=0;n<t;++n)e.push(null);return e}return this.states_}set states(t){this.states_=t}build(t){if(null!=this.numConstants)throw new NV("Constants support is not implemented in RNN yet.");gW(t)&&(t=t[0]),t=t;const e=this.stateful?t[0]:null,n=t.slice(2);this.inputSpec[0]=new SW({shape:[e,null,...n]});const r=[t[0]].concat(t.slice(2));let s;if(this.cell.build(r),s=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!i.arraysEqual(this.stateSpec.map(t=>t.shape[t.shape.length-1]),s))throw new RV(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map(t=>new SW({shape:[null,t]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){_O(()=>{if(!this.stateful)throw new MV("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new RV("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(t=>aF([n,t])):[aF([n,this.cell.stateSize])];else if(null==t)SO(this.states_),null!=this.keptStates&&(SO(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(t=>aF([n,t])):this.states_[0]=aF([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new RV(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);!0===e?this.keptStates.push(this.states_.slice()):SO(this.states_);for(let e=0;e<this.states_.length;++e){const r=t[e],s=Array.isArray(this.cell.stateSize)?this.cell.stateSize[e]:this.cell.stateSize,o=[n,s];if(!i.arraysEqual(r.shape,o))throw new RV(`State ${e} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${r.shape}`);this.states_[e]=r}}this.states_=this.states_.map(t=>EO(t.clone()))})}apply(t,e){let n=null==e?null:e.initialState,i=null==e?null:e.constants;null==e&&(e={});const r=$Q(t,n,i,this.numConstants);t=r.inputs,n=r.initialState,i=r.constants;let s=[],o=[];if(null!=n){e.initialState=n,s=s.concat(n),this.stateSpec=[];for(const t of n)this.stateSpec.push(new SW({shape:t.shape}));o=o.concat(this.stateSpec)}if(null!=i&&(e.constants=i,s=s.concat(i),this.numConstants=i.length),s[0]instanceof EW){const n=[t].concat(s),i=this.inputSpec.concat(o),r=this.inputSpec;this.inputSpec=i;const a=super.apply(n,e);return this.inputSpec=r,a}return super.apply(t,e)}call(t,e){return _O(()=>{const n=null==e?null:e.mask,i=null==e?null:e.training;let r=null==e?null:e.initialState;t=vW(t),null==r&&(r=this.stateful?this.states_:this.getInitialState(t));const s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==s)throw new RV(`RNN Layer has ${s} state(s) but was passed ${r.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:i},a=zQ((t,e)=>{const n=this.cell.call([t].concat(e),o);return[n[0],n.slice(1)]},t,r,this.goBackwards,n,null,this.unroll,this.returnSequences),l=a[0],c=a[1],u=a[2];this.stateful&&this.resetStates(u,i);const h=this.returnSequences?c:l;return this.returnState?[h].concat(u):h})}getInitialState(t){return _O(()=>{let e=aF(t.shape);return e=zP(e,[1,2]),e=MG(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(t=>t>1?BG(e,[1,t]):e):this.cell.stateSize>1?[BG(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(e.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===UQ.className&&(e.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,t,e)}static fromConfig(t,e,n={}){const i=VW(e.cell,n);return new t(Object.assign(e,{cell:i}))}}UQ.className="RNN",c.registerClass(UQ);class HQ extends MW{}class VQ extends HQ{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,YV(this.units,"units"),this.activation=lQ(null==t.activation?this.DEFAULT_ACTIVATION:t.activation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=hW(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=hW(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=hW(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=fQ(t.kernelRegularizer),this.recurrentRegularizer=fQ(t.recurrentRegularizer),this.biasRegularizer=fQ(t.biasRegularizer),this.kernelConstraint=lG(t.kernelConstraint),this.recurrentConstraint=lG(t.recurrentConstraint),this.biasConstraint=lG(t.biasConstraint),this.dropout=EG([1,CG([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=EG([1,CG([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=bW(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return _O(()=>{if(2!==(t=t).length)throw new RV(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let n=t[1];t=t[0];const i=null!=e.training&&e.training;let r;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=YQ({ones:()=>cF(t),rate:this.dropout,training:i})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=YQ({ones:()=>cF(n),rate:this.recurrentDropout,training:i}));const s=this.dropoutMask,o=this.recurrentDropoutMask;r=PG(null!=s?FP(t,s):t,this.kernel.read()),null!=this.bias&&(r=UG(r,this.bias.read())),null!=o&&(n=FP(n,o));let a=RO(r,PG(n,this.recurrentKernel.read()));return null!=this.activation&&(a=this.activation.apply(a)),[a,a]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:oQ(this.activation),useBias:this.useBias,kernelInitializer:uW(this.kernelInitializer),recurrentInitializer:uW(this.recurrentInitializer),biasInitializer:uW(this.biasInitializer),kernelRegularizer:dQ(this.kernelRegularizer),recurrentRegularizer:dQ(this.recurrentRegularizer),biasRegularizer:dQ(this.biasRegularizer),activityRegularizer:dQ(this.activityRegularizer),kernelConstraint:oG(this.kernelConstraint),recurrentConstraint:oG(this.recurrentConstraint),biasConstraint:oG(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},t,e)}}VQ.className="SimpleRNNCell",c.registerClass(VQ);class GQ extends UQ{constructor(t){t.cell=new VQ(t),super(t)}call(t,e){return _O(()=>(null!=this.cell.dropoutMask&&(SO(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(SO(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}static fromConfig(t,e){return new t(e)}}GQ.className="SimpleRNN",c.registerClass(GQ);class WQ extends HQ{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new RV("GRUCell does not support reset_after parameter set to true.");this.units=t.units,YV(this.units,"units"),this.activation=lQ(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=lQ(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=hW(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=hW(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=hW(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=fQ(t.kernelRegularizer),this.recurrentRegularizer=fQ(t.recurrentRegularizer),this.biasRegularizer=fQ(t.biasRegularizer),this.kernelConstraint=lG(t.kernelConstraint),this.recurrentConstraint=lG(t.recurrentConstraint),this.biasConstraint=lG(t.biasConstraint),this.dropout=EG([1,CG([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=EG([1,CG([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=bW(t),this.kernel=this.addWeight("kernel",[t[t.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return _O(()=>{if(2!==(t=t).length)throw new RV(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const n=null!=e.training&&e.training;let i=t[1];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=YQ({ones:()=>cF(t),rate:this.dropout,training:n,count:3})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=YQ({ones:()=>cF(i),rate:this.recurrentDropout,training:n,count:3}));const r=this.recurrentDropoutMask;let s,o,a;0<this.dropout&&this.dropout<1&&(t=FP(t,this.dropoutMask[0]));let l=PG(t,this.kernel.read());this.useBias&&(l=UG(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(i=FP(i,r[0]));const c=this.recurrentKernel.read(),[u,h]=kF(c,[2*this.units,this.units],c.rank-1),d=PG(i,u),[p,f,m]=kF(l,3,l.rank-1),[g,y]=kF(d,2,d.rank-1);s=this.recurrentActivation.apply(RO(p,g)),o=this.recurrentActivation.apply(RO(f,y));const v=PG(FP(o,i),h);a=this.activation.apply(RO(m,v));const b=RO(FP(s,i),FP(RO(1,rF(s)),a));return[b,b]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:oQ(this.activation),recurrentActivation:oQ(this.recurrentActivation),useBias:this.useBias,kernelInitializer:uW(this.kernelInitializer),recurrentInitializer:uW(this.recurrentInitializer),biasInitializer:uW(this.biasInitializer),kernelRegularizer:dQ(this.kernelRegularizer),recurrentRegularizer:dQ(this.recurrentRegularizer),biasRegularizer:dQ(this.biasRegularizer),activityRegularizer:dQ(this.activityRegularizer),kernelConstraint:oG(this.kernelConstraint),recurrentConstraint:oG(this.recurrentConstraint),biasConstraint:oG(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},t,e)}}WQ.className="GRUCell",c.registerClass(WQ);class jQ extends UQ{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new WQ(t),super(t)}call(t,e){return _O(()=>(null!=this.cell.dropoutMask&&(SO(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(SO(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}jQ.className="GRU",c.registerClass(jQ);class QQ extends HQ{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,YV(this.units,"units"),this.activation=lQ(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=lQ(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=hW(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=hW(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=hW(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=fQ(t.kernelRegularizer),this.recurrentRegularizer=fQ(t.recurrentRegularizer),this.biasRegularizer=fQ(t.biasRegularizer),this.kernelConstraint=lG(t.kernelConstraint),this.recurrentConstraint=lG(t.recurrentConstraint),this.biasConstraint=lG(t.biasConstraint),this.dropout=EG([1,CG([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=EG([1,CG([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;let n;if(t=bW(t),this.kernel=this.addWeight("kernel",[t[t.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const t=this.biasInitializer,i=this.units;n=new((e=class extends jG{apply(e,n){const r=t.apply([i]),s=(new qG).apply([i]),o=t.apply([2*i]);return DG(DG(r,s),o)}}).className="CustomInit",e)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return _O(()=>{const n=null!=e.training&&e.training;if(3!==(t=t).length)throw new RV(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let i=t[1];const r=t[2];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=YQ({ones:()=>cF(t),rate:this.dropout,training:n,count:4})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=YQ({ones:()=>cF(i),rate:this.recurrentDropout,training:n,count:4}));const s=this.recurrentDropoutMask;let o,a,l,c;0<this.dropout&&this.dropout<1&&(t=FP(t,this.dropoutMask[0]));let u=PG(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(i=FP(i,s[0])),u=RO(u,PG(i,this.recurrentKernel.read())),this.useBias&&(u=UG(u,this.bias.read()));const[h,d,p,f]=kF(u,4,u.rank-1);o=this.recurrentActivation.apply(h),a=this.recurrentActivation.apply(d),l=RO(FP(a,r),FP(o,this.activation.apply(p))),c=this.recurrentActivation.apply(f);const m=FP(c,this.activation.apply(l));return[m,m,l]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:oQ(this.activation),recurrentActivation:oQ(this.recurrentActivation),useBias:this.useBias,kernelInitializer:uW(this.kernelInitializer),recurrentInitializer:uW(this.recurrentInitializer),biasInitializer:uW(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:dQ(this.kernelRegularizer),recurrentRegularizer:dQ(this.recurrentRegularizer),biasRegularizer:dQ(this.biasRegularizer),activityRegularizer:dQ(this.activityRegularizer),kernelConstraint:oG(this.kernelConstraint),recurrentConstraint:oG(this.recurrentConstraint),biasConstraint:oG(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},t,e)}}QQ.className="LSTMCell",c.registerClass(QQ);class qQ extends UQ{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new QQ(t),super(t)}call(t,e){return _O(()=>(null!=this.cell.dropoutMask&&(SO(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(SO(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}qQ.className="LSTM",c.registerClass(qQ);class XQ extends HQ{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return _O(()=>{let n=(t=t).slice(1);const i=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?i.push(n.splice(0,t.stateSize.length)):i.push(n.splice(0,1));i.reverse();const r=[];let s;for(let o=0;o<this.cells.length;++o){const a=this.cells[o];n=i[o],s=0===o?[t[0]].concat(n):[s[0]].concat(n),s=a.call(s,e),r.push(s.slice(1))}n=[];for(const t of r.slice().reverse())n.push(...t);return[s[0]].concat(n)})}build(t){let e;gW(t)&&(t=t[0]),t=t,this.cells.forEach((n,i)=>{bG(`RNNCell_${i}`,()=>{n.build(t),e=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){const t=super.getConfig(),e=this.cells.map(t=>({className:t.getClassName(),config:t.getConfig()}));return Object.assign({},t,{cells:e})}static fromConfig(t,e,n={}){const i=[];for(const r of e.cells)i.push(VW(r,n));return new t({cells:i})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return wW(t)}setWeights(t){const e=[];for(const n of this.cells){const i=t.splice(n.weights.length);for(let t=0;t<n.weights.length;++t)e.push([n.weights[t],i[t]])}_W(e)}}function YQ(t){const{ones:e,rate:n,training:i=!1,count:r=1}=t,s=()=>HG(e(),n),o=()=>VG(s,e,i);return!r||r<=1?EO(o().clone()):Array(r).fill(void 0).map(o).map(t=>EO(t.clone()))}var KQ,JQ;XQ.className="StackedRNNCells",c.registerClass(XQ);class ZQ extends UQ{constructor(t){if(t.unroll)throw new NV("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new NV("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new SW({ndim:5})]}call(t,e){return _O(()=>{if(null!=this.cell.dropoutMask&&(SO(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(SO(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new RV("ConvRNN2D cell does not support constants");return super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return _O(()=>{const{stateSize:e}=this.cell,n=this.computeSingleOutputShape(t.shape),i=aF([n[0],...n.slice(2)]);return Array.isArray(e)?Array(e.length).fill(i):[i]})}resetStates(t,e=!1){_O(()=>{if(!this.stateful)throw new MV("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)];if(null==n[0])throw new RV("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>aF(s)):[aF(s)];else if(null==t)SO(this.states_),null!=this.keptStates&&(SO(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>aF(s)):this.states_[0]=aF(s);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new RV(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):SO(this.states_);for(let e=0;e<this.states_.length;++e){const n=t[e],r=s;if(!i.arraysEqual(n.shape,r))throw new RV(`State ${e} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[e]=n}}this.states_=this.states_.map(t=>EO(t.clone()))})}computeSingleOutputShape(t){const{dataFormat:e,filters:n,kernelSize:i,padding:r,strides:s,dilationRate:o}=this.cell,a="channelsFirst"===e,l=t[a?4:3],c=wQ(t[a?3:2],i[0],r,s[0],o[0]),u=wQ(l,i[1],r,s[1],o[1]);return[...t.slice(0,2),...a?[n,c,u]:[c,u,n]]}}ZQ.className="ConvRNN2D";class tq extends QQ{constructor(t){const{filters:e,kernelSize:n,strides:i,padding:r,dataFormat:s,dilationRate:o}=t;super(Object.assign({},t,{units:e})),this.filters=e,YV(this.filters,"filters"),this.kernelSize=xQ(n,2,"kernelSize"),this.kernelSize.forEach(t=>YV(t,"kernelSize")),this.strides=xQ(i||1,2,"strides"),this.strides.forEach(t=>YV(t,"strides")),this.padding=r||"valid",gG(this.padding),this.dataFormat=s||"channelsLast",mG(this.dataFormat),this.dilationRate=xQ(o||1,2,"dilationRate"),this.dilationRate.forEach(t=>YV(t,"dilationRate"))}build(t){var e;t=bW(t);const n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new RV(`The channel dimension of the input should be defined. Found ${t[n]}`);const i=this.kernelSize.concat([t[n],4*this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const r=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",r,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let t;if(this.unitForgetBias){const n=this.biasInitializer,i=this.filters;t=new((e=class extends jG{apply(t,e){return LG([n.apply([i]),lF([i]),n.apply([2*i])])}}).className="CustomInit",e)}else t=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,t,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return _O(()=>{if(3!==t.length)throw new RV(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const n=e.training||!1,i=t[0],r=t[1],s=t[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=YQ({ones:()=>cF(i),rate:this.dropout,training:n,count:4}));const o=this.dropoutMask,a=(t,e,n)=>e&&e[n]?FP(e[n],t):t;let l=a(i,o,0),c=a(i,o,1),u=a(i,o,2),h=a(i,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=YQ({ones:()=>cF(r),rate:this.recurrentDropout,training:n,count:4}));const d=this.recurrentDropoutMask;let p=a(r,d,0),f=a(r,d,1),m=a(r,d,2),g=a(r,d,3);const[y,v,b,A]=kF(this.kernel.read(),4,3),[x,w,_,S]=this.useBias?kF(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,x,this.padding),c=this.inputConv(c,v,w,this.padding),u=this.inputConv(u,b,_,this.padding),h=this.inputConv(h,A,S,this.padding);const[E,C,I,T]=kF(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,E),f=this.recurrentConv(f,C),m=this.recurrentConv(m,I),g=this.recurrentConv(g,T);const M=this.recurrentActivation.apply(RO(l,p)),k=this.recurrentActivation.apply(RO(c,f)),R=RO(FP(k,s),FP(M,this.activation.apply(RO(u,m)))),N=FP(this.recurrentActivation.apply(RO(h,g)),this.activation.apply(R));return[N,N,R]})}getConfig(){const t=function(t,e){var n={};for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&e.indexOf(i)<0&&(n[i]=t[i]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(i=Object.getOwnPropertySymbols(t);r<i.length;r++)e.indexOf(i[r])<0&&Object.prototype.propertyIsEnumerable.call(t,i[r])&&(n[i[r]]=t[i[r]])}return n}(super.getConfig(),["units"]);return Object.assign({},t,{filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides})}inputConv(t,e,n,i){const r=aP(t,e,this.strides,i||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?UG(r,n,this.dataFormat):r}recurrentConv(t,e){return aP(t,e,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}tq.className="ConvLSTM2DCell",c.registerClass(tq);class eq extends ZQ{constructor(t){const e=new tq(t);super(Object.assign({},t,{cell:e}))}static fromConfig(t,e){return new t(e)}}eq.className="ConvLSTM2D",c.registerClass(eq);class nq extends MW{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const e=t.shape,n=[];for(let i=0;i<this.noiseShape.length;++i)n.push(null==this.noiseShape[i]?e[i]:this.noiseShape[i]);return n}call(t,e){return _O(()=>{this.invokeCallHook(t,e);const n=vW(t);if(0<this.rate&&this.rate<1){const t=null!=e.training&&e.training,i=this.getNoiseShape(n);return VG(()=>HG(n,this.rate,i,this.seed),()=>n,t)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}nq.className="Dropout",c.registerClass(nq);class iq extends nq{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}iq.className="SpatialDropout1D",c.registerClass(iq);class rq extends MW{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,YV(this.units,"units"),this.activation=lQ(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=hW(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=hW(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=lG(t.kernelConstraint),this.biasConstraint=lG(t.biasConstraint),this.kernelRegularizer=fQ(t.kernelRegularizer),this.biasRegularizer=fQ(t.biasRegularizer),this.activityRegularizer=fQ(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const e=(t=bW(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){const e=(t=bW(t)).slice();return e[e.length-1]=this.units,e}call(t,e){return _O(()=>{this.invokeCallHook(t,e);const n=vW(t),i=JV(this.activation.getClassName());let r;return null!=i?r=PG(n,this.kernel.read(),i,this.bias?this.bias.read():null):(r=PG(n,this.kernel.read()),null!=this.bias&&(r=UG(r,this.bias.read())),null!=this.activation&&(r=this.activation.apply(r))),r})}getConfig(){const t={units:this.units,activation:oQ(this.activation),useBias:this.useBias,kernelInitializer:uW(this.kernelInitializer),biasInitializer:uW(this.biasInitializer),kernelRegularizer:dQ(this.kernelRegularizer),biasRegularizer:dQ(this.biasRegularizer),activityRegularizer:dQ(this.activityRegularizer),kernelConstraint:oG(this.kernelConstraint),biasConstraint:oG(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}rq.className="Dense",c.registerClass(rq);class sq extends MW{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=bW(t);for(const e of t.slice(1))if(null==e)throw new RV(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],SG(t,1)]}call(t,e){return _O(()=>{this.invokeCallHook(t,e);let n=vW(t);if("channelsFirst"===this.dataFormat&&n.rank>1){const t=[0];for(let e=2;e<n.rank;++e)t.push(e);t.push(1),n=HF(n,t)}return function(t){if(t.rank<=1)throw new RV(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const e=[t.shape[0],SG(t.shape,1)];return qO(t,e)}(n)})}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}sq.className="Flatten",c.registerClass(sq);class oq extends MW{constructor(t){super(t),this.supportsMasking=!0,this.activation=lQ(t.activation)}call(t,e){return _O(()=>{this.invokeCallHook(t,e);const n=vW(t);return this.activation.apply(n)})}getConfig(){const t={activation:oQ(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}oq.className="Activation",c.registerClass(oq);class aq extends MW{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return _O(()=>{return t=vW(t),e=t,n=this.n,_O(()=>{if(2!==e.shape.length)throw new RV(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return BG(MG(e,1),[1,n,1])});var e,n})}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}aq.className="RepeatVector",c.registerClass(aq);class lq extends MW{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,e){const n="Total size of new array must be unchanged.",i=e.slice();let r=1,s=null;for(let a=0;a<i.length;++a){const t=i[a];if(this.isUnknown(t)){if(null!==s)throw new RV("Can only specifiy one unknown dimension.");s=a}else r*=t}const o=SG(t);if(null!==s){if(0===r||o%r!=0)throw new RV(n);i[s]=o/r}else if(o!==r)throw new RV(n);return i}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return _O(()=>{this.invokeCallHook(t,e);const n=vW(t),i=n.shape,r=i.slice(0,1).concat(this.fixUnknownDimension(i.slice(1),this.targetShape));return qO(n,r)})}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}lq.className="Reshape",c.registerClass(lq);class cq extends MW{constructor(t){if(super(t),null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const e=IG(1,t.dims.length+1);if(!i.arraysEqual(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new SW({ndim:this.dims.length+1})]}computeOutputShape(t){const e=(t=bW(t)).slice();return this.dims.forEach((n,i)=>{e[i+1]=t[n]}),e}call(t,e){return HF(vW(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}cq.className="Permute",c.registerClass(cq);class uq extends MW{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const n=vW(t);return LO(sF(n,this.maskValue),-1)}call(t,e){return _O(()=>{this.invokeCallHook(t,e);const n=vW(t),i=LO(sF(n,this.maskValue),-1,!0);return FP(n,NB(i,n.dtype))})}}uq.className="Masking",c.registerClass(uq);class hq extends MW{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=null==t.inputLength?[e,null]:[e].concat(FV(t.inputLength))}this.inputDim=t.inputDim,YV(this.inputDim,"inputDim"),this.outputDim=t.outputDim,YV(this.outputDim,"outputDim"),this.embeddingsInitializer=hW(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=fQ(t.embeddingsRegularizer),this.activityRegularizer=fQ(t.activityRegularizer),this.embeddingsConstraint=lG(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return _O(()=>this.maskZero?(t=vW(t),sF(t,UF(t))):null)}computeOutputShape(t){if(t=bW(t),null==this.inputLength)return[...t,this.outputDim];const e=FV(this.inputLength);if(e.length!==t.length-1)throw new RV(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let n=0;for(let i=0;i<e.length;++i){const r=e[i],s=t[i+1];if(null!=r&&null!=s&&r!==s)throw new RV(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);null==r&&(e[n]=s),n++}}return[t[0],...e,this.outputDim]}call(t,e){return _O(()=>{this.invokeCallHook(t,e);let n=vW(t);"int32"!==n.dtype&&(n=TG(n,"int32"));const i=FG(this.embeddings.read(),qO(n,[n.size]));return qO(i,bW(this.computeOutputShape(n.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:uW(this.embeddingsInitializer),embeddingsRegularizer:dQ(this.embeddingsRegularizer),activityRegularizer:dQ(this.activityRegularizer),embeddingsConstraint:oG(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}hq.className="Embedding",c.registerClass(hq);class dq extends MW{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new NV}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const n=t.slice(0,t.length-e.length);for(let i=0;i<e.length;++i){const r=t[t.length-e.length+i],s=e[i];if(null==r||null==s||r<0||s<0)n.push(null);else if(1===r)n.push(s);else if(1===s)n.push(r);else{if(r!==s)throw new RV("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(r)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[bW(t)]),(t=t).length<2)throw new RV(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const r of t)null!=r&&null!==r[0]&&e.push(r[0]);if(e=jV(e),e.length>1)throw new RV(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let n=null==t[0]?null:t[0].slice(1);for(let r=1;r<t.length;++r){const e=null==t[r]?null:t[r].slice(1);n=this.computeElementwiseOpOutputShape(n,e)}const i=t.map(t=>t.length);this.reshapeRequired=-1!==t.indexOf(null)||1!==jV(i).length}call(t,e){return _O(()=>{if(t=t,this.reshapeRequired){const e=[],n=t.map(t=>t.rank);if(-1===n.indexOf(null)){const i=CG(n);for(let n of t){const t=n.rank;for(let e=0;e<i-t;++e)n=MG(n,1);e.push(n)}return this.mergeFunction(e)}{let n=!1;for(const s of t){const t=s.rank;if(null==t){const t=s.shape,i=t[0],r=t.slice(1).concat([i]);let o=qO(s,[i].concat(SG(t.slice(1))));o=HF(o,[1,0]),o=qO(o,r),e.push(o),n=!0}else if(t>1){const i=IG(1,t).concat([0]);e.push(HF(s,i)),n=!0}else e.push(s)}let i=this.mergeFunction(e);const r=i.rank;if(n)if(null==r){const t=i.shape,e=t[t.length-1],n=[e].concat(t.slice(0,t.length-1));i=qO(HF(qO(i,[-1,e]),[1,0]),n)}else if(r>1){const t=[r-1].concat(IG(0,r-1));i=HF(i,t)}return i}}return this.mergeFunction(t)})}computeOutputShape(t){let e;e=null==(t=t)[0]?null:t[0].slice(1);for(let i=1;i<t.length;++i){const n=null==t[i]?null:t[i].slice(1);e=this.computeElementwiseOpOutputShape(e,n)}let n=[];for(const i of t)null!=i&&null!==i[0]&&n.push(i[0]);return n=jV(n),e=1===n.length?n.concat(e):[null].concat(e),e}computeMask(t,e){return _O(()=>{if(null==e)return null;if(!Array.isArray(e))throw new RV("`mask` should be an Array");if(!Array.isArray(t))throw new RV("`inputs` should be an Array");if(e.length!==t.length)throw new RV(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(t=>null==t))return null;let n=(e=e.map(t=>null==t?t:EP(t,0)))[0];for(let t=1;t<e.length-1;++t)n=HP(n,e[t]);return n})}}class pq extends dq{constructor(t){super(t)}mergeFunction(t){return _O(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=RO(e,t[n]);return e})}}pq.className="Add",c.registerClass(pq);class fq extends dq{constructor(t){super(t)}mergeFunction(t){return _O(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=FP(e,t[n]);return e})}}fq.className="Multiply",c.registerClass(fq);class mq extends dq{constructor(t){super(t)}mergeFunction(t){return _O(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=RO(e,t[n]);return FP(1/t.length,e)})}}mq.className="Average",c.registerClass(mq);class gq extends dq{constructor(t){super(t)}mergeFunction(t){return _O(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=WP(e,t[n]);return e})}}gq.className="Maximum",c.registerClass(gq);class yq extends dq{constructor(t){super(t)}mergeFunction(t){return _O(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=QP(e,t[n]);return e})}}yq.className="Minimum",c.registerClass(yq);class vq extends dq{constructor(t){super(t),this.DEFAULT_AXIS=-1,null==t&&(t={}),this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new RV("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(const i of t)if(null!=i){e=!1;break}if(e)return;const n=[];for(let r=0;r<t.length;++r){const e=t[r].slice();e.splice(this.axis,1);let s=!1;for(const t of n)if(i.arraysEqual(t,e)){s=!0;break}s||n.push(e)}if(n.length>1)throw new RV("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return _O(()=>LG(t,this.axis))}computeOutputShape(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new RV("A `Concatenate` layer should be called on a list of inputs.");const e=t,n=e[0].slice(),i=this.axis<0?n.length+this.axis:this.axis;for(const r of e.slice(1)){if(null==n[i]||null==r[i]){n[i]=null;break}n[i]+=r[i]}return n}computeMask(t,e){if(null==e)return null;if(!Array.isArray(e))throw new RV("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new RV("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new RV(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return _O(()=>{let n=!0;if(e.forEach(t=>{null==t||(n=!1)}),n)return null;const i=[];for(let s=0;s<t.length;++s)i.push(null==e[s]?NB(cF(t[s]),"bool"):e[s].rank<t[s].rank?EP(e[s],-1):e[s]);const r=nP(i,this.axis);return NO(r,-1,!1)})}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function bq(t,e){for(;t<0;)t+=e;return t}vq.className="Concatenate",c.registerClass(vq);class Aq extends dq{constructor(t){super(t),this.axes=t.axes,this.normalize=null!=t.normalize&&t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){i.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0],n=t[1];if(e.length>3||n.length>3)throw new NV("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);if(e[r[0]]!==n[r[1]])throw new RV(`Dimension incompatibility: ${e[r[0]]} !== ${n[r[1]]}`)}mergeFunction(t){if(2!==t.length)throw new RV(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e,n=t[0],r=t[1];return e=Array.isArray(this.axes)?this.axes.map((e,n)=>bq(e,t[n].shape.length)):[bq(this.axes,n.shape.length),bq(this.axes,r.shape.length)],this.normalize&&(n=GW(n,e[0]),r=GW(r,e[1])),function(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new NV("batchDot is not implemented for tensors of 4D or higher rank yet");if(i.assert(t.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`),i.assert(t.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),"number"==typeof n&&(n=[n,n]),"complex64"===t.dtype||"complex64"===e.dtype)throw new NV("batchDot is not implemented for complex64-type Tensors yet.");const r=t.shape.length,s=e.shape.length;null==n&&(n=[r-1,s-2]);const o=n;return _O(()=>{let n,i;if(r>s){n=r-s;const t=[];for(let e=0;e<n;++e)t.push(1);e=qO(e,e.shape.concat(t))}else if(s>r){n=s-r;const e=[];for(let t=0;t<n;++t)e.push(1);t=qO(t,t.shape.concat(e))}else n=0;if(i=2===t.shape.length&&2===e.shape.length?o[0]===o[1]?zP(FP(t,e),o[0]):zP(FP(HF(t,[1,0]),e),o[1]):yP(t,e,o[0]!==t.shape.length-1,o[1]===e.shape.length-1),n>0){let t;t=r>s?r+s-3:r-1;const e=[];for(let i=t;i<t+n;++i)e.push(i);i=NF(i,e)}return 1===i.shape.length&&(i=EP(i,1)),i})}(n,r,e)}interpretAxes(t,e){let n;return n=Array.isArray(this.axes)?this.axes:[bq(this.axes,t.length),bq(this.axes,e.length)],n}computeOutputShape(t){i.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new NV("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);e.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const s=e.concat(n);return 1===s.length&&s.push(1),s}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}Aq.className="Dot",c.registerClass(Aq);class xq extends MW{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return _O(()=>{this.invokeCallHook(t,e);const n=vW(t);return VG(()=>RO(OG(n.shape,0,this.stddev),n),()=>n,e.training||!1)})}}xq.className="GaussianNoise",c.registerClass(xq);class wq extends MW{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return _O(()=>{this.invokeCallHook(t,e);const n=vW(t);return this.rate>0&&this.rate<1?VG(()=>{const t=Math.sqrt(this.rate/(1-this.rate));return FP(n,OG(n.shape,1,t))},()=>n,e.training||!1):n})}}wq.className="GaussianDropout",c.registerClass(wq);class _q extends MW{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||vW(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return _O(()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(t);return VG(()=>{const e=vW(t),i=-1.7580993408473766;let r=NP(yF(n),this.rate);r=TG(r,"float32");const s=((1-this.rate)*(1+this.rate*i**2))**-.5,o=-s*i*this.rate,a=RO(FP(e,r),FP(RO(r,-1),i));return RO(FP(a,s),o)},()=>vW(t),e.training||!1)}return t})}}function Sq(t,e,n,i,r,s=.001){let o;if(2===t.rank)o=JO(t,e,n,i,r,s);else if(3===t.rank)o=ZO(t,e,n,i,r,s);else{if(4!==t.rank)throw new NV(`batchNormalization is not implemented for array of rank ${t.rank} yet`);o=tP(t,e,n,i,r,s)}return o}_q.className="AlphaDropout",c.registerClass(_q);class Eq extends MW{constructor(t){null==t&&(t={}),super(t),this.supportsMasking=!0,this.axis=null==t.axis?-1:t.axis,this.momentum=null==t.momentum?.99:t.momentum,this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=hW(t.betaInitializer||"zeros"),this.gammaInitializer=hW(t.gammaInitializer||"ones"),this.movingMeanInitializer=hW(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=hW(t.movingVarianceInitializer||"ones"),this.betaConstraint=lG(t.betaConstraint),this.gammaConstraint=lG(t.gammaConstraint),this.betaRegularizer=fQ(t.betaRegularizer),this.gammaRegularizer=fQ(t.gammaRegularizer)}build(t){t=bW(t);const e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(null==n)throw new RV(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new SW({ndim:t.length,axes:{[e]:n}})];const i=[n];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return _O(()=>{const n=null!=e.training&&e.training,r=vW(t),s=r.shape,o=s.length,a=IG(0,o),l=this.axis>=0?this.axis:this.axis+o;a.splice(l,1);const c=DV(1,o);c[l]=s[l];const u=a.slice();u.sort();const h=!i.arraysEqual(u,IG(0,o).slice(0,o-1));if(!n)return(()=>{if(h){const t=qO(this.movingMean.read(),c),e=qO(this.movingVariance.read(),c),n=this.center?qO(this.beta.read(),c):null,i=this.scale?qO(this.gamma.read(),c):null;return Sq(r,t,e,n,i,this.epsilon)}return Sq(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[d,p,f]=function(t,e,n,r,s=.001){return i.arraysEqual(r.slice().sort(),IG(0,t.rank-1))?function(t,e,n,i,r=.001){return _O(()=>{const s=iF(t,i),o=s.mean,a=s.variance;return[Sq(t,o,a,n,e,r),o,a]})}(t,e,n,r,s):function(t,e,n,i,r=.001){return _O(()=>{const s=iF(t,i),o=s.mean,a=s.variance,l=[];for(const e of IG(0,t.rank))-1!==i.indexOf(e)?l.push(1):l.push(t.shape[e]);const c=qO(o,l),u=qO(a,l),h=null==e?null:qO(e,l),d=null==n?null:qO(n,l);return[Sq(t,c,u,d,h,r),o,a]})}(t,e,n,r,s)}(r,this.gamma.read(),this.beta.read(),a,this.epsilon),m=(t,e,n)=>{_O(()=>{const i=1-n,r=t.read(),s=FP($P(r,e),i);t.write($P(r,s))})};return(()=>{m(this.movingMean,p,this.momentum),m(this.movingVariance,f,this.momentum)})(),d})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:uW(this.betaInitializer),gammaInitializer:uW(this.gammaInitializer),movingMeanInitializer:uW(this.movingMeanInitializer),movingVarianceInitializer:uW(this.movingVarianceInitializer),betaRegularizer:dQ(this.betaRegularizer),gammaRegularizer:dQ(this.gammaRegularizer),betaConstraint:oG(this.betaConstraint),gammaConstraint:oG(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}Eq.className="BatchNormalization",c.registerClass(Eq);class Cq extends MW{constructor(t){if(null==t&&(t={}),super(t),this.axis=null==t.axis?-1:t.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=hW(t.betaInitializer||"zeros"),this.gammaInitializer=hW(t.gammaInitializer||"ones"),this.betaRegularizer=fQ(t.betaRegularizer),this.gammaRegularizer=fQ(t.gammaRegularizer),this.supportsMasking=!0}build(t){const e=(t=bW(t)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=e);for(const i of this.axis)if(i<0||i>=e)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==jV(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map(e=>t[e]);this.gamma=this.scale?this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(t,e){const n=vW(t),i=n.shape,r=i.length;return _O(()=>{let{mean:t,variance:e}=iF(n,this.axis,!0);const s=DV(1,r);for(const n of this.axis)s[n]=i[n];const o=t=>null!=t&&t.shape.length!==r&&this.axis!==[r-1]?qO(t,s):t;let a=o(this.gamma.read()),l=o(this.beta.read());const c=[],u=[];for(let n=0;n<r;++n)-1!==this.axis.indexOf(n)?(c.push(i[n]),u.push(1)):(c.push(1),u.push(i[n]));return t=CP(t,c),e=CP(e,c),a=CP(a,u),l=CP(l,u),Sq(n,t,e,l,a,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:uW(this.betaInitializer),gammaInitializer:uW(this.gammaInitializer),betaRegularizer:dQ(this.betaRegularizer),gammaRegularizer:dQ(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}Cq.className="LayerNormalization",c.registerClass(Cq);class Iq extends MW{constructor(t){if(null==t&&(t={}),super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,null==t.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof t.padding)this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new RV(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,n;if("number"==typeof t.padding[0])e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new RV(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],2!==t.padding[1].length)throw new RV(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new SW({ndim:4})]}computeOutputShape(t){let e,n;return t=bW(t),"channelsFirst"===this.dataFormat?(e=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],e,n]):(e=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],e,n,t[3]])}call(t,e){return _O(()=>{return e=vW(t),n=this.padding,i=this.dataFormat,_O(()=>{if(4!==e.rank)throw new RV(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new RV("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==i&&(i="channelsLast"),"channelsLast"!==i&&"channelsFirst"!==i)throw new RV(`Unknown data format: ${i}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let t;return t="channelsFirst"===i?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],uF(e,t)});var e,n,i})}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}function Tq(t,e,n,i,r,s){return _O(()=>{let o;mG(r),yG(s),gG(i),null==n&&(n=[1,1]),null==i&&(i="valid"),null==r&&(r="channelsLast"),null==s&&(s="max"),t=SQ(t,r);const a="same"===i?"same":"valid";return o="max"===s?VP(t,e,n,a):XO(t,e,n,a),"channelsFirst"===r&&(o=HF(o,[0,3,1,2])),o})}function Mq(t,e,n,i,r,s){return _O(()=>{let o;mG(r),yG(s),gG(i),null==n&&(n=[1,1,1]),null==i&&(i="valid"),null==r&&(r="channelsLast"),null==s&&(s="max"),t=EQ(t,r);const a="same"===i?"same":"valid";return o="max"===s?GP(t,e,n,a):YO(t,e,n,a),"channelsFirst"===r&&(o=HF(o,[0,4,1,2,3])),o})}Iq.className="ZeroPadding2D",c.registerClass(Iq);class kq extends MW{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new RV(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if(YV(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new RV(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}YV(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,gG(this.padding),this.inputSpec=[new SW({ndim:3})]}computeOutputShape(t){const e=wQ((t=bW(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return _O(()=>{this.invokeCallHook(t,e),t=MG(vW(t),2);const n=this.poolingFunction(vW(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return NF(n,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class Rq extends kq{constructor(t){super(t)}poolingFunction(t,e,n,i,r){return mG(r),gG(i),Tq(t,e,n,i,r,"max")}}Rq.className="MaxPooling1D",c.registerClass(Rq);class Nq extends kq{constructor(t){super(t)}poolingFunction(t,e,n,i,r){return mG(r),gG(i),Tq(t,e,n,i,r,"avg")}}Nq.className="AveragePooling1D",c.registerClass(Nq);class Lq extends MW{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new RV(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];YV(this.poolSize,"poolSize"),YV(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,mG(this.dataFormat),gG(this.padding),this.inputSpec=[new SW({ndim:4})]}computeOutputShape(t){t=bW(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2];return e=wQ(e,this.poolSize[0],this.padding,this.strides[0]),n=wQ(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return _O(()=>(this.invokeCallHook(t,e),this.poolingFunction(vW(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class Dq extends Lq{constructor(t){super(t)}poolingFunction(t,e,n,i,r){return mG(r),gG(i),Tq(t,e,n,i,r,"max")}}Dq.className="MaxPooling2D",c.registerClass(Dq);class Bq extends Lq{constructor(t){super(t)}poolingFunction(t,e,n,i,r){return mG(r),gG(i),Tq(t,e,n,i,r,"avg")}}Bq.className="AveragePooling2D",c.registerClass(Bq);class Oq extends MW{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new RV(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];YV(this.poolSize,"poolSize"),YV(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,mG(this.dataFormat),gG(this.padding),this.inputSpec=[new SW({ndim:5})]}computeOutputShape(t){t=bW(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],i="channelsFirst"===this.dataFormat?t[4]:t[3];return e=wQ(e,this.poolSize[0],this.padding,this.strides[0]),n=wQ(n,this.poolSize[1],this.padding,this.strides[1]),i=wQ(i,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n,i]:[t[0],e,n,i,t[4]]}call(t,e){return _O(()=>(this.invokeCallHook(t,e),this.poolingFunction(vW(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class Pq extends Oq{constructor(t){super(t)}poolingFunction(t,e,n,i,r){return mG(r),gG(i),Mq(t,e,n,i,r,"max")}}Pq.className="MaxPooling3D",c.registerClass(Pq);class Fq extends Oq{constructor(t){super(t)}poolingFunction(t,e,n,i,r){return mG(r),gG(i),Mq(t,e,n,i,r,"avg")}}Fq.className="AveragePooling3D",c.registerClass(Fq);class $q extends MW{constructor(t){super(t),this.inputSpec=[new SW({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new NV}}class zq extends $q{constructor(t){super(t||{})}call(t,e){return _O(()=>{const e=vW(t);return jP(e,1)})}}zq.className="GlobalAveragePooling1D",c.registerClass(zq);class Uq extends $q{constructor(t){super(t||{})}call(t,e){return _O(()=>{const e=vW(t);return PP(e,1)})}}Uq.className="GlobalMaxPooling1D",c.registerClass(Uq);class Hq extends MW{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,mG(this.dataFormat),this.inputSpec=[new SW({ndim:4})]}computeOutputShape(t){return t=t,"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new NV}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class Vq extends Hq{call(t,e){return _O(()=>{const e=vW(t);return jP(e,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}Vq.className="GlobalAveragePooling2D",c.registerClass(Vq);class Gq extends Hq{call(t,e){return _O(()=>{const e=vW(t);return PP(e,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}Gq.className="GlobalMaxPooling2D",c.registerClass(Gq);class Wq extends MW{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,n={}){const i=VW(e.layer,n);delete e.layer;const r={layer:i};return Object.assign(r,e),new t(r)}}class jq extends Wq{constructor(t){super(t),this.supportsMasking=!0}build(t){if((t=bW(t)).length<3)throw new RV(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){const e=[(t=bW(t))[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e);return[n[0],t[1]].concat(n.slice(1))}call(t,e){return _O(()=>zQ((t,n)=>[vW(this.layer.call(t,e)),[]],t=vW(t),[],!1,null,null,!1,!0)[1])}}jq.className="TimeDistributed",c.registerClass(jq);class Qq extends Wq{constructor(t){super(t);const e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=VW(n),e.goBackwards=!0!==e.goBackwards;const i={};if(i.className=t.layer.getClassName(),i.config=e,this.backwardLayer=VW(i),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===t.mergeMode?"concat":t.mergeMode,qV(pG,"BidirectionalMergeMode",this.mergeMode),t.weights)throw new NV("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=Math.floor(t.length/2);this.forwardLayer.setWeights(t.slice(0,e)),this.backwardLayer.setWeights(t.slice(e))}computeOutputShape(t){let e,n,i,r=this.forwardLayer.computeOutputShape(t);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),r=r,this.returnState?(i=r.slice(1),e=r[0]):e=r[0],e=e,"concat"===this.mergeMode?(e[e.length-1]*=2,n=[e]):n=null==this.mergeMode?[e,e.slice()]:[e],this.returnState?null==this.mergeMode?n.concat(i).concat(i.slice()):[e].concat(i).concat(i.slice()):PV(n)}apply(t,e){let n=null==e?null:e.initialState,i=null==e?null:e.constants;null==e&&(e={});const r=$Q(t,n,i,this.numConstants);if(t=r.inputs,n=r.initialState,i=r.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(null==n||0===n.length)&&null==i)return super.apply(t,e);const s=[],o=[];if(null!=n){const t=n.length;if(t%2>0)throw new RV("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,s.push(...n);const i=n.map(t=>new SW({shape:t.shape}));this.forwardLayer.stateSpec=i.slice(0,t/2),this.backwardLayer.stateSpec=i.slice(t/2),o.push(...i)}if(null!=i)throw new NV("Support for constants in Bidirectional layers is not implemented yet.");const a=s[0]instanceof EW;for(const l of s)if(l instanceof EW!==a)throw new RV("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(a){const n=[t].concat(s),i=this.inputSpec.concat(o),r=this.inputSpec;this.inputSpec=i;const a=super.apply(n,e);return this.inputSpec=r,a}return super.apply(t,e)}call(t,e){return _O(()=>{const n=e.initialState;let i,r,s,o;if(null==n)i=this.forwardLayer.call(t,e),r=this.backwardLayer.call(t,e);else{const s=n.slice(0,n.length/2),o=n.slice(n.length/2);i=this.forwardLayer.call(t,Object.assign(e,{initialState:s})),r=this.backwardLayer.call(t,Object.assign(e,{initialState:o}))}return this.returnState&&(Array.isArray(i)&&(s=i.slice(1).concat(r.slice(1))),i=i[0],r=r[0]),this.returnSequences&&(r=bF(r,1)),"concat"===this.mergeMode?o=LG([i,r]):"sum"===this.mergeMode?o=RO(i,r):"ave"===this.mergeMode?o=FP(.5,RO(i,r)):"mul"===this.mergeMode?o=FP(i,r):null==this.mergeMode&&(o=[i,r]),this.returnState?null==this.mergeMode?o.concat(s):[o].concat(s):o})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){bG(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),bG(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){let n;if(Array.isArray(e)&&(e=e[0]),n=this.returnSequences?null==this.mergeMode?[e,e]:e:null==this.mergeMode?[null,null]:null,this.returnState){const t=this.forwardLayer.states.map(t=>null);return Array.isArray(n)?n.concat(t).concat(t):[n].concat(t).concat(t)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const n=VW(e.layer);if(delete e.layer,null!=e.numConstants)throw new NV("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const i=e;return i.layer=n,new t(i)}}Qq.className="Bidirectional",c.registerClass(Qq),function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(KQ||(KQ={})),function(t){let e;!function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(e=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))}(JQ||(JQ={}));const qq=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Xq=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Yq=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],Kq=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Jq=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Zq=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],tX=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],eX=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],nX=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],iX=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],rX=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],sX=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],oX=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],aX=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],lX=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],cX=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],uX=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],hX=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],dX=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}];LD({addN_:function(t){_M(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),_M(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const e=t.map((t,e)=>RD(t,`tensors${e}`,"addN")),n=e[0];return e.forEach(t=>{if(t.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(t=>{if(!MM(t.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),_D.runKernel(Ak,e)}}),LD({maxPoolWithArgmax_:function(t,e,n,i,r=!1){const s=RD(t,"x","maxPoolWithArgmax"),o=_D.runKernel(YR,{x:s},{filterSize:e,strides:n,pad:i,includeBatchInIndex:r});return{result:o[0],indexes:o[1]}}}),LD({multinomial_:function(t,e,n,i=!1){const r=RD(t,"logits","multinomial"),s=r.size,o=r.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);n=n||Math.random();const a=1===o?qO(r,[1,-1]):r,l=_D.runKernel(nN,{logits:a},{numSamples:e,seed:n,normalized:i});return 1===o?qO(l,[l.size]):l}}),LD({einsum_:function(t,...e){const n=e.map((t,e)=>RD(t,`tensors${e}`,"einsum"));return _D.runKernel(cR,n,{equation:t})}}),LD({sparseToDense_:function(t,e,n,i=0){const r=RD(t,"sparseIndices","sparseToDense","int32"),s=RD(e,"sparseValues","sparseToDense"),o=RD(i,"defaultValue","sparseToDense",s.dtype);return function(t,e,n,i){if("int32"!==t.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const r=t.rank>0?t.shape[0]:1,s=t.rank>1?t.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);if(0!==e.rank&&(1!==e.rank||e.size!==r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==i.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(r,s,n,o),_D.runKernel(QN,{sparseIndices:r,sparseValues:s,defaultValue:o},{outputShape:n})}}),LD({denseBincount_:function(t,e,n,i=!1){const r=RD(t,"x","denseBincount"),s=RD(e,"weights","denseBincount");return _M("int32"===r.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),_M(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),_M(n>=0,()=>`size must be non-negative, but got ${n}.`),_M(s.size===r.size||0===s.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${s.shape}.`),_D.runKernel(Zk,{x:r,weights:s},{size:n,binaryOutput:i})}}),LD({scatterND_:function(t,e,n){const i=RD(t,"indices","scatterND","int32"),r=RD(e,"updates","scatterND");return yz(r,i,n),_D.runKernel(MN,{indices:i,updates:r},{shape:n})}}),LD({gatherND_:function(t,e){const n=RD(e,"indices","gatherND","int32"),i=RD(t,"x","gatherND","string_or_numeric");return _D.runKernel(SR,{params:i,indices:n})}});var pX,fX=n("YSVl");function mX(t,e,n=new Map,i=new Set){if(null==t)return null;if(i.has(t))throw new Error("Circular references are not supported.");if(n.has(t))return n.get(t);const r=e(t);if(r.recurse&&null!==r.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse){if(bX(t)){const r=Array.isArray(t)?[]:{};i.add(t);for(const s in t){const o=mX(t[s],e,n,i);r[s]=o}return i.delete(t),r}throw new Error(`Can't recurse into non-iterable type: ${t}`)}return n.set(t,r.value),r.value}function gX(t,e=vX){return yX(t,e)}function yX(t,e,n=new Set){const i=t[0];if(n.has(i))throw new Error("Circular references are not supported.");const r=e(t);if(r.recurse&&null!==r.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse){if(bX(i)){const r=Array.isArray(i)?[]:{};n.add(i);for(const s in i){const i=yX(t.map(t=>t[s]),e,n);r[s]=i}return n.delete(i),r}throw new Error(`Can't recurse into non-iterable type: ${i}`)}return r.value}function vX(t){return null===t?null:bX(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}function bX(t){return null!=t&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||"object"==typeof t&&!(t instanceof iD))}function AX(t){return mX(t,xX)}function xX(t){return t instanceof iD?{value:t.clone(),recurse:!1}:bX(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}class wX{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}}class _X extends wX{constructor(){super(_X.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){const t=2*this.capacity,e=new Array(t),n=this.length();for(let i=0;i<n;i++)e[i]=this.get(this.wrap(this.begin+i));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}_X.INITIAL_CAPACITY=32;class SX{async toArray(){const t=[];let e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){const t=this.prefetch(100),e=[];let n=await t.next();for(;!n.done;)e.push(n.value),n=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),n=t(e.value);for(;!e.done&&n;)e=await this.next(),n=t(e.value)}handleErrors(t){return new LX(this,t)}filter(t){return new RX(this,t)}map(t){return new NX(this,t)}mapAsync(t){return new DX(this,t)}serialMapAsync(t){return new DX(this,t).serial()}flatmap(t){return new OX(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile(t=>!0===t)}rowMajorBatch(t,e=!0){return new kX(this,t,e)}columnMajorBatch(t,e=!0,n=vX){return this.rowMajorBatch(t,e).map(t=>gX(t,n))}concatenate(t,e){return new PX(new EX([this,t]),e)}take(t){return t<0||null==t?this:new MX(this,t)}skip(t){return t<0||null==t?this:new TX(this,t)}prefetch(t){return new FX(this,t)}shuffle(t,e){return new $X(this,t,e)}serial(){return new IX(this)}}class EX extends SX{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const t=this.items[this.trav];return this.trav++,{value:AX(t),done:!1}}}class CX extends SX{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}}}class IX extends SX{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class TX extends SX{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const t=await this.upstream.next();if(t.done)return t;SO(t.value)}return this.upstream.next()}}class MX extends SX{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class kX extends SX{constructor(t,e,n=!0){super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const t=[];for(;t.length<this.batchSize;){const e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}}class RX extends SX{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;SO(t.value)}}}class NX extends SX{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Map`}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=r.getTensorsInContainer(t.value),n=this.transform(t.value),i=r.getTensorsInContainer(n);for(const s of e)r.isTensorInList(s,i)||s.dispose();return{value:n,done:!1}}}class LX extends SX{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}}class DX extends SX{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=r.getTensorsInContainer(t.value),n=await this.transform(t.value),i=r.getTensorsInContainer(n);for(const s of e)r.isTensorInList(s,i)||s.dispose();return{value:n,done:!1}}}class BX extends SX{constructor(){super(),this.outputQueue=new _X,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!(await this.pump()))return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class OX extends BX{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const t=await this.upstream.next();if(t.done)return!1;const e=r.getTensorsInContainer(t.value),n=this.transform(t.value),i=r.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(const s of e)r.isTensorInList(s,i)||s.dispose();return!0}}class PX extends SX{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,null==this.iterator){const t=await this.moreIterators.next();if(t.done)return{value:null,done:!0};this.iterator=t.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}}!function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"}(pX||(pX={}));class FX extends SX{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new wX(e)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class $X extends FX{constructor(t,e,n){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=fX.alea(n||i.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(!e.done)return this.refill(),e;this.upstreamExhausted=!0}return{value:null,done:!0}}}class zX{constructor(){this.size=null}batch(t,e=!0){const n=this;let r;return i.assert(t>0,()=>`batchSize needs to be positive, but it is\n      ${t}`),r=this.size===1/0||null==this.size?this.size:e?Math.ceil(this.size/t):Math.floor(this.size/t),UX(async()=>(await n.iterator()).columnMajorBatch(t,e,HX),r)}concatenate(t){const e=this;let n;return n=this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null,UX(async()=>(await e.iterator()).concatenate(await t.iterator()),n)}filter(t){const e=this;let n;return n=this.size===1/0?1/0:null,UX(async()=>(await e.iterator()).filter(e=>_O(()=>t(e))),n)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){const e=this;return UX(async()=>(await e.iterator()).map(e=>_O(()=>t(e))),this.size)}mapAsync(t){const e=this;return UX(async()=>(await e.iterator()).mapAsync(t),this.size)}prefetch(t){if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const e=this;return UX(async()=>(await e.iterator()).prefetch(t),this.size)}repeat(t){const e=this;let n;return n=null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null,UX(async()=>{return n=(i=async()=>({value:await e.iterator(),done:!1}),new CX(i)).take(t),new PX(n,undefined);var n,i},n)}skip(t){const e=this;let n;return n=null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null,UX(async()=>(await e.iterator()).skip(t),n)}shuffle(t,e,n=!0){if(null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,s=fX.alea(e||i.now().toString());return UX(async()=>{let e=s.int32();return n&&(e+=s.int32()),(await r.iterator()).shuffle(t,e.toString())},this.size)}take(t){const e=this;let n;return n=null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null,UX(async()=>(await e.iterator()).take(t),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function UX(t,e=null){return new class extends zX{constructor(){super(...arguments),this.size=e}async iterator(){return t()}}}function HX(t){return null===t?null:null==(e=t[0])||null===(n=e)||"object"!=typeof n&&"function"!=typeof n||Array.isArray(e)||"object"==typeof e&&e instanceof iD||i.isTypedArray(e)?{value:function(t){if(0===t.length)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof iD?LF(t):OD(t)}(t),recurse:!1}:{value:null,recurse:!0};var e,n}function VX(t,e){Array.isArray(t)||(t=[t]),t.forEach(t=>{null!=t&&i.assert("complex64"!==t.dtype,()=>`${e} does not support complex64 tensors in the CPU backend.`)})}zX.MAX_BUFFER_SIZE=1e4,Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const GX=p.whereImpl;class WX extends pM{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new dM(this,xO())}nextDataId(){return WX.nextDataId++}write(t,e,n){this.firstUse&&(this.firstUse=!1,hk().get("IS_NODE")&&d.warn("\n============================\nHi there \ud83d\udc4b. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const i={id:this.nextDataId()};return this.data.set(i,{values:t,dtype:n,refCount:1}),i}makeTensorInfo(t,e,n){let r;if("string"===e&&null!=n&&n.length>0&&i.isString(n[0])){const s=n.map(t=>i.encodeString(t));r=this.write(s,t,e)}else r=this.write(n,t,e);return{dataId:r,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){this.data.get(t).refCount++}decRef(t){this.data.has(t)&&this.data.get(t).refCount--}move(t,e,n,i,r){this.data.set(t,{values:e,dtype:i,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensorInfos:n}=this.data.get(t);if("complex64"===e){const t=this.readSync(n.real.dataId),e=this.readSync(n.imag.dataId);return d.mergeRealAndImagArrays(t,e)}return this.data.get(t).values}bufferSync(t){const e=this.readSync(t.dataId);let n=e;if("string"===t.dtype)try{n=e.map(t=>i.decodeString(t))}catch(GTt){throw new Error("Failed to decode encoded string bytes into utf-8")}return RB(t.shape,t.dtype,n)}makeOutput(t,e,n){const i=this.write(t,e,n);return xO().makeTensorFromDataId(i,e,n,this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(t);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const e=i.now();return t(),{kernelMs:i.now()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){VX([t],"where");const e=this.readSync(t.dataId);return GX(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}function jX(t,e,n){return({inputs:r,attrs:s,backend:o})=>{const{x:a}=r;if(VX(a,t),"string"===a.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const l=o,c=l.data.get(a.dataId).values,u=i.sizeFromShape(a.shape),h=n||a.dtype,d=i.getArrayFromDType(h,u);for(let t=0;t<u;++t)d[t]=e(c[t],s);return l.makeTensorInfo(a.shape,h,d)}}function QX(t,e,n){return({inputs:i,attrs:r,backend:s})=>{const{x:o}=i;if(VX(o,t),"string"===o.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const a=s,l=a.data.get(o.dataId).values,c=n||o.dtype,u=e(l,c,r);return a.makeTensorInfo(o.shape,c,u)}}WX.nextDataId=0,CO("cpu",()=>new WX,1);const qX=jX(uR,t=>t>=0?t:Math.exp(t)-1),XX={kernelName:uR,backendName:"cpu",kernelFunc:qX};function YX(t){const{inputs:e,backend:n}=t,{x:i}=e;return n.incRef(i.dataId),{dataId:i.dataId,shape:i.shape,dtype:i.dtype}}const KX={kernelName:IR,backendName:"cpu",kernelFunc:YX};function JX(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{alpha:o}=r;VX([s],"leakyRelu");const a=i.sizeFromShape(s.shape),l=n.data.get(s.dataId).values,c=i.getTypedArrayFromDType("float32",a);for(let i=0;i<l.length;i++)c[i]=l[i]<0?o*l[i]:l[i];return n.makeTensorInfo(s.shape,"float32",c)}const ZX={kernelName:LR,backendName:"cpu",kernelFunc:JX};function tY(t){return(e,n,r,s,o)=>{const a=d.assertAndGetBroadcastShape(e,n),l=a.length,c=i.computeStrides(a),u=i.sizeFromShape(a),h=i.getTypedArrayFromDType(o,u),p=e.length,f=n.length,m=i.computeStrides(e),g=i.computeStrides(n),y=d.getBroadcastDims(e,a),v=d.getBroadcastDims(n,a);if(y.length+v.length===0)for(let i=0;i<h.length;++i)h[i]=t(r[i%r.length],s[i%s.length]);else for(let d=0;d<h.length;++d){const e=i.indexToLoc(d,l,c),n=e.slice(-p);y.forEach(t=>n[t]=0);const o=i.locToIndex(n,p,m),a=e.slice(-f);v.forEach(t=>a[t]=0);const u=i.locToIndex(a,f,g);h[d]=t(r[o],s[u])}return[h,a]}}const eY=tY((t,e)=>t<0?e*t:t);function nY(t){const{inputs:e,backend:n}=t,{x:i,alpha:r}=e;VX([i,r],"prelu");const s=n.data.get(i.dataId).values,o=n.data.get(r.dataId).values,[a,l]=eY(i.shape,r.shape,s,o,i.dtype);return n.makeTensorInfo(l,i.dtype,a)}const iY={kernelName:fN,backendName:"cpu",kernelFunc:nY},rY=jX(bN,t=>Math.max(0,t)),sY={kernelName:bN,backendName:"cpu",kernelFunc:rY},oY=jX(EN,t=>Math.min(Math.max(0,t),6)),aY={kernelName:EN,backendName:"cpu",kernelFunc:oY},lY=jX(ON,t=>1/(1+Math.exp(-t))),cY={kernelName:ON,backendName:"cpu",kernelFunc:lY};function uY(t,e,n,i,r){if("linear"===n)return YX({inputs:{x:e},backend:t});if("relu"===n)return rY({inputs:{x:e},backend:t});if("elu"===n)return qX({inputs:{x:e},backend:t});if("relu6"===n)return oY({inputs:{x:e},backend:t});if("prelu"===n)return nY({inputs:{x:e,alpha:i},backend:t});if("leakyrelu"===n)return JX({inputs:{x:e},backend:t,attrs:{alpha:r}});if("sigmoid"===n)return lY({inputs:{x:e},backend:t});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function hY(t){const{inputs:e,backend:n}=t,{real:i,imag:r}=e,s=n.data.get(i.dataId).values,o=n.data.get(r.dataId).values,a=n.makeTensorInfo(i.shape,"complex64");return n.data.get(a.dataId).complexTensorInfos={real:n.makeTensorInfo(i.shape,"float32",s),imag:n.makeTensorInfo(r.shape,"float32",o)},a}const dY={kernelName:zk,backendName:"cpu",kernelFunc:hY};function pY(t,e,n="float32"){if("complex64"===n)return hY({inputs:{real:pY(t,e,"float32"),imag:pY(t,e,"float32")},backend:t});const r=i.makeZerosTypedArray(i.sizeFromShape(e),n);return t.makeTensorInfo(e,n,r)}function fY(t){const{inputs:e,backend:n}=t,{input:i}=e,r=n.data.get(i.dataId).complexTensorInfos.real,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}const mY={kernelName:yN,backendName:"cpu",kernelFunc:fY};function gY(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return YX({inputs:{x:s},backend:n});const t=pY(n,s.shape,s.dtype),e=gY({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),i=hY({inputs:{real:e,imag:t},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),i}if("complex64"===s.dtype){const t=fY({inputs:{input:s},backend:n}),e=gY({inputs:{x:t},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(t),e}if(!i.hasEncodingLoss(s.dtype,o)){const t=YX({inputs:{x:s},backend:n});return{dataId:t.dataId,shape:t.shape,dtype:o}}if("int32"===o){const t=n.data.get(s.dataId).values,e=Int32Array.from(t);return n.makeTensorInfo(s.shape,"int32",e)}if("bool"===o){const t=n.data.get(s.dataId).values,e=i.toTypedArray([0],s.dtype),[r,o]=tY((t,e)=>t!==e?1:0)(s.shape,[],t,e,"bool");return n.makeTensorInfo(o,"bool",r)}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}const yY={kernelName:Pk,backendName:"cpu",kernelFunc:gY};function vY(t,e,n,i){return null==n?({inputs:n,backend:r})=>{const{a:s,b:o}=n,a=r;VX([s,o],t);const l=a.data.get(s.dataId).values,c=a.data.get(o.dataId).values,u="string"===s.dtype?d.fromUint8ToStringArray(l):l,h="string"===s.dtype?d.fromUint8ToStringArray(c):c,p=i||s.dtype,[f,m]=e(s.shape,o.shape,u,h,p);return a.makeTensorInfo(m,p,f)}:({inputs:t,backend:r})=>{const{a:s,b:o}=t,a=r;if("complex64"===s.dtype||"complex64"===o.dtype){const t=gY({inputs:{x:s},backend:a,attrs:{dtype:"complex64"}}),e=a.data.get(t.dataId),i=e.complexTensorInfos.imag,r=a.data.get(e.complexTensorInfos.real.dataId).values,l=a.data.get(i.dataId).values,c=gY({inputs:{x:o},backend:a,attrs:{dtype:"complex64"}}),u=a.data.get(c.dataId),h=u.complexTensorInfos.imag,d=a.data.get(u.complexTensorInfos.real.dataId).values,p=a.data.get(h.dataId).values,[f,m,g]=n(s.shape,o.shape,r,l,d,p),y=a.makeTensorInfo(g,"float32",f),v=a.makeTensorInfo(g,"float32",m),b=hY({inputs:{real:y,imag:v},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(c),a.disposeIntermediateTensorInfo(y),a.disposeIntermediateTensorInfo(v),b}{const t=a.data.get(s.dataId).values,n=a.data.get(o.dataId).values,r=i||s.dtype,[l,c]=e(s.shape,o.shape,t,n,r);return a.makeTensorInfo(c,r,l)}}}function bY(t){return(e,n,r,s,o,a)=>{const l=d.assertAndGetBroadcastShape(e,n),c=i.sizeFromShape(l),u=l.length,h=i.computeStrides(l),p=i.getTypedArrayFromDType("float32",c),f=i.getTypedArrayFromDType("float32",c),m=d.getBroadcastDims(e,l),g=d.getBroadcastDims(n,l),y=d.mergeRealAndImagArrays(r,s),v=d.mergeRealAndImagArrays(o,a),b=e.length,A=i.computeStrides(e),x=n.length,w=i.computeStrides(n);if(m.length+g.length===0)for(let i=0;i<p.length;i++){const e=i%y.length,n=i%v.length,r=t(y[2*e],y[2*e+1],v[2*n],v[2*n+1]);p[i]=r.real,f[i]=r.imag}else for(let d=0;d<p.length;d++){const e=i.indexToLoc(d,u,h),n=e.slice(-b);m.forEach(t=>n[t]=0);const r=i.locToIndex(n,b,A),s=e.slice(-x);g.forEach(t=>s[t]=0);const o=i.locToIndex(s,x,w),a=t(y[2*r],y[2*r+1],v[2*o],v[2*o+1]);p[d]=a.real,f[d]=a.imag}return[p,f,l]}}const AY=tY((t,e)=>t+e),xY=bY((t,e,n,i)=>({real:t+n,imag:e+i})),wY=vY(bk,AY,xY),_Y={kernelName:bk,backendName:"cpu",kernelFunc:wY};function SY(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{shape:o}=r,a=i.sizeFromShape(s.shape),l=i.inferFromImplicitShape(o,a),c=i.sizeFromShape(l);i.assert(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),n.incRef(s.dataId);const u=n.data.get(s.dataId);if(null!=u.complexTensorInfos){const t=u.complexTensorInfos.imag;u.complexTensorInfos.real.shape=l,t.shape=l}return{dataId:s.dataId,shape:l,dtype:s.dtype}}const EY={kernelName:AN,backendName:"cpu",kernelFunc:SY};function CY(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:o}=e,{transposeA:a,transposeB:l}=r;VX([s,o],"matMul");const c=s.shape.length,u=o.shape.length,h=a?s.shape[c-2]:s.shape[c-1],d=l?o.shape[u-1]:o.shape[u-2],p=a?s.shape[c-1]:s.shape[c-2],f=l?o.shape[u-2]:o.shape[u-1],m=s.shape.slice(0,-2),g=o.shape.slice(0,-2),y=i.sizeFromShape(m),v=i.sizeFromShape(g);i.assert(c>=2&&u>=2&&(y===v||1===y||1===v),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${m}) and (${g}).`);const b=(y>v?s.shape.slice(0,-2):o.shape.slice(0,-2)).concat([p,f]);i.assert(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${s.shape} and ${o.shape} and transposeA=${a} and transposeB=${l} must match.`);const A=l?[v,f,d]:[v,d,f],x=SY({inputs:{x:s},backend:n,attrs:{shape:a?[y,h,p]:[y,p,h]}}),w=SY({inputs:{x:o},backend:n,attrs:{shape:A}}),_=a?x.shape[1]:x.shape[2],S=a?x.shape[2]:x.shape[1],E=l?w.shape[1]:w.shape[2],C=Math.max(y,v),I=n.data.get(x.dataId).values,T=n.data.get(w.dataId).values,M=i.computeStrides(x.shape),k=i.computeStrides(w.shape),[R,N,L]=a?[M[0],1,M[1]]:[M[0],M[1],1],[D,B,O]=l?[1,k[1],k[0]]:[k[1],1,k[0]],P=S*E,F=RB([C,S,E],x.dtype),$=F.values,z=n.blockSize;for(let i=0;i<C;i++)for(let t=0;t<S;t+=z)for(let e=0;e<E;e+=z)for(let n=0;n<_;n+=z){const r=Math.min(t+z,S),s=Math.min(e+z,E),o=Math.min(n+z,_);for(let a=t;a<r;a++)for(let t=e;t<s;t++){let e=0;for(let r=n;r<o;r++){const n=Math.min(i,y-1)*R,s=Math.min(i,v-1)*O;e+=I[n+a*N+r*L]*T[r*D+t*B+s]}$[i*P+(a*E+t)]+=e}}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(b,F.dtype,F.values)}const IY={kernelName:Dk,backendName:"cpu",kernelFunc:CY},TY={kernelName:fL,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{a:r,b:s,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=i;let d,p,f;const m=[];d=CY({inputs:{a:r,b:s},attrs:{transposeA:l,transposeB:c},backend:n}),o&&(p=wY({inputs:{a:d,b:o},backend:n}),m.push(d),d=p),u&&(f=uY(n,d,u,a,h),m.push(d),d=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return d}};function MY(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}const kY={kernelName:gk,backendName:"cpu",kernelFunc:t=>{const{x:e}=t.inputs,n=t.backend;VX(e,"abs");let r=new Float32Array(i.sizeFromShape(e.shape));return r=MY(n.data.get(e.dataId).values),n.makeOutput(r,e.shape,"float32")}},RY=jX(yk,t=>Math.acos(t)),NY={kernelName:yk,backendName:"cpu",kernelFunc:RY},LY=jX(vk,t=>Math.acosh(t)),DY={kernelName:vk,backendName:"cpu",kernelFunc:LY},BY={kernelName:Ak,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,i=e;VX(e,"addN");const r=i.map(t=>n.data.get(t.dataId).values),s=RB(i[0].shape,i[0].dtype),o=s.values;for(let a=0;a<i.length;a++){const t=r[a];for(let e=0;e<o.length;e++)o[e]+=t[e]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}};function OY(t,e,n,r,s){const o=e.length,a=i.sizeFromShape(e),l=i.computeStrides(e),c=i.computeStrides(s),u=i.getTypedArrayFromDType(n,i.sizeFromShape(s));for(let h=0;h<a;++h){const e=i.indexToLoc(h,o,l),n=new Array(e.length);for(let t=0;t<n.length;t++)n[t]=e[r[t]];u[i.locToIndex(n,o,c)]=t[h]}return u}function PY(t){const{inputs:e,attrs:n,backend:i}=t,{x:r}=e,{perm:s}=n;VX(r,"transpose");const o=new Array(r.shape.length);for(let l=0;l<o.length;l++)o[l]=r.shape[s[l]];const a=OY(i.data.get(r.dataId).values,r.shape,r.dtype,s,o);return{dataId:i.write(a,o,r.dtype),shape:o,dtype:r.dtype}}const FY={kernelName:oL,backendName:"cpu",kernelFunc:PY},$Y={kernelName:xk,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:a}=r;VX(s,"all");const l=i.parseAxisParam(o,s.shape);let c=l;const u=d.getAxesPermutation(c,s.shape.length);let h=s;null!=u&&(h=PY({inputs:{x:s},backend:n,attrs:{perm:u}}),c=d.getInnerMostAxes(c.length,s.shape.length)),d.assertAxesAreInnerMostDims("all",c,h.shape.length);const[p,f]=d.computeOutAndReduceShapes(h.shape,c),m=i.sizeFromShape(f),g=i.makeZerosTypedArray(i.sizeFromShape(p),h.dtype),y=n.data.get(h.dataId).values;for(let i=0;i<g.length;++i){const t=i*m;let e=y[t];for(let n=0;n<m;++n){const i=y[t+n];e=e&&i}g[i]=e}null!=u&&n.disposeIntermediateTensorInfo(h);const v=n.makeTensorInfo(p,h.dtype,g);if(a){const t=SY({inputs:{x:v},backend:n,attrs:{shape:d.expandShapeToKeepDim(p,l)}});return n.disposeIntermediateTensorInfo(v),t}return v}},zY={kernelName:wk,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:a}=r;VX(s,"any");const l=i.parseAxisParam(o,s.shape);let c=l;const u=d.getAxesPermutation(c,s.shape.length);let h=s;null!=u&&(h=PY({inputs:{x:s},backend:n,attrs:{perm:u}}),c=d.getInnerMostAxes(c.length,s.shape.length)),d.assertAxesAreInnerMostDims("any",c,h.shape.length);const[p,f]=d.computeOutAndReduceShapes(h.shape,c),m=i.sizeFromShape(f),g=i.makeZerosTypedArray(i.sizeFromShape(p),h.dtype),y=n.data.get(h.dataId).values;for(let i=0;i<g.length;++i){const t=i*m;let e=y[t];for(let n=0;n<m;++n){const i=y[t+n];e=e||i}g[i]=e}null!=u&&n.disposeIntermediateTensorInfo(h);const v=n.makeTensorInfo(p,h.dtype,g);if(a){const t=SY({inputs:{x:v},backend:n,attrs:{shape:d.expandShapeToKeepDim(p,l)}});return n.disposeIntermediateTensorInfo(v),t}return v}},UY={kernelName:_k,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o}=r;VX(s,"argMax");let a=i.parseAxisParam(o,s.shape);const l=d.getAxesPermutation(a,s.shape.length);let c=s;const u=[];null!=l&&(c=PY({inputs:{x:s},backend:n,attrs:{perm:l}}),u.push(c),a=d.getInnerMostAxes(a.length,c.shape.length)),a=[a[0]],d.assertAxesAreInnerMostDims("argMax",a,c.shape.length);const[h,p]=d.computeOutAndReduceShapes(c.shape,a),f=i.sizeFromShape(h),m=i.makeZerosTypedArray(f,"int32"),g=i.sizeFromShape(p),y=n.data.get(c.dataId).values;for(let i=0;i<m.length;++i){const t=i*g;let e=y[t],n=0;for(let i=0;i<g;++i){const r=y[t+i];r>e&&(e=r,n=i)}m[i]=n}return u.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.makeTensorInfo(h,"int32",m)}},HY={kernelName:Sk,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o}=r;VX(s,"argMin");let a=i.parseAxisParam(o,s.shape);const l=d.getAxesPermutation(a,s.shape.length);let c=s;const u=[];null!=l&&(c=PY({inputs:{x:s},backend:n,attrs:{perm:l}}),u.push(c),a=d.getInnerMostAxes(a.length,c.shape.length)),a=[a[0]],d.assertAxesAreInnerMostDims("argMin",a,c.shape.length);const[h,p]=d.computeOutAndReduceShapes(c.shape,a),f=i.sizeFromShape(h),m=i.makeZerosTypedArray(f,"int32"),g=i.sizeFromShape(p),y=n.data.get(c.dataId).values;for(let i=0;i<m.length;++i){const t=i*g;let e=y[t],n=0;for(let i=0;i<g;++i){const r=y[t+i];r<e&&(e=r,n=i)}m[i]=n}return u.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.makeTensorInfo(h,"int32",m)}},VY=jX(Ek,t=>Math.asin(t)),GY={kernelName:Ek,backendName:"cpu",kernelFunc:VY},WY=jX(Ck,t=>Math.asinh(t)),jY={kernelName:Ck,backendName:"cpu",kernelFunc:WY},QY=jX(Ik,t=>Math.atan(t)),qY={kernelName:Ik,backendName:"cpu",kernelFunc:QY},XY=tY((t,e)=>Math.atan2(t,e)),YY=vY(Mk,XY),KY={kernelName:Mk,backendName:"cpu",kernelFunc:YY},JY=jX(Tk,t=>Math.atanh(t)),ZY={kernelName:Tk,backendName:"cpu",kernelFunc:JY};function tK(t,e,n,i,r,s){const o=r.strideHeight,a=r.strideWidth,l=r.dilationHeight,c=r.dilationWidth,u=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=RB(r.outShape,n),g=m.values,y=r.outShape[1]*r.outShape[2]*r.outShape[3],v=r.outShape[2]*r.outShape[3],b=r.outShape[3];for(let A=0;A<r.batchSize;++A){const e=A*y,n=A*i[0];for(let m=0;m<r.inChannels;++m)for(let y=0;y<r.outHeight;++y){const A=y*o-d,x=Math.max(0,A),w=Math.min(r.inHeight,u+A),_=e+y*v;for(let e=0;e<r.outWidth;++e){const o=e*a-p,u=Math.max(0,o),d=Math.min(r.inWidth,h+o);let y=f,v=0,A=0;for(let e=x;e<w;e+=l){const r=n+e*i[1];for(let e=u;e<d;e+=c){const n=t[r+e*i[2]+m];"max"===s&&n>y?y=n:"avg"===s&&(v+=n,A++)}if(isNaN(y))break}g[_+e*b+m]="avg"===s?v/A:y}}}return m}function eK(t,e,n,i,r=!1,s=!1){const o=RB(i.outShape,"int32"),a=i.strideHeight,l=i.strideWidth,c=i.dilationHeight,u=i.dilationWidth,h=i.effectiveFilterHeight,d=i.effectiveFilterWidth,p=i.padInfo.top,f=i.padInfo.left,m=RB(e,n,t);for(let g=0;g<i.batchSize;++g)for(let t=0;t<i.inChannels;++t)for(let e=0;e<i.outHeight;++e){const n=e*a-p;let y=n;for(;y<0;)y+=c;const v=Math.min(i.inHeight,h+n);for(let a=0;a<i.outWidth;++a){const h=a*l-f;let p=h;for(;p<0;)p+=u;const b=Math.min(i.inWidth,d+h);let A=Number.NEGATIVE_INFINITY,x=-1;for(let e=y;e<v;e+=c){const o=e-n;for(let n=p;n<b;n+=u){const a=n-h,l=m.get(g,e,n,t);l>A&&(A=l,x=r?s?((g*i.inHeight+e)*i.inWidth+n)*i.inChannels+t:(e*i.inWidth+n)*i.inChannels+t:o*d+a)}}o.set(x,g,e,a,t)}}return o}function nK(t,e,n,i,r,s){const o=r.strideDepth,a=r.strideHeight,l=r.strideWidth,c=r.dilationDepth,u=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,y=r.padInfo.left,v="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,b=RB(r.outShape,n),A=b.values,x=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],w=r.outShape[2]*r.outShape[3]*r.outShape[4],_=r.outShape[3]*r.outShape[4],S=r.outShape[4];for(let E=0;E<r.batchSize;++E){const e=E*x,n=E*i[0];for(let b=0;b<r.inChannels;++b)for(let x=0;x<r.outDepth;++x){const E=x*o-m;let C=E;for(;C<0;)C+=c;const I=Math.min(r.inDepth,d+E),T=e+x*w;for(let e=0;e<r.outHeight;++e){const o=e*a-g;let d=o;for(;d<0;)d+=u;const m=Math.min(r.inHeight,p+o),x=T+e*_;for(let e=0;e<r.outWidth;++e){const o=e*l-y;let a=o;for(;a<0;)a+=h;const p=Math.min(r.inWidth,f+o),g=x+e*S;let w=v,_=0,E=0;for(let e=C;e<I;e+=c){const r=n+e*i[1];for(let e=d;e<m;e+=u){const n=r+e*i[2];for(let e=a;e<p;e+=h){const r=t[n+e*i[3]+b];if("max"===s&&r>w?w=r:"avg"===s&&(_+=r,E++),isNaN(w))break}if(isNaN(w))break}if(isNaN(w))break}A[g+b]="avg"===s?_/E:w}}}}return b}const iK={kernelName:kk,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;VX(s,"avgPool");const{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=r;i.assert(d.eitherStridesOrDilationsAreOne(a,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`);const u=d.computePool2DInfo(s.shape,o,a,1,l,c);let h;if(1===u.filterWidth&&1===u.filterHeight&&i.arraysEqual(u.inShape,u.outShape))h=YX({inputs:{x:s},backend:n});else{const t=n.data.get(s.dataId).values,e=i.computeStrides(s.shape),r=tK(t,0,s.dtype,e,u,"avg");h=n.makeTensorInfo(u.outShape,s.dtype,r.values)}return h}},rK={kernelName:Nk,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:c,dataFormat:u}=r;VX(s,"avgPool3d");const h=d.computePool3DInfo(s.shape,o,a,1,l,c,u),p=nK(n.data.get(s.dataId).values,0,s.dtype,i.computeStrides(s.shape),h,"avg");return n.makeTensorInfo(p.shape,"float32",p.values)}},sK={kernelName:Lk,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,input:s}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=i;VX([r,s],"avgPool3DGrad");const u=d.computePool3DInfo(s.shape,o,a,1,l,c),h=u.strideDepth,p=u.strideHeight,f=u.strideWidth,m=u.filterDepth,g=u.filterHeight,y=u.filterWidth,v=u.dilationDepth,b=u.dilationHeight,A=u.dilationWidth,x=u.effectiveFilterDepth,w=u.effectiveFilterHeight,_=u.effectiveFilterWidth,S=x-1-u.padInfo.front,E=_-1-u.padInfo.left,C=w-1-u.padInfo.top,I=RB(s.shape,"float32"),T=1/(m*g*y),M=n.bufferSync(r);for(let d=0;d<u.batchSize;++d)for(let t=0;t<u.inChannels;++t)for(let e=0;e<u.inDepth;++e)for(let n=0;n<u.inHeight;++n)for(let i=0;i<u.inWidth;++i){const r=e-S,s=n-C,o=i-E;let a=0;for(let e=0;e<x;e+=v){const n=(r+e)/h;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let e=0;e<w;e+=b){const i=(s+e)/p;if(!(i<0||i>=u.outHeight||Math.floor(i)!==i))for(let e=0;e<_;e+=A){const r=(o+e)/f;r<0||r>=u.outWidth||Math.floor(r)!==r||(a+=M.get(d,n,i,r,t))}}}I.set(a*T,d,e,n,i,t)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}},oK={kernelName:Rk,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,input:s}=e,o=s;VX([r,s],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=i,u=d.computePool2DInfo(o.shape,a,l,1,c),h=u.strideHeight,p=u.strideWidth,f=u.filterHeight,m=u.filterWidth,g=u.dilationHeight,y=u.dilationWidth,v=u.effectiveFilterHeight,b=u.effectiveFilterWidth,A=b-1-u.padInfo.left,x=v-1-u.padInfo.top,w=RB(o.shape,"float32"),_=1/(f*m),S=n.data.get(r.dataId).values,E=RB(r.shape,"float32",S);for(let d=0;d<u.batchSize;++d)for(let t=0;t<u.inChannels;++t)for(let e=0;e<u.inHeight;++e)for(let n=0;n<u.inWidth;++n){const i=e-x,r=n-A;let s=0;for(let e=0;e<v;e+=g){const n=(i+e)/h;if(!(n<0||n>=u.outHeight||Math.floor(n)!==n))for(let e=0;e<b;e+=y){const i=(r+e)/p;i<0||i>=u.outWidth||Math.floor(i)!==i||(s+=E.get(d,n,i,t))}}w.set(s*_,d,e,n,t)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}},aK={kernelName:wR,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,scale:o,offset:a,mean:l,variance:c}=e;i.assert(l.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),i.assert(null==a||l.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),i.assert(null==o||l.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),VX([s,l,c,o,a],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const h=n.data.get(s.dataId).values,d=n.data.get(l.dataId).values,p=n.data.get(c.dataId).values,f=o?n.data.get(o.dataId).values:new Float32Array([1]),m=a?n.data.get(a.dataId).values:new Float32Array([0]),g=new Float32Array(h.length),y=m.length,v=f.length,b=p.length,A=d.length;let x=0,w=0,_=0,S=0;for(let i=0;i<h.length;++i)g[i]=m[x++]+(h[i]-d[w++])*f[_++]/Math.sqrt(p[S++]+u),x>=y&&(x=0),w>=A&&(w=0),_>=v&&(_=0),S>=b&&(S=0);return n.makeTensorInfo(s.shape,s.dtype,g)}};function lK(t,e,n,r,s){const o=l.isSliceContinous(r,e,n),a=i.sizeFromShape(n),c=i.computeStrides(r);if(o){const n=l.computeFlatOffset(e,c);return"string"===s?t.slice(n,n+a):t.subarray(n,n+a)}const u=RB(r,s,"string"===s?d.fromUint8ToStringArray(t):t),h=RB(n,s);for(let i=0;i<h.size;++i){const t=h.indexToLoc(i),n=t.map((t,n)=>t+e[n]);h.set(u.get(...n),...t)}return"string"===s?d.fromStringArrayToUint8(h.values):h.values}function cK(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{begin:s,size:o}=i;VX(r,"slice");const[a,c]=l.parseSliceParams(r,s,o);l.assertParamsValid(r,a,c);const u=lK(n.data.get(r.dataId).values,a,c,r.shape,r.dtype);return n.makeTensorInfo(c,r.dtype,u)}const uK={kernelName:NN,backendName:"cpu",kernelFunc:cK},hK={kernelName:Bk,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{blockShape:s,crops:o}=i;VX([r],"batchToSpaceND");const a=s.reduce((t,e)=>t*e),l=d.getReshaped(r.shape,s,a),c=d.getPermuted(l.length,s.length),u=d.getReshapedPermuted(r.shape,s,a),h=d.getSliceBeginCoords(o,s.length),p=d.getSliceSize(u,o,s.length),f=SY({inputs:{x:r},backend:n,attrs:{shape:l}}),m=PY({inputs:{x:f},backend:n,attrs:{perm:c}}),g=SY({inputs:{x:m},backend:n,attrs:{shape:u}}),y=cK({inputs:{x:g},backend:n,attrs:{begin:h,size:p}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}};function dK(t,e,n,r,s){const o=i.sizeFromShape(r),a=i.makeZerosTypedArray(s,n);for(let i=0;i<t.length;i++){const n=t[i];if(n<0)throw new Error("Input x must be non-negative!");n>=s||(a[n]+=o>0?e[i]:1)}return a}function pK(t,e,n,i=!1){const r=t.shape[0],s=t.shape[1],o=RB([r,n],e.dtype);for(let a=0;a<r;a++)for(let r=0;r<s;r++){const s=t.get(a,r);if(s<0)throw new Error("Input x must be non-negative!");s>=n||o.set(i?1:e.size>0?o.get(a,s)+e.get(a,r):o.get(a,s)+1,a,s)}return o}const fK={kernelName:Ok,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,weights:s}=e,{size:o}=i,a=dK(n.data.get(r.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,a)}};function mK(t){return(e,n,r)=>{const s=i.getTypedArrayFromDType(n,e.length);for(let i=0;i<e.length;++i)s[i]=t(e[i],r);return s}}const gK=mK(t=>Math.ceil(t)),yK=QX(Fk,gK),vK={kernelName:Fk,backendName:"cpu",kernelFunc:yK},bK=jX($k,(t,e)=>t>e.clipValueMax?e.clipValueMax:t<e.clipValueMin?e.clipValueMin:t),AK={kernelName:$k,backendName:"cpu",kernelFunc:bK},xK={kernelName:Uk,backendName:"cpu",kernelFunc:t=>{const{x:e}=t.inputs,n=t.backend,r=new Float32Array(i.sizeFromShape(e.shape)),s=n.data.get(e.dataId),o=s.complexTensorInfos.imag,a=n.data.get(s.complexTensorInfos.real.dataId).values,l=n.data.get(o.dataId).values;for(let i=0;i<a.length;i++)r[i]=Math.hypot(a[i],l[i]);return n.makeOutput(r,e.shape,"float32")}};function wK(t,e,n,r){const s=i.getArrayFromDType(n,i.sizeFromShape(e));if(r&&"string"!==n){let e=0;t.forEach(t=>{const n=i.sizeFromShape(t.shape);s.set(t.vals,e),e+=n})}else{let i=0;t.forEach(t=>{const r="string"===n?d.fromUint8ToStringArray(t.vals):t.vals;let o=0;for(let n=0;n<t.shape[0];++n){const a=n*e[1]+i;for(let e=0;e<t.shape[1];++e)s[a+e]=r[o++]}i+=t.shape[1]})}return s}function _K(t){const{inputs:e,backend:n}=t,{input:i}=e,r=n.data.get(i.dataId).complexTensorInfos.imag,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}const SK={kernelName:MR,backendName:"cpu",kernelFunc:_K};function EK(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r,o=i.parseAxisParam(s,e[0].shape)[0];let a=d.computeOutShape(e.map(t=>t.shape),o);if(0===i.sizeFromShape(a))return n.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(t=>i.sizeFromShape(t.shape)>0);if(1===l.length)return YX({inputs:{x:l[0]},backend:n});const c=l.map(t=>t.shape);if(d.assertParamsConsistent(c,o),"complex64"===l[0].dtype){const t=l.map(t=>fY({inputs:{input:t},backend:n})),e=l.map(t=>_K({inputs:{input:t},backend:n})),i=EK({inputs:t,backend:n,attrs:{axis:o}}),r=EK({inputs:e,backend:n,attrs:{axis:o}}),s=hY({inputs:{real:i,imag:r},backend:n});return t.forEach(t=>n.disposeIntermediateTensorInfo(t)),e.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(r),s}const u=l.map(t=>{const e=i.sizeFromShape(t.shape.slice(o));return SY({inputs:{x:t},backend:n,attrs:{shape:[-1,e]}})}),h=u.map(t=>({vals:n.data.get(t.dataId).values,shape:t.shape}));a=d.computeOutShape(u.map(t=>t.shape),1);const p=wK(h,a,e[0].dtype,1===u[0].shape[0]),f=d.computeOutShape(l.map(t=>t.shape),o),m=n.makeTensorInfo(f,e[0].dtype,p);return u.forEach(t=>n.disposeIntermediateTensorInfo(t)),m}const CK={kernelName:Hk,backendName:"cpu",kernelFunc:EK};function IK(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:a,pad:l,dataFormat:c,dilations:u,dimRoundingMode:h}=r;VX([s,o],"conv2d");const p=d.convertConv2DDataFormat(c),f=d.computeConv2DInfo(s.shape,o.shape,a,u,l,h,!1,p),m=f.filterHeight,g=f.filterWidth,y=f.dilationHeight,v=f.dilationWidth,b=f.padInfo.left,A=f.padInfo.top,x="channelsLast"===f.dataFormat,w=new ZL(f.outShape,s.dtype),_=i.computeStrides(s.shape),S=i.computeStrides(o.shape),E=_[0],C=x?_[1]:_[2],I=x?_[2]:1,T=x?1:_[1],M=w.strides[0],k=x?w.strides[1]:w.strides[2],R=x?w.strides[2]:1,N=x?1:w.strides[1],L=n.data.get(s.dataId).values,D=n.data.get(o.dataId).values,B=w.values;for(let i=0;i<f.batchSize;++i){const t=i*E,e=i*M;for(let n=0;n<f.outHeight;++n){const i=e+n*k,r=n*f.strideHeight-A;for(let e=0;e<m;++e){const n=r+e*y;if(n<0||n>=f.inHeight)continue;const s=e*S[0],o=t+n*C;for(let t=0;t<f.outWidth;++t){const e=i+t*R,n=t*f.strideWidth-b;for(let t=0;t<g;++t){const i=n+t*v;if(i<0||i>=f.inWidth)continue;const r=o+i*I;let a=s+t*S[1];for(let t=0;t<f.inChannels;++t){const n=L[r+t*T];for(let t=0;t<f.outChannels;++t)B[e+t*N]+=n*D[a+t];a+=f.outChannels}}}}}}return n.makeTensorInfo(w.shape,w.dtype,B)}const TK={kernelName:Vk,backendName:"cpu",kernelFunc:IK},MK={kernelName:Gk,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,dy:s}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=i;VX([r,s],"conv2dBackpropFilter");const h=d.convertConv2DDataFormat(l),p=d.computeConv2DInfo(r.shape,u,o,1,a,c,!1,h),{strideHeight:f,strideWidth:m,filterHeight:g,filterWidth:y}=p,v="channelsLast"===p.dataFormat,b=new ZL(p.filterShape,"float32"),A=p.padInfo.left,x=p.padInfo.top,w=n.data.get(r.dataId).values,_=n.data.get(s.dataId).values,S=new ZL(r.shape,r.dtype,w),E=new ZL(s.shape,s.dtype,_);for(let d=0;d<g;++d){const t=Math.max(0,Math.ceil((x-d)/f)),e=Math.min(p.outHeight,(p.inHeight+x-d)/f);for(let n=0;n<y;++n){const i=Math.max(0,Math.ceil((A-n)/m)),r=Math.min(p.outWidth,(p.inWidth+A-n)/m);for(let s=0;s<p.inChannels;++s)for(let o=0;o<p.outChannels;++o){let a=0;for(let l=0;l<p.batchSize;++l)for(let c=t;c<e;++c){const t=d+c*f-x;for(let e=i;e<r;++e){const i=n+e*m-A;a+=v?S.get(l,t,i,s)*E.get(l,c,e,o):S.get(l,s,t,i)*E.get(l,o,c,e)}}b.set(a,d,n,s,o)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}},kK={kernelName:Wk,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{inputShape:a,strides:l,pad:c,dataFormat:u,dimRoundingMode:h}=r;VX([s,o],"conv2dBackpropInput");const p=i.computeStrides(o.shape),f=i.computeStrides(s.shape);let m=d.convertConv2DDataFormat(u);const g=d.computeConv2DInfo(a,o.shape,l,1,c,h,!1,m),y=new ZL(g.inShape,"float32"),v=y.values,b=n.data.get(s.dataId).values,A=n.data.get(o.dataId).values,[x,w,_]=p,{batchSize:S,filterHeight:E,filterWidth:C,inChannels:I,inHeight:T,inWidth:M,outChannels:k,outHeight:R,outWidth:N,strideHeight:L,strideWidth:D}=g;m=g.dataFormat;const B=E-1-g.padInfo.top,O=C-1-g.padInfo.left,P="channelsLast"===m,F=y.strides[0],$=P?y.strides[1]:y.strides[2],z=P?y.strides[2]:1,U=P?1:y.strides[1],H=f[0],V=P?f[1]:f[2],G=P?f[2]:1,W=P?1:f[1];for(let i=0;i<S;++i)for(let t=0;t<I;++t)for(let e=0;e<T;++e){const n=e-B,r=Math.max(0,Math.ceil(n/L)),s=Math.min(R,(E+n)/L);for(let o=0;o<M;++o){const a=o-O,l=Math.max(0,Math.ceil(a/D)),c=Math.min(N,(C+a)/D);let u=0;for(let e=r;e<s;++e){const r=e*L-n;for(let n=l;n<c;++n){const s=H*i+V*e+G*n,o=x*(E-1-r)+w*(C-1-(n*D-a))+_*t;for(let t=0;t<k;++t)u+=b[s+W*t]*A[o+t]}}v[F*i+$*e+z*o+U*t]=u}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},RK={kernelName:jk,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:a,pad:l,dilations:c}=r;VX([s,o],"conv3d");const u=d.computeConv3DInfo(s.shape,o.shape,a,c,l),{filterDepth:h,filterHeight:p,filterWidth:f,dilationDepth:m,dilationHeight:g,dilationWidth:y,padInfo:v}=u,b=v.front,A=v.left,x=v.top,w=new ZL(u.outShape,s.dtype),_=n.data.get(s.dataId).values,S=n.data.get(o.dataId).values,E=w.values,C=i.computeStrides(s.shape),I=i.computeStrides(o.shape);for(let i=0;i<u.batchSize;++i){const t=i*C[0],e=i*w.strides[0];for(let n=0;n<u.outDepth;++n){const i=e+n*w.strides[1],r=n*u.strideDepth-b;for(let e=0;e<h;++e){const n=r+e*m;if(n<0||n>=u.inDepth)continue;const s=e*I[0],o=t+n*C[1];for(let t=0;t<u.outHeight;++t){const e=i+t*w.strides[2],n=t*u.strideHeight-x;for(let t=0;t<p;++t){const i=n+t*g;if(i<0||i>=u.inHeight)continue;const r=s+t*I[1],a=o+i*C[2];for(let t=0;t<u.outWidth;++t){const n=e+t*u.outChannels,i=t*u.strideWidth-A;for(let t=0;t<f;++t){const e=i+t*y;if(e<0||e>=u.inWidth)continue;const s=a+e*u.inChannels;let o=r+t*I[2];for(let t=0;t<u.inChannels;++t){const e=_[s+t];for(let t=0;t<u.outChannels;++t)E[n+t]+=e*S[o+t];o+=u.outChannels}}}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}},NK={kernelName:Qk,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:a,pad:l,filterShape:c}=r;VX([s,o],"conv3dBackpropFilterV2");const u=i.computeStrides(s.shape),h=i.computeStrides(o.shape),p=d.computeConv3DInfo(s.shape,c,a,1,l),f=p.strideDepth,m=p.strideHeight,g=p.strideWidth,y=p.filterDepth,v=p.filterHeight,b=p.filterWidth,A=new ZL(p.filterShape,"float32"),x=A.values,[w,_,S,E]=A.strides,C=n.data.get(o.dataId).values,[I,T,M,k]=h,R=n.data.get(s.dataId).values,[N,L,D,B]=u,O=p.padInfo.front,P=p.padInfo.left,F=p.padInfo.top;for(let i=0;i<y;++i){const t=Math.max(0,Math.ceil((O-i)/f)),e=Math.min(p.outDepth,(p.inDepth+O-i)/f),n=i*w;for(let r=0;r<v;++r){const s=Math.max(0,Math.ceil((F-r)/m)),o=Math.min(p.outHeight,(p.inHeight+F-r)/m),a=r*_+n;for(let n=0;n<b;++n){const l=Math.max(0,Math.ceil((P-n)/g)),c=Math.min(p.outWidth,(p.inWidth+P-n)/g),u=n*S+a;for(let a=0;a<p.inChannels;++a){const h=a*E+u;for(let u=0;u<p.outChannels;++u){let d=0;for(let h=0;h<p.batchSize;++h){const p=h*N,y=h*I;for(let h=t;h<e;++h){const t=(i+h*f-O)*L+p,e=h*T+y;for(let i=s;i<o;++i){const s=(r+i*m-F)*D+t,o=i*M+e;for(let t=l;t<c;++t)d+=R[(n+t*g-P)*B+s+a]*C[t*k+o+u]}}}x[h+u]=d}}}}}return n.makeTensorInfo(A.shape,A.dtype,A.values)}},LK={kernelName:qk,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{pad:a,strides:l,inputShape:c}=r;VX([s],"conv3dBackpropInputV2");const u=i.computeStrides(s.shape),h=i.computeStrides(o.shape),p=d.computeConv3DInfo(c,o.shape,l,1,a),f=new ZL(p.inShape,"float32"),m=f.values,[g,y,v,b]=f.strides,A=n.data.get(s.dataId).values,[x,w,_,S]=u,E=n.data.get(o.dataId).values,[C,I,T,M]=h,{batchSize:k,filterDepth:R,filterHeight:N,filterWidth:L,inChannels:D,inDepth:B,inHeight:O,inWidth:P,outChannels:F,outDepth:$,outHeight:z,outWidth:U,strideDepth:H,strideHeight:V,strideWidth:G}=p,W=R-1-p.padInfo.front,j=N-1-p.padInfo.top,Q=L-1-p.padInfo.left;for(let i=0;i<k;++i)for(let t=0;t<D;++t)for(let e=0;e<B;++e){const n=e-W,r=Math.max(0,Math.ceil(n/H)),s=Math.min($,(R+n)/H);for(let o=0;o<O;++o){const a=o-j,l=Math.max(0,Math.ceil(a/V)),c=Math.min(z,(N+a)/V);for(let u=0;u<P;++u){const h=u-Q,d=Math.max(0,Math.ceil(h/G)),p=Math.min(U,(L+h)/G);let f=0;for(let e=r;e<s;++e){const r=e*H-n;for(let n=l;n<c;++n){const s=n*V-a;for(let o=d;o<p;++o){const a=x*i+w*e+_*n+S*o,l=C*(R-1-r)+I*(N-1-s)+T*(L-1-(o*G-h))+M*t;for(let t=0;t<F;++t)f+=A[a+t]*E[l+t]}}}m[g*i+y*e+v*o+b*u+t]=f}}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}},DK=jX(Xk,t=>Math.cos(t)),BK={kernelName:Xk,backendName:"cpu",kernelFunc:DK},OK=jX(Yk,t=>Math.cosh(t)),PK={kernelName:Yk,backendName:"cpu",kernelFunc:OK},FK={kernelName:Jk,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{image:s,boxes:o,boxInd:a}=e,{cropSize:l,method:c,extrapolationValue:u}=r,[h,d,p,f]=s.shape,m=o.shape[0],[g,y]=l,v=RB([m,g,y,f],"float32"),b=n.data.get(o.dataId).values,A=n.data.get(a.dataId).values,x=n.data.get(s.dataId).values,w=i.computeStrides(s.shape),_=i.computeStrides(v.shape);for(let i=0;i<m;i++){const t=4*i,e=b[t],n=b[t+1],r=b[t+2],s=b[t+3],o=A[i];if(o>=h)continue;const a=g>1?(r-e)*(d-1)/(g-1):0,l=y>1?(s-n)*(p-1)/(y-1):0;for(let h=0;h<g;h++){const t=g>1?e*(d-1)+h*a:.5*(e+r)*(d-1);if(t<0||t>d-1)for(let e=0;e<y;e++)for(let t=0;t<f;t++)v.values[t+e*_[2]+h*_[1]+i*_[0]]=u;else if("bilinear"===c){const e=Math.floor(t),r=Math.ceil(t),a=t-e;for(let t=0;t<y;t++){const c=y>1?n*(p-1)+t*l:.5*(n+s)*(p-1);if(c<0||c>p-1){for(let e=0;e<f;e++)v.values[e+t*_[2]+h*_[1]+i*_[0]]=u;continue}const d=Math.floor(c),m=Math.ceil(c),g=c-d;for(let n=0;n<f;n++){let s=n+d*w[2]+e*w[1]+o*w[0];const l=x[s];s=n+m*w[2]+e*w[1]+o*w[0];const c=x[s];s=n+d*w[2]+r*w[1]+o*w[0];const u=x[s];s=n+m*w[2]+r*w[1]+o*w[0];const p=x[s],f=l+(c-l)*g;s=n+t*_[2]+h*_[1]+i*_[0],v.values[s]=f+(u+(p-u)*g-f)*a}}}else for(let e=0;e<y;++e){const r=y>1?n*(p-1)+e*l:.5*(n+s)*(p-1);if(r<0||r>p-1){for(let t=0;t<f;t++)v.values[t+e*_[2]+h*_[1]+i*_[0]]=u;continue}const a=Math.round(r),c=Math.round(t);for(let t=0;t<f;t++)v.values[t+e*_[2]+h*_[1]+i*_[0]]=x[t+a*w[2]+c*w[1]+o*w[0]]}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}},$K={kernelName:Kk,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,exclusive:a,reverse:l}=r;VX(s,"cumsum");const c=d.getAxesPermutation([o],s.shape.length);let u=s;null!=c&&(u=PY({inputs:{x:s},backend:n,attrs:{perm:c}}));const h=d.getInnerMostAxes(1,s.shape.length)[0];if(h!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${h}`);const p=dD(u.dtype,"int32"),f=i.makeZerosTypedArray(i.sizeFromShape(u.shape),p),m=n.data.get(u.dataId).values,g=u.shape[u.shape.length-1],y=l?(t,e)=>t+g-e-1:(t,e)=>t+e;for(let i=0;i<m.length;i+=g)for(let t=0;t<g;t++){const e=y(i,t);if(0===t)f[e]=a?0:m[e];else{const n=y(i,t-1);f[e]=a?m[n]+f[n]:m[e]+f[n]}}const v=n.makeTensorInfo(u.shape,p,f);if(null!=c){const t=PY({inputs:{x:v},backend:n,attrs:{perm:d.getUndoAxesPermutation(c)}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(u),t}return v}},zK={kernelName:Zk,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,weights:s}=e,{size:o,binaryOutput:a}=i;if(1===r.shape.length){const t=dK(n.data.get(r.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,t)}if(2===r.shape.length){const t=pK(n.bufferSync(r),n.bufferSync(s),o,a);return n.makeTensorInfo(t.shape,s.dtype,t.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}},UK={kernelName:tR,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockSize:o,dataFormat:a}=r;i.assert("NHWC"===a,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`),i.assert(o>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${o}`);const l=s.shape[0],c=s.shape[1],u=s.shape[2],h=s.shape[3],d=c*o,p=u*o,f=h/(o*o),m=n.data.get(s.dataId).values,g=new Float32Array(l*d*p*f);let y=0;for(let i=0;i<l;++i)for(let t=0;t<d;++t){const e=Math.floor(t/o),n=t%o;for(let t=0;t<p;++t){const r=Math.floor(t/o),s=(n*o+t%o)*f;for(let t=0;t<f;++t)g[y++]=m[t+s+h*(r+u*(e+c*i))]}}return n.makeTensorInfo([l,d,p,f],s.dtype,g)}};function HK(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:a,pad:l,dilations:c,dimRoundingMode:u}=r;VX([s,o],"depthwiseConv2DNative");const h=i.computeStrides(s.shape),p=i.computeStrides(o.shape);let f=c;null==f&&(f=[1,1]),i.assert(d.eitherStridesOrDilationsAreOne(a,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${f}'`);const m=d.computeConv2DInfo(s.shape,o.shape,a,f,l,u,!0),{filterHeight:g,filterWidth:y,dilationHeight:v,dilationWidth:b,padInfo:A}=m,x=A.left,w=A.top,_=m.outChannels/m.inChannels,S=new ZL(m.outShape,s.dtype),E=n.data.get(s.dataId).values,C=n.data.get(o.dataId).values,I=S.values;for(let i=0;i<m.batchSize;++i){const t=i*h[0],e=i*S.strides[0];for(let n=0;n<m.outHeight;++n){const i=e+n*S.strides[1],r=n*m.strideHeight-w;for(let e=0;e<g;++e){const n=r+e*v;if(n<0||n>=m.inHeight)continue;const s=e*p[0],o=t+n*h[1];for(let t=0;t<m.outWidth;++t){const e=i+t*S.strides[2],n=t*m.strideWidth-x;for(let t=0;t<y;++t){const i=n+t*b;if(i<0||i>=m.inWidth)continue;const r=o+i*m.inChannels;let a=e,l=s+t*p[1];for(let t=0;t<m.inChannels;++t){const e=E[r+t];for(let t=0;t<_;++t)I[a+t]+=e*C[l+t];a+=_,l+=_}}}}}}return n.makeTensorInfo(S.shape,S.dtype,S.values)}const VK={kernelName:eR,backendName:"cpu",kernelFunc:HK},GK={kernelName:nR,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,dy:s}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=i;VX([r,s],"depthwiseConv2dNativeBackpropFilter");const h=d.computeConv2DInfo(r.shape,u,o,a,l,c,!0),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,y=new ZL(h.filterShape,"float32"),v=h.padInfo.left,b=h.padInfo.top,A=h.outChannels/h.inChannels,x=n.data.get(r.dataId).values,w=new ZL(r.shape,r.dtype,x),_=n.data.get(s.dataId).values,S=new ZL(s.shape,s.dtype,_);for(let d=0;d<m;++d){const t=Math.max(0,Math.ceil((b-d)/p)),e=Math.min(h.outHeight,(h.inHeight+b-d)/p);for(let n=0;n<g;++n){const i=Math.max(0,Math.ceil((v-n)/f)),r=Math.min(h.outWidth,(h.inWidth+v-n)/f);for(let s=0;s<h.outChannels;++s){const o=Math.trunc(s/A),a=s%A;let l=0;for(let c=0;c<h.batchSize;++c)for(let a=t;a<e;++a){const t=d+a*p-b;for(let e=i;e<r;++e)l+=w.get(c,t,n+e*f-v,o)*S.get(c,a,e,s)}y.set(l,d,n,o,a)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},WK={kernelName:iR,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{strides:a,dilations:l,pad:c,dimRoundingMode:u,inputShape:h}=r;VX([s,o],"depthwiseConv2DNativeBackpropInput");const p=i.computeStrides(s.shape),f=i.computeStrides(o.shape),m=d.computeConv2DInfo(h,o.shape,a,l,c,u,!0),g=new ZL(m.inShape,"float32"),y=g.values,[v,b,A]=g.strides,x=n.data.get(s.dataId).values,[w,_,S]=p,E=n.data.get(o.dataId).values,[C,I,T]=f,{batchSize:M,filterHeight:k,filterWidth:R,inChannels:N,inHeight:L,inWidth:D,outChannels:B,outHeight:O,outWidth:P,strideHeight:F,strideWidth:$}=m,z=k-1-m.padInfo.top,U=R-1-m.padInfo.left,H=B/N;for(let i=0;i<M;++i)for(let t=0;t<N;++t)for(let e=0;e<L;++e){const n=e-z,r=Math.max(0,Math.ceil(n/F)),s=Math.min(O,(k+n)/F);for(let o=0;o<D;++o){const a=o-U,l=Math.max(0,Math.ceil(a/$)),c=Math.min(P,(R+a)/$);let u=0;for(let e=r;e<s;++e){const r=e*F-n;for(let n=l;n<c;++n){const s=w*i+_*e+S*n,o=C*(k-1-r)+I*(R-1-(n*$-a))+T*t;for(let e=0;e<H;++e)u+=x[s+(t*H+e)]*E[o+e]}}y[v*i+b*e+A*o+t]=u}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}},jK={kernelName:rR,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e,s=i.sizeFromShape(r.shape),o=n.data.get(r.dataId).values,a=RB([s,s],r.dtype),l=a.values;for(let i=0;i<o.length;i++)l[i*s+i]=o[i];const c=[...r.shape,...r.shape];return n.makeTensorInfo(c,a.dtype,a.values)}},QK={kernelName:sR,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:s}=t,{strides:o,pad:a,dilations:l}=n,c=e,u=c.data.get(r.dataId).values,h=r.shape.length,p=c.data.get(s.dataId).values,f=s.shape.length,{batchSize:m,inHeight:g,inWidth:y,inChannels:v,outHeight:b,outWidth:A,padInfo:x,strideHeight:w,strideWidth:_,filterHeight:S,filterWidth:E,dilationHeight:C,dilationWidth:I,outShape:T}=d.computeDilation2DInfo(r.shape,s.shape,o,a,"NHWC",l),M=i.sizeFromShape(T),k=T.length,R=i.getArrayFromDType(r.dtype,M);for(let d=0;d<m;++d)for(let t=0;t<b;++t){const e=t*w-x.top;for(let n=0;n<A;++n){const o=n*_-x.left;for(let a=0;a<v;++a){let l=Number.MIN_SAFE_INTEGER;for(let t=0;t<S;++t){const n=e+t*C;if(n>=0&&n<g)for(let e=0;e<E;++e){const c=o+e*I;if(c>=0&&c<y){const o=i.locToIndex([d,n,c,a],h,i.computeStrides(r.shape)),m=i.locToIndex([t,e,a],f,i.computeStrides(s.shape)),g=u[o]+p[m];g>l&&(l=g)}}}R[i.locToIndex([d,t,n,a],k,i.computeStrides(T))]=l}}}return{dataId:c.write(i.toTypedArray(R,r.dtype),T,r.dtype),shape:T,dtype:r.dtype}}},qK={kernelName:aR,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:s,dy:o}=t,{strides:a,pad:l,dilations:c}=n,u=e,h=i.toNestedArray(r.shape,u.data.get(r.dataId).values),p=i.toNestedArray(s.shape,u.data.get(s.dataId).values),{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:v,outWidth:b,padInfo:A,strideHeight:x,strideWidth:w,filterHeight:_,filterWidth:S,dilationHeight:E,dilationWidth:C,outShape:I}=d.computeDilation2DInfo(r.shape,s.shape,a,l,"NHWC",c);i.assert(o.rank===I.length,()=>`Error in Dilation2DBackpropFilter, dy must have the same rank as output ${I.length}, but got ${o.rank}`);const T=i.toNestedArray(I,u.data.get(o.dataId).values),M=i.makeZerosNestedTypedArray(s.shape,s.dtype);for(let i=0;i<f;++i)for(let t=0;t<v;++t){const e=t*x-A.top;for(let n=0;n<b;++n){const r=n*w-A.left;for(let s=0;s<y;++s){let o=Number.MIN_SAFE_INTEGER,a=0,l=0;for(let t=0;t<_;++t){const n=e+t*E;if(n>=0&&n<m)for(let e=0;e<S;++e){const c=r+e*C;if(c>=0&&c<g){const r=h[i][n][c][s]+p[t][e][s];r>o&&(o=r,a=t,l=e)}}}M[a][l][s]+=T[i][t][n][s]}}}return{dataId:u.write(i.toTypedArray(M,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},XK={kernelName:oR,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:s,dy:o}=t,{strides:a,pad:l,dilations:c}=n,u=e,h=i.toNestedArray(r.shape,u.data.get(r.dataId).values),p=i.toNestedArray(s.shape,u.data.get(s.dataId).values),{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:v,outWidth:b,padInfo:A,strideHeight:x,strideWidth:w,filterHeight:_,filterWidth:S,dilationHeight:E,dilationWidth:C,outShape:I}=d.computeDilation2DInfo(r.shape,s.shape,a,l,"NHWC",c);i.assert(o.rank===I.length,()=>`Error in Dilation2DBackpropInput, dy must have the same rank as output ${I.length}, but got ${o.rank}`);const T=i.toNestedArray(I,u.data.get(o.dataId).values),M=i.makeZerosNestedTypedArray(r.shape,r.dtype);for(let i=0;i<f;++i)for(let t=0;t<v;++t){const e=t*x-A.top;for(let n=0;n<b;++n){const r=n*w-A.left;for(let s=0;s<y;++s){let o=Number.MIN_SAFE_INTEGER,a=e<0?0:e,l=r<0?0:r;for(let t=0;t<_;++t){const n=e+t*E;if(n>=0&&n<m)for(let e=0;e<S;++e){const c=r+e*C;if(c>=0&&c<g){const r=h[i][n][c][s]+p[t][e][s];r>o&&(o=r,a=n,l=c)}}}M[i][a][l][s]+=T[i][t][n][s]}}}return{dataId:u.write(i.toTypedArray(M,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},YK=tY((t,e)=>t*e),KK=bY((t,e,n,i)=>({real:t*n-e*i,imag:t*i+e*n})),JK=vY(iN,YK,KK),ZK={kernelName:iN,backendName:"cpu",kernelFunc:JK};function tJ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:a}=r;let l;VX(s,"sum"),l="bool"===s.dtype?gY({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):YX({inputs:{x:s},backend:n});const c=l.shape.length,u=i.parseAxisParam(o,l.shape),h=d.getAxesPermutation(u,c);let p=u,f=l;null!=h&&(f=PY({inputs:{x:l},backend:n,attrs:{perm:h}}),p=d.getInnerMostAxes(p.length,c)),d.assertAxesAreInnerMostDims("sum",p,f.shape.length);const[m,g]=d.computeOutAndReduceShapes(f.shape,p);let y=pY(n,m,d.upcastType(f.dtype,"int32"));const v=i.sizeFromShape(g),b=n.data.get(y.dataId).values,A=n.data.get(f.dataId).values;for(let i=0;i<b.length;++i){const t=i*v;let e=0;for(let n=0;n<v;++n)e+=A[t+n];b[i]=e}if(a){const t=y;y=SY({inputs:{x:y},backend:n,attrs:{shape:d.expandShapeToKeepDim(y.shape,u)}}),n.disposeIntermediateTensorInfo(t)}return n.disposeIntermediateTensorInfo(l),null!=h&&n.disposeIntermediateTensorInfo(f),y}const eJ={kernelName:$N,backendName:"cpu",kernelFunc:tJ},nJ={kernelName:cR,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{equation:s}=r,o=e,{allDims:a,summedDims:l,idDims:c}=d.decodeEinsumEquation(s,o.length);d.checkEinsumDimSizes(a.length,c,o);const{path:u,steps:h}=d.getEinsumComputePath(l,c),p=h.length;let f=null,m=a.length;const g=[];for(let y=0;y<p;++y){for(const t of h[y]){const{permutationIndices:e,expandDims:r}=d.getEinsumPermutation(m,c[t]);let s;d.isIdentityPermutation(e)?s=o[t]:(s=PY({inputs:{x:o[t]},backend:n,attrs:{perm:e}}),g.push(s));const a=s.shape.slice();for(let t=0;t<r.length;++t)a.splice(r[t],0,1);i.arraysEqual(s.shape,a)||(s=SY({inputs:{x:s},backend:n,attrs:{shape:a}}),g.push(s)),null===f?f=s:(f=JK({inputs:{a:s,b:f},backend:n}),g.push(f))}y<p-1&&(u[y]>=0&&(f=tJ({inputs:{x:f},backend:n,attrs:{axis:u[y]-(a.length-m),keepDims:!1}}),g.push(f)),m--)}for(const i of g)i!==f&&n.disposeIntermediateTensorInfo(i);return f}},iJ={kernelName:hR,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{dy:r,y:s}=e;VX([r,s],"eluGrad");const o=new Float32Array(i.sizeFromShape(s.shape)),a=n.data.get(s.dataId).values,l=n.data.get(r.dataId).values;for(let i=0;i<a.length;++i){const t=a[i];o[i]=t>=1?l[i]:l[i]*(t+1)}return n.makeTensorInfo(s.shape,"float32",o)}},rJ=tY((t,e)=>t===e?1:0),sJ=vY(pR,rJ,null,"bool"),oJ={kernelName:pR,backendName:"cpu",kernelFunc:sJ},aJ=d.ERF_P,lJ=d.ERF_A1,cJ=d.ERF_A2,uJ=d.ERF_A3,hJ=d.ERF_A4,dJ=d.ERF_A5,pJ=jX(dR,t=>{const e=Math.sign(t),n=Math.abs(t),i=1/(1+aJ*n);return e*(1-((((dJ*i+hJ)*i+uJ)*i+cJ)*i+lJ)*i*Math.exp(-n*n))}),fJ={kernelName:dR,backendName:"cpu",kernelFunc:pJ},mJ=mK(t=>Math.exp(t)),gJ=QX(fR,mJ),yJ={kernelName:fR,backendName:"cpu",kernelFunc:gJ};function vJ(t){const{inputs:e,backend:n,attrs:r}=t,{input:s}=e,{dim:o}=r,a=s.shape.length,l=s.shape.slice();let c=o;return o<0&&(i.assert(-(a+1)<=o,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),c=a+o+1),l.splice(c,0,1),SY({inputs:{x:s},backend:n,attrs:{shape:l}})}const bJ={kernelName:mR,backendName:"cpu",kernelFunc:vJ},AJ=mK(t=>Math.expm1(t)),xJ=QX(gR,AJ),wJ={kernelName:gR,backendName:"cpu",kernelFunc:xJ},_J=tY((t,e)=>t/e),SJ=vY(lR,_J),EJ={kernelName:lR,backendName:"cpu",kernelFunc:SJ},CJ=tY((t,e)=>t-e),IJ=bY((t,e,n,i)=>({real:t-n,imag:e-i})),TJ=vY(tL,CJ,IJ),MJ={kernelName:tL,backendName:"cpu",kernelFunc:TJ};function kJ(t,e,n){const r=t.shape,s=r[0],o=r[1],a=n.data.get(t.dataId),l=a.complexTensorInfos.real,c=a.complexTensorInfos.imag,u=[s,o],h=i.sizeFromShape(u),p=i.getTypedArrayFromDType("float32",h),f=i.getTypedArrayFromDType("float32",h);for(let i=0;i<s;i++){const t=cK({inputs:{x:l},backend:n,attrs:{begin:[i,0],size:[1,o]}}),r=cK({inputs:{x:c},backend:n,attrs:{begin:[i,0],size:[1,o]}}),s=hY({inputs:{real:t,imag:r},backend:n}),{real:a,imag:u}=RJ(s,e,n),h=d.mergeRealAndImagArrays(a,u);for(let e=0;e<o;e++){const t=d.getComplexWithIndex(h,e);p[i*o+e]=t.real,f[i*o+e]=t.imag}n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s)}const m=n.makeTensorInfo(u,"float32",p),g=n.makeTensorInfo(u,"float32",f),y=hY({inputs:{real:m,imag:g},backend:n});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}function RJ(t,e,n){const r=i.sizeFromShape(t.shape),s=n.data.get(t.dataId),o=n.data.get(s.complexTensorInfos.real.dataId).values,a=n.data.get(s.complexTensorInfos.imag.dataId).values;if(0==((l=r)&l-1)){const s=NJ(o,a,r,e,n),l=[t.shape[0],t.shape[1]];if(e){const t=n.makeTensorInfo(l,"float32",s.real),e=n.makeTensorInfo(l,"float32",s.imag),o=n.makeTensorInfo([],"float32",i.createScalarValue(r,"float32")),a=YX({inputs:{x:o},backend:n}),c=EJ.kernelFunc({inputs:{a:t,b:o},backend:n}),u=EJ.kernelFunc({inputs:{a:e,b:a},backend:n}),h=n.data.get(c.dataId).values,d=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(u),{real:h,imag:d}}return s}{const t=function(t,e,n){const i=new Float32Array(2*e);for(let r=0;r<e;r++){let s=0,o=0;for(let i=0;i<e;i++){const a=d.exponent(r*i,e,n),l=d.getComplexWithIndex(t,i);s+=l.real*a.real-l.imag*a.imag,o+=l.real*a.imag+l.imag*a.real}n&&(s/=e,o/=e),d.assignToTypedArray(i,s,o,r)}return i}(d.mergeRealAndImagArrays(o,a),r,e);return d.splitRealAndImagArrays(t)}var l}function NJ(t,e,n,i,r){if(1===n)return{real:t,imag:e};const s=d.mergeRealAndImagArrays(t,e),o=n/2,a=d.complexWithEvenIndex(s),l=a.real,c=a.imag,u=[l.length],h=r.makeTensorInfo(u,"float32",l),p=r.makeTensorInfo(u,"float32",c),f=hY({inputs:{real:h,imag:p},backend:r}),m=d.complexWithOddIndex(s),g=m.real,y=m.imag,v=[g.length],b=r.makeTensorInfo(v,"float32",g),A=r.makeTensorInfo(v,"float32",y),x=hY({inputs:{real:b,imag:A},backend:r}),w=NJ(l,c,o,i,r),_=w.real,S=w.imag,E=[_.length],C=r.makeTensorInfo(E,"float32",_),I=r.makeTensorInfo(E,"float32",S),T=hY({inputs:{real:C,imag:I},backend:r}),M=NJ(g,y,o,i,r),k=M.real,R=M.imag,N=[k.length],L=r.makeTensorInfo(N,"float32",k),D=r.makeTensorInfo(N,"float32",R),B=hY({inputs:{real:L,imag:D},backend:r}),O=d.exponents(n,i),P=[O.real.length],F=r.makeTensorInfo(P,"float32",O.real),$=r.makeTensorInfo(P,"float32",O.imag),z=hY({inputs:{real:F,imag:$},backend:r}),U=JK({inputs:{a:z,b:B},backend:r}),H=wY({inputs:{a:T,b:U},backend:r}),V=TJ({inputs:{a:T,b:U},backend:r}),G=fY({inputs:{input:H},backend:r}),W=fY({inputs:{input:V},backend:r}),j=_K({inputs:{input:H},backend:r}),Q=_K({inputs:{input:V},backend:r}),q=EK({inputs:[G,W],backend:r,attrs:{axis:0}}),X=EK({inputs:[j,Q],backend:r,attrs:{axis:0}}),Y=r.data.get(q.dataId).values,K=r.data.get(X.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(A),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(C),r.disposeIntermediateTensorInfo(I),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(L),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo($),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(Q),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(X),{real:Y,imag:K}}const LJ={kernelName:yR,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e,s=i.sizeFromShape(r.shape),o=r.shape[r.shape.length-1],a=SY({inputs:{x:r},backend:n,attrs:{shape:[s/o,o]}}),l=kJ(a,!1,n),c=SY({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),c}};function DJ(t){const{backend:e,attrs:n}=t,{shape:r,value:s,dtype:o}=n,a=o||i.inferDtype(s),l=i.getArrayFromDType(a,i.sizeFromShape(r));return function(t,e,n){t.fill(e)}(l,s),e.makeTensorInfo(r,a,l)}const BJ={kernelName:vR,backendName:"cpu",kernelFunc:DJ},OJ={kernelName:bR,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,r=e,s=i.getTypedArrayFromDType(n.dtype,i.sizeFromShape(n.shape)),[o,a,l,c]=n.shape,u=r.data.get(n.dataId).values;for(let i=0;i<o;i++){const t=i*l*a*c;for(let e=0;e<a;e++){const n=e*(l*c);for(let e=0;e<l;e++){const i=e*c;for(let r=0;r<c;r++){const o=Math.round(l-e-1),a=t+n+i+r;let h=u[a];o>=0&&o<l&&(h=u[t+n+o*c+r]),s[a]=h}}}}return{dataId:r.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},PJ=mK(t=>Math.floor(t)),FJ=QX(AR,PJ),$J={kernelName:AR,backendName:"cpu",kernelFunc:FJ},zJ=tY((t,e)=>Math.floor(t/e)),UJ=vY(xR,zJ,null,"int32"),HJ={kernelName:xR,backendName:"cpu",kernelFunc:UJ},VJ={kernelName:mL,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=i;let m=IK({inputs:{x:r,filter:s},backend:n,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(o){const t=m;m=wY({inputs:{a:m,b:o},backend:n}),n.disposeIntermediateTensorInfo(t)}if(p){const t=m;m=uY(n,m,p,a,f),n.disposeIntermediateTensorInfo(t)}return m}},GJ={kernelName:gL,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=i;let m=HK({inputs:{x:r,filter:s},backend:n,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(o){const t=m;m=wY({inputs:{a:m,b:o},backend:n}),n.disposeIntermediateTensorInfo(t)}if(p){const t=m;m=uY(n,m,p,a,f),n.disposeIntermediateTensorInfo(t)}return m}};function WJ(t,e,n,i,r,s,o,a,l){const c=RB([i,s],n);for(let u=0;u<i;u++){const n=[];let i=0;for(let e=0;e<r;e++){const s=t[u*r+e];i+=s*o[e],n.push(s)}if(i<0||i>=l/s)throw new Error(`Invalid indices: ${n} does not index into ${a}`);for(let t=0;t<s;t++)c.values[u*s+t]=e.get(...e.indexToLoc(i*s+t))}return c}const jJ={kernelName:SR,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{params:r,indices:s}=e,o=i.sizeFromShape(r.shape),a=s.shape,l=a[a.length-1],[c,u,h,p]=d.prepareAndValidate(r,s);if(0===u)return n.makeTensorInfo(c,r.dtype,[]);const f=WJ(n.data.get(s.dataId).values,n.bufferSync(r),r.dtype,u,l,h,p,r.shape,o);return n.makeTensorInfo(c,r.dtype,f.values)}};function QJ(t,e,n){const i=RB(n,t.dtype);for(let r=0;r<i.size;++r){const n=i.indexToLoc(r).slice(),s=e.locToIndex([n[0],n[2]]);n[2]=e.values[s];const o=t.locToIndex(n);i.values[r]=t.values[o]}return i}const qJ={kernelName:_R,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,indices:o}=e,{axis:a,batchDims:l}=r;VX([s,o],"gatherV2");let c=l;null==l&&(c=0);const u=i.sizeFromShape(o.shape),h=i.parseAxisParam(a,s.shape)[0],p=d.segment_util.collectGatherOpShapeInfo(s,o,h,c),f=SY({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=SY({inputs:{x:o},backend:n,attrs:{shape:[p.batchSize,u/p.batchSize]}}),g=[p.batchSize,p.outerSize,u/p.batchSize,p.sliceSize],y=n.bufferSync(m),v=QJ(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,v.dtype,v.values)}},XJ=tY((t,e)=>t>e?1:0),YJ=vY(ER,XJ,null,"bool"),KJ={kernelName:ER,backendName:"cpu",kernelFunc:YJ},JJ=tY((t,e)=>t>=e?1:0),ZJ=vY(CR,JJ,null,"bool"),tZ={kernelName:CR,backendName:"cpu",kernelFunc:ZJ},eZ={kernelName:TR,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e,s=i.sizeFromShape(r.shape),o=r.shape[r.shape.length-1],a=SY({inputs:{x:r},backend:n,attrs:{shape:[s/o,o]}}),l=kJ(a,!0,n),c=SY({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),c}},nZ=jX(kR,t=>Number.isFinite(t)?1:0,"bool"),iZ={kernelName:kR,backendName:"cpu",kernelFunc:nZ},rZ=jX(RR,t=>Math.abs(t)===1/0?1:0,"bool"),sZ={kernelName:RR,backendName:"cpu",kernelFunc:rZ},oZ=jX(NR,t=>Number.isNaN(t)?1:0,"bool"),aZ={kernelName:NR,backendName:"cpu",kernelFunc:oZ},lZ=tY((t,e)=>t<e?1:0),cZ=vY(DR,lZ,null,"bool"),uZ={kernelName:DR,backendName:"cpu",kernelFunc:cZ},hZ=tY((t,e)=>t<=e?1:0),dZ=vY(BR,hZ,null,"bool"),pZ={kernelName:BR,backendName:"cpu",kernelFunc:dZ};function fZ(t,e,n){const r=(e-t)/(n-1),s=i.makeZerosTypedArray(n,"float32");s[0]=t;for(let i=1;i<s.length;i++)s[i]=s[i-1]+r;return s}const mZ={kernelName:OR,backendName:"cpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:i,stop:r,num:s}=n,o=fZ(i,r,s);return e.makeTensorInfo([o.length],"float32",o)}},gZ=mK(t=>Math.log(t)),yZ=QX(PR,gZ),vZ={kernelName:PR,backendName:"cpu",kernelFunc:yZ},bZ=jX(FR,t=>Math.log1p(t)),AZ={kernelName:FR,backendName:"cpu",kernelFunc:bZ},xZ=tY((t,e)=>t&&e),wZ=vY($R,xZ,null,"bool"),_Z={kernelName:$R,backendName:"cpu",kernelFunc:wZ},SZ=jX(zR,t=>t?0:1,"bool"),EZ={kernelName:zR,backendName:"cpu",kernelFunc:SZ},CZ=tY((t,e)=>t||e),IZ=vY(UR,CZ,null,"bool"),TZ={kernelName:UR,backendName:"cpu",kernelFunc:IZ},MZ={kernelName:HR,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{depthRadius:o,bias:a,alpha:l,beta:c}=r;VX(s,"LRN");const u=s.shape[3],h=u-1,d=n.data.get(s.dataId).values,p=i.sizeFromShape(s.shape),f=new Float32Array(p);function m(t){const e=t%u;let n=t-e+Math.max(0,e-o);const i=t-e+Math.min(e+o,h);let r=0;for(;n<=i;n++){const t=d[n];r+=t*t}return r}for(let i=0;i<p;i++){const t=m(i),e=d[i]*Math.pow(a+l*t,-c);f[i]=e}return n.makeTensorInfo(s.shape,s.dtype,f)}},kZ={kernelName:VR,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,y:o,dy:a}=e,{depthRadius:l,bias:c,alpha:u,beta:h}=r;VX(a,"LRNGrad");const d=i.sizeFromShape(a.shape),p=a.shape[3],f=n.data.get(a.dataId).values,m=n.data.get(s.dataId).values,g=n.data.get(o.dataId).values,y=new Float32Array(d),v=d;for(let i=0;i<v;i++){const t=i%p,e=i-t+Math.max(0,t-l),n=i-t+Math.min(p,t+l+1);let r=0;for(let i=e;i<n;i++)r+=Math.pow(m[i],2);r=u*r+c;for(let s=e;s<n;s++){let t=-2*u*h*m[s]*g[i]/r;i===s&&(t+=Math.pow(r,-h)),t*=f[i],y[s]+=t}}return n.makeTensorInfo(a.shape,s.dtype,y)}};function RZ(t,e,n,r){const s=i.getTypedArrayFromDType(r,i.sizeFromShape(n));for(let i=0;i<s.length;++i){const n=i*e;let r=t[n];for(let i=0;i<e;++i){const e=t[n+i];(Number.isNaN(e)||e>r)&&(r=e)}s[i]=r}return s}function NZ(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reductionIndices:o,keepDims:a}=r,l=n;let c=s.shape;const u=c.length,h=i.parseAxisParam(o,c);let p=h;const f=d.getAxesPermutation(p,u);let m=l.data.get(s.dataId).values;if(null!=f){const t=new Array(u);for(let e=0;e<t.length;e++)t[e]=c[f[e]];m=OY(m,c,s.dtype,f,t),p=d.getInnerMostAxes(p.length,u),c=t}VX(s,"max"),d.assertAxesAreInnerMostDims("max",p,u);const[g,y]=d.computeOutAndReduceShapes(c,p),v=RZ(m,i.sizeFromShape(y),g,s.dtype),b=l.write(v,g,s.dtype);let A=g;return a&&(A=d.expandShapeToKeepDim(g,h)),{dataId:b,shape:A,dtype:s.dtype}}const LZ={kernelName:GR,backendName:"cpu",kernelFunc:NZ},DZ=tY((t,e)=>Math.max(t,e)),BZ=vY(WR,DZ),OZ={kernelName:WR,backendName:"cpu",kernelFunc:BZ},PZ={kernelName:jR,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;VX(s,"maxPool");const{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=r;i.assert(d.eitherStridesOrDilationsAreOne(a,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`);const u=d.computePool2DInfo(s.shape,o,a,1,l,c);let h;if(1===u.filterWidth&&1===u.filterHeight&&i.arraysEqual(u.inShape,u.outShape))h=YX({inputs:{x:s},backend:n});else{const t=n.data.get(s.dataId).values,e=i.computeStrides(s.shape),r=tK(t,0,s.dtype,e,u,"max");h=n.makeTensorInfo(u.outShape,s.dtype,r.values)}return h}},FZ={kernelName:qR,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:c,dataFormat:u}=r;VX(s,"maxPool3d");const h=d.computePool3DInfo(s.shape,o,a,1,l,c,u),p=nK(n.data.get(s.dataId).values,0,s.dtype,i.computeStrides(s.shape),h,"max");return n.makeTensorInfo(p.shape,"float32",p.values)}},$Z={kernelName:XR,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,input:s}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=i;VX([r,s],"maxPool3DGrad");const u=d.computePool3DInfo(s.shape,o,a,1,l,c),h=function(t,e){const n=RB(e.outShape,"int32"),i=e.strideDepth,r=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left;for(let m=0;m<e.batchSize;++m)for(let g=0;g<e.inChannels;++g)for(let y=0;y<e.outDepth;++y){const v=y*i-d;let b=v;for(;b<0;)b+=o;const A=Math.min(e.inDepth,c+v);for(let i=0;i<e.outHeight;++i){const c=i*r-p;let d=c;for(;d<0;)d+=a;const x=Math.min(e.inHeight,u+c);for(let r=0;r<e.outWidth;++r){const p=r*s-f;let w=p;for(;w<0;)w+=l;const _=Math.min(e.inWidth,h+p);let S=Number.NEGATIVE_INFINITY,E=-1;for(let e=b;e<A;e+=o){const n=e-v;for(let i=d;i<x;i+=a){const r=i-c;for(let s=w;s<_;s+=l){const o=s-p,a=t.get(m,e,i,s,g);a>=S&&(S=a,E=n*u*h+r*u+o)}}}n.set(E,m,y,i,r,g)}}}return n}(n.bufferSync(s),u),p=u.strideDepth,f=u.strideHeight,m=u.strideWidth,g=u.dilationDepth,y=u.dilationHeight,v=u.dilationWidth,b=u.effectiveFilterDepth,A=u.effectiveFilterHeight,x=u.effectiveFilterWidth,w=b-1-u.padInfo.front,_=x-1-u.padInfo.left,S=A-1-u.padInfo.top,E=RB(s.shape,"float32"),C=n.bufferSync(r);for(let d=0;d<u.batchSize;++d)for(let t=0;t<u.inChannels;++t)for(let e=0;e<u.inDepth;++e)for(let n=0;n<u.inHeight;++n)for(let i=0;i<u.inWidth;++i){const r=e-w,s=n-S,o=i-_;let a=0;for(let e=0;e<b;e+=g){const n=(r+e)/p;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let i=0;i<A;i+=y){const r=(s+i)/f;if(!(r<0||r>=u.outHeight||Math.floor(r)!==r))for(let s=0;s<x;s+=v){const l=(o+s)/m;if(l<0||l>=u.outWidth||Math.floor(l)!==l)continue;const c=b*A*x-1-h.get(d,n,r,l,t)===e*A*x+i*x+s?1:0;0!==c&&(a+=C.get(d,n,r,l,t)*c)}}}E.set(a,d,e,n,i,t)}return n.makeTensorInfo(E.shape,E.dtype,E.values)}},zZ={kernelName:QR,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,input:s,output:o}=e,a=s;VX([s,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=i,p=d.computePool2DInfo(a.shape,l,c,1,u,h),f=n.data.get(a.dataId).values,m=RB(p.outShape,a.dtype,eK(f,a.shape,a.dtype,p).values),g=p.strideHeight,y=p.strideWidth,v=p.dilationHeight,b=p.dilationWidth,A=p.effectiveFilterHeight,x=p.effectiveFilterWidth,w=x-1-p.padInfo.left,_=A-1-p.padInfo.top,S=RB(a.shape,"float32"),E=n.data.get(r.dataId).values,C=RB(r.shape,"float32",E);for(let d=0;d<p.batchSize;++d)for(let t=0;t<p.inChannels;++t)for(let e=0;e<p.inHeight;++e)for(let n=0;n<p.inWidth;++n){const i=e-_,r=n-w;let s=0;for(let e=0;e<A;e+=v){const n=(i+e)/g;if(!(n<0||n>=p.outHeight||Math.floor(n)!==n))for(let i=0;i<x;i+=b){const o=(r+i)/y;if(o<0||o>=p.outWidth||Math.floor(o)!==o)continue;const a=A*x-1-m.get(d,n,o,t)===e*x+i?1:0;0!==a&&(s+=C.get(d,n,o,t)*a)}}S.set(s,d,e,n,t)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}},UZ={kernelName:YR,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:s,strides:o,pad:a,includeBatchInIndex:l}=e,c=n;VX(r,"MaxPoolWithArgmax");const u=c.data.get(r.dataId).values,h=d.computePool2DInfo(r.shape,s,o,[1,1],a),[p,f]=function(t,e,n,r,s){const o=tK(t,0,n,i.computeStrides(e),s,"max"),a=eK(t,e,n,s,!0,r);return[o.values,a.values]}(u,r.shape,r.dtype,l,h),m=c.write(p,h.outShape,r.dtype),g=c.write(f,h.outShape,r.dtype);return[{dataId:m,shape:h.outShape,dtype:r.dtype},{dataId:g,shape:h.outShape,dtype:"int32"}]}},HZ={kernelName:KR,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:a}=r,l=i.parseAxisParam(o,s.shape),c=d.computeOutAndReduceShapes(s.shape,l),u=i.sizeFromShape(c[1]),h=[],p=n.makeTensorInfo([],"float32",new Float32Array([u]));h.push(p);const f=gY({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});h.push(f);const m=SJ({inputs:{a:f,b:p},backend:n});h.push(m);const g=tJ({inputs:{x:m},backend:n,attrs:{axis:o,keepDims:a}});return h.forEach(t=>n.disposeIntermediateTensorInfo(t)),g}},VZ={kernelName:JR,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:a}=r;VX(s,"min");const l=i.parseAxisParam(o,s.shape);let c=l;const u=d.getAxesPermutation(c,s.shape.length);let h=s;null!=u&&(h=PY({inputs:{x:s},backend:n,attrs:{perm:u}}),c=d.getInnerMostAxes(c.length,s.shape.length)),d.assertAxesAreInnerMostDims("min",c,h.shape.length);const[p,f]=d.computeOutAndReduceShapes(h.shape,c),m=i.sizeFromShape(f),g=i.makeZerosTypedArray(i.sizeFromShape(p),h.dtype),y=n.data.get(h.dataId).values;for(let i=0;i<g.length;++i){const t=i*m;let e=y[t];for(let n=0;n<m;++n){const i=y[t+n];(Number.isNaN(i)||i<e)&&(e=i)}g[i]=e}null!=u&&n.disposeIntermediateTensorInfo(h);const v=n.makeTensorInfo(p,h.dtype,g);if(a){const t=SY({inputs:{x:v},backend:n,attrs:{shape:d.expandShapeToKeepDim(p,l)}});return n.disposeIntermediateTensorInfo(v),t}return v}},GZ=tY((t,e)=>Math.min(t,e)),WZ=vY(ZR,GZ),jZ={kernelName:ZR,backendName:"cpu",kernelFunc:WZ},QZ={kernelName:tN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{paddings:o,mode:a}=r;VX(s,"mirrorPad");const l=o.map((t,e)=>t[0]+s.shape[e]+t[1]),c=o.map(t=>t[0]),u=o.map((t,e)=>t[0]+s.shape[e]),h="reflect"===a?0:1,d=n.data.get(s.dataId).values,p=s.shape.length,f=i.computeStrides(s.shape),m=i.sizeFromShape(l),g=l.length,y=i.computeStrides(l),v=i.getTypedArrayFromDType(s.dtype,m);for(let b=0;b<m;b++){let t=i.indexToLoc(b,g,y);for(let n=0;n<g;n++)t[n]<c[n]?t[n]=2*c[n]-t[n]-h:t[n]>=u[n]&&(t[n]=2*(u[n]-1)-t[n]+h);t=t.map((t,e)=>t-c[e]);const e=i.locToIndex(t,p,f);v[b]=d[e]}return{dataId:n.write(v,l,s.dtype),shape:l,dtype:s.dtype}}},qZ=tY((t,e)=>{const n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e}),XZ=vY(eN,qZ),YZ={kernelName:eN,backendName:"cpu",kernelFunc:XZ};function KZ(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{dim:o}=r,a=s.shape.length;let l=o;if(-1===l&&(l=a-1),l!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${l}`);const c=i.parseAxisParam([l],s.shape),u=NZ({inputs:{x:s},backend:n,attrs:{reductionIndices:c,keepDims:!1}}),h=d.expandShapeToKeepDim(u.shape,c),p=SY({inputs:{x:u},backend:n,attrs:{shape:h}}),f=TJ({inputs:{a:s,b:p},backend:n}),m=gJ({inputs:{x:f},backend:n}),g=tJ({inputs:{x:m},backend:n,attrs:{axis:c,keepDims:!1}}),y=SY({inputs:{x:g},backend:n,attrs:{shape:h}}),v=SJ({inputs:{a:m,b:y},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),v}const JZ={kernelName:HN,backendName:"cpu",kernelFunc:KZ},ZZ={kernelName:nN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{numSamples:o,seed:a,normalized:l}=r;VX(s,"multinomial");const c=l?s:KZ({inputs:{logits:s},backend:n,attrs:{dim:-1}}),u=c.shape[0],h=c.shape[1],d=n.data.get(c.dataId).values,p=[u,o],f=i.makeZerosTypedArray(i.sizeFromShape(p),"int32");for(let i=0;i<u;++i){const t=i*h,e=new Float32Array(h-1);e[0]=d[t];for(let i=1;i<e.length;++i)e[i]=e[i-1]+d[t+i];const n=pF.alea(a.toString()),r=i*o;for(let i=0;i<o;++i){const t=n();f[r+i]=e.length;for(let n=0;n<e.length;n++)if(t<e[n]){f[r+i]=n;break}}}return l||n.disposeIntermediateTensorInfo(c),n.makeTensorInfo(p,"int32",f)}};function t0(t,e,n){const r=i.createScalarValue(-1,n);return YK([],e,r,t,n)}const e0={kernelName:rN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:i}=e;VX(i,"neg");const r=n.data.get(i.dataId).values,[s,o]=t0(r,i.shape,i.dtype);return n.makeTensorInfo(o,i.dtype,s)}},n0=p.nonMaxSuppressionV3Impl,i0={kernelName:oN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{boxes:r,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=i;VX(r,"NonMaxSuppression");const c=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,{selectedIndices:h}=n0(c,u,o,a,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},r0=p.nonMaxSuppressionV4Impl,s0={kernelName:aN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{boxes:r,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=i;VX(r,"NonMaxSuppressionPadded");const u=n.data.get(r.dataId).values,h=n.data.get(s.dataId).values,{selectedIndices:d,validOutputs:p}=r0(u,h,o,a,l,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},o0=p.nonMaxSuppressionV5Impl,a0={kernelName:lN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{boxes:r,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=i;VX(r,"NonMaxSuppressionWithScore");const u=n.data.get(r.dataId).values,h=n.data.get(s.dataId).values,d=o,p=a,f=l,m=c,{selectedIndices:g,selectedScores:y}=o0(u,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},l0=tY((t,e)=>t!==e?1:0),c0=vY(sN,l0,null,"bool"),u0={kernelName:sN,backendName:"cpu",kernelFunc:c0},h0={kernelName:uN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s}=e,{depth:o,onValue:a,offValue:l}=r;VX(s,"oneHot");const c=i.sizeFromShape(s.shape),u=new Float32Array(c*o);u.fill(l);const h=n.data.get(s.dataId).values;for(let i=0;i<c;++i)h[i]>=0&&h[i]<o&&(u[i*o+h[i]]=a);return n.makeTensorInfo([...s.shape,o],"int32",u)}};function d0(t){const{inputs:e,backend:n}=t,{x:i}=e;if("string"===i.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===i.dtype){const t=fY({inputs:{input:i},backend:n}),e=d0({inputs:{x:t},backend:n}),r=_K({inputs:{input:i},backend:n}),s=d0({inputs:{x:r},backend:n}),o=hY({inputs:{real:e,imag:s},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),o}return DJ({backend:n,attrs:{shape:i.shape,value:0,dtype:i.dtype}})}const p0={kernelName:uL,backendName:"cpu",kernelFunc:d0},f0={kernelName:cN,backendName:"cpu",kernelFunc:function t(e){const{inputs:n,backend:i}=e,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const e=fY({inputs:{input:r},backend:i}),n=t({inputs:{x:e},backend:i}),s=_K({inputs:{input:r},backend:i}),o=d0({inputs:{x:s},backend:i}),a=hY({inputs:{real:n,imag:o},backend:i});return i.disposeIntermediateTensorInfo(e),i.disposeIntermediateTensorInfo(n),i.disposeIntermediateTensorInfo(s),i.disposeIntermediateTensorInfo(o),a}return DJ({backend:i,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function m0(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r;if(1===e.length)return vJ({inputs:{input:e[0]},backend:n,attrs:{dim:s}});const o=e[0].shape,a=e[0].dtype;e.forEach(t=>{i.assertShapesMatch(o,t.shape,"All tensors passed to stack must have matching shapes"),i.assert(a===t.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],c=EK({inputs:e.map(t=>{const e=vJ({inputs:{input:t},backend:n,attrs:{dim:s}});return l.push(e),e}),backend:n,attrs:{axis:s}});return l.forEach(t=>n.disposeIntermediateTensorInfo(t)),c}const g0={kernelName:hN,backendName:"cpu",kernelFunc:m0},y0={kernelName:dN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{paddings:o,constantValue:a}=r;VX(s,"pad");const l=o.map((t,e)=>t[0]+s.shape[e]+t[1]),c=o.map(t=>t[0]),u=n.data.get(s.dataId).values,h=i.sizeFromShape(s.shape),d=s.shape.length,p=i.computeStrides(s.shape),f=i.sizeFromShape(l),m=l.length,g=i.computeStrides(l),y=i.getTypedArrayFromDType(s.dtype,f);0!==a&&y.fill(a);for(let v=0;v<h;v++){const t=i.indexToLoc(v,d,p).map((t,e)=>t+c[e]);y[i.locToIndex(t,m,g)]=u[v]}return{dataId:n.write(y,l,s.dtype),shape:l,dtype:s.dtype}}},v0=tY((t,e)=>Math.pow(t,e)),b0=vY(pN,v0),A0={kernelName:pN,backendName:"cpu",kernelFunc:b0};function x0(t,e,n,r){const[s,o]=d.computeOutAndReduceShapes(t,r),a=dD(e,"int32"),l=i.makeZerosTypedArray(i.sizeFromShape(s),a),c=i.sizeFromShape(o);for(let i=0;i<l.length;++i){const t=i*c;let e=1;for(let i=0;i<c;++i)e*=n[t+i];l[i]=e}return{outVals:l,outShape:s,outDtype:a}}const w0={kernelName:mN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:a}=r;VX(s,"prod");const l=s.shape.length,c=i.parseAxisParam(o,s.shape),u=d.getAxesPermutation(c,l);let h=c,p=s;const f=[];null!=u&&(p=PY({inputs:{x:s},backend:n,attrs:{perm:u}}),f.push(p),h=d.getInnerMostAxes(h.length,l));const m=n.data.get(p.dataId).values,{outVals:g,outShape:y,outDtype:v}=x0(p.shape,p.dtype,m,h);let b=y;return a&&(b=d.expandShapeToKeepDim(y,c)),f.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.makeTensorInfo(b,v,g)}};function _0(t,e,n,r){if(t===e||t<e&&n<0||e<t&&n>1)return i.makeZerosTypedArray(0,r);const s=Math.abs(Math.ceil((e-t)/n)),o=i.makeZerosTypedArray(s,r);e<t&&1===n&&(n=-1),o[0]=t;for(let i=1;i<o.length;i++)o[i]=o[i-1]+n;return o}const S0={kernelName:gN,backendName:"cpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:i,stop:r,dtype:s,step:o}=n,a=_0(i,r,o,s);return e.makeTensorInfo([a.length],s,a)}},E0=jX(vN,t=>1/t),C0={kernelName:vN,backendName:"cpu",kernelFunc:E0},I0={kernelName:_N,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:o,halfPixelCenters:a,size:l}=r;VX(s,"resizeBilinear");const c=i.computeStrides(s.shape),[u,h]=l,[d,p,f,m]=s.shape,g=n.data.get(s.dataId).values,y=new Float32Array(i.sizeFromShape([d,u,h,m])),v=[o&&u>1?p-1:p,o&&h>1?f-1:f],b=[o&&u>1?u-1:u,o&&h>1?h-1:h];let A=0;const x=v[0]/b[0],w=v[1]/b[1];for(let i=0;i<d;i++)for(let t=0;t<u;t++){let e;e=a?x*(t+.5)-.5:x*t;const n=Math.max(0,Math.floor(e)),r=e-n,s=Math.min(p-1,Math.ceil(e)),o=i*c[0]+n*c[1],l=i*c[0]+s*c[1];for(let t=0;t<h;t++){let e;e=a?w*(t+.5)-.5:w*t;const n=Math.max(0,Math.floor(e)),i=e-n,s=Math.min(f-1,Math.ceil(e)),u=o+n*c[2],h=l+n*c[2],d=o+s*c[2],p=l+s*c[2];for(let t=0;t<m;t++){const e=g[u+t],n=g[h+t],s=e+(g[d+t]-e)*i;y[A++]=s+(n+(g[p+t]-n)*i-s)*r}}}return n.makeTensorInfo([d,u,h,m],"float32",y)}},T0={kernelName:SN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:o}=e,{alignCorners:a}=r;VX([o,s],"resizeBilinearGrad");const l=i.computeStrides(s.shape),[c,u,h,d]=s.shape,[,p,f]=o.shape,m=new Float32Array(c*u*h*d),g=[a&&p>1?u-1:u,a&&f>1?h-1:h],y=[a&&p>1?p-1:p,a&&f>1?f-1:f],v=g[0]/y[0],b=g[1]/y[1],A=n.data.get(o.dataId).values;let x=0;for(let i=0;i<c;i++){const t=i*l[0];for(let e=0;e<p;e++){const n=e*v,i=Math.floor(n),r=Math.min(Math.ceil(n),u-1),s=t+i*l[1],o=t+r*l[1],a=n-i,c=1-a;for(let t=0;t<f;t++){const e=t*b,n=Math.floor(e),i=Math.min(Math.ceil(e),h-1),r=e-n,u=1-r,p=s+n*l[2],f=s+i*l[2],g=o+n*l[2],y=o+i*l[2],v=c*u,w=c*r,_=a*u,S=a*r;for(let t=0;t<d;t++){const e=A[x++];m[p+t]+=e*v,m[f+t]+=e*w,m[g+t]+=e*_,m[y+t]+=e*S}}}}return n.makeTensorInfo([c,h,u,d],"float32",m)}},M0={kernelName:xN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:o,halfPixelCenters:a,size:l}=r;VX(s,"resizeNearestNeighbor");const c=i.computeStrides(s.shape),[u,h]=l,[d,p,f,m]=s.shape,g=n.data.get(s.dataId).values,y=new Float32Array(d*u*h*m),v=[o&&u>1?p-1:p,o&&h>1?f-1:f],b=[o&&u>1?u-1:u,o&&h>1?h-1:h],A=v[0]/b[0],x=v[1]/b[1];let w=0;for(let i=0;i<d;i++){const t=i*c[0];for(let e=0;e<u;e++){const n=a?A*(e+.5):A*e;let i=Math.min(p-1,o?Math.round(n):Math.floor(n));a&&(i=Math.max(0,i));const r=t+i*c[1];for(let t=0;t<h;t++){const e=a?x*(t+.5):x*t;let n=Math.min(f-1,o?Math.round(e):Math.floor(e));a&&(n=Math.max(0,n));const i=r+n*c[2];for(let t=0;t<m;t++)y[w++]=g[i+t]}}}return n.makeTensorInfo([d,u,h,m],s.dtype,y)}},k0={kernelName:wN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:o}=e,{alignCorners:a}=r;VX([o,s],"resizeNearestNeighborGrad");const l=i.computeStrides(s.shape),c=i.computeStrides(o.shape),[u,h,d,p]=s.shape,[,f,m]=o.shape,g=new Float32Array(u*h*d*p),y=n.data.get(o.dataId).values,v=[a&&f>1?h-1:h,a&&m>1?d-1:d],b=[a&&f>1?f-1:f,a&&m>1?m-1:m],A=v[0]/b[0],x=v[1]/b[1],w=1/A,_=1/x,S=2*Math.ceil(w)+2,E=2*Math.ceil(_)+2;for(let i=0;i<u;i++){const t=i*l[0];for(let e=0;e<h;e++){const n=t+e*l[1],i=Math.floor(e*w),r=Math.floor(i-S/2);for(let s=0;s<d;s++){const i=n+s*l[2],o=Math.floor(s*_),u=Math.floor(o-E/2);for(let n=0;n<p;n++){let o=0;for(let i=0;i<S;i++){const l=i+r;if(l<0||l>=f)continue;const p=t+l*c[1],g=l*A;if(e===Math.min(h-1,a?Math.round(g):Math.floor(g)))for(let t=0;t<E;t++){const e=t+u;if(e<0||e>=m)continue;const i=p+e*c[2],r=e*x;s===Math.min(d-1,a?Math.round(r):Math.floor(r))&&(o+=y[i+n])}}g[i+n]=o}}}}return n.makeTensorInfo(s.shape,s.dtype,g)}},R0={kernelName:CN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dims:o}=r;VX(s,"reverse");const a=s.shape.length,l=i.parseAxisParam(o,s.shape);if(0===a)return YX({inputs:{x:s},backend:n});const c=new ZL(s.shape,s.dtype),u=n.bufferSync(s);for(let i=0;i<c.size;i++){const t=c.indexToLoc(i),e=t.slice();l.forEach(t=>e[t]=s.shape[t]-1-e[t]),c.set(u.get(...e),...t)}return n.makeTensorInfo(c.shape,c.dtype,c.values)}},N0={kernelName:pL,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:s,fillValue:o,center:a}=e,l=n,c=i.getTypedArrayFromDType(r.dtype,i.sizeFromShape(r.shape)),[u,h,p,f]=r.shape,[m,g]=d.getImageCenter(a,h,p),y=Math.sin(s),v=Math.cos(s),b=l.data.get(r.dataId).values;for(let i=0;i<u;i++){const t=i*p*h*f;for(let e=0;e<h;e++){const n=e*(p*f);for(let i=0;i<p;i++){const r=i*f;for(let s=0;s<f;s++){const a=[u,e,i,s],l=a[2],d=a[1];let A=(l-m)*v-(d-g)*y,x=(l-m)*y+(d-g)*v;A=Math.round(A+m),x=Math.round(x+g);let w=o;"number"!=typeof o&&(w=3===s?255:o[s]),A>=0&&A<p&&x>=0&&x<h&&(w=b[t+x*(p*f)+A*f+s]),c[t+n+r+s]=w}}}}return{dataId:l.write(c,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},L0=jX(IN,t=>{const e=Math.floor(t);return t-e<.5?Math.floor(t):t-e>.5?Math.ceil(t):e%2==0?e:e+1}),D0={kernelName:IN,backendName:"cpu",kernelFunc:L0},B0=mK(t=>1/Math.sqrt(t)),O0=QX(TN,B0),P0={kernelName:TN,backendName:"cpu",kernelFunc:O0};function F0(t,e,n,i,r,s,o,a,l,c){const u=[i/r,r],h=t.values,d=e.values;if(0===i)return RB(n,e.dtype);const p=RB(u,e.dtype);p.values.fill(l);for(let f=0;f<s;f++){const t=[];let s=0;for(let e=0;e<o;e++){const n=h[f*o+e];t.push(n),s+=n*a[e]}if(s<0||s>=i/r)throw new Error(`Invalid indices: ${t} does not index into ${n}`);for(let n=0;n<r;n++)c?p.values[s*r+n]+=d[f*r+n]:p.values[s*r+n]=0===e.rank?d[0]:d[f*r+n]}return p}const $0={kernelName:MN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{indices:r,updates:s}=e,{shape:o}=i,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=d.calculateShapes(s,r,o),p=F0(n.bufferSync(r),n.bufferSync(s),o,h,c,l,a,u,0,!0);return n.makeTensorInfo(o,p.dtype,p.values)}},z0={kernelName:kN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:r,t:s,e:o}=e;VX([r,s,o],"select");const a=r.shape.length,l=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,u=n.data.get(o.dataId).values,h=dD(s.dtype,o.dtype),d=i.makeZerosTypedArray(i.sizeFromShape(s.shape),h);let p=0;const f=0===a||a>1||1===s.shape.length?1:i.sizeFromShape(s.shape.slice(1));for(let i=0;i<l.length;i++)for(let t=0;t<f;t++)d[p++]=1===l[i]?c[i]:u[i];return n.makeTensorInfo(s.shape,h,d)}},U0=d.SELU_SCALEALPHA,H0=d.SELU_SCALE,V0=jX(RN,t=>t>=0?H0*t:U0*(Math.exp(t)-1)),G0={kernelName:RN,backendName:"cpu",kernelFunc:V0},W0=jX(BN,t=>t<0?-1:t>0?1:0),j0={kernelName:BN,backendName:"cpu",kernelFunc:W0},Q0=jX(LN,t=>Math.sin(t)),q0={kernelName:LN,backendName:"cpu",kernelFunc:Q0},X0=jX(DN,t=>Math.sinh(t)),Y0={kernelName:DN,backendName:"cpu",kernelFunc:X0},K0=Math.log(1.1920928955078125e-7)+2,J0=jX(PN,t=>{const e=t>-K0,n=t<K0,i=Math.exp(t);let r;return r=n?i:e?t:Math.log(1+i),r}),Z0={kernelName:PN,backendName:"cpu",kernelFunc:J0},t1={kernelName:zN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:o,paddings:a}=r;VX([s],"spaceToBatchND");const l=i.sizeFromShape(o),c=[[0,0]];c.push(...a);for(let i=1+o.length;i<s.shape.length;++i)c.push([0,0]);const u=y0.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:c,constantValue:0}}),h=d.getReshaped(u.shape,o,l,!1),p=d.getPermuted(h.length,o.length,!1),f=d.getReshapedPermuted(u.shape,o,l,!1),m=SY({inputs:{x:u},backend:n,attrs:{shape:h}}),g=PY({inputs:{x:m},backend:n,attrs:{perm:p}}),y=SY({inputs:{x:g},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}};function e1(t,e,n,r,s,o,a){const l=e[0],c=o[0],u=new Array(c),h=new Array(l),d=e[1];if(0===c){if(0!==l)throw new Error(`Received SparseTensor with denseShape[0] = 0 but\n         indices.shape[0] = ${l}`);return[i.getArrayFromDType(n,0),[0,d],i.getArrayFromDType(s,0),u,h]}let p=!0,f=0;const m=new Array(c).fill(0);for(let i=0;i<l;++i){const e=t[i*d];if(e<0)throw new Error(`indices(${i}, 0) is invalid: ${e} < 0`);if(e>=c)throw new Error(`indices(${i}, 0) is invalid: ${e} >= ${c}`);++m[e],p=p&&e>=f,f=e}let g=!0;for(let i=0;i<c;++i){const t=0===m[i];u[i]=t,g=g&&!t,m[i]=Math.max(m[i],1),i>0&&(m[i]+=m[i-1])}if(g&&p){const e=t,n=r;for(let t=0;t<l;++t)h[t]=t;return[e,[l,d],n,u,h]}{const e=m[c-1],o=i.getArrayFromDType(n,e*d),p=i.getArrayFromDType(s,e),f=new Array(c).fill(0);for(let n=0;n<l;++n){const e=t[n*d],i=(0===e?0:m[e-1])+f[e];f[e]++;for(let r=0;r<d;++r)o[i*d+r]=t[n*d+r];p[i]=r[n],h[n]=i}for(let t=0;t<c;++t)if(0===f[t]){const e=0===t?0:m[t-1];o[e*d+0]=t;for(let t=1;t<d;++t)o[e*d+t]=0;p[e]=a}return[o,[e,d],p,u,h]}}const n1={kernelName:VN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{indices:i,values:r,denseShape:s,defaultValue:o}=e;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(2!==i.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${i.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n        ${r.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=n.data.get(i.dataId).values,l=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,u=n.data.get(o.dataId).values[0],[h,d,p,f,m]=e1(a,i.shape,i.dtype,l,r.dtype,c,u);return[n.makeTensorInfo(d,i.dtype,h),n.makeTensorInfo([d[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(t=>Number(t)))),n.makeTensorInfo([m.length],i.dtype,new Int32Array(m))]}};function i1(t,e,n,r,s){const o=i.sizeFromShape(r),a=e[0],l=s.length,c=[];let u=1,h=-1;for(let i=0;i<l;++i){const t=s[i];if(-1===t){if(-1!==h)throw new Error(`only one output dimension may be -1, not both ${h} and ${i}`);h=i,c.push(1)}else{if(t<0)throw new Error(`size ${i} must be non-negative, not ${t}`);u*=t,c.push(t)}}if(-1!==h){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const t=Math.trunc(o/u);if(u*t!==o)throw new Error(`Input to reshape is a SparseTensor with ${o}\n          dense values, but the requested shape requires a multiple of ${u}. inputShape=${r} outputShape= ${c}`);c[h]=t}const d=i.sizeFromShape(c);if(d!==o)throw new Error(`Input to reshape is a tensor with ${o} dense values, but the requested shape has ${d}. inputShape=${r} outputShape=${c}`);const p=r.length,f=[];if(p>0){f[p-1]=1;for(let t=p-2;t>=0;--t)f[t]=f[t+1]*r[t+1]}const m=[];if(l>0){m[l-1]=1;for(let t=l-2;t>=0;--t)m[t]=m[t+1]*c[t+1]}const g=i.getArrayFromDType(n,a*l);for(let i=0;i<a;++i){let e=0;for(let n=0;n<p;++n)e+=t[i*p+n]*f[n];for(let t=0;t<l;++t)g[i*l+t]=Math.trunc(e/m[t]),e%=m[t]}return[g,[a,l],c]}const r1={kernelName:GN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{inputIndices:i,inputShape:r,newShape:s}=e;if(2!==i.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${i.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(n.data.get(r.dataId).values),a=n.data.get(i.dataId).values,l=Array.from(n.data.get(s.dataId).values),[c,u,h]=i1(a,i.shape,i.dtype,o,l);return[n.makeTensorInfo(u,i.dtype,c),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}};function s1(t,e,n,r,s,o=!1,a=0){const l=r.length;if(l!==s.length)throw new Error("segmentIds and indices should have same size.");const c=[e[0],t.length/e[0]],u=c[1],h=l>0?s[l-1]+1:0;if(h<0)throw new Error("segment ids must be >= 0");const d=e.slice();d[0]=h;const p=d.reduce((t,e)=>t*e,1),f=i.getArrayFromDType(n,p);if(0===l)return h>0&&f.fill(a),[f,d];if(h<=0)throw new Error("segment ids must be >= 0");let m=0,g=1,y=0,v=s[m];for(;;){let e=0;if(g<l){if(e=s[g],v===e){++g;continue}if(v>=e)throw new Error("segment ids are not increasing")}if(v<0||v>=h)throw new Error(`Segment id ${v} out of range [0, ${h}), possibly because segmentIds input is not sorted.`);v>y&&f.fill(a,y*u,v*u);for(let n=m;n<g;++n){const e=r[n];if(e<0||e>=c[0])throw new Error(`Bad: indices[${n}] == ${r[n]} out of range [0, ${c[0]})`);for(let n=0;n<u;n++)f[v*u+n]+=t[e*u+n]}if(o)for(let t=0;t<u;t++)f[v*u+t]/=g-m;if(m=g,++g,y=v+1,v=e,g>l)break}return y<h&&f.fill(a,y*u,h*u),[f,d]}const o1={kernelName:WN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:i,indices:r,segmentIds:s}=e;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${r.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${s.shape}`);const o=n.data.get(i.dataId).values,a=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,[c,u]=s1(o,i.shape,i.dtype,a,l,!0);return n.makeTensorInfo(u,i.dtype,c)}},a1={kernelName:jN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:i,indices:r,segmentIds:s}=e;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${s.shape}`);const o=n.data.get(i.dataId).values,a=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,[c,u]=s1(o,i.shape,i.dtype,a,l);return n.makeTensorInfo(u,i.dtype,c)}},l1={kernelName:QN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{sparseIndices:r,sparseValues:s,defaultValue:o}=e,{outputShape:a}=i,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:p}=d.calculateShapes(s,r,a),f=F0(n.bufferSync(r),n.bufferSync(s),a,p,u,c,l,h,n.data.get(o.dataId).values[0],!1);return n.makeTensorInfo(a,f.dtype,f.values)}},c1={kernelName:UN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{numOrSizeSplits:o,axis:a}=r,l=i.parseAxisParam(a,s.shape)[0],c=d.prepareSplitSize(s,o,l),u=new Array(s.shape.length).fill(0),h=s.shape.slice();return c.map(t=>{const e=[...h];e[l]=t;const i=cK({inputs:{x:s},backend:n,attrs:{begin:u,size:e}});return u[l]+=t,i})}},u1=jX(FN,t=>Math.sqrt(t)),h1={kernelName:FN,backendName:"cpu",kernelFunc:u1},d1={kernelName:XN,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,i=e;VX(n,"square");const r=i.data.get(n.dataId).values,s=new Float32Array(r.length);for(let o=0;o<r.length;++o){const t=r[o];s[o]=t*t}return{dataId:i.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},p1=tY((t,e)=>{const n=t-e;return n*n}),f1=vY(qN,p1),m1={kernelName:qN,backendName:"cpu",kernelFunc:f1},g1=jX(hL,(t,e)=>{const n=e;return isNaN(t)?NaN:t>0?1:n.alpha}),y1={kernelName:hL,backendName:"cpu",kernelFunc:g1};function v1(t,e,n,i){const r=RB(t,e.dtype);for(let s=0;s<r.size;s++){const t=r.indexToLoc(s),o=new Array(t.length);for(let e=0;e<o.length;e++)o[e]=t[e]*n[e]+i[e];r.set(e.get(...o),...t)}return r}const b1={kernelName:YN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{begin:s,end:o,strides:a,beginMask:c,endMask:u,ellipsisMask:h,newAxisMask:d,shrinkAxisMask:p}=i;VX(r,"stridedSlice");const{nonStrided:f,$begin:m,$strides:g,size:y,newShape:v,outShape:b}=l.sliceInfo(r.shape,s,o,a,c,u,h,d,p),A=SY({inputs:{x:r},backend:n,attrs:{shape:v}});let x;if(f){const t=cK({inputs:{x:A},backend:n,attrs:{begin:m,size:y}});x=SY({inputs:{x:t},backend:n,attrs:{shape:b}}),n.disposeIntermediateTensorInfo(t)}else if(b.some(t=>0===t))x=n.makeTensorInfo(b,r.dtype,[]);else{const t=v1(b,n.bufferSync(A),g,m);x=n.makeTensorInfo(t.shape,t.dtype,t.values)}const w=SY({inputs:{x:x},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(A),n.disposeIntermediateTensorInfo(x),w}};class A1{constructor(t,e,n,r,s,o){this.separator=i.encodeString(t),this.nGramWidths=e,this.leftPad=i.encodeString(n),this.rightPad=i.encodeString(r),this.padWidth=s,this.preserveShort=o}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const n=this.getPadWidth(e);return Math.max(0,t+2*n-e+1)}createNGrams(t,e,n,i,r,s){for(let o=0;o<r;++o){const a=this.getPadWidth(s),l=Math.max(0,a-o),c=Math.max(0,a-(r-(o+1))),u=s-(l+c),h=e+(l>0?0:o-a);let d=0;d+=l*this.leftPad.length;for(let e=0;e<u;++e)d+=t[h+e].length;d+=c*this.rightPad.length,d+=(l+c+u-1)*this.separator.length,n[i+o]=new Uint8Array(d);const p=n[i+o];let f=0;const m=t=>t.forEach(t=>p[f++]=t);for(let t=0;t<l;++t)m(this.leftPad),m(this.separator);for(let e=0;e<u-1;++e)m(t[h+e]),m(this.separator);if(u>0){m(t[h+u-1]);for(let t=0;t<c;++t)m(this.separator),m(this.rightPad)}else{for(let t=0;t<c-1;++t)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(t,e){const n=t.length,r=e.length;if(r>0){let t=e[0];if(0!==t)throw new Error(`First split value must be 0, got ${t}`);for(let i=1;i<r;++i){let r=e[i]>=t;if(r=r&&e[i]<=n,!r)throw new Error(`Invalid split value ${e[i]}, must be in [${t}, ${n}]`);t=e[i]}if(t!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${t}`)}const s=r-1,o=i.getArrayFromDType("int32",r);if(0===n||0===r){const t=new Array(n);for(let e=0;e<=s;++e)o[e]=0;return[t,o]}o[0]=0;for(let i=1;i<=s;++i){const t=e[i]-e[i-1];let n=0;this.nGramWidths.forEach(e=>{n+=this.getNumNGrams(t,e)}),this.preserveShort&&t>0&&0===n&&(n=1),o[i]=o[i-1]+n}const a=new Array(o[s]);for(let i=0;i<s;++i){const n=e[i];let r=o[i];if(this.nGramWidths.forEach(s=>{const o=this.getNumNGrams(e[i+1]-e[i],s);this.createNGrams(t,n,a,r,o,s),r+=o}),this.preserveShort&&r===o[i]){const s=e[i+1]-e[i];if(0===s)continue;this.createNGrams(t,n,a,r,1,s+2*this.padWidth)}}return[a,o]}}function x1(t,e,n,i,r,s,o,a){return new A1(n,i,r,s,o,a).compute(t,e)}const w1={kernelName:KN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{separator:r,nGramWidths:s,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=i,{data:u,dataSplits:h}=e,d=n.data.get(u.dataId).values,p=n.data.get(h.dataId).values,[f,m]=x1(d,p,r,s,o,a,l,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};function _1(t,e,n){if(!t.length)return[];if(0===e.length){const e=new Array(t.length);for(let n=0;n<t.length;++n)e[n]=t.subarray(n,n+1);return e}if(1===e.length){const i=e[0],r=[];let s=t.indexOf(i);for(;-1!==s;){const e=t.subarray(0,s);n&&0===e.length||r.push(e),s=(t=t.subarray(s+1)).indexOf(i)}return n&&0===t.length||r.push(t),r}const i=[];let r=0;for(let s=0;s<t.length+1;s++)if(s===t.length||-1!==e.indexOf(t[s])){const e=t.subarray(r,s);n&&0===e.length||i.push(e),r=s+1}return i}function S1(t,e,n){const r=t.length,s=[];let o=0,a=0;const l=new Array(r);for(let i=0;i<r;++i){const r=_1(t[i],e,n),c=r.length;l[i]=c,o+=c,a=Math.max(a,c),s.push(...r)}const c=i.getArrayFromDType("int32",2*o),u=new Array(o),h=[r,a];let d=0;for(let i=0;i<r;++i)for(let t=0;t<l[i];++t)c[2*d]=i,c[2*d+1]=t,u[d]=s[d],++d;return[c,u,h]}const E1={kernelName:JN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{skipEmpty:r}=i,{input:s,delimiter:o}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values[0],[c,u,h]=S1(a,l,r),d=u.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};function C1(t,e){const n=i.getArrayFromDType("int32",t.length);for(let r=0;r<t.length;++r)n[r]=i.fingerPrint64(t[r]).modulo(e).getLowBitsUnsigned();return n}const I1={kernelName:ZN,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{numBuckets:r}=i,{input:s}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=C1(n.data.get(s.dataId).values,r);return n.makeTensorInfo(s.shape,"int32",o)}},T1=jX(eL,t=>Math.tan(t)),M1={kernelName:eL,backendName:"cpu",kernelFunc:T1},k1=jX(nL,t=>Math.tanh(t));function R1(t,e){const n=new Array(t.rank);for(let r=0;r<n.length;r++)n[r]=t.shape[r]*e[r];const i=RB(n,t.dtype);for(let r=0;r<i.values.length;++r){const e=i.indexToLoc(r),n=new Array(t.rank);for(let i=0;i<n.length;i++)n[i]=e[i]%t.shape[i];const s=t.locToIndex(n);i.values[r]=t.values[s]}return i}const N1=(t,e)=>{const n=e.value-t.value;return 0===n?t.index-e.index:n};function L1(t,e,n=0,r=t.length-1){for(;r>n;){if(r-n>600){const i=r-n+1,s=e-n+1,o=Math.log(i),a=.5*Math.exp(2*o/3),l=.5*Math.sqrt(o*a*(i-a)/i)*Math.sign(s-i/2);L1(t,e,Math.max(n,Math.floor(e-s*a/i+l)),Math.min(r,Math.floor(e+(i-s)*a/i+l)))}const s=t[e];let o=n,a=r;for(i.swap(t,n,e),N1(t[r],s)>0&&i.swap(t,n,r);o<a;){for(i.swap(t,o,a),o++,a--;N1(t[o],s)<0;)o+=1;for(;N1(t[a],s)>0;)a-=1}0===N1(t[n],s)?i.swap(t,n,a):(a+=1,i.swap(t,a,r)),a<=e&&(n=a+1),e<=a&&(r=a-1)}}function D1(t,e,n,r,s){const o=e[e.length-1],[a,l]=[t.length/o,o],c=i.getTypedArrayFromDType(n,a*r),u=i.getTypedArrayFromDType("int32",a*r);for(let i=0;i<a;i++){const e=i*l,n=t.subarray(e,e+l);let o=new Array(n.length);n.forEach((t,e)=>o[e]={value:t,index:e}),r<o.length&&(L1(o,r),o=o.slice(0,r)),s&&o.sort(N1);const a=i*r,h=c.subarray(a,a+r),d=u.subarray(a,a+r);for(let t=0;t<r;t++)h[t]=o[t].value,d[t]=o[t].index}const h=e.slice();return h[h.length-1]=r,[RB(h,n,c),RB(h,"int32",u)]}function B1(t,e,n){switch(n){case"reflect":return function(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const t=2*e;n<t&&(n=t*Math.trunc(-n/t)+n),n=n<-e?n+t:-n-1}else if(n>e-1)if(e<=1)n=0;else{const t=2*e;n-=t*Math.trunc(n/t),n>=e&&(n=t-n-1)}return i.clamp(0,n,e-1)}(t,e);case"wrap":return function(t,e){let n=t;return n<0?e<=1?n=0:n+=e*(Math.trunc(-n/(e-1))+1):n>e-1&&(e<=1?n=0:n-=e*Math.trunc(n/(e-1))),i.clamp(0,n,e-1)}(t,e);case"nearest":return function(t,e){return i.clamp(0,t,e-1)}(t,e);case"constant":default:return function(t,e){return t}(t)}}function O1(t,e,n,i,r,s,o,a,l,c,u){return 0<=a&&a<e&&0<=l&&l<n?t[o*i+a*r+l*s+c]:u}function P1(t,e,n,i,r,s,o,a,l,c,u){return O1(t,e,n,i,r,s,o,Math.round(a),Math.round(l),c,u)}function F1(t,e,n,i,r,s,o,a,l,c,u){const h=Math.floor(a),d=Math.floor(l),p=h+1,f=d+1;return(p-a)*((f-l)*O1(t,e,n,i,r,s,o,h,d,c,u)+(l-d)*O1(t,e,n,i,r,s,o,h,f,c,u))+(a-h)*((f-l)*O1(t,e,n,i,r,s,o,p,d,c,u)+(l-d)*O1(t,e,n,i,r,s,o,p,f,c,u))}function $1(t,e,n,r){const s=i.parseAxisParam(e,n)[0],o=[1,n[0],1];for(let i=0;i<s;i++)o[0]*=n[i];o[1]=n[s];for(let i=s+1;i<n.length;i++)o[2]*=n[i];const a={},l=new Int32Array(n[s]),c=new ZL(o,r,t),u=[],h=1===o[0]&&1===o[2];for(let i=0;i<n[s];i++){let e;if(h)e=t[i].toString();else{const t=[];for(let e=0;e<o[0];e++)for(let n=0;n<o[2];n++)t.push(c.get(e,i,n));e=t.join(",")}if(void 0!==a[e])l[i]=a[e];else{const t=Object.keys(a).length;a[e]=t,l[i]=t,u.push(i)}}const d=o.slice();d[1]=Object.keys(a).length;const p=new ZL(d,r);u.forEach((t,e)=>{for(let n=0;n<o[0];n++)for(let i=0;i<o[2];i++)p.set(c.get(n,t,i),n,e,i)});const f=n.slice();return f[s]=d[1],{outputValues:p.values,outputShape:f,indices:l}}const z1=[TY,kY,NY,DY,_Y,BY,$Y,zY,UY,HY,GY,jY,qY,KY,ZY,iK,rK,sK,oK,IY,aK,hK,fK,yY,vK,AK,dY,xK,CK,MK,kK,TK,NK,LK,RK,BK,PK,FK,$K,zK,UK,VK,GK,WK,jK,QK,XK,qK,EJ,nJ,XX,iJ,oJ,fJ,yJ,bJ,wJ,LJ,BJ,OJ,$J,HJ,VJ,GJ,jJ,qJ,KJ,tZ,KX,eZ,SK,iZ,sZ,aZ,ZX,uZ,pZ,mZ,vZ,AZ,_Z,EZ,TZ,MZ,kZ,OZ,PZ,FZ,$Z,zZ,UZ,LZ,HZ,VZ,jZ,QZ,YZ,ZZ,ZK,e0,i0,s0,a0,u0,h0,f0,g0,y0,A0,iY,w0,S0,mY,C0,sY,aY,EY,I0,T0,M0,k0,R0,N0,D0,P0,$0,z0,G0,cY,j0,q0,Y0,uK,JZ,Z0,t1,n1,r1,o1,a1,l1,c1,h1,d1,m1,y1,b1,w1,E1,I1,MJ,eJ,M1,{kernelName:nL,backendName:"cpu",kernelFunc:k1},{kernelName:iL,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{reps:s}=i;VX(r,"tile");const o=R1(n.bufferSync(r),s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}},{kernelName:rL,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{k:s,sorted:o}=i;VX(r,"topk");const a=n.data.get(r.dataId).values,[l,c]=D1(a,r.shape,r.dtype,s,o);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(c.shape,c.dtype,c.values)]}},FY,{kernelName:sL,backendName:"cpu",kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{image:s,transforms:o}=e,{interpolation:a,fillMode:l,fillValue:c,outputShape:u}=n,[h,d,p,f]=s.shape,[m,g]=null!=u?u:[d,p],y=[h,m,g,f],v=i.computeStrides(s.shape),b=v[0],A=v[1],x=v[2],w=i.getTypedArrayFromDType(s.dtype,i.sizeFromShape(y));w.fill(c);const _=r.data.get(s.dataId).values,S=r.data.get(o.dataId).values;for(let i=0;i<h;++i){const t=1===o.shape[0]?S:S.subarray(8*i,8*i+8);for(let e=0;e<m;++e)for(let n=0;n<g;++n)for(let r=0;r<f;++r){let s;const o=t[6]*n+t[7]*e+1;if(0===o)continue;const u=(t[3]*n+t[4]*e+t[5])/o,h=B1((t[0]*n+t[1]*e+t[2])/o,p,l),f=B1(u,d,l);switch(a){case"nearest":s=P1(_,d,p,b,A,x,i,f,h,r,c);break;case"bilinear":s=F1(_,d,p,b,A,x,i,f,h,r,c);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}w[i*b+e*A+n*x+r]=s}return r.makeTensorInfo(y,s.dtype,w)}return{dataId:r.write(w,y,s.dtype),shape:s.shape,dtype:s.dtype}}},{kernelName:aL,backendName:"cpu",kernelFunc:function(t){const{inputs:e,attrs:n,backend:i}=t,{axis:r}=n,{x:s}=e;VX(s,"unique");const o=i.data.get(s.dataId).values,{outputValues:a,outputShape:l,indices:c}=$1(o,r,s.shape,s.dtype);return[i.makeTensorInfo(l,s.dtype,a),i.makeTensorInfo([c.length],"int32",c)]}},{kernelName:lL,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{value:r}=e;let{axis:s}=i;s<0&&(s+=r.shape.length);const o=r.shape.length,a=r.shape[s],l=new Array(o-1);let c=0;for(let p=0;p<o;p++)p!==s&&(l[c++]=r.shape[p]);const u=new Array(o).fill(0),h=r.shape.slice();h[s]=1;const d=new Array(a);for(let p=0;p<d.length;p++){u[s]=p;const t=cK({inputs:{x:r},backend:n,attrs:{begin:u,size:h}});d[p]=SY({inputs:{x:t},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(t)}return d}},{kernelName:cL,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,segmentIds:o}=e,{numSegments:a}=r;VX(s,"unsortedSegmentSum");const l=[],c=[],u=s.shape.length-o.shape.length;let h=o;for(let i=0;i<u;++i){const t=vJ({inputs:{input:h},backend:n,attrs:{dim:i+1}});h=t,c.push(t)}for(let p=0;p<a;++p){const t=i.createScalarValue(p,"int32"),e=n.makeTensorInfo([],"int32",t),r=sJ({inputs:{a:e,b:h},backend:n}),o=gY({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),a=JK({inputs:{a:o,b:s},backend:n}),u=tJ({inputs:{x:a},backend:n,attrs:{axis:0,keepDims:!1}});l.push(u),c.push(e),c.push(r),c.push(o),c.push(a),c.push(u)}const d=m0({inputs:l,backend:n,attrs:{axis:0}});return c.forEach(t=>n.disposeIntermediateTensorInfo(t)),d}},p0];for(const Set of z1)wL(Set);const U1={},H1={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function V1(t){if(!(t in U1)){const e=function(t){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=function(t){if("undefined"!=typeof OffscreenCanvas&&2===t)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(t);return e.addEventListener("webglcontextlost",e=>{e.preventDefault(),delete U1[t]},!1),1===t?e.getContext("webgl",H1)||e.getContext("experimental-webgl",H1):e.getContext("webgl2",H1)}(t);if(null===e)return console.log("Could not get context for WebGL version",t),null;U1[t]=e}const e=U1[t];return e.isContextLost()?(delete U1[t],V1(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),U1[t])}var G1,W1,j1;function Q1(t,e){return[e,t]}function q1(t){const e=i.sizeFromShape(t),n=Math.ceil(e/4);return i.sizeToSquarishShape(n)}function X1(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function Y1(t,e){const n=t;let i,r,s,o,a,l,c,u,h,d;return 2===hk().getNumber("WEBGL_VERSION")?(i=n.R32F,r=n.R16F,s=n.RGBA16F,o=n.RGBA32F,a=n.RED,c=4,u=1,h=n.HALF_FLOAT,d=n.FLOAT):(i=t.RGBA,r=t.RGBA,s=t.RGBA,o=n.RGBA,a=t.RGBA,c=4,u=4,h=null!=e?e.HALF_FLOAT_OES:null,d=t.FLOAT),l=t.RGBA,{internalFormatFloat:i,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:d}}function K1(t,e){const n=e();return hk().getBool("DEBUG")&&function(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+function(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}(t,e))}(t),n}function J1(t){return!!(hk().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||5.96e-8<Math.abs(t)&&Math.abs(t)<65504)}function Z1(t,e){return o2(t,()=>t.getExtension(e),'Extension "'+e+'" not supported on this browser.')}!function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"}(G1||(G1={})),function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(W1||(W1={})),function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(j1||(j1={}));const t2=/ERROR: [0-9]+:([0-9]+):/g;function e2(t,e){if(K1(t,()=>t.validateProgram(e)),!1===t.getProgramParameter(e,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function n2(t,e,n,i,r,s,o){const a=t.getAttribLocation(e,n);return-1!==a&&(K1(t,()=>t.bindBuffer(t.ARRAY_BUFFER,i)),K1(t,()=>t.vertexAttribPointer(a,r,t.FLOAT,!1,s,o)),K1(t,()=>t.enableVertexAttribArray(a)),!0)}function i2(t,e,n){K1(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),K1(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0))}function r2(t,e){K1(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),K1(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function s2(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}(t,e))}function o2(t,e,n){const i=K1(t,()=>e());if(null==i)throw new Error(n);return i}function a2(t,e=2){return i.sizeFromShape(t.slice(0,t.length-e))}function l2(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function c2(t){let e=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(e=[a2(t),...l2(t)]),e}function u2(t){return t%2==0}function h2(t,e){if(t=t.slice(-2),e=e.slice(-2),i.arraysEqual(t,e))return!0;if(!t.length||!e.length)return!0;if(0===t[0]||0===t[1]||0===e[0]||0===e[1])return!0;if(t.length!==e.length){const n=t.slice(-1)[0],i=e.slice(-1)[0];if(n===i)return!0;if(u2(n)&&u2(i)&&(1===t[0]||1===e[0]))return!0}return t[1]===e[1]&&u2(t[0])&&u2(e[0])}let d2,p2;function f2(t,e){return null!=t.getExtension(e)}function m2(t){try{if(null!=V1(t))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function g2(t){const e=Y1(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const r=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(i),r}function y2(t,e){Array.isArray(t)||(t=[t]),t.forEach(t=>{null!=t&&i.assert("complex64"!==t.dtype,()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}const v2=hk();function b2(){let t,e,n,i,r,s,o,a,l,c;return 2===hk().getNumber("WEBGL_VERSION")?(t="#version 300 es",e="in",n="out",i="in",r="texture",s="outputColor",o="out vec4 outputColor;",a="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",e="attribute",n="varying",i="varying",r="texture2D",s="gl_FragColor",o="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:e,varyingVs:n,varyingFs:i,texture2D:r,output:s,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}function A2(t,e,n="index"){const r=i.computeStrides(e);return r.map((e,i)=>`int ${t[i]} = ${n} / ${e}; ${i===r.length-1?`int ${t[i+1]} = ${n} - ${t[i]} * ${e}`:`index -= ${t[i]} * ${e}`};`).join("")}function x2(t,e,n="index"){const r=i.computeStrides(e);return r.map((e,i)=>`int ${t[i]} = ${n} / outShapeStrides[${i}]; ${i===r.length-1?`int ${t[i+1]} = ${n} - ${t[i]} * outShapeStrides[${i}]`:`index -= ${t[i]} * outShapeStrides[${i}]`};`).join("")}function w2(t){const e=i.computeStrides(t).map(t=>t.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;\n  }\n`}v2.registerFlag("HAS_WEBGL",()=>v2.getNumber("WEBGL_VERSION")>0),v2.registerFlag("WEBGL_VERSION",()=>m2(2)?2:m2(1)?1:0),v2.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),v2.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===v2.get("WEBGL_VERSION")),v2.registerFlag("WEBGL_CPU_FORWARD",()=>!0),v2.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),v2.registerFlag("WEBGL_PACK",()=>v2.getBool("HAS_WEBGL")),v2.registerFlag("WEBGL_PACK_NORMALIZATION",()=>v2.getBool("WEBGL_PACK")),v2.registerFlag("WEBGL_PACK_CLIP",()=>v2.getBool("WEBGL_PACK")),v2.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>v2.getBool("WEBGL_PACK")),v2.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>v2.getBool("WEBGL_PACK")),v2.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>v2.getBool("WEBGL_PACK")),v2.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>v2.getBool("WEBGL_PACK")),v2.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>v2.getBool("WEBGL_PACK")),v2.registerFlag("WEBGL_PACK_REDUCE",()=>v2.getBool("WEBGL_PACK")),v2.registerFlag("WEBGL_LAZILY_UNPACK",()=>v2.getBool("WEBGL_PACK")),v2.registerFlag("WEBGL_CONV_IM2COL",()=>v2.getBool("WEBGL_PACK")),v2.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(t){if(null==d2){const e=V1(t);d2=e.getParameter(e.MAX_TEXTURE_SIZE)}return d2}(v2.getNumber("WEBGL_VERSION"))),v2.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(t){if(null==p2){const e=V1(t);p2=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,p2)}(v2.getNumber("WEBGL_VERSION"))),v2.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=v2.getNumber("WEBGL_VERSION");return 0===t?0:function(t){if(0===t)return 0;let e;const n=V1(t);return e=f2(n,"EXT_disjoint_timer_query_webgl2")&&2===t?2:f2(n,"EXT_disjoint_timer_query")?1:0,e}(t)}),v2.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>v2.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!s.isMobile()),v2.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(t){if(0===t)return!1;const e=V1(t);if(1===t){if(!f2(e,"OES_texture_float"))return!1}else if(!f2(e,"EXT_color_buffer_float"))return!1;return g2(e)}(v2.getNumber("WEBGL_VERSION"))),v2.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!v2.getBool("WEBGL_FORCE_F16_TEXTURES")&&v2.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),v2.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function(t){if(0===t)return!1;const e=V1(t);if(1!==t){if(f2(e,"EXT_color_buffer_float"))return g2(e);const t="EXT_color_buffer_half_float";if(f2(e,t)){const n=e.getExtension(t);return function(t,e){const n=Y1(t,e),i=t.createTexture();t.bindTexture(t.TEXTURE_2D,i),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,i,0);const s=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(i),t.deleteFramebuffer(r),s}(e,n)}return!1}return!!f2(e,"OES_texture_float")&&!!f2(e,"WEBGL_color_buffer_float")&&g2(e)}(v2.getNumber("WEBGL_VERSION"))),v2.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return 2===(t=v2.getNumber("WEBGL_VERSION"))&&null!=V1(t).fenceSync;var t}),v2.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>v2.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),v2.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)}),v2.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>s.isMobile()&&v2.getBool("IS_CHROME")?1:-1,t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)}),v2.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),v2.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),v2.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),v2.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);const _2="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";class S2{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=G1.DENSE;const e=q1(t),n=b2();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${A2(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class E2{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=G1.DENSE;const e=q1(t),n=b2();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${A2(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class C2{constructor(t){this.variableNames=["A"],this.outTexUsage=W1.DOWNLOAD;const e=b2();this.outputShape=t,this.userCode=`\n      ${_2}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class I2{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=W1.DOWNLOAD;const e=b2();this.outputShape=t,this.userCode=`\n      ${_2}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}class T2{constructor(t,e,n=!1){this.variableNames=["A"];const i=b2(),[r,s]=e;this.outputShape=t;let o="result";n&&(o="floor(result * 255. + 0.5)"),this.userCode=`\n      ${w2(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${s};\n        int c = imod(flatIndex, ${s});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${s}.0, ${r}.0);\n        vec4 values = ${i.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${i.output} = vec4(${o}, 0., 0., 0.);\n      }\n    `}}class M2{constructor(t,e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const i=b2(),[r,s]=e;this.outputShape=t;let o="",a="result";n&&(a="floor(result * 255. + 0.5)");for(let l=0;l<=1;l++)for(let e=0;e<=1;e++){const n=2*l+e;o+=`\n          localCoords = coords;\n          if(localCoords[2] + ${e} < ${t[2]}) {\n            localCoords[2] += ${e};\n            if(localCoords[1] + ${l} < ${t[1]}) {\n              localCoords[1] += ${l};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${s};\n              c = imod(flatIndex, ${s});\n              uv = (vec2(c, r) + halfCR) / vec2(${s}.0, ${r}.0);\n              values = ${i.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${n}] = values[0];\n              } else if(offset == 1) {\n                result[${n}] = values[1];\n              } else if(offset == 2) {\n                result[${n}] = values[2];\n              } else {\n                result[${n}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${w2(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${o}\n\n        ${i.output} = ${a};\n      }\n    `}}function k2(t,e,n,i,r,s){!function(t,e){const n=hk().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0)throw new Error(`Requested texture size [${t}x${e}] is invalid.`);if(t>n||e>n)throw new Error(`Requested texture size [${t}x${e}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(e,n);const o=function(t){return o2(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}(t),a=t.TEXTURE_2D;return K1(t,()=>t.bindTexture(a,o)),K1(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),K1(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),K1(t,()=>t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.NEAREST)),K1(t,()=>t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.NEAREST)),K1(t,()=>t.texImage2D(a,0,i,e,n,0,r,s,null)),K1(t,()=>t.bindTexture(t.TEXTURE_2D,null)),o}function R2(t){return t.internalFormatFloat}function N2(t){return t.internalFormatHalfFloat}function L2(t){return t.downloadTextureFormat}function D2(t){return t.internalFormatPackedFloat}function B2(t){return t.internalFormatPackedHalfFloat}class O2{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const e=hk().getNumber("WEBGL_VERSION");null!=t?(this.gl=t,function(t,e){U1[t]=e}(e,t)):this.gl=V1(e);let n="WEBGL_color_buffer_float";const i="EXT_color_buffer_half_float";if(1===hk().getNumber("WEBGL_VERSION")){const t="OES_texture_half_float";if(this.textureFloatExtension=Z1(this.gl,"OES_texture_float"),f2(this.gl,t))this.textureHalfFloatExtension=Z1(this.gl,t);else if(hk().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),f2(this.gl,i))this.colorBufferHalfFloatExtension=Z1(this.gl,i);else if(hk().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",f2(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!f2(this.gl,i))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(i)}this.vertexBuffer=function(t){return function(t,e){const n=o2(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return K1(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),K1(t,()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)),n}(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(t){return function(t,e){const n=o2(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return K1(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)),K1(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW)),n}(t,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(t){return o2(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=Y1(this.gl,this.textureHalfFloatExtension)}get debug(){return hk().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;K1(t,()=>t.finish()),K1(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),K1(t,()=>t.deleteFramebuffer(this.framebuffer)),K1(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),K1(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),K1(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,i){const[r,s]=Q1(e,n);return k2(t,r,s,R2(i),i.textureFormatFloat,t.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,i){const[r,s]=Q1(e,n);return k2(t,r,s,N2(i),i.textureFormatFloat,i.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,i){const[r,s]=Q1(e,n);return k2(t,r,s,L2(i),t.RGBA,t.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function(t,e,n){K1(t,()=>t.bindTexture(t.TEXTURE_2D,e)),n.data instanceof Uint8Array?K1(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data)):K1(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),K1(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,i){this.throwIfDisposed(),function(t,e,n,i,r,s){let o,a,l;K1(t,()=>t.bindTexture(t.TEXTURE_2D,e)),r instanceof Uint8Array?(o=new Uint8Array(n*i*4),a=t.UNSIGNED_BYTE,l=t.RGBA):(o=new Float32Array(n*i*4),a=t.FLOAT,l=s.internalFormatPackedFloat),o.set(r),K1(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,n,i,0,t.RGBA,a,o)),K1(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,t,e,n,i,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,i){const[r,s]=X1(e,n);return k2(t,r,s,B2(i),t.RGBA,i.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,i){const[r,s]=X1(e,n);return k2(t,r,s,D2(i),t.RGBA,t.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(r2(this.gl,this.framebuffer),this.outputTexture=null),K1(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,()=>function(t,e,n,i){const[r,s]=Q1(e,n),o=new Uint8Array(e*n*4);return K1(t,()=>t.readPixels(0,0,r,s,i.downloadTextureFormat,t.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}(this.gl,e,n,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,n,i,r,s){return function(t,e,n,i,r,s,o,a){const l=t,c=new Float32Array(function(t,e){const[n,i]=X1(t,e);return n*i*4}(s,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}(this.gl,t,0,0,0,r,s)}downloadFloat32MatrixFromBuffer(t,e){return function(t,e,n){const i=t,r=new Float32Array(n);return i.bindBuffer(i.PIXEL_PACK_BUFFER,e),i.getBufferSubData(i.PIXEL_PACK_BUFFER,0,r),i.bindBuffer(i.PIXEL_PACK_BUFFER,null),r}(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);const i=function(t,e,n,i){const r=t.createBuffer();K1(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,r));const s=16*e*n;return K1(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,s,t.STREAM_READ)),K1(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0)),K1(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),r}(this.gl,e,n);return this.unbindTextureToFrameBuffer(),i}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(hk().getBool("WEBGL_FENCE_API_ENABLED")){const i=t,r=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{const t=i.clientWaitSync(r,0,0);return t===i.ALREADY_SIGNALED||t===i.CONDITION_SATISFIED},e=r}else hk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,hk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,()=>function(t,e,n){const i=new Float32Array(e*n*4);return K1(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,i)),i}(this.gl,e,n))}createProgram(t){this.throwIfDisposed();const e=this.gl,n=function(t,e){const n=o2(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(K1(t,()=>t.shaderSource(n,e)),K1(t,()=>t.compileShader(n)),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw function(t,e){const n=t2.exec(e);if(null==n)return console.log(`Couldn't parse line number in error: ${e}`),void console.log(t);const r=+n[1],s=t.split("\n"),o=s.length.toString().length+2,a=s.map((t,e)=>i.rightPad((e+1).toString(),o)+t);let l=0;for(let i=0;i<a.length;i++)l=Math.max(a[i].length,l);const c=a.slice(0,r-1),u=a.slice(r-1,r),h=a.slice(r);console.log(c.join("\n")),console.log(e.split("\n")[0]),console.log(`%c ${i.rightPad(u[0],l)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join("\n"))}(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e,t);null==this.vertexShader&&(this.vertexShader=function(t){const e=b2();return function(t,e){const n=o2(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(K1(t,()=>t.shaderSource(n,e)),K1(t,()=>t.compileShader(n)),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(t,`${e.version}\n    precision highp float;\n    ${e.attribute} vec3 clipSpacePos;\n    ${e.attribute} vec2 uv;\n    ${e.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const r=function(t){return o2(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}(e);return K1(e,()=>e.attachShader(r,this.vertexShader)),K1(e,()=>e.attachShader(r,n)),function(t,e){if(K1(t,()=>t.linkProgram(e)),!1===t.getProgramParameter(e,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}(e,r),this.debug&&e2(e,r),this.vertexAttrsAreBound||(this.setProgram(r),this.vertexAttrsAreBound=function(t,e,n){return K1(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),n2(t,e,"clipSpacePos",n,3,20,0)&&n2(t,e,"uv",n,2,20,12)}(e,this.program,this.vertexBuffer)),r}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&K1(this.gl,()=>this.gl.deleteProgram(t))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&e2(this.gl,this.program),K1(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?function(t,e,n){return o2(t,()=>t.getUniformLocation(e,n),'uniform "'+n+'" not present in program.')}(this.gl,t,e):function(t,e,n){return t.getUniformLocation(e,n)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),K1(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),function(t,e,n,i){K1(t,()=>function(t,e,n){(function(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,i=e+t.TEXTURE0;if(i<t.TEXTURE0||i>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)})(t,n),K1(t,()=>t.activeTexture(t.TEXTURE0+n)),K1(t,()=>t.bindTexture(t.TEXTURE_2D,e))}(t,e,i)),K1(t,()=>t.uniform1i(n,i))}(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();const[i,r]=X1(e,n);this.setOutputMatrixTextureDriver(t,i,r)}setOutputMatrixWriteRegion(t,e,n,i){this.setOutputMatrixWriteRegionDriver(n,t,i,e)}setOutputPackedMatrixWriteRegion(t,e,n,i){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&e2(this.gl,this.program),s2(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;this.debug&&this.debugValidate(),K1(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),K1(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=Z1(this.gl,2===hk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===hk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2(),n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===hk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2();return void t.endQuery(e.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await i.repeatedTry(()=>this.disposed||this.isQueryAvailable(t,hk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,hk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(0===e)return null;if(2===e){const e=this.gl;return e.getQueryParameter(t,e.QUERY_RESULT)/1e6}{const e=this.getQueryTimerExtensionWebGL1();return e.getQueryObjectEXT(t,e.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const e=this.gl,n=this.getQueryTimerExtensionWebGL2(),i=e.getQueryParameter(t,e.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),i&&!this.disjoint}{const e=this.getQueryTimerExtensionWebGL1(),n=e.getQueryObjectEXT(t,e.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(e.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}(this.itemsToPoll.map(t=>t.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:t}=this.itemsToPoll[e];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||i.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),i2(this.gl,t,this.framebuffer),this.debug&&s2(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(i2(this.gl,this.outputTexture,this.framebuffer),this.debug&&s2(this.gl)):r2(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();const i=this.gl;i2(i,t,this.framebuffer),this.debug&&s2(i),this.outputTexture=t,K1(i,()=>i.viewport(0,0,e,n)),K1(i,()=>i.scissor(0,0,e,n))}setOutputMatrixWriteRegionDriver(t,e,n,i){this.throwIfDisposed(),K1(this.gl,()=>this.gl.scissor(t,e,n,i))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{getBroadcastDims:P2}=d;function F2(t,e,n){const r=[];if(t.forEach(t=>{const e=i.sizeFromShape(t.shapeInfo.logicalShape);if(t.shapeInfo.isUniform?r.push(`uniform float ${t.name}${e>1?`[${e}]`:""};`):(r.push(`uniform sampler2D ${t.name};`),r.push(`uniform int offset${t.name};`)),n.enableShapeUniforms){const{uniformShape:e}=q2(n.packedInputs,t.shapeInfo.logicalShape,t.shapeInfo.texShape);switch(e.length){case 1:r.push(`uniform int ${t.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${t.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${t.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${t.name}Shape;`)}r.push(`uniform ivec2 ${t.name}TexShape;`)}}),n.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(t=>{r.push(`uniform ${t.type} ${t.name}${t.arrayIndex?`[${t.arrayIndex}]`:""};`)});const s=r.join("\n"),o=t.map(t=>function(t,e,n=!1,r){let s="";return s+=n?z2(t,r):$2(t,r),t.shapeInfo.logicalShape.length<=e.logicalShape.length&&(s+=n?function(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",o=t.shapeInfo.logicalShape.length,a=e.logicalShape.length,l=P2(t.shapeInfo.logicalShape,e.logicalShape),c=Q2(a),u=a-o;let h;const d=["x","y","z","w","u","v"];h=0===o?"":a<2&&l.length>=1?"coords = 0;":l.map(t=>`coords.${d[t+u]} = 0;`).join("\n");let p="";p=a<2&&o>0?"coords":t.shapeInfo.logicalShape.map((t,e)=>`coords.${d[e+u]}`).join(", ");let f="return outputValue;";const m=1===i.sizeFromShape(t.shapeInfo.logicalShape),g=1===i.sizeFromShape(e.logicalShape);if(1!==o||m||g){if(m&&!g)f=1===a?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(l.length){const t=o-2,e=o-1;l.indexOf(t)>-1&&l.indexOf(e)>-1?f="return vec4(outputValue.x);":l.indexOf(t)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(e)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${c} coords = getOutputCoords();\n      ${h}\n      vec4 outputValue = get${r}(${p});\n      ${f}\n    }\n  `}(t,e):function(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",o=t.shapeInfo.logicalShape.length,a=e.logicalShape.length;if(!t.shapeInfo.isUniform&&o===a&&null==t.shapeInfo.flatOffset&&i.arraysEqual(t.shapeInfo.texShape,e.texShape))return`\n      float ${s}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const l=Q2(a),c=P2(t.shapeInfo.logicalShape,e.logicalShape),u=a-o;let h;const d=["x","y","z","w","u","v"];h=0===o?"":a<2&&c.length>=1?"coords = 0;":c.map(t=>`coords.${d[t+u]} = 0;`).join("\n");let p="";return p=a<2&&o>0?"coords":t.shapeInfo.logicalShape.map((t,e)=>`coords.${d[e+u]}`).join(", "),`\n    float ${s}() {\n      ${l} coords = getOutputCoords();\n      ${h}\n      return get${r}(${p});\n    }\n  `}(t,e)),s}(t,e,n.packedInputs,n.enableShapeUniforms)).join("\n"),a=e.texShape,l=b2(),c=function(t){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${t.texture2D}(textureSampler, uv).r;\n    }\n  `}(l);let u,h,d=function(t){return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFs} vec2 resultUV;\n    ${t.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${t.defineSpecialNaN}\n    ${t.defineSpecialInf}\n    ${t.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${U2}\n    ${H2}\n    ${V2}\n  `}(l);return e.isPacked?(u=function(t,e,n){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e,n){const i=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return 1===i[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${i[1]}.0);\n      }\n    `:1===i[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${i[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${i[0]}, ${i[1]}));\n      return 2 * (resTexRC.x * ${i[1]} + resTexRC.y);\n    }\n  `}(0,e,n);case 2:return function(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(i.arraysEqual(t,e))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(t[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(t,e,n);case 3:return function(t,e,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const i=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[2]/2),s=r*Math.ceil(t[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${i[0]}, ${i[1]}));\n      int index = resTexRC.x * ${i[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(t,e,n);default:return function(t,e,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const i=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[t.length-1]/2),s=r*Math.ceil(t[t.length-2]/2);let o=s,a="",l="b, r, c";for(let c=2;c<t.length-1;c++)o*=t[t.length-c-1],a=`\n      int b${c} = index / ${o};\n      index -= b${c} * ${o};\n    `+a,l=`b${c}, `+l;return`\n    ivec${t.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${i[0]}, ${i[1]}));\n      int index = resTexRC.x * ${i[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${t.length}(${l});\n    }\n  `}(t,e,n)}}(e.logicalShape,a,n.enableShapeUniforms),h=function(t){return`\n    void setOutput(vec4 val) {\n      ${t.output} = val;\n    }\n  `}(l)):(u=function(t,e,n){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e,n){return 1===e[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${e[1]}.0);\n      }\n    `:1===e[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${e[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      return resTexRC.x * ${e[1]} + resTexRC.y;\n    }\n  `}(0,e,n);case 2:return function(t,e,n){return i.arraysEqual(t,e)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));\n      }\n    `:1===t[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===t[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      int r = index / ${t[1]};\n      int c = index - r * ${t[1]};\n      return ivec2(r, c);\n    }\n  `}(t,e,n);case 3:return function(t,e,n){if(n)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${x2(["r","c","d"],t)}\n    return ivec3(r, c, d);\n  }\n`;const i=A2(["r","c","d"],t);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${i}\n      return ivec3(r, c, d);\n    }\n  `}(t,e,n);case 4:return function(t,e,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${x2(["r","c","d","d2"],t)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const i=A2(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${i}\n      return ivec4(r, c, d, d2);\n    }\n  `}(t,e,n);case 5:return function(t,e){const n=A2(["r","c","d","d2","d3"],t);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},\n                             ${e[1]}));\n\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(t,e);case 6:return function(t,e){const n=A2(["r","c","d","d2","d3","d4"],t);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}(e.logicalShape,a,n.enableShapeUniforms),h=function(t){return`\n    void setOutput(float val) {\n      ${t.output} = vec4(val, 0, 0, 0);\n    }\n  `}(l)),n.packedInputs&&(d+=G2),[d,c,h,s,u,o,n.userCode].join("\n")}function $2(t,e=!1){const n=t.shapeInfo.logicalShape;switch(n.length){case 0:return function(t,e){const n=t.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`float ${i}() {return ${n};}`;const[r,s]=t.shapeInfo.texShape;if(1===r&&1===s)return`\n      float ${i}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=W2(n);if(e)return`\n    float ${i}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[a,l]=t.shapeInfo.texShape;return`\n    float ${i}() {\n      vec2 uv = uvFromFlat(${a}, ${l}, ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(t,e);case 1:return function(t,e){const n=t.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`\n      float ${i}(int index) {\n        ${j2(t)}\n      }\n    `;const r=t.shapeInfo.texShape,s=r[0],o=r[1];if(1===o&&1===s)return`\n      float ${i}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const a=W2(n);return 1===o?e?`\n      float ${i}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${i}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===s?e?`\n      float ${i}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${i}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:e?`\n    float ${i}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${a});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${i}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${o}, index + ${a});\n      return sampleTexture(${n}, uv);\n    }\n  `}(t,e);case 2:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape;if(null!=o&&i.arraysEqual(n,o))return e?`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${o[1]}.0, ${o[0]}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const{newShape:a,keptDims:l}=i.squeezeShape(n);if(a.length<n.length){const n=["row","col"];return`\n      ${$2(X2(t,a),e)}\n      float ${s}(int row, int col) {\n        return ${s}(${Y2(n,l)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${j2(t)}\n      }\n    `;const c=o[0],u=o[1],h=W2(r);return 1===u?e?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===c?e?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:e?`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${h};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${h};\n    vec2 uv = uvFromFlat(${c}, ${u}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(t,e);case 3:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[1]*n[2],a=n[2],{newShape:l,keptDims:c}=i.squeezeShape(n);if(l.length<n.length){const n=["row","col","depth"];return`\n        ${$2(X2(t,l),e)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${Y2(n,c)});\n        }\n      `}if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${o}, ${a}, 1)));\n        ${j2(t)}\n      }\n    `;const u=t.shapeInfo.texShape,h=u[0],d=u[1],p=t.shapeInfo.flatOffset;if(d===o&&null==p)return e?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${a}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${h}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(d===a&&null==p)return e?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const f=W2(r);return e?`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * ${o} + col * ${a} + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${o} + col * ${a} + depth + ${f};\n        vec2 uv = uvFromFlat(${h}, ${d}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(t,e);case 4:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[3],a=n[2]*o,l=n[1]*a,{newShape:c,keptDims:u}=i.squeezeShape(n);if(c.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${$2(X2(t,c),e)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${Y2(n,u)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${l}, ${a}, ${o}, 1)));\n        ${j2(t)}\n      }\n    `;const h=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,p=d[0],f=d[1],m=`int stride2 = ${r}Shape[3];`,g=`int stride1 = ${r}Shape[2] * stride2;`,y=`int stride0 = ${r}Shape[1] * stride1;`;if(f===l&&null==h)return e?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${m}\n        ${g}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${a}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(f===o&&null==h)return e?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const v=W2(r);return e?`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${m}\n      ${g}\n      ${y}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${v});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${l} + col * ${a} +\n          depth * ${o} + depth2;\n      vec2 uv = uvFromFlat(${p}, ${f}, index + ${v});\n      return sampleTexture(${r}, uv);\n    }\n  `}(t,e);case 5:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[4],o=e[3]*s,a=e[2]*o,l=e[1]*a,{newShape:c,keptDims:u}=i.squeezeShape(e);if(c.length<e.length){const e=["row","col","depth","depth2","depth3"];return`\n      ${$2(X2(t,c))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Y2(e,u)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${l}, ${a}, ${o}, ${s})) +\n          depth3;\n        ${j2(t)}\n      }\n    `;const h=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,p=d[0],f=d[1];return f===l&&null==h?`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${a}, ${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:f===s&&null==h?`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]},\n               ${e[2]*e[3]}, ${e[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${l} + col * ${a} + depth * ${o} +\n          depth2 * ${s} + depth3 + ${W2(n)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 6:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:o}=i.squeezeShape(e);if(s.length<e.length){const e=["row","col","depth","depth2","depth3","depth4"];return`\n      ${$2(X2(t,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Y2(e,o)});\n      }\n    `}const a=e[5],l=e[4]*a,c=e[3]*l,u=e[2]*c,h=e[1]*u;if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${h}, ${u}, ${c}, ${l})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${a}, 1)));\n        ${j2(t)}\n      }\n    `;const d=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,f=p[0],m=p[1];return m===h&&null==d?`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${c}, ${l}, ${a})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${m}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:m===a&&null==d?`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]*e[4]},\n               ${e[2]*e[3]*e[4]},\n               ${e[3]*e[4]},\n               ${e[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${m}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${h} + col * ${u} + depth * ${c} +\n          depth2 * ${l} + depth3 * ${a} + depth4 + ${W2(n)};\n      vec2 uv = uvFromFlat(${f}, ${m}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function z2(t,e){switch(t.shapeInfo.logicalShape.length){case 0:return function(t){const e=t.name;return`\n    vec4 ${"get"+e.charAt(0).toUpperCase()+e.slice(1)}() {\n      return ${b2().texture2D}(${e}, halfCR);\n    }\n  `}(t);case 1:return function(t,e){const n=t.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t.shapeInfo.texShape,s=b2();if(e)return`\n    vec4 ${i}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `;const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`\n    vec4 ${i}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${o[0]}, ${o[1]}, index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(t,e);case 2:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape,a=o[0],l=o[1],c=b2();if(null!=o&&i.arraysEqual(n,o))return e?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${c.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${a}.0);\n\n        return ${c.texture2D}(${r}, uv);\n      }\n    `;if(e)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${c.texture2D}(${r}, uv);\n    }\n  `;const u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(n[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${c.texture2D}(${r}, uv);\n    }\n  `}(t,e);case 3:return function(t,e){const n=t.shapeInfo.logicalShape,i=t.name,r="get"+i.charAt(0).toUpperCase()+i.slice(1),s=t.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){const i=[1,2],s=["b","row","col"];return`\n        ${z2(X2(t,n.slice(1)),e)}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${Y2(s,i)});\n        }\n      `}const a=b2();if(e)return`\n    vec4 ${r}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${i}TexShape[0]) / 2.0), ceil(float(${i}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${i}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${i}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${a.texture2D}(${i}, uv);\n    }\n  `;const l=o[0],c=o[1],u=Math.ceil(n[2]/2);return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${c}, ${u*Math.ceil(n[1]/2)}, ${u}, b, row, col);\n      return ${a.texture2D}(${i}, uv);\n    }\n  `}(t,e);default:return function(t,e){const n=t.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1),r=b2();if(e)return`\n    vec4 ${i}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${n}, uv);\n    }\n  `;const s=t.shapeInfo.logicalShape,o=s.length,a=t.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],u=l[1],h=Math.ceil(s[o-1]/2);let d=h*Math.ceil(s[o-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let m=2;m<o-1;m++)p=`int b${m}, `+p,d*=s[o-m-1],f=`b${m} * ${d} + `+f;return`\n    vec4 ${i}(${p}) {\n      int index = ${f};\n      int texR = index / ${u};\n      int texC = index - texR * ${u};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});\n      return ${r.texture2D}(${n}, uv);\n    }\n  `}(t,e)}}const U2="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",H2="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",V2="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",G2="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function W2(t){return`offset${t}`}function j2(t){const e=t.name,n=i.sizeFromShape(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${e}[i];\n      }\n    }\n  `}function Q2(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function q2(t,e,n){const{newShape:r}=i.squeezeShape(e),s=e.length,o=t&&3===s&&1===e[0],a=o?e.slice(1):r,l=!t&&s>1&&!i.arraysEqual(e,n)&&r.length<s||o;return{useSqueezeShape:l,uniformShape:l?a:e}}function X2(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function Y2(t,e){return e.map(e=>t[e]).join(", ")}function K2(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((t,n)=>{const r=t.logicalShape,s=e[n],o=s.shape;if(!i.arraysEqual(r,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${o} must match`);if(t.isUniform&&s.isUniform)return;const a=t.texShape,l=s.isUniform?null:s.texData.texShape;if(!i.arraysEqual(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function J2(t){return hk().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}const{addImpl:Z2,bincountImpl:t3,bincountReduceImpl:e3,ceilImpl:n3,concatImpl:i3,equalImpl:r3,expImpl:s3,expm1Impl:o3,floorImpl:a3,gatherNdImpl:l3,gatherV2Impl:c3,greaterImpl:u3,greaterEqualImpl:h3,lessImpl:d3,lessEqualImpl:p3,linSpaceImpl:f3,logImpl:m3,maxImpl:g3,maximumImpl:y3,minimumImpl:v3,multiplyImpl:b3,negImpl:A3,notEqualImpl:x3,prodImpl:w3,rangeImpl:_3,rsqrtImpl:S3,simpleAbsImpl:E3,sliceImpl:C3,sparseFillEmptyRowsImpl:I3,sparseReshapeImpl:T3,sparseSegmentReductionImpl:M3,stridedSliceImpl:k3,stringNGramsImpl:R3,stringSplitImpl:N3,stringToHashBucketFastImpl:L3,subImpl:D3,tileImpl:B3,topKImpl:O3,transposeImpl:P3,uniqueImpl:F3}=L;function $3(t,e){return["x","y","z","w","u","v"].slice(0,e).map(e=>`${t}.${e}`)}function z3(t,e){return 1===e?[t]:$3(t,e)}class U3{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t;const e=t.length;if(0===e)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=z3("rc",e),i=Q2(e),r=function(t,e,n){if(1===t)return`rc > ${e[0]}`;let i="";for(let r=t-2;r<t;r++)i+=`${n[r]} >= ${e[r]}`,r<t-1&&(i+="||");return i}(e,t,n),s=function(t,e,n,i){if(1===t)return"";const r=i.slice(-2);return`\n    int r = ${r[0]};\n    int c = ${r[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${e};\n    bool rEdge = rp1 >= ${n};\n  `}(e,t[t.length-1],t[t.length-2],n),o=function(t,e){const n=t.length,i=function(t,e){const n=[];for(let i=0;i<=1;i++)for(let r=0;r<=1;r++){let s=`${0===i?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let n=2;n<t;n++)s=`${e[e.length-1-n]},`+s;n.push(s)}return n}(n,e);return 1===n?`getA(rc),\n            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),\n            0, 0`:`getA(${i[0]}),\n          cEdge ? 0. : getA(${i[1]}),\n          rEdge ? 0. : getA(${i[2]}),\n          rEdge || cEdge ? 0. : getA(${i[3]})`}(t,n);this.userCode=`\n        void main() {\n          ${i} rc = getOutputCoords();\n\n          if(${r}) {\n            setOutput(vec4(0));\n          } else {\n            ${s}\n\n            setOutput(vec4(${o}));\n          }\n        }\n      `}}}class H3{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;let n="";for(let r=0;r<4;r++){let t="thisRC = rc;";r%2==1&&(t+="thisRC.z += 1;"),r>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${r}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${r>0?"}":""}\n      `}var i;this.userCode=`\n      ${i=e,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${A2(["r","c","d"],i)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${w2(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${t[1]};\n        int cols = ${t[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class V3{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,n){const i=W3(e,n),r=j3(t,i,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const s=G3(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();const t=this.freeTextures[r].shift();return this.usedTextures[r].push(t),t}let o;return i===j1.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):i===j1.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):i===j1.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):i===j1.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):i===j1.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[r].push(o),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),o}releaseTexture(t,e,n,i){if(null==this.freeTextures)return;const r=W3(n,i),s=j3(e,r,i);s in this.freeTextures||(this.freeTextures[s]=[]);const o=G3(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,i),a=hk().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==a&&this._numBytesAllocated>a?(this.gpgpu.deleteMatrixTexture(t),this._numBytesAllocated-=o):(this.freeTextures[s].push(t),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const l=this.usedTextures[s],c=l.indexOf(t);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(c,1),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});for(const t in this.usedTextures)this.usedTextures[t].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function G3(t,e,n,i,r){const s=function(t,e){switch(t){case j1.PACKED_2X2_FLOAT32:return D2(e);case j1.PACKED_2X2_FLOAT16:return B2(e);case j1.UNPACKED_FLOAT32:return R2(e);case j1.UNPACKED_FLOAT16:return N2(e);case j1.PACKED_4X1_UNSIGNED_BYTE:return L2(e);default:throw new Error(`Unknown physical texture type ${t}`)}}(e,i);let o;if(r){const[e,n]=X1(t[0],t[1]);o=e*n}else{const[e,n]=Q1(t[0],t[1]);o=e*n}return o*function(t,e){if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===t.RGBA16F)return 8;throw new Error(`Unknown internal format ${e}`)}(n,s)}function W3(t,e){if(t===W1.UPLOAD)return j1.PACKED_2X2_FLOAT32;if(t===W1.RENDER||null==t)return function(t){return hk().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?j1.PACKED_2X2_FLOAT32:j1.UNPACKED_FLOAT32:t?j1.PACKED_2X2_FLOAT16:j1.UNPACKED_FLOAT16}(e);if(t===W1.DOWNLOAD||t===W1.PIXELS)return j1.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function j3(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}class Q3{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=J2(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const q3="return abs(x);",X3="return x;";class Y3{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=J2(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class K3{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t;const e=t.length,n=z3("rc",e),i=Q2(e),r=function(t,e){if(1===t)return"rc";let n="";for(let i=0;i<t;i++)n+=e[i],i<t-1&&(n+=",");return n}(e,n),s=n.slice(-2),o=e<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${i} rc = getOutputCoords();\n        vec4 packedInput = getA(${r});\n\n        setOutput(getChannel(packedInput, ${o}));\n      }\n    `}}const J3=p.whereImpl,Z3={},t4=hk().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class e4 extends pM{constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!hk().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==t){const t=V1(hk().getNumber("WEBGL_VERSION"));this.binaryCache=((e=hk().getNumber("WEBGL_VERSION"))in Z3||(Z3[e]={}),Z3[e]),this.gpgpu=new O2(t),this.canvas=t.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=t,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=t.gl.canvas;var e;this.textureManager=new V3(this.gpgpu),this.numMBBeforeWarning=null==hk().global.screen?1024:hk().global.screen.height*hk().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new dM(this,xO())}nextDataId(){return e4.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(t,e,n){if((hk().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||hk().getBool("DEBUG"))&&this.checkNumericalProblems(t),"complex64"===n&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.texData.set(i,{shape:e,dtype:n,values:t,usage:W1.UPLOAD,refCount:1}),i}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){this.texData.get(t).refCount++}decRef(t){this.texData.has(t)&&this.texData.get(t).refCount--}move(t,e,n,i,r){if(hk().getBool("DEBUG")&&this.checkNumericalProblems(e),"complex64"===i)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:i,values:e,usage:W1.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const e=this.texData.get(t),{values:n,dtype:r,complexTensorInfos:s,slice:o,shape:a,isPacked:l}=e;if(null!=o){let e;e=l?new Y3(a,X3):new Q3(a,X3);const n=this.runWebGLProgram(e,[{dataId:t,shape:a,dtype:r}],r),i=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),i}if(null!=n)return this.convertAndCacheOnCPU(t);if("string"===r)return n;const c=null!=this.activeTimers;let u,h;if(c&&(u=i.now()),"complex64"===r){const t=this.readSync(s.real.dataId),e=this.readSync(s.imag.dataId);h=d.mergeRealAndImagArrays(t,e)}else h=this.getValuesFromTexture(t);return c&&(this.downloadWaitMs+=i.now()-u),this.convertAndCacheOnCPU(t,h)}async read(t){if(this.pendingRead.has(t)){const e=this.pendingRead.get(t);return new Promise(t=>e.push(t))}const e=this.texData.get(t),{values:n,shape:r,slice:s,dtype:o,complexTensorInfos:a,isPacked:l}=e;if(null!=s){let e;e=l?new Y3(r,X3):new Q3(r,X3);const n=this.runWebGLProgram(e,[{dataId:t,shape:r,dtype:o}],o),i=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),i}if(null!=n)return this.convertAndCacheOnCPU(t);if(!hk().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===hk().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c,u,h=null;if("complex64"!==o&&hk().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(t);const e=this.texData.get(c.dataId);h=this.gpgpu.createBufferFromTexture(e.texture,...q1(r))}if(this.pendingRead.set(t,[]),"complex64"!==o&&await this.gpgpu.createAndWaitForFence(),"complex64"===o){const t=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]);u=d.mergeRealAndImagArrays(t[0],t[1])}else if(null==h)u=this.getValuesFromTexture(t);else{const t=i.sizeFromShape(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(h,t)}if(null!=c&&this.disposeIntermediateTensorInfo(c),null!=h){const t=this.gpgpu.gl;K1(t,()=>t.deleteBuffer(h))}const p=this.convertAndCacheOnCPU(t,u),f=this.pendingRead.get(t);return this.pendingRead.delete(t),f.forEach(t=>t(p)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&xO().removeDataId(t,this),this.pendingDeletes--),p}bufferSync(t){const e=this.readSync(t.dataId);let n=e;if("string"===t.dtype)try{n=e.map(t=>i.decodeString(t))}catch(GTt){throw new Error("Failed to decode encoded string bytes into utf-8")}return RB(t.shape,t.dtype,n)}checkNumericalProblems(t){if(null!=t)for(let e=0;e<t.length;e++){const n=t[e];if(!J1(n)){if(hk().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(t){const{shape:e,dtype:n,isPacked:r}=this.texData.get(t),s=i.sizeFromShape(e);if(hk().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(t),i=this.texData.get(n.dataId),r=this.gpgpu.downloadMatrixFromPackedTexture(i.texture,...q1(e)).subarray(0,s);return this.disposeIntermediateTensorInfo(n),r}const o=hk().getBool("WEBGL_PACK")&&!0===r,a=o?c2(e):e,l=o?new I2(a):new C2(a),c=this.runWebGLProgram(l,[{shape:a,dtype:n,dataId:t}],"float32"),u=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture,u.texShape[0],u.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return hk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}async time(t){const e=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,t();const s=i.flatten(this.activeTimers.map(t=>t.query)).filter(t=>null!=t),o=i.flatten(this.activeTimers.map(t=>t.name)).filter(t=>null!=t);this.activeTimers=e,r&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(hk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const t=await Promise.all(s);a.kernelMs=i.sum(t),a.getExtraProfileInfo=()=>t.map((t,e)=>({name:o[e],ms:t})).map(t=>`${t.name}: ${t.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return hk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:i.now(),endMs:null}}endTimer(t){return hk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=i.now(),t)}async getQueryTime(t){return hk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.waitForQueryAndGetTime(t):t.endMs-t.startMs}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:n}=this.texData.get(t);return null!=n&&(this.disposeData(n.real.dataId,e),this.disposeData(n.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:e,dtype:n,texShape:i,usage:r,isPacked:s,slice:o}=this.texData.get(t),a=o&&o.origDataId||t,l=this.dataRefCount.get(a);l>1?this.dataRefCount.set(a,l-1):(this.dataRefCount.delete(a),null!=e&&(this.numBytesInGPU-=this.computeBytes(i,n),this.textureManager.releaseTexture(e,i,r,s)));const c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,e=t4){return hk().getBool("WEBGL_CPU_FORWARD")&&t.every(t=>null==this.texData.get(t.dataId).texture&&i.sizeFromShape(t.shape)<e)}getGPGPUContext(){return this.gpgpu}where(t){d.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return J3(t.shape,e)}packedUnaryOp(t,e,n){const i=new Y3(t.shape,e),r=this.compileAndRun(i,[t],n);return xO().makeTensorFromDataId(r.dataId,r.shape,r.dtype)}abs(t){if(this.shouldExecuteOnCPU([t])&&"complex64"!==t.dtype){const e=E3(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,e)}if(hk().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,q3,t.dtype);const e=new Q3(t.shape,q3),n=this.compileAndRun(e,[t]);return xO().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(t,e,n){let r;if("string"===e&&null!=n&&n.length>0&&i.isString(n[0])){const s=n.map(t=>i.encodeString(t));r=this.write(s,t,e)}else r=this.write(n,t,e);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:e}}makeOutput(t,e,n){const{dataId:i}=this.makeTensorInfo(t,e,n);return xO().makeTensorFromDataId(i,t,e,this)}unpackTensor(t){const e=new K3(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new U3(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const n=[a2(t.shape),...l2(t.shape)],i={dtype:t.dtype,shape:n,dataId:t.dataId},r=[a2(e),...l2(e)],s=new H3(r,n),o=this.runWebGLProgram(s,[i],t.dtype,null,!0);return{dataId:o.dataId,shape:e,dtype:o.dtype}}decode(t){const e=this.texData.get(t),{isPacked:n,shape:i,dtype:r}=e,s=c2(i);let o;return o=n?new E2(s):new S2(s),{dtype:r,shape:i,dataId:this.runWebGLProgram(o,[{shape:s,dtype:r,dataId:t}],r,null,!0).dataId}}runWebGLProgram(t,e,n,r,s=!1){const o=this.makeTensorInfo(t.outputShape,n),a=this.texData.get(o.dataId);if(t.packedOutput&&(a.isPacked=!0),t.outPackingScheme===G1.DENSE){const e=q1(t.outputShape);a.texShape=e.map(t=>2*t)}if(null!=t.outTexUsage&&(a.usage=t.outTexUsage),0===i.sizeFromShape(o.shape))return a.values=i.getTypedArrayFromDType(o.dtype,0),o;const l=[],c=e.map(e=>{if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(e.dataId);if(null==n.texture){if(!t.packedInputs&&i.sizeFromShape(e.shape)<=hk().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:n.values};t.packedInputs&&(n.isPacked=!0,n.shape=e.shape)}else if(!!n.isPacked!=!!t.packedInputs)e=n.isPacked?this.unpackTensor(e):this.packTensor(e),l.push(e),n=this.texData.get(e.dataId);else if(n.isPacked&&!h2(n.shape,e.shape)){const t=e,i=e.shape;e.shape=n.shape,e=this.packedReshape(e,i),l.push(e),n=this.texData.get(e.dataId),t.shape=i}return this.uploadToGPU(e.dataId),{shape:e.shape,texData:n,isUniform:!1}});this.uploadToGPU(o.dataId);const u={shape:o.shape,texData:a,isUniform:!1},h=function(t,e,n){let r="";e.concat(n).forEach(e=>{const s=null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!e.isUniform){const o=e.texData.texShape,{useSqueezeShape:a,uniformShape:l}=q2(t.packedInputs,e.shape,o);let c="",u="",h="";if(1===l.length&&t.packedInputs){const t=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];c=`${t[0]>1}_${t[1]>1}`}else if(2!==l.length||t.packedInputs){if(l.length>2&&!t.packedInputs){const t=i.computeStrides(l);h=`${t[0]===o[1]}_${t[t.length-1]===o[1]}`}}else u=`${l[0]>1}_${l[1]>1}`;const p=e.shape.length,f=2===p&&i.arraysEqual(e.shape,o),m=1===i.sizeFromShape(e.shape),g=d.getBroadcastDims(e.shape,n.shape),y=!t.packedInputs&&p===n.shape.length&&i.arraysEqual(o,n.texData.texShape);r+=`${p}_${y}_${a}_${l.length}_${m}_${g}_${f}_${c}_${u}_${h}_${t.packedInputs||p>2?"":`${o[0]>1}_${o[1]>1}`}_${s}`}else r+=`${e.shape}_${e.isUniform?"uniform":e.texData.texShape}_${s}`});let s=t.constructor.name;return s+="_"+r+"_"+t.userCode+`${hk().getNumber("WEBGL_VERSION")}`,s}(t,c,u),p=this.getAndSaveBinary(h,()=>function(t,e,n,i){const r=n.map((t,n)=>{const i={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(i.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[n],shapeInfo:i}}),s=r.map(t=>t.shapeInfo),o={logicalShape:i.shape,texShape:i.texData.texShape,isUniform:!1,isPacked:i.texData.isPacked,flatOffset:null},a=F2(r,o,e),l=t.createProgram(a);let c=null;const u=t.getUniformLocation(l,"NAN",!1);1===hk().getNumber("WEBGL_VERSION")&&(c=t.getUniformLocation(l,"INFINITY",!1));const h=!1,d={},p={},f={};for(let b=0;b<e.variableNames.length;b++){const n=e.variableNames[b];d[n]=t.getUniformLocation(l,n,h),d[`offset${n}`]=t.getUniformLocation(l,`offset${n}`,h),e.enableShapeUniforms&&(p[`${n}Shape`]=t.getUniformLocation(l,`${n}Shape`,h),f[`${n}TexShape`]=t.getUniformLocation(l,`${n}TexShape`,h))}let m,g,y;e.enableShapeUniforms&&(m=t.getUniformLocation(l,"outShape",h),y=t.getUniformLocation(l,"outShapeStrides",h),g=t.getUniformLocation(l,"outTexShape",h));const v=[];return e.customUniforms&&e.customUniforms.forEach((e,n)=>{v[n]=t.getUniformLocation(l,e.name,h)}),{program:e,source:a,webGLProgram:l,uniformLocations:d,customUniformLocations:v,inShapeInfos:s,outShapeInfo:o,infLoc:c,nanLoc:u,inShapesLocations:p,inTexShapesLocations:f,outShapeLocation:m,outShapeStridesLocation:y,outTexShapeLocation:g}}(this.gpgpu,t,c,u)),f=null!=this.activeTimers;let m;f&&(m=this.startTimer()),function(t,e,n,r,s){e.program.enableShapeUniforms||(K2(e.inShapeInfos,n),K2([e.outShapeInfo],[r]));const o=r.texData.texture,a=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(o,a[0],a[1]):t.setOutputMatrixTexture(o,a[0],a[1]),t.setProgram(e.webGLProgram),1===hk().getNumber("WEBGL_VERSION")&&null!==e.infLoc&&t.gl.uniform1f(e.infLoc,1/0),null!==e.nanLoc&&t.gl.uniform1f(e.nanLoc,NaN),n.forEach((n,r)=>{const s=e.program.variableNames[r],o=e.uniformLocations[s],a=e.uniformLocations[`offset${s}`],l=e.inShapesLocations[`${s}Shape`],c=e.inTexShapesLocations[`${s}TexShape`];if(l){const{uniformShape:i}=q2(e.program.packedInputs,n.shape,n.texData.texShape);switch(i.length){case 1:t.gl.uniform1iv(l,new Int32Array(i));break;case 2:t.gl.uniform2iv(l,new Int32Array(i));break;case 3:t.gl.uniform3iv(l,new Int32Array(i));break;case 4:t.gl.uniform4iv(l,new Int32Array(i))}}if(c&&t.gl.uniform2i(c,n.texData.texShape[0],n.texData.texShape[1]),null!=o)if(n.isUniform)if(i.sizeFromShape(n.shape)<2)t.gl.uniform1f(o,n.uniformValues[0]);else{let e=n.uniformValues;e instanceof Float32Array||(e=new Float32Array(e)),t.gl.uniform1fv(o,e)}else null!=n.texData.slice&&null!=a&&t.gl.uniform1i(a,n.texData.slice.flatOffset),t.setInputMatrixTexture(n.texData.texture,o,r)});const l=e.outShapeLocation;if(l)switch(r.shape.length){case 1:t.gl.uniform1iv(l,new Int32Array(r.shape));break;case 2:t.gl.uniform2iv(l,new Int32Array(r.shape));break;case 3:t.gl.uniform3iv(l,new Int32Array(r.shape));break;case 4:t.gl.uniform4iv(l,new Int32Array(r.shape))}if(e.outShapeStridesLocation){const n=i.computeStrides(r.shape);switch(r.shape.length){case 2:t.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(n));break;case 3:t.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(n));break;case 4:t.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(n))}}e.outTexShapeLocation&&t.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&s&&e.program.customUniforms.forEach((n,i)=>{const r=e.customUniformLocations[i],o=s[i];if("float"===n.type)t.gl.uniform1fv(r,o);else if("vec2"===n.type)t.gl.uniform2fv(r,o);else if("vec3"===n.type)t.gl.uniform3fv(r,o);else if("vec4"===n.type)t.gl.uniform4fv(r,o);else if("int"===n.type)t.gl.uniform1iv(r,o);else if("ivec2"===n.type)t.gl.uniform2iv(r,o);else if("ivec3"===n.type)t.gl.uniform3iv(r,o);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);t.gl.uniform4iv(r,o)}}),t.executeProgram()}(this.gpgpu,p,c,u,r),l.forEach(t=>this.disposeIntermediateTensorInfo(t)),f&&(m=this.endTimer(m),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(m)}));const g=hk().get("WEBGL_FLUSH_THRESHOLD");if(g>0){const t=i.now();t-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=t)}if(!hk().getBool("WEBGL_LAZILY_UNPACK")&&a.isPacked&&!1===s){const t=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),t}return o}compileAndRun(t,e,n,i,r=!1){return this.runWebGLProgram(t,e,n=n||e[0].dtype,i,r)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(hk().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=_O(()=>{if(!hk().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=hk().getBool("DEBUG");hk().set("DEBUG",!1);const e=this.abs(TO(1e-8)).dataSync()[0];if(hk().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(t){const e=this.texData.get(t),{shape:n,dtype:r,values:s,texture:o,usage:a,isPacked:l}=e;if(null!=o)return;const c=null!=this.activeTimers;let u;c&&(u=i.now());let h=e.texShape;if(null==h&&(h=function(t,e=!1){let n=hk().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e&&(n*=2,1===(t=t.map((e,n)=>n>=t.length-2?i.nearestLargerEven(t[n]):t[n])).length&&(t=[2,t[0]])),2!==t.length){const e=i.squeezeShape(t);t=e.newShape}let r=i.sizeFromShape(t);if(t.length<=1&&r<=n)return[1,r];if(2===t.length&&t[0]<=n&&t[1]<=n)return t;if(3===t.length&&t[0]*t[1]<=n&&t[2]<=n)return[t[0]*t[1],t[2]];if(3===t.length&&t[0]<=n&&t[1]*t[2]<=n)return[t[0],t[1]*t[2]];if(4===t.length&&t[0]*t[1]*t[2]<=n&&t[3]<=n)return[t[0]*t[1]*t[2],t[3]];if(4===t.length&&t[0]<=n&&t[1]*t[2]*t[3]<=n)return[t[0],t[1]*t[2]*t[3]];if(e){const e=a2(t);let n=2,s=2;return t.length&&([n,s]=l2(t)),r=e*(n/2)*(s/2),i.sizeToSquarishShape(r).map(t=>2*t)}return i.sizeToSquarishShape(r)}(n,l),e.texShape=h),null!=s){const t=c2(n);let o,a=h[1],d=h[0];const p=s instanceof Uint8Array;l?([a,d]=X1(h[0],h[1]),o=new M2(t,[d,a],p)):o=new T2(t,[d,a],p);const f=this.makeTensorInfo([d,a],r);this.texData.get(f.dataId).usage=p?W1.PIXELS:W1.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),a,d,s);const m=this.runWebGLProgram(o,[f],r,null,!0),g=this.texData.get(m.dataId);e.texture=g.texture,e.texShape=g.texShape,e.isPacked=g.isPacked,e.usage=g.usage,this.disposeIntermediateTensorInfo(f),this.texData.delete(m.dataId),e.values=null,c&&(this.uploadWaitMs+=i.now()-u)}else{const t=this.acquireTexture(h,a,r,l);e.texture=t}}convertAndCacheOnCPU(t,e){const n=this.texData.get(t),{dtype:i}=n;return this.releaseGPUData(t),null!=e&&(n.values=function(t,e){if("float32"===e||"complex64"===e)return t;if("int32"===e||"bool"===e){const n="int32"===e?new Int32Array(t.length):new Uint8Array(t.length);for(let e=0;e<n.length;++e)n[e]=Math.round(t[e]);return n}throw new Error(`Unknown dtype ${e}`)}(e,i)),n.values}acquireTexture(t,e,n,i){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const t=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${t} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,i)}computeBytes(t,e){return t[0]*t[1]*i.bytesPerElement(e)}}e4.nextDataId=0,s.isBrowser()&&CO("webgl",()=>new e4,2);class n4{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=d.assertAndGetBroadcastShape(e,n),this.enableShapeUniforms=J2(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class i4{constructor(t,e,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=d.assertAndGetBroadcastShape(e,n);const s=this.outputShape.length;this.enableShapeUniforms=J2(s);let o="";if(r)if(0===s||1===i.sizeFromShape(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(o=`\n          ${Q2(s)} coords = getOutputCoords();\n        `,1===s)o+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const t=z3("coords",s);o+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${t[s-2]} + 1) >= outShape[${s} - 2];\n            bool nextColOutOfBounds =\n              (${t[s-1]} + 1) >= outShape[${s} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${t[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${t[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${o}\n\n        setOutput(result);\n      }\n    `}}function r4(t){const{inputs:e,backend:n}=t,{x:i}=e;return n.incRef(i.dataId),{dataId:i.dataId,shape:i.shape,dtype:i.dtype}}const s4={kernelName:IR,backendName:"webgl",kernelFunc:r4};function o4(t){const{inputs:e,backend:n}=t,{real:i,imag:r}=e,s=n.makeTensorInfo(i.shape,"complex64"),o=n.texData.get(s.dataId),a=r4({inputs:{x:i},backend:n}),l=r4({inputs:{x:r},backend:n});return o.complexTensorInfos={real:a,imag:l},s}const a4={kernelName:zk,backendName:"webgl",kernelFunc:o4},l4="return (a < 0.) ? b * a : a;",c4="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",u4={kernelName:LR,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{alpha:o}=r,a=n.makeTensorInfo([],"float32",i.createScalarValue(o,"float32")),l=hk().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new i4(c4,s.shape,a.shape):new n4(l4,s.shape,a.shape),c=n.runWebGLProgram(l,[s,a],s.dtype);return n.disposeIntermediateTensorInfo(a),c}},h4="return (a < 0.) ? b * a : a;",d4="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",p4={kernelName:fN,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:i,alpha:r}=e,s=hk().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new i4(d4,i.shape,r.shape):new n4(h4,i.shape,r.shape);return n.runWebGLProgram(s,[i,r],i.dtype)}};function f4({opSnippet:t,packedOpSnippet:e,cpuKernelImpl:n,dtype:i}){return({inputs:r,backend:s})=>{const{x:o}=r,a=s,l=i||o.dtype;if(a.shouldExecuteOnCPU([o])&&null!=n){const t=a.texData.get(o.dataId),e=n(t.values,l);return a.makeTensorInfo(o.shape,l,e)}let c;return c=hk().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=e?new Y3(o.shape,e):new Q3(o.shape,t),a.runWebGLProgram(c,[o],l)}}function m4({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:i=!1,cpuKernelImpl:r,dtype:s}){return({inputs:o,backend:a})=>{const{a:l,b:c}=o,u=a;if(i&&"complex64"===l.dtype){const e=u.texData.get(l.dataId),n=u.texData.get(c.dataId),[i,r]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map(e=>{const[n,i]=e,r={dataId:n.dataId,dtype:n.dtype,shape:l.shape},s={dataId:i.dataId,dtype:i.dtype,shape:c.shape},o=new n4(t,l.shape,c.shape);return u.runWebGLProgram(o,[r,s],dD(n.dtype,i.dtype))}),s=o4({inputs:{real:i,imag:r},backend:u});return u.disposeIntermediateTensorInfo(i),u.disposeIntermediateTensorInfo(r),s}const h=s||dD(l.dtype,c.dtype);if(("string"===l.dtype||"string"===c.dtype||u.shouldExecuteOnCPU([l,c]))&&null!=r){const t=u.texData.get(l.dataId).values,e=u.texData.get(c.dataId).values,n="string"===l.dtype?d.fromUint8ToStringArray(t):t,i="string"===l.dtype?d.fromUint8ToStringArray(e):e,[s,o]=r(l.shape,c.shape,n,i,h),a=u.makeTensorInfo(o,h);return u.texData.get(a.dataId).values=s,a}let p;return p=hk().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=e?new i4(e,l.shape,c.shape,n):new n4(t,l.shape,c.shape),u.runWebGLProgram(p,[l,c],h)}}function g4(t,e=!1){if("linear"===t)return"return x;";if("relu"===t)return e?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===t)return e?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===t)return e?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===t)return e?d4:h4;if("leakyrelu"===t)return e?c4:l4;if("sigmoid"===t)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}class y4{constructor(t,e,n,i=!1,r=!1,s=!1,o=null,a=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;const c=Math.ceil((i?t[1]:t[2])/2),u=i?"i * 2, rc.y":"rc.y, i * 2",h=r?"rc.z, i * 2":"i * 2, rc.z",d=i?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],p=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let f="",m="";o&&(f=a?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${o}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${o}\n        }`:`vec4 activation(vec4 x) {\n          ${o}\n        }`,m="result = activation(result);");const g=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let y="rc.x",v="rc.x";t[0]<e[0]?y=`int(min(float(rc.x), ${t[0]-1}.))`:e[0]<t[0]&&(v=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`\n      ${f}\n\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${c}; i++) {\n          int batchA = ${y};\n          int batchB = ${v};\n          vec4 a = getMatrixA(batchA, ${u});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${d[0]} * ${p[0]});\n          result += (${d[1]} * ${p[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${g}\n\n        ${m}\n\n        setOutput(result);\n      }\n    `}}class v4{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=d.assertAndGetBroadcastShape(e,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const b4="return a * b;";function A4(t){const{inputs:e,backend:n}=t,{a:i,b:r}=e,s=d.upcastType(i.dtype,r.dtype);if("complex64"===i.dtype){const t=n.texData.get(i.dataId),e=n.texData.get(r.dataId),s=new v4("return areal * breal - aimag * bimag;",i.shape,r.shape),o=new v4("return areal * bimag + aimag * breal;",i.shape,r.shape),a=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:i.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:i.shape},{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape}],l=n.runWebGLProgram(s,a,"float32"),c=n.runWebGLProgram(o,a,"float32"),u=o4({inputs:{real:l,imag:c},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),u}if(n.shouldExecuteOnCPU([i,r])){const t=n.texData.get(i.dataId),e=n.texData.get(r.dataId),[o,a]=b3(i.shape,r.shape,t.values,e.values,s),l=n.makeTensorInfo(a,s);return n.texData.get(l.dataId).values=o,l}let o;return o=hk().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new i4(b4,i.shape,r.shape):new n4(b4,i.shape,r.shape),n.runWebGLProgram(o,[i,r],s)}const x4={kernelName:iN,backendName:"webgl",kernelFunc:A4};function w4(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{shape:o}=r,a=n,l=i.sizeFromShape(s.shape),c=i.inferFromImplicitShape(o,l),u=i.sizeFromShape(c);i.assert(l===u,()=>`The new shape (${c}) has ${u} elements and the old shape (${s.shape}) has ${l} elements. The new shape and old shape must have the same number of elements.`);const h=a.texData.get(s.dataId);return!h.isPacked||h2(s.shape,c)||null!==h.texture&&h2(h.shape,c)?(a.incRef(s.dataId),{dataId:s.dataId,shape:c,dtype:s.dtype}):function(t,e,n){const i=[a2(t.shape),...l2(t.shape)],r={dtype:t.dtype,shape:i,dataId:t.dataId},s=[a2(e),...l2(e)],o=new H3(s,i),a=n.runWebGLProgram(o,[r],t.dtype,null,!0);return{dataId:a.dataId,shape:e,dtype:a.dtype}}(s,c,a)}const _4={kernelName:AN,backendName:"webgl",kernelFunc:w4};class S4{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:o}=t;this.outputShape=[r,o];const a=4*Math.floor(n/4),l=n%4;let c="sumValue += dot(values, ones);";if(null!=e){const t=1/e;c=`sumValue += dot(values * ${i.isInt(t)?t.toPrecision(2):t}, ones);`}let u="";s%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===l}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${c}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${c}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `}}class E4{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:i,inSize:r,outSize:s}=t;this.outputShape=[i,s];let o="0.0",a="";"prod"===e?o="1.0":"min"===e?(o="1.0 / 1e-20",a="min"):"max"===e&&(o="-1.0 / 1e-20",a="max");let l=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?l="sumValue":"prod"===e?l="prodValue":"all"===e?l="allValue":"any"===e&&(l="anyValue");const c=4*Math.floor(n/4),u=n%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${a}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${a}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,d="vec4";"all"===e?(o="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===e&&(o="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";r%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${o};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${o});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===u}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===u}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===u}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${l});\n      }\n    `}}function C4(t,e,n,i){const r=function(t){const e=[];for(;0===e.length||1!==e[e.length-1].outSize;){const n=e.length?e[e.length-1].outSize:t[1],i=d.computeOptimalWindowSize(n);e.push({inSize:n,windowSize:i,outSize:Math.ceil(n/i)})}return e}(t.shape);let s=t;for(let o=0;o<r.length;o++){const{inSize:a,windowSize:l,outSize:c}=r[o];let u,h;u="mean"===n?0===o?new S4({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:c},a):new S4({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:c}):new E4({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:c},n),h=s,s=i.runWebGLProgram(u,[s],e),h.dataId!==t.dataId&&i.disposeIntermediateTensorInfo(h)}return s}class I4{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let s=0;s<n.length;s++)n[s]=t[e[s]];this.outputShape=n,this.rank=n.length;const i=Q2(this.rank),r=function(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],i=new Array(e);for(let r=0;r<t.length;r++)i[t[r]]=n[r];return i.join()}(e);this.userCode=`\n    void main() {\n      ${i} resRC = getOutputCoords();\n      setOutput(getA(${r}));\n    }\n    `}}class T4{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(t.length);for(let c=0;c<n.length;c++)n[c]=t[e[c]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const i=Q2(this.rank),r=$3("rc",this.rank),s=new Array(this.rank);for(let c=0;c<e.length;c++)s[e[c]]=r[c];const o=`vec2(${s.slice(-2).join()})`,a=`++${r[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${o})`;this.userCode=`\n    void main() {\n      ${i} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${a}) {\n        result[1] = ${l};\n      }\n      --${r[this.rank-1]};\n      if(++${r[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${a}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function M4(t,e,n){const i=hk().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new T4(t.shape,e):new I4(t.shape,e);return n.runWebGLProgram(i,[t],t.dtype)}function k4(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:a}=r;return function(t,e,n,r){const s=t.shape.length,o=i.parseAxisParam(e,t.shape);let a=o;const l=d.getAxesPermutation(a,s),c=null!=l;let u=t;c&&(u=M4(t,l,r),a=d.getInnerMostAxes(a.length,s)),d.assertAxesAreInnerMostDims("sum",a,s);const[h,p]=d.computeOutAndReduceShapes(u.shape,a);let f=h;n&&(f=d.expandShapeToKeepDim(h,o));const m=i.sizeFromShape(p),g=w4({inputs:{x:u},attrs:{shape:[i.sizeFromShape(t.shape)/m,m]},backend:r}),y=C4(g,pD(t.dtype),"sum",r),v=w4({inputs:{x:y},attrs:{shape:f},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(y),c&&r.disposeIntermediateTensorInfo(u),v}(s,o,a,n)}const R4={kernelName:$N,backendName:"webgl",kernelFunc:k4};function N4(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{perm:s}=i,o=n,a=new Array(r.shape.length);for(let c=0;c<a.length;c++)a[c]=r.shape[s[c]];let l;if(o.shouldExecuteOnCPU([r])){const t=o.texData.get(r.dataId),e=P3(t.values,r.shape,r.dtype,s,a);l=o.makeTensorInfo(a,r.dtype),o.texData.get(l.dataId).values=e}else l=M4(r,s,o);return l}const L4={kernelName:oL,backendName:"webgl",kernelFunc:N4};function D4({a:t,b:e,transposeA:n,transposeB:r,backend:s,bias:o=null,preluActivationWeights:a=null,leakyreluAlpha:l=0,activation:c=null}){const u=t.shape.length,h=e.shape.length,d=n?t.shape[u-2]:t.shape[u-1],p=r?e.shape[h-1]:e.shape[h-2],f=n?t.shape[u-1]:t.shape[u-2],m=r?e.shape[h-2]:e.shape[h-1],g=t.shape.slice(0,-2),y=e.shape.slice(0,-2),v=i.sizeFromShape(g),b=i.sizeFromShape(y);i.assert(u>=2&&h>=2&&(v===b||1===v||1===b),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${g}) and (${y}).`);const A=(v>b?t.shape.slice(0,-2):e.shape.slice(0,-2)).concat([f,m]);i.assert(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${r} must match.`);const x=n?[v,d,f]:[v,f,d],w=r?[b,m,p]:[b,p,m],_=w4({inputs:{x:t},backend:s,attrs:{shape:x}}),S=w4({inputs:{x:e},backend:s,attrs:{shape:w}}),E=[_,S],C=Math.max(v,b),I=n?_.shape[1]:_.shape[2],T=null!=o,M=null!=a,k="leakyrelu"===c,R=null!=c?g4(c,!0):null;let N;if((1===f||1===m)&&I>1e3&&!1===(T||M||k||null!=R)){let t=_,e=S;n&&(t=N4({inputs:{x:_},backend:s,attrs:{perm:[0,2,1]}}),E.push(t)),r&&(e=N4({inputs:{x:S},backend:s,attrs:{perm:[0,2,1]}}),E.push(e));const i=1===m;let o=t;1!==m&&(o=w4({inputs:{x:t},backend:s,attrs:{shape:[C,I,1]}}),E.push(o));const a=1===m?2:1;let l=e;i&&(l=w4({inputs:{x:e},backend:s,attrs:{shape:[C,1,I]}}),E.push(l));const c=A4({inputs:{a:o,b:l},backend:s});N=k4({inputs:{x:c},backend:s,attrs:{axis:a,keepDims:!0}}),E.push(c)}else{const c=dD(t.dtype,e.dtype),u=new y4(x,w,[C,f,m],n,r,T,R,M,k),h=[_,S];if(null!=o&&h.push(o),M&&h.push(a),k){const t=s.makeTensorInfo([],"float32",i.createScalarValue(l,"float32"));h.push(t),E.push(t)}N=s.runWebGLProgram(u,h,c)}const L=w4({inputs:{x:N},backend:s,attrs:{shape:A}});E.push(N);for(const i of E)s.disposeIntermediateTensorInfo(i);return L}const B4={kernelName:fL,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{a:r,b:s,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=i;return D4({a:r,b:s,transposeA:l,transposeB:c,backend:n,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:u})}},O4="return abs(x);",P4={kernelName:gk,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:i}=e;if(n.shouldExecuteOnCPU([i])&&"complex64"!==i.dtype){const t=n.texData.get(i.dataId),e=E3(t.values);return n.makeTensorInfo(i.shape,i.dtype,e)}let r;return r=hk().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Y3(i.shape,O4):new Q3(i.shape,O4),n.runWebGLProgram(r,[i],i.dtype)}},F4=f4({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),$4={kernelName:yk,backendName:"webgl",kernelFunc:F4},z4=f4({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),U4={kernelName:vk,backendName:"webgl",kernelFunc:z4},H4="return a + b;",V4=m4({opSnippet:H4,packedOpSnippet:H4,supportsComplex:!0,cpuKernelImpl:Z2}),G4={kernelName:bk,backendName:"webgl",kernelFunc:V4};class W4{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((t,e)=>`T${e}`);const n=[];this.variableNames.forEach(t=>{n.push(`float v${t} = get${t}AtOutCoords();`)});const i=this.variableNames.map(t=>`v${t}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${i};\n        setOutput(result);\n      }\n    `}}class j4{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((t,e)=>`T${e}`);const n=[];this.variableNames.forEach(t=>{n.push(`vec4 v${t} = get${t}AtOutCoords();`)});const i=this.variableNames.map(t=>`v${t}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${i};\n        setOutput(result);\n      }\n    `}}const Q4={kernelName:Ak,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:i}=e,r=n;if(1===r.length)return r4({inputs:{x:r[0]},backend:i});if(r.length>hk().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const e=Math.floor(r.length/2),n=t({inputs:r.slice(0,e),backend:i}),s=t({inputs:r.slice(e),backend:i});return t({inputs:[n,s],backend:i})}const s=r.map(t=>t.dtype).reduce((t,e)=>dD(t,e)),o=r.map(t=>t.shape),a=hk().getBool("WEBGL_PACK")?new j4(r[0].shape,o):new W4(r[0].shape,o);return i.runWebGLProgram(a,r,s)}},q4={kernelName:xk,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:a}=r,l=s.shape.length,c=i.parseAxisParam(o,s.shape);let u=c;const h=d.getAxesPermutation(u,l);let p=s;null!=h&&(p=N4({inputs:{x:s},backend:n,attrs:{perm:h}}),u=d.getInnerMostAxes(u.length,l)),d.assertAxesAreInnerMostDims("all",u,l);const[f,m]=d.computeOutAndReduceShapes(p.shape,u),g=w4({inputs:{x:p},backend:n,attrs:{shape:[-1,i.sizeFromShape(m)]}}),y=C4(g,g.dtype,"all",n);let v;return v=w4(a?{inputs:{x:y},backend:n,attrs:{shape:d.expandShapeToKeepDim(f,c)}}:{inputs:{x:y},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),null!=h&&n.disposeIntermediateTensorInfo(p),v}},X4={kernelName:wk,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:a}=r,l=s.shape.length,c=i.parseAxisParam(o,s.shape);let u=c;const h=d.getAxesPermutation(u,l);let p=s;null!=h&&(p=N4({inputs:{x:s},backend:n,attrs:{perm:h}}),u=d.getInnerMostAxes(u.length,l)),d.assertAxesAreInnerMostDims("any",u,l);const[f,m]=d.computeOutAndReduceShapes(p.shape,u),g=w4({inputs:{x:p},backend:n,attrs:{shape:[-1,i.sizeFromShape(m)]}}),y=C4(g,g.dtype,"any",n);let v;return v=w4(a?{inputs:{x:y},backend:n,attrs:{shape:d.expandShapeToKeepDim(f,c)}}:{inputs:{x:y},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),null!=h&&n.disposeIntermediateTensorInfo(p),v}};class Y4{constructor(t,e,n){this.variableNames=["A"];const{windowSize:i,batchSize:r,outSize:s}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,s],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${i};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${i}; i++) {\n          int inIdx = ${n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class K4{constructor(t,e,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,i.assert(t.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const s=Math.ceil(t[t.length-1]/e);this.outputShape=t.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");const o=this.outputShape,a=o.length,l=Q2(a),c=z3("coords",a);let u,h;if(1===s){h=a+1;const t=Q2(h);u=`\n        ${t} sourceLocR = ${t}(${c.join()}, 0);\n        ++${c[a-1]};\n        ${t} sourceLocG = ${t}(${c.join()}, 0);\n        ++${c[a-2]};\n        ${t} sourceLocA = ${t}(${c.join()}, 0);\n        --${c[a-1]};\n        ${t} sourceLocB = ${t}(${c.join()}, 0);\n        --${c[a-2]};`}else h=a,u=`\n        ${l} sourceLocR = coords;\n        ++${c[a-1]};\n        ${l} sourceLocG = coords;\n        ++${c[a-2]};\n        ${l} sourceLocA = coords;\n        --${c[a-1]};\n        ${l} sourceLocB = coords;\n        --${c[a-2]};`;const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map(t=>"int "+t),m=z3("sourceLocR",h-1).concat("inIdx.r"),g=z3("sourceLocG",h-1).concat("inIdx.g"),y=z3("sourceLocB",h-1).concat("inIdx.b"),v=z3("sourceLocA",h-1).concat("inIdx.a"),b="max"===n?"greaterThan":"lessThan",A=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${v.join()})));`,x=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,w=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${d.join()}),\n                                          vec2(${d.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${d.join()}),\n                               vec2(${d.slice(-2).join()}));\n      }\n      ${w}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${c[a-1]} < ${o[a-1]-1};\n        bool hasNextRow = ${c[a-2]} < ${o[a-2]-1};\n        ${u}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${x};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${A}\n          vec4 candidate = ${x};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${b}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function J4(t,e,n,i=null){let r=e.shape[0],s=e.shape[1];null!=i&&(r=i.shape[0],s=i.shape[1]);const o=d.computeOptimalWindowSize(s),a={windowSize:o,inSize:s,batchSize:r,outSize:Math.ceil(s/o)},l=new Y4(a,n,null==i),c=[e];null!=i&&c.push(i);const u=t.runWebGLProgram(l,c,"int32");if(1===u.shape[1])return u;const h=J4(t,e,n,u);return t.disposeIntermediateTensorInfo(u),h}function Z4(t,e,n,i=null){const r=null!=i?i.shape:e.shape,s=d.computeOptimalWindowSize(r[r.length-1]),o=new K4(r,s,n,null==i),a=t.runWebGLProgram(o,null==i?[e]:[e,i],"int32");if(a.shape.length===e.shape.length){const i=Z4(t,e,n,a);return t.disposeIntermediateTensorInfo(a),i}return a}function t5(t,e,n,r){const s=[n];if(d.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,e.shape.length),!hk().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const n=[],[o,a]=d.computeOutAndReduceShapes(e.shape,s),l=i.sizeFromShape(a),c=w4({inputs:{x:e},backend:t,attrs:{shape:[-1,l]}});n.push(c);const u=J4(t,c,r);n.push(u);const h=w4({inputs:{x:u},backend:t,attrs:{shape:o}});return n.forEach(e=>t.disposeIntermediateTensorInfo(e)),h}return Z4(t,e,r)}const e5={kernelName:_k,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o}=r;let a=i.parseAxisParam(o,s.shape);const l=d.getAxesPermutation(a,s.shape.length);let c=s;const u=[];null!=l&&(c=N4({inputs:{x:s},backend:n,attrs:{perm:l}}),u.push(c),a=d.getInnerMostAxes(a.length,c.shape.length)),d.assertAxesAreInnerMostDims("argMax",[a[0]],c.shape.length);const h=t5(n,c,a[0],"max");return u.forEach(t=>n.disposeIntermediateTensorInfo(t)),h}},n5={kernelName:Sk,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o}=r;let a=i.parseAxisParam(o,s.shape);const l=d.getAxesPermutation(a,s.shape.length);let c=s;const u=[];null!=l&&(c=N4({inputs:{x:s},backend:n,attrs:{perm:l}}),u.push(c),a=d.getInnerMostAxes(a.length,c.shape.length)),d.assertAxesAreInnerMostDims("argMin",[a[0]],c.shape.length);const h=t5(n,c,a[0],"min");return u.forEach(t=>n.disposeIntermediateTensorInfo(t)),h}},i5=f4({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),r5={kernelName:Ek,backendName:"webgl",kernelFunc:i5},s5=f4({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),o5={kernelName:Ck,backendName:"webgl",kernelFunc:s5},a5=f4({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),l5={kernelName:Ik,backendName:"webgl",kernelFunc:a5},c5=m4({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),u5={kernelName:Mk,backendName:"webgl",kernelFunc:c5},h5=f4({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),d5={kernelName:Tk,backendName:"webgl",kernelFunc:h5};class p5{constructor(t,e,n,i=!1,r=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const s=t.filterWidth,o=t.strideHeight,a=t.strideWidth,l=t.dilationHeight,c=t.dilationWidth,u=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.top,p=t.padInfo.left;this.outputShape=t.outShape;const f="avg"===e;let m="0.0";if(f||(m="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec2 strides = ivec2(${o}, ${a});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${u};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${c}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${i?r?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let g=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(g="avgValue / count");const y=4*Math.floor(s/4),v=s%4,b=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${a});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${m};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${m});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${u};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${y}; wC += 4) {\n            int xC = xCCorner + wC * ${c};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              getValue(batch, xR, xC + 3 * ${c}, d)\n            );\n\n            ${b}\n          }\n\n          int xC = xCCorner + ${y};\n          if (${1===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${b}\n          } else if (${2===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${b}\n          } else if (${3===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              initializationValue\n            );\n\n            ${b}\n          }\n        }\n        setOutput(${g});\n      }\n    `}}class f5{constructor(t,e,n,i=!1,r=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const s=t.filterWidth,o=t.strideDepth,a=t.strideHeight,l=t.strideWidth,c=t.dilationDepth,u=t.dilationHeight,h=t.dilationWidth,d=t.effectiveFilterDepth,p=t.effectiveFilterHeight,f=t.effectiveFilterWidth,m=t.padInfo.front,g=t.padInfo.top,y=t.padInfo.left;this.outputShape=t.outShape;const v="avg"===e;let b="0.0";if(v||(b="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${o}, ${a}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${c}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${u}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${i?r?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let A=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(A="avgValue / count");const x=4*Math.floor(s/4),w=s%4,_=`\n      if (${v}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${o}, ${a}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${c}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${x}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${_}\n            }\n\n            int xC = xCCorner + ${x};\n            if (${1===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${_}\n            } else if (${2===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${_}\n            } else if (${3===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${_}\n            }\n          }\n          setOutput(${A});\n        }\n      }\n    `}}const m5={kernelName:kk,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;y2(s,"avgPool");const{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=r;i.assert(d.eitherStridesOrDilationsAreOne(a,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`);const u=d.computePool2DInfo(s.shape,o,a,1,l,c);if(1===u.filterWidth&&1===u.filterHeight&&i.arraysEqual(u.inShape,u.outShape))return r4({inputs:{x:s},backend:n});const h=new p5(u,"avg",!1);return n.runWebGLProgram(h,[s],"float32")}},g5={kernelName:Nk,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{filterSize:s,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=i,u=d.computePool3DInfo(r.shape,s,o,[1,1,1],a,l,c),h=new f5(u,"avg",!1);return n.runWebGLProgram(h,[r],"float32")}};class y5{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.effectiveFilterHeight,n=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class v5{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.effectiveFilterDepth,n=t.effectiveFilterHeight,i=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${i-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${e};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${i};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const b5={kernelName:Lk,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,input:s}=e,o=s,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=i,h=d.computePool3DInfo(o.shape,a,l,[1,1,1],c,u),p=new v5(h);return n.runWebGLProgram(p,[r],o.dtype)}},A5={kernelName:Rk,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,input:s}=e,o=s;y2([r,s],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=i,u=d.computePool2DInfo(o.shape,a,l,1,c),h=new y5(u);return n.runWebGLProgram(h,[r],o.dtype)}},x5={kernelName:Dk,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{a:r,b:s}=e,{transposeA:o,transposeB:a}=i;return D4({a:r,b:s,transposeA:o,transposeB:a,backend:n})}};class w5{constructor(t,e,n,i,r,s){this.outputShape=[],this.variableNames=["x","mean","variance"],d.assertAndGetBroadcastShape(t,e),d.assertAndGetBroadcastShape(t,n);let o="0.0";null!=i&&(d.assertAndGetBroadcastShape(t,i),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let a="1.0";null!=r&&(d.assertAndGetBroadcastShape(t,r),this.variableNames.push("scale"),a="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${o};\n        float scale = ${a};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class _5{constructor(t,e,n,i,r,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],d.assertAndGetBroadcastShape(t,e),d.assertAndGetBroadcastShape(t,n);let o="vec4(0.0)";null!=i&&(d.assertAndGetBroadcastShape(t,i),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let a="vec4(1.0)";null!=r&&(d.assertAndGetBroadcastShape(t,r),this.variableNames.push("scale"),a="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${o};\n        vec4 scale = ${a};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const S5={kernelName:wR,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,mean:s,variance:o,offset:a,scale:l}=t;i.assert(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),i.assert(null==a||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),i.assert(null==l||s.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:c}=n;null==c&&(c=.001);const u=[r,s,o];let h=null;null!=a&&(h=a.shape,u.push(a));let d=null;null!=l&&(d=l.shape,u.push(l));const p=hk().getBool("WEBGL_PACK_NORMALIZATION")?new _5(r.shape,s.shape,o.shape,h,d,c):new w5(r.shape,s.shape,o.shape,h,d,c);return e.runWebGLProgram(p,u,u[0].dtype)}};class E5{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=Q2(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(t){if(1===t)return"sourceLoc";if(t<=6)return C5.slice(0,t).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}(this.rank);let i;i=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((t,e)=>`sourceLoc.${C5[e]} = start[${e}] + coords.${C5[e]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${i}\n        setOutput(getSource(${n}));\n      }\n    `}}const C5=["x","y","z","w","u","v"];class I5{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=Q2(this.rank),n=z3("coords",this.rank),i=z3("sourceLoc",this.rank),r=1===this.rank?"sourceLoc":`vec2(${i.slice(-2).join()})`,s=`getChannel(getSource(${i.join()}), ${r})`,o=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${i[this.rank-1]};\n        result.y = ${s};\n        --${i[this.rank-1]};\n      }\n    `,a=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${i[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${i[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((t,e)=>`start[${e}]`).join()});`:t.map((t,e)=>`${i[e]} = ${n[e]} + start[${e}];`).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${o}\n        ${a}\n        setOutput(result);\n      }\n    `}}function T5(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:o,size:a}=r,[c,u]=l.parseSliceParams(s,o,a);if(l.assertParamsValid(s,c,u),0===i.sizeFromShape(u))return n.makeTensorInfo(u,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||"string"===s.dtype){const t=n.texData.get(s.dataId),e=C3(t.values,c,u,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,e)}const{isPacked:h}=n.texData.get(s.dataId),d=l.isSliceContinous(s.shape,c,u);if(h||!d){const t=hk().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new I5(u):new E5(u);return n.runWebGLProgram(t,[s],s.dtype,[c])}return n.uploadToGPU(s.dataId),function(t,e,n,r){const s=r.texData.get(t.dataId),o=r.makeTensorInfo(n,t.dtype),a=r.texData.get(o.dataId);Object.assign(a,s),a.refCount=1,a.shape=n,a.dtype=t.dtype;let c=l.computeFlatOffset(e,i.computeStrides(t.shape));s.slice&&(c+=s.slice.flatOffset),a.slice={flatOffset:c,origDataId:s.slice&&s.slice.origDataId||t.dataId};const u=r.dataRefCount.get(a.slice.origDataId)||1;return r.dataRefCount.set(a.slice.origDataId,u+1),o}(s,c,u,n)}const M5={kernelName:NN,backendName:"webgl",kernelFunc:T5},k5={kernelName:Bk,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:o,crops:a}=r;i.assert(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const l=o.reduce((t,e)=>t*e),c=d.getReshaped(s.shape,o,l),u=d.getPermuted(c.length,o.length),h=d.getReshapedPermuted(s.shape,o,l),p=d.getSliceBeginCoords(a,o.length),f=d.getSliceSize(h,a,o.length),m=[],g=w4({inputs:{x:s},backend:n,attrs:{shape:c}}),y=N4({inputs:{x:g},backend:n,attrs:{perm:u}}),v=w4({inputs:{x:y},backend:n,attrs:{shape:h}}),b=T5({inputs:{x:v},backend:n,attrs:{begin:p,size:f}});return m.push(g),m.push(y),m.push(v),m.forEach(t=>n.disposeIntermediateTensorInfo(t)),b}},R5={kernelName:Ok,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,weights:s}=e,{size:o}=i,a=n.readSync(r.dataId),l=n.readSync(s.dataId),c=t3(a,l,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,c)}},N5=m4({opSnippet:"return float(a != b);",cpuKernelImpl:x3,dtype:"bool"}),L5={kernelName:sN,backendName:"webgl",kernelFunc:N5};function D5(t){const{inputs:e,backend:n}=t,{input:i}=e;return r4({inputs:{x:n.texData.get(i.dataId).complexTensorInfos.real},backend:n})}const B5={kernelName:yN,backendName:"webgl",kernelFunc:D5},O5={kernelName:Pk,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:r,attrs:s}=e,{x:o}=n,{dtype:a}=s;if("complex64"===a){if("complex64"===o.dtype)return r4({inputs:{x:o},backend:r});const e=aF(o.shape),n=t({inputs:{x:o},backend:r,attrs:{dtype:"float32"}}),i=o4({inputs:{real:n,imag:e},backend:r});return e.dispose(),r.disposeIntermediateTensorInfo(n),i}if("complex64"===o.dtype){const e=D5({inputs:{input:o},backend:r}),n=t({inputs:{x:e},backend:r,attrs:{dtype:a}});return r.disposeIntermediateTensorInfo(e),n}if(!i.hasEncodingLoss(o.dtype,a)){const t=r4({inputs:{x:o},backend:r});return{dataId:t.dataId,shape:t.shape,dtype:a}}if("int32"===a)return function(t,e){const n=new Q3(t.shape,"return float(int(x));"),i=e.runWebGLProgram(n,[t],"int32");return{dataId:i.dataId,shape:i.shape,dtype:i.dtype}}(o,r);if("bool"===a){const t=r.makeTensorInfo([],"bool",i.getTypedArrayFromDType("bool",1)),e=N5({inputs:{a:o,b:t},backend:r});return r.disposeIntermediateTensorInfo(t),e}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${a}`)}},P5="return ceil(x);",F5=f4({opSnippet:P5,packedOpSnippet:P5,cpuKernelImpl:n3}),$5={kernelName:Fk,backendName:"webgl",kernelFunc:F5};class z5{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class U5{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const H5={kernelName:$k,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{clipValueMin:s,clipValueMax:o}=i;let a;return a=hk().getBool("WEBGL_PACK_CLIP")?new U5(r.shape):new z5(r.shape),n.runWebGLProgram(a,[r],r.dtype,[[s],[o]])}};class V5{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function G5(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}const W5={kernelName:Uk,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:i}=e,r=n.texData.get(i.dataId),s=new V5(i.shape),o=[G5(i,r.complexTensorInfos.real),G5(i,r.complexTensorInfos.imag)];return n.runWebGLProgram(s,o,o[0].dtype)}};class j5{constructor(t){this.outputShape=[],this.outputShape=d.computeOutShape(t,1),this.variableNames=t.map((t,e)=>`T${e}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let i=1;i<e.length;i++)e[i]=e[i-1]+t[i][1];const n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<e.length;i++)n.push(`else if (yC < ${e[i]}) setOutput(getT${i}(yR, yC-${e[i-1]}));`);n.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class Q5{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=d.computeOutShape(t,e);const n=this.outputShape,i=n.length,r=Q2(i),s=z3("coords",i),o=["x","y","z","w","u","v"].slice(0,i);this.variableNames=t.map((t,e)=>`T${e}`);const a=new Array(t.length-1);a[0]=t[0][e];for(let d=1;d<a.length;d++)a[d]=a[d-1]+t[d][e];const l=o[e],c=o.slice(-2),u=o.join();let h=`if (${l} < ${a[0]}) {\n        return getChannel(\n            getT0(${u}), vec2(${c.join()}));\n        }`;for(let d=1;d<a.length;d++){const t=a[d-1];h+=`\n        if (${l} < ${a[d]}  && ${l} >= ${a[d-1]}) {\n          return getChannel(\n            getT${d}(${q5(o,l,t)}),\n            vec2(${q5(c,l,t)}));\n        }`}const p=a[a.length-1];h+=`\n        return getChannel(\n          getT${a.length}(${q5(o,l,p)}),\n          vec2(${q5(c,l,p)}));`,this.userCode=`\n      float getValue(${o.map(t=>"int "+t)}) {\n        ${h}\n      }\n\n      void main() {\n        ${r} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[i-1]} = ${s[i-1]} + 1;\n        if (${s[i-1]} < ${n[i-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[i-2]} = ${s[i-2]} + 1;\n        if (${s[i-2]} < ${n[i-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[i-1]} = ${s[i-1]} - 1;\n        if (${s[i-2]} < ${n[i-2]} &&\n            ${s[i-1]} < ${n[i-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}}function q5(t,e,n){const i=t.indexOf(e);return t.map((t,e)=>e===i?`${t} - ${n}`:t).join()}function X5(t){const{inputs:e,backend:n}=t,{input:i}=e;return r4({inputs:{x:n.texData.get(i.dataId).complexTensorInfos.imag},backend:n})}const Y5={kernelName:MR,backendName:"webgl",kernelFunc:X5};function K5(t,e,n){const r=t[0].dtype;if("complex64"===r){const i=t.map(t=>D5({inputs:{input:t},backend:n})),r=t.map(t=>X5({inputs:{input:t},backend:n})),s=K5(i,e,n),o=K5(r,e,n),a=o4({inputs:{real:s,imag:o},backend:n});return i.forEach(t=>n.disposeIntermediateTensorInfo(t)),r.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),a}let s=n.shouldExecuteOnCPU(t);if("string"===r&&(s=!0),s){const s=t.map(t=>{const r=i.sizeFromShape(t.shape.slice(e));return w4({inputs:{x:t},backend:n,attrs:{shape:[-1,r]}})}),o=s.map(t=>({vals:n.readSync(t.dataId),shape:t.shape})),a=d.computeOutShape(s.map(t=>t.shape),1),l=i3(o,a,r,1===s[0].shape[0]),c=d.computeOutShape(t.map(t=>t.shape),e),u=n.makeTensorInfo(c,r,l);return s.forEach(t=>n.disposeIntermediateTensorInfo(t)),u}if(t.length>hk().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const i=Math.floor(t.length/2),r=K5(t.slice(0,i),e,n),s=K5(t.slice(i),e,n),o=K5([r,s],e,n);return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),o}if(hk().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&t[0].shape.length>1){const i=new Q5(t.map(t=>t.shape),e);return n.runWebGLProgram(i,t,r)}const{tensors2D:o,outShape:a}=function(t,e,n){const r=d.computeOutShape(t.map(t=>t.shape),e);return{tensors2D:t.map(t=>w4({inputs:{x:t},attrs:{shape:[-1,i.sizeFromShape(t.shape.slice(e))]},backend:n})),outShape:r}}(t,e,n),l=new j5(o.map(t=>t.shape)),c=n.runWebGLProgram(l,o,r);o.forEach(t=>n.disposeIntermediateTensorInfo(t));const u=w4({inputs:{x:c},attrs:{shape:a},backend:n});return n.disposeIntermediateTensorInfo(c),u}function J5(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r,o=i.parseAxisParam(s,e[0].shape)[0],a=d.computeOutShape(e.map(t=>t.shape),o);if(0===i.sizeFromShape(a))return n.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(t=>i.sizeFromShape(t.shape)>0);if(1===l.length)return r4({inputs:{x:l[0]},backend:n});const c=l.map(t=>t.shape);return d.assertParamsConsistent(c,o),K5(l,o,n)}const Z5={kernelName:Hk,backendName:"webgl",kernelFunc:J5};class t6{constructor(t,e=!1,n=null,i=!1,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const s=t.padInfo.top,o=t.padInfo.left,a=t.strideHeight,l=t.strideWidth,c=t.dilationHeight,u=t.dilationWidth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4,m="channelsLast"===t.dataFormat,g=m?1:2,y=m?2:3,v=m?3:1;let b="",A="";n&&(b=i?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,A="result = activation(result);");const x=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${b}\n\n      const ivec2 strides = ivec2(${a}, ${l});\n      const ivec2 pads = ivec2(${s}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${v}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${c};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${u};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${x}\n        ${A}\n        setOutput(result);\n      }\n    `}}class e6{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,n=t.padInfo.top,i=t.padInfo.left,r=t.strideDepth,s=t.strideHeight,o=t.strideWidth,a=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,u=t.filterDepth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${r}, ${s}, ${o});\n      const ivec3 pads = ivec3(${e}, ${n}, ${i});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${u}; wF++) {\n          int xF = xFCorner + wF * ${a};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${c};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class n6{constructor(t,e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;const{filterWidth:i,inChannels:r,strideWidth:s,strideHeight:o,padInfo:a,outWidth:l,dilationWidth:c,dilationHeight:u,dataFormat:h}=n,{left:d,top:p}=a,f=r*i,m=b2(),g="channelsLast"===h,y=g?0:1,v=g?1:2;let b="";for(let A=0;A<=1;A++)for(let n=0;n<=1;n++)b+=`\n          blockIndex = rc.y + ${n};\n          pos = rc.x + ${A};\n\n          if(blockIndex < ${t[1]} && pos < ${t[0]}) {\n            offsetY = int(blockIndex / (${l})) * ${o} - ${p};\n            d0 = offsetY + ${u} * (pos / ${f});\n\n            if(d0 < ${e[y]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${l}.) * ${s}. - ${d}.);\n              d1 = offsetX + ${c} * (int(mod(float(pos), ${f}.) / ${r}.));\n\n              if(d1 < ${e[v]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${r}.));\n\n                if (${g}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*A+n}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*A+n}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${b}\n\n        ${m.output} = result;\n      }\n    `}}function i6({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=t.shape,u=r.texData.get(t.dataId),h="channelsLast"===n.dataFormat;let d;const p=[],f=c[2]%2!=0&&!!u.isPacked;if((1!=c[0]*c[1]*c[2]&&1!==n.outChannels||!(n.inChannels>1e3))&&hk().getBool("WEBGL_LAZILY_UNPACK")&&hk().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&f){const f={dataId:t.dataId,shape:[1,h?c[0]*c[1]*(c[2]+1):c[0]*c[2]*(c[3]+1),n.inChannels],dtype:t.dtype},m=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,i.assert(h2(u.shape,f.shape),()=>`packed reshape ${u.shape} to ${f.shape} isn't free`);const g=w4({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});p.push(g);const y=D4({a:f,b:g,backend:r,transposeA:!1,transposeB:!1,bias:s,activation:l,preluActivationWeights:o,leakyreluAlpha:a}),v=r.texData.get(y.dataId);i.assert(v.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=m,v.shape=n.outShape,d=r4({inputs:{x:y},backend:r}),d.shape=n.outShape,p.push(y)}else{const i=w4({inputs:{x:t},backend:r,attrs:{shape:[1,h?c[0]*c[1]*c[2]:c[0]*c[2]*c[3],n.inChannels]}}),u=w4({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),f=D4({a:i,b:u,transposeA:!1,transposeB:!1,backend:r,bias:s,activation:l,preluActivationWeights:o,leakyreluAlpha:a});d=w4({inputs:{x:f},backend:r,attrs:{shape:n.outShape}}),p.push(i),p.push(u),p.push(f)}for(const i of p)r.disposeIntermediateTensorInfo(i);return d}function r6({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const{filterWidth:c,filterHeight:u,inChannels:h,outWidth:d,outHeight:p,dataFormat:f}=n,m="channelsLast"===f,g=c*u*h,y=p*d,v=[g,y],b=[],A=w4({inputs:{x:t},backend:r,attrs:{shape:t.shape.slice(1)}}),x=w4({inputs:{x:e},backend:r,attrs:{shape:[1,g,i.sizeFromShape(e.shape)/g]}});b.push(A),b.push(x);const w=new n6(v,A.shape,n),_=r.runWebGLProgram(w,[A],"float32"),S=w4({inputs:{x:_},backend:r,attrs:{shape:[1,v[0],v[1]]}});b.push(_),b.push(S);const E=null!=s,C=null!=o,I="leakyrelu"===l,T=l?g4(l,!0):null,M=new y4(S.shape,x.shape,[1,y,n.outChannels],!0,!1,E,T,C,I),k=[S,x];if(s&&k.push(s),C&&k.push(o),I){const t=r.makeTensorInfo([],"float32",i.createScalarValue(a,"float32"));k.push(t),b.push(t)}const R=r.runWebGLProgram(M,k,"float32"),N=w4({inputs:{x:R},backend:r,attrs:{shape:m?[1,p,d,n.outChannels]:[1,n.outChannels,p,d]}});b.push(R);for(const i of b)r.disposeIntermediateTensorInfo(i);return N}const s6={kernelName:Vk,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,filter:s}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=i,h=d.convertConv2DDataFormat(l),p=d.computeConv2DInfo(r.shape,s.shape,o,c,a,u,!1,h);let f;if(1!==p.filterHeight||1!==p.filterWidth||1!==p.dilationHeight||1!==p.dilationWidth||1!==p.strideHeight||1!==p.strideWidth||"SAME"!==p.padInfo.type&&"VALID"!==p.padInfo.type)if(hk().getBool("WEBGL_CONV_IM2COL")&&1===r.shape[0])f=r6({x:r,filter:s,convInfo:p,backend:n});else{const t=new t6(p);f=n.runWebGLProgram(t,[r,s],"float32")}else f=i6({x:r,filter:s,convInfo:p,backend:n});const m=w4({inputs:{x:f},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(f),m}};class o6{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===t.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class a6{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,i="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${i?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${i?1:2}], coords[${i?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${i}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class l6{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class c6{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,i=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${i-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${i}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${i} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const u6={kernelName:Gk,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,dy:s}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=i,h=d.convertConv2DDataFormat(l),p=d.computeConv2DInfo(r.shape,u,o,1,a,c,!1,h),f=new o6(p);return n.runWebGLProgram(f,[r,s],"float32")}},h6={kernelName:Wk,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,filter:s}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=i,h=d.convertConv2DDataFormat(c),p=d.computeConv2DInfo(o,s.shape,a,1,l,u,!1,h),f=new a6(p);return n.runWebGLProgram(f,[r,s],"float32")}},d6={kernelName:jk,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,filter:s}=e,{strides:o,pad:a,dilations:l}=i,c=d.computeConv3DInfo(r.shape,s.shape,o,l,a),u=new e6(c);return n.runWebGLProgram(u,[r,s],"float32")}},p6={kernelName:Qk,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,dy:s}=e,{strides:o,pad:a,filterShape:l}=i,c=d.computeConv3DInfo(r.shape,l,o,1,a),u=new l6(c);return n.runWebGLProgram(u,[r,s],"float32")}},f6={kernelName:qk,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,filter:s}=e,{pad:o,strides:a,inputShape:l}=i,c=d.computeConv3DInfo(l,s.shape,a,1,o),u=new c6(c);return n.runWebGLProgram(u,[r,s],"float32")}},m6=f4({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),g6={kernelName:Xk,backendName:"webgl",kernelFunc:m6},y6=f4({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),v6={kernelName:Yk,backendName:"webgl",kernelFunc:y6};class b6{constructor(t,e,n,i,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,o,a,l]=t,[c]=e,[u,h]=n;this.outputShape=[c,u,h,l];const d="bilinear"===i?1:0,[p,f]=[o-1+".0",a-1+".0"],[m,g,y]=u>1?[""+(o-1)/(u-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[v,b,A]=h>1?[""+(a-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${v});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${b};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${r}));\n          return;\n        }\n        float in_x = ${A};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${r}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const A6={kernelName:Jk,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:i}=t,{image:r,boxes:s,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=i,u=new b6(r.shape,s.shape,a,l,c);return n.runWebGLProgram(u,[r,s,o],"float32")}};class x6{constructor(t,e,n){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=t;const i=t.length,r=e?"0.0":`getX(${w6(i,"coords")})`,s=t[t.length-1];let o="",a="";e?(o=n?"end != "+(s-1):"end != 0",a=n?"end + 1":"end - 1"):(o=n?`end + pow2 < ${s}`:"end >= pow2",a=n?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${Q2(i)} coords = getOutputCoords();\n        int end = ${_6(i,"coords")};\n        float val = ${r};\n        int pow2 = int(pow(2.0, index));\n        if (${o}) {\n          int idx = ${a};\n          ${_6(i,"coords")} = idx;\n          val += getX(${w6(i,"coords")});\n        }\n        setOutput(val);\n      }\n    `}}function w6(t,e){if(1===t)return`${e}`;if(2===t)return`${e}.x, ${e}.y`;if(3===t)return`${e}.x, ${e}.y, ${e}.z`;if(4===t)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}function _6(t,e){if(1===t)return`${e}`;if(2===t)return`${e}.y`;if(3===t)return`${e}.z`;if(4===t)return`${e}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}const S6={kernelName:Kk,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s,exclusive:o,reverse:a}=i,l=r.shape.length,c=d.getAxesPermutation([s],l);let u=r;null!=c&&(u=N4({inputs:{x:r},backend:n,attrs:{perm:c}}));const h=d.getInnerMostAxes(1,l)[0];if(h!==l-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${r.shape.length-1} but got axis=${s}`);const p=u.shape[h];let f=r4({inputs:{x:u},backend:n});for(let d=0;d<=Math.ceil(Math.log2(p))-1;d++){const t=new x6(u.shape,!1,a),e=f;f=n.runWebGLProgram(t,[f],f.dtype,[[d]]),n.disposeIntermediateTensorInfo(e)}if(o){const t=new x6(u.shape,o,a),e=f;f=n.runWebGLProgram(t,[f],f.dtype),n.disposeIntermediateTensorInfo(e)}if(null!=c){const t=N4({inputs:{x:f},backend:n,attrs:{perm:d.getUndoAxesPermutation(c)}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(u),t}return f}},E6={kernelName:Zk,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,weights:s}=e,{size:o,binaryOutput:a}=i;if(1===r.shape.length){const t=n.readSync(r.dataId),e=n.readSync(s.dataId),i=t3(t,e,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,i)}if(2===r.shape.length){const t=n.bufferSync(r),e=n.bufferSync(s),i=e3(t,e,o,a);return n.makeTensorInfo(i.shape,s.dtype,i.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}};class C6{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const I6={kernelName:tR,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockSize:o,dataFormat:a}=r;i.assert(o>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${o}`);const l=s.shape[0],c=("NHWC"===a?s.shape[1]:s.shape[2])*o,u=("NHWC"===a?s.shape[2]:s.shape[3])*o,h=("NHWC"===a?s.shape[3]:s.shape[1])/(o*o),d=new C6("NHWC"===a?[l,c,u,h]:[l,h,c,u],o,a);return n.runWebGLProgram(d,[s],s.dtype)}};class T6{constructor(t,e=!1,n=null,i=!1,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const s=t.inHeight,o=t.inWidth,a=t.padInfo.top,l=t.padInfo.left,c=t.strideHeight,u=t.strideWidth,h=t.dilationHeight,d=t.dilationWidth,p=t.filterHeight,f=t.filterWidth,m=t.outChannels/t.inChannels;let g="",y="";n&&(g=i?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,y="result = activation(result);");const v=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${g}\n\n      const ivec2 strides = ivec2(${c}, ${u});\n      const ivec2 pads = ivec2(${a}, ${l});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${m};\n        int q = d2 - d1 * ${m};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${p}; wR++) {\n          int xR = xRCorner + wR * ${h};\n\n          if (xR < 0 || xR >= ${s}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${o}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${v}\n        ${y}\n        setOutput(result);\n      }\n    `}}class M6{constructor(t,e=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.outShape;const o=t.outChannels/t.inChannels,a=t.inHeight,l=t.inWidth,c=t.padInfo.top,u=t.padInfo.left,h=t.strideHeight,d=t.strideWidth,p=t.dilationHeight,f=t.dilationWidth,m=t.filterHeight,g=t.filterWidth,y=g;let v="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let i=0;i<g;i++)v+=`\n          vec4 xTexelC${2*i};\n          int xTexelC${2*i}Ready;\n          vec4 xTexelC${2*i+1};\n          int xTexelC${2*i+1}Ready;\n          vec4 xC${i};`;for(let w=0;w<m;w++){for(let t=0;t<g;t++)v+=`\n          xTexelC${2*t} = vec4(0.0);\n          xTexelC${2*t}Ready = 0;\n          xTexelC${2*t+1} = vec4(0.0);\n          xTexelC${2*t+1}Ready = 0;\n          xC${t} = vec4(0.0);`;v+=`\n        xR = xRCorner + ${w*p};\n        if (xR >=0 && xR < ${a}) {\n      `;for(let t=0;t<(y+1)/2;t++){const e=2*t,n=e*f;if(v+=`\n          xC = xCCorner + ${n};\n          `,1===d){if(e<g&&(u%2==1?(v+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < ${l} && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${l}) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n              `,v+=1===f&&n>0?`\n                xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < ${l}) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${l}) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                  }\n                  `):v+=`\n                if (xC >= 0 && xC < ${l} && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${l}) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xC${e} = xTexelC${e};\n                `,n+1<g)){const t=u%2==0?i.nearestLargerEven(f):f;f%2==0&&u%2==1||f%2!=0&&u%2!=1?(v+=`\n                  xCOffset = xC + ${u%2} + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < ${l} && xTexelC${e+1}Ready == 0) {\n                    xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${l}) {\n                      xTexelC${e+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${e+1}Ready = 1;\n                  }\n                  `,f>1&&(v+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < ${l} && xTexelC${e}Ready == 0) {\n                      xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${e}Ready = 1;\n                    }\n                    `),v+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                  `):v+=1===t?`\n                    xC${e+1} = xTexelC${e};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < ${l} && xTexelC${e+1}Ready == 0) {\n                      xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= ${l}) {\n                        xTexelC${e+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${e+1}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${e+1};\n                    `}}else n<g&&(u%2==1?(v+=`\n                xCOffset = xC + 1 - ${d};\n                if(xCOffset >= 0 && xCOffset < ${l} && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${l}) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${l} && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= ${l}) {\n                    xTexelC${e+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n              `,n+1<g&&(v+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + ${d};\n                  if(xCOffset >= 0 && xCOffset < ${l}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                `)):(v+=`\n                if(xC >= 0 && xC < ${l} && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${l}) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xCOffset = xC + ${d};\n                if(xCOffset >= 0 && xCOffset < ${l} && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= ${l}) {\n                    xTexelC${e+1}.zw = vec2(0.);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${e}.xy, xTexelC${e+1}.xy);\n              `,n+1<g&&(v+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                `)));e<g&&(v+=`\n            wTexel = getW(${w}, ${n}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,n+1<g&&(v+=`\n              wTexel = getW(${w}, ${n+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}v+="\n        }\n      "}let b="",A="";n&&(b=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,A="result = activation(result);");const x=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${b}\n\n      const ivec2 strides = ivec2(${h}, ${d});\n      const ivec2 pads = ivec2(${c}, ${u});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${v}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${x}\n        ${A}\n        setOutput(result);\n      }\n    `}}const k6={kernelName:eR,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:a,pad:l,dilations:c,dimRoundingMode:u}=r;let h=c;null==h&&(h=[1,1]),i.assert(d.eitherStridesOrDilationsAreOne(a,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${h}'`);const p=d.computeConv2DInfo(s.shape,o.shape,a,h,l,u,!0);let f;return f=hk().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels==1?new M6(p):new T6(p),n.runWebGLProgram(f,[s,o],"float32")}};class R6{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class N6{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,i=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${i}; dm++) {\n              int d2 = d1 * ${i} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const L6={kernelName:nR,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,dy:s}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=i,h=d.computeConv2DInfo(r.shape,u,o,a,l,c,!0),p=new R6(h);return n.runWebGLProgram(p,[r,s],"float32")}},D6={kernelName:iR,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,filter:s}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=i,h=d.computeConv2DInfo(u,s.shape,o,a,l,c,!0),p=new N6(h);return n.runWebGLProgram(p,[r,s],"float32")}};class B6{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const O6={kernelName:rR,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e,s=[...r.shape,...r.shape],o=i.sizeFromShape(r.shape),a=w4({inputs:{x:r},backend:n,attrs:{shape:[o]}}),l=new B6(o),c=n.runWebGLProgram(l,[a],a.dtype),u=w4({inputs:{x:c},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(c),u}};class P6{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:n,padInfo:i,strideHeight:r,strideWidth:s,filterHeight:o,filterWidth:a,dilationHeight:l,dilationWidth:c}=t,{top:u,left:h}=i;this.userCode=`\n      const ivec2 strides = ivec2(${r}, ${s});\n      const ivec2 pads = ivec2(${u}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${o}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${a}; w++) {\n              int wIn = wBeg + w * ${c};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const F6={kernelName:sR,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,filter:s}=e,{strides:o,pad:a,dilations:l}=i,c=d.computeDilation2DInfo(r.shape,s.shape,o,a,"NHWC",l);let u;const h=new P6(c);u=n.runWebGLProgram(h,[r,s],"float32");const p=w4({inputs:{x:u},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(u),p}},$6={kernelName:cR,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{equation:s}=r,o=e,{allDims:a,summedDims:l,idDims:c}=d.decodeEinsumEquation(s,o.length);d.checkEinsumDimSizes(a.length,c,o);const{path:u,steps:h}=d.getEinsumComputePath(l,c),p=h.length;let f=null,m=a.length;const g=[];for(let y=0;y<p;++y){for(const t of h[y]){const{permutationIndices:e,expandDims:r}=d.getEinsumPermutation(m,c[t]);let s;d.isIdentityPermutation(e)?s=o[t]:(s=N4({inputs:{x:o[t]},backend:n,attrs:{perm:e}}),g.push(s));const a=s.shape.slice();for(let t=0;t<r.length;++t)a.splice(r[t],0,1);i.arraysEqual(s.shape,a)||(s=w4({inputs:{x:s},backend:n,attrs:{shape:a}}),g.push(s)),null===f?f=s:(f=A4({inputs:{a:s,b:f},backend:n}),g.push(f))}y<p-1&&(u[y]>=0&&(f=k4({inputs:{x:f},backend:n,attrs:{axis:u[y]-(a.length-m),keepDims:!1}}),g.push(f)),m--)}for(const i of g)i!==f&&n.disposeIntermediateTensorInfo(i);return f}},z6=f4({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),U6={kernelName:uR,backendName:"webgl",kernelFunc:z6},H6={kernelName:hR,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n}=t,{dy:i,y:r}=e,s=hk().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new i4("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",i.shape,r.shape):new n4("return (b >= 1.0) ? a : a * (b + 1.0);",i.shape,r.shape);return n.runWebGLProgram(s,[i,r],i.dtype)}},V6=m4({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:r3}),G6={kernelName:pR,backendName:"webgl",kernelFunc:V6},W6=f4({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${d.ERF_P};\n  float a1 = ${d.ERF_A1};\n  float a2 = ${d.ERF_A2};\n  float a3 = ${d.ERF_A3};\n  float a4 = ${d.ERF_A4};\n  float a5 = ${d.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),j6={kernelName:dR,backendName:"webgl",kernelFunc:W6},Q6="return exp(x);",q6=f4({opSnippet:Q6,packedOpSnippet:Q6,cpuKernelImpl:s3}),X6={kernelName:fR,backendName:"webgl",kernelFunc:q6};function Y6(t){const{inputs:e,attrs:n,backend:r}=t,{dim:s}=n,{input:o}=e,a=o.shape.length,l=o.shape.slice();let c=s;return s<0&&(i.assert(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),c=a+s+1),l.splice(c,0,1),w4({inputs:{x:o},backend:r,attrs:{shape:l}})}const K6={kernelName:mR,backendName:"webgl",kernelFunc:Y6},J6="return exp(x) - 1.0;",Z6=f4({opSnippet:J6,packedOpSnippet:J6,cpuKernelImpl:o3}),t8={kernelName:gR,backendName:"webgl",kernelFunc:Z6};class e8{constructor(t,e,n){this.variableNames=["real","imag"];const i=e[1];this.outputShape=e;const r=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${i}.0`:"1.0";let o;if("real"===t)o="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);o="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${r};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${o}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${i});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${i}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${s};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function n8(t,e,n){const r=n.texData.get(t.dataId),s=i.sizeFromShape(t.shape),o=t.shape[t.shape.length-1],a=w4({inputs:{x:t},backend:n,attrs:{shape:[s/o,o]}}),l=a.shape,c=new e8("real",l,e),u=new e8("imag",l,e),h=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],d=n.runWebGLProgram(c,h,"float32"),p=n.runWebGLProgram(u,h,"float32"),f=o4({inputs:{real:d,imag:p},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p);const m=w4({inputs:{x:f},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(f),m}const i8={kernelName:yR,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:i}=e;return n8(i,!1,n)}};class r8{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function s8(t){const{backend:e,attrs:n}=t,{shape:r,value:s}=n;let{dtype:o}=n;if(o=o||i.inferDtype(s),"string"===o){const t=i.getArrayFromDType(o,i.sizeFromShape(r));return t.fill(s),e.makeTensorInfo(r,o,t)}{const t=new r8(r,s);return e.runWebGLProgram(t,[],o,[[s]])}}const o8={kernelName:vR,backendName:"webgl",kernelFunc:s8};class a8{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const l8={kernelName:bR,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,i=e,r=new a8(n.shape);return i.runWebGLProgram(r,[n],n.dtype)}},c8="return floor(x);",u8=f4({opSnippet:c8,packedOpSnippet:c8,cpuKernelImpl:a3}),h8={kernelName:AR,backendName:"webgl",kernelFunc:u8},d8=m4({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),p8={kernelName:xR,backendName:"webgl",kernelFunc:d8};class f8{constructor(t){this.variableNames=["A"];const e=b2(),[n,i]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}.0, ${n}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class m8{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=b2(),[n,i]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${i}.0, ${n}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const g8={kernelName:dL,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t;let{pixels:r}=e;const{numChannels:s}=i,o="undefined"!=typeof HTMLVideoElement&&r instanceof HTMLVideoElement,a="undefined"!=typeof HTMLImageElement&&r instanceof HTMLImageElement,[l,c]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],u=[c,l],h=[c,l,s];(a||o)&&(null==y8&&(y8=document.createElement("canvas").getContext("2d")),y8.canvas.width=l,y8.canvas.height=c,y8.drawImage(r,0,0,l,c),r=y8.canvas);const d=n.makeTensorInfo(u,"int32");n.texData.get(d.dataId).usage=W1.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),r);const p=hk().getBool("WEBGL_PACK")?new m8(h):new f8(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let y8;const v8={kernelName:mL,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,bias:a,preluActivationWeights:l}=e,{strides:c,pad:u,dataFormat:h,dilations:p,dimRoundingMode:f,activation:m,leakyreluAlpha:g}=r,y=d.convertConv2DDataFormat(h),v=d.computeConv2DInfo(s.shape,o.shape,c,p,u,f,!1,y);let b;const A=[];if(1!==v.filterHeight||1!==v.filterWidth||1!==v.dilationHeight||1!==v.dilationWidth||1!==v.strideHeight||1!==v.strideWidth||"SAME"!==v.padInfo.type&&"VALID"!==v.padInfo.type)if(hk().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])b=r6({x:s,filter:o,convInfo:v,backend:n,bias:a,activation:m,preluActivationWeights:l,leakyreluAlpha:g});else{const t=null!=a,e=null!=l,r="leakyrelu"===m,c=m?g4(m,!1):null,u=new t6(v,t,c,e,r),h=[s,o];if(a&&h.push(a),l&&h.push(l),r){const t=n.makeTensorInfo([],"float32",i.createScalarValue(g,"float32"));h.push(t),A.push(t)}b=n.runWebGLProgram(u,h,"float32")}else b=i6({x:s,filter:o,convInfo:v,backend:n,bias:a,activation:m,preluActivationWeights:l,leakyreluAlpha:g});const x=w4({inputs:{x:b},backend:n,attrs:{shape:v.outShape}});return A.push(b),A.forEach(t=>n.disposeIntermediateTensorInfo(t)),x}},b8={kernelName:gL,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,bias:a,preluActivationWeights:l}=e,{strides:c,pad:u,dilations:h,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=r,g=[];let y=h;null==y&&(y=[1,1]),i.assert(d.eitherStridesOrDilationsAreOne(c,y),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${c} and dilations '${y}'`);const v=d.computeConv2DInfo(s.shape,o.shape,c,y,u,p,!0),b=hk().getBool("WEBGL_PACK_DEPTHWISECONV")&&v.strideWidth<=2&&v.outChannels/v.inChannels==1,A=f?g4(f,b):null,x=[s,o],w=null!=a,_=null!=l,S="leakyrelu"===f;if(w&&x.push(a),_&&x.push(l),S){const t=n.makeTensorInfo([],"float32",i.createScalarValue(m,"float32"));x.push(t),g.push(t)}let E;E=b?new M6(v,w,A,_,S):new T6(v,w,A,_,S);const C=n.runWebGLProgram(E,x,"float32");return g.forEach(t=>n.disposeIntermediateTensorInfo(t)),C}};class A8{constructor(t,e,n){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=n;const i=Q2(e.length),r=Q2(n.length);this.userCode=`\n        ${i} strides = ${i}(${this.strides});\n         void main() {\n          ${r} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${this.sliceDim>1?"strides[j]":"strides"};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}const x8={kernelName:SR,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{params:r,indices:s}=e,o=s.shape,a=o[o.length-1],l=i.sizeFromShape(r.shape),[c,u,h,p]=d.prepareAndValidate(r,s),f=w4({inputs:{x:s},backend:n,attrs:{shape:[u,a]}}),m=w4({inputs:{x:r},backend:n,attrs:{shape:[i.sizeFromShape(r.shape)/h,h]}});if(n.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const t=n.readSync(s.dataId),e=n.bufferSync(r),i=l3(t,e,r.dtype,u,a,h,p,r.shape,l);return n.makeTensorInfo(c,r.dtype,i.values)}const g=new A8(a,p,[u,h]),y=n.runWebGLProgram(g,[m,f],m.dtype),v=w4({inputs:{x:y},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),v}};class w8{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const n=Q2(this.rank),i=function(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[];for(let r=0;r<t.length;r++)i.push(2===r?"int(getIndices(resRC.x, resRC.z))":`${n[r]}`);return i.join()}(t);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        setOutput(getA(${i}));\n      }\n    `}}function _8(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,indices:o}=e,{axis:a,batchDims:l}=r,c=i.parseAxisParam(a,s.shape)[0],u=d.segment_util.collectGatherOpShapeInfo(s,o,c,l),h=i.sizeFromShape(o.shape),p=[],f=w4({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),m=w4({inputs:{x:o},backend:n,attrs:{shape:[u.batchSize,h/u.batchSize]}});p.push(f),p.push(m);const g=[u.batchSize,u.outerSize,h/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,o])||"string"===s.dtype){const t=n.bufferSync(m),e=n.bufferSync(f),i=c3(e,t,g);return p.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.makeTensorInfo(u.outputShape,i.dtype,i.values)}const y=new w8(f.shape,g),v=n.runWebGLProgram(y,[f,m],f.dtype);p.push(v);const b=w4({inputs:{x:v},backend:n,attrs:{shape:u.outputShape}});return p.forEach(t=>n.disposeIntermediateTensorInfo(t)),b}const S8={kernelName:_R,backendName:"webgl",kernelFunc:_8},E8=m4({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:u3,dtype:"bool"}),C8={kernelName:ER,backendName:"webgl",kernelFunc:E8},I8=m4({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:h3}),T8={kernelName:CR,backendName:"webgl",kernelFunc:I8},M8={kernelName:TR,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:i}=e;return n8(i,!0,n)}},k8=f4({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),R8={kernelName:kR,backendName:"webgl",kernelFunc:k8},N8=f4({opSnippet:"return float(isinf(x));",dtype:"bool"}),L8={kernelName:RR,backendName:"webgl",kernelFunc:N8},D8=f4({opSnippet:"return float(isnan(x));",dtype:"bool"}),B8={kernelName:NR,backendName:"webgl",kernelFunc:D8},O8=m4({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:d3,dtype:"bool"}),P8={kernelName:DR,backendName:"webgl",kernelFunc:O8},F8=m4({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:p3,dtype:"bool"}),$8={kernelName:BR,backendName:"webgl",kernelFunc:F8},z8={kernelName:OR,backendName:"webgl",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:i,stop:r,num:s}=n,o=f3(i,r,s);return e.makeTensorInfo([o.length],"float32",o)}},U8=f4({opSnippet:"if (x < 0.0) return NAN;\n  return log(x);",packedOpSnippet:"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:m3}),H8={kernelName:PR,backendName:"webgl",kernelFunc:U8},V8=f4({opSnippet:"return log(1.0 + x);"}),G8={kernelName:FR,backendName:"webgl",kernelFunc:V8},W8=m4({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),j8={kernelName:$R,backendName:"webgl",kernelFunc:W8},Q8=f4({opSnippet:"return float(!(x >= 1.0));"}),q8={kernelName:zR,backendName:"webgl",kernelFunc:Q8},X8=m4({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),Y8={kernelName:UR,backendName:"webgl",kernelFunc:X8};class K8{constructor(t,e,n,i,r){this.variableNames=["x"],this.outputShape=[];const s=e,o=t[3]-1;let a;this.outputShape=t;const l=`float(${n}) + float(${i}) * sum`;a=.5===r?`inversesqrt(${l})`:1===r?`1.0/(${l})`:`exp(log(${l}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${o}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${a};\n        setOutput(val);\n      }\n    `}}class J8{constructor(t,e,n,i,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const s=e,o=t[3]-1;let a;this.outputShape=t;const l=`float(${n}) + float(${i}) * sum`;a=.5===r?`inversesqrt(${l})`:1===r?`1.0/(${l})`:`exp(log(${l}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${a};\n        setOutput(result);\n      }\n    `}}const Z8={kernelName:HR,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{depthRadius:s,bias:o,alpha:a,beta:l}=i,c=hk().getBool("WEBGL_PACK_NORMALIZATION")?new J8(r.shape,s,o,a,l):new K8(r.shape,s,o,a,l);return n.runWebGLProgram(c,[r],r.dtype)}};class t7{constructor(t,e,n,i,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=i,this.beta=r,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${i}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${i})\n                * float(${r})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${r});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const e7={kernelName:VR,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:i}=t,{x:r,y:s,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=i,h=new t7(r.shape,a,l,c,u);return n.runWebGLProgram(h,[r,s,o],r.dtype)}};function n7(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reductionIndices:o,keepDims:a}=r,l=s.shape.length,c=i.parseAxisParam(o,s.shape);let u=c;const h=d.getAxesPermutation(u,l),p=null!=h,f=n.shouldExecuteOnCPU([s]);let m=s;if(p){if(f){const t=n.texData.get(m.dataId).values,e=new Array(l);for(let n=0;n<e.length;n++)e[n]=s.shape[h[n]];const i=P3(t,s.shape,s.dtype,h,e);m=n.makeTensorInfo(e,s.dtype),n.texData.get(m.dataId).values=i}else m=M4(s,h,n);u=d.getInnerMostAxes(u.length,l)}d.assertAxesAreInnerMostDims("max",u,l);const[g,y]=d.computeOutAndReduceShapes(m.shape,u);let v,b=g;if(a&&(b=d.expandShapeToKeepDim(g,c)),f){const t=n.texData.get(m.dataId),e=g3(t.values,i.sizeFromShape(y),b,s.dtype);v=n.makeTensorInfo(b,s.dtype),n.texData.get(v.dataId).values=e}else v=function(t,e,n,r){const s=i.sizeFromShape(e),o=w4({inputs:{x:t},attrs:{shape:[i.sizeFromShape(t.shape)/s,s]},backend:r}),a=C4(o,t.dtype,"max",r),l=w4({inputs:{x:a},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(a),l}(m,y,b,n);return p&&n.disposeIntermediateTensorInfo(m),v}const i7={kernelName:GR,backendName:"webgl",kernelFunc:n7},r7=m4({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:y3}),s7={kernelName:WR,backendName:"webgl",kernelFunc:r7},o7={kernelName:jR,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;y2(s,"maxPool");const{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=r;i.assert(d.eitherStridesOrDilationsAreOne(a,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`);const u=d.computePool2DInfo(s.shape,o,a,1,l,c);if(1===u.filterWidth&&1===u.filterHeight&&i.arraysEqual(u.inShape,u.outShape))return r4({inputs:{x:s},backend:n});const h=new p5(u,"max",!1);return n.runWebGLProgram(h,[s],s.dtype)}},a7={kernelName:qR,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{filterSize:s,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=i,u=d.computePool3DInfo(r.shape,s,o,[1,1,1],a,c,l),h=new f5(u,"max",!1);return n.runWebGLProgram(h,[r],r.dtype)}};class l7{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.effectiveFilterHeight,n=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${e*n-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${n} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class c7{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.effectiveFilterDepth,n=t.effectiveFilterHeight,i=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${i-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${e};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${i};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${e*n*i-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${n} * ${i} +\n                  wR * ${i} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const u7={kernelName:XR,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,input:s}=e,o=s,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=i,h=d.computePool3DInfo(o.shape,a,l,[1,1,1],c,u),p=new f5(h,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new c7(h),g=n.runWebGLProgram(m,[r,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}},h7={kernelName:QR,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,input:s,output:o}=e,a=s;y2([s,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=i,p=d.computePool2DInfo(a.shape,l,c,1,u,h),f=new p5(p,"max",!0),m=n.runWebGLProgram(f,[a],a.dtype),g=new l7(p),y=n.runWebGLProgram(g,[r,m],a.dtype);return n.disposeIntermediateTensorInfo(m),y}},d7={kernelName:YR,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:s,strides:o,pad:a,includeBatchInIndex:l}=e,c=n;i.assert(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const u=[1,1];i.assert(d.eitherStridesOrDilationsAreOne(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const h=d.computePool2DInfo(r.shape,s,o,u,a),[p,f]=function(t,e,n,i){let r=new p5(n,"max",!1);const s=i.runWebGLProgram(r,[t],"float32");return r=new p5(n,"max",!0,!0,e),[s,i.runWebGLProgram(r,[t],"float32")]}(r,l,h,c);return[p,f]}},p7={kernelName:KR,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{keepDims:s,axis:o}=e,a=n,l=r.shape.length,c=i.parseAxisParam(o,r.shape);let u=c;const h=d.getAxesPermutation(u,l),p=null!=h,f=a.shouldExecuteOnCPU([r]),m=[];let g=r;if(p){if(f){const t=a.texData.get(g.dataId).values,e=new Array(l);for(let i=0;i<e.length;i++)e[i]=r.shape[h[i]];const n=P3(t,r.shape,r.dtype,h,e);g=a.makeTensorInfo(e,r.dtype),a.texData.get(g.dataId).values=n}else g=M4(r,h,a);m.push(g),u=d.getInnerMostAxes(u.length,l)}d.assertAxesAreInnerMostDims("sum",u,l);const[y,v]=d.computeOutAndReduceShapes(g.shape,u);let b=y;s&&(b=d.expandShapeToKeepDim(y,c));const A=function(t,e,n,r){const s=i.sizeFromShape(e),o=w4({inputs:{x:t},attrs:{shape:[i.sizeFromShape(t.shape)/s,s]},backend:r}),a=C4(o,"float32","mean",r),l=w4({inputs:{x:a},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(a),l}(g,v,b,a);for(const i of m)a.disposeIntermediateTensorInfo(i);return A}},f7={kernelName:JR,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:a}=r,l=s.shape.length,c=i.parseAxisParam(o,s.shape);let u=c;const h=d.getAxesPermutation(u,l);let p=s;null!=h&&(p=N4({inputs:{x:s},backend:n,attrs:{perm:h}}),u=d.getInnerMostAxes(u.length,s.shape.length)),d.assertAxesAreInnerMostDims("min",u,l);const[f,m]=d.computeOutAndReduceShapes(p.shape,u),g=w4({inputs:{x:p},backend:n,attrs:{shape:[-1,i.sizeFromShape(m)]}}),y=C4(g,g.dtype,"min",n);let v;return v=w4(a?{inputs:{x:y},backend:n,attrs:{shape:d.expandShapeToKeepDim(f,c)}}:{inputs:{x:y},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),null!=h&&n.disposeIntermediateTensorInfo(p),v}},m7=m4({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:v3}),g7={kernelName:ZR,backendName:"webgl",kernelFunc:m7};class y7{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const i=t.length,r=Q2(i),s=e.map(t=>t[0]).join(","),o=e.map((e,n)=>e[0]+t[n]).join(","),a=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i),l="reflect"===n?0:1;this.userCode=1!==i?`\n      ${r} start = ${r}(${s});\n      ${r} end = ${r}(${o});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        for (int i = 0; i < ${i}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${r} coords = outC - start;\n        setOutput(getX(${a}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class v7{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const i=t.length,r=Q2(i),s=e.map(t=>t[0]).join(","),o=e.map((e,n)=>e[0]+t[n]).join(","),a=z3("rc",i),l=z3("source",i),c=`${a[i-1]} < ${this.outputShape[i-1]}`,u=1===i?"source":`vec2(${l.slice(-2).join()})`,h="reflect"===n?0:1;let d="";if(1===i){const t=`\n        ${r} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;d=`\n        ${r} rc = outputLoc;\n        ${t}\n        result[0] = getChannel(getX(${l.join()}), ${u});\n        ${a[i-1]} += 1;\n        if(${c}) {\n          ${t}\n          result[1] = getChannel(getX(${l.join()}), ${u});\n        }\n      `}else{const t=`\n        ${r} source = rc;\n        ${r} lt = ${r}(lessThan(source, start));\n        ${r} gte = ${r}(greaterThanEqual(source, end));\n        ${r} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;d=`\n        ${r} rc = outputLoc;\n        ${t}\n        result[0] = getChannel(getX(${l.join()}), ${u});\n        ${a[i-1]} += 1;\n        if(${c}) {\n          ${t}\n          result[1] = getChannel(getX(${l.join()}), ${u});\n        }\n        rc = outputLoc;\n        ${a[i-2]} += 1;\n        if(${a[i-2]} < ${this.outputShape[i-2]}) {\n          ${t}\n          result[2] = getChannel(getX(${l.join()}), ${u});\n          ${a[i-1]} += 1;\n          if(${c}) {\n            ${t}\n            result[3] = getChannel(getX(${l.join()}), ${u});\n          }\n        }\n      `}this.userCode=`\n      const ${r} start = ${r}(${s});\n      const ${r} end = ${r}(${o});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}const b7={kernelName:tN,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:i}=t,{paddings:r,mode:s}=n,o=hk().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new v7(i.shape,r,s):new y7(i.shape,r,s);return e.runWebGLProgram(o,[i],i.dtype)}},A7=m4({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),x7={kernelName:eN,backendName:"webgl",kernelFunc:A7};class w7{constructor(t,e,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}const _7=m4({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),S7={kernelName:lR,backendName:"webgl",kernelFunc:_7},E7="return a - b;",C7=m4({opSnippet:E7,packedOpSnippet:E7,supportsComplex:!0,cpuKernelImpl:D3}),I7={kernelName:tL,backendName:"webgl",kernelFunc:C7};function T7(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{dim:o}=r,a=i.parseAxisParam([o],s.shape),l=n7({inputs:{x:s},backend:n,attrs:{reductionIndices:a,keepDims:!1}}),c=d.expandShapeToKeepDim(l.shape,a),u=w4({inputs:{x:l},backend:n,attrs:{shape:c}}),h=C7({inputs:{a:s,b:u},backend:n}),p=q6({inputs:{x:h},backend:n}),f=k4({inputs:{x:p},backend:n,attrs:{axis:a,keepDims:!1}}),m=w4({inputs:{x:f},backend:n,attrs:{shape:c}}),g=_7({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const M7={kernelName:HN,backendName:"webgl",kernelFunc:T7},k7={kernelName:nN,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{logits:r}=e,{numSamples:s,seed:o,normalized:a}=i,l=a?r:T7({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),c=new w7(l.shape[0],l.shape[1],s),u=n.runWebGLProgram(c,[l],"int32",[[o]]);return a||n.disposeIntermediateTensorInfo(l),u}},R7="return -x;",N7={kernelName:rN,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:i}=e;if(n.shouldExecuteOnCPU([i])){const t=n.texData.get(i.dataId),[e,r]=A3(t.values,i.shape,i.dtype);return n.makeTensorInfo(r,i.dtype,e)}let r;return r=hk().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Y3(i.shape,R7):new Q3(i.shape,R7),n.runWebGLProgram(r,[i],i.dtype)}},L7=p.nonMaxSuppressionV3Impl,D7={kernelName:oN,backendName:"webgl",kernelFunc:function(t){d.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:i}=t,{boxes:r,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=i,c=n.readSync(r.dataId),u=n.readSync(s.dataId),{selectedIndices:h}=L7(c,u,o,a,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},B7=p.nonMaxSuppressionV4Impl,O7={kernelName:aN,backendName:"webgl",kernelFunc:function(t){d.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:i}=t,{boxes:r,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=i,u=n.readSync(r.dataId),h=n.readSync(s.dataId),{selectedIndices:p,validOutputs:f}=B7(u,h,o,a,l,c);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([f]))]}},P7=p.nonMaxSuppressionV5Impl,F7={kernelName:lN,backendName:"webgl",kernelFunc:function(t){d.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:i}=t,{boxes:r,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=i,u=n.readSync(r.dataId),h=n.readSync(s.dataId),p=o,f=a,m=l,g=c,{selectedIndices:y,selectedScores:v}=P7(u,h,p,f,m,g);return[n.makeTensorInfo([y.length],"int32",new Int32Array(y)),n.makeTensorInfo([v.length],"float32",new Float32Array(v))]}};class $7{constructor(t,e,n,i){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${i}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const z7={kernelName:uN,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{indices:s}=e,{depth:o,onValue:a,offValue:l}=r,c=i.sizeFromShape(s.shape),u=new $7(c,o,a,l),h=w4({inputs:{x:s},backend:n,attrs:{shape:[c]}}),d=n.runWebGLProgram(u,[h],s.dtype);n.disposeIntermediateTensorInfo(h);const p=w4({inputs:{x:d},backend:n,attrs:{shape:[...s.shape,o]}});return n.disposeIntermediateTensorInfo(d),p}};function U7(t){const{inputs:e,backend:n}=t,{x:i}=e;if("complex64"===i.dtype){const t=D5({inputs:{input:i},backend:n}),e=U7({inputs:{x:t},backend:n}),r=X5({inputs:{input:i},backend:n}),s=U7({inputs:{x:r},backend:n}),o=o4({inputs:{real:e,imag:s},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),o}return s8({attrs:{shape:i.shape,dtype:i.dtype,value:"string"===i.dtype?"":0},backend:n})}const H7={kernelName:uL,backendName:"webgl",kernelFunc:U7},V7={kernelName:cN,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:i}=e,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const e=D5({inputs:{input:r},backend:i}),n=t({inputs:{x:e},backend:i}),s=X5({inputs:{input:r},backend:i}),o=U7({inputs:{x:s},backend:i}),a=o4({inputs:{real:n,imag:o},backend:i});return i.disposeIntermediateTensorInfo(e),i.disposeIntermediateTensorInfo(n),i.disposeIntermediateTensorInfo(s),i.disposeIntermediateTensorInfo(o),a}return s8({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:i})}},G7={kernelName:hN,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r;if(1===e.length)return Y6({inputs:{input:e[0]},backend:n,attrs:{dim:s}});const o=e[0].shape,a=e[0].dtype;e.forEach(t=>{i.assertShapesMatch(o,t.shape,"All tensors passed to stack must have matching shapes"),i.assert(a===t.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],c=J5({inputs:e.map(t=>{const e=Y6({inputs:{input:t},backend:n,attrs:{dim:s}});return l.push(e),e}),backend:n,attrs:{axis:s}});return l.forEach(t=>n.disposeIntermediateTensorInfo(t)),c}};class W7{constructor(t,e,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const i=t.length,r=Q2(i),s=e.map(t=>t[0]).join(","),o=e.map((e,n)=>e[0]+t[n]).join(","),a=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i);this.userCode=1!==i?`\n      ${r} start = ${r}(${s});\n      ${r} end = ${r}(${o});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${r} coords = outC - start;\n          setOutput(getX(${a}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class j7{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const i=t.length,r=Q2(i),s=e.map(t=>t[0]).join(","),o=e.map((e,n)=>e[0]+t[n]).join(","),a=z3("rc",i),l=z3("source",i),c=`${a[i-1]} < ${this.outputShape[i-1]}`,u=1===i?"source":`vec2(${l.slice(-2).join()})`,h=[`${r} rc = outputLoc;`,`${a[i-1]} += 1;\n       if(${c}) {\n      `,1===i?"":`}\n       rc = outputLoc;\n       ${a[i-2]} += 1;\n       if(${a[i-2]} < ${this.outputShape[i-2]}) {`,1===i?"":`  ${a[i-1]} += 1;\n         if(${c}) {`],d=1===i?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===i?2:4;f<m;f++)p+=`\n        ${h[f]}\n        if (${d}) {\n          result[${f}] = float(value);\n        } else {\n          ${r} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${u});\n        }\n      `;p+=1===i?"} ":"}}",this.userCode=`\n      const ${r} start = ${r}(${s});\n      const ${r} end = ${r}(${o});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const Q7=t=>{const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{paddings:s,constantValue:o}=i,a=hk().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new j7(r.shape,s,o):new W7(r.shape,s,o);return n.runWebGLProgram(a,[r],r.dtype,[[o]])},q7={kernelName:dN,backendName:"webgl",kernelFunc:Q7},X7=m4({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),Y7={kernelName:pN,backendName:"webgl",kernelFunc:X7},K7={kernelName:mN,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:a}=r,l=s.shape.length,c=[],u=i.parseAxisParam(o,s.shape);let h=u;const p=d.getAxesPermutation(h,l);let f,m=s;if(null!=p&&(m=N4({inputs:{x:s},backend:n,attrs:{perm:p}}),h=d.getInnerMostAxes(h.length,l),c.push(m)),d.assertAxesAreInnerMostDims("prod",h,l),n.shouldExecuteOnCPU([m])){const t=n.texData.get(m.dataId).values,{outVals:e,outShape:i,outDtype:r}=w3(m.shape,m.dtype,t,h);f=n.makeTensorInfo(i,r,e)}else{const[t,e]=d.computeOutAndReduceShapes(m.shape,h),r=i.sizeFromShape(e),o=w4({inputs:{x:m},backend:n,attrs:{shape:[-1,r]}}),a=C4(o,pD(s.dtype),"prod",n);f=w4({inputs:{x:a},backend:n,attrs:{shape:t}}),c.push(o),c.push(a)}if(a){c.push(f);const t=d.expandShapeToKeepDim(f.shape,u);f=w4({inputs:{x:f},backend:n,attrs:{shape:t}})}return c.forEach(t=>n.disposeIntermediateTensorInfo(t)),f}},J7=t=>{const{backend:e,attrs:n}=t,{start:i,stop:r,step:s,dtype:o}=n,a=_3(i,r,s,o);return e.makeTensorInfo([a.length],o,a)},Z7={kernelName:gN,backendName:"webgl",kernelFunc:J7},t9=f4({opSnippet:"return 1.0 / x;"}),e9={kernelName:vN,backendName:"webgl",kernelFunc:t9},n9=f4({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),i9={kernelName:bN,backendName:"webgl",kernelFunc:n9},r9=f4({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),s9={kernelName:EN,backendName:"webgl",kernelFunc:r9};class o9{constructor(t,e,n,i,r){this.variableNames=["A"],this.outputShape=[];const[s,o,a,l]=t;this.outputShape=[s,e,n,l];const c=[i&&e>1?o-1:o,i&&n>1?a-1:a],u=[i&&e>1?e-1:e,i&&n>1?n-1:n];let h;h=r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/u[0]},\n          ${c[1]/u[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${a}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class a9{constructor(t,e,n,i,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,a,l]=t;this.outputShape=[s,e,n,l];const c=[i&&e>1?o-1:o,i&&n>1?a-1:a],u=[i&&e>1?e-1:e,i&&n>1?n-1:n];let h;h=r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/u[0]},\n          ${c[1]/u[1]},\n          ${c[1]/u[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${a}.0,\n                                     ${a}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const l9={kernelName:_N,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{images:r}=e,{alignCorners:s,halfPixelCenters:o,size:a}=i,[l,c]=a,u=hk().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new a9(r.shape,l,c,s,o):new o9(r.shape,l,c,s,o);return n.runWebGLProgram(u,[r],"float32")}};class c9{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,i,r]=e,[,s,o]=t,a=[n&&s>1?i-1:i,n&&o>1?r-1:r],l=[n&&s>1?s-1:s,n&&o>1?o-1:o],c=a[0]/l[0],u=a[1]/l[1],h=1/c,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${u});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${i-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const u9={kernelName:SN,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{images:r,dy:s}=e,{alignCorners:o}=i,a=new c9(s.shape,r.shape,o);return n.runWebGLProgram(a,[s],s.dtype)}};class h9{constructor(t,e,n,i,r){this.variableNames=["A"],this.outputShape=[];const[s,o,a,l]=t;this.outputShape=[s,e,n,l];const c=[i&&e>1?o-1:o,i&&n>1?a-1:a],u=[i&&e>1?e-1:e,i&&n>1?n-1:n];let h;h=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/u[0]},\n          ${c[1]/u[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${a}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${i?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class d9{constructor(t,e,n,i,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,a,l]=t;this.outputShape=[s,e,n,l];const c=[i&&e>1?o-1:o,i&&n>1?a-1:a],u=[i&&e>1?e-1:e,i&&n>1?n-1:n];let h;h=r?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/u[0]},\n          ${c[1]/u[1]},\n          ${c[1]/u[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${a}.0,\n                                     ${a}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${i?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const p9={kernelName:xN,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{images:r}=e,{alignCorners:s,halfPixelCenters:o,size:a}=i,[l,c]=a,u=hk().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new d9(r.shape,l,c,s,o):new h9(r.shape,l,c,s,o);return n.runWebGLProgram(u,[r],r.dtype)}};class f9{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,i,r]=e,[,s,o]=t,a=[n&&s>1?i-1:i,n&&o>1?r-1:r],l=[n&&s>1?s-1:s,n&&o>1?o-1:o],c=a[0]/l[0],u=a[1]/l[1],h=1/c,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${u});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${a[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${a[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${i}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const m9={kernelName:wN,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{images:r,dy:s}=e,{alignCorners:o}=i,a=new f9(s.shape,r.shape,o);return n.runWebGLProgram(a,[s],s.dtype)}};class g9{constructor(t,e){this.variableNames=["x"];const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const i=t.map((n,i)=>(n=>-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - coords[${n}] - 1`:`coords[${n}]`)(i)).join(","),r=Q2(n);this.userCode=`\n      void main() {\n        ${r} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}class y9{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;const i=z3("rc",n),r=`${i[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${i[n-2]} + 1 < ${this.outputShape[n-2]}`,o=Q2(n);function a(n){const i=t.map((i,r)=>function(n,i){return-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - ${i[n]} - 1`:`${i[n]}`}(r,n));return`getChannel(getX(${i.join(",")}), vec2(${i.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${r}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${o} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(t){return a(t)}(i.slice())};\n          if(${r}){\n            result.g = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",a(t)}(i.slice())};\n          }\n          if(${s}) {\n            result.b = ${function(t){return t[n-2]="("+t[n-2]+" + 1)",a(t)}(i.slice())};\n            if(${r}) {\n              result.a = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",t[n-2]="("+t[n-2]+" + 1)",a(t)}(i.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const v9={kernelName:CN,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dims:o}=r,a=s.shape.length,l=i.parseAxisParam(o,s.shape);if(0===a)return r4({inputs:{x:s},backend:n});const c=hk().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new y9(s.shape,l):new g9(s.shape,l);return n.runWebGLProgram(c,[s],s.dtype)}};class b9{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=t[1],i=t[2];this.outputShape=t;let r="";r="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${r}\n          if(coordX >= 0 && coordX < ${i} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const A9={kernelName:pL,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:i}=t,{radians:r,fillValue:s,center:o}=e,a=n,l=new b9(i.shape,s),[c,u]=d.getImageCenter(o,i.shape[1],i.shape[2]),h=[[c,u,Math.sin(r),Math.cos(r)]];return a.runWebGLProgram(l,[i],i.dtype,h)}},x9=f4({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),w9={kernelName:IN,backendName:"webgl",kernelFunc:x9},_9=f4({opSnippet:"return inversesqrt(x);",cpuKernelImpl:S3}),S9={kernelName:TN,backendName:"webgl",kernelFunc:_9};class E9{constructor(t,e,n,i,r,s,o=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const a=Q2(r.length),l=Q2(s.length);let c="";1===n?c="i":2===n&&(c="i, j");let u="";1===i?u="i":2===i&&(u="i, coords[1]"),this.userCode=`\n        ${a} strides = ${a}(${r});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${c}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${u});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const C9={kernelName:MN,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{indices:r,updates:s}=e,{shape:o}=i,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=d.calculateShapes(s,r,o),p=[h/c,c];if(0===h)return n.makeTensorInfo(o,r.dtype);const f=w4({inputs:{x:r},backend:n,attrs:{shape:[l,a]}}),m=w4({inputs:{x:s},backend:n,attrs:{shape:[l,c]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0])),y=new E9(l,a,f.shape.length,m.shape.length,u,p),v=n.runWebGLProgram(y,[m,f,g],m.dtype),b=w4({inputs:{x:v},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(g),b}};class I9{constructor(t,e,n){let i,r;if(this.variableNames=["c","a","b"],this.outputShape=e,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)r="resRC",i="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],o=[];for(let i=0;i<e.length;i++)o.push(`${n[i]}`),i<t&&s.push(`${n[i]}`);i=s.join(),r=o.join()}const s=Q2(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${i});\n        if (cVal >= 1.0) {\n          setOutput(getA(${r}));\n        } else {\n          setOutput(getB(${r}));\n        }\n      }\n    `}}const T9={kernelName:kN,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:i,t:r,e:s}=e,o=new I9(i.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(o,[i,r,s],dD(r.dtype,s.dtype))}},M9=f4({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${d.SELU_SCALEALPHA};\n  float scale = ${d.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),k9={kernelName:RN,backendName:"webgl",kernelFunc:M9},R9=f4({opSnippet:"return 1.0 / (1.0 + exp(-1.0 * x));"}),N9={kernelName:ON,backendName:"webgl",kernelFunc:R9},L9=f4({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),D9={kernelName:BN,backendName:"webgl",kernelFunc:L9},B9=f4({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),O9={kernelName:LN,backendName:"webgl",kernelFunc:B9},P9=f4({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),F9={kernelName:DN,backendName:"webgl",kernelFunc:P9},$9=f4({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),z9={kernelName:PN,backendName:"webgl",kernelFunc:$9},U9={kernelName:zN,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:o,paddings:a}=r;i.assert(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const l=o.reduce((t,e)=>t*e),c=[[0,0]];c.push(...a);for(let i=1+o.length;i<s.shape.length;++i)c.push([0,0]);const u=[],h=Q7({inputs:{x:s},backend:n,attrs:{paddings:c,constantValue:0}}),p=d.getReshaped(h.shape,o,l,!1),f=d.getPermuted(p.length,o.length,!1),m=d.getReshapedPermuted(h.shape,o,l,!1),g=w4({inputs:{x:h},backend:n,attrs:{shape:p}}),y=N4({inputs:{x:g},backend:n,attrs:{perm:f}}),v=w4({inputs:{x:y},backend:n,attrs:{shape:m}});return u.push(h),u.push(g),u.push(y),u.forEach(t=>n.disposeIntermediateTensorInfo(t)),v}},H9={kernelName:VN,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{indices:i,values:r,denseShape:s,defaultValue:o}=e;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(2!==i.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${i.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n         ${r.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=n.readSync(i.dataId),l=n.readSync(r.dataId),c=n.readSync(s.dataId),u=n.readSync(o.dataId)[0],[h,d,p,f,m]=I3(a,i.shape,i.dtype,l,r.dtype,c,u);return[n.makeTensorInfo(d,i.dtype,h),n.makeTensorInfo([d[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(t=>Number(t)))),n.makeTensorInfo([m.length],i.dtype,new Int32Array(m))]}},V9={kernelName:GN,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{inputIndices:i,inputShape:r,newShape:s}=e;if(2!==i.shape.length)throw new Error(`Input indices should be a matrix but received shape ${i.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(n.readSync(r.dataId)),a=n.readSync(i.dataId),l=Array.from(n.readSync(s.dataId)),[c,u,h]=T3(a,i.shape,i.dtype,o,l);return[n.makeTensorInfo(u,i.dtype,c),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}},G9={kernelName:WN,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:i,indices:r,segmentIds:s}=e;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${r.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);const o=n.readSync(i.dataId),a=n.readSync(r.dataId),l=n.readSync(s.dataId),[c,u]=M3(o,i.shape,i.dtype,a,l,!0);return n.makeTensorInfo(u,i.dtype,c)}},W9={kernelName:jN,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:i,indices:r,segmentIds:s}=e;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${r.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);const o=n.readSync(i.dataId),a=n.readSync(r.dataId),l=n.readSync(s.dataId),[c,u]=M3(o,i.shape,i.dtype,a,l);return n.makeTensorInfo(u,i.dtype,c)}},j9={kernelName:QN,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{sparseIndices:r,sparseValues:s,defaultValue:o}=e,{outputShape:a}=i,{sliceRank:l,numUpdates:c,strides:u,outputSize:h}=d.calculateShapes(s,r,a),p=new E9(c,l,r.shape.length,s.shape.length,u,[h,1],!1),f=n.runWebGLProgram(p,[s,r,o],s.dtype),m=w4({inputs:{x:f},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(f),m}},Q9={kernelName:UN,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{numOrSizeSplits:o,axis:a}=r,l=i.parseAxisParam(a,s.shape)[0],c=d.prepareSplitSize(s,o,l),u=new Array(s.shape.length).fill(0),h=s.shape.slice();return c.map(t=>{const e=[...h];e[l]=t;const i=T5({inputs:{x:s},backend:n,attrs:{begin:u,size:e}});return u[l]+=t,i})}},q9=f4({opSnippet:"return sqrt(x);"}),X9={kernelName:FN,backendName:"webgl",kernelFunc:q9},Y9={kernelName:XN,backendName:"webgl",kernelFunc:f4({opSnippet:"return x * x;"})},K9="return (a - b) * (a - b);",J9=m4({opSnippet:K9,packedOpSnippet:K9}),Z9={kernelName:qN,backendName:"webgl",kernelFunc:J9},ttt={kernelName:hL,backendName:"webgl",kernelFunc:function({inputs:t,attrs:e,backend:n}){const{x:i}=t,r=new Q3(i.shape,`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${e.alpha});\n  `);return n.runWebGLProgram(r,[i],i.dtype)}};class ett{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;const i=n.length,r=Q2(n.length),s=Q2(n.length);let o="";if(1===i)o="coords * strides + begin";else{let t=0;o=n.map((e,i)=>(t++,1===n.length?`coords * strides[${i}] + begin[${i}]`:`coords[${t-1}] * strides[${i}] + begin[${i}]`)).join(",")}this.userCode=`\n      ${r} begin = ${r}(${t});\n      ${r} strides = ${r}(${e});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}const ntt={kernelName:YN,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{begin:s,end:o,strides:a,beginMask:c,endMask:u,ellipsisMask:h,newAxisMask:d,shrinkAxisMask:p}=i,{nonStrided:f,$begin:m,$strides:g,size:y,newShape:v,outShape:b}=l.sliceInfo(r.shape,s,o,a,c,u,h,d,p),A=w4({inputs:{x:r},backend:n,attrs:{shape:v}});let x;if(f){const t=T5({inputs:{x:A},backend:n,attrs:{begin:m,size:y}});x=w4({inputs:{x:t},backend:n,attrs:{shape:b}}),n.disposeIntermediateTensorInfo(t)}else if(b.some(t=>0===t))x=n.makeTensorInfo(b,r.dtype,[]);else if(n.shouldExecuteOnCPU([A])){const t=n.texData.get(A.dataId),e=RB(A.shape,A.dtype,t.values),i=k3(b,e,g,m);x=n.makeTensorInfo(b,A.dtype,i.values)}else{const t=new ett(m,g,b);x=n.runWebGLProgram(t,[A],A.dtype)}const w=w4({inputs:{x:x},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(A),n.disposeIntermediateTensorInfo(x),w}},itt={kernelName:KN,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{separator:r,nGramWidths:s,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=i,{data:u,dataSplits:h}=e,d=n.readSync(u.dataId),p=n.readSync(h.dataId),[f,m]=R3(d,p,r,s,o,a,l,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}},rtt={kernelName:JN,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{skipEmpty:r}=i,{input:s,delimiter:o}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=n.readSync(s.dataId),l=n.readSync(o.dataId)[0],[c,u,h]=N3(a,l,r),d=u.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}},stt={kernelName:ZN,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{numBuckets:r}=i,{input:s}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=n.readSync(s.dataId),a=L3(o,r);return n.makeTensorInfo(s.shape,"int32",a)}},ott=f4({opSnippet:"return tan(x);"}),att={kernelName:eL,backendName:"webgl",kernelFunc:ott},ltt=f4({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),ctt={kernelName:nL,backendName:"webgl",kernelFunc:ltt};class utt{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let s=0;s<n.length;s++)n[s]=t[s]*e[s];this.outputShape=n,this.rank=n.length;const i=Q2(this.rank),r=function(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],i=[];for(let r=0;r<t.length;r++)i.push(`imod(${n[r]}, ${t[r]})`);return i.join()}(t);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `}}function htt(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reps:o}=r;if("string"===s.dtype||s.shape.length>5){const t=n.readSync(s.dataId),e="string"===s.dtype?t.map(t=>i.decodeString(t)):t,r=RB(s.shape,s.dtype,e),a=B3(r,o);return n.makeTensorInfo(a.shape,a.dtype,a.values)}const a=new utt(s.shape,o);return n.runWebGLProgram(a,[s],s.dtype)}const dtt={kernelName:iL,backendName:"webgl",kernelFunc:htt};class ptt{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class ftt{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function mtt(t,e){null!==e&&t.disposeIntermediateTensorInfo(e)}function gtt(t){let e=1;for(;e<t;)e*=2;return e}const ytt={kernelName:rL,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{k:o,sorted:a}=r,l=hk().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=hk().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,h=u[u.length-1];if(n.shouldExecuteOnCPU([s])||h<l||o>c){const t=n.readSync(s.dataId),[e,i]=O3(t,u,s.dtype,o,a);return[n.makeTensorInfo(e.shape,e.dtype,e.values),n.makeTensorInfo(i.shape,i.dtype,i.values)]}if(0===o)return u[u.length-1]=0,[n.makeTensorInfo(u,s.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===h)return[s,s8({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const d=n.texData.get(s.dataId),p=null!==d&&d.isPacked,f=p?n.unpackTensor(s):s,m=i.sizeFromShape(u)/h,g=w4({inputs:{x:f},attrs:{shape:[m,h]},backend:n});p&&mtt(n,f);const y=gtt(o),v=gtt(h);let b=null;const A=()=>null===b?[g,g]:[g,b],x=(t,e,i)=>{const r=A(),s=new ptt(i),o=b;b=n.runWebGLProgram(s,r,"int32",[[h],[null===b?1:0],[Number.NEGATIVE_INFINITY],[t],[e]]),mtt(n,o)};for(let i=1;i<y;i*=2){const t=2*i;for(let e=i;e>=1;e/=2)x(t,e,[m,v])}for(let i=v;i>y;i/=2){const t=A(),e=new ftt([m,i/2]),r=b;b=n.runWebGLProgram(e,t,"int32",[[h],[null===b?1:0],[y]]),mtt(n,r);const s=y/2,o=2*s;for(let n=s;n>=1;n/=2)x(o,n,b.shape)}let w=b;b=T5({inputs:{x:b},backend:n,attrs:{begin:0,size:[m,o]}}),mtt(n,w);let _=_8({inputs:{x:g,indices:b},backend:n,attrs:{axis:1,batchDims:1}});mtt(n,g);const S=u.slice(0,-1);S.push(o),w=b,b=w4({inputs:{x:b},attrs:{shape:S},backend:n}),mtt(n,w);const E=_;return _=w4({inputs:{x:_},attrs:{shape:S},backend:n}),mtt(n,E),[_,b]}};class vtt{constructor(t,e,n,i,r,s){this.variableNames=["Image","Transforms"],this.outputShape=s;const o="nearest"===n?1:2;let a;switch(i){case"constant":a=1;break;case"reflect":a=2;break;case"wrap":a=3;break;case"nearest":a=4;break;default:a=1}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${a} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${a} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${a} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${r});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${r});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${o} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const btt={kernelName:sL,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{image:r,transforms:s}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=i,[u,h,d,p]=r.shape,[f,m]=null!=c?c:[h,d],g=new vtt(h,d,o,a,l,[u,f,m,p]);return n.runWebGLProgram(g,[r,s],"float32")}},Att={kernelName:aL,backendName:"webgl",kernelFunc:function(t){const{inputs:e,attrs:n,backend:i}=t,{axis:r}=n,{x:s}=e;y2(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=i.readSync(s.dataId),{outputValues:a,outputShape:l,indices:c}=F3(o,r,s.shape,s.dtype);return[i.makeTensorInfo(l,s.dtype,a),i.makeTensorInfo([c.length],"int32",c)]}},xtt={kernelName:lL,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{value:r}=e;let{axis:s}=i;s<0&&(s+=r.shape.length);const o=r,a=o.shape.length,l=r.shape[s],c=new Array(a-1);let u=0;for(let m=0;m<a;m++)m!==s&&(c[u++]=o.shape[m]);const h=[],d=new Array(a).fill(0),p=o.shape.slice();p[s]=1;const f=new Array(l);for(let m=0;m<f.length;m++){d[s]=m;const t=T5({inputs:{x:o},backend:n,attrs:{begin:d,size:p}}),e=w4({inputs:{x:t},backend:n,attrs:{shape:c}});f[m]=e,h.push(t)}return h.forEach(t=>n.disposeIntermediateTensorInfo(t)),f}};class wtt{constructor(t,e){this.variableNames=["x","segmentIds"];const n=t.windowSize,i=t.batchSize,r=t.inSize,s=t.numSegments,o=s*Math.ceil(r/n);this.outputShape=[i,o];const a=4*Math.floor(n/4),l=n%4,c="\n        sumValue += dot(values, segFilter);\n    ";let u="";r%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `);let h="";r%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${c}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${c}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `}}const _tt=[Z8,e7,B4,P4,$4,U4,G4,Q4,q4,X4,e5,n5,r5,o5,u5,l5,d5,g5,m5,b5,A5,x5,S5,k5,R5,O5,$5,H5,W5,a4,Z5,u6,h6,s6,p6,f6,d6,g6,v6,A6,S6,E6,I6,L6,D6,k6,O6,F6,$6,U6,H6,G6,j6,X6,K6,t8,i8,o8,l8,h8,p8,g8,v8,b8,x8,S8,C8,T8,s4,M8,Y5,R8,L8,B8,u4,P8,$8,z8,G8,H8,j8,q8,Y8,i7,a7,o7,u7,h7,d7,s7,p7,f7,g7,b7,x7,k7,x4,N7,D7,O7,F7,L5,z7,V7,G7,q7,Y7,p4,K7,Z7,B5,S7,e9,s9,i9,_4,l9,u9,p9,m9,v9,A9,w9,S9,C9,T9,k9,N9,D9,O9,F9,M5,M7,z9,U9,H9,V9,G9,W9,j9,Q9,X9,Y9,Z9,ttt,ntt,itt,rtt,stt,I7,R4,att,ctt,dtt,ytt,btt,L4,Att,xtt,{kernelName:cL,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,segmentIds:o}=e,{numSegments:a}=r,l=s.shape.length,c=[];let u=0;const h=d.getAxesPermutation([u],l);let p=s;null!=h&&(p=N4({inputs:{x:s},backend:n,attrs:{perm:h}}),c.push(p),u=d.getInnerMostAxes(1,l)[0]);const f=d.segment_util.computeOutShape(p.shape,u,a),m=i.sizeFromShape([p.shape[u]]),g=w4({inputs:{x:p},backend:n,attrs:{shape:[-1,m]}});c.push(g);const y=pD(s.dtype),v=(t,e,i,r,s)=>{const o=t.shape[0],a=t.shape[1],l=d.segment_util.segOpComputeOptimalWindowSize(a,s),u=new wtt({windowSize:l,inSize:a,batchSize:o,numSegments:s},e),h=n.compileAndRun(u,[t,i],r);if(c.push(h),h.shape[1]===s)return h;const p=J7({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),f=htt({inputs:{x:p},backend:n,attrs:{reps:[a/l]}});return c.push(p),c.push(f),v(h,e,f,r,s)},b=w4({inputs:{x:v(g,"unsortedSegmentSum",o,y,a)},backend:n,attrs:{shape:f}});let A=b;if(null!=h){c.push(b);const t=d.getUndoAxesPermutation(h);A=N4({inputs:{x:A},backend:n,attrs:{perm:t}})}return c.forEach(t=>n.disposeIntermediateTensorInfo(t)),A}},H7];for(const Set of _tt)wL(Set);const Stt=100,Ett=1e3,Ctt=1001,Itt=1002,Ttt=1003,Mtt=1006,ktt=1008,Rtt=1012,Ntt=1014,Ltt=1015,Dtt=1016,Btt=1020,Ott=1022,Ptt=1023,Ftt=1026,$tt=1027,ztt=2300,Utt=2301,Htt=2302,Vtt=2400,Gtt=2401,Wtt=2402,jtt=3e3,Qtt=7680,qtt=35044,Xtt=35048,Ytt="300 es";function Ktt(){}Object.assign(Ktt.prototype,{addEventListener:function(t,e){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[t]&&(n[t]=[]),-1===n[t].indexOf(e)&&n[t].push(e)},hasEventListener:function(t,e){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[t]&&-1!==n[t].indexOf(e)},removeEventListener:function(t,e){if(void 0===this._listeners)return;const n=this._listeners[t];if(void 0!==n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}},dispatchEvent:function(t){if(void 0===this._listeners)return;const e=this._listeners[t.type];if(void 0!==e){t.target=this;const n=e.slice(0);for(let e=0,i=n.length;e<i;e++)n[e].call(this,t)}}});const Jtt=[];for(let Set=0;Set<256;Set++)Jtt[Set]=(Set<16?"0":"")+Set.toString(16);let Ztt=1234567;const tet={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,n=4294967295*Math.random()|0,i=4294967295*Math.random()|0;return(Jtt[255&t]+Jtt[t>>8&255]+Jtt[t>>16&255]+Jtt[t>>24&255]+"-"+Jtt[255&e]+Jtt[e>>8&255]+"-"+Jtt[e>>16&15|64]+Jtt[e>>24&255]+"-"+Jtt[63&n|128]+Jtt[n>>8&255]+"-"+Jtt[n>>16&255]+Jtt[n>>24&255]+Jtt[255&i]+Jtt[i>>8&255]+Jtt[i>>16&255]+Jtt[i>>24&255]).toUpperCase()},clamp:function(t,e,n){return Math.max(e,Math.min(n,t))},euclideanModulo:function(t,e){return(t%e+e)%e},mapLinear:function(t,e,n,i,r){return i+(t-e)*(r-i)/(n-e)},lerp:function(t,e,n){return(1-n)*t+n*e},damp:function(t,e,n,i){return tet.lerp(t,e,1-Math.exp(-n*i))},pingpong:function(t,e=1){return e-Math.abs(tet.euclideanModulo(t,2*e)-e)},smoothstep:function(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*(3-2*t)},smootherstep:function(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*t*(t*(6*t-15)+10)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},seededRandom:function(t){return void 0!==t&&(Ztt=t%2147483647),Ztt=16807*Ztt%2147483647,(Ztt-1)/2147483646},degToRad:function(t){return t*tet.DEG2RAD},radToDeg:function(t){return t*tet.RAD2DEG},isPowerOfTwo:function(t){return 0==(t&t-1)&&0!==t},ceilPowerOfTwo:function(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))},floorPowerOfTwo:function(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))},setQuaternionFromProperEuler:function(t,e,n,i,r){const s=Math.cos,o=Math.sin,a=s(n/2),l=o(n/2),c=s((e+i)/2),u=o((e+i)/2),h=s((e-i)/2),d=o((e-i)/2),p=s((i-e)/2),f=o((i-e)/2);switch(r){case"XYX":t.set(a*u,l*h,l*d,a*c);break;case"YZY":t.set(l*d,a*u,l*h,a*c);break;case"ZXZ":t.set(l*h,l*d,a*u,a*c);break;case"XZX":t.set(a*u,l*f,l*p,a*c);break;case"YXY":t.set(l*p,a*u,l*f,a*c);break;case"ZYZ":t.set(l*f,l*p,a*u,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}}};class eet{constructor(t=0,e=0){Object.defineProperty(this,"isVector2",{value:!0}),this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6],this.y=i[1]*e+i[4]*n+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),i=Math.sin(e),r=this.x-t.x,s=this.y-t.y;return this.x=r*n-s*i+t.x,this.y=r*i+s*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}class net{constructor(){Object.defineProperty(this,"isMatrix3",{value:!0}),this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,r,s,o,a,l){const c=this.elements;return c[0]=t,c[1]=i,c[2]=o,c[3]=e,c[4]=r,c[5]=a,c[6]=n,c[7]=s,c[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}clone(){return(new this.constructor).fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,s=n[0],o=n[3],a=n[6],l=n[1],c=n[4],u=n[7],h=n[2],d=n[5],p=n[8],f=i[0],m=i[3],g=i[6],y=i[1],v=i[4],b=i[7],A=i[2],x=i[5],w=i[8];return r[0]=s*f+o*y+a*A,r[3]=s*m+o*v+a*x,r[6]=s*g+o*b+a*w,r[1]=l*f+c*y+u*A,r[4]=l*m+c*v+u*x,r[7]=l*g+c*b+u*w,r[2]=h*f+d*y+p*A,r[5]=h*m+d*v+p*x,r[8]=h*g+d*b+p*w,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],o=t[5],a=t[6],l=t[7],c=t[8];return e*s*c-e*o*l-n*r*c+n*o*a+i*r*l-i*s*a}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],o=t[5],a=t[6],l=t[7],c=t[8],u=c*s-o*l,h=o*a-c*r,d=l*r-s*a,p=e*u+n*h+i*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const f=1/p;return t[0]=u*f,t[1]=(i*l-c*n)*f,t[2]=(o*n-i*s)*f,t[3]=h*f,t[4]=(c*e-i*a)*f,t[5]=(i*r-o*e)*f,t[6]=d*f,t[7]=(n*a-l*e)*f,t[8]=(s*e-n*r)*f,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).copy(this).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,i,r,s,o){const a=Math.cos(r),l=Math.sin(r);return this.set(n*a,n*l,-n*(a*s+l*o)+s+t,-i*l,i*a,-i*(-l*s+a*o)+o+e,0,0,1),this}scale(t,e){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=e,n[4]*=e,n[7]*=e,this}rotate(t){const e=Math.cos(t),n=Math.sin(t),i=this.elements,r=i[0],s=i[3],o=i[6],a=i[1],l=i[4],c=i[7];return i[0]=e*r+n*a,i[3]=e*s+n*l,i[6]=e*o+n*c,i[1]=-n*r+e*a,i[4]=-n*s+e*l,i[7]=-n*o+e*c,this}translate(t,e){const n=this.elements;return n[0]+=t*n[2],n[3]+=t*n[5],n[6]+=t*n[8],n[1]+=e*n[2],n[4]+=e*n[5],n[7]+=e*n[8],this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<9;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}}let iet;const ret={getDataURL:function(t){if(/^data:/i.test(t.src))return t.src;if("undefined"==typeof HTMLCanvasElement)return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{void 0===iet&&(iet=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),iet.width=t.width,iet.height=t.height;const n=iet.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=iet}return e.width>2048||e.height>2048?e.toDataURL("image/jpeg",.6):e.toDataURL("image/png")}};let set=0;function oet(t=oet.DEFAULT_IMAGE,e=oet.DEFAULT_MAPPING,n=1001,i=1001,r=1006,s=1008,o=1023,a=1009,l=1,c=3e3){Object.defineProperty(this,"id",{value:set++}),this.uuid=tet.generateUUID(),this.name="",this.image=t,this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=i,this.magFilter=r,this.minFilter=s,this.anisotropy=l,this.format=o,this.internalFormat=null,this.type=a,this.offset=new eet(0,0),this.repeat=new eet(1,1),this.center=new eet(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new net,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.version=0,this.onUpdate=null}function aet(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?ret.getDataURL(t):t.data?{data:Array.prototype.slice.call(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}oet.DEFAULT_IMAGE=void 0,oet.DEFAULT_MAPPING=300,oet.prototype=Object.assign(Object.create(Ktt.prototype),{constructor:oet,isTexture:!0,updateMatrix:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)},clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.name=t.name,this.image=t.image,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this},toJSON:function(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(void 0!==this.image){const i=this.image;if(void 0===i.uuid&&(i.uuid=tet.generateUUID()),!e&&void 0===t.images[i.uuid]){let e;if(Array.isArray(i)){e=[];for(let t=0,n=i.length;t<n;t++)e.push(aet(i[t].isDataTexture?i[t].image:i[t]))}else e=aet(i);t.images[i.uuid]={uuid:i.uuid,url:e}}n.image=i.uuid}return e||(t.textures[this.uuid]=n),n},dispose:function(){this.dispatchEvent({type:"dispose"})},transformUv:function(t){if(300!==this.mapping)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case Ett:t.x=t.x-Math.floor(t.x);break;case Ctt:t.x=t.x<0?0:1;break;case Itt:t.x=1===Math.abs(Math.floor(t.x)%2)?Math.ceil(t.x)-t.x:t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case Ett:t.y=t.y-Math.floor(t.y);break;case Ctt:t.y=t.y<0?0:1;break;case Itt:t.y=1===Math.abs(Math.floor(t.y)%2)?Math.ceil(t.y)-t.y:t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}}),Object.defineProperty(oet.prototype,"needsUpdate",{set:function(t){!0===t&&this.version++}});class cet{constructor(t=0,e=0,n=0,i=1){Object.defineProperty(this,"isVector4",{value:!0}),this.x=t,this.y=e,this.z=n,this.w=i}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,i){return this.x=t,this.y=e,this.z=n,this.w=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=this.w,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*i+s[12]*r,this.y=s[1]*e+s[5]*n+s[9]*i+s[13]*r,this.z=s[2]*e+s[6]*n+s[10]*i+s[14]*r,this.w=s[3]*e+s[7]*n+s[11]*i+s[15]*r,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,i,r;const s=.01,o=.1,a=t.elements,l=a[0],c=a[4],u=a[8],h=a[1],d=a[5],p=a[9],f=a[2],m=a[6],g=a[10];if(Math.abs(c-h)<s&&Math.abs(u-f)<s&&Math.abs(p-m)<s){if(Math.abs(c+h)<o&&Math.abs(u+f)<o&&Math.abs(p+m)<o&&Math.abs(l+d+g-3)<o)return this.set(1,0,0,0),this;e=Math.PI;const t=(l+1)/2,a=(d+1)/2,y=(g+1)/2,v=(c+h)/4,b=(u+f)/4,A=(p+m)/4;return t>a&&t>y?t<s?(n=0,i=.707106781,r=.707106781):(n=Math.sqrt(t),i=v/n,r=b/n):a>y?a<s?(n=.707106781,i=0,r=.707106781):(i=Math.sqrt(a),n=v/i,r=A/i):y<s?(n=.707106781,i=.707106781,r=0):(r=Math.sqrt(y),n=b/r,i=A/r),this.set(n,i,r,e),this}let y=Math.sqrt((m-p)*(m-p)+(u-f)*(u-f)+(h-c)*(h-c));return Math.abs(y)<.001&&(y=1),this.x=(m-p)/y,this.y=(u-f)/y,this.z=(h-c)/y,this.w=Math.acos((l+d+g-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}class uet extends Ktt{constructor(t,e,n){super(),Object.defineProperty(this,"isWebGLRenderTarget",{value:!0}),this.width=t,this.height=e,this.scissor=new cet(0,0,t,e),this.scissorTest=!1,this.viewport=new cet(0,0,t,e),this.texture=new oet(void 0,(n=n||{}).mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.image={},this.texture.image.width=t,this.texture.image.height=e,this.texture.generateMipmaps=void 0!==n.generateMipmaps&&n.generateMipmaps,this.texture.minFilter=void 0!==n.minFilter?n.minFilter:Mtt,this.depthBuffer=void 0===n.depthBuffer||n.depthBuffer,this.stencilBuffer=void 0!==n.stencilBuffer&&n.stencilBuffer,this.depthTexture=void 0!==n.depthTexture?n.depthTexture:null}setSize(t,e){this.width===t&&this.height===e||(this.width=t,this.height=e,this.texture.image.width=t,this.texture.image.height=e,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return(new this.constructor).copy(this)}copy(t){return this.width=t.width,this.height=t.height,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}class het{constructor(t=0,e=0,n=0,i=1){Object.defineProperty(this,"isQuaternion",{value:!0}),this._x=t,this._y=e,this._z=n,this._w=i}static slerp(t,e,n,i){return n.copy(t).slerp(e,i)}static slerpFlat(t,e,n,i,r,s,o){let a=n[i+0],l=n[i+1],c=n[i+2],u=n[i+3];const h=r[s+0],d=r[s+1],p=r[s+2],f=r[s+3];if(u!==f||a!==h||l!==d||c!==p){let t=1-o;const e=a*h+l*d+c*p+u*f,n=e>=0?1:-1,i=1-e*e;if(i>Number.EPSILON){const r=Math.sqrt(i),s=Math.atan2(r,e*n);t=Math.sin(t*s)/r,o=Math.sin(o*s)/r}const r=o*n;if(a=a*t+h*r,l=l*t+d*r,c=c*t+p*r,u=u*t+f*r,t===1-o){const t=1/Math.sqrt(a*a+l*l+c*c+u*u);a*=t,l*=t,c*=t,u*=t}}t[e]=a,t[e+1]=l,t[e+2]=c,t[e+3]=u}static multiplyQuaternionsFlat(t,e,n,i,r,s){const o=n[i],a=n[i+1],l=n[i+2],c=n[i+3],u=r[s],h=r[s+1],d=r[s+2],p=r[s+3];return t[e]=o*p+c*u+a*d-l*h,t[e+1]=a*p+c*h+l*u-o*d,t[e+2]=l*p+c*d+o*h-a*u,t[e+3]=c*p-o*u-a*h-l*d,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!t||!t.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=t._x,i=t._y,r=t._z,s=t._order,o=Math.cos,a=Math.sin,l=o(n/2),c=o(i/2),u=o(r/2),h=a(n/2),d=a(i/2),p=a(r/2);switch(s){case"XYZ":this._x=h*c*u+l*d*p,this._y=l*d*u-h*c*p,this._z=l*c*p+h*d*u,this._w=l*c*u-h*d*p;break;case"YXZ":this._x=h*c*u+l*d*p,this._y=l*d*u-h*c*p,this._z=l*c*p-h*d*u,this._w=l*c*u+h*d*p;break;case"ZXY":this._x=h*c*u-l*d*p,this._y=l*d*u+h*c*p,this._z=l*c*p+h*d*u,this._w=l*c*u-h*d*p;break;case"ZYX":this._x=h*c*u-l*d*p,this._y=l*d*u+h*c*p,this._z=l*c*p-h*d*u,this._w=l*c*u+h*d*p;break;case"YZX":this._x=h*c*u+l*d*p,this._y=l*d*u+h*c*p,this._z=l*c*p-h*d*u,this._w=l*c*u-h*d*p;break;case"XZY":this._x=h*c*u-l*d*p,this._y=l*d*u-h*c*p,this._z=l*c*p+h*d*u,this._w=l*c*u+h*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return!1!==e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,i=Math.sin(n);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],i=e[4],r=e[8],s=e[1],o=e[5],a=e[9],l=e[2],c=e[6],u=e[10],h=n+o+u;if(h>0){const t=.5/Math.sqrt(h+1);this._w=.25/t,this._x=(c-a)*t,this._y=(r-l)*t,this._z=(s-i)*t}else if(n>o&&n>u){const t=2*Math.sqrt(1+n-o-u);this._w=(c-a)/t,this._x=.25*t,this._y=(i+s)/t,this._z=(r+l)/t}else if(o>u){const t=2*Math.sqrt(1+o-n-u);this._w=(r-l)/t,this._x=(i+s)/t,this._y=.25*t,this._z=(a+c)/t}else{const t=2*Math.sqrt(1+u-n-o);this._w=(s-i)/t,this._x=(r+l)/t,this._y=(a+c)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<1e-6?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(tet.clamp(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(0===n)return this;const i=Math.min(1,e/n);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return void 0!==e?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,i=t._y,r=t._z,s=t._w,o=e._x,a=e._y,l=e._z,c=e._w;return this._x=n*c+s*o+i*l-r*a,this._y=i*c+s*a+r*o-n*l,this._z=r*c+s*l+n*a-i*o,this._w=s*c-n*o-i*a-r*l,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);const n=this._x,i=this._y,r=this._z,s=this._w;let o=s*t._w+n*t._x+i*t._y+r*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=s,this._x=n,this._y=i,this._z=r,this;const a=1-o*o;if(a<=Number.EPSILON){const t=1-e;return this._w=t*s+e*this._w,this._x=t*n+e*this._x,this._y=t*i+e*this._y,this._z=t*r+e*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(a),c=Math.atan2(l,o),u=Math.sin((1-e)*c)/l,h=Math.sin(e*c)/l;return this._w=s*u+this._w*h,this._x=n*u+this._x*h,this._y=i*u+this._y*h,this._z=r*u+this._z*h,this._onChangeCallback(),this}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}class det{constructor(t=0,e=0,n=0){Object.defineProperty(this,"isVector3",{value:!0}),this.x=t,this.y=e,this.z=n}set(t,e,n){return void 0===n&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(fet.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(fet.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6]*i,this.y=r[1]*e+r[4]*n+r[7]*i,this.z=r[2]*e+r[5]*n+r[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=t.elements,s=1/(r[3]*e+r[7]*n+r[11]*i+r[15]);return this.x=(r[0]*e+r[4]*n+r[8]*i+r[12])*s,this.y=(r[1]*e+r[5]*n+r[9]*i+r[13])*s,this.z=(r[2]*e+r[6]*n+r[10]*i+r[14])*s,this}applyQuaternion(t){const e=this.x,n=this.y,i=this.z,r=t.x,s=t.y,o=t.z,a=t.w,l=a*e+s*i-o*n,c=a*n+o*e-r*i,u=a*i+r*n-s*e,h=-r*e-s*n-o*i;return this.x=l*a+h*-r+c*-o-u*-s,this.y=c*a+h*-s+u*-r-l*-o,this.z=u*a+h*-o+l*-s-c*-r,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[4]*n+r[8]*i,this.y=r[1]*e+r[5]*n+r[9]*i,this.z=r[2]*e+r[6]*n+r[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t,e){return void 0!==e?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,i=t.y,r=t.z,s=e.x,o=e.y,a=e.z;return this.x=i*a-r*o,this.y=r*s-n*a,this.z=n*o-i*s,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return pet.copy(this).projectOnVector(t),this.sub(pet)}reflect(t){return this.sub(pet.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(tet.clamp(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return e*e+n*n+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const i=Math.sin(e)*t;return this.x=i*Math.sin(n),this.y=Math.cos(e)*t,this.z=i*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}const pet=new det,fet=new het;class met{constructor(t,e){Object.defineProperty(this,"isBox3",{value:!0}),this.min=void 0!==t?t:new det(1/0,1/0,1/0),this.max=void 0!==e?e:new det(-1/0,-1/0,-1/0)}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,n=1/0,i=1/0,r=-1/0,s=-1/0,o=-1/0;for(let a=0,l=t.length;a<l;a+=3){const l=t[a],c=t[a+1],u=t[a+2];l<e&&(e=l),c<n&&(n=c),u<i&&(i=u),l>r&&(r=l),c>s&&(s=c),u>o&&(o=u)}return this.min.set(e,n,i),this.max.set(r,s,o),this}setFromBufferAttribute(t){let e=1/0,n=1/0,i=1/0,r=-1/0,s=-1/0,o=-1/0;for(let a=0,l=t.count;a<l;a++){const l=t.getX(a),c=t.getY(a),u=t.getZ(a);l<e&&(e=l),c<n&&(n=c),u<i&&(i=u),l>r&&(r=l),c>s&&(s=c),u>o&&(o=u)}return this.min.set(e,n,i),this.max.set(r,s,o),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=vet.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t){return this.makeEmpty(),this.expandByObject(t)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return void 0===t&&(console.warn("THREE.Box3: .getCenter() target is now required"),t=new det),this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return void 0===t&&(console.warn("THREE.Box3: .getSize() target is now required"),t=new det),this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){t.updateWorldMatrix(!1,!1);const e=t.geometry;void 0!==e&&(null===e.boundingBox&&e.computeBoundingBox(),bet.copy(e.boundingBox),bet.applyMatrix4(t.matrixWorld),this.union(bet));const n=t.children;for(let i=0,r=n.length;i<r;i++)this.expandByObject(n[i]);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return void 0===e&&(console.warn("THREE.Box3: .getParameter() target is now required"),e=new det),e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,vet),vet.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Iet),Tet.subVectors(this.max,Iet),Aet.subVectors(t.a,Iet),xet.subVectors(t.b,Iet),wet.subVectors(t.c,Iet),_et.subVectors(xet,Aet),Eet.subVectors(wet,xet),Cet.subVectors(Aet,wet);let e=[0,-_et.z,_et.y,0,-Eet.z,Eet.y,0,-Cet.z,Cet.y,_et.z,0,-_et.x,Eet.z,0,-Eet.x,Cet.z,0,-Cet.x,-_et.y,_et.x,0,-Eet.y,Eet.x,0,-Cet.y,Cet.x,0];return!!get(e,Aet,xet,wet,Tet)&&(e=[1,0,0,0,1,0,0,0,1],!!get(e,Aet,xet,wet,Tet)&&(Met.crossVectors(_et,Eet),e=[Met.x,Met.y,Met.z],get(e,Aet,xet,wet,Tet)))}clampPoint(t,e){return void 0===e&&(console.warn("THREE.Box3: .clampPoint() target is now required"),e=new det),e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return vet.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return void 0===t&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(t.center),t.radius=.5*this.getSize(vet).length(),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(yet[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),yet[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),yet[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),yet[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),yet[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),yet[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),yet[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),yet[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(yet)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}function get(t,e,n,i,r){for(let s=0,o=t.length-3;s<=o;s+=3){ket.fromArray(t,s);const o=r.x*Math.abs(ket.x)+r.y*Math.abs(ket.y)+r.z*Math.abs(ket.z),a=e.dot(ket),l=n.dot(ket),c=i.dot(ket);if(Math.max(-Math.max(a,l,c),Math.min(a,l,c))>o)return!1}return!0}const yet=[new det,new det,new det,new det,new det,new det,new det,new det],vet=new det,bet=new met,Aet=new det,xet=new det,wet=new det,_et=new det,Eet=new det,Cet=new det,Iet=new det,Tet=new det,Met=new det,ket=new det,Ret=new met;class Net{constructor(t,e){this.center=void 0!==t?t:new det,this.radius=void 0!==e?e:-1}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;void 0!==e?n.copy(e):Ret.setFromPoints(t).getCenter(n);let i=0;for(let r=0,s=t.length;r<s;r++)i=Math.max(i,n.distanceToSquared(t[r]));return this.radius=Math.sqrt(i),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return void 0===e&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),e=new det),e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return void 0===t&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),t=new met),this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}}const Let=new det,Det=new det,Bet=new det,Oet=new det,Pet=new det,Fet=new det,$et=new det;class zet{constructor(t,e){this.origin=void 0!==t?t:new det,this.direction=void 0!==e?e:new det(0,0,-1)}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return void 0===e&&(console.warn("THREE.Ray: .at() target is now required"),e=new det),e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,Let)),this}closestPointToPoint(t,e){void 0===e&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),e=new det),e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=Let.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(Let.copy(this.direction).multiplyScalar(e).add(this.origin),Let.distanceToSquared(t))}distanceSqToSegment(t,e,n,i){Det.copy(t).add(e).multiplyScalar(.5),Bet.copy(e).sub(t).normalize(),Oet.copy(this.origin).sub(Det);const r=.5*t.distanceTo(e),s=-this.direction.dot(Bet),o=Oet.dot(this.direction),a=-Oet.dot(Bet),l=Oet.lengthSq(),c=Math.abs(1-s*s);let u,h,d,p;if(c>0)if(u=s*a-o,h=s*o-a,p=r*c,u>=0)if(h>=-p)if(h<=p){const t=1/c;u*=t,h*=t,d=u*(u+s*h+2*o)+h*(s*u+h+2*a)+l}else h=r,u=Math.max(0,-(s*h+o)),d=-u*u+h*(h+2*a)+l;else h=-r,u=Math.max(0,-(s*h+o)),d=-u*u+h*(h+2*a)+l;else h<=-p?(u=Math.max(0,-(-s*r+o)),h=u>0?-r:Math.min(Math.max(-r,-a),r),d=-u*u+h*(h+2*a)+l):h<=p?(u=0,h=Math.min(Math.max(-r,-a),r),d=h*(h+2*a)+l):(u=Math.max(0,-(s*r+o)),h=u>0?r:Math.min(Math.max(-r,-a),r),d=-u*u+h*(h+2*a)+l);else h=s>0?-r:r,u=Math.max(0,-(s*h+o)),d=-u*u+h*(h+2*a)+l;return n&&n.copy(this.direction).multiplyScalar(u).add(this.origin),i&&i.copy(Bet).multiplyScalar(h).add(Det),d}intersectSphere(t,e){Let.subVectors(t.center,this.origin);const n=Let.dot(this.direction),i=Let.dot(Let)-n*n,r=t.radius*t.radius;if(i>r)return null;const s=Math.sqrt(r-i),o=n-s,a=n+s;return o<0&&a<0?null:this.at(o<0?a:o,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(0===e)return 0===t.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return null===n?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return 0===e||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,i,r,s,o,a;const l=1/this.direction.x,c=1/this.direction.y,u=1/this.direction.z,h=this.origin;return l>=0?(n=(t.min.x-h.x)*l,i=(t.max.x-h.x)*l):(n=(t.max.x-h.x)*l,i=(t.min.x-h.x)*l),c>=0?(r=(t.min.y-h.y)*c,s=(t.max.y-h.y)*c):(r=(t.max.y-h.y)*c,s=(t.min.y-h.y)*c),n>s||r>i?null:((r>n||n!=n)&&(n=r),(s<i||i!=i)&&(i=s),u>=0?(o=(t.min.z-h.z)*u,a=(t.max.z-h.z)*u):(o=(t.max.z-h.z)*u,a=(t.min.z-h.z)*u),n>a||o>i?null:((o>n||n!=n)&&(n=o),(a<i||i!=i)&&(i=a),i<0?null:this.at(n>=0?n:i,e)))}intersectsBox(t){return null!==this.intersectBox(t,Let)}intersectTriangle(t,e,n,i,r){Pet.subVectors(e,t),Fet.subVectors(n,t),$et.crossVectors(Pet,Fet);let s,o=this.direction.dot($et);if(o>0){if(i)return null;s=1}else{if(!(o<0))return null;s=-1,o=-o}Oet.subVectors(this.origin,t);const a=s*this.direction.dot(Fet.crossVectors(Oet,Fet));if(a<0)return null;const l=s*this.direction.dot(Pet.cross(Oet));if(l<0)return null;if(a+l>o)return null;const c=-s*Oet.dot($et);return c<0?null:this.at(c/o,r)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}}class Uet{constructor(){Object.defineProperty(this,"isMatrix4",{value:!0}),this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,r,s,o,a,l,c,u,h,d,p,f,m){const g=this.elements;return g[0]=t,g[4]=e,g[8]=n,g[12]=i,g[1]=r,g[5]=s,g[9]=o,g[13]=a,g[2]=l,g[6]=c,g[10]=u,g[14]=h,g[3]=d,g[7]=p,g[11]=f,g[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new Uet).fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,i=1/Het.setFromMatrixColumn(t,0).length(),r=1/Het.setFromMatrixColumn(t,1).length(),s=1/Het.setFromMatrixColumn(t,2).length();return e[0]=n[0]*i,e[1]=n[1]*i,e[2]=n[2]*i,e[3]=0,e[4]=n[4]*r,e[5]=n[5]*r,e[6]=n[6]*r,e[7]=0,e[8]=n[8]*s,e[9]=n[9]*s,e[10]=n[10]*s,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,n=t.x,i=t.y,r=t.z,s=Math.cos(n),o=Math.sin(n),a=Math.cos(i),l=Math.sin(i),c=Math.cos(r),u=Math.sin(r);if("XYZ"===t.order){const t=s*c,n=s*u,i=o*c,r=o*u;e[0]=a*c,e[4]=-a*u,e[8]=l,e[1]=n+i*l,e[5]=t-r*l,e[9]=-o*a,e[2]=r-t*l,e[6]=i+n*l,e[10]=s*a}else if("YXZ"===t.order){const t=a*c,n=a*u,i=l*c,r=l*u;e[0]=t+r*o,e[4]=i*o-n,e[8]=s*l,e[1]=s*u,e[5]=s*c,e[9]=-o,e[2]=n*o-i,e[6]=r+t*o,e[10]=s*a}else if("ZXY"===t.order){const t=a*c,n=a*u,i=l*c,r=l*u;e[0]=t-r*o,e[4]=-s*u,e[8]=i+n*o,e[1]=n+i*o,e[5]=s*c,e[9]=r-t*o,e[2]=-s*l,e[6]=o,e[10]=s*a}else if("ZYX"===t.order){const t=s*c,n=s*u,i=o*c,r=o*u;e[0]=a*c,e[4]=i*l-n,e[8]=t*l+r,e[1]=a*u,e[5]=r*l+t,e[9]=n*l-i,e[2]=-l,e[6]=o*a,e[10]=s*a}else if("YZX"===t.order){const t=s*a,n=s*l,i=o*a,r=o*l;e[0]=a*c,e[4]=r-t*u,e[8]=i*u+n,e[1]=u,e[5]=s*c,e[9]=-o*c,e[2]=-l*c,e[6]=n*u+i,e[10]=t-r*u}else if("XZY"===t.order){const t=s*a,n=s*l,i=o*a,r=o*l;e[0]=a*c,e[4]=-u,e[8]=l*c,e[1]=t*u+r,e[5]=s*c,e[9]=n*u-i,e[2]=i*u-n,e[6]=o*c,e[10]=r*u+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(Get,t,Wet)}lookAt(t,e,n){const i=this.elements;return qet.subVectors(t,e),0===qet.lengthSq()&&(qet.z=1),qet.normalize(),jet.crossVectors(n,qet),0===jet.lengthSq()&&(1===Math.abs(n.z)?qet.x+=1e-4:qet.z+=1e-4,qet.normalize(),jet.crossVectors(n,qet)),jet.normalize(),Qet.crossVectors(qet,jet),i[0]=jet.x,i[4]=Qet.x,i[8]=qet.x,i[1]=jet.y,i[5]=Qet.y,i[9]=qet.y,i[2]=jet.z,i[6]=Qet.z,i[10]=qet.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,s=n[0],o=n[4],a=n[8],l=n[12],c=n[1],u=n[5],h=n[9],d=n[13],p=n[2],f=n[6],m=n[10],g=n[14],y=n[3],v=n[7],b=n[11],A=n[15],x=i[0],w=i[4],_=i[8],S=i[12],E=i[1],C=i[5],I=i[9],T=i[13],M=i[2],k=i[6],R=i[10],N=i[14],L=i[3],D=i[7],B=i[11],O=i[15];return r[0]=s*x+o*E+a*M+l*L,r[4]=s*w+o*C+a*k+l*D,r[8]=s*_+o*I+a*R+l*B,r[12]=s*S+o*T+a*N+l*O,r[1]=c*x+u*E+h*M+d*L,r[5]=c*w+u*C+h*k+d*D,r[9]=c*_+u*I+h*R+d*B,r[13]=c*S+u*T+h*N+d*O,r[2]=p*x+f*E+m*M+g*L,r[6]=p*w+f*C+m*k+g*D,r[10]=p*_+f*I+m*R+g*B,r[14]=p*S+f*T+m*N+g*O,r[3]=y*x+v*E+b*M+A*L,r[7]=y*w+v*C+b*k+A*D,r[11]=y*_+v*I+b*R+A*B,r[15]=y*S+v*T+b*N+A*O,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],i=t[8],r=t[12],s=t[1],o=t[5],a=t[9],l=t[13],c=t[2],u=t[6],h=t[10],d=t[14];return t[3]*(+r*a*u-i*l*u-r*o*h+n*l*h+i*o*d-n*a*d)+t[7]*(+e*a*d-e*l*h+r*s*h-i*s*d+i*l*c-r*a*c)+t[11]*(+e*l*u-e*o*d-r*s*u+n*s*d+r*o*c-n*l*c)+t[15]*(-i*o*c-e*a*u+e*o*h+i*s*u-n*s*h+n*a*c)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],o=t[5],a=t[6],l=t[7],c=t[8],u=t[9],h=t[10],d=t[11],p=t[12],f=t[13],m=t[14],g=t[15],y=u*m*l-f*h*l+f*a*d-o*m*d-u*a*g+o*h*g,v=p*h*l-c*m*l-p*a*d+s*m*d+c*a*g-s*h*g,b=c*f*l-p*u*l+p*o*d-s*f*d-c*o*g+s*u*g,A=p*u*a-c*f*a-p*o*h+s*f*h+c*o*m-s*u*m,x=e*y+n*v+i*b+r*A;if(0===x)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const w=1/x;return t[0]=y*w,t[1]=(f*h*r-u*m*r-f*i*d+n*m*d+u*i*g-n*h*g)*w,t[2]=(o*m*r-f*a*r+f*i*l-n*m*l-o*i*g+n*a*g)*w,t[3]=(u*a*r-o*h*r-u*i*l+n*h*l+o*i*d-n*a*d)*w,t[4]=v*w,t[5]=(c*m*r-p*h*r+p*i*d-e*m*d-c*i*g+e*h*g)*w,t[6]=(p*a*r-s*m*r-p*i*l+e*m*l+s*i*g-e*a*g)*w,t[7]=(s*h*r-c*a*r+c*i*l-e*h*l-s*i*d+e*a*d)*w,t[8]=b*w,t[9]=(p*u*r-c*f*r-p*n*d+e*f*d+c*n*g-e*u*g)*w,t[10]=(s*f*r-p*o*r+p*n*l-e*f*l-s*n*g+e*o*g)*w,t[11]=(c*o*r-s*u*r-c*n*l+e*u*l+s*n*d-e*o*d)*w,t[12]=A*w,t[13]=(c*f*i-p*u*i+p*n*h-e*f*h-c*n*m+e*u*m)*w,t[14]=(p*o*i-s*f*i-p*n*a+e*f*a+s*n*m-e*o*m)*w,t[15]=(s*u*i-c*o*i+c*n*a-e*u*a-s*n*h+e*o*h)*w,this}scale(t){const e=this.elements,n=t.x,i=t.y,r=t.z;return e[0]*=n,e[4]*=i,e[8]*=r,e[1]*=n,e[5]*=i,e[9]*=r,e[2]*=n,e[6]*=i,e[10]*=r,e[3]*=n,e[7]*=i,e[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements;return Math.sqrt(Math.max(t[0]*t[0]+t[1]*t[1]+t[2]*t[2],t[4]*t[4]+t[5]*t[5]+t[6]*t[6],t[8]*t[8]+t[9]*t[9]+t[10]*t[10]))}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),i=Math.sin(e),r=1-n,s=t.x,o=t.y,a=t.z,l=r*s,c=r*o;return this.set(l*s+n,l*o-i*a,l*a+i*o,0,l*o+i*a,c*o+n,c*a-i*s,0,l*a-i*o,c*a+i*s,r*a*a+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n){return this.set(1,e,n,0,t,1,n,0,t,e,1,0,0,0,0,1),this}compose(t,e,n){const i=this.elements,r=e._x,s=e._y,o=e._z,a=e._w,l=r+r,c=s+s,u=o+o,h=r*l,d=r*c,p=r*u,f=s*c,m=s*u,g=o*u,y=a*l,v=a*c,b=a*u,A=n.x,x=n.y,w=n.z;return i[0]=(1-(f+g))*A,i[1]=(d+b)*A,i[2]=(p-v)*A,i[3]=0,i[4]=(d-b)*x,i[5]=(1-(h+g))*x,i[6]=(m+y)*x,i[7]=0,i[8]=(p+v)*w,i[9]=(m-y)*w,i[10]=(1-(h+f))*w,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,n){const i=this.elements;let r=Het.set(i[0],i[1],i[2]).length();const s=Het.set(i[4],i[5],i[6]).length(),o=Het.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),t.x=i[12],t.y=i[13],t.z=i[14],Vet.copy(this);const a=1/r,l=1/s,c=1/o;return Vet.elements[0]*=a,Vet.elements[1]*=a,Vet.elements[2]*=a,Vet.elements[4]*=l,Vet.elements[5]*=l,Vet.elements[6]*=l,Vet.elements[8]*=c,Vet.elements[9]*=c,Vet.elements[10]*=c,e.setFromRotationMatrix(Vet),n.x=r,n.y=s,n.z=o,this}makePerspective(t,e,n,i,r,s){void 0===s&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const o=this.elements,a=2*r/(n-i),l=(e+t)/(e-t),c=(n+i)/(n-i),u=-(s+r)/(s-r),h=-2*s*r/(s-r);return o[0]=2*r/(e-t),o[4]=0,o[8]=l,o[12]=0,o[1]=0,o[5]=a,o[9]=c,o[13]=0,o[2]=0,o[6]=0,o[10]=u,o[14]=h,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(t,e,n,i,r,s){const o=this.elements,a=1/(e-t),l=1/(n-i),c=1/(s-r),u=(e+t)*a,h=(n+i)*l,d=(s+r)*c;return o[0]=2*a,o[4]=0,o[8]=0,o[12]=-u,o[1]=0,o[5]=2*l,o[9]=0,o[13]=-h,o[2]=0,o[6]=0,o[10]=-2*c,o[14]=-d,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<16;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}const Het=new det,Vet=new Uet,Get=new det(0,0,0),Wet=new det(1,1,1),jet=new det,Qet=new det,qet=new det;class Xet{constructor(t=0,e=0,n=0,i=Xet.DefaultOrder){Object.defineProperty(this,"isEuler",{value:!0}),this._x=t,this._y=e,this._z=n,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._order=i||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e,n){const i=tet.clamp,r=t.elements,s=r[0],o=r[4],a=r[8],l=r[1],c=r[5],u=r[9],h=r[2],d=r[6],p=r[10];switch(e=e||this._order){case"XYZ":this._y=Math.asin(i(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-u,p),this._z=Math.atan2(-o,s)):(this._x=Math.atan2(d,c),this._z=0);break;case"YXZ":this._x=Math.asin(-i(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(a,p),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-h,s),this._z=0);break;case"ZXY":this._x=Math.asin(i(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-h,p),this._z=Math.atan2(-o,c)):(this._y=0,this._z=Math.atan2(l,s));break;case"ZYX":this._y=Math.asin(-i(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(l,s)):(this._x=0,this._z=Math.atan2(-o,c));break;case"YZX":this._z=Math.asin(i(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,c),this._y=Math.atan2(-h,s)):(this._x=0,this._y=Math.atan2(a,p));break;case"XZY":this._z=Math.asin(-i(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(d,c),this._y=Math.atan2(a,s)):(this._x=Math.atan2(-u,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!1!==n&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return Yet.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Yet,e,n)}setFromVector3(t,e){return this.set(t.x,t.y,t.z,e||this._order)}reorder(t){return Ket.setFromEuler(this),this.setFromQuaternion(Ket,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new det(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}Xet.DefaultOrder="XYZ",Xet.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];const Yet=new Uet,Ket=new het;class Jet{constructor(){this.mask=1}set(t){this.mask=1<<t|0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return 0!=(this.mask&t.mask)}}let Zet=0;const tnt=new det,ent=new het,nnt=new Uet,int=new det,rnt=new det,snt=new det,ont=new het,ant=new det(1,0,0),lnt=new det(0,1,0),cnt=new det(0,0,1),unt={type:"added"},hnt={type:"removed"};function dnt(){Object.defineProperty(this,"id",{value:Zet++}),this.uuid=tet.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=dnt.DefaultUp.clone();const t=new det,e=new Xet,n=new het,i=new det(1,1,1);e._onChange(function(){n.setFromEuler(e,!1)}),n._onChange(function(){e.setFromQuaternion(n,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new Uet},normalMatrix:{value:new net}}),this.matrix=new Uet,this.matrixWorld=new Uet,this.matrixAutoUpdate=dnt.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new Jet,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}dnt.DefaultUp=new det(0,1,0),dnt.DefaultMatrixAutoUpdate=!0,dnt.prototype=Object.assign(Object.create(Ktt.prototype),{constructor:dnt,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix4:function(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(t){return this.quaternion.premultiply(t),this},setRotationFromAxisAngle:function(t,e){this.quaternion.setFromAxisAngle(t,e)},setRotationFromEuler:function(t){this.quaternion.setFromEuler(t,!0)},setRotationFromMatrix:function(t){this.quaternion.setFromRotationMatrix(t)},setRotationFromQuaternion:function(t){this.quaternion.copy(t)},rotateOnAxis:function(t,e){return ent.setFromAxisAngle(t,e),this.quaternion.multiply(ent),this},rotateOnWorldAxis:function(t,e){return ent.setFromAxisAngle(t,e),this.quaternion.premultiply(ent),this},rotateX:function(t){return this.rotateOnAxis(ant,t)},rotateY:function(t){return this.rotateOnAxis(lnt,t)},rotateZ:function(t){return this.rotateOnAxis(cnt,t)},translateOnAxis:function(t,e){return tnt.copy(t).applyQuaternion(this.quaternion),this.position.add(tnt.multiplyScalar(e)),this},translateX:function(t){return this.translateOnAxis(ant,t)},translateY:function(t){return this.translateOnAxis(lnt,t)},translateZ:function(t){return this.translateOnAxis(cnt,t)},localToWorld:function(t){return t.applyMatrix4(this.matrixWorld)},worldToLocal:function(t){return t.applyMatrix4(nnt.copy(this.matrixWorld).invert())},lookAt:function(t,e,n){t.isVector3?int.copy(t):int.set(t,e,n);const i=this.parent;this.updateWorldMatrix(!0,!1),rnt.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?nnt.lookAt(rnt,int,this.up):nnt.lookAt(int,rnt,this.up),this.quaternion.setFromRotationMatrix(nnt),i&&(nnt.extractRotation(i.matrixWorld),ent.setFromRotationMatrix(nnt),this.quaternion.premultiply(ent.invert()))},add:function(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(null!==t.parent&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(unt)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)},remove:function(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(t);return-1!==e&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(hnt)),this},clear:function(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(hnt)}return this.children.length=0,this},attach:function(t){return this.updateWorldMatrix(!0,!1),nnt.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),nnt.multiply(t.parent.matrixWorld)),t.applyMatrix4(nnt),t.updateWorldMatrix(!1,!1),this.add(t),this},getObjectById:function(t){return this.getObjectByProperty("id",t)},getObjectByName:function(t){return this.getObjectByProperty("name",t)},getObjectByProperty:function(t,e){if(this[t]===e)return this;for(let n=0,i=this.children.length;n<i;n++){const i=this.children[n].getObjectByProperty(t,e);if(void 0!==i)return i}},getWorldPosition:function(t){return void 0===t&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),t=new det),this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(t){return void 0===t&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),t=new het),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(rnt,t,snt),t},getWorldScale:function(t){return void 0===t&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),t=new det),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(rnt,ont,t),t},getWorldDirection:function(t){void 0===t&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),t=new det),this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()},raycast:function(){},traverse:function(t){t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverse(t)},traverseVisible:function(t){if(!1===this.visible)return;t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverseVisible(t)},traverseAncestors:function(t){const e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].updateMatrixWorld(t)},updateWorldMatrix:function(t,e){const n=this.parent;if(!0===t&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===e){const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].updateWorldMatrix(!1,!0)}},toJSON:function(t){const e=void 0===t||"string"==typeof t,n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};function r(e,n){return void 0===e[n.uuid]&&(e[n.uuid]=n.toJSON(t)),n.uuid}if(i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),!0===this.castShadow&&(i.castShadow=!0),!0===this.receiveShadow&&(i.receiveShadow=!0),!1===this.visible&&(i.visible=!1),!1===this.frustumCulled&&(i.frustumCulled=!1),0!==this.renderOrder&&(i.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON()),this.isMesh||this.isLine||this.isPoints){i.geometry=r(t.geometries,this.geometry);const e=this.geometry.parameters;if(void 0!==e&&void 0!==e.shapes){const n=e.shapes;if(Array.isArray(n))for(let e=0,i=n.length;e<i;e++)r(t.shapes,n[e]);else r(t.shapes,n)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(r(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const e=[];for(let n=0,i=this.material.length;n<i;n++)e.push(r(t.materials,this.material[n]));i.material=e}else i.material=r(t.materials,this.material);if(this.children.length>0){i.children=[];for(let e=0;e<this.children.length;e++)i.children.push(this.children[e].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let e=0;e<this.animations.length;e++)i.animations.push(r(t.animations,this.animations[e]))}if(e){const e=s(t.geometries),i=s(t.materials),r=s(t.textures),o=s(t.images),a=s(t.shapes),l=s(t.skeletons),c=s(t.animations);e.length>0&&(n.geometries=e),i.length>0&&(n.materials=i),r.length>0&&(n.textures=r),o.length>0&&(n.images=o),a.length>0&&(n.shapes=a),l.length>0&&(n.skeletons=l),c.length>0&&(n.animations=c)}return n.object=i,n;function s(t){const e=[];for(const n in t){const i=t[n];delete i.metadata,e.push(i)}return e}},clone:function(t){return(new this.constructor).copy(this,t)},copy:function(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(let n=0;n<t.children.length;n++)this.add(t.children[n].clone());return this}});const pnt=new det,fnt=new det,mnt=new net;class gnt{constructor(t,e){Object.defineProperty(this,"isPlane",{value:!0}),this.normal=void 0!==t?t:new det(1,0,0),this.constant=void 0!==e?e:0}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,i){return this.normal.set(t,e,n),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const i=pnt.subVectors(n,e).cross(fnt.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return void 0===e&&(console.warn("THREE.Plane: .projectPoint() target is now required"),e=new det),e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){void 0===e&&(console.warn("THREE.Plane: .intersectLine() target is now required"),e=new det);const n=t.delta(pnt),i=this.normal.dot(n);if(0===i)return 0===this.distanceToPoint(t.start)?e.copy(t.start):void 0;const r=-(t.start.dot(this.normal)+this.constant)/i;return r<0||r>1?void 0:e.copy(n).multiplyScalar(r).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return void 0===t&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),t=new det),t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||mnt.getNormalMatrix(t),i=this.coplanarPoint(pnt).applyMatrix4(t),r=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}}const ynt=new det,vnt=new det,bnt=new det,Ant=new det,xnt=new det,wnt=new det,_nt=new det,Snt=new det,Ent=new det,Cnt=new det;class Int{constructor(t,e,n){this.a=void 0!==t?t:new det,this.b=void 0!==e?e:new det,this.c=void 0!==n?n:new det}static getNormal(t,e,n,i){void 0===i&&(console.warn("THREE.Triangle: .getNormal() target is now required"),i=new det),i.subVectors(n,e),ynt.subVectors(t,e),i.cross(ynt);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(t,e,n,i,r){ynt.subVectors(i,e),vnt.subVectors(n,e),bnt.subVectors(t,e);const s=ynt.dot(ynt),o=ynt.dot(vnt),a=ynt.dot(bnt),l=vnt.dot(vnt),c=vnt.dot(bnt),u=s*l-o*o;if(void 0===r&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),r=new det),0===u)return r.set(-2,-1,-1);const h=1/u,d=(l*a-o*c)*h,p=(s*c-o*a)*h;return r.set(1-d-p,p,d)}static containsPoint(t,e,n,i){return this.getBarycoord(t,e,n,i,Ant),Ant.x>=0&&Ant.y>=0&&Ant.x+Ant.y<=1}static getUV(t,e,n,i,r,s,o,a){return this.getBarycoord(t,e,n,i,Ant),a.set(0,0),a.addScaledVector(r,Ant.x),a.addScaledVector(s,Ant.y),a.addScaledVector(o,Ant.z),a}static isFrontFacing(t,e,n,i){return ynt.subVectors(n,e),vnt.subVectors(t,e),ynt.cross(vnt).dot(i)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,i){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[i]),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return ynt.subVectors(this.c,this.b),vnt.subVectors(this.a,this.b),.5*ynt.cross(vnt).length()}getMidpoint(t){return void 0===t&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),t=new det),t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return Int.getNormal(this.a,this.b,this.c,t)}getPlane(t){return void 0===t&&(console.warn("THREE.Triangle: .getPlane() target is now required"),t=new gnt),t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return Int.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,i,r){return Int.getUV(t,this.a,this.b,this.c,e,n,i,r)}containsPoint(t){return Int.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return Int.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){void 0===e&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),e=new det);const n=this.a,i=this.b,r=this.c;let s,o;xnt.subVectors(i,n),wnt.subVectors(r,n),Snt.subVectors(t,n);const a=xnt.dot(Snt),l=wnt.dot(Snt);if(a<=0&&l<=0)return e.copy(n);Ent.subVectors(t,i);const c=xnt.dot(Ent),u=wnt.dot(Ent);if(c>=0&&u<=c)return e.copy(i);const h=a*u-c*l;if(h<=0&&a>=0&&c<=0)return s=a/(a-c),e.copy(n).addScaledVector(xnt,s);Cnt.subVectors(t,r);const d=xnt.dot(Cnt),p=wnt.dot(Cnt);if(p>=0&&d<=p)return e.copy(r);const f=d*l-a*p;if(f<=0&&l>=0&&p<=0)return o=l/(l-p),e.copy(n).addScaledVector(wnt,o);const m=c*p-d*u;if(m<=0&&u-c>=0&&d-p>=0)return _nt.subVectors(r,i),o=(u-c)/(u-c+(d-p)),e.copy(i).addScaledVector(_nt,o);const g=1/(m+f+h);return s=f*g,o=h*g,e.copy(n).addScaledVector(xnt,s).addScaledVector(wnt,o)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const Tnt={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Mnt={h:0,s:0,l:0},knt={h:0,s:0,l:0};function Rnt(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+6*(e-t)*n:n<.5?e:n<2/3?t+6*(e-t)*(2/3-n):t}function Nnt(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function Lnt(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}class Dnt{constructor(t,e,n){return Object.defineProperty(this,"isColor",{value:!0}),void 0===e&&void 0===n?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):"number"==typeof t?this.setHex(t):"string"==typeof t&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,this}setRGB(t,e,n){return this.r=t,this.g=e,this.b=n,this}setHSL(t,e,n){if(t=tet.euclideanModulo(t,1),e=tet.clamp(e,0,1),n=tet.clamp(n,0,1),0===e)this.r=this.g=this.b=n;else{const i=n<=.5?n*(1+e):n+e-n*e,r=2*n-i;this.r=Rnt(r,i,t+1/3),this.g=Rnt(r,i,t),this.b=Rnt(r,i,t-1/3)}return this}setStyle(t){function e(e){void 0!==e&&parseFloat(e)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let t;const i=n[2];switch(n[1]){case"rgb":case"rgba":if(t=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))return this.r=Math.min(255,parseInt(t[1],10))/255,this.g=Math.min(255,parseInt(t[2],10))/255,this.b=Math.min(255,parseInt(t[3],10))/255,e(t[4]),this;if(t=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))return this.r=Math.min(100,parseInt(t[1],10))/100,this.g=Math.min(100,parseInt(t[2],10))/100,this.b=Math.min(100,parseInt(t[3],10))/100,e(t[4]),this;break;case"hsl":case"hsla":if(t=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)){const n=parseFloat(t[1])/360,i=parseInt(t[2],10)/100,r=parseInt(t[3],10)/100;return e(t[4]),this.setHSL(n,i,r)}}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const t=n[1],e=t.length;if(3===e)return this.r=parseInt(t.charAt(0)+t.charAt(0),16)/255,this.g=parseInt(t.charAt(1)+t.charAt(1),16)/255,this.b=parseInt(t.charAt(2)+t.charAt(2),16)/255,this;if(6===e)return this.r=parseInt(t.charAt(0)+t.charAt(1),16)/255,this.g=parseInt(t.charAt(2)+t.charAt(3),16)/255,this.b=parseInt(t.charAt(4)+t.charAt(5),16)/255,this}return t&&t.length>0?this.setColorName(t):this}setColorName(t){const e=Tnt[t];return void 0!==e?this.setHex(e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copyGammaToLinear(t,e=2){return this.r=Math.pow(t.r,e),this.g=Math.pow(t.g,e),this.b=Math.pow(t.b,e),this}copyLinearToGamma(t,e=2){const n=e>0?1/e:1;return this.r=Math.pow(t.r,n),this.g=Math.pow(t.g,n),this.b=Math.pow(t.b,n),this}convertGammaToLinear(t){return this.copyGammaToLinear(this,t),this}convertLinearToGamma(t){return this.copyLinearToGamma(this,t),this}copySRGBToLinear(t){return this.r=Nnt(t.r),this.g=Nnt(t.g),this.b=Nnt(t.b),this}copyLinearToSRGB(t){return this.r=Lnt(t.r),this.g=Lnt(t.g),this.b=Lnt(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(t){void 0===t&&(console.warn("THREE.Color: .getHSL() target is now required"),t={h:0,s:0,l:0});const e=this.r,n=this.g,i=this.b,r=Math.max(e,n,i),s=Math.min(e,n,i);let o,a;const l=(s+r)/2;if(s===r)o=0,a=0;else{const t=r-s;switch(a=l<=.5?t/(r+s):t/(2-r-s),r){case e:o=(n-i)/t+(n<i?6:0);break;case n:o=(i-e)/t+2;break;case i:o=(e-n)/t+4}o/=6}return t.h=o,t.s=a,t.l=l,t}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(t,e,n){return this.getHSL(Mnt),Mnt.h+=t,Mnt.s+=e,Mnt.l+=n,this.setHSL(Mnt.h,Mnt.s,Mnt.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(Mnt),t.getHSL(knt);const n=tet.lerp(Mnt.h,knt.h,e),i=tet.lerp(Mnt.s,knt.s,e),r=tet.lerp(Mnt.l,knt.l,e);return this.setHSL(n,i,r),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),!0===t.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Dnt.NAMES=Tnt,Dnt.prototype.r=1,Dnt.prototype.g=1,Dnt.prototype.b=1;class Bnt{constructor(t,e,n,i,r,s=0){this.a=t,this.b=e,this.c=n,this.normal=i&&i.isVector3?i:new det,this.vertexNormals=Array.isArray(i)?i:[],this.color=r&&r.isColor?r:new Dnt,this.vertexColors=Array.isArray(r)?r:[],this.materialIndex=s}clone(){return(new this.constructor).copy(this)}copy(t){this.a=t.a,this.b=t.b,this.c=t.c,this.normal.copy(t.normal),this.color.copy(t.color),this.materialIndex=t.materialIndex;for(let e=0,n=t.vertexNormals.length;e<n;e++)this.vertexNormals[e]=t.vertexNormals[e].clone();for(let e=0,n=t.vertexColors.length;e<n;e++)this.vertexColors[e]=t.vertexColors[e].clone();return this}}let Ont=0;function Pnt(){Object.defineProperty(this,"id",{value:Ont++}),this.uuid=tet.generateUUID(),this.name="",this.type="Material",this.fog=!0,this.blending=1,this.side=0,this.flatShading=!1,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=Stt,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Qtt,this.stencilZFail=Qtt,this.stencilZPass=Qtt,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}function Fnt(t){Pnt.call(this),this.type="MeshBasicMaterial",this.color=new Dnt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(t)}Pnt.prototype=Object.assign(Object.create(Ktt.prototype),{constructor:Pnt,isMaterial:!0,onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(t){if(void 0!==t)for(const e in t){const n=t[e];if(void 0===n){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if("shading"===e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===n;continue}const i=this[e];void 0!==i?i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[e]=n:console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.")}},toJSON:function(t){const e=void 0===t||"string"==typeof t;e&&(t={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function i(t){const e=[];for(const n in t){const i=t[n];delete i.metadata,e.push(i)}return e}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(n.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,n.reflectivity=this.reflectivity,n.refractionRatio=this.refractionRatio,void 0!==this.combine&&(n.combine=this.combine),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity)),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),void 0!==this.size&&(n.size=this.size),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(n.blending=this.blending),!0===this.flatShading&&(n.flatShading=this.flatShading),0!==this.side&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),!0===this.transparent&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.morphTargets&&(n.morphTargets=!0),!0===this.morphNormals&&(n.morphNormals=!0),!0===this.skinning&&(n.skinning=!0),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),e){const e=i(t.textures),r=i(t.images);e.length>0&&(n.textures=e),r.length>0&&(n.images=r)}return n},clone:function(){return(new this.constructor).copy(this)},copy:function(t){this.name=t.name,this.fog=t.fog,this.blending=t.blending,this.side=t.side,this.flatShading=t.flatShading,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(null!==e){const t=e.length;n=new Array(t);for(let i=0;i!==t;++i)n[i]=e[i].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),Object.defineProperty(Pnt.prototype,"needsUpdate",{set:function(t){!0===t&&this.version++}}),(Fnt.prototype=Object.create(Pnt.prototype)).constructor=Fnt,Fnt.prototype.isMeshBasicMaterial=!0,Fnt.prototype.copy=function(t){return Pnt.prototype.copy.call(this,t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this};const $nt=new det,znt=new eet;function Unt(t,e,n){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=!0===n,this.usage=qtt,this.updateRange={offset:0,count:-1},this.version=0}function Hnt(t,e,n){Unt.call(this,new Int8Array(t),e,n)}function Vnt(t,e,n){Unt.call(this,new Uint8Array(t),e,n)}function Gnt(t,e,n){Unt.call(this,new Uint8ClampedArray(t),e,n)}function Wnt(t,e,n){Unt.call(this,new Int16Array(t),e,n)}function jnt(t,e,n){Unt.call(this,new Uint16Array(t),e,n)}function Qnt(t,e,n){Unt.call(this,new Int32Array(t),e,n)}function qnt(t,e,n){Unt.call(this,new Uint32Array(t),e,n)}function Xnt(t,e,n){Unt.call(this,new Uint16Array(t),e,n)}function Ynt(t,e,n){Unt.call(this,new Float32Array(t),e,n)}function Knt(t,e,n){Unt.call(this,new Float64Array(t),e,n)}function Jnt(t){if(0===t.length)return-1/0;let e=t[0];for(let n=1,i=t.length;n<i;++n)t[n]>e&&(e=t[n]);return e}Object.defineProperty(Unt.prototype,"needsUpdate",{set:function(t){!0===t&&this.version++}}),Object.assign(Unt.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setUsage:function(t){return this.usage=t,this},copy:function(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this},copyAt:function(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[t+i]=e.array[n+i];return this},copyArray:function(t){return this.array.set(t),this},copyColorsArray:function(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),r=new Dnt),e[n++]=r.r,e[n++]=r.g,e[n++]=r.b}return this},copyVector2sArray:function(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),r=new eet),e[n++]=r.x,e[n++]=r.y}return this},copyVector3sArray:function(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),r=new det),e[n++]=r.x,e[n++]=r.y,e[n++]=r.z}return this},copyVector4sArray:function(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),r=new cet),e[n++]=r.x,e[n++]=r.y,e[n++]=r.z,e[n++]=r.w}return this},applyMatrix3:function(t){if(2===this.itemSize)for(let e=0,n=this.count;e<n;e++)znt.fromBufferAttribute(this,e),znt.applyMatrix3(t),this.setXY(e,znt.x,znt.y);else if(3===this.itemSize)for(let e=0,n=this.count;e<n;e++)$nt.fromBufferAttribute(this,e),$nt.applyMatrix3(t),this.setXYZ(e,$nt.x,$nt.y,$nt.z);return this},applyMatrix4:function(t){for(let e=0,n=this.count;e<n;e++)$nt.x=this.getX(e),$nt.y=this.getY(e),$nt.z=this.getZ(e),$nt.applyMatrix4(t),this.setXYZ(e,$nt.x,$nt.y,$nt.z);return this},applyNormalMatrix:function(t){for(let e=0,n=this.count;e<n;e++)$nt.x=this.getX(e),$nt.y=this.getY(e),$nt.z=this.getZ(e),$nt.applyNormalMatrix(t),this.setXYZ(e,$nt.x,$nt.y,$nt.z);return this},transformDirection:function(t){for(let e=0,n=this.count;e<n;e++)$nt.x=this.getX(e),$nt.y=this.getY(e),$nt.z=this.getZ(e),$nt.transformDirection(t),this.setXYZ(e,$nt.x,$nt.y,$nt.z);return this},set:function(t,e=0){return this.array.set(t,e),this},getX:function(t){return this.array[t*this.itemSize]},setX:function(t,e){return this.array[t*this.itemSize]=e,this},getY:function(t){return this.array[t*this.itemSize+1]},setY:function(t,e){return this.array[t*this.itemSize+1]=e,this},getZ:function(t){return this.array[t*this.itemSize+2]},setZ:function(t,e){return this.array[t*this.itemSize+2]=e,this},getW:function(t){return this.array[t*this.itemSize+3]},setW:function(t,e){return this.array[t*this.itemSize+3]=e,this},setXY:function(t,e,n){return this.array[0+(t*=this.itemSize)]=e,this.array[t+1]=n,this},setXYZ:function(t,e,n,i){return this.array[0+(t*=this.itemSize)]=e,this.array[t+1]=n,this.array[t+2]=i,this},setXYZW:function(t,e,n,i,r){return this.array[0+(t*=this.itemSize)]=e,this.array[t+1]=n,this.array[t+2]=i,this.array[t+3]=r,this},onUpload:function(t){return this.onUploadCallback=t,this},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this)},toJSON:function(){return{itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized}}}),(Hnt.prototype=Object.create(Unt.prototype)).constructor=Hnt,(Vnt.prototype=Object.create(Unt.prototype)).constructor=Vnt,(Gnt.prototype=Object.create(Unt.prototype)).constructor=Gnt,(Wnt.prototype=Object.create(Unt.prototype)).constructor=Wnt,(jnt.prototype=Object.create(Unt.prototype)).constructor=jnt,(Qnt.prototype=Object.create(Unt.prototype)).constructor=Qnt,(qnt.prototype=Object.create(Unt.prototype)).constructor=qnt,(Xnt.prototype=Object.create(Unt.prototype)).constructor=Xnt,Xnt.prototype.isFloat16BufferAttribute=!0,(Ynt.prototype=Object.create(Unt.prototype)).constructor=Ynt,(Knt.prototype=Object.create(Unt.prototype)).constructor=Knt;const Znt={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:"undefined"!=typeof Uint8ClampedArray?Uint8ClampedArray:Uint8Array,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};function tit(t,e){return new Znt[t](e)}let eit=0;const nit=new Uet,iit=new dnt,rit=new det,sit=new met,oit=new met,ait=new det;function lit(){Object.defineProperty(this,"id",{value:eit++}),this.uuid=tet.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}lit.prototype=Object.assign(Object.create(Ktt.prototype),{constructor:lit,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(t){return this.index=Array.isArray(t)?new(Jnt(t)>65535?qnt:jnt)(t,1):t,this},getAttribute:function(t){return this.attributes[t]},setAttribute:function(t,e){return this.attributes[t]=e,this},deleteAttribute:function(t){return delete this.attributes[t],this},hasAttribute:function(t){return void 0!==this.attributes[t]},addGroup:function(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})},clearGroups:function(){this.groups=[]},setDrawRange:function(t,e){this.drawRange.start=t,this.drawRange.count=e},applyMatrix4:function(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const e=(new net).getNormalMatrix(t);n.applyNormalMatrix(e),n.needsUpdate=!0}const i=this.attributes.tangent;return void 0!==i&&(i.transformDirection(t),i.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},rotateX:function(t){return nit.makeRotationX(t),this.applyMatrix4(nit),this},rotateY:function(t){return nit.makeRotationY(t),this.applyMatrix4(nit),this},rotateZ:function(t){return nit.makeRotationZ(t),this.applyMatrix4(nit),this},translate:function(t,e,n){return nit.makeTranslation(t,e,n),this.applyMatrix4(nit),this},scale:function(t,e,n){return nit.makeScale(t,e,n),this.applyMatrix4(nit),this},lookAt:function(t){return iit.lookAt(t),iit.updateMatrix(),this.applyMatrix4(iit.matrix),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(rit).negate(),this.translate(rit.x,rit.y,rit.z),this},setFromPoints:function(t){const e=[];for(let n=0,i=t.length;n<i;n++){const i=t[n];e.push(i.x,i.y,i.z||0)}return this.setAttribute("position",new Ynt(e,3)),this},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new met);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new det(-1/0,-1/0,-1/0),new det(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let n=0,i=e.length;n<i;n++)sit.setFromBufferAttribute(e[n]),this.morphTargetsRelative?(ait.addVectors(this.boundingBox.min,sit.min),this.boundingBox.expandByPoint(ait),ait.addVectors(this.boundingBox.max,sit.max),this.boundingBox.expandByPoint(ait)):(this.boundingBox.expandByPoint(sit.min),this.boundingBox.expandByPoint(sit.max))}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new Net);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new det,1/0);if(t){const n=this.boundingSphere.center;if(sit.setFromBufferAttribute(t),e)for(let t=0,r=e.length;t<r;t++)oit.setFromBufferAttribute(e[t]),this.morphTargetsRelative?(ait.addVectors(sit.min,oit.min),sit.expandByPoint(ait),ait.addVectors(sit.max,oit.max),sit.expandByPoint(ait)):(sit.expandByPoint(oit.min),sit.expandByPoint(oit.max));sit.getCenter(n);let i=0;for(let e=0,r=t.count;e<r;e++)ait.fromBufferAttribute(t,e),i=Math.max(i,n.distanceToSquared(ait));if(e)for(let r=0,s=e.length;r<s;r++){const s=e[r],o=this.morphTargetsRelative;for(let e=0,r=s.count;e<r;e++)ait.fromBufferAttribute(s,e),o&&(rit.fromBufferAttribute(t,e),ait.add(rit)),i=Math.max(i,n.distanceToSquared(ait))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}},computeFaceNormals:function(){},computeTangents:function(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=t.array,i=e.position.array,r=e.normal.array,s=e.uv.array,o=i.length/3;void 0===e.tangent&&this.setAttribute("tangent",new Unt(new Float32Array(4*o),4));const a=e.tangent.array,l=[],c=[];for(let E=0;E<o;E++)l[E]=new det,c[E]=new det;const u=new det,h=new det,d=new det,p=new eet,f=new eet,m=new eet,g=new det,y=new det;function v(t,e,n){u.fromArray(i,3*t),h.fromArray(i,3*e),d.fromArray(i,3*n),p.fromArray(s,2*t),f.fromArray(s,2*e),m.fromArray(s,2*n),h.sub(u),d.sub(u),f.sub(p),m.sub(p);const r=1/(f.x*m.y-m.x*f.y);isFinite(r)&&(g.copy(h).multiplyScalar(m.y).addScaledVector(d,-f.y).multiplyScalar(r),y.copy(d).multiplyScalar(f.x).addScaledVector(h,-m.x).multiplyScalar(r),l[t].add(g),l[e].add(g),l[n].add(g),c[t].add(y),c[e].add(y),c[n].add(y))}let b=this.groups;0===b.length&&(b=[{start:0,count:n.length}]);for(let E=0,C=b.length;E<C;++E){const t=b[E],e=t.start;for(let i=e,r=e+t.count;i<r;i+=3)v(n[i+0],n[i+1],n[i+2])}const A=new det,x=new det,w=new det,_=new det;function S(t){w.fromArray(r,3*t),_.copy(w);const e=l[t];A.copy(e),A.sub(w.multiplyScalar(w.dot(e))).normalize(),x.crossVectors(_,e);const n=x.dot(c[t])<0?-1:1;a[4*t]=A.x,a[4*t+1]=A.y,a[4*t+2]=A.z,a[4*t+3]=n}for(let E=0,C=b.length;E<C;++E){const t=b[E],e=t.start;for(let i=e,r=e+t.count;i<r;i+=3)S(n[i+0]),S(n[i+1]),S(n[i+2])}},computeVertexNormals:function(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let n=this.getAttribute("normal");if(void 0===n)n=new Unt(new Float32Array(3*e.count),3),this.setAttribute("normal",n);else for(let t=0,e=n.count;t<e;t++)n.setXYZ(t,0,0,0);const i=new det,r=new det,s=new det,o=new det,a=new det,l=new det,c=new det,u=new det;if(t)for(let h=0,d=t.count;h<d;h+=3){const d=t.getX(h+0),p=t.getX(h+1),f=t.getX(h+2);i.fromBufferAttribute(e,d),r.fromBufferAttribute(e,p),s.fromBufferAttribute(e,f),c.subVectors(s,r),u.subVectors(i,r),c.cross(u),o.fromBufferAttribute(n,d),a.fromBufferAttribute(n,p),l.fromBufferAttribute(n,f),o.add(c),a.add(c),l.add(c),n.setXYZ(d,o.x,o.y,o.z),n.setXYZ(p,a.x,a.y,a.z),n.setXYZ(f,l.x,l.y,l.z)}else for(let t=0,h=e.count;t<h;t+=3)i.fromBufferAttribute(e,t+0),r.fromBufferAttribute(e,t+1),s.fromBufferAttribute(e,t+2),c.subVectors(s,r),u.subVectors(i,r),c.cross(u),n.setXYZ(t+0,c.x,c.y,c.z),n.setXYZ(t+1,c.x,c.y,c.z),n.setXYZ(t+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}},merge:function(t,e){if(!t||!t.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);void 0===e&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const i in n){if(void 0===t.attributes[i])continue;const r=n[i].array,s=t.attributes[i],o=s.array,a=s.itemSize*e,l=Math.min(o.length,r.length-a);for(let t=0,e=a;t<l;t++,e++)r[e]=o[t]}return this},normalizeNormals:function(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)ait.fromBufferAttribute(t,e),ait.normalize(),t.setXYZ(e,ait.x,ait.y,ait.z)},toNonIndexed:function(){function t(t,e){const n=t.array,i=t.itemSize,r=t.normalized,s=new n.constructor(e.length*i);let o=0,a=0;for(let l=0,c=e.length;l<c;l++){o=e[l]*i;for(let t=0;t<i;t++)s[a++]=n[o++]}return new Unt(s,i,r)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new lit,n=this.index.array,i=this.attributes;for(const o in i){const r=t(i[o],n);e.setAttribute(o,r)}const r=this.morphAttributes;for(const o in r){const i=[],s=r[o];for(let e=0,r=s.length;e<r;e++){const r=t(s[e],n);i.push(r)}e.morphAttributes[o]=i}e.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let o=0,a=s.length;o<a;o++){const t=s[o];e.addGroup(t.start,t.count,t.materialIndex)}return e},toJSON:function(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const n in e)void 0!==e[n]&&(t[n]=e[n]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const a in n){const e=n[a],i=e.toJSON(t.data);""!==e.name&&(i.name=e.name),t.data.attributes[a]=i}const i={};let r=!1;for(const a in this.morphAttributes){const e=this.morphAttributes[a],n=[];for(let i=0,r=e.length;i<r;i++){const r=e[i],s=r.toJSON(t.data);""!==r.name&&(s.name=r.name),n.push(s)}n.length>0&&(i[a]=n,r=!0)}r&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(t.data.groups=JSON.parse(JSON.stringify(s)));const o=this.boundingSphere;return null!==o&&(t.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),t},clone:function(){return(new lit).copy(this)},copy:function(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;null!==n&&this.setIndex(n.clone(e));const i=t.attributes;for(const l in i)this.setAttribute(l,i[l].clone(e));const r=t.morphAttributes;for(const l in r){const t=[],n=r[l];for(let i=0,r=n.length;i<r;i++)t.push(n[i].clone(e));this.morphAttributes[l]=t}this.morphTargetsRelative=t.morphTargetsRelative;const s=t.groups;for(let l=0,c=s.length;l<c;l++){const t=s[l];this.addGroup(t.start,t.count,t.materialIndex)}const o=t.boundingBox;null!==o&&(this.boundingBox=o.clone());const a=t.boundingSphere;return null!==a&&(this.boundingSphere=a.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});const cit=new Uet,uit=new zet,hit=new Net,dit=new det,pit=new det,fit=new det,mit=new det,git=new det,yit=new det,vit=new det,bit=new det,Ait=new det,xit=new eet,wit=new eet,_it=new eet,Sit=new det,Eit=new det;function Cit(t=new lit,e=new Fnt){dnt.call(this),this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}function Iit(t,e,n,i,r,s,o,a,l,c,u,h){dit.fromBufferAttribute(r,c),pit.fromBufferAttribute(r,u),fit.fromBufferAttribute(r,h);const d=t.morphTargetInfluences;if(e.morphTargets&&s&&d){vit.set(0,0,0),bit.set(0,0,0),Ait.set(0,0,0);for(let t=0,e=s.length;t<e;t++){const e=d[t],n=s[t];0!==e&&(mit.fromBufferAttribute(n,c),git.fromBufferAttribute(n,u),yit.fromBufferAttribute(n,h),o?(vit.addScaledVector(mit,e),bit.addScaledVector(git,e),Ait.addScaledVector(yit,e)):(vit.addScaledVector(mit.sub(dit),e),bit.addScaledVector(git.sub(pit),e),Ait.addScaledVector(yit.sub(fit),e)))}dit.add(vit),pit.add(bit),fit.add(Ait)}t.isSkinnedMesh&&(t.boneTransform(c,dit),t.boneTransform(u,pit),t.boneTransform(h,fit));const p=function(t,e,n,i,r,s,o,a){let l;if(l=1===e.side?i.intersectTriangle(o,s,r,!0,a):i.intersectTriangle(r,s,o,2!==e.side,a),null===l)return null;Eit.copy(a),Eit.applyMatrix4(t.matrixWorld);const c=n.ray.origin.distanceTo(Eit);return c<n.near||c>n.far?null:{distance:c,point:Eit.clone(),object:t}}(t,e,n,i,dit,pit,fit,Sit);if(p){a&&(xit.fromBufferAttribute(a,c),wit.fromBufferAttribute(a,u),_it.fromBufferAttribute(a,h),p.uv=Int.getUV(Sit,dit,pit,fit,xit,wit,_it,new eet)),l&&(xit.fromBufferAttribute(l,c),wit.fromBufferAttribute(l,u),_it.fromBufferAttribute(l,h),p.uv2=Int.getUV(Sit,dit,pit,fit,xit,wit,_it,new eet));const t=new Bnt(c,u,h);Int.getNormal(dit,pit,fit,t.normal),p.face=t}return p}Cit.prototype=Object.assign(Object.create(dnt.prototype),{constructor:Cit,isMesh:!0,copy:function(t){return dnt.prototype.copy.call(this,t),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this},updateMorphTargets:function(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},raycast:function(t,e){const n=this.geometry,i=this.material,r=this.matrixWorld;if(void 0===i)return;if(null===n.boundingSphere&&n.computeBoundingSphere(),hit.copy(n.boundingSphere),hit.applyMatrix4(r),!1===t.ray.intersectsSphere(hit))return;if(cit.copy(r).invert(),uit.copy(t.ray).applyMatrix4(cit),null!==n.boundingBox&&!1===uit.intersectsBox(n.boundingBox))return;let s;if(n.isBufferGeometry){const r=n.index,o=n.attributes.position,a=n.morphAttributes.position,l=n.morphTargetsRelative,c=n.attributes.uv,u=n.attributes.uv2,h=n.groups,d=n.drawRange;if(null!==r)if(Array.isArray(i))for(let n=0,p=h.length;n<p;n++){const p=h[n],f=i[p.materialIndex];for(let n=Math.max(p.start,d.start),i=Math.min(p.start+p.count,d.start+d.count);n<i;n+=3){const i=r.getX(n),h=r.getX(n+1),d=r.getX(n+2);s=Iit(this,f,t,uit,o,a,l,c,u,i,h,d),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=p.materialIndex,e.push(s))}}else for(let n=Math.max(0,d.start),p=Math.min(r.count,d.start+d.count);n<p;n+=3){const h=r.getX(n),d=r.getX(n+1),p=r.getX(n+2);s=Iit(this,i,t,uit,o,a,l,c,u,h,d,p),s&&(s.faceIndex=Math.floor(n/3),e.push(s))}else if(void 0!==o)if(Array.isArray(i))for(let n=0,p=h.length;n<p;n++){const r=h[n],p=i[r.materialIndex];for(let n=Math.max(r.start,d.start),i=Math.min(r.start+r.count,d.start+d.count);n<i;n+=3)s=Iit(this,p,t,uit,o,a,l,c,u,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=r.materialIndex,e.push(s))}else for(let n=Math.max(0,d.start),p=Math.min(o.count,d.start+d.count);n<p;n+=3)s=Iit(this,i,t,uit,o,a,l,c,u,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),e.push(s))}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}});class Tit extends lit{constructor(t=1,e=1,n=1,i=1,r=1,s=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:i,heightSegments:r,depthSegments:s};const o=this;i=Math.floor(i),r=Math.floor(r),s=Math.floor(s);const a=[],l=[],c=[],u=[];let h=0,d=0;function p(t,e,n,i,r,s,p,f,m,g,y){const v=s/m,b=p/g,A=s/2,x=p/2,w=f/2,_=m+1,S=g+1;let E=0,C=0;const I=new det;for(let o=0;o<S;o++){const s=o*b-x;for(let a=0;a<_;a++)I[t]=(a*v-A)*i,I[e]=s*r,I[n]=w,l.push(I.x,I.y,I.z),I[t]=0,I[e]=0,I[n]=f>0?1:-1,c.push(I.x,I.y,I.z),u.push(a/m),u.push(1-o/g),E+=1}for(let o=0;o<g;o++)for(let t=0;t<m;t++){const e=h+t+_*(o+1),n=h+(t+1)+_*(o+1),i=h+(t+1)+_*o;a.push(h+t+_*o,e,i),a.push(e,n,i),C+=6}o.addGroup(d,C,y),d+=C,h+=E}p("z","y","x",-1,-1,n,e,t,s,r,0),p("z","y","x",1,-1,n,e,-t,s,r,1),p("x","z","y",1,1,t,n,e,i,s,2),p("x","z","y",1,-1,t,n,-e,i,s,3),p("x","y","z",1,-1,t,e,n,i,r,4),p("x","y","z",-1,-1,t,e,-n,i,r,5),this.setIndex(a),this.setAttribute("position",new Ynt(l,3)),this.setAttribute("normal",new Ynt(c,3)),this.setAttribute("uv",new Ynt(u,2))}}function Mit(t){const e={};for(const n in t){e[n]={};for(const i in t[n]){const r=t[n][i];e[n][i]=r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture)?r.clone():Array.isArray(r)?r.slice():r}}return e}function kit(t){const e={};for(let n=0;n<t.length;n++){const i=Mit(t[n]);for(const t in i)e[t]=i[t]}return e}const Rit={clone:Mit,merge:kit};function Nit(t){Pnt.call(this),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==t&&(void 0!==t.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}function Lit(){dnt.call(this),this.type="Camera",this.matrixWorldInverse=new Uet,this.projectionMatrix=new Uet,this.projectionMatrixInverse=new Uet}function Dit(t=50,e=1,n=.1,i=2e3){Lit.call(this),this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}(Nit.prototype=Object.create(Pnt.prototype)).constructor=Nit,Nit.prototype.isShaderMaterial=!0,Nit.prototype.copy=function(t){return Pnt.prototype.copy.call(this,t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=Mit(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.lights=t.lights,this.clipping=t.clipping,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this},Nit.prototype.toJSON=function(t){const e=Pnt.prototype.toJSON.call(this,t);e.glslVersion=this.glslVersion,e.uniforms={};for(const i in this.uniforms){const n=this.uniforms[i].value;e.uniforms[i]=n&&n.isTexture?{type:"t",value:n.toJSON(t).uuid}:n&&n.isColor?{type:"c",value:n.getHex()}:n&&n.isVector2?{type:"v2",value:n.toArray()}:n&&n.isVector3?{type:"v3",value:n.toArray()}:n&&n.isVector4?{type:"v4",value:n.toArray()}:n&&n.isMatrix3?{type:"m3",value:n.toArray()}:n&&n.isMatrix4?{type:"m4",value:n.toArray()}:{value:n}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const n={};for(const i in this.extensions)!0===this.extensions[i]&&(n[i]=!0);return Object.keys(n).length>0&&(e.extensions=n),e},Lit.prototype=Object.assign(Object.create(dnt.prototype),{constructor:Lit,isCamera:!0,copy:function(t,e){return dnt.prototype.copy.call(this,t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this},getWorldDirection:function(t){void 0===t&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),t=new det),this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()},updateMatrixWorld:function(t){dnt.prototype.updateMatrixWorld.call(this,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()},updateWorldMatrix:function(t,e){dnt.prototype.updateWorldMatrix.call(this,t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()},clone:function(){return(new this.constructor).copy(this)}}),Dit.prototype=Object.assign(Object.create(Lit.prototype),{constructor:Dit,isPerspectiveCamera:!0,copy:function(t,e){return Lit.prototype.copy.call(this,t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=null===t.view?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this},setFocalLength:function(t){const e=.5*this.getFilmHeight()/t;this.fov=2*tet.RAD2DEG*Math.atan(e),this.updateProjectionMatrix()},getFocalLength:function(){const t=Math.tan(.5*tet.DEG2RAD*this.fov);return.5*this.getFilmHeight()/t},getEffectiveFOV:function(){return 2*tet.RAD2DEG*Math.atan(Math.tan(.5*tet.DEG2RAD*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(t,e,n,i,r,s){this.aspect=t/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const t=this.near;let e=t*Math.tan(.5*tet.DEG2RAD*this.fov)/this.zoom,n=2*e,i=this.aspect*n,r=-.5*i;const s=this.view;if(null!==this.view&&this.view.enabled){const t=s.fullWidth,o=s.fullHeight;r+=s.offsetX*i/t,e-=s.offsetY*n/o,i*=s.width/t,n*=s.height/o}const o=this.filmOffset;0!==o&&(r+=t*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,e,e-n,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(t){const e=dnt.prototype.toJSON.call(this,t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}});const Bit=90;function Oit(t,e,n){if(dnt.call(this),this.type="CubeCamera",!0!==n.isWebGLCubeRenderTarget)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=n;const i=new Dit(Bit,1,t,e);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new det(1,0,0)),this.add(i);const r=new Dit(Bit,1,t,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new det(-1,0,0)),this.add(r);const s=new Dit(Bit,1,t,e);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(new det(0,1,0)),this.add(s);const o=new Dit(Bit,1,t,e);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new det(0,-1,0)),this.add(o);const a=new Dit(Bit,1,t,e);a.layers=this.layers,a.up.set(0,-1,0),a.lookAt(new det(0,0,1)),this.add(a);const l=new Dit(Bit,1,t,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new det(0,0,-1)),this.add(l),this.update=function(t,e){null===this.parent&&this.updateMatrixWorld();const c=t.xr.enabled,u=t.getRenderTarget();t.xr.enabled=!1;const h=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,i),t.setRenderTarget(n,1),t.render(e,r),t.setRenderTarget(n,2),t.render(e,s),t.setRenderTarget(n,3),t.render(e,o),t.setRenderTarget(n,4),t.render(e,a),n.texture.generateMipmaps=h,t.setRenderTarget(n,5),t.render(e,l),t.setRenderTarget(u),t.xr.enabled=c}}function Pit(t,e,n,i,r,s,o,a,l,c){oet.call(this,t=void 0!==t?t:[],e=void 0!==e?e:301,n,i,r,s,o=void 0!==o?o:Ott,a,l,c),this.flipY=!1,this._needsFlipEnvMap=!0}(Oit.prototype=Object.create(dnt.prototype)).constructor=Oit,(Pit.prototype=Object.create(oet.prototype)).constructor=Pit,Pit.prototype.isCubeTexture=!0,Object.defineProperty(Pit.prototype,"images",{get:function(){return this.image},set:function(t){this.image=t}});class Fit extends uet{constructor(t,e,n){Number.isInteger(e)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),e=n),super(t,t,e),Object.defineProperty(this,"isWebGLCubeRenderTarget",{value:!0}),this.texture=new Pit(void 0,(e=e||{}).mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.format=Ptt,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n=new Tit(5,5,5),i=new Nit({name:"CubemapFromEquirect",uniforms:Mit({tEquirect:{value:null}}),vertexShader:"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",side:1,blending:0});i.uniforms.tEquirect.value=e;const r=new Cit(n,i),s=e.minFilter;return e.minFilter===ktt&&(e.minFilter=Mtt),new Oit(1,10,this).update(t,r),e.minFilter=s,r.geometry.dispose(),r.material.dispose(),this}clear(t,e,n,i){const r=t.getRenderTarget();for(let s=0;s<6;s++)t.setRenderTarget(this,s),t.clear(e,n,i);t.setRenderTarget(r)}}function $it(t,e,n,i,r,s,o,a,l,c,u,h){oet.call(this,null,s,o,a,l,c,i,r,u,h),this.image={data:t||null,width:e||1,height:n||1},this.magFilter=void 0!==l?l:Ttt,this.minFilter=void 0!==c?c:Ttt,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}($it.prototype=Object.create(oet.prototype)).constructor=$it,$it.prototype.isDataTexture=!0;const zit=new Net,Uit=new det;class Hit{constructor(t,e,n,i,r,s){this.planes=[void 0!==t?t:new gnt,void 0!==e?e:new gnt,void 0!==n?n:new gnt,void 0!==i?i:new gnt,void 0!==r?r:new gnt,void 0!==s?s:new gnt]}set(t,e,n,i,r,s){const o=this.planes;return o[0].copy(t),o[1].copy(e),o[2].copy(n),o[3].copy(i),o[4].copy(r),o[5].copy(s),this}clone(){return(new this.constructor).copy(this)}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t){const e=this.planes,n=t.elements,i=n[0],r=n[1],s=n[2],o=n[3],a=n[4],l=n[5],c=n[6],u=n[7],h=n[8],d=n[9],p=n[10],f=n[11],m=n[12],g=n[13],y=n[14],v=n[15];return e[0].setComponents(o-i,u-a,f-h,v-m).normalize(),e[1].setComponents(o+i,u+a,f+h,v+m).normalize(),e[2].setComponents(o+r,u+l,f+d,v+g).normalize(),e[3].setComponents(o-r,u-l,f-d,v-g).normalize(),e[4].setComponents(o-s,u-c,f-p,v-y).normalize(),e[5].setComponents(o+s,u+c,f+p,v+y).normalize(),this}intersectsObject(t){const e=t.geometry;return null===e.boundingSphere&&e.computeBoundingSphere(),zit.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(zit)}intersectsSprite(t){return zit.center.set(0,0,0),zit.radius=.7071067811865476,zit.applyMatrix4(t.matrixWorld),this.intersectsSphere(zit)}intersectsSphere(t){const e=this.planes,n=t.center,i=-t.radius;for(let r=0;r<6;r++)if(e[r].distanceToPoint(n)<i)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const i=e[n];if(Uit.x=i.normal.x>0?t.max.x:t.min.x,Uit.y=i.normal.y>0?t.max.y:t.min.y,Uit.z=i.normal.z>0?t.max.z:t.min.z,i.distanceToPoint(Uit)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}}function Vit(){let t=null,e=!1,n=null,i=null;function r(e,s){n(e,s),i=t.requestAnimationFrame(r)}return{start:function(){!0!==e&&null!==n&&(i=t.requestAnimationFrame(r),e=!0)},stop:function(){t.cancelAnimationFrame(i),e=!1},setAnimationLoop:function(t){n=t},setContext:function(e){t=e}}}function Git(t,e){const n=e.isWebGL2,i=new WeakMap;return{get:function(t){return t.isInterleavedBufferAttribute&&(t=t.data),i.get(t)},remove:function(e){e.isInterleavedBufferAttribute&&(e=e.data);const n=i.get(e);n&&(t.deleteBuffer(n.buffer),i.delete(e))},update:function(e,r){if(e.isGLBufferAttribute){const t=i.get(e);return void((!t||t.version<e.version)&&i.set(e,{buffer:e.buffer,type:e.type,bytesPerElement:e.elementSize,version:e.version}))}e.isInterleavedBufferAttribute&&(e=e.data);const s=i.get(e);void 0===s?i.set(e,function(e,i){const r=e.array,s=e.usage,o=t.createBuffer();t.bindBuffer(i,o),t.bufferData(i,r,s),e.onUploadCallback();let a=5126;return r instanceof Float32Array?a=5126:r instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):r instanceof Uint16Array?e.isFloat16BufferAttribute?n?a=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):a=5123:r instanceof Int16Array?a=5122:r instanceof Uint32Array?a=5125:r instanceof Int32Array?a=5124:r instanceof Int8Array?a=5120:r instanceof Uint8Array&&(a=5121),{buffer:o,type:a,bytesPerElement:r.BYTES_PER_ELEMENT,version:e.version}}(e,r)):s.version<e.version&&(function(e,i,r){const s=i.array,o=i.updateRange;t.bindBuffer(r,e),-1===o.count?t.bufferSubData(r,0,s):(n?t.bufferSubData(r,o.offset*s.BYTES_PER_ELEMENT,s,o.offset,o.count):t.bufferSubData(r,o.offset*s.BYTES_PER_ELEMENT,s.subarray(o.offset,o.offset+o.count)),o.count=-1)}(s.buffer,e,r),s.version=e.version)}}}class Wit extends lit{constructor(t=1,e=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:i};const r=t/2,s=e/2,o=Math.floor(n),a=Math.floor(i),l=o+1,c=a+1,u=t/o,h=e/a,d=[],p=[],f=[],m=[];for(let g=0;g<c;g++){const t=g*h-s;for(let e=0;e<l;e++)p.push(e*u-r,-t,0),f.push(0,0,1),m.push(e/o),m.push(1-g/a)}for(let g=0;g<a;g++)for(let t=0;t<o;t++){const e=t+l*(g+1),n=t+1+l*(g+1),i=t+1+l*g;d.push(t+l*g,e,i),d.push(e,n,i)}this.setIndex(d),this.setAttribute("position",new Ynt(p,3)),this.setAttribute("normal",new Ynt(f,3)),this.setAttribute("uv",new Ynt(m,2))}}const jit={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",normal_fragment_begin:"#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmissionmap_fragment:"#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",transmissionmap_pars_fragment:"#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",normal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",normal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"},Qit={common:{diffuse:{value:new Dnt(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new net},uv2Transform:{value:new net},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new eet(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Dnt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Dnt(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new net}},sprite:{diffuse:{value:new Dnt(15658734)},opacity:{value:1},center:{value:new eet(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new net}}},qit={basic:{uniforms:kit([Qit.common,Qit.specularmap,Qit.envmap,Qit.aomap,Qit.lightmap,Qit.fog]),vertexShader:jit.meshbasic_vert,fragmentShader:jit.meshbasic_frag},lambert:{uniforms:kit([Qit.common,Qit.specularmap,Qit.envmap,Qit.aomap,Qit.lightmap,Qit.emissivemap,Qit.fog,Qit.lights,{emissive:{value:new Dnt(0)}}]),vertexShader:jit.meshlambert_vert,fragmentShader:jit.meshlambert_frag},phong:{uniforms:kit([Qit.common,Qit.specularmap,Qit.envmap,Qit.aomap,Qit.lightmap,Qit.emissivemap,Qit.bumpmap,Qit.normalmap,Qit.displacementmap,Qit.fog,Qit.lights,{emissive:{value:new Dnt(0)},specular:{value:new Dnt(1118481)},shininess:{value:30}}]),vertexShader:jit.meshphong_vert,fragmentShader:jit.meshphong_frag},standard:{uniforms:kit([Qit.common,Qit.envmap,Qit.aomap,Qit.lightmap,Qit.emissivemap,Qit.bumpmap,Qit.normalmap,Qit.displacementmap,Qit.roughnessmap,Qit.metalnessmap,Qit.fog,Qit.lights,{emissive:{value:new Dnt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:jit.meshphysical_vert,fragmentShader:jit.meshphysical_frag},toon:{uniforms:kit([Qit.common,Qit.aomap,Qit.lightmap,Qit.emissivemap,Qit.bumpmap,Qit.normalmap,Qit.displacementmap,Qit.gradientmap,Qit.fog,Qit.lights,{emissive:{value:new Dnt(0)}}]),vertexShader:jit.meshtoon_vert,fragmentShader:jit.meshtoon_frag},matcap:{uniforms:kit([Qit.common,Qit.bumpmap,Qit.normalmap,Qit.displacementmap,Qit.fog,{matcap:{value:null}}]),vertexShader:jit.meshmatcap_vert,fragmentShader:jit.meshmatcap_frag},points:{uniforms:kit([Qit.points,Qit.fog]),vertexShader:jit.points_vert,fragmentShader:jit.points_frag},dashed:{uniforms:kit([Qit.common,Qit.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:jit.linedashed_vert,fragmentShader:jit.linedashed_frag},depth:{uniforms:kit([Qit.common,Qit.displacementmap]),vertexShader:jit.depth_vert,fragmentShader:jit.depth_frag},normal:{uniforms:kit([Qit.common,Qit.bumpmap,Qit.normalmap,Qit.displacementmap,{opacity:{value:1}}]),vertexShader:jit.normal_vert,fragmentShader:jit.normal_frag},sprite:{uniforms:kit([Qit.sprite,Qit.fog]),vertexShader:jit.sprite_vert,fragmentShader:jit.sprite_frag},background:{uniforms:{uvTransform:{value:new net},t2D:{value:null}},vertexShader:jit.background_vert,fragmentShader:jit.background_frag},cube:{uniforms:kit([Qit.envmap,{opacity:{value:1}}]),vertexShader:jit.cube_vert,fragmentShader:jit.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:jit.equirect_vert,fragmentShader:jit.equirect_frag},distanceRGBA:{uniforms:kit([Qit.common,Qit.displacementmap,{referencePosition:{value:new det},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:jit.distanceRGBA_vert,fragmentShader:jit.distanceRGBA_frag},shadow:{uniforms:kit([Qit.lights,Qit.fog,{color:{value:new Dnt(0)},opacity:{value:1}}]),vertexShader:jit.shadow_vert,fragmentShader:jit.shadow_frag}};function Xit(t,e,n,i,r){const s=new Dnt(0);let o,a,l=0,c=null,u=0,h=null;function d(t,e){n.buffers.color.setClear(t.r,t.g,t.b,e,r)}return{getClearColor:function(){return s},setClearColor:function(t,e=1){s.set(t),l=e,d(s,l)},getClearAlpha:function(){return l},setClearAlpha:function(t){l=t,d(s,l)},render:function(n,r,p,f){let m=!0===r.isScene?r.background:null;m&&m.isTexture&&(m=e.get(m));const g=t.xr,y=g.getSession&&g.getSession();y&&"additive"===y.environmentBlendMode&&(m=null),null===m?d(s,l):m&&m.isColor&&(d(m,1),f=!0),(t.autoClear||f)&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),m&&(m.isCubeTexture||m.isWebGLCubeRenderTarget||306===m.mapping)?(void 0===a&&(a=new Cit(new Tit(1,1,1),new Nit({name:"BackgroundCubeMaterial",uniforms:Mit(qit.cube.uniforms),vertexShader:qit.cube.vertexShader,fragmentShader:qit.cube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),a.geometry.deleteAttribute("uv"),a.onBeforeRender=function(t,e,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(a.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(a)),m.isWebGLCubeRenderTarget&&(m=m.texture),a.material.uniforms.envMap.value=m,a.material.uniforms.flipEnvMap.value=m.isCubeTexture&&m._needsFlipEnvMap?-1:1,c===m&&u===m.version&&h===t.toneMapping||(a.material.needsUpdate=!0,c=m,u=m.version,h=t.toneMapping),n.unshift(a,a.geometry,a.material,0,0,null)):m&&m.isTexture&&(void 0===o&&(o=new Cit(new Wit(2,2),new Nit({name:"BackgroundMaterial",uniforms:Mit(qit.background.uniforms),vertexShader:qit.background.vertexShader,fragmentShader:qit.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),Object.defineProperty(o.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(o)),o.material.uniforms.t2D.value=m,!0===m.matrixAutoUpdate&&m.updateMatrix(),o.material.uniforms.uvTransform.value.copy(m.matrix),c===m&&u===m.version&&h===t.toneMapping||(o.material.needsUpdate=!0,c=m,u=m.version,h=t.toneMapping),n.unshift(o,o.geometry,o.material,0,0,null))}}}function Yit(t,e,n,i){const r=t.getParameter(34921),s=i.isWebGL2?null:e.get("OES_vertex_array_object"),o=i.isWebGL2||null!==s,a={},l=d(null);let c=l;function u(e){return i.isWebGL2?t.bindVertexArray(e):s.bindVertexArrayOES(e)}function h(e){return i.isWebGL2?t.deleteVertexArray(e):s.deleteVertexArrayOES(e)}function d(t){const e=[],n=[],i=[];for(let s=0;s<r;s++)e[s]=0,n[s]=0,i[s]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:e,enabledAttributes:n,attributeDivisors:i,object:t,attributes:{},index:null}}function p(){const t=c.newAttributes;for(let e=0,n=t.length;e<n;e++)t[e]=0}function f(t){m(t,0)}function m(n,r){const s=c.enabledAttributes,o=c.attributeDivisors;c.newAttributes[n]=1,0===s[n]&&(t.enableVertexAttribArray(n),s[n]=1),o[n]!==r&&((i.isWebGL2?t:e.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](n,r),o[n]=r)}function g(){const e=c.newAttributes,n=c.enabledAttributes;for(let i=0,r=n.length;i<r;i++)n[i]!==e[i]&&(t.disableVertexAttribArray(i),n[i]=0)}function y(e,n,r,s,o,a){!0!==i.isWebGL2||5124!==r&&5125!==r?t.vertexAttribPointer(e,n,r,s,o,a):t.vertexAttribIPointer(e,n,r,o,a)}function v(){b(),c!==l&&(c=l,u(c.object))}function b(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:function(r,l,h,v,b){let A=!1;if(o){const e=function(e,n,r){const o=!0===r.wireframe;let l=a[e.id];void 0===l&&(l={},a[e.id]=l);let c=l[n.id];void 0===c&&(c={},l[n.id]=c);let u=c[o];return void 0===u&&(u=d(i.isWebGL2?t.createVertexArray():s.createVertexArrayOES()),c[o]=u),u}(v,h,l);c!==e&&(c=e,u(c.object)),A=function(t,e){const n=c.attributes,i=t.attributes;let r=0;for(const s in i){const t=n[s],e=i[s];if(void 0===t)return!0;if(t.attribute!==e)return!0;if(t.data!==e.data)return!0;r++}return c.attributesNum!==r||c.index!==e}(v,b),A&&function(t,e){const n={},i=t.attributes;let r=0;for(const s in i){const t=i[s],e={};e.attribute=t,t.data&&(e.data=t.data),n[s]=e,r++}c.attributes=n,c.attributesNum=r,c.index=e}(v,b)}else{const t=!0===l.wireframe;c.geometry===v.id&&c.program===h.id&&c.wireframe===t||(c.geometry=v.id,c.program=h.id,c.wireframe=t,A=!0)}!0===r.isInstancedMesh&&(A=!0),null!==b&&n.update(b,34963),A&&(function(r,s,o,a){if(!1===i.isWebGL2&&(r.isInstancedMesh||a.isInstancedBufferGeometry)&&null===e.get("ANGLE_instanced_arrays"))return;p();const l=a.attributes,c=o.getAttributes(),u=s.defaultAttributeValues;for(const e in c){const i=c[e];if(i>=0){const s=l[e];if(void 0!==s){const e=s.normalized,r=s.itemSize,o=n.get(s);if(void 0===o)continue;const l=o.buffer,c=o.type,u=o.bytesPerElement;if(s.isInterleavedBufferAttribute){const n=s.data,o=n.stride,h=s.offset;n&&n.isInstancedInterleavedBuffer?(m(i,n.meshPerAttribute),void 0===a._maxInstanceCount&&(a._maxInstanceCount=n.meshPerAttribute*n.count)):f(i),t.bindBuffer(34962,l),y(i,r,c,e,o*u,h*u)}else s.isInstancedBufferAttribute?(m(i,s.meshPerAttribute),void 0===a._maxInstanceCount&&(a._maxInstanceCount=s.meshPerAttribute*s.count)):f(i),t.bindBuffer(34962,l),y(i,r,c,e,0,0)}else if("instanceMatrix"===e){const e=n.get(r.instanceMatrix);if(void 0===e)continue;const s=e.buffer,o=e.type;m(i+0,1),m(i+1,1),m(i+2,1),m(i+3,1),t.bindBuffer(34962,s),t.vertexAttribPointer(i+0,4,o,!1,64,0),t.vertexAttribPointer(i+1,4,o,!1,64,16),t.vertexAttribPointer(i+2,4,o,!1,64,32),t.vertexAttribPointer(i+3,4,o,!1,64,48)}else if("instanceColor"===e){const e=n.get(r.instanceColor);if(void 0===e)continue;const s=e.buffer,o=e.type;m(i,1),t.bindBuffer(34962,s),t.vertexAttribPointer(i,3,o,!1,12,0)}else if(void 0!==u){const n=u[e];if(void 0!==n)switch(n.length){case 2:t.vertexAttrib2fv(i,n);break;case 3:t.vertexAttrib3fv(i,n);break;case 4:t.vertexAttrib4fv(i,n);break;default:t.vertexAttrib1fv(i,n)}}}}g()}(r,l,h,v),null!==b&&t.bindBuffer(34963,n.get(b).buffer))},reset:v,resetDefaultState:b,dispose:function(){v();for(const t in a){const e=a[t];for(const t in e){const n=e[t];for(const t in n)h(n[t].object),delete n[t];delete e[t]}delete a[t]}},releaseStatesOfGeometry:function(t){if(void 0===a[t.id])return;const e=a[t.id];for(const n in e){const t=e[n];for(const e in t)h(t[e].object),delete t[e];delete e[n]}delete a[t.id]},releaseStatesOfProgram:function(t){for(const e in a){const n=a[e];if(void 0===n[t.id])continue;const i=n[t.id];for(const t in i)h(i[t].object),delete i[t];delete n[t.id]}},initAttributes:p,enableAttribute:f,disableUnusedAttributes:g}}function Kit(t,e,n,i){const r=i.isWebGL2;let s;this.setMode=function(t){s=t},this.render=function(e,i){t.drawArrays(s,e,i),n.update(i,s,1)},this.renderInstances=function(i,o,a){if(0===a)return;let l,c;if(r)l=t,c="drawArraysInstanced";else if(l=e.get("ANGLE_instanced_arrays"),c="drawArraysInstancedANGLE",null===l)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");l[c](s,i,o,a),n.update(o,s,a)}}function Jit(t,e,n){let i;function r(e){if("highp"===e){if(t.getShaderPrecisionFormat(35633,36338).precision>0&&t.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";e="mediump"}return"mediump"===e&&t.getShaderPrecisionFormat(35633,36337).precision>0&&t.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const s="undefined"!=typeof WebGL2RenderingContext&&t instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&t instanceof WebGL2ComputeRenderingContext;let o=void 0!==n.precision?n.precision:"highp";const a=r(o);a!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",a,"instead."),o=a);const l=!0===n.logarithmicDepthBuffer,c=t.getParameter(34930),u=t.getParameter(35660),h=t.getParameter(3379),d=t.getParameter(34076),p=t.getParameter(34921),f=t.getParameter(36347),m=t.getParameter(36348),g=t.getParameter(36349),y=u>0,v=s||!!e.get("OES_texture_float");return{isWebGL2:s,getMaxAnisotropy:function(){if(void 0!==i)return i;const n=e.get("EXT_texture_filter_anisotropic");return i=null!==n?t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0,i},getMaxPrecision:r,precision:o,logarithmicDepthBuffer:l,maxTextures:c,maxVertexTextures:u,maxTextureSize:h,maxCubemapSize:d,maxAttributes:p,maxVertexUniforms:f,maxVaryings:m,maxFragmentUniforms:g,vertexTextures:y,floatFragmentTextures:v,floatVertexTextures:y&&v,maxSamples:s?t.getParameter(36183):0}}function Zit(t){const e=this;let n=null,i=0,r=!1,s=!1;const o=new gnt,a=new net,l={value:null,needsUpdate:!1};function c(){l.value!==n&&(l.value=n,l.needsUpdate=i>0),e.numPlanes=i,e.numIntersection=0}function u(t,n,i,r){const s=null!==t?t.length:0;let c=null;if(0!==s){if(c=l.value,!0!==r||null===c){const e=i+4*s,r=n.matrixWorldInverse;a.getNormalMatrix(r),(null===c||c.length<e)&&(c=new Float32Array(e));for(let n=0,l=i;n!==s;++n,l+=4)o.copy(t[n]).applyMatrix4(r,a),o.normal.toArray(c,l),c[l+3]=o.constant}l.value=c,l.needsUpdate=!0}return e.numPlanes=s,e.numIntersection=0,c}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(t,e,s){const o=0!==t.length||e||0!==i||r;return r=e,n=u(t,s,0),i=t.length,o},this.beginShadows=function(){s=!0,u(null)},this.endShadows=function(){s=!1,c()},this.setState=function(e,o,a){const h=e.clippingPlanes,d=e.clipIntersection,p=e.clipShadows,f=t.get(e);if(!r||null===h||0===h.length||s&&!p)s?u(null):c();else{const t=s?0:i,e=4*t;let r=f.clippingState||null;l.value=r,r=u(h,o,e,a);for(let i=0;i!==e;++i)r[i]=n[i];f.clippingState=r,this.numIntersection=d?this.numPlanes:0,this.numPlanes+=t}}}function trt(t){let e=new WeakMap;function n(t,e){return 303===e?t.mapping=301:304===e&&(t.mapping=302),t}function i(t){const n=t.target;n.removeEventListener("dispose",i);const r=e.get(n);void 0!==r&&(e.delete(n),r.dispose())}return{get:function(r){if(r&&r.isTexture){const s=r.mapping;if(303===s||304===s){if(e.has(r))return n(e.get(r).texture,r.mapping);{const s=r.image;if(s&&s.height>0){const o=t.getRenderList(),a=t.getRenderTarget(),l=new Fit(s.height/2);return l.fromEquirectangularTexture(t,r),e.set(r,l),t.setRenderTarget(a),t.setRenderList(o),r.addEventListener("dispose",i),n(l.texture,r.mapping)}return null}}}return r},dispose:function(){e=new WeakMap}}}function ert(t){const e={};function n(n){if(void 0!==e[n])return e[n];let i;switch(n){case"WEBGL_depth_texture":i=t.getExtension("WEBGL_depth_texture")||t.getExtension("MOZ_WEBGL_depth_texture")||t.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=t.getExtension("WEBGL_compressed_texture_s3tc")||t.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=t.getExtension("WEBGL_compressed_texture_pvrtc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=t.getExtension(n)}return e[n]=i,i}return{has:function(t){return null!==n(t)},init:function(t){t.isWebGL2?n("EXT_color_buffer_float"):(n("WEBGL_depth_texture"),n("OES_texture_float"),n("OES_texture_half_float"),n("OES_texture_half_float_linear"),n("OES_standard_derivatives"),n("OES_element_index_uint"),n("OES_vertex_array_object"),n("ANGLE_instanced_arrays")),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float")},get:function(t){const e=n(t);return null===e&&console.warn("THREE.WebGLRenderer: "+t+" extension not supported."),e}}}function nrt(t,e,n,i){const r={},s=new WeakMap;function o(t){const a=t.target;null!==a.index&&e.remove(a.index);for(const n in a.attributes)e.remove(a.attributes[n]);a.removeEventListener("dispose",o),delete r[a.id];const l=s.get(a);l&&(e.remove(l),s.delete(a)),i.releaseStatesOfGeometry(a),!0===a.isInstancedBufferGeometry&&delete a._maxInstanceCount,n.memory.geometries--}function a(t){const n=[],i=t.index,r=t.attributes.position;let o=0;if(null!==i){const t=i.array;o=i.version;for(let e=0,i=t.length;e<i;e+=3){const i=t[e+0],r=t[e+1],s=t[e+2];n.push(i,r,r,s,s,i)}}else{o=r.version;for(let t=0,e=r.array.length/3-1;t<e;t+=3){const e=t+0,i=t+1,r=t+2;n.push(e,i,i,r,r,e)}}const a=new(Jnt(n)>65535?qnt:jnt)(n,1);a.version=o;const l=s.get(t);l&&e.remove(l),s.set(t,a)}return{get:function(t,e){return!0===r[e.id]||(e.addEventListener("dispose",o),r[e.id]=!0,n.memory.geometries++),e},update:function(t){const n=t.attributes;for(const r in n)e.update(n[r],34962);const i=t.morphAttributes;for(const r in i){const t=i[r];for(let n=0,i=t.length;n<i;n++)e.update(t[n],34962)}},getWireframeAttribute:function(t){const e=s.get(t);if(e){const n=t.index;null!==n&&e.version<n.version&&a(t)}else a(t);return s.get(t)}}}function irt(t,e,n,i){const r=i.isWebGL2;let s,o,a;this.setMode=function(t){s=t},this.setIndex=function(t){o=t.type,a=t.bytesPerElement},this.render=function(e,i){t.drawElements(s,i,o,e*a),n.update(i,s,1)},this.renderInstances=function(i,l,c){if(0===c)return;let u,h;if(r)u=t,h="drawElementsInstanced";else if(u=e.get("ANGLE_instanced_arrays"),h="drawElementsInstancedANGLE",null===u)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");u[h](s,l,o,i*a,c),n.update(l,s,c)}}function rrt(t){const e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(t,n,i){switch(e.calls++,n){case 4:e.triangles+=i*(t/3);break;case 1:e.lines+=i*(t/2);break;case 3:e.lines+=i*(t-1);break;case 2:e.lines+=i*t;break;case 0:e.points+=i*t;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",n)}}}}function srt(t,e){return t[0]-e[0]}function ort(t,e){return Math.abs(e[1])-Math.abs(t[1])}function art(t){const e={},n=new Float32Array(8),i=[];for(let r=0;r<8;r++)i[r]=[r,0];return{update:function(r,s,o,a){const l=r.morphTargetInfluences,c=void 0===l?0:l.length;let u=e[s.id];if(void 0===u){u=[];for(let t=0;t<c;t++)u[t]=[t,0];e[s.id]=u}for(let t=0;t<c;t++){const e=u[t];e[0]=t,e[1]=l[t]}u.sort(ort);for(let t=0;t<8;t++)t<c&&u[t][1]?(i[t][0]=u[t][0],i[t][1]=u[t][1]):(i[t][0]=Number.MAX_SAFE_INTEGER,i[t][1]=0);i.sort(srt);const h=o.morphTargets&&s.morphAttributes.position,d=o.morphNormals&&s.morphAttributes.normal;let p=0;for(let t=0;t<8;t++){const e=i[t],r=e[0],o=e[1];r!==Number.MAX_SAFE_INTEGER&&o?(h&&s.getAttribute("morphTarget"+t)!==h[r]&&s.setAttribute("morphTarget"+t,h[r]),d&&s.getAttribute("morphNormal"+t)!==d[r]&&s.setAttribute("morphNormal"+t,d[r]),n[t]=o,p+=o):(h&&!0===s.hasAttribute("morphTarget"+t)&&s.deleteAttribute("morphTarget"+t),d&&!0===s.hasAttribute("morphNormal"+t)&&s.deleteAttribute("morphNormal"+t),n[t]=0)}const f=s.morphTargetsRelative?1:1-p;a.getUniforms().setValue(t,"morphTargetBaseInfluence",f),a.getUniforms().setValue(t,"morphTargetInfluences",n)}}}function lrt(t,e,n,i){let r=new WeakMap;function s(t){const e=t.target;e.removeEventListener("dispose",s),n.remove(e.instanceMatrix),null!==e.instanceColor&&n.remove(e.instanceColor)}return{update:function(t){const o=i.render.frame,a=e.get(t,t.geometry);return r.get(a)!==o&&(e.update(a),r.set(a,o)),t.isInstancedMesh&&(!1===t.hasEventListener("dispose",s)&&t.addEventListener("dispose",s),n.update(t.instanceMatrix,34962),null!==t.instanceColor&&n.update(t.instanceColor,34962)),a},dispose:function(){r=new WeakMap}}}function crt(t=null,e=1,n=1,i=1){oet.call(this,null),this.image={data:t,width:e,height:n,depth:i},this.magFilter=Ttt,this.minFilter=Ttt,this.wrapR=Ctt,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}function urt(t=null,e=1,n=1,i=1){oet.call(this,null),this.image={data:t,width:e,height:n,depth:i},this.magFilter=Ttt,this.minFilter=Ttt,this.wrapR=Ctt,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}qit.physical={uniforms:kit([qit.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new eet(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new Dnt(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:jit.meshphysical_vert,fragmentShader:jit.meshphysical_frag},(crt.prototype=Object.create(oet.prototype)).constructor=crt,crt.prototype.isDataTexture2DArray=!0,(urt.prototype=Object.create(oet.prototype)).constructor=urt,urt.prototype.isDataTexture3D=!0;const hrt=new oet,drt=new crt,prt=new urt,frt=new Pit,mrt=[],grt=[],yrt=new Float32Array(16),vrt=new Float32Array(9),brt=new Float32Array(4);function Art(t,e,n){const i=t[0];if(i<=0||i>0)return t;const r=e*n;let s=mrt[r];if(void 0===s&&(s=new Float32Array(r),mrt[r]=s),0!==e){i.toArray(s,0);for(let i=1,r=0;i!==e;++i)r+=n,t[i].toArray(s,r)}return s}function xrt(t,e){if(t.length!==e.length)return!1;for(let n=0,i=t.length;n<i;n++)if(t[n]!==e[n])return!1;return!0}function wrt(t,e){for(let n=0,i=e.length;n<i;n++)t[n]=e[n]}function _rt(t,e){let n=grt[e];void 0===n&&(n=new Int32Array(e),grt[e]=n);for(let i=0;i!==e;++i)n[i]=t.allocateTextureUnit();return n}function Srt(t,e){const n=this.cache;n[0]!==e&&(t.uniform1f(this.addr,e),n[0]=e)}function Ert(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2f(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(xrt(n,e))return;t.uniform2fv(this.addr,e),wrt(n,e)}}function Crt(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3f(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else if(void 0!==e.r)n[0]===e.r&&n[1]===e.g&&n[2]===e.b||(t.uniform3f(this.addr,e.r,e.g,e.b),n[0]=e.r,n[1]=e.g,n[2]=e.b);else{if(xrt(n,e))return;t.uniform3fv(this.addr,e),wrt(n,e)}}function Irt(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4f(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(xrt(n,e))return;t.uniform4fv(this.addr,e),wrt(n,e)}}function Trt(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(xrt(n,e))return;t.uniformMatrix2fv(this.addr,!1,e),wrt(n,e)}else{if(xrt(n,i))return;brt.set(i),t.uniformMatrix2fv(this.addr,!1,brt),wrt(n,i)}}function Mrt(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(xrt(n,e))return;t.uniformMatrix3fv(this.addr,!1,e),wrt(n,e)}else{if(xrt(n,i))return;vrt.set(i),t.uniformMatrix3fv(this.addr,!1,vrt),wrt(n,i)}}function krt(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(xrt(n,e))return;t.uniformMatrix4fv(this.addr,!1,e),wrt(n,e)}else{if(xrt(n,i))return;yrt.set(i),t.uniformMatrix4fv(this.addr,!1,yrt),wrt(n,i)}}function Rrt(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.safeSetTexture2D(e||hrt,r)}function Nrt(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTexture2DArray(e||drt,r)}function Lrt(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTexture3D(e||prt,r)}function Drt(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.safeSetTextureCube(e||frt,r)}function Brt(t,e){const n=this.cache;n[0]!==e&&(t.uniform1i(this.addr,e),n[0]=e)}function Ort(t,e){const n=this.cache;xrt(n,e)||(t.uniform2iv(this.addr,e),wrt(n,e))}function Prt(t,e){const n=this.cache;xrt(n,e)||(t.uniform3iv(this.addr,e),wrt(n,e))}function Frt(t,e){const n=this.cache;xrt(n,e)||(t.uniform4iv(this.addr,e),wrt(n,e))}function $rt(t,e){const n=this.cache;n[0]!==e&&(t.uniform1ui(this.addr,e),n[0]=e)}function zrt(t,e){t.uniform1fv(this.addr,e)}function Urt(t,e){t.uniform1iv(this.addr,e)}function Hrt(t,e){t.uniform2iv(this.addr,e)}function Vrt(t,e){t.uniform3iv(this.addr,e)}function Grt(t,e){t.uniform4iv(this.addr,e)}function Wrt(t,e){const n=Art(e,this.size,2);t.uniform2fv(this.addr,n)}function jrt(t,e){const n=Art(e,this.size,3);t.uniform3fv(this.addr,n)}function Qrt(t,e){const n=Art(e,this.size,4);t.uniform4fv(this.addr,n)}function qrt(t,e){const n=Art(e,this.size,4);t.uniformMatrix2fv(this.addr,!1,n)}function Xrt(t,e){const n=Art(e,this.size,9);t.uniformMatrix3fv(this.addr,!1,n)}function Yrt(t,e){const n=Art(e,this.size,16);t.uniformMatrix4fv(this.addr,!1,n)}function Krt(t,e,n){const i=e.length,r=_rt(n,i);t.uniform1iv(this.addr,r);for(let s=0;s!==i;++s)n.safeSetTexture2D(e[s]||hrt,r[s])}function Jrt(t,e,n){const i=e.length,r=_rt(n,i);t.uniform1iv(this.addr,r);for(let s=0;s!==i;++s)n.safeSetTextureCube(e[s]||frt,r[s])}function Zrt(t,e,n){this.id=t,this.addr=n,this.cache=[],this.setValue=function(t){switch(t){case 5126:return Srt;case 35664:return Ert;case 35665:return Crt;case 35666:return Irt;case 35674:return Trt;case 35675:return Mrt;case 35676:return krt;case 5124:case 35670:return Brt;case 35667:case 35671:return Ort;case 35668:case 35672:return Prt;case 35669:case 35673:return Frt;case 5125:return $rt;case 35678:case 36198:case 36298:case 36306:case 35682:return Rrt;case 35679:case 36299:case 36307:return Lrt;case 35680:case 36300:case 36308:case 36293:return Drt;case 36289:case 36303:case 36311:case 36292:return Nrt}}(e.type)}function tst(t,e,n){this.id=t,this.addr=n,this.cache=[],this.size=e.size,this.setValue=function(t){switch(t){case 5126:return zrt;case 35664:return Wrt;case 35665:return jrt;case 35666:return Qrt;case 35674:return qrt;case 35675:return Xrt;case 35676:return Yrt;case 5124:case 35670:return Urt;case 35667:case 35671:return Hrt;case 35668:case 35672:return Vrt;case 35669:case 35673:return Grt;case 35678:case 36198:case 36298:case 36306:case 35682:return Krt;case 35680:case 36300:case 36308:case 36293:return Jrt}}(e.type)}function est(t){this.id=t,this.seq=[],this.map={}}tst.prototype.updateCache=function(t){const e=this.cache;t instanceof Float32Array&&e.length!==t.length&&(this.cache=new Float32Array(t.length)),wrt(e,t)},est.prototype.setValue=function(t,e,n){const i=this.seq;for(let r=0,s=i.length;r!==s;++r){const s=i[r];s.setValue(t,e[s.id],n)}};const nst=/(\w+)(\])?(\[|\.)?/g;function ist(t,e){t.seq.push(e),t.map[e.id]=e}function rst(t,e,n){const i=t.name,r=i.length;for(nst.lastIndex=0;;){const s=nst.exec(i),o=nst.lastIndex;let a=s[1];const l=s[3];if("]"===s[2]&&(a|=0),void 0===l||"["===l&&o+2===r){ist(n,void 0===l?new Zrt(a,t,e):new tst(a,t,e));break}{let t=n.map[a];void 0===t&&(t=new est(a),ist(n,t)),n=t}}}function sst(t,e){this.seq=[],this.map={};const n=t.getProgramParameter(e,35718);for(let i=0;i<n;++i){const n=t.getActiveUniform(e,i);rst(n,t.getUniformLocation(e,n.name),this)}}function ost(t,e,n){const i=t.createShader(e);return t.shaderSource(i,n),t.compileShader(i),i}sst.prototype.setValue=function(t,e,n,i){const r=this.map[e];void 0!==r&&r.setValue(t,n,i)},sst.prototype.setOptional=function(t,e,n){const i=e[n];void 0!==i&&this.setValue(t,n,i)},sst.upload=function(t,e,n,i){for(let r=0,s=e.length;r!==s;++r){const s=e[r],o=n[s.id];!1!==o.needsUpdate&&s.setValue(t,o.value,i)}},sst.seqWithValue=function(t,e){const n=[];for(let i=0,r=t.length;i!==r;++i){const r=t[i];r.id in e&&n.push(r)}return n};let ast=0;function lst(t){switch(t){case jtt:return["Linear","( value )"];case 3001:return["sRGB","( value )"];case 3002:return["RGBE","( value )"];case 3004:return["RGBM","( value, 7.0 )"];case 3005:return["RGBM","( value, 16.0 )"];case 3006:return["RGBD","( value, 256.0 )"];case 3007:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case 3003:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",t),["Linear","( value )"]}}function cst(t,e,n){const i=t.getShaderParameter(e,35713),r=t.getShaderInfoLog(e).trim();return i&&""===r?"":"THREE.WebGLShader: gl.getShaderInfoLog() "+n+"\n"+r+function(t){const e=t.split("\n");for(let n=0;n<e.length;n++)e[n]=n+1+": "+e[n];return e.join("\n")}(t.getShaderSource(e))}function ust(t,e){const n=lst(e);return"vec4 "+t+"( vec4 value ) { return "+n[0]+"ToLinear"+n[1]+"; }"}function hst(t,e){const n=lst(e);return"vec4 "+t+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function dst(t,e){let n;switch(e){case 1:n="Linear";break;case 2:n="Reinhard";break;case 3:n="OptimizedCineon";break;case 4:n="ACESFilmic";break;case 5:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),n="Linear"}return"vec3 "+t+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function pst(t){return""!==t}function fst(t,e){return t.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function mst(t,e){return t.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const gst=/^[ \t]*#include +<([\w\d./]+)>/gm;function yst(t){return t.replace(gst,vst)}function vst(t,e){const n=jit[e];if(void 0===n)throw new Error("Can not resolve #include <"+e+">");return yst(n)}const bst=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Ast=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function xst(t){return t.replace(Ast,_st).replace(bst,wst)}function wst(t,e,n,i){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),_st(0,e,n,i)}function _st(t,e,n,i){let r="";for(let s=parseInt(e);s<parseInt(n);s++)r+=i.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return r}function Sst(t){let e="precision "+t.precision+" float;\nprecision "+t.precision+" int;";return"highp"===t.precision?e+="\n#define HIGH_PRECISION":"mediump"===t.precision?e+="\n#define MEDIUM_PRECISION":"lowp"===t.precision&&(e+="\n#define LOW_PRECISION"),e}function Est(t,e,n,i){const r=t.getContext(),s=n.defines;let o=n.vertexShader,a=n.fragmentShader;const l=function(t){let e="SHADOWMAP_TYPE_BASIC";return 1===t.shadowMapType?e="SHADOWMAP_TYPE_PCF":2===t.shadowMapType?e="SHADOWMAP_TYPE_PCF_SOFT":3===t.shadowMapType&&(e="SHADOWMAP_TYPE_VSM"),e}(n),c=function(t){let e="ENVMAP_TYPE_CUBE";if(t.envMap)switch(t.envMapMode){case 301:case 302:e="ENVMAP_TYPE_CUBE";break;case 306:case 307:e="ENVMAP_TYPE_CUBE_UV"}return e}(n),u=function(t){let e="ENVMAP_MODE_REFLECTION";if(t.envMap)switch(t.envMapMode){case 302:case 307:e="ENVMAP_MODE_REFRACTION"}return e}(n),h=function(t){let e="ENVMAP_BLENDING_NONE";if(t.envMap)switch(t.combine){case 0:e="ENVMAP_BLENDING_MULTIPLY";break;case 1:e="ENVMAP_BLENDING_MIX";break;case 2:e="ENVMAP_BLENDING_ADD"}return e}(n),d=t.gammaFactor>0?t.gammaFactor:1,p=n.isWebGL2?"":function(t){return[t.extensionDerivatives||t.envMapCubeUV||t.bumpMap||t.tangentSpaceNormalMap||t.clearcoatNormalMap||t.flatShading||"physical"===t.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(t.extensionFragDepth||t.logarithmicDepthBuffer)&&t.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",t.extensionDrawBuffers&&t.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(t.extensionShaderTextureLOD||t.envMap)&&t.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(pst).join("\n")}(n),f=function(t){const e=[];for(const n in t){const i=t[n];!1!==i&&e.push("#define "+n+" "+i)}return e.join("\n")}(s),m=r.createProgram();let g,y,v=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(g=[f].filter(pst).join("\n"),g.length>0&&(g+="\n"),y=[p,f].filter(pst).join("\n"),y.length>0&&(y+="\n")):(g=[Sst(n),"#define SHADER_NAME "+n.shaderName,f,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+d,"#define MAX_BONES "+n.maxBones,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+u:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.useVertexTexture?"#define BONE_TEXTURE":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#ifdef USE_COLOR","\tattribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(pst).join("\n"),y=[p,Sst(n),"#define SHADER_NAME "+n.shaderName,f,n.alphaTest?"#define ALPHATEST "+n.alphaTest+(n.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+d,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+c:"",n.envMap?"#define "+u:"",n.envMap?"#define "+h:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.sheen?"#define USE_SHEEN":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==n.toneMapping?"#define TONE_MAPPING":"",0!==n.toneMapping?jit.tonemapping_pars_fragment:"",0!==n.toneMapping?dst("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",jit.encodings_pars_fragment,n.map?ust("mapTexelToLinear",n.mapEncoding):"",n.matcap?ust("matcapTexelToLinear",n.matcapEncoding):"",n.envMap?ust("envMapTexelToLinear",n.envMapEncoding):"",n.emissiveMap?ust("emissiveMapTexelToLinear",n.emissiveMapEncoding):"",n.lightMap?ust("lightMapTexelToLinear",n.lightMapEncoding):"",hst("linearToOutputTexel",n.outputEncoding),n.depthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(pst).join("\n")),o=yst(o),o=fst(o,n),o=mst(o,n),a=yst(a),a=fst(a,n),a=mst(a,n),o=xst(o),a=xst(a),n.isWebGL2&&!0!==n.isRawShaderMaterial&&(v="#version 300 es\n",g=["#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+g,y=["#define varying in",n.glslVersion===Ytt?"":"out highp vec4 pc_fragColor;",n.glslVersion===Ytt?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+y);const b=v+y+a,A=ost(r,35633,v+g+o),x=ost(r,35632,b);if(r.attachShader(m,A),r.attachShader(m,x),void 0!==n.index0AttributeName?r.bindAttribLocation(m,0,n.index0AttributeName):!0===n.morphTargets&&r.bindAttribLocation(m,0,"position"),r.linkProgram(m),t.debug.checkShaderErrors){const t=r.getProgramInfoLog(m).trim(),e=r.getShaderInfoLog(A).trim(),n=r.getShaderInfoLog(x).trim();let i=!0,s=!0;if(!1===r.getProgramParameter(m,35714)){i=!1;const e=cst(r,A,"vertex"),n=cst(r,x,"fragment");console.error("THREE.WebGLProgram: shader error: ",r.getError(),"35715",r.getProgramParameter(m,35715),"gl.getProgramInfoLog",t,e,n)}else""!==t?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",t):""!==e&&""!==n||(s=!1);s&&(this.diagnostics={runnable:i,programLog:t,vertexShader:{log:e,prefix:g},fragmentShader:{log:n,prefix:y}})}let w,_;return r.deleteShader(A),r.deleteShader(x),this.getUniforms=function(){return void 0===w&&(w=new sst(r,m)),w},this.getAttributes=function(){return void 0===_&&(_=function(t,e){const n={},i=t.getProgramParameter(e,35721);for(let r=0;r<i;r++){const i=t.getActiveAttrib(e,r).name;n[i]=t.getAttribLocation(e,i)}return n}(r,m)),_},this.destroy=function(){i.releaseStatesOfProgram(this),r.deleteProgram(m),this.program=void 0},this.name=n.shaderName,this.id=ast++,this.cacheKey=e,this.usedTimes=1,this.program=m,this.vertexShader=A,this.fragmentShader=x,this}function Cst(t,e,n,i,r,s){const o=[],a=i.isWebGL2,l=i.logarithmicDepthBuffer,c=i.floatVertexTextures,u=i.maxVertexUniforms,h=i.vertexTextures;let d=i.precision;const p={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},f=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function m(t){let e;return t&&t.isTexture?e=t.encoding:t&&t.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),e=t.texture.encoding):e=jtt,e}return{getParameters:function(r,o,f,g,y){const v=g.fog,b=e.get(r.envMap||(r.isMeshStandardMaterial?g.environment:null)),A=p[r.type],x=y.isSkinnedMesh?function(t){const e=t.skeleton.bones;if(c)return 1024;{const t=Math.floor((u-20)/4),n=Math.min(t,e.length);return n<e.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+e.length+" bones. This GPU supports "+n+"."),0):n}}(y):0;let w,_;if(null!==r.precision&&(d=i.getMaxPrecision(r.precision),d!==r.precision&&console.warn("THREE.WebGLProgram.getParameters:",r.precision,"not supported, using",d,"instead.")),A){const t=qit[A];w=t.vertexShader,_=t.fragmentShader}else w=r.vertexShader,_=r.fragmentShader;const S=t.getRenderTarget();return{isWebGL2:a,shaderID:A,shaderName:r.type,vertexShader:w,fragmentShader:_,defines:r.defines,isRawShaderMaterial:!0===r.isRawShaderMaterial,glslVersion:r.glslVersion,precision:d,instancing:!0===y.isInstancedMesh,instancingColor:!0===y.isInstancedMesh&&null!==y.instanceColor,supportsVertexTextures:h,outputEncoding:null!==S?m(S.texture):t.outputEncoding,map:!!r.map,mapEncoding:m(r.map),matcap:!!r.matcap,matcapEncoding:m(r.matcap),envMap:!!b,envMapMode:b&&b.mapping,envMapEncoding:m(b),envMapCubeUV:!!b&&(306===b.mapping||307===b.mapping),lightMap:!!r.lightMap,lightMapEncoding:m(r.lightMap),aoMap:!!r.aoMap,emissiveMap:!!r.emissiveMap,emissiveMapEncoding:m(r.emissiveMap),bumpMap:!!r.bumpMap,normalMap:!!r.normalMap,objectSpaceNormalMap:1===r.normalMapType,tangentSpaceNormalMap:0===r.normalMapType,clearcoatMap:!!r.clearcoatMap,clearcoatRoughnessMap:!!r.clearcoatRoughnessMap,clearcoatNormalMap:!!r.clearcoatNormalMap,displacementMap:!!r.displacementMap,roughnessMap:!!r.roughnessMap,metalnessMap:!!r.metalnessMap,specularMap:!!r.specularMap,alphaMap:!!r.alphaMap,gradientMap:!!r.gradientMap,sheen:!!r.sheen,transmissionMap:!!r.transmissionMap,combine:r.combine,vertexTangents:r.normalMap&&r.vertexTangents,vertexColors:r.vertexColors,vertexUvs:!!(r.map||r.bumpMap||r.normalMap||r.specularMap||r.alphaMap||r.emissiveMap||r.roughnessMap||r.metalnessMap||r.clearcoatMap||r.clearcoatRoughnessMap||r.clearcoatNormalMap||r.displacementMap||r.transmissionMap),uvsVertexOnly:!(r.map||r.bumpMap||r.normalMap||r.specularMap||r.alphaMap||r.emissiveMap||r.roughnessMap||r.metalnessMap||r.clearcoatNormalMap||r.transmissionMap||!r.displacementMap),fog:!!v,useFog:r.fog,fogExp2:v&&v.isFogExp2,flatShading:r.flatShading,sizeAttenuation:r.sizeAttenuation,logarithmicDepthBuffer:l,skinning:r.skinning&&x>0,maxBones:x,useVertexTexture:c,morphTargets:r.morphTargets,morphNormals:r.morphNormals,maxMorphTargets:t.maxMorphTargets,maxMorphNormals:t.maxMorphNormals,numDirLights:o.directional.length,numPointLights:o.point.length,numSpotLights:o.spot.length,numRectAreaLights:o.rectArea.length,numHemiLights:o.hemi.length,numDirLightShadows:o.directionalShadowMap.length,numPointLightShadows:o.pointShadowMap.length,numSpotLightShadows:o.spotShadowMap.length,numClippingPlanes:s.numPlanes,numClipIntersection:s.numIntersection,dithering:r.dithering,shadowMapEnabled:t.shadowMap.enabled&&f.length>0,shadowMapType:t.shadowMap.type,toneMapping:r.toneMapped?t.toneMapping:0,physicallyCorrectLights:t.physicallyCorrectLights,premultipliedAlpha:r.premultipliedAlpha,alphaTest:r.alphaTest,doubleSided:2===r.side,flipSided:1===r.side,depthPacking:void 0!==r.depthPacking&&r.depthPacking,index0AttributeName:r.index0AttributeName,extensionDerivatives:r.extensions&&r.extensions.derivatives,extensionFragDepth:r.extensions&&r.extensions.fragDepth,extensionDrawBuffers:r.extensions&&r.extensions.drawBuffers,extensionShaderTextureLOD:r.extensions&&r.extensions.shaderTextureLOD,rendererExtensionFragDepth:a||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:a||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:a||n.has("EXT_shader_texture_lod"),customProgramCacheKey:r.customProgramCacheKey()}},getProgramCacheKey:function(e){const n=[];if(e.shaderID?n.push(e.shaderID):(n.push(e.fragmentShader),n.push(e.vertexShader)),void 0!==e.defines)for(const t in e.defines)n.push(t),n.push(e.defines[t]);if(!1===e.isRawShaderMaterial){for(let t=0;t<f.length;t++)n.push(e[f[t]]);n.push(t.outputEncoding),n.push(t.gammaFactor)}return n.push(e.customProgramCacheKey),n.join()},getUniforms:function(t){const e=p[t.type];let n;return n=e?Rit.clone(qit[e].uniforms):t.uniforms,n},acquireProgram:function(e,n){let i;for(let t=0,r=o.length;t<r;t++){const e=o[t];if(e.cacheKey===n){i=e,++i.usedTimes;break}}return void 0===i&&(i=new Est(t,n,e,r),o.push(i)),i},releaseProgram:function(t){if(0==--t.usedTimes){const e=o.indexOf(t);o[e]=o[o.length-1],o.pop(),t.destroy()}},programs:o}}function Ist(){let t=new WeakMap;return{get:function(e){let n=t.get(e);return void 0===n&&(n={},t.set(e,n)),n},remove:function(e){t.delete(e)},update:function(e,n,i){t.get(e)[n]=i},dispose:function(){t=new WeakMap}}}function Tst(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.program!==e.program?t.program.id-e.program.id:t.material.id!==e.material.id?t.material.id-e.material.id:t.z!==e.z?t.z-e.z:t.id-e.id}function Mst(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.id-e.id}function kst(t){const e=[];let n=0;const i=[],r=[],s={id:-1};function o(i,r,o,a,l,c){let u=e[n];const h=t.get(o);return void 0===u?(u={id:i.id,object:i,geometry:r,material:o,program:h.program||s,groupOrder:a,renderOrder:i.renderOrder,z:l,group:c},e[n]=u):(u.id=i.id,u.object=i,u.geometry=r,u.material=o,u.program=h.program||s,u.groupOrder=a,u.renderOrder=i.renderOrder,u.z=l,u.group=c),n++,u}return{opaque:i,transparent:r,init:function(){n=0,i.length=0,r.length=0},push:function(t,e,n,s,a,l){const c=o(t,e,n,s,a,l);(!0===n.transparent?r:i).push(c)},unshift:function(t,e,n,s,a,l){const c=o(t,e,n,s,a,l);(!0===n.transparent?r:i).unshift(c)},finish:function(){for(let t=n,i=e.length;t<i;t++){const n=e[t];if(null===n.id)break;n.id=null,n.object=null,n.geometry=null,n.material=null,n.program=null,n.group=null}},sort:function(t,e){i.length>1&&i.sort(t||Tst),r.length>1&&r.sort(e||Mst)}}}function Rst(t){let e=new WeakMap;return{get:function(n,i){const r=e.get(n);let s;return void 0===r?(s=new kst(t),e.set(n,new WeakMap),e.get(n).set(i,s)):(s=r.get(i),void 0===s&&(s=new kst(t),r.set(i,s))),s},dispose:function(){e=new WeakMap}}}function Nst(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":n={direction:new det,color:new Dnt};break;case"SpotLight":n={position:new det,direction:new det,color:new Dnt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new det,color:new Dnt,distance:0,decay:0};break;case"HemisphereLight":n={direction:new det,skyColor:new Dnt,groundColor:new Dnt};break;case"RectAreaLight":n={color:new Dnt,position:new det,halfWidth:new det,halfHeight:new det}}return t[e.id]=n,n}}}let Lst=0;function Dst(t,e){return(e.castShadow?1:0)-(t.castShadow?1:0)}function Bst(t,e){const n=new Nst,i=function(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new eet};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new eet,shadowCameraNear:1,shadowCameraFar:1e3}}return t[e.id]=n,n}}}(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let l=0;l<9;l++)r.probe.push(new det);const s=new det,o=new Uet,a=new Uet;return{setup:function(s){let o=0,a=0,l=0;for(let t=0;t<9;t++)r.probe[t].set(0,0,0);let c=0,u=0,h=0,d=0,p=0,f=0,m=0,g=0;s.sort(Dst);for(let t=0,e=s.length;t<e;t++){const e=s[t],y=e.color,v=e.intensity,b=e.distance,A=e.shadow&&e.shadow.map?e.shadow.map.texture:null;if(e.isAmbientLight)o+=y.r*v,a+=y.g*v,l+=y.b*v;else if(e.isLightProbe)for(let t=0;t<9;t++)r.probe[t].addScaledVector(e.sh.coefficients[t],v);else if(e.isDirectionalLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity),e.castShadow){const t=e.shadow,n=i.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,r.directionalShadow[c]=n,r.directionalShadowMap[c]=A,r.directionalShadowMatrix[c]=e.shadow.matrix,f++}r.directional[c]=t,c++}else if(e.isSpotLight){const t=n.get(e);if(t.position.setFromMatrixPosition(e.matrixWorld),t.color.copy(y).multiplyScalar(v),t.distance=b,t.coneCos=Math.cos(e.angle),t.penumbraCos=Math.cos(e.angle*(1-e.penumbra)),t.decay=e.decay,e.castShadow){const t=e.shadow,n=i.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,r.spotShadow[h]=n,r.spotShadowMap[h]=A,r.spotShadowMatrix[h]=e.shadow.matrix,g++}r.spot[h]=t,h++}else if(e.isRectAreaLight){const t=n.get(e);t.color.copy(y).multiplyScalar(v),t.halfWidth.set(.5*e.width,0,0),t.halfHeight.set(0,.5*e.height,0),r.rectArea[d]=t,d++}else if(e.isPointLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity),t.distance=e.distance,t.decay=e.decay,e.castShadow){const t=e.shadow,n=i.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,n.shadowCameraNear=t.camera.near,n.shadowCameraFar=t.camera.far,r.pointShadow[u]=n,r.pointShadowMap[u]=A,r.pointShadowMatrix[u]=e.shadow.matrix,m++}r.point[u]=t,u++}else if(e.isHemisphereLight){const t=n.get(e);t.skyColor.copy(e.color).multiplyScalar(v),t.groundColor.copy(e.groundColor).multiplyScalar(v),r.hemi[p]=t,p++}}d>0&&(e.isWebGL2||!0===t.has("OES_texture_float_linear")?(r.rectAreaLTC1=Qit.LTC_FLOAT_1,r.rectAreaLTC2=Qit.LTC_FLOAT_2):!0===t.has("OES_texture_half_float_linear")?(r.rectAreaLTC1=Qit.LTC_HALF_1,r.rectAreaLTC2=Qit.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=o,r.ambient[1]=a,r.ambient[2]=l;const y=r.hash;y.directionalLength===c&&y.pointLength===u&&y.spotLength===h&&y.rectAreaLength===d&&y.hemiLength===p&&y.numDirectionalShadows===f&&y.numPointShadows===m&&y.numSpotShadows===g||(r.directional.length=c,r.spot.length=h,r.rectArea.length=d,r.point.length=u,r.hemi.length=p,r.directionalShadow.length=f,r.directionalShadowMap.length=f,r.pointShadow.length=m,r.pointShadowMap.length=m,r.spotShadow.length=g,r.spotShadowMap.length=g,r.directionalShadowMatrix.length=f,r.pointShadowMatrix.length=m,r.spotShadowMatrix.length=g,y.directionalLength=c,y.pointLength=u,y.spotLength=h,y.rectAreaLength=d,y.hemiLength=p,y.numDirectionalShadows=f,y.numPointShadows=m,y.numSpotShadows=g,r.version=Lst++)},setupView:function(t,e){let n=0,i=0,l=0,c=0,u=0;const h=e.matrixWorldInverse;for(let d=0,p=t.length;d<p;d++){const e=t[d];if(e.isDirectionalLight){const t=r.directional[n];t.direction.setFromMatrixPosition(e.matrixWorld),s.setFromMatrixPosition(e.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(h),n++}else if(e.isSpotLight){const t=r.spot[l];t.position.setFromMatrixPosition(e.matrixWorld),t.position.applyMatrix4(h),t.direction.setFromMatrixPosition(e.matrixWorld),s.setFromMatrixPosition(e.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(h),l++}else if(e.isRectAreaLight){const t=r.rectArea[c];t.position.setFromMatrixPosition(e.matrixWorld),t.position.applyMatrix4(h),a.identity(),o.copy(e.matrixWorld),o.premultiply(h),a.extractRotation(o),t.halfWidth.set(.5*e.width,0,0),t.halfHeight.set(0,.5*e.height,0),t.halfWidth.applyMatrix4(a),t.halfHeight.applyMatrix4(a),c++}else if(e.isPointLight){const t=r.point[i];t.position.setFromMatrixPosition(e.matrixWorld),t.position.applyMatrix4(h),i++}else if(e.isHemisphereLight){const t=r.hemi[u];t.direction.setFromMatrixPosition(e.matrixWorld),t.direction.transformDirection(h),t.direction.normalize(),u++}}},state:r}}function Ost(t,e){const n=new Bst(t,e),i=[],r=[];return{init:function(){i.length=0,r.length=0},state:{lightsArray:i,shadowsArray:r,lights:n},setupLights:function(){n.setup(i)},setupLightsView:function(t){n.setupView(i,t)},pushLight:function(t){i.push(t)},pushShadow:function(t){r.push(t)}}}function Pst(t,e){let n=new WeakMap;return{get:function(i,r=0){let s;return!1===n.has(i)?(s=new Ost(t,e),n.set(i,[]),n.get(i).push(s)):r>=n.get(i).length?(s=new Ost(t,e),n.get(i).push(s)):s=n.get(i)[r],s},dispose:function(){n=new WeakMap}}}function Fst(t){Pnt.call(this),this.type="MeshDepthMaterial",this.depthPacking=3200,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(t)}function $st(t){Pnt.call(this),this.type="MeshDistanceMaterial",this.referencePosition=new det,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(t)}function zst(t,e,n){let i=new Hit;const r=new eet,s=new eet,o=new cet,a=[],l=[],c={},u={0:1,1:0,2:2},h=new Nit({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new eet},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),d=h.clone();d.defines.HORIZONTAL_PASS=1;const p=new lit;p.setAttribute("position",new Unt(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const f=new Cit(p,h),m=this;function g(n,i){const r=e.update(f);h.uniforms.shadow_pass.value=n.map.texture,h.uniforms.resolution.value=n.mapSize,h.uniforms.radius.value=n.radius,t.setRenderTarget(n.mapPass),t.clear(),t.renderBufferDirect(i,null,r,h,f,null),d.uniforms.shadow_pass.value=n.mapPass.texture,d.uniforms.resolution.value=n.mapSize,d.uniforms.radius.value=n.radius,t.setRenderTarget(n.map),t.clear(),t.renderBufferDirect(i,null,r,d,f,null)}function y(t,e,n){const i=t<<0|e<<1|n<<2;let r=a[i];return void 0===r&&(r=new Fst({depthPacking:3201,morphTargets:t,skinning:e}),a[i]=r),r}function v(t,e,n){const i=t<<0|e<<1|n<<2;let r=l[i];return void 0===r&&(r=new $st({morphTargets:t,skinning:e}),l[i]=r),r}function b(e,n,i,r,s,o,a){let l=null,h=y,d=e.customDepthMaterial;if(!0===r.isPointLight&&(h=v,d=e.customDistanceMaterial),void 0===d){let t=!1;!0===i.morphTargets&&(t=n.morphAttributes&&n.morphAttributes.position&&n.morphAttributes.position.length>0);let r=!1;!0===e.isSkinnedMesh&&(!0===i.skinning?r=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",e)),l=h(t,r,!0===e.isInstancedMesh)}else l=d;if(t.localClippingEnabled&&!0===i.clipShadows&&0!==i.clippingPlanes.length){const t=l.uuid,e=i.uuid;let n=c[t];void 0===n&&(n={},c[t]=n);let r=n[e];void 0===r&&(r=l.clone(),n[e]=r),l=r}return l.visible=i.visible,l.wireframe=i.wireframe,l.side=3===a?null!==i.shadowSide?i.shadowSide:i.side:null!==i.shadowSide?i.shadowSide:u[i.side],l.clipShadows=i.clipShadows,l.clippingPlanes=i.clippingPlanes,l.clipIntersection=i.clipIntersection,l.wireframeLinewidth=i.wireframeLinewidth,l.linewidth=i.linewidth,!0===r.isPointLight&&!0===l.isMeshDistanceMaterial&&(l.referencePosition.setFromMatrixPosition(r.matrixWorld),l.nearDistance=s,l.farDistance=o),l}function A(n,r,s,o,a){if(!1===n.visible)return;if(n.layers.test(r.layers)&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&3===a)&&(!n.frustumCulled||i.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,n.matrixWorld);const i=e.update(n),r=n.material;if(Array.isArray(r)){const e=i.groups;for(let l=0,c=e.length;l<c;l++){const c=e[l],u=r[c.materialIndex];if(u&&u.visible){const e=b(n,i,u,o,s.near,s.far,a);t.renderBufferDirect(s,null,i,e,n,c)}}}else if(r.visible){const e=b(n,i,r,o,s.near,s.far,a);t.renderBufferDirect(s,null,i,e,n,null)}}const l=n.children;for(let t=0,e=l.length;t<e;t++)A(l[t],r,s,o,a)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function(e,a,l){if(!1===m.enabled)return;if(!1===m.autoUpdate&&!1===m.needsUpdate)return;if(0===e.length)return;const c=t.getRenderTarget(),u=t.getActiveCubeFace(),h=t.getActiveMipmapLevel(),d=t.state;d.setBlending(0),d.buffers.color.setClear(1,1,1,1),d.buffers.depth.setTest(!0),d.setScissorTest(!1);for(let p=0,f=e.length;p<f;p++){const c=e[p],u=c.shadow;if(void 0===u){console.warn("THREE.WebGLShadowMap:",c,"has no shadow.");continue}if(!1===u.autoUpdate&&!1===u.needsUpdate)continue;r.copy(u.mapSize);const h=u.getFrameExtents();if(r.multiply(h),s.copy(u.mapSize),(r.x>n||r.y>n)&&(r.x>n&&(s.x=Math.floor(n/h.x),r.x=s.x*h.x,u.mapSize.x=s.x),r.y>n&&(s.y=Math.floor(n/h.y),r.y=s.y*h.y,u.mapSize.y=s.y)),null===u.map&&!u.isPointLightShadow&&3===this.type){const t={minFilter:Mtt,magFilter:Mtt,format:Ptt};u.map=new uet(r.x,r.y,t),u.map.texture.name=c.name+".shadowMap",u.mapPass=new uet(r.x,r.y,t),u.camera.updateProjectionMatrix()}null===u.map&&(u.map=new uet(r.x,r.y,{minFilter:Ttt,magFilter:Ttt,format:Ptt}),u.map.texture.name=c.name+".shadowMap",u.camera.updateProjectionMatrix()),t.setRenderTarget(u.map),t.clear();const f=u.getViewportCount();for(let t=0;t<f;t++){const e=u.getViewport(t);o.set(s.x*e.x,s.y*e.y,s.x*e.z,s.y*e.w),d.viewport(o),u.updateMatrices(c,t),i=u.getFrustum(),A(a,l,u.camera,c,this.type)}u.isPointLightShadow||3!==this.type||g(u,l),u.needsUpdate=!1}m.needsUpdate=!1,t.setRenderTarget(c,u,h)}}function Ust(t,e,n){const i=n.isWebGL2,r=new function(){let e=!1;const n=new cet;let i=null;const r=new cet(0,0,0,0);return{setMask:function(n){i===n||e||(t.colorMask(n,n,n,n),i=n)},setLocked:function(t){e=t},setClear:function(e,i,s,o,a){!0===a&&(e*=o,i*=o,s*=o),n.set(e,i,s,o),!1===r.equals(n)&&(t.clearColor(e,i,s,o),r.copy(n))},reset:function(){e=!1,i=null,r.set(-1,0,0,0)}}},s=new function(){let e=!1,n=null,i=null,r=null;return{setTest:function(t){t?L(2929):D(2929)},setMask:function(i){n===i||e||(t.depthMask(i),n=i)},setFunc:function(e){if(i!==e){if(e)switch(e){case 0:t.depthFunc(512);break;case 1:t.depthFunc(519);break;case 2:t.depthFunc(513);break;case 3:t.depthFunc(515);break;case 4:t.depthFunc(514);break;case 5:t.depthFunc(518);break;case 6:t.depthFunc(516);break;case 7:t.depthFunc(517);break;default:t.depthFunc(515)}else t.depthFunc(515);i=e}},setLocked:function(t){e=t},setClear:function(e){r!==e&&(t.clearDepth(e),r=e)},reset:function(){e=!1,n=null,i=null,r=null}}},o=new function(){let e=!1,n=null,i=null,r=null,s=null,o=null,a=null,l=null,c=null;return{setTest:function(t){e||(t?L(2960):D(2960))},setMask:function(i){n===i||e||(t.stencilMask(i),n=i)},setFunc:function(e,n,o){i===e&&r===n&&s===o||(t.stencilFunc(e,n,o),i=e,r=n,s=o)},setOp:function(e,n,i){o===e&&a===n&&l===i||(t.stencilOp(e,n,i),o=e,a=n,l=i)},setLocked:function(t){e=t},setClear:function(e){c!==e&&(t.clearStencil(e),c=e)},reset:function(){e=!1,n=null,i=null,r=null,s=null,o=null,a=null,l=null,c=null}}};let a={},l=null,c=null,u=null,h=null,d=null,p=null,f=null,m=null,g=null,y=!1,v=null,b=null,A=null,x=null,w=null;const _=t.getParameter(35661);let S=!1,E=0;const C=t.getParameter(7938);-1!==C.indexOf("WebGL")?(E=parseFloat(/^WebGL (\d)/.exec(C)[1]),S=E>=1):-1!==C.indexOf("OpenGL ES")&&(E=parseFloat(/^OpenGL ES (\d)/.exec(C)[1]),S=E>=2);let I=null,T={};const M=new cet,k=new cet;function R(e,n,i){const r=new Uint8Array(4),s=t.createTexture();t.bindTexture(e,s),t.texParameteri(e,10241,9728),t.texParameteri(e,10240,9728);for(let o=0;o<i;o++)t.texImage2D(n+o,0,6408,1,1,0,6408,5121,r);return s}const N={};function L(e){!0!==a[e]&&(t.enable(e),a[e]=!0)}function D(e){!1!==a[e]&&(t.disable(e),a[e]=!1)}N[3553]=R(3553,3553,1),N[34067]=R(34067,34069,6),r.setClear(0,0,0,1),s.setClear(1),o.setClear(0),L(2929),s.setFunc(3),F(!1),$(1),L(2884),P(0);const B={[Stt]:32774,101:32778,102:32779};if(i)B[103]=32775,B[104]=32776;else{const t=e.get("EXT_blend_minmax");null!==t&&(B[103]=t.MIN_EXT,B[104]=t.MAX_EXT)}const O={200:0,201:1,202:768,204:770,210:776,208:774,206:772,203:769,205:771,209:775,207:773};function P(e,n,i,r,s,o,a,l){if(0!==e){if(c||(L(3042),c=!0),5===e)s=s||n,o=o||i,a=a||r,n===h&&s===f||(t.blendEquationSeparate(B[n],B[s]),h=n,f=s),i===d&&r===p&&o===m&&a===g||(t.blendFuncSeparate(O[i],O[r],O[o],O[a]),d=i,p=r,m=o,g=a),u=e,y=null;else if(e!==u||l!==y){if(h===Stt&&f===Stt||(t.blendEquation(32774),h=Stt,f=Stt),l)switch(e){case 1:t.blendFuncSeparate(1,771,1,771);break;case 2:t.blendFunc(1,1);break;case 3:t.blendFuncSeparate(0,0,769,771);break;case 4:t.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}else switch(e){case 1:t.blendFuncSeparate(770,771,1,771);break;case 2:t.blendFunc(770,1);break;case 3:t.blendFunc(0,769);break;case 4:t.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}d=null,p=null,m=null,g=null,u=e,y=l}}else c&&(D(3042),c=!1)}function F(e){v!==e&&(t.frontFace(e?2304:2305),v=e)}function $(e){0!==e?(L(2884),e!==b&&t.cullFace(1===e?1029:2===e?1028:1032)):D(2884),b=e}function z(e,n,i){e?(L(32823),x===n&&w===i||(t.polygonOffset(n,i),x=n,w=i)):D(32823)}function U(e){void 0===e&&(e=33984+_-1),I!==e&&(t.activeTexture(e),I=e)}return{buffers:{color:r,depth:s,stencil:o},enable:L,disable:D,useProgram:function(e){return l!==e&&(t.useProgram(e),l=e,!0)},setBlending:P,setMaterial:function(t,e){2===t.side?D(2884):L(2884);let n=1===t.side;e&&(n=!n),F(n),1===t.blending&&!1===t.transparent?P(0):P(t.blending,t.blendEquation,t.blendSrc,t.blendDst,t.blendEquationAlpha,t.blendSrcAlpha,t.blendDstAlpha,t.premultipliedAlpha),s.setFunc(t.depthFunc),s.setTest(t.depthTest),s.setMask(t.depthWrite),r.setMask(t.colorWrite);const i=t.stencilWrite;o.setTest(i),i&&(o.setMask(t.stencilWriteMask),o.setFunc(t.stencilFunc,t.stencilRef,t.stencilFuncMask),o.setOp(t.stencilFail,t.stencilZFail,t.stencilZPass)),z(t.polygonOffset,t.polygonOffsetFactor,t.polygonOffsetUnits)},setFlipSided:F,setCullFace:$,setLineWidth:function(e){e!==A&&(S&&t.lineWidth(e),A=e)},setPolygonOffset:z,setScissorTest:function(t){t?L(3089):D(3089)},activeTexture:U,bindTexture:function(e,n){null===I&&U();let i=T[I];void 0===i&&(i={type:void 0,texture:void 0},T[I]=i),i.type===e&&i.texture===n||(t.bindTexture(e,n||N[e]),i.type=e,i.texture=n)},unbindTexture:function(){const e=T[I];void 0!==e&&void 0!==e.type&&(t.bindTexture(e.type,null),e.type=void 0,e.texture=void 0)},compressedTexImage2D:function(){try{t.compressedTexImage2D.apply(t,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage2D:function(){try{t.texImage2D.apply(t,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage3D:function(){try{t.texImage3D.apply(t,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},scissor:function(e){!1===M.equals(e)&&(t.scissor(e.x,e.y,e.z,e.w),M.copy(e))},viewport:function(e){!1===k.equals(e)&&(t.viewport(e.x,e.y,e.z,e.w),k.copy(e))},reset:function(){a={},I=null,T={},l=null,c=null,u=null,h=null,d=null,p=null,f=null,m=null,g=null,y=!1,v=null,b=null,A=null,x=null,w=null,r.reset(),s.reset(),o.reset()}}}function Hst(t,e,n,i,r,s,o){const a=r.isWebGL2,l=r.maxTextures,c=r.maxCubemapSize,u=r.maxTextureSize,h=r.maxSamples,d=new WeakMap;let p,f=!1;try{f="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(WTt){}function m(t,e){return f?new OffscreenCanvas(t,e):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function g(t,e,n,i){let r=1;if((t.width>i||t.height>i)&&(r=i/Math.max(t.width,t.height)),r<1||!0===e){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const i=e?tet.floorPowerOfTwo:Math.floor,s=i(r*t.width),o=i(r*t.height);void 0===p&&(p=m(s,o));const a=n?m(s,o):p;return a.width=s,a.height=o,a.getContext("2d").drawImage(t,0,0,s,o),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+t.width+"x"+t.height+") to ("+s+"x"+o+")."),a}return"data"in t&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+t.width+"x"+t.height+")."),t}return t}function y(t){return tet.isPowerOfTwo(t.width)&&tet.isPowerOfTwo(t.height)}function v(t,e){return t.generateMipmaps&&e&&t.minFilter!==Ttt&&t.minFilter!==Mtt}function b(e,n,r,s){t.generateMipmap(e),i.get(n).__maxMipLevel=Math.log(Math.max(r,s))*Math.LOG2E}function A(n,i,r){if(!1===a)return i;if(null!==n){if(void 0!==t[n])return t[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let s=i;return 6403===i&&(5126===r&&(s=33326),5131===r&&(s=33325),5121===r&&(s=33321)),6407===i&&(5126===r&&(s=34837),5131===r&&(s=34843),5121===r&&(s=32849)),6408===i&&(5126===r&&(s=34836),5131===r&&(s=34842),5121===r&&(s=32856)),33325!==s&&33326!==s&&34842!==s&&34836!==s||e.get("EXT_color_buffer_float"),s}function x(t){return t===Ttt||1004===t||1005===t?9728:9729}function w(e){const n=e.target;n.removeEventListener("dispose",w),function(e){const n=i.get(e);void 0!==n.__webglInit&&(t.deleteTexture(n.__webglTexture),i.remove(e))}(n),n.isVideoTexture&&d.delete(n),o.memory.textures--}function _(e){const n=e.target;n.removeEventListener("dispose",_),function(e){const n=i.get(e),r=i.get(e.texture);if(e){if(void 0!==r.__webglTexture&&t.deleteTexture(r.__webglTexture),e.depthTexture&&e.depthTexture.dispose(),e.isWebGLCubeRenderTarget)for(let e=0;e<6;e++)t.deleteFramebuffer(n.__webglFramebuffer[e]),n.__webglDepthbuffer&&t.deleteRenderbuffer(n.__webglDepthbuffer[e]);else t.deleteFramebuffer(n.__webglFramebuffer),n.__webglDepthbuffer&&t.deleteRenderbuffer(n.__webglDepthbuffer),n.__webglMultisampledFramebuffer&&t.deleteFramebuffer(n.__webglMultisampledFramebuffer),n.__webglColorRenderbuffer&&t.deleteRenderbuffer(n.__webglColorRenderbuffer),n.__webglDepthRenderbuffer&&t.deleteRenderbuffer(n.__webglDepthRenderbuffer);i.remove(e.texture),i.remove(e)}}(n),o.memory.textures--}let S=0;function E(t,e){const r=i.get(t);if(t.isVideoTexture&&function(t){const e=o.render.frame;d.get(t)!==e&&(d.set(t,e),t.update())}(t),t.version>0&&r.__version!==t.version){const n=t.image;if(void 0===n)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else{if(!1!==n.complete)return void R(r,t,e);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.activeTexture(33984+e),n.bindTexture(3553,r.__webglTexture)}function C(e,r){const o=i.get(e);e.version>0&&o.__version!==e.version?function(e,i,r){if(6!==i.image.length)return;k(e,i),n.activeTexture(33984+r),n.bindTexture(34067,e.__webglTexture),t.pixelStorei(37440,i.flipY),t.pixelStorei(37441,i.premultiplyAlpha),t.pixelStorei(3317,i.unpackAlignment);const o=i&&(i.isCompressedTexture||i.image[0].isCompressedTexture),l=i.image[0]&&i.image[0].isDataTexture,u=[];for(let t=0;t<6;t++)u[t]=o||l?l?i.image[t].image:i.image[t]:g(i.image[t],!1,!0,c);const h=u[0],d=y(h)||a,p=s.convert(i.format),f=s.convert(i.type),m=A(i.internalFormat,p,f);let x;if(M(34067,i,d),o){for(let t=0;t<6;t++){x=u[t].mipmaps;for(let e=0;e<x.length;e++){const r=x[e];i.format!==Ptt&&i.format!==Ott?null!==p?n.compressedTexImage2D(34069+t,e,m,r.width,r.height,0,r.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):n.texImage2D(34069+t,e,m,r.width,r.height,0,p,f,r.data)}}e.__maxMipLevel=x.length-1}else{x=i.mipmaps;for(let t=0;t<6;t++)if(l){n.texImage2D(34069+t,0,m,u[t].width,u[t].height,0,p,f,u[t].data);for(let e=0;e<x.length;e++){const i=x[e].image[t].image;n.texImage2D(34069+t,e+1,m,i.width,i.height,0,p,f,i.data)}}else{n.texImage2D(34069+t,0,m,p,f,u[t]);for(let e=0;e<x.length;e++)n.texImage2D(34069+t,e+1,m,p,f,x[e].image[t])}e.__maxMipLevel=x.length}v(i,d)&&b(34067,i,h.width,h.height),e.__version=i.version,i.onUpdate&&i.onUpdate(i)}(o,e,r):(n.activeTexture(33984+r),n.bindTexture(34067,o.__webglTexture))}const I={[Ett]:10497,[Ctt]:33071,[Itt]:33648},T={[Ttt]:9728,1004:9984,1005:9986,[Mtt]:9729,1007:9985,[ktt]:9987};function M(n,s,o){o?(t.texParameteri(n,10242,I[s.wrapS]),t.texParameteri(n,10243,I[s.wrapT]),32879!==n&&35866!==n||t.texParameteri(n,32882,I[s.wrapR]),t.texParameteri(n,10240,T[s.magFilter]),t.texParameteri(n,10241,T[s.minFilter])):(t.texParameteri(n,10242,33071),t.texParameteri(n,10243,33071),32879!==n&&35866!==n||t.texParameteri(n,32882,33071),s.wrapS===Ctt&&s.wrapT===Ctt||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),t.texParameteri(n,10240,x(s.magFilter)),t.texParameteri(n,10241,x(s.minFilter)),s.minFilter!==Ttt&&s.minFilter!==Mtt&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));const l=e.get("EXT_texture_filter_anisotropic");if(l){if(s.type===Ltt&&null===e.get("OES_texture_float_linear"))return;if(s.type===Dtt&&null===(a||e.get("OES_texture_half_float_linear")))return;(s.anisotropy>1||i.get(s).__currentAnisotropy)&&(t.texParameterf(n,l.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(s.anisotropy,r.getMaxAnisotropy())),i.get(s).__currentAnisotropy=s.anisotropy)}}function k(e,n){void 0===e.__webglInit&&(e.__webglInit=!0,n.addEventListener("dispose",w),e.__webglTexture=t.createTexture(),o.memory.textures++)}function R(e,i,r){let o=3553;i.isDataTexture2DArray&&(o=35866),i.isDataTexture3D&&(o=32879),k(e,i),n.activeTexture(33984+r),n.bindTexture(o,e.__webglTexture),t.pixelStorei(37440,i.flipY),t.pixelStorei(37441,i.premultiplyAlpha),t.pixelStorei(3317,i.unpackAlignment);const l=function(t){return!a&&(t.wrapS!==Ctt||t.wrapT!==Ctt||t.minFilter!==Ttt&&t.minFilter!==Mtt)}(i)&&!1===y(i.image),c=g(i.image,l,!1,u),h=y(c)||a,d=s.convert(i.format);let p,f=s.convert(i.type),m=A(i.internalFormat,d,f);M(o,i,h);const x=i.mipmaps;if(i.isDepthTexture)m=6402,a?m=i.type===Ltt?36012:i.type===Ntt?33190:i.type===Btt?35056:33189:i.type===Ltt&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),i.format===Ftt&&6402===m&&i.type!==Rtt&&i.type!==Ntt&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),i.type=Rtt,f=s.convert(i.type)),i.format===$tt&&6402===m&&(m=34041,i.type!==Btt&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),i.type=Btt,f=s.convert(i.type))),n.texImage2D(3553,0,m,c.width,c.height,0,d,f,null);else if(i.isDataTexture)if(x.length>0&&h){for(let t=0,e=x.length;t<e;t++)p=x[t],n.texImage2D(3553,t,m,p.width,p.height,0,d,f,p.data);i.generateMipmaps=!1,e.__maxMipLevel=x.length-1}else n.texImage2D(3553,0,m,c.width,c.height,0,d,f,c.data),e.__maxMipLevel=0;else if(i.isCompressedTexture){for(let t=0,e=x.length;t<e;t++)p=x[t],i.format!==Ptt&&i.format!==Ott?null!==d?n.compressedTexImage2D(3553,t,m,p.width,p.height,0,p.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):n.texImage2D(3553,t,m,p.width,p.height,0,d,f,p.data);e.__maxMipLevel=x.length-1}else if(i.isDataTexture2DArray)n.texImage3D(35866,0,m,c.width,c.height,c.depth,0,d,f,c.data),e.__maxMipLevel=0;else if(i.isDataTexture3D)n.texImage3D(32879,0,m,c.width,c.height,c.depth,0,d,f,c.data),e.__maxMipLevel=0;else if(x.length>0&&h){for(let t=0,e=x.length;t<e;t++)p=x[t],n.texImage2D(3553,t,m,d,f,p);i.generateMipmaps=!1,e.__maxMipLevel=x.length-1}else n.texImage2D(3553,0,m,d,f,c),e.__maxMipLevel=0;v(i,h)&&b(o,i,c.width,c.height),e.__version=i.version,i.onUpdate&&i.onUpdate(i)}function N(e,r,o,a){const l=s.convert(r.texture.format),c=s.convert(r.texture.type),u=A(r.texture.internalFormat,l,c);n.texImage2D(a,0,u,r.width,r.height,0,l,c,null),t.bindFramebuffer(36160,e),t.framebufferTexture2D(36160,o,a,i.get(r.texture).__webglTexture,0),t.bindFramebuffer(36160,null)}function L(e,n,i){if(t.bindRenderbuffer(36161,e),n.depthBuffer&&!n.stencilBuffer){let r=33189;if(i){const e=n.depthTexture;e&&e.isDepthTexture&&(e.type===Ltt?r=36012:e.type===Ntt&&(r=33190));const i=D(n);t.renderbufferStorageMultisample(36161,i,r,n.width,n.height)}else t.renderbufferStorage(36161,r,n.width,n.height);t.framebufferRenderbuffer(36160,36096,36161,e)}else if(n.depthBuffer&&n.stencilBuffer){if(i){const e=D(n);t.renderbufferStorageMultisample(36161,e,35056,n.width,n.height)}else t.renderbufferStorage(36161,34041,n.width,n.height);t.framebufferRenderbuffer(36160,33306,36161,e)}else{const e=s.convert(n.texture.format),r=s.convert(n.texture.type),o=A(n.texture.internalFormat,e,r);if(i){const e=D(n);t.renderbufferStorageMultisample(36161,e,o,n.width,n.height)}else t.renderbufferStorage(36161,o,n.width,n.height)}t.bindRenderbuffer(36161,null)}function D(t){return a&&t.isWebGLMultisampleRenderTarget?Math.min(h,t.samples):0}let B=!1,O=!1;this.allocateTextureUnit=function(){const t=S;return t>=l&&console.warn("THREE.WebGLTextures: Trying to use "+t+" texture units while this GPU supports only "+l),S+=1,t},this.resetTextureUnits=function(){S=0},this.setTexture2D=E,this.setTexture2DArray=function(t,e){const r=i.get(t);t.version>0&&r.__version!==t.version?R(r,t,e):(n.activeTexture(33984+e),n.bindTexture(35866,r.__webglTexture))},this.setTexture3D=function(t,e){const r=i.get(t);t.version>0&&r.__version!==t.version?R(r,t,e):(n.activeTexture(33984+e),n.bindTexture(32879,r.__webglTexture))},this.setTextureCube=C,this.setupRenderTarget=function(e){const r=i.get(e),l=i.get(e.texture);e.addEventListener("dispose",_),l.__webglTexture=t.createTexture(),o.memory.textures++;const c=!0===e.isWebGLCubeRenderTarget,u=!0===e.isWebGLMultisampleRenderTarget,h=y(e)||a;if(!a||e.texture.format!==Ott||e.texture.type!==Ltt&&e.texture.type!==Dtt||(e.texture.format=Ptt,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),c){r.__webglFramebuffer=[];for(let e=0;e<6;e++)r.__webglFramebuffer[e]=t.createFramebuffer()}else if(r.__webglFramebuffer=t.createFramebuffer(),u)if(a){r.__webglMultisampledFramebuffer=t.createFramebuffer(),r.__webglColorRenderbuffer=t.createRenderbuffer(),t.bindRenderbuffer(36161,r.__webglColorRenderbuffer);const n=s.convert(e.texture.format),i=s.convert(e.texture.type),o=A(e.texture.internalFormat,n,i),a=D(e);t.renderbufferStorageMultisample(36161,a,o,e.width,e.height),t.bindFramebuffer(36160,r.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(36160,36064,36161,r.__webglColorRenderbuffer),t.bindRenderbuffer(36161,null),e.depthBuffer&&(r.__webglDepthRenderbuffer=t.createRenderbuffer(),L(r.__webglDepthRenderbuffer,e,!0)),t.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(c){n.bindTexture(34067,l.__webglTexture),M(34067,e.texture,h);for(let t=0;t<6;t++)N(r.__webglFramebuffer[t],e,36064,34069+t);v(e.texture,h)&&b(34067,e.texture,e.width,e.height),n.bindTexture(34067,null)}else n.bindTexture(3553,l.__webglTexture),M(3553,e.texture,h),N(r.__webglFramebuffer,e,36064,3553),v(e.texture,h)&&b(3553,e.texture,e.width,e.height),n.bindTexture(3553,null);e.depthBuffer&&function(e){const n=i.get(e),r=!0===e.isWebGLCubeRenderTarget;if(e.depthTexture){if(r)throw new Error("target.depthTexture not supported in Cube render targets");!function(e,n){if(n&&n.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,e),!n.depthTexture||!n.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");i.get(n.depthTexture).__webglTexture&&n.depthTexture.image.width===n.width&&n.depthTexture.image.height===n.height||(n.depthTexture.image.width=n.width,n.depthTexture.image.height=n.height,n.depthTexture.needsUpdate=!0),E(n.depthTexture,0);const r=i.get(n.depthTexture).__webglTexture;if(n.depthTexture.format===Ftt)t.framebufferTexture2D(36160,36096,3553,r,0);else{if(n.depthTexture.format!==$tt)throw new Error("Unknown depthTexture format");t.framebufferTexture2D(36160,33306,3553,r,0)}}(n.__webglFramebuffer,e)}else if(r){n.__webglDepthbuffer=[];for(let i=0;i<6;i++)t.bindFramebuffer(36160,n.__webglFramebuffer[i]),n.__webglDepthbuffer[i]=t.createRenderbuffer(),L(n.__webglDepthbuffer[i],e,!1)}else t.bindFramebuffer(36160,n.__webglFramebuffer),n.__webglDepthbuffer=t.createRenderbuffer(),L(n.__webglDepthbuffer,e,!1);t.bindFramebuffer(36160,null)}(e)},this.updateRenderTargetMipmap=function(t){const e=t.texture;if(v(e,y(t)||a)){const r=t.isWebGLCubeRenderTarget?34067:3553,s=i.get(e).__webglTexture;n.bindTexture(r,s),b(r,e,t.width,t.height),n.bindTexture(r,null)}},this.updateMultisampleRenderTarget=function(e){if(e.isWebGLMultisampleRenderTarget)if(a){const n=i.get(e);t.bindFramebuffer(36008,n.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,n.__webglFramebuffer);const r=e.width,s=e.height;let o=16384;e.depthBuffer&&(o|=256),e.stencilBuffer&&(o|=1024),t.blitFramebuffer(0,0,r,s,0,0,r,s,o,9728),t.bindFramebuffer(36160,n.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")},this.safeSetTexture2D=function(t,e){t&&t.isWebGLRenderTarget&&(!1===B&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),B=!0),t=t.texture),E(t,e)},this.safeSetTextureCube=function(t,e){t&&t.isWebGLCubeRenderTarget&&(!1===O&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),O=!0),t=t.texture),C(t,e)}}function Vst(t,e,n){const i=n.isWebGL2;return{convert:function(t){let n;if(1009===t)return 5121;if(1017===t)return 32819;if(1018===t)return 32820;if(1019===t)return 33635;if(1010===t)return 5120;if(1011===t)return 5122;if(t===Rtt)return 5123;if(1013===t)return 5124;if(t===Ntt)return 5125;if(t===Ltt)return 5126;if(t===Dtt)return i?5131:(n=e.get("OES_texture_half_float"),null!==n?n.HALF_FLOAT_OES:null);if(1021===t)return 6406;if(t===Ott)return 6407;if(t===Ptt)return 6408;if(1024===t)return 6409;if(1025===t)return 6410;if(t===Ftt)return 6402;if(t===$tt)return 34041;if(1028===t)return 6403;if(1029===t)return 36244;if(1030===t)return 33319;if(1031===t)return 33320;if(1032===t)return 36248;if(1033===t)return 36249;if(33776===t||33777===t||33778===t||33779===t){if(n=e.get("WEBGL_compressed_texture_s3tc"),null===n)return null;if(33776===t)return n.COMPRESSED_RGB_S3TC_DXT1_EXT;if(33777===t)return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(33778===t)return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(33779===t)return n.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(35840===t||35841===t||35842===t||35843===t){if(n=e.get("WEBGL_compressed_texture_pvrtc"),null===n)return null;if(35840===t)return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(35841===t)return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(35842===t)return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(35843===t)return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(36196===t)return n=e.get("WEBGL_compressed_texture_etc1"),null!==n?n.COMPRESSED_RGB_ETC1_WEBGL:null;if((37492===t||37496===t)&&(n=e.get("WEBGL_compressed_texture_etc"),null!==n)){if(37492===t)return n.COMPRESSED_RGB8_ETC2;if(37496===t)return n.COMPRESSED_RGBA8_ETC2_EAC}return 37808===t||37809===t||37810===t||37811===t||37812===t||37813===t||37814===t||37815===t||37816===t||37817===t||37818===t||37819===t||37820===t||37821===t||37840===t||37841===t||37842===t||37843===t||37844===t||37845===t||37846===t||37847===t||37848===t||37849===t||37850===t||37851===t||37852===t||37853===t?(n=e.get("WEBGL_compressed_texture_astc"),null!==n?t:null):36492===t?(n=e.get("EXT_texture_compression_bptc"),null!==n?t:null):t===Btt?i?34042:(n=e.get("WEBGL_depth_texture"),null!==n?n.UNSIGNED_INT_24_8_WEBGL:null):void 0}}}function Gst(t=[]){Dit.call(this),this.cameras=t}function Wst(){dnt.call(this),this.type="Group"}function jst(){this._targetRay=null,this._grip=null,this._hand=null}function Qst(t,e){const n=this;let i=null,r=1,s=null,o="local-floor",a=null;const l=[],c=new Map,u=new Dit;u.layers.enable(1),u.viewport=new cet;const h=new Dit;h.layers.enable(2),h.viewport=new cet;const d=[u,h],p=new Gst;p.layers.enable(1),p.layers.enable(2);let f=null,m=null;function g(t){const e=c.get(t.inputSource);e&&e.dispatchEvent({type:t.type,data:t.inputSource})}function y(){c.forEach(function(t,e){t.disconnect(e)}),c.clear(),f=null,m=null,t.setFramebuffer(null),t.setRenderTarget(t.getRenderTarget()),_.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function v(t){const e=i.inputSources;for(let n=0;n<l.length;n++)c.set(e[n],l[n]);for(let n=0;n<t.removed.length;n++){const e=t.removed[n],i=c.get(e);i&&(i.dispatchEvent({type:"disconnected",data:e}),c.delete(e))}for(let n=0;n<t.added.length;n++){const e=t.added[n],i=c.get(e);i&&i.dispatchEvent({type:"connected",data:e})}}this.enabled=!1,this.isPresenting=!1,this.getController=function(t){let e=l[t];return void 0===e&&(e=new jst,l[t]=e),e.getTargetRaySpace()},this.getControllerGrip=function(t){let e=l[t];return void 0===e&&(e=new jst,l[t]=e),e.getGripSpace()},this.getHand=function(t){let e=l[t];return void 0===e&&(e=new jst,l[t]=e),e.getHandSpace()},this.setFramebufferScaleFactor=function(t){r=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(t){o=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return s},this.getSession=function(){return i},this.setSession=async function(t){if(i=t,null!==i){i.addEventListener("select",g),i.addEventListener("selectstart",g),i.addEventListener("selectend",g),i.addEventListener("squeeze",g),i.addEventListener("squeezestart",g),i.addEventListener("squeezeend",g),i.addEventListener("end",y),i.addEventListener("inputsourceschange",v);const t=e.getContextAttributes();!0!==t.xrCompatible&&await e.makeXRCompatible();const a=new XRWebGLLayer(i,e,{antialias:t.antialias,alpha:t.alpha,depth:t.depth,stencil:t.stencil,framebufferScaleFactor:r});i.updateRenderState({baseLayer:a}),s=await i.requestReferenceSpace(o),_.setContext(i),_.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};const b=new det,A=new det;function x(t,e){null===e?t.matrixWorld.copy(t.matrix):t.matrixWorld.multiplyMatrices(e.matrixWorld,t.matrix),t.matrixWorldInverse.copy(t.matrixWorld).invert()}this.getCamera=function(t){p.near=h.near=u.near=t.near,p.far=h.far=u.far=t.far,f===p.near&&m===p.far||(i.updateRenderState({depthNear:p.near,depthFar:p.far}),f=p.near,m=p.far);const e=t.parent,n=p.cameras;x(p,e);for(let i=0;i<n.length;i++)x(n[i],e);t.matrixWorld.copy(p.matrixWorld),t.matrix.copy(p.matrix),t.matrix.decompose(t.position,t.quaternion,t.scale);const r=t.children;for(let i=0,s=r.length;i<s;i++)r[i].updateMatrixWorld(!0);return 2===n.length?function(t,e,n){b.setFromMatrixPosition(e.matrixWorld),A.setFromMatrixPosition(n.matrixWorld);const i=b.distanceTo(A),r=e.projectionMatrix.elements,s=n.projectionMatrix.elements,o=r[14]/(r[10]-1),a=r[14]/(r[10]+1),l=(r[9]+1)/r[5],c=(r[9]-1)/r[5],u=(r[8]-1)/r[0],h=(s[8]+1)/s[0],d=o*u,p=o*h,f=i/(-u+h),m=f*-u;e.matrixWorld.decompose(t.position,t.quaternion,t.scale),t.translateX(m),t.translateZ(f),t.matrixWorld.compose(t.position,t.quaternion,t.scale),t.matrixWorldInverse.copy(t.matrixWorld).invert();const g=o+f,y=a+f;t.projectionMatrix.makePerspective(d-m,p+(i-m),l*a/y*g,c*a/y*g,g,y)}(p,u,h):p.projectionMatrix.copy(u.projectionMatrix),p};let w=null;const _=new Vit;_.setAnimationLoop(function(e,n){if(a=n.getViewerPose(s),null!==a){const e=a.views,n=i.renderState.baseLayer;t.setFramebuffer(n.framebuffer);let r=!1;e.length!==p.cameras.length&&(p.cameras.length=0,r=!0);for(let t=0;t<e.length;t++){const i=e[t],s=n.getViewport(i),o=d[t];o.matrix.fromArray(i.transform.matrix),o.projectionMatrix.fromArray(i.projectionMatrix),o.viewport.set(s.x,s.y,s.width,s.height),0===t&&p.matrix.copy(o.matrix),!0===r&&p.cameras.push(o)}}const r=i.inputSources;for(let t=0;t<l.length;t++)l[t].update(r[t],n,s);w&&w(e,n)}),this.setAnimationLoop=function(t){w=t},this.dispose=function(){}}function qst(t){function e(e,n){e.opacity.value=n.opacity,n.color&&e.diffuse.value.copy(n.color),n.emissive&&e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),n.map&&(e.map.value=n.map),n.alphaMap&&(e.alphaMap.value=n.alphaMap),n.specularMap&&(e.specularMap.value=n.specularMap);const i=t.get(n).envMap;if(i){e.envMap.value=i,e.flipEnvMap.value=i.isCubeTexture&&i._needsFlipEnvMap?-1:1,e.reflectivity.value=n.reflectivity,e.refractionRatio.value=n.refractionRatio;const r=t.get(i).__maxMipLevel;void 0!==r&&(e.maxMipLevel.value=r)}let r,s;n.lightMap&&(e.lightMap.value=n.lightMap,e.lightMapIntensity.value=n.lightMapIntensity),n.aoMap&&(e.aoMap.value=n.aoMap,e.aoMapIntensity.value=n.aoMapIntensity),n.map?r=n.map:n.specularMap?r=n.specularMap:n.displacementMap?r=n.displacementMap:n.normalMap?r=n.normalMap:n.bumpMap?r=n.bumpMap:n.roughnessMap?r=n.roughnessMap:n.metalnessMap?r=n.metalnessMap:n.alphaMap?r=n.alphaMap:n.emissiveMap?r=n.emissiveMap:n.clearcoatMap?r=n.clearcoatMap:n.clearcoatNormalMap?r=n.clearcoatNormalMap:n.clearcoatRoughnessMap&&(r=n.clearcoatRoughnessMap),void 0!==r&&(r.isWebGLRenderTarget&&(r=r.texture),!0===r.matrixAutoUpdate&&r.updateMatrix(),e.uvTransform.value.copy(r.matrix)),n.aoMap?s=n.aoMap:n.lightMap&&(s=n.lightMap),void 0!==s&&(s.isWebGLRenderTarget&&(s=s.texture),!0===s.matrixAutoUpdate&&s.updateMatrix(),e.uv2Transform.value.copy(s.matrix))}function n(e,n){e.roughness.value=n.roughness,e.metalness.value=n.metalness,n.roughnessMap&&(e.roughnessMap.value=n.roughnessMap),n.metalnessMap&&(e.metalnessMap.value=n.metalnessMap),n.emissiveMap&&(e.emissiveMap.value=n.emissiveMap),n.bumpMap&&(e.bumpMap.value=n.bumpMap,e.bumpScale.value=n.bumpScale,1===n.side&&(e.bumpScale.value*=-1)),n.normalMap&&(e.normalMap.value=n.normalMap,e.normalScale.value.copy(n.normalScale),1===n.side&&e.normalScale.value.negate()),n.displacementMap&&(e.displacementMap.value=n.displacementMap,e.displacementScale.value=n.displacementScale,e.displacementBias.value=n.displacementBias),t.get(n).envMap&&(e.envMapIntensity.value=n.envMapIntensity)}return{refreshFogUniforms:function(t,e){t.fogColor.value.copy(e.color),e.isFog?(t.fogNear.value=e.near,t.fogFar.value=e.far):e.isFogExp2&&(t.fogDensity.value=e.density)},refreshMaterialUniforms:function(t,i,r,s){i.isMeshBasicMaterial?e(t,i):i.isMeshLambertMaterial?(e(t,i),function(t,e){e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap)}(t,i)):i.isMeshToonMaterial?(e(t,i),function(t,e){e.gradientMap&&(t.gradientMap.value=e.gradientMap),e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap),e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1)),e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate()),e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshPhongMaterial?(e(t,i),function(t,e){t.specular.value.copy(e.specular),t.shininess.value=Math.max(e.shininess,1e-4),e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap),e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1)),e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate()),e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshStandardMaterial?(e(t,i),i.isMeshPhysicalMaterial?function(t,e){n(t,e),t.reflectivity.value=e.reflectivity,t.clearcoat.value=e.clearcoat,t.clearcoatRoughness.value=e.clearcoatRoughness,e.sheen&&t.sheen.value.copy(e.sheen),e.clearcoatMap&&(t.clearcoatMap.value=e.clearcoatMap),e.clearcoatRoughnessMap&&(t.clearcoatRoughnessMap.value=e.clearcoatRoughnessMap),e.clearcoatNormalMap&&(t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),t.clearcoatNormalMap.value=e.clearcoatNormalMap,1===e.side&&t.clearcoatNormalScale.value.negate()),t.transmission.value=e.transmission,e.transmissionMap&&(t.transmissionMap.value=e.transmissionMap)}(t,i):n(t,i)):i.isMeshMatcapMaterial?(e(t,i),function(t,e){e.matcap&&(t.matcap.value=e.matcap),e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1)),e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate()),e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshDepthMaterial?(e(t,i),function(t,e){e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshDistanceMaterial?(e(t,i),function(t,e){e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias),t.referencePosition.value.copy(e.referencePosition),t.nearDistance.value=e.nearDistance,t.farDistance.value=e.farDistance}(t,i)):i.isMeshNormalMaterial?(e(t,i),function(t,e){e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1)),e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate()),e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isLineBasicMaterial?(function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity}(t,i),i.isLineDashedMaterial&&function(t,e){t.dashSize.value=e.dashSize,t.totalSize.value=e.dashSize+e.gapSize,t.scale.value=e.scale}(t,i)):i.isPointsMaterial?function(t,e,n,i){let r;t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.size.value=e.size*n,t.scale.value=.5*i,e.map&&(t.map.value=e.map),e.alphaMap&&(t.alphaMap.value=e.alphaMap),e.map?r=e.map:e.alphaMap&&(r=e.alphaMap),void 0!==r&&(!0===r.matrixAutoUpdate&&r.updateMatrix(),t.uvTransform.value.copy(r.matrix))}(t,i,r,s):i.isSpriteMaterial?function(t,e){let n;t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.rotation.value=e.rotation,e.map&&(t.map.value=e.map),e.alphaMap&&(t.alphaMap.value=e.alphaMap),e.map?n=e.map:e.alphaMap&&(n=e.alphaMap),void 0!==n&&(!0===n.matrixAutoUpdate&&n.updateMatrix(),t.uvTransform.value.copy(n.matrix))}(t,i):i.isShadowMaterial?(t.color.value.copy(i.color),t.opacity.value=i.opacity):i.isShaderMaterial&&(i.uniformsNeedUpdate=!1)}}}function Xst(t){const e=void 0!==(t=t||{}).canvas?t.canvas:function(){const t=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return t.style.display="block",t}(),n=void 0!==t.context?t.context:null,i=void 0!==t.alpha&&t.alpha,r=void 0===t.depth||t.depth,s=void 0===t.stencil||t.stencil,o=void 0!==t.antialias&&t.antialias,a=void 0===t.premultipliedAlpha||t.premultipliedAlpha,l=void 0!==t.preserveDrawingBuffer&&t.preserveDrawingBuffer,c=void 0!==t.powerPreference?t.powerPreference:"default",u=void 0!==t.failIfMajorPerformanceCaveat&&t.failIfMajorPerformanceCaveat;let h=null,d=null;const p=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=jtt,this.physicallyCorrectLights=!1,this.toneMapping=0,this.toneMappingExposure=1,this.maxMorphTargets=8,this.maxMorphNormals=4;const f=this;let m=!1,g=null,y=0,v=0,b=null,A=null,x=-1,w=null;const _=new cet,S=new cet;let E=null,C=e.width,I=e.height,T=1,M=null,k=null;const R=new cet(0,0,C,I),N=new cet(0,0,C,I);let L=!1;const D=new Hit;let B=!1,O=!1;const P=new Uet,F=new det,$={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function z(){return null===b?T:1}let U,H,V,G,W,j,Q,q,X,Y,K,J,Z,tt,et,nt,it,rt,st,ot,at,lt=n;function ct(t,n){for(let i=0;i<t.length;i++){const r=e.getContext(t[i],n);if(null!==r)return r}return null}try{const t={alpha:i,depth:r,stencil:s,antialias:o,premultipliedAlpha:a,preserveDrawingBuffer:l,powerPreference:c,failIfMajorPerformanceCaveat:u};if(e.addEventListener("webglcontextlost",pt,!1),e.addEventListener("webglcontextrestored",ft,!1),null===lt){const e=["webgl2","webgl","experimental-webgl"];if(!0===f.isWebGL1Renderer&&e.shift(),lt=ct(e,t),null===lt)throw ct(e)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===lt.getShaderPrecisionFormat&&(lt.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(St){throw console.error("THREE.WebGLRenderer: "+St.message),St}function ut(){U=new ert(lt),H=new Jit(lt,U,t),U.init(H),ot=new Vst(lt,U,H),V=new Ust(lt,U,H),V.scissor(S.copy(N).multiplyScalar(T).floor()),V.viewport(_.copy(R).multiplyScalar(T).floor()),G=new rrt(lt),W=new Ist,j=new Hst(lt,U,V,W,H,ot,G),Q=new trt(f),q=new Git(lt,H),at=new Yit(lt,U,q,H),X=new nrt(lt,q,G,at),Y=new lrt(lt,X,q,G),it=new art(lt),et=new Zit(W),K=new Cst(f,Q,U,H,at,et),J=new qst(W),Z=new Rst(W),tt=new Pst(U,H),nt=new Xit(f,Q,V,Y,a),rt=new Kit(lt,U,G,H),st=new irt(lt,U,G,H),G.programs=K.programs,f.capabilities=H,f.extensions=U,f.properties=W,f.renderLists=Z,f.state=V,f.info=G}ut();const ht=new Qst(f,lt);this.xr=ht;const dt=new zst(f,Y,H.maxTextureSize);function pt(t){t.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),m=!0}function ft(){console.log("THREE.WebGLRenderer: Context Restored."),m=!1,ut()}function mt(t){const e=t.target;e.removeEventListener("dispose",mt),function(t){gt(t),W.remove(t)}(e)}function gt(t){const e=W.get(t).program;void 0!==e&&K.releaseProgram(e)}this.shadowMap=dt,this.getContext=function(){return lt},this.getContextAttributes=function(){return lt.getContextAttributes()},this.forceContextLoss=function(){const t=U.get("WEBGL_lose_context");t&&t.loseContext()},this.forceContextRestore=function(){const t=U.get("WEBGL_lose_context");t&&t.restoreContext()},this.getPixelRatio=function(){return T},this.setPixelRatio=function(t){void 0!==t&&(T=t,this.setSize(C,I,!1))},this.getSize=function(t){return void 0===t&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),t=new eet),t.set(C,I)},this.setSize=function(t,n,i){ht.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(C=t,I=n,e.width=Math.floor(t*T),e.height=Math.floor(n*T),!1!==i&&(e.style.width=t+"px",e.style.height=n+"px"),this.setViewport(0,0,t,n))},this.getDrawingBufferSize=function(t){return void 0===t&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),t=new eet),t.set(C*T,I*T).floor()},this.setDrawingBufferSize=function(t,n,i){C=t,I=n,T=i,e.width=Math.floor(t*i),e.height=Math.floor(n*i),this.setViewport(0,0,t,n)},this.getCurrentViewport=function(t){return void 0===t&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),t=new cet),t.copy(_)},this.getViewport=function(t){return t.copy(R)},this.setViewport=function(t,e,n,i){t.isVector4?R.set(t.x,t.y,t.z,t.w):R.set(t,e,n,i),V.viewport(_.copy(R).multiplyScalar(T).floor())},this.getScissor=function(t){return t.copy(N)},this.setScissor=function(t,e,n,i){t.isVector4?N.set(t.x,t.y,t.z,t.w):N.set(t,e,n,i),V.scissor(S.copy(N).multiplyScalar(T).floor())},this.getScissorTest=function(){return L},this.setScissorTest=function(t){V.setScissorTest(L=t)},this.setOpaqueSort=function(t){M=t},this.setTransparentSort=function(t){k=t},this.getClearColor=function(t){return void 0===t&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),t=new Dnt),t.copy(nt.getClearColor())},this.setClearColor=function(){nt.setClearColor.apply(nt,arguments)},this.getClearAlpha=function(){return nt.getClearAlpha()},this.setClearAlpha=function(){nt.setClearAlpha.apply(nt,arguments)},this.clear=function(t,e,n){let i=0;(void 0===t||t)&&(i|=16384),(void 0===e||e)&&(i|=256),(void 0===n||n)&&(i|=1024),lt.clear(i)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",pt,!1),e.removeEventListener("webglcontextrestored",ft,!1),Z.dispose(),tt.dispose(),W.dispose(),Q.dispose(),Y.dispose(),at.dispose(),ht.dispose(),vt.stop()},this.renderBufferImmediate=function(t,e){at.initAttributes();const n=W.get(t);t.hasPositions&&!n.position&&(n.position=lt.createBuffer()),t.hasNormals&&!n.normal&&(n.normal=lt.createBuffer()),t.hasUvs&&!n.uv&&(n.uv=lt.createBuffer()),t.hasColors&&!n.color&&(n.color=lt.createBuffer());const i=e.getAttributes();t.hasPositions&&(lt.bindBuffer(34962,n.position),lt.bufferData(34962,t.positionArray,35048),at.enableAttribute(i.position),lt.vertexAttribPointer(i.position,3,5126,!1,0,0)),t.hasNormals&&(lt.bindBuffer(34962,n.normal),lt.bufferData(34962,t.normalArray,35048),at.enableAttribute(i.normal),lt.vertexAttribPointer(i.normal,3,5126,!1,0,0)),t.hasUvs&&(lt.bindBuffer(34962,n.uv),lt.bufferData(34962,t.uvArray,35048),at.enableAttribute(i.uv),lt.vertexAttribPointer(i.uv,2,5126,!1,0,0)),t.hasColors&&(lt.bindBuffer(34962,n.color),lt.bufferData(34962,t.colorArray,35048),at.enableAttribute(i.color),lt.vertexAttribPointer(i.color,3,5126,!1,0,0)),at.disableUnusedAttributes(),lt.drawArrays(4,0,t.count),t.count=0},this.renderBufferDirect=function(t,e,n,i,r,s){null===e&&(e=$);const o=r.isMesh&&r.matrixWorld.determinant()<0,a=_t(t,e,i,r);V.setMaterial(i,o);let l=n.index;const c=n.attributes.position;if(null===l){if(void 0===c||0===c.count)return}else if(0===l.count)return;let u,h=1;!0===i.wireframe&&(l=X.getWireframeAttribute(n),h=2),(i.morphTargets||i.morphNormals)&&it.update(r,n,i,a),at.setup(r,i,a,n,l);let d=rt;null!==l&&(u=q.get(l),d=st,d.setIndex(u));const p=null!==l?l.count:c.count,f=n.drawRange.start*h,m=n.drawRange.count*h,g=null!==s?s.start*h:0,y=null!==s?s.count*h:1/0,v=Math.max(f,g),b=Math.min(p,f+m,g+y)-1,A=Math.max(0,b-v+1);if(0!==A){if(r.isMesh)!0===i.wireframe?(V.setLineWidth(i.wireframeLinewidth*z()),d.setMode(1)):d.setMode(4);else if(r.isLine){let t=i.linewidth;void 0===t&&(t=1),V.setLineWidth(t*z()),d.setMode(r.isLineSegments?1:r.isLineLoop?2:3)}else r.isPoints?d.setMode(0):r.isSprite&&d.setMode(4);if(r.isInstancedMesh)d.renderInstances(v,A,r.count);else if(n.isInstancedBufferGeometry){const t=Math.min(n.instanceCount,n._maxInstanceCount);d.renderInstances(v,A,t)}else d.render(v,A)}},this.compile=function(t,e){d=tt.get(t),d.init(),t.traverseVisible(function(t){t.isLight&&t.layers.test(e.layers)&&(d.pushLight(t),t.castShadow&&d.pushShadow(t))}),d.setupLights();const n=new WeakMap;t.traverse(function(e){const i=e.material;if(i)if(Array.isArray(i))for(let r=0;r<i.length;r++){const s=i[r];!1===n.has(s)&&(wt(s,t,e),n.set(s))}else!1===n.has(i)&&(wt(i,t,e),n.set(i))})};let yt=null;const vt=new Vit;function bt(t,e,n,i){if(!1===t.visible)return;if(t.layers.test(e.layers))if(t.isGroup)n=t.renderOrder;else if(t.isLOD)!0===t.autoUpdate&&t.update(e);else if(t.isLight)d.pushLight(t),t.castShadow&&d.pushShadow(t);else if(t.isSprite){if(!t.frustumCulled||D.intersectsSprite(t)){i&&F.setFromMatrixPosition(t.matrixWorld).applyMatrix4(P);const e=Y.update(t),r=t.material;r.visible&&h.push(t,e,r,n,F.z,null)}}else if(t.isImmediateRenderObject)i&&F.setFromMatrixPosition(t.matrixWorld).applyMatrix4(P),h.push(t,null,t.material,n,F.z,null);else if((t.isMesh||t.isLine||t.isPoints)&&(t.isSkinnedMesh&&t.skeleton.frame!==G.render.frame&&(t.skeleton.update(),t.skeleton.frame=G.render.frame),!t.frustumCulled||D.intersectsObject(t))){i&&F.setFromMatrixPosition(t.matrixWorld).applyMatrix4(P);const e=Y.update(t),r=t.material;if(Array.isArray(r)){const i=e.groups;for(let s=0,o=i.length;s<o;s++){const o=i[s],a=r[o.materialIndex];a&&a.visible&&h.push(t,e,a,n,F.z,o)}}else r.visible&&h.push(t,e,r,n,F.z,null)}const r=t.children;for(let s=0,o=r.length;s<o;s++)bt(r[s],e,n,i)}function At(t,e,n){const i=!0===e.isScene?e.overrideMaterial:null;for(let r=0,s=t.length;r<s;r++){const s=t[r],o=s.object,a=s.geometry,l=null===i?s.material:i,c=s.group;if(n.isArrayCamera){const t=n.cameras;for(let n=0,i=t.length;n<i;n++){const i=t[n];o.layers.test(i.layers)&&(V.viewport(_.copy(i.viewport)),d.setupLightsView(i),xt(o,e,i,a,l,c))}}else xt(o,e,n,a,l,c)}}function xt(t,e,n,i,r,s){if(t.onBeforeRender(f,e,n,i,r,s),t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix),t.isImmediateRenderObject){const i=_t(n,e,r,t);V.setMaterial(r),at.reset(),function(t,e){t.render(function(t){f.renderBufferImmediate(t,e)})}(t,i)}else f.renderBufferDirect(n,e,i,r,t,s);t.onAfterRender(f,e,n,i,r,s)}function wt(t,e,n){!0!==e.isScene&&(e=$);const i=W.get(t),r=d.state.lights,s=r.state.version,o=K.getParameters(t,r.state,d.state.shadowsArray,e,n),a=K.getProgramCacheKey(o);let l=i.program,c=!0;if(i.environment=t.isMeshStandardMaterial?e.environment:null,i.fog=e.fog,i.envMap=Q.get(t.envMap||i.environment),void 0===l)t.addEventListener("dispose",mt);else if(l.cacheKey!==a)gt(t);else if(i.lightsStateVersion!==s)c=!1;else{if(void 0!==o.shaderID)return;c=!1}c&&(o.uniforms=K.getUniforms(t),t.onBeforeCompile(o,f),l=K.acquireProgram(o,a),i.program=l,i.uniforms=o.uniforms,i.outputEncoding=o.outputEncoding);const u=i.uniforms;(t.isShaderMaterial||t.isRawShaderMaterial)&&!0!==t.clipping||(i.numClippingPlanes=et.numPlanes,i.numIntersection=et.numIntersection,u.clippingPlanes=et.uniform),i.needsLights=function(t){return t.isMeshLambertMaterial||t.isMeshToonMaterial||t.isMeshPhongMaterial||t.isMeshStandardMaterial||t.isShadowMaterial||t.isShaderMaterial&&!0===t.lights}(t),i.lightsStateVersion=s,i.needsLights&&(u.ambientLightColor.value=r.state.ambient,u.lightProbe.value=r.state.probe,u.directionalLights.value=r.state.directional,u.directionalLightShadows.value=r.state.directionalShadow,u.spotLights.value=r.state.spot,u.spotLightShadows.value=r.state.spotShadow,u.rectAreaLights.value=r.state.rectArea,u.ltc_1.value=r.state.rectAreaLTC1,u.ltc_2.value=r.state.rectAreaLTC2,u.pointLights.value=r.state.point,u.pointLightShadows.value=r.state.pointShadow,u.hemisphereLights.value=r.state.hemi,u.directionalShadowMap.value=r.state.directionalShadowMap,u.directionalShadowMatrix.value=r.state.directionalShadowMatrix,u.spotShadowMap.value=r.state.spotShadowMap,u.spotShadowMatrix.value=r.state.spotShadowMatrix,u.pointShadowMap.value=r.state.pointShadowMap,u.pointShadowMatrix.value=r.state.pointShadowMatrix);const h=i.program.getUniforms(),p=sst.seqWithValue(h.seq,u);i.uniformsList=p}function _t(t,e,n,i){!0!==e.isScene&&(e=$),j.resetTextureUnits();const r=e.fog,s=n.isMeshStandardMaterial?e.environment:null,o=null===b?f.outputEncoding:b.texture.encoding,a=Q.get(n.envMap||s),l=W.get(n),c=d.state.lights;!0!==B||!0!==O&&t===w||et.setState(n,t,t===w&&n.id===x),n.version===l.__version?n.fog&&l.fog!==r||l.environment!==s||l.needsLights&&l.lightsStateVersion!==c.state.version?wt(n,e,i):void 0===l.numClippingPlanes||l.numClippingPlanes===et.numPlanes&&l.numIntersection===et.numIntersection?(l.outputEncoding!==o||l.envMap!==a)&&wt(n,e,i):wt(n,e,i):(wt(n,e,i),l.__version=n.version);let u=!1,h=!1,p=!1;const m=l.program,g=m.getUniforms(),y=l.uniforms;if(V.useProgram(m.program)&&(u=!0,h=!0,p=!0),n.id!==x&&(x=n.id,h=!0),u||w!==t){if(g.setValue(lt,"projectionMatrix",t.projectionMatrix),H.logarithmicDepthBuffer&&g.setValue(lt,"logDepthBufFC",2/(Math.log(t.far+1)/Math.LN2)),w!==t&&(w=t,h=!0,p=!0),n.isShaderMaterial||n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshStandardMaterial||n.envMap){const e=g.map.cameraPosition;void 0!==e&&e.setValue(lt,F.setFromMatrixPosition(t.matrixWorld))}(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial)&&g.setValue(lt,"isOrthographic",!0===t.isOrthographicCamera),(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial||n.isShadowMaterial||n.skinning)&&g.setValue(lt,"viewMatrix",t.matrixWorldInverse)}if(n.skinning){g.setOptional(lt,i,"bindMatrix"),g.setOptional(lt,i,"bindMatrixInverse");const t=i.skeleton;if(t){const e=t.bones;if(H.floatVertexTextures){if(null===t.boneTexture){let n=Math.sqrt(4*e.length);n=tet.ceilPowerOfTwo(n),n=Math.max(n,4);const i=new Float32Array(n*n*4);i.set(t.boneMatrices);const r=new $it(i,n,n,Ptt,Ltt);t.boneMatrices=i,t.boneTexture=r,t.boneTextureSize=n}g.setValue(lt,"boneTexture",t.boneTexture,j),g.setValue(lt,"boneTextureSize",t.boneTextureSize)}else g.setOptional(lt,t,"boneMatrices")}}var v,A;return(h||l.receiveShadow!==i.receiveShadow)&&(l.receiveShadow=i.receiveShadow,g.setValue(lt,"receiveShadow",i.receiveShadow)),h&&(g.setValue(lt,"toneMappingExposure",f.toneMappingExposure),l.needsLights&&((v=y).ambientLightColor.needsUpdate=A=p,v.lightProbe.needsUpdate=A,v.directionalLights.needsUpdate=A,v.directionalLightShadows.needsUpdate=A,v.pointLights.needsUpdate=A,v.pointLightShadows.needsUpdate=A,v.spotLights.needsUpdate=A,v.spotLightShadows.needsUpdate=A,v.rectAreaLights.needsUpdate=A,v.hemisphereLights.needsUpdate=A),r&&n.fog&&J.refreshFogUniforms(y,r),J.refreshMaterialUniforms(y,n,T,I),sst.upload(lt,l.uniformsList,y,j)),n.isShaderMaterial&&!0===n.uniformsNeedUpdate&&(sst.upload(lt,l.uniformsList,y,j),n.uniformsNeedUpdate=!1),n.isSpriteMaterial&&g.setValue(lt,"center",i.center),g.setValue(lt,"modelViewMatrix",i.modelViewMatrix),g.setValue(lt,"normalMatrix",i.normalMatrix),g.setValue(lt,"modelMatrix",i.matrixWorld),m}vt.setAnimationLoop(function(t){ht.isPresenting||yt&&yt(t)}),"undefined"!=typeof window&&vt.setContext(window),this.setAnimationLoop=function(t){yt=t,ht.setAnimationLoop(t),null===t?vt.stop():vt.start()},this.render=function(t,e){let n,i;if(void 0!==arguments[2]&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),n=arguments[2]),void 0!==arguments[3]&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),i=arguments[3]),void 0!==e&&!0!==e.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===m)return;at.resetDefaultState(),x=-1,w=null,!0===t.autoUpdate&&t.updateMatrixWorld(),null===e.parent&&e.updateMatrixWorld(),!0===ht.enabled&&!0===ht.isPresenting&&(e=ht.getCamera(e)),!0===t.isScene&&t.onBeforeRender(f,t,e,n||b),d=tt.get(t,p.length),d.init(),p.push(d),P.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),D.setFromProjectionMatrix(P),O=this.localClippingEnabled,B=et.init(this.clippingPlanes,O,e),h=Z.get(t,e),h.init(),bt(t,e,0,f.sortObjects),h.finish(),!0===f.sortObjects&&h.sort(M,k),!0===B&&et.beginShadows();const r=d.state.shadowsArray;dt.render(r,t,e),d.setupLights(),d.setupLightsView(e),!0===B&&et.endShadows(),!0===this.info.autoReset&&this.info.reset(),void 0!==n&&this.setRenderTarget(n),nt.render(h,t,e,i);const s=h.opaque,o=h.transparent;s.length>0&&At(s,t,e),o.length>0&&At(o,t,e),!0===t.isScene&&t.onAfterRender(f,t,e),null!==b&&(j.updateRenderTargetMipmap(b),j.updateMultisampleRenderTarget(b)),V.buffers.depth.setTest(!0),V.buffers.depth.setMask(!0),V.buffers.color.setMask(!0),V.setPolygonOffset(!1),p.pop(),d=p.length>0?p[p.length-1]:null,h=null},this.setFramebuffer=function(t){g!==t&&null===b&&lt.bindFramebuffer(36160,t),g=t},this.getActiveCubeFace=function(){return y},this.getActiveMipmapLevel=function(){return v},this.getRenderList=function(){return h},this.setRenderList=function(t){h=t},this.getRenderTarget=function(){return b},this.setRenderTarget=function(t,e=0,n=0){b=t,y=e,v=n,t&&void 0===W.get(t).__webglFramebuffer&&j.setupRenderTarget(t);let i=g,r=!1;if(t){const n=W.get(t).__webglFramebuffer;t.isWebGLCubeRenderTarget?(i=n[e],r=!0):i=t.isWebGLMultisampleRenderTarget?W.get(t).__webglMultisampledFramebuffer:n,_.copy(t.viewport),S.copy(t.scissor),E=t.scissorTest}else _.copy(R).multiplyScalar(T).floor(),S.copy(N).multiplyScalar(T).floor(),E=L;if(A!==i&&(lt.bindFramebuffer(36160,i),A=i),V.viewport(_),V.scissor(S),V.setScissorTest(E),r){const i=W.get(t.texture);lt.framebufferTexture2D(36160,36064,34069+e,i.__webglTexture,n)}},this.readRenderTargetPixels=function(t,e,n,i,r,s,o){if(!t||!t.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let a=W.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==o&&(a=a[o]),a){let o=!1;a!==A&&(lt.bindFramebuffer(36160,a),o=!0);try{const a=t.texture,l=a.format,c=a.type;if(l!==Ptt&&ot.convert(l)!==lt.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const u=c===Dtt&&(U.has("EXT_color_buffer_half_float")||H.isWebGL2&&U.has("EXT_color_buffer_float"));if(!(1009===c||ot.convert(c)===lt.getParameter(35738)||c===Ltt&&(H.isWebGL2||U.has("OES_texture_float")||U.has("WEBGL_color_buffer_float"))||u))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");36053===lt.checkFramebufferStatus(36160)?e>=0&&e<=t.width-i&&n>=0&&n<=t.height-r&&lt.readPixels(e,n,i,r,ot.convert(l),ot.convert(c),s):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{o&&lt.bindFramebuffer(36160,A)}}},this.copyFramebufferToTexture=function(t,e,n=0){const i=Math.pow(2,-n),r=Math.floor(e.image.width*i),s=Math.floor(e.image.height*i),o=ot.convert(e.format);j.setTexture2D(e,0),lt.copyTexImage2D(3553,n,o,t.x,t.y,r,s,0),V.unbindTexture()},this.copyTextureToTexture=function(t,e,n,i=0){const r=e.image.width,s=e.image.height,o=ot.convert(n.format),a=ot.convert(n.type);j.setTexture2D(n,0),lt.pixelStorei(37440,n.flipY),lt.pixelStorei(37441,n.premultiplyAlpha),lt.pixelStorei(3317,n.unpackAlignment),e.isDataTexture?lt.texSubImage2D(3553,i,t.x,t.y,r,s,o,a,e.image.data):e.isCompressedTexture?lt.compressedTexSubImage2D(3553,i,t.x,t.y,e.mipmaps[0].width,e.mipmaps[0].height,o,e.mipmaps[0].data):lt.texSubImage2D(3553,i,t.x,t.y,o,a,e.image),0===i&&n.generateMipmaps&&lt.generateMipmap(3553),V.unbindTexture()},this.initTexture=function(t){j.setTexture2D(t,0),V.unbindTexture()},this.resetState=function(){V.reset(),at.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}function Yst(t){Xst.call(this,t)}function Kst(t,e){this.array=t,this.stride=e,this.count=void 0!==t?t.length/e:0,this.usage=qtt,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=tet.generateUUID()}(Fst.prototype=Object.create(Pnt.prototype)).constructor=Fst,Fst.prototype.isMeshDepthMaterial=!0,Fst.prototype.copy=function(t){return Pnt.prototype.copy.call(this,t),this.depthPacking=t.depthPacking,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this},($st.prototype=Object.create(Pnt.prototype)).constructor=$st,$st.prototype.isMeshDistanceMaterial=!0,$st.prototype.copy=function(t){return Pnt.prototype.copy.call(this,t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this},Gst.prototype=Object.assign(Object.create(Dit.prototype),{constructor:Gst,isArrayCamera:!0}),Wst.prototype=Object.assign(Object.create(dnt.prototype),{constructor:Wst,isGroup:!0}),Object.assign(jst.prototype,{constructor:jst,getHandSpace:function(){return null===this._hand&&(this._hand=new Wst,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand},getTargetRaySpace:function(){return null===this._targetRay&&(this._targetRay=new Wst,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1),this._targetRay},getGripSpace:function(){return null===this._grip&&(this._grip=new Wst,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1),this._grip},dispatchEvent:function(t){return null!==this._targetRay&&this._targetRay.dispatchEvent(t),null!==this._grip&&this._grip.dispatchEvent(t),null!==this._hand&&this._hand.dispatchEvent(t),this},disconnect:function(t){return this.dispatchEvent({type:"disconnected",data:t}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this},update:function(t,e,n){let i=null,r=null,s=null;const o=this._targetRay,a=this._grip,l=this._hand;if(t&&"visible-blurred"!==e.session.visibilityState)if(l&&t.hand){s=!0;for(const s of t.hand.values()){const t=e.getJointPose(s,n);if(void 0===l.joints[s.jointName]){const t=new Wst;t.matrixAutoUpdate=!1,t.visible=!1,l.joints[s.jointName]=t,l.add(t)}const i=l.joints[s.jointName];null!==t&&(i.matrix.fromArray(t.transform.matrix),i.matrix.decompose(i.position,i.rotation,i.scale),i.jointRadius=t.radius),i.visible=null!==t}const i=l.joints["index-finger-tip"].position.distanceTo(l.joints["thumb-tip"].position),r=.02,o=.005;l.inputState.pinching&&i>r+o?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!l.inputState.pinching&&i<=r-o&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else null!==o&&(i=e.getPose(t.targetRaySpace,n),null!==i&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale))),null!==a&&t.gripSpace&&(r=e.getPose(t.gripSpace,n),null!==r&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale)));return null!==o&&(o.visible=null!==i),null!==a&&(a.visible=null!==r),null!==l&&(l.visible=null!==s),this}}),Object.assign(Qst.prototype,Ktt.prototype),Yst.prototype=Object.assign(Object.create(Xst.prototype),{constructor:Yst,isWebGL1Renderer:!0}),Object.defineProperty(Kst.prototype,"needsUpdate",{set:function(t){!0===t&&this.version++}}),Object.assign(Kst.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setUsage:function(t){return this.usage=t,this},copy:function(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this},copyAt:function(t,e,n){t*=this.stride,n*=e.stride;for(let i=0,r=this.stride;i<r;i++)this.array[t+i]=e.array[n+i];return this},set:function(t,e=0){return this.array.set(t,e),this},clone:function(t){void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=tet.generateUUID()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new Kst(new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),this.stride);return e.setUsage(this.usage),e},onUpload:function(t){return this.onUploadCallback=t,this},toJSON:function(t){return void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=tet.generateUUID()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}});const Jst=new det;function Zst(t,e,n,i){this.name="",this.data=t,this.itemSize=e,this.offset=n,this.normalized=!0===i}function tot(t){Pnt.call(this),this.type="SpriteMaterial",this.color=new Dnt(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(t)}let eot;Object.defineProperties(Zst.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}},needsUpdate:{set:function(t){this.data.needsUpdate=t}}}),Object.assign(Zst.prototype,{isInterleavedBufferAttribute:!0,applyMatrix4:function(t){for(let e=0,n=this.data.count;e<n;e++)Jst.x=this.getX(e),Jst.y=this.getY(e),Jst.z=this.getZ(e),Jst.applyMatrix4(t),this.setXYZ(e,Jst.x,Jst.y,Jst.z);return this},setX:function(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this},setY:function(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this},setZ:function(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this},setW:function(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this},getX:function(t){return this.data.array[t*this.data.stride+this.offset]},getY:function(t){return this.data.array[t*this.data.stride+this.offset+1]},getZ:function(t){return this.data.array[t*this.data.stride+this.offset+2]},getW:function(t){return this.data.array[t*this.data.stride+this.offset+3]},setXY:function(t,e,n){return this.data.array[(t=t*this.data.stride+this.offset)+0]=e,this.data.array[t+1]=n,this},setXYZ:function(t,e,n,i){return this.data.array[(t=t*this.data.stride+this.offset)+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this},setXYZW:function(t,e,n,i,r){return this.data.array[(t=t*this.data.stride+this.offset)+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this.data.array[t+3]=r,this},clone:function(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return new Unt(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new Zst(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)},toJSON:function(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}),(tot.prototype=Object.create(Pnt.prototype)).constructor=tot,tot.prototype.isSpriteMaterial=!0,tot.prototype.copy=function(t){return Pnt.prototype.copy.call(this,t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this};const not=new det,iot=new det,rot=new det,sot=new eet,oot=new eet,aot=new Uet,lot=new det,cot=new det,uot=new det,hot=new eet,dot=new eet,pot=new eet;function fot(t){if(dnt.call(this),this.type="Sprite",void 0===eot){eot=new lit;const t=new Kst(new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),5);eot.setIndex([0,1,2,0,2,3]),eot.setAttribute("position",new Zst(t,3,0,!1)),eot.setAttribute("uv",new Zst(t,2,3,!1))}this.geometry=eot,this.material=void 0!==t?t:new tot,this.center=new eet(.5,.5)}function mot(t,e,n,i,r,s){sot.subVectors(t,n).addScalar(.5).multiply(i),void 0!==r?(oot.x=s*sot.x-r*sot.y,oot.y=r*sot.x+s*sot.y):oot.copy(sot),t.copy(e),t.x+=oot.x,t.y+=oot.y,t.applyMatrix4(aot)}fot.prototype=Object.assign(Object.create(dnt.prototype),{constructor:fot,isSprite:!0,raycast:function(t,e){null===t.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),iot.setFromMatrixScale(this.matrixWorld),aot.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),rot.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&iot.multiplyScalar(-rot.z);const n=this.material.rotation;let i,r;0!==n&&(r=Math.cos(n),i=Math.sin(n));const s=this.center;mot(lot.set(-.5,-.5,0),rot,s,iot,i,r),mot(cot.set(.5,-.5,0),rot,s,iot,i,r),mot(uot.set(.5,.5,0),rot,s,iot,i,r),hot.set(0,0),dot.set(1,0),pot.set(1,1);let o=t.ray.intersectTriangle(lot,cot,uot,!1,not);if(null===o&&(mot(cot.set(-.5,.5,0),rot,s,iot,i,r),dot.set(0,1),o=t.ray.intersectTriangle(lot,uot,cot,!1,not),null===o))return;const a=t.ray.origin.distanceTo(not);a<t.near||a>t.far||e.push({distance:a,point:not.clone(),uv:Int.getUV(not,lot,cot,uot,hot,dot,pot,new eet),face:null,object:this})},copy:function(t){return dnt.prototype.copy.call(this,t),void 0!==t.center&&this.center.copy(t.center),this.material=t.material,this}});const got=new det,yot=new det;function vot(){dnt.call(this),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}vot.prototype=Object.assign(Object.create(dnt.prototype),{constructor:vot,isLOD:!0,copy:function(t){dnt.prototype.copy.call(this,t,!1);const e=t.levels;for(let n=0,i=e.length;n<i;n++){const t=e[n];this.addLevel(t.object.clone(),t.distance)}return this.autoUpdate=t.autoUpdate,this},addLevel:function(t,e=0){e=Math.abs(e);const n=this.levels;let i;for(i=0;i<n.length&&!(e<n[i].distance);i++);return n.splice(i,0,{distance:e,object:t}),this.add(t),this},getCurrentLevel:function(){return this._currentLevel},getObjectForDistance:function(t){const e=this.levels;if(e.length>0){let n,i;for(n=1,i=e.length;n<i&&!(t<e[n].distance);n++);return e[n-1].object}return null},raycast:function(t,e){if(this.levels.length>0){got.setFromMatrixPosition(this.matrixWorld);const n=t.ray.origin.distanceTo(got);this.getObjectForDistance(n).raycast(t,e)}},update:function(t){const e=this.levels;if(e.length>1){got.setFromMatrixPosition(t.matrixWorld),yot.setFromMatrixPosition(this.matrixWorld);const n=got.distanceTo(yot)/t.zoom;let i,r;for(e[0].object.visible=!0,i=1,r=e.length;i<r&&n>=e[i].distance;i++)e[i-1].object.visible=!1,e[i].object.visible=!0;for(this._currentLevel=i-1;i<r;i++)e[i].object.visible=!1}},toJSON:function(t){const e=dnt.prototype.toJSON.call(this,t);!1===this.autoUpdate&&(e.object.autoUpdate=!1),e.object.levels=[];const n=this.levels;for(let i=0,r=n.length;i<r;i++){const t=n[i];e.object.levels.push({object:t.object.uuid,distance:t.distance})}return e}});const bot=new det,Aot=new cet,xot=new cet,wot=new det,_ot=new Uet;function Sot(t,e){t&&t.isGeometry&&console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),Cit.call(this,t,e),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Uet,this.bindMatrixInverse=new Uet}function Eot(){dnt.call(this),this.type="Bone"}Sot.prototype=Object.assign(Object.create(Cit.prototype),{constructor:Sot,isSkinnedMesh:!0,copy:function(t){return Cit.prototype.copy.call(this,t),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this},bind:function(t,e){this.skeleton=t,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){const t=new cet,e=this.geometry.attributes.skinWeight;for(let n=0,i=e.count;n<i;n++){t.x=e.getX(n),t.y=e.getY(n),t.z=e.getZ(n),t.w=e.getW(n);const i=1/t.manhattanLength();i!==1/0?t.multiplyScalar(i):t.set(1,0,0,0),e.setXYZW(n,t.x,t.y,t.z,t.w)}},updateMatrixWorld:function(t){Cit.prototype.updateMatrixWorld.call(this,t),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},boneTransform:function(t,e){const n=this.skeleton,i=this.geometry;Aot.fromBufferAttribute(i.attributes.skinIndex,t),xot.fromBufferAttribute(i.attributes.skinWeight,t),bot.fromBufferAttribute(i.attributes.position,t).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let r=0;r<4;r++){const t=xot.getComponent(r);if(0!==t){const i=Aot.getComponent(r);_ot.multiplyMatrices(n.bones[i].matrixWorld,n.boneInverses[i]),e.addScaledVector(wot.copy(bot).applyMatrix4(_ot),t)}}return e.applyMatrix4(this.bindMatrixInverse)}}),Eot.prototype=Object.assign(Object.create(dnt.prototype),{constructor:Eot,isBone:!0});const Cot=new Uet,Iot=new Uet;function Tot(t=[],e=[]){this.uuid=tet.generateUUID(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}Object.assign(Tot.prototype,{init:function(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(16*t.length),0===e.length)this.calculateInverses();else if(t.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let t=0,e=this.bones.length;t<e;t++)this.boneInverses.push(new Uet)}},calculateInverses:function(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const e=new Uet;this.bones[t]&&e.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(e)}},pose:function(){for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&e.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&(e.parent&&e.parent.isBone?(e.matrix.copy(e.parent.matrixWorld).invert(),e.matrix.multiply(e.matrixWorld)):e.matrix.copy(e.matrixWorld),e.matrix.decompose(e.position,e.quaternion,e.scale))}},update:function(){const t=this.bones,e=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let r=0,s=t.length;r<s;r++)Cot.multiplyMatrices(t[r]?t[r].matrixWorld:Iot,e[r]),Cot.toArray(n,16*r);null!==i&&(i.needsUpdate=!0)},clone:function(){return new Tot(this.bones,this.boneInverses)},getBoneByName:function(t){for(let e=0,n=this.bones.length;e<n;e++){const n=this.bones[e];if(n.name===t)return n}},dispose:function(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)},fromJSON:function(t,e){this.uuid=t.uuid;for(let n=0,i=t.bones.length;n<i;n++){const i=t.bones[n];let r=e[i];void 0===r&&(console.warn("THREE.Skeleton: No bone found with UUID:",i),r=new Eot),this.bones.push(r),this.boneInverses.push((new Uet).fromArray(t.boneInverses[n]))}return this.init(),this},toJSON:function(){const t={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,n=this.boneInverses;for(let i=0,r=e.length;i<r;i++)t.bones.push(e[i].uuid),t.boneInverses.push(n[i].toArray());return t}});const Mot=new Uet,kot=new Uet,Rot=[],Not=new Cit;function Lot(t,e,n){Cit.call(this,t,e),this.instanceMatrix=new Unt(new Float32Array(16*n),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}function Dot(t){Pnt.call(this),this.type="LineBasicMaterial",this.color=new Dnt(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(t)}Lot.prototype=Object.assign(Object.create(Cit.prototype),{constructor:Lot,isInstancedMesh:!0,copy:function(t){return Cit.prototype.copy.call(this,t),this.instanceMatrix.copy(t.instanceMatrix),null!==t.instanceColor&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this},getColorAt:function(t,e){e.fromArray(this.instanceColor.array,3*t)},getMatrixAt:function(t,e){e.fromArray(this.instanceMatrix.array,16*t)},raycast:function(t,e){const n=this.matrixWorld,i=this.count;if(Not.geometry=this.geometry,Not.material=this.material,void 0!==Not.material)for(let r=0;r<i;r++){this.getMatrixAt(r,Mot),kot.multiplyMatrices(n,Mot),Not.matrixWorld=kot,Not.raycast(t,Rot);for(let t=0,n=Rot.length;t<n;t++){const n=Rot[t];n.instanceId=r,n.object=this,e.push(n)}Rot.length=0}},setColorAt:function(t,e){null===this.instanceColor&&(this.instanceColor=new Unt(new Float32Array(3*this.count),3)),e.toArray(this.instanceColor.array,3*t)},setMatrixAt:function(t,e){e.toArray(this.instanceMatrix.array,16*t)},updateMorphTargets:function(){},dispose:function(){this.dispatchEvent({type:"dispose"})}}),(Dot.prototype=Object.create(Pnt.prototype)).constructor=Dot,Dot.prototype.isLineBasicMaterial=!0,Dot.prototype.copy=function(t){return Pnt.prototype.copy.call(this,t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.morphTargets=t.morphTargets,this};const Bot=new det,Oot=new det,Pot=new Uet,Fot=new zet,$ot=new Net;function zot(t=new lit,e=new Dot){dnt.call(this),this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}zot.prototype=Object.assign(Object.create(dnt.prototype),{constructor:zot,isLine:!0,copy:function(t){return dnt.prototype.copy.call(this,t),this.material=t.material,this.geometry=t.geometry,this},computeLineDistances:function(){const t=this.geometry;if(t.isBufferGeometry)if(null===t.index){const e=t.attributes.position,n=[0];for(let t=1,i=e.count;t<i;t++)Bot.fromBufferAttribute(e,t-1),Oot.fromBufferAttribute(e,t),n[t]=n[t-1],n[t]+=Bot.distanceTo(Oot);t.setAttribute("lineDistance",new Ynt(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this},raycast:function(t,e){const n=this.geometry,i=this.matrixWorld,r=t.params.Line.threshold;if(null===n.boundingSphere&&n.computeBoundingSphere(),$ot.copy(n.boundingSphere),$ot.applyMatrix4(i),$ot.radius+=r,!1===t.ray.intersectsSphere($ot))return;Pot.copy(i).invert(),Fot.copy(t.ray).applyMatrix4(Pot);const s=r/((this.scale.x+this.scale.y+this.scale.z)/3),o=s*s,a=new det,l=new det,c=new det,u=new det,h=this.isLineSegments?2:1;if(n.isBufferGeometry){const i=n.index,r=n.attributes.position;if(null!==i){const n=i.array;for(let i=0,s=n.length-1;i<s;i+=h){const s=n[i+1];if(a.fromBufferAttribute(r,n[i]),l.fromBufferAttribute(r,s),Fot.distanceSqToSegment(a,l,u,c)>o)continue;u.applyMatrix4(this.matrixWorld);const h=t.ray.origin.distanceTo(u);h<t.near||h>t.far||e.push({distance:h,point:c.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this})}}else for(let n=0,s=r.count-1;n<s;n+=h){if(a.fromBufferAttribute(r,n),l.fromBufferAttribute(r,n+1),Fot.distanceSqToSegment(a,l,u,c)>o)continue;u.applyMatrix4(this.matrixWorld);const i=t.ray.origin.distanceTo(u);i<t.near||i>t.far||e.push({distance:i,point:c.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});const Uot=new det,Hot=new det;function Vot(t,e){zot.call(this,t,e),this.type="LineSegments"}function Got(t,e){zot.call(this,t,e),this.type="LineLoop"}function Wot(t){Pnt.call(this),this.type="PointsMaterial",this.color=new Dnt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(t)}Vot.prototype=Object.assign(Object.create(zot.prototype),{constructor:Vot,isLineSegments:!0,computeLineDistances:function(){const t=this.geometry;if(t.isBufferGeometry)if(null===t.index){const e=t.attributes.position,n=[];for(let t=0,i=e.count;t<i;t+=2)Uot.fromBufferAttribute(e,t),Hot.fromBufferAttribute(e,t+1),n[t]=0===t?0:n[t-1],n[t+1]=n[t]+Uot.distanceTo(Hot);t.setAttribute("lineDistance",new Ynt(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}),Got.prototype=Object.assign(Object.create(zot.prototype),{constructor:Got,isLineLoop:!0}),(Wot.prototype=Object.create(Pnt.prototype)).constructor=Wot,Wot.prototype.isPointsMaterial=!0,Wot.prototype.copy=function(t){return Pnt.prototype.copy.call(this,t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.morphTargets=t.morphTargets,this};const jot=new Uet,Qot=new zet,qot=new Net,Xot=new det;function Yot(t=new lit,e=new Wot){dnt.call(this),this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}function Kot(t,e,n,i,r,s,o){const a=Qot.distanceSqToPoint(t);if(a<n){const n=new det;Qot.closestPointToPoint(t,n),n.applyMatrix4(i);const l=r.ray.origin.distanceTo(n);if(l<r.near||l>r.far)return;s.push({distance:l,distanceToRay:Math.sqrt(a),point:n,index:e,face:null,object:o})}}function Jot(t,e,n,i,r,s,o,a,l){oet.call(this,t,e,n,i,r,s,o,a,l),this.format=void 0!==o?o:Ott,this.minFilter=void 0!==s?s:Mtt,this.magFilter=void 0!==r?r:Mtt,this.generateMipmaps=!1;const c=this;"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback(function e(){c.needsUpdate=!0,t.requestVideoFrameCallback(e)})}function Zot(t,e,n,i,r,s,o,a,l,c,u,h){oet.call(this,null,s,o,a,l,c,i,r,u,h),this.image={width:e,height:n},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}function tat(t,e,n,i,r,s,o,a,l){oet.call(this,t,e,n,i,r,s,o,a,l),this.needsUpdate=!0}function eat(t,e,n,i,r,s,o,a,l,c){if((c=void 0!==c?c:Ftt)!==Ftt&&c!==$tt)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===n&&c===Ftt&&(n=Rtt),void 0===n&&c===$tt&&(n=Btt),oet.call(this,null,i,r,s,o,a,c,n,l),this.image={width:t,height:e},this.magFilter=void 0!==o?o:Ttt,this.minFilter=void 0!==a?a:Ttt,this.flipY=!1,this.generateMipmaps=!1}function nat(t,e,n,i,r){let s,o;if(r===function(t,e,n,i){let r=0;for(let s=e,o=n-i;s<n;s+=i)r+=(t[o]-t[s])*(t[s+1]+t[o+1]),o=s;return r}(t,e,n,i)>0)for(s=e;s<n;s+=i)o=_at(s,t[s],t[s+1],o);else for(s=n-i;s>=e;s-=i)o=_at(s,t[s],t[s+1],o);return o&&yat(o,o.next)&&(Sat(o),o=o.next),o}function iat(t,e){if(!t)return t;e||(e=t);let n,i=t;do{if(n=!1,i.steiner||!yat(i,i.next)&&0!==gat(i.prev,i,i.next))i=i.next;else{if(Sat(i),i=e=i.prev,i===i.next)break;n=!0}}while(n||i!==e);return e}function rat(t,e,n,i,r,s,o){if(!t)return;!o&&s&&function(t,e,n,i){let r=t;do{null===r.z&&(r.z=dat(r.x,r.y,e,n,i)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next}while(r!==t);r.prevZ.nextZ=null,r.prevZ=null,function(t){let e,n,i,r,s,o,a,l,c=1;do{for(n=t,t=null,s=null,o=0;n;){for(o++,i=n,a=0,e=0;e<c&&(a++,i=i.nextZ,i);e++);for(l=c;a>0||l>0&&i;)0!==a&&(0===l||!i||n.z<=i.z)?(r=n,n=n.nextZ,a--):(r=i,i=i.nextZ,l--),s?s.nextZ=r:t=r,r.prevZ=s,s=r;n=i}s.nextZ=null,c*=2}while(o>1)}(r)}(t,i,r,s);let a,l,c=t;for(;t.prev!==t.next;)if(a=t.prev,l=t.next,s?oat(t,i,r,s):sat(t))e.push(a.i/n),e.push(t.i/n),e.push(l.i/n),Sat(t),t=l.next,c=l.next;else if((t=l)===c){o?1===o?rat(t=aat(iat(t),e,n),e,n,i,r,s,2):2===o&&lat(t,e,n,i,r,s):rat(iat(t),e,n,i,r,s,1);break}}function sat(t){const e=t.prev,n=t,i=t.next;if(gat(e,n,i)>=0)return!1;let r=t.next.next;for(;r!==t.prev;){if(fat(e.x,e.y,n.x,n.y,i.x,i.y,r.x,r.y)&&gat(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function oat(t,e,n,i){const r=t.prev,s=t,o=t.next;if(gat(r,s,o)>=0)return!1;const a=r.x>s.x?r.x>o.x?r.x:o.x:s.x>o.x?s.x:o.x,l=r.y>s.y?r.y>o.y?r.y:o.y:s.y>o.y?s.y:o.y,c=dat(r.x<s.x?r.x<o.x?r.x:o.x:s.x<o.x?s.x:o.x,r.y<s.y?r.y<o.y?r.y:o.y:s.y<o.y?s.y:o.y,e,n,i),u=dat(a,l,e,n,i);let h=t.prevZ,d=t.nextZ;for(;h&&h.z>=c&&d&&d.z<=u;){if(h!==t.prev&&h!==t.next&&fat(r.x,r.y,s.x,s.y,o.x,o.y,h.x,h.y)&&gat(h.prev,h,h.next)>=0)return!1;if(h=h.prevZ,d!==t.prev&&d!==t.next&&fat(r.x,r.y,s.x,s.y,o.x,o.y,d.x,d.y)&&gat(d.prev,d,d.next)>=0)return!1;d=d.nextZ}for(;h&&h.z>=c;){if(h!==t.prev&&h!==t.next&&fat(r.x,r.y,s.x,s.y,o.x,o.y,h.x,h.y)&&gat(h.prev,h,h.next)>=0)return!1;h=h.prevZ}for(;d&&d.z<=u;){if(d!==t.prev&&d!==t.next&&fat(r.x,r.y,s.x,s.y,o.x,o.y,d.x,d.y)&&gat(d.prev,d,d.next)>=0)return!1;d=d.nextZ}return!0}function aat(t,e,n){let i=t;do{const r=i.prev,s=i.next.next;!yat(r,s)&&vat(r,i,i.next,s)&&xat(r,s)&&xat(s,r)&&(e.push(r.i/n),e.push(i.i/n),e.push(s.i/n),Sat(i),Sat(i.next),i=t=s),i=i.next}while(i!==t);return iat(i)}function lat(t,e,n,i,r,s){let o=t;do{let t=o.next.next;for(;t!==o.prev;){if(o.i!==t.i&&mat(o,t)){let a=wat(o,t);return o=iat(o,o.next),a=iat(a,a.next),rat(o,e,n,i,r,s),void rat(a,e,n,i,r,s)}t=t.next}o=o.next}while(o!==t)}function cat(t,e){return t.x-e.x}function uat(t,e){if(e=function(t,e){let n=e;const i=t.x,r=t.y;let s,o=-1/0;do{if(r<=n.y&&r>=n.next.y&&n.next.y!==n.y){const t=n.x+(r-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(t<=i&&t>o){if(o=t,t===i){if(r===n.y)return n;if(r===n.next.y)return n.next}s=n.x<n.next.x?n:n.next}}n=n.next}while(n!==e);if(!s)return null;if(i===o)return s;const a=s,l=s.x,c=s.y;let u,h=1/0;n=s;do{i>=n.x&&n.x>=l&&i!==n.x&&fat(r<c?i:o,r,l,c,r<c?o:i,r,n.x,n.y)&&(u=Math.abs(r-n.y)/(i-n.x),xat(n,t)&&(u<h||u===h&&(n.x>s.x||n.x===s.x&&hat(s,n)))&&(s=n,h=u)),n=n.next}while(n!==a);return s}(t,e)){const n=wat(e,t);iat(e,e.next),iat(n,n.next)}}function hat(t,e){return gat(t.prev,t,e.prev)<0&&gat(e.next,t,t.next)<0}function dat(t,e,n,i,r){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-n)*r)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-i)*r)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function pat(t){let e=t,n=t;do{(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next}while(e!==t);return n}function fat(t,e,n,i,r,s,o,a){return(r-o)*(e-a)-(t-o)*(s-a)>=0&&(t-o)*(i-a)-(n-o)*(e-a)>=0&&(n-o)*(s-a)-(r-o)*(i-a)>=0}function mat(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&vat(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}(t,e)&&(xat(t,e)&&xat(e,t)&&function(t,e){let n=t,i=!1;const r=(t.x+e.x)/2,s=(t.y+e.y)/2;do{n.y>s!=n.next.y>s&&n.next.y!==n.y&&r<(n.next.x-n.x)*(s-n.y)/(n.next.y-n.y)+n.x&&(i=!i),n=n.next}while(n!==t);return i}(t,e)&&(gat(t.prev,t,e.prev)||gat(t,e.prev,e))||yat(t,e)&&gat(t.prev,t,t.next)>0&&gat(e.prev,e,e.next)>0)}function gat(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function yat(t,e){return t.x===e.x&&t.y===e.y}function vat(t,e,n,i){const r=Aat(gat(t,e,n)),s=Aat(gat(t,e,i)),o=Aat(gat(n,i,t)),a=Aat(gat(n,i,e));return r!==s&&o!==a||!(0!==r||!bat(t,n,e))||!(0!==s||!bat(t,i,e))||!(0!==o||!bat(n,t,i))||!(0!==a||!bat(n,e,i))}function bat(t,e,n){return e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y)}function Aat(t){return t>0?1:t<0?-1:0}function xat(t,e){return gat(t.prev,t,t.next)<0?gat(t,e,t.next)>=0&&gat(t,t.prev,e)>=0:gat(t,e,t.prev)<0||gat(t,t.next,e)<0}function wat(t,e){const n=new Eat(t.i,t.x,t.y),i=new Eat(e.i,e.x,e.y),r=t.next,s=e.prev;return t.next=e,e.prev=t,n.next=r,r.prev=n,i.next=n,n.prev=i,s.next=i,i.prev=s,i}function _at(t,e,n,i){const r=new Eat(t,e,n);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function Sat(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function Eat(t,e,n){this.i=t,this.x=e,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}Yot.prototype=Object.assign(Object.create(dnt.prototype),{constructor:Yot,isPoints:!0,copy:function(t){return dnt.prototype.copy.call(this,t),this.material=t.material,this.geometry=t.geometry,this},raycast:function(t,e){const n=this.geometry,i=this.matrixWorld,r=t.params.Points.threshold;if(null===n.boundingSphere&&n.computeBoundingSphere(),qot.copy(n.boundingSphere),qot.applyMatrix4(i),qot.radius+=r,!1===t.ray.intersectsSphere(qot))return;jot.copy(i).invert(),Qot.copy(t.ray).applyMatrix4(jot);const s=r/((this.scale.x+this.scale.y+this.scale.z)/3),o=s*s;if(n.isBufferGeometry){const r=n.index,s=n.attributes.position;if(null!==r){const n=r.array;for(let r=0,a=n.length;r<a;r++){const a=n[r];Xot.fromBufferAttribute(s,a),Kot(Xot,a,o,i,t,e,this)}}else for(let n=0,a=s.count;n<a;n++)Xot.fromBufferAttribute(s,n),Kot(Xot,n,o,i,t,e,this)}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}),Jot.prototype=Object.assign(Object.create(oet.prototype),{constructor:Jot,clone:function(){return new this.constructor(this.image).copy(this)},isVideoTexture:!0,update:function(){const t=this.image;0=="requestVideoFrameCallback"in t&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}),(Zot.prototype=Object.create(oet.prototype)).constructor=Zot,Zot.prototype.isCompressedTexture=!0,(tat.prototype=Object.create(oet.prototype)).constructor=tat,tat.prototype.isCanvasTexture=!0,(eat.prototype=Object.create(oet.prototype)).constructor=eat,eat.prototype.isDepthTexture=!0,new det,new det,new det,new Int;const Cat={area:function(t){const e=t.length;let n=0;for(let i=e-1,r=0;r<e;i=r++)n+=t[i].x*t[r].y-t[r].x*t[i].y;return.5*n},isClockWise:function(t){return Cat.area(t)<0},triangulateShape:function(t,e){const n=[],i=[],r=[];Iat(t),Tat(n,t);let s=t.length;e.forEach(Iat);for(let a=0;a<e.length;a++)i.push(s),s+=e[a].length,Tat(n,e[a]);const o=function(t,e,n){n=n||2;const i=e&&e.length,r=i?e[0]*n:t.length;let s=nat(t,0,r,n,!0);const o=[];if(!s||s.next===s.prev)return o;let a,l,c,u,h,d,p;if(i&&(s=function(t,e,n,i){const r=[];let s,o,a,l,c;for(s=0,o=e.length;s<o;s++)a=e[s]*i,l=s<o-1?e[s+1]*i:t.length,c=nat(t,a,l,i,!1),c===c.next&&(c.steiner=!0),r.push(pat(c));for(r.sort(cat),s=0;s<r.length;s++)uat(r[s],n),n=iat(n,n.next);return n}(t,e,s,n)),t.length>80*n){a=c=t[0],l=u=t[1];for(let e=n;e<r;e+=n)h=t[e],d=t[e+1],h<a&&(a=h),d<l&&(l=d),h>c&&(c=h),d>u&&(u=d);p=Math.max(c-a,u-l),p=0!==p?1/p:0}return rat(s,o,n,a,l,p),o}(n,i);for(let a=0;a<o.length;a+=3)r.push(o.slice(a,a+3));return r}};function Iat(t){const e=t.length;e>2&&t[e-1].equals(t[0])&&t.pop()}function Tat(t,e){for(let n=0;n<e.length;n++)t.push(e[n].x),t.push(e[n].y)}class Mat extends lit{constructor(t,e){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const n=this,i=[],r=[];for(let o=0,a=t.length;o<a;o++)s(t[o]);function s(t){const s=[],o=void 0!==e.curveSegments?e.curveSegments:12,a=void 0!==e.steps?e.steps:1;let l=void 0!==e.depth?e.depth:100,c=void 0===e.bevelEnabled||e.bevelEnabled,u=void 0!==e.bevelThickness?e.bevelThickness:6,h=void 0!==e.bevelSize?e.bevelSize:u-2,d=void 0!==e.bevelOffset?e.bevelOffset:0,p=void 0!==e.bevelSegments?e.bevelSegments:3;const f=e.extrudePath,m=void 0!==e.UVGenerator?e.UVGenerator:kat;void 0!==e.amount&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),l=e.amount);let g,y,v,b,A,x=!1;f&&(g=f.getSpacedPoints(a),x=!0,c=!1,y=f.computeFrenetFrames(a,!1),v=new det,b=new det,A=new det),c||(p=0,u=0,h=0,d=0);const w=t.extractPoints(o);let _=w.shape;const S=w.holes;if(!Cat.isClockWise(_)){_=_.reverse();for(let t=0,e=S.length;t<e;t++){const e=S[t];Cat.isClockWise(e)&&(S[t]=e.reverse())}}const E=Cat.triangulateShape(_,S),C=_;for(let e=0,n=S.length;e<n;e++)_=_.concat(S[e]);function I(t,e,n){return e||console.error("THREE.ExtrudeGeometry: vec does not exist"),e.clone().multiplyScalar(n).add(t)}const T=_.length,M=E.length;function k(t,e,n){let i,r,s;const o=t.x-e.x,a=t.y-e.y,l=n.x-t.x,c=n.y-t.y,u=o*o+a*a;if(Math.abs(o*c-a*l)>Number.EPSILON){const h=Math.sqrt(u),d=Math.sqrt(l*l+c*c),p=e.x-a/h,f=e.y+o/h,m=((n.x-c/d-p)*c-(n.y+l/d-f)*l)/(o*c-a*l);i=p+o*m-t.x,r=f+a*m-t.y;const g=i*i+r*r;if(g<=2)return new eet(i,r);s=Math.sqrt(g/2)}else{let t=!1;o>Number.EPSILON?l>Number.EPSILON&&(t=!0):o<-Number.EPSILON?l<-Number.EPSILON&&(t=!0):Math.sign(a)===Math.sign(c)&&(t=!0),t?(i=-a,r=o,s=Math.sqrt(u)):(i=o,r=a,s=Math.sqrt(u/2))}return new eet(i/s,r/s)}const R=[];for(let e=0,n=C.length,i=n-1,r=e+1;e<n;e++,i++,r++)i===n&&(i=0),r===n&&(r=0),R[e]=k(C[e],C[i],C[r]);const N=[];let L,D=R.concat();for(let e=0,n=S.length;e<n;e++){const t=S[e];L=[];for(let e=0,n=t.length,i=n-1,r=e+1;e<n;e++,i++,r++)i===n&&(i=0),r===n&&(r=0),L[e]=k(t[e],t[i],t[r]);N.push(L),D=D.concat(L)}for(let e=0;e<p;e++){const t=e/p,n=u*Math.cos(t*Math.PI/2),i=h*Math.sin(t*Math.PI/2)+d;for(let e=0,r=C.length;e<r;e++){const t=I(C[e],R[e],i);P(t.x,t.y,-n)}for(let e=0,r=S.length;e<r;e++){const t=S[e];L=N[e];for(let e=0,r=t.length;e<r;e++){const r=I(t[e],L[e],i);P(r.x,r.y,-n)}}}const B=h+d;for(let e=0;e<T;e++){const t=c?I(_[e],D[e],B):_[e];x?(b.copy(y.normals[0]).multiplyScalar(t.x),v.copy(y.binormals[0]).multiplyScalar(t.y),A.copy(g[0]).add(b).add(v),P(A.x,A.y,A.z)):P(t.x,t.y,0)}for(let e=1;e<=a;e++)for(let t=0;t<T;t++){const n=c?I(_[t],D[t],B):_[t];x?(b.copy(y.normals[e]).multiplyScalar(n.x),v.copy(y.binormals[e]).multiplyScalar(n.y),A.copy(g[e]).add(b).add(v),P(A.x,A.y,A.z)):P(n.x,n.y,l/a*e)}for(let e=p-1;e>=0;e--){const t=e/p,n=u*Math.cos(t*Math.PI/2),i=h*Math.sin(t*Math.PI/2)+d;for(let e=0,r=C.length;e<r;e++){const t=I(C[e],R[e],i);P(t.x,t.y,l+n)}for(let e=0,r=S.length;e<r;e++){const t=S[e];L=N[e];for(let e=0,r=t.length;e<r;e++){const r=I(t[e],L[e],i);x?P(r.x,r.y+g[a-1].y,g[a-1].x+n):P(r.x,r.y,l+n)}}}function O(t,e){let n=t.length;for(;--n>=0;){const i=n;let r=n-1;r<0&&(r=t.length-1);for(let t=0,n=a+2*p;t<n;t++){const n=T*t,s=T*(t+1);$(e+i+n,e+r+n,e+r+s,e+i+s)}}}function P(t,e,n){s.push(t),s.push(e),s.push(n)}function F(t,e,r){z(t),z(e),z(r);const s=i.length/3,o=m.generateTopUV(n,i,s-3,s-2,s-1);U(o[0]),U(o[1]),U(o[2])}function $(t,e,r,s){z(t),z(e),z(s),z(e),z(r),z(s);const o=i.length/3,a=m.generateSideWallUV(n,i,o-6,o-3,o-2,o-1);U(a[0]),U(a[1]),U(a[3]),U(a[1]),U(a[2]),U(a[3])}function z(t){i.push(s[3*t+0]),i.push(s[3*t+1]),i.push(s[3*t+2])}function U(t){r.push(t.x),r.push(t.y)}!function(){const t=i.length/3;if(c){let t=0,e=T*t;for(let n=0;n<M;n++){const t=E[n];F(t[2]+e,t[1]+e,t[0]+e)}t=a+2*p,e=T*t;for(let n=0;n<M;n++){const t=E[n];F(t[0]+e,t[1]+e,t[2]+e)}}else{for(let t=0;t<M;t++){const e=E[t];F(e[2],e[1],e[0])}for(let t=0;t<M;t++){const e=E[t];F(e[0]+T*a,e[1]+T*a,e[2]+T*a)}}n.addGroup(t,i.length/3-t,0)}(),function(){const t=i.length/3;let e=0;O(C,e),e+=C.length;for(let n=0,i=S.length;n<i;n++){const t=S[n];O(t,e),e+=t.length}n.addGroup(t,i.length/3-t,1)}()}this.setAttribute("position",new Ynt(i,3)),this.setAttribute("uv",new Ynt(r,2)),this.computeVertexNormals()}toJSON(){const t=lit.prototype.toJSON.call(this);return function(t,e,n){if(n.shapes=[],Array.isArray(t))for(let i=0,r=t.length;i<r;i++)n.shapes.push(t[i].uuid);else n.shapes.push(t.uuid);return void 0!==e.extrudePath&&(n.options.extrudePath=e.extrudePath.toJSON()),n}(this.parameters.shapes,this.parameters.options,t)}}const kat={generateTopUV:function(t,e,n,i,r){const s=e[3*i],o=e[3*i+1],a=e[3*r],l=e[3*r+1];return[new eet(e[3*n],e[3*n+1]),new eet(s,o),new eet(a,l)]},generateSideWallUV:function(t,e,n,i,r,s){const o=e[3*n],a=e[3*n+1],l=e[3*n+2],c=e[3*i],u=e[3*i+1],h=e[3*i+2],d=e[3*r],p=e[3*r+1],f=e[3*r+2],m=e[3*s],g=e[3*s+1],y=e[3*s+2];return Math.abs(a-u)<.01?[new eet(o,1-l),new eet(c,1-h),new eet(d,1-f),new eet(m,1-y)]:[new eet(a,1-l),new eet(u,1-h),new eet(p,1-f),new eet(g,1-y)]}};function Rat(t,e,n){lit.call(this),this.type="ParametricGeometry",this.parameters={func:t,slices:e,stacks:n};const i=[],r=[],s=[],o=[],a=1e-5,l=new det,c=new det,u=new det,h=new det,d=new det;t.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");const p=e+1;for(let f=0;f<=n;f++){const i=f/n;for(let n=0;n<=e;n++){const p=n/e;t(p,i,c),r.push(c.x,c.y,c.z),p-a>=0?(t(p-a,i,u),h.subVectors(c,u)):(t(p+a,i,u),h.subVectors(u,c)),i-a>=0?(t(p,i-a,u),d.subVectors(c,u)):(t(p,i+a,u),d.subVectors(u,c)),l.crossVectors(h,d).normalize(),s.push(l.x,l.y,l.z),o.push(p,i)}}for(let f=0;f<n;f++)for(let t=0;t<e;t++){const e=f*p+t+1,n=(f+1)*p+t+1,r=(f+1)*p+t;i.push(f*p+t,e,r),i.push(e,n,r)}this.setIndex(i),this.setAttribute("position",new Ynt(r,3)),this.setAttribute("normal",new Ynt(s,3)),this.setAttribute("uv",new Ynt(o,2))}(Rat.prototype=Object.create(lit.prototype)).constructor=Rat;class Nat extends lit{constructor(t,e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const n=[],i=[],r=[],s=[];let o=0,a=0;if(!1===Array.isArray(t))l(t);else for(let c=0;c<t.length;c++)l(t[c]),this.addGroup(o,a,c),o+=a,a=0;function l(t){const o=i.length/3,l=t.extractPoints(e);let c=l.shape;const u=l.holes;!1===Cat.isClockWise(c)&&(c=c.reverse());for(let e=0,n=u.length;e<n;e++){const t=u[e];!0===Cat.isClockWise(t)&&(u[e]=t.reverse())}const h=Cat.triangulateShape(c,u);for(let e=0,n=u.length;e<n;e++)c=c.concat(u[e]);for(let e=0,n=c.length;e<n;e++){const t=c[e];i.push(t.x,t.y,0),r.push(0,0,1),s.push(t.x,t.y)}for(let e=0,i=h.length;e<i;e++){const t=h[e];n.push(t[0]+o,t[1]+o,t[2]+o),a+=3}}this.setIndex(n),this.setAttribute("position",new Ynt(i,3)),this.setAttribute("normal",new Ynt(r,3)),this.setAttribute("uv",new Ynt(s,2))}toJSON(){const t=lit.prototype.toJSON.call(this);return function(t,e){if(e.shapes=[],Array.isArray(t))for(let n=0,i=t.length;n<i;n++)e.shapes.push(t[n].uuid);else e.shapes.push(t.uuid);return e}(this.parameters.shapes,t)}}function Lat(t){Pnt.call(this),this.type="ShadowMaterial",this.color=new Dnt(0),this.transparent=!0,this.setValues(t)}function Dat(t){Nit.call(this,t),this.type="RawShaderMaterial"}function Bat(t){Pnt.call(this),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Dnt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Dnt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new eet(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.vertexTangents=!1,this.setValues(t)}function Oat(t){Bat.call(this),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new eet(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,Object.defineProperty(this,"ior",{get:function(){return(1+.4*this.reflectivity)/(1-.4*this.reflectivity)},set:function(t){this.reflectivity=tet.clamp(2.5*(t-1)/(t+1),0,1)}}),this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(t)}function Pat(t){Pnt.call(this),this.type="MeshPhongMaterial",this.color=new Dnt(16777215),this.specular=new Dnt(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Dnt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new eet(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}function Fat(t){Pnt.call(this),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Dnt(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Dnt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new eet(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}function $at(t){Pnt.call(this),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new eet(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}function zat(t){Pnt.call(this),this.type="MeshLambertMaterial",this.color=new Dnt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Dnt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}function Uat(t){Pnt.call(this),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Dnt(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new eet(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}function Hat(t){Dot.call(this),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}(Lat.prototype=Object.create(Pnt.prototype)).constructor=Lat,Lat.prototype.isShadowMaterial=!0,Lat.prototype.copy=function(t){return Pnt.prototype.copy.call(this,t),this.color.copy(t.color),this},(Dat.prototype=Object.create(Nit.prototype)).constructor=Dat,Dat.prototype.isRawShaderMaterial=!0,(Bat.prototype=Object.create(Pnt.prototype)).constructor=Bat,Bat.prototype.isMeshStandardMaterial=!0,Bat.prototype.copy=function(t){return Pnt.prototype.copy.call(this,t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this.vertexTangents=t.vertexTangents,this},(Oat.prototype=Object.create(Bat.prototype)).constructor=Oat,Oat.prototype.isMeshPhysicalMaterial=!0,Oat.prototype.copy=function(t){return Bat.prototype.copy.call(this,t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.reflectivity=t.reflectivity,this.sheen=t.sheen?(this.sheen||new Dnt).copy(t.sheen):null,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this},(Pat.prototype=Object.create(Pnt.prototype)).constructor=Pat,Pat.prototype.isMeshPhongMaterial=!0,Pat.prototype.copy=function(t){return Pnt.prototype.copy.call(this,t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this},(Fat.prototype=Object.create(Pnt.prototype)).constructor=Fat,Fat.prototype.isMeshToonMaterial=!0,Fat.prototype.copy=function(t){return Pnt.prototype.copy.call(this,t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this},($at.prototype=Object.create(Pnt.prototype)).constructor=$at,$at.prototype.isMeshNormalMaterial=!0,$at.prototype.copy=function(t){return Pnt.prototype.copy.call(this,t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this},(zat.prototype=Object.create(Pnt.prototype)).constructor=zat,zat.prototype.isMeshLambertMaterial=!0,zat.prototype.copy=function(t){return Pnt.prototype.copy.call(this,t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this},(Uat.prototype=Object.create(Pnt.prototype)).constructor=Uat,Uat.prototype.isMeshMatcapMaterial=!0,Uat.prototype.copy=function(t){return Pnt.prototype.copy.call(this,t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this},(Hat.prototype=Object.create(Dot.prototype)).constructor=Hat,Hat.prototype.isLineDashedMaterial=!0,Hat.prototype.copy=function(t){return Dot.prototype.copy.call(this,t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this};var Vat=Object.freeze({__proto__:null,ShadowMaterial:Lat,SpriteMaterial:tot,RawShaderMaterial:Dat,ShaderMaterial:Nit,PointsMaterial:Wot,MeshPhysicalMaterial:Oat,MeshStandardMaterial:Bat,MeshPhongMaterial:Pat,MeshToonMaterial:Fat,MeshNormalMaterial:$at,MeshLambertMaterial:zat,MeshDepthMaterial:Fst,MeshDistanceMaterial:$st,MeshBasicMaterial:Fnt,MeshMatcapMaterial:Uat,LineDashedMaterial:Hat,LineBasicMaterial:Dot,Material:Pnt});const Gat={arraySlice:function(t,e,n){return Gat.isTypedArray(t)?new t.constructor(t.subarray(e,void 0!==n?n:t.length)):t.slice(e,n)},convertArray:function(t,e,n){return!t||!n&&t.constructor===e?t:"number"==typeof e.BYTES_PER_ELEMENT?new e(t):Array.prototype.slice.call(t)},isTypedArray:function(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)},getKeyframeOrder:function(t){const e=t.length,n=new Array(e);for(let i=0;i!==e;++i)n[i]=i;return n.sort(function(e,n){return t[e]-t[n]}),n},sortedArray:function(t,e,n){const i=t.length,r=new t.constructor(i);for(let s=0,o=0;o!==i;++s){const i=n[s]*e;for(let n=0;n!==e;++n)r[o++]=t[i+n]}return r},flattenJSON:function(t,e,n,i){let r=1,s=t[0];for(;void 0!==s&&void 0===s[i];)s=t[r++];if(void 0===s)return;let o=s[i];if(void 0!==o)if(Array.isArray(o))do{o=s[i],void 0!==o&&(e.push(s.time),n.push.apply(n,o)),s=t[r++]}while(void 0!==s);else if(void 0!==o.toArray)do{o=s[i],void 0!==o&&(e.push(s.time),o.toArray(n,n.length)),s=t[r++]}while(void 0!==s);else do{o=s[i],void 0!==o&&(e.push(s.time),n.push(o)),s=t[r++]}while(void 0!==s)},subclip:function(t,e,n,i,r=30){const s=t.clone();s.name=e;const o=[];for(let l=0;l<s.tracks.length;++l){const t=s.tracks[l],e=t.getValueSize(),a=[],c=[];for(let s=0;s<t.times.length;++s){const o=t.times[s]*r;if(!(o<n||o>=i)){a.push(t.times[s]);for(let n=0;n<e;++n)c.push(t.values[s*e+n])}}0!==a.length&&(t.times=Gat.convertArray(a,t.times.constructor),t.values=Gat.convertArray(c,t.values.constructor),o.push(t))}s.tracks=o;let a=1/0;for(let l=0;l<s.tracks.length;++l)a>s.tracks[l].times[0]&&(a=s.tracks[l].times[0]);for(let l=0;l<s.tracks.length;++l)s.tracks[l].shift(-1*a);return s.resetDuration(),s},makeClipAdditive:function(t,e=0,n=t,i=30){i<=0&&(i=30);const r=n.tracks.length,s=e/i;for(let o=0;o<r;++o){const e=n.tracks[o],i=e.ValueTypeName;if("bool"===i||"string"===i)continue;const r=t.tracks.find(function(t){return t.name===e.name&&t.ValueTypeName===i});if(void 0===r)continue;let a=0;const l=e.getValueSize();e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(a=l/3);let c=0;const u=r.getValueSize();r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=u/3);const h=e.times.length-1;let d;if(s<=e.times[0])d=Gat.arraySlice(e.values,a,l-a);else if(s>=e.times[h]){const t=h*l+a;d=Gat.arraySlice(e.values,t,t+l-a)}else{const t=e.createInterpolant(),n=a,i=l-a;t.evaluate(s),d=Gat.arraySlice(t.resultBuffer,n,i)}"quaternion"===i&&(new het).fromArray(d).normalize().conjugate().toArray(d);const p=r.times.length;for(let t=0;t<p;++t){const e=t*u+c;if("quaternion"===i)het.multiplyQuaternionsFlat(r.values,e,d,0,r.values,e);else{const t=u-2*c;for(let n=0;n<t;++n)r.values[e+n]-=d[n]}}}return t.blendMode=2501,t}};function Wat(t,e,n,i){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=void 0!==i?i:new e.constructor(n),this.sampleValues=e,this.valueSize=n}function jat(t,e,n,i){Wat.call(this,t,e,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0}function Qat(t,e,n,i){Wat.call(this,t,e,n,i)}function qat(t,e,n,i){Wat.call(this,t,e,n,i)}function Xat(t,e,n,i){if(void 0===t)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===e||0===e.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=Gat.convertArray(e,this.TimeBufferType),this.values=Gat.convertArray(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}function Yat(t,e,n){Xat.call(this,t,e,n)}function Kat(t,e,n,i){Xat.call(this,t,e,n,i)}function Jat(t,e,n,i){Xat.call(this,t,e,n,i)}function Zat(t,e,n,i){Wat.call(this,t,e,n,i)}function tlt(t,e,n,i){Xat.call(this,t,e,n,i)}function elt(t,e,n,i){Xat.call(this,t,e,n,i)}function nlt(t,e,n,i){Xat.call(this,t,e,n,i)}function ilt(t,e=-1,n,i=2500){this.name=t,this.tracks=n,this.duration=e,this.blendMode=i,this.uuid=tet.generateUUID(),this.duration<0&&this.resetDuration()}function rlt(t){if(void 0===t.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=function(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Jat;case"vector":case"vector2":case"vector3":case"vector4":return nlt;case"color":return Kat;case"quaternion":return tlt;case"bool":case"boolean":return Yat;case"string":return elt}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}(t.type);if(void 0===t.times){const e=[],n=[];Gat.flattenJSON(t.keys,e,n,"value"),t.times=e,t.values=n}return void 0!==e.parse?e.parse(t):new e(t.name,t.times,t.values,t.interpolation)}Object.assign(Wat.prototype,{evaluate:function(t){const e=this.parameterPositions;let n=this._cachedIndex,i=e[n],r=e[n-1];t:{e:{let s;n:{i:if(!(t<i)){for(let s=n+2;;){if(void 0===i){if(t<r)break i;return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,t,r)}if(n===s)break;if(r=i,i=e[++n],t<i)break e}s=e.length;break n}if(t>=r)break t;{const o=e[1];t<o&&(n=2,r=o);for(let s=n-2;;){if(void 0===r)return this._cachedIndex=0,this.beforeStart_(0,t,i);if(n===s)break;if(i=r,r=e[--n-1],t>=r)break e}s=n,n=0}}for(;n<s;){const i=n+s>>>1;t<e[i]?s=i:n=i+1}if(i=e[n],r=e[n-1],void 0===r)return this._cachedIndex=0,this.beforeStart_(0,t,i);if(void 0===i)return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,r,t)}this._cachedIndex=n,this.intervalChanged_(n,r,i)}return this.interpolate_(n,r,t,i)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(t){const e=this.resultBuffer,n=this.sampleValues,i=this.valueSize,r=t*i;for(let s=0;s!==i;++s)e[s]=n[r+s];return e},interpolate_:function(){throw new Error("call to abstract method")},intervalChanged_:function(){}}),Object.assign(Wat.prototype,{beforeStart_:Wat.prototype.copySampleValue_,afterEnd_:Wat.prototype.copySampleValue_}),jat.prototype=Object.assign(Object.create(Wat.prototype),{constructor:jat,DefaultSettings_:{endingStart:Vtt,endingEnd:Vtt},intervalChanged_:function(t,e,n){const i=this.parameterPositions;let r=t-2,s=t+1,o=i[r],a=i[s];if(void 0===o)switch(this.getSettings_().endingStart){case Gtt:r=t,o=2*e-n;break;case Wtt:r=i.length-2,o=e+i[r]-i[r+1];break;default:r=t,o=n}if(void 0===a)switch(this.getSettings_().endingEnd){case Gtt:s=t,a=2*n-e;break;case Wtt:s=1,a=n+i[1]-i[0];break;default:s=t-1,a=e}const l=.5*(n-e),c=this.valueSize;this._weightPrev=l/(e-o),this._weightNext=l/(a-n),this._offsetPrev=r*c,this._offsetNext=s*c},interpolate_:function(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=t*o,l=a-o,c=this._offsetPrev,u=this._offsetNext,h=this._weightPrev,d=this._weightNext,p=(n-e)/(i-e),f=p*p,m=f*p,g=-h*m+2*h*f-h*p,y=(1+h)*m+(-1.5-2*h)*f+(-.5+h)*p+1,v=(-1-d)*m+(1.5+d)*f+.5*p,b=d*m-d*f;for(let A=0;A!==o;++A)r[A]=g*s[c+A]+y*s[l+A]+v*s[a+A]+b*s[u+A];return r}}),Qat.prototype=Object.assign(Object.create(Wat.prototype),{constructor:Qat,interpolate_:function(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=t*o,l=a-o,c=(n-e)/(i-e),u=1-c;for(let h=0;h!==o;++h)r[h]=s[l+h]*u+s[a+h]*c;return r}}),qat.prototype=Object.assign(Object.create(Wat.prototype),{constructor:qat,interpolate_:function(t){return this.copySampleValue_(t-1)}}),Object.assign(Xat,{toJSON:function(t){const e=t.constructor;let n;if(void 0!==e.toJSON)n=e.toJSON(t);else{n={name:t.name,times:Gat.convertArray(t.times,Array),values:Gat.convertArray(t.values,Array)};const e=t.getInterpolation();e!==t.DefaultInterpolation&&(n.interpolation=e)}return n.type=t.ValueTypeName,n}}),Object.assign(Xat.prototype,{constructor:Xat,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:Utt,InterpolantFactoryMethodDiscrete:function(t){return new qat(this.times,this.values,this.getValueSize(),t)},InterpolantFactoryMethodLinear:function(t){return new Qat(this.times,this.values,this.getValueSize(),t)},InterpolantFactoryMethodSmooth:function(t){return new jat(this.times,this.values,this.getValueSize(),t)},setInterpolation:function(t){let e;switch(t){case ztt:e=this.InterpolantFactoryMethodDiscrete;break;case Utt:e=this.InterpolantFactoryMethodLinear;break;case Htt:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){const e="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(t===this.DefaultInterpolation)throw new Error(e);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",e),this}return this.createInterpolant=e,this},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return ztt;case this.InterpolantFactoryMethodLinear:return Utt;case this.InterpolantFactoryMethodSmooth:return Htt}},getValueSize:function(){return this.values.length/this.times.length},shift:function(t){if(0!==t){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]+=t}return this},scale:function(t){if(1!==t){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]*=t}return this},trim:function(t,e){const n=this.times,i=n.length;let r=0,s=i-1;for(;r!==i&&n[r]<t;)++r;for(;-1!==s&&n[s]>e;)--s;if(++s,0!==r||s!==i){r>=s&&(s=Math.max(s,1),r=s-1);const t=this.getValueSize();this.times=Gat.arraySlice(n,r,s),this.values=Gat.arraySlice(this.values,r*t,s*t)}return this},validate:function(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const n=this.times,i=this.values,r=n.length;0===r&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let s=null;for(let o=0;o!==r;o++){const e=n[o];if("number"==typeof e&&isNaN(e)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,e),t=!1;break}if(null!==s&&s>e){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,e,s),t=!1;break}s=e}if(void 0!==i&&Gat.isTypedArray(i))for(let o=0,a=i.length;o!==a;++o){const e=i[o];if(isNaN(e)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,e),t=!1;break}}return t},optimize:function(){const t=Gat.arraySlice(this.times),e=Gat.arraySlice(this.values),n=this.getValueSize(),i=this.getInterpolation()===Htt,r=t.length-1;let s=1;for(let o=1;o<r;++o){let r=!1;const a=t[o];if(a!==t[o+1]&&(1!==o||a!==t[0]))if(i)r=!0;else{const t=o*n,i=t-n,s=t+n;for(let o=0;o!==n;++o){const n=e[t+o];if(n!==e[i+o]||n!==e[s+o]){r=!0;break}}}if(r){if(o!==s){t[s]=t[o];const i=o*n,r=s*n;for(let t=0;t!==n;++t)e[r+t]=e[i+t]}++s}}if(r>0){t[s]=t[r];for(let t=r*n,i=s*n,o=0;o!==n;++o)e[i+o]=e[t+o];++s}return s!==t.length?(this.times=Gat.arraySlice(t,0,s),this.values=Gat.arraySlice(e,0,s*n)):(this.times=t,this.values=e),this},clone:function(){const t=Gat.arraySlice(this.times,0),e=Gat.arraySlice(this.values,0),n=new(0,this.constructor)(this.name,t,e);return n.createInterpolant=this.createInterpolant,n}}),Yat.prototype=Object.assign(Object.create(Xat.prototype),{constructor:Yat,ValueTypeName:"bool",ValueBufferType:Array,DefaultInterpolation:ztt,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),Kat.prototype=Object.assign(Object.create(Xat.prototype),{constructor:Kat,ValueTypeName:"color"}),Jat.prototype=Object.assign(Object.create(Xat.prototype),{constructor:Jat,ValueTypeName:"number"}),Zat.prototype=Object.assign(Object.create(Wat.prototype),{constructor:Zat,interpolate_:function(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=(n-e)/(i-e);let l=t*o;for(let c=l+o;l!==c;l+=4)het.slerpFlat(r,0,s,l-o,s,l,a);return r}}),tlt.prototype=Object.assign(Object.create(Xat.prototype),{constructor:tlt,ValueTypeName:"quaternion",DefaultInterpolation:Utt,InterpolantFactoryMethodLinear:function(t){return new Zat(this.times,this.values,this.getValueSize(),t)},InterpolantFactoryMethodSmooth:void 0}),elt.prototype=Object.assign(Object.create(Xat.prototype),{constructor:elt,ValueTypeName:"string",ValueBufferType:Array,DefaultInterpolation:ztt,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),nlt.prototype=Object.assign(Object.create(Xat.prototype),{constructor:nlt,ValueTypeName:"vector"}),Object.assign(ilt,{parse:function(t){const e=[],n=t.tracks,i=1/(t.fps||1);for(let s=0,o=n.length;s!==o;++s)e.push(rlt(n[s]).scale(i));const r=new ilt(t.name,t.duration,e,t.blendMode);return r.uuid=t.uuid,r},toJSON:function(t){const e=[],n=t.tracks,i={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let r=0,s=n.length;r!==s;++r)e.push(Xat.toJSON(n[r]));return i},CreateFromMorphTargetSequence:function(t,e,n,i){const r=e.length,s=[];for(let o=0;o<r;o++){let t=[],a=[];t.push((o+r-1)%r,o,(o+1)%r),a.push(0,1,0);const l=Gat.getKeyframeOrder(t);t=Gat.sortedArray(t,1,l),a=Gat.sortedArray(a,1,l),i||0!==t[0]||(t.push(r),a.push(a[0])),s.push(new Jat(".morphTargetInfluences["+e[o].name+"]",t,a).scale(1/n))}return new ilt(t,-1,s)},findByName:function(t,e){let n=t;if(!Array.isArray(t)){const e=t;n=e.geometry&&e.geometry.animations||e.animations}for(let i=0;i<n.length;i++)if(n[i].name===e)return n[i];return null},CreateClipsFromMorphTargetSequences:function(t,e,n){const i={},r=/^([\w-]*?)([\d]+)$/;for(let o=0,a=t.length;o<a;o++){const e=t[o],n=e.name.match(r);if(n&&n.length>1){const t=n[1];let r=i[t];r||(i[t]=r=[]),r.push(e)}}const s=[];for(const o in i)s.push(ilt.CreateFromMorphTargetSequence(o,i[o],e,n));return s},parseAnimation:function(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(t,e,n,i,r){if(0!==n.length){const s=[],o=[];Gat.flattenJSON(n,s,o,i),0!==s.length&&r.push(new t(e,s,o))}},i=[],r=t.name||"default",s=t.fps||30,o=t.blendMode;let a=t.length||-1;const l=t.hierarchy||[];for(let c=0;c<l.length;c++){const t=l[c].keys;if(t&&0!==t.length)if(t[0].morphTargets){const e={};let n;for(n=0;n<t.length;n++)if(t[n].morphTargets)for(let i=0;i<t[n].morphTargets.length;i++)e[t[n].morphTargets[i]]=-1;for(const r in e){const e=[],s=[];for(let i=0;i!==t[n].morphTargets.length;++i){const i=t[n];e.push(i.time),s.push(i.morphTarget===r?1:0)}i.push(new Jat(".morphTargetInfluence["+r+"]",e,s))}a=e.length*(s||1)}else{const r=".bones["+e[c].name+"]";n(nlt,r+".position",t,"pos",i),n(tlt,r+".quaternion",t,"rot",i),n(nlt,r+".scale",t,"scl",i)}}return 0===i.length?null:new ilt(r,a,i,o)}}),Object.assign(ilt.prototype,{resetDuration:function(){let t=0;for(let e=0,n=this.tracks.length;e!==n;++e){const n=this.tracks[e];t=Math.max(t,n.times[n.times.length-1])}return this.duration=t,this},trim:function(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this},validate:function(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t},optimize:function(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this},clone:function(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new ilt(this.name,this.duration,t,this.blendMode)},toJSON:function(){return ilt.toJSON(this)}});const slt={enabled:!1,files:{},add:function(t,e){!1!==this.enabled&&(this.files[t]=e)},get:function(t){if(!1!==this.enabled)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}},olt=new function(t,e,n){const i=this;let r,s=!1,o=0,a=0;const l=[];this.onStart=void 0,this.onLoad=void 0,this.onProgress=void 0,this.onError=void 0,this.itemStart=function(t){a++,!1===s&&void 0!==i.onStart&&i.onStart(t,o,a),s=!0},this.itemEnd=function(t){o++,void 0!==i.onProgress&&i.onProgress(t,o,a),o===a&&(s=!1,void 0!==i.onLoad&&i.onLoad())},this.itemError=function(t){void 0!==i.onError&&i.onError(t)},this.resolveURL=function(t){return r?r(t):t},this.setURLModifier=function(t){return r=t,this},this.addHandler=function(t,e){return l.push(t,e),this},this.removeHandler=function(t){const e=l.indexOf(t);return-1!==e&&l.splice(e,2),this},this.getHandler=function(t){for(let e=0,n=l.length;e<n;e+=2){const n=l[e],i=l[e+1];if(n.global&&(n.lastIndex=0),n.test(t))return i}return null}};function alt(t){this.manager=void 0!==t?t:olt,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}Object.assign(alt.prototype,{load:function(){},loadAsync:function(t,e){const n=this;return new Promise(function(i,r){n.load(t,i,e,r)})},parse:function(){},setCrossOrigin:function(t){return this.crossOrigin=t,this},setWithCredentials:function(t){return this.withCredentials=t,this},setPath:function(t){return this.path=t,this},setResourcePath:function(t){return this.resourcePath=t,this},setRequestHeader:function(t){return this.requestHeader=t,this}});const llt={};function clt(t){alt.call(this,t)}function ult(t){alt.call(this,t)}function hlt(t){alt.call(this,t)}function dlt(t){alt.call(this,t)}function plt(t){alt.call(this,t)}function flt(t){alt.call(this,t)}function mlt(t){alt.call(this,t)}function glt(){this.type="Curve",this.arcLengthDivisions=200}function ylt(t,e,n,i,r,s,o,a){glt.call(this),this.type="EllipseCurve",this.aX=t||0,this.aY=e||0,this.xRadius=n||1,this.yRadius=i||1,this.aStartAngle=r||0,this.aEndAngle=s||2*Math.PI,this.aClockwise=o||!1,this.aRotation=a||0}function vlt(t,e,n,i,r,s){ylt.call(this,t,e,n,n,i,r,s),this.type="ArcCurve"}function blt(){let t=0,e=0,n=0,i=0;function r(r,s,o,a){t=r,e=o,n=-3*r+3*s-2*o-a,i=2*r-2*s+o+a}return{initCatmullRom:function(t,e,n,i,s){r(e,n,s*(n-t),s*(i-e))},initNonuniformCatmullRom:function(t,e,n,i,s,o,a){let l=(e-t)/s-(n-t)/(s+o)+(n-e)/o,c=(n-e)/o-(i-e)/(o+a)+(i-n)/a;l*=o,c*=o,r(e,n,l,c)},calc:function(r){const s=r*r;return t+e*r+n*s+i*(s*r)}}}clt.prototype=Object.assign(Object.create(alt.prototype),{constructor:clt,load:function(t,e,n,i){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,s=slt.get(t);if(void 0!==s)return r.manager.itemStart(t),setTimeout(function(){e&&e(s),r.manager.itemEnd(t)},0),s;if(void 0!==llt[t])return void llt[t].push({onLoad:e,onProgress:n,onError:i});const o=t.match(/^data:(.*?)(;base64)?,(.*)$/);let a;if(o){const n=o[1],s=!!o[2];let a=o[3];a=decodeURIComponent(a),s&&(a=atob(a));try{let i;const s=(this.responseType||"").toLowerCase();switch(s){case"arraybuffer":case"blob":const t=new Uint8Array(a.length);for(let n=0;n<a.length;n++)t[n]=a.charCodeAt(n);i="blob"===s?new Blob([t.buffer],{type:n}):t.buffer;break;case"document":const e=new DOMParser;i=e.parseFromString(a,n);break;case"json":i=JSON.parse(a);break;default:i=a}setTimeout(function(){e&&e(i),r.manager.itemEnd(t)},0)}catch(l){setTimeout(function(){i&&i(l),r.manager.itemError(t),r.manager.itemEnd(t)},0)}}else{llt[t]=[],llt[t].push({onLoad:e,onProgress:n,onError:i}),a=new XMLHttpRequest,a.open("GET",t,!0),a.addEventListener("load",function(e){const n=this.response,i=llt[t];if(delete llt[t],200===this.status||0===this.status){0===this.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),slt.add(t,n);for(let t=0,e=i.length;t<e;t++){const e=i[t];e.onLoad&&e.onLoad(n)}r.manager.itemEnd(t)}else{for(let t=0,n=i.length;t<n;t++){const n=i[t];n.onError&&n.onError(e)}r.manager.itemError(t),r.manager.itemEnd(t)}},!1),a.addEventListener("progress",function(e){const n=llt[t];for(let t=0,i=n.length;t<i;t++){const i=n[t];i.onProgress&&i.onProgress(e)}},!1),a.addEventListener("error",function(e){const n=llt[t];delete llt[t];for(let t=0,i=n.length;t<i;t++){const i=n[t];i.onError&&i.onError(e)}r.manager.itemError(t),r.manager.itemEnd(t)},!1),a.addEventListener("abort",function(e){const n=llt[t];delete llt[t];for(let t=0,i=n.length;t<i;t++){const i=n[t];i.onError&&i.onError(e)}r.manager.itemError(t),r.manager.itemEnd(t)},!1),void 0!==this.responseType&&(a.responseType=this.responseType),void 0!==this.withCredentials&&(a.withCredentials=this.withCredentials),a.overrideMimeType&&a.overrideMimeType(void 0!==this.mimeType?this.mimeType:"text/plain");for(const t in this.requestHeader)a.setRequestHeader(t,this.requestHeader[t]);a.send(null)}return r.manager.itemStart(t),a},setResponseType:function(t){return this.responseType=t,this},setMimeType:function(t){return this.mimeType=t,this}}),ult.prototype=Object.assign(Object.create(alt.prototype),{constructor:ult,load:function(t,e,n,i){const r=this,s=new clt(r.manager);s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(t,function(n){try{e(r.parse(JSON.parse(n)))}catch(s){i?i(s):console.error(s),r.manager.itemError(t)}},n,i)},parse:function(t){const e=[];for(let n=0;n<t.length;n++){const i=ilt.parse(t[n]);e.push(i)}return e}}),hlt.prototype=Object.assign(Object.create(alt.prototype),{constructor:hlt,load:function(t,e,n,i){const r=this,s=[],o=new Zot,a=new clt(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(r.withCredentials);let l=0;function c(c){a.load(t[c],function(t){const n=r.parse(t,!0);s[c]={width:n.width,height:n.height,format:n.format,mipmaps:n.mipmaps},l+=1,6===l&&(1===n.mipmapCount&&(o.minFilter=Mtt),o.image=s,o.format=n.format,o.needsUpdate=!0,e&&e(o))},n,i)}if(Array.isArray(t))for(let u=0,h=t.length;u<h;++u)c(u);else a.load(t,function(t){const n=r.parse(t,!0);if(n.isCubemap){const t=n.mipmaps.length/n.mipmapCount;for(let e=0;e<t;e++){s[e]={mipmaps:[]};for(let t=0;t<n.mipmapCount;t++)s[e].mipmaps.push(n.mipmaps[e*n.mipmapCount+t]),s[e].format=n.format,s[e].width=n.width,s[e].height=n.height}o.image=s}else o.image.width=n.width,o.image.height=n.height,o.mipmaps=n.mipmaps;1===n.mipmapCount&&(o.minFilter=Mtt),o.format=n.format,o.needsUpdate=!0,e&&e(o)},n,i);return o}}),dlt.prototype=Object.assign(Object.create(alt.prototype),{constructor:dlt,load:function(t,e,n,i){void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,s=slt.get(t);if(void 0!==s)return r.manager.itemStart(t),setTimeout(function(){e&&e(s),r.manager.itemEnd(t)},0),s;const o=document.createElementNS("http://www.w3.org/1999/xhtml","img");function a(){o.removeEventListener("load",a,!1),o.removeEventListener("error",l,!1),slt.add(t,this),e&&e(this),r.manager.itemEnd(t)}function l(e){o.removeEventListener("load",a,!1),o.removeEventListener("error",l,!1),i&&i(e),r.manager.itemError(t),r.manager.itemEnd(t)}return o.addEventListener("load",a,!1),o.addEventListener("error",l,!1),"data:"!==t.substr(0,5)&&void 0!==this.crossOrigin&&(o.crossOrigin=this.crossOrigin),r.manager.itemStart(t),o.src=t,o}}),plt.prototype=Object.assign(Object.create(alt.prototype),{constructor:plt,load:function(t,e,n,i){const r=new Pit,s=new dlt(this.manager);s.setCrossOrigin(this.crossOrigin),s.setPath(this.path);let o=0;function a(n){s.load(t[n],function(t){r.images[n]=t,o++,6===o&&(r.needsUpdate=!0,e&&e(r))},void 0,i)}for(let l=0;l<t.length;++l)a(l);return r}}),flt.prototype=Object.assign(Object.create(alt.prototype),{constructor:flt,load:function(t,e,n,i){const r=this,s=new $it,o=new clt(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(r.withCredentials),o.load(t,function(t){const n=r.parse(t);n&&(void 0!==n.image?s.image=n.image:void 0!==n.data&&(s.image.width=n.width,s.image.height=n.height,s.image.data=n.data),s.wrapS=void 0!==n.wrapS?n.wrapS:Ctt,s.wrapT=void 0!==n.wrapT?n.wrapT:Ctt,s.magFilter=void 0!==n.magFilter?n.magFilter:Mtt,s.minFilter=void 0!==n.minFilter?n.minFilter:Mtt,s.anisotropy=void 0!==n.anisotropy?n.anisotropy:1,void 0!==n.encoding&&(s.encoding=n.encoding),void 0!==n.flipY&&(s.flipY=n.flipY),void 0!==n.format&&(s.format=n.format),void 0!==n.type&&(s.type=n.type),void 0!==n.mipmaps&&(s.mipmaps=n.mipmaps,s.minFilter=ktt),1===n.mipmapCount&&(s.minFilter=Mtt),s.needsUpdate=!0,e&&e(s,n))},n,i),s}}),mlt.prototype=Object.assign(Object.create(alt.prototype),{constructor:mlt,load:function(t,e,n,i){const r=new oet,s=new dlt(this.manager);return s.setCrossOrigin(this.crossOrigin),s.setPath(this.path),s.load(t,function(n){r.image=n;const i=t.search(/\.jpe?g($|\?)/i)>0||0===t.search(/^data\:image\/jpeg/);r.format=i?Ott:Ptt,r.needsUpdate=!0,void 0!==e&&e(r)},n,i),r}}),Object.assign(glt.prototype,{getPoint:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null},getPointAt:function(t,e){const n=this.getUtoTmapping(t);return this.getPoint(n,e)},getPoints:function(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return e},getSpacedPoints:function(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPointAt(n/t));return e},getLength:function(){const t=this.getLengths();return t[t.length-1]},getLengths:function(t){if(void 0===t&&(t=this.arcLengthDivisions),this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let n,i=this.getPoint(0),r=0;e.push(0);for(let s=1;s<=t;s++)n=this.getPoint(s/t),r+=n.distanceTo(i),e.push(r),i=n;return this.cacheArcLengths=e,e},updateArcLengths:function(){this.needsUpdate=!0,this.getLengths()},getUtoTmapping:function(t,e){const n=this.getLengths();let i=0;const r=n.length;let s;s=e||t*n[r-1];let o,a=0,l=r-1;for(;a<=l;)if(i=Math.floor(a+(l-a)/2),o=n[i]-s,o<0)a=i+1;else{if(!(o>0)){l=i;break}l=i-1}if(i=l,n[i]===s)return i/(r-1);const c=n[i];return(i+(s-c)/(n[i+1]-c))/(r-1)},getTangent:function(t,e){const n=1e-4;let i=t-n,r=t+n;i<0&&(i=0),r>1&&(r=1);const s=this.getPoint(i),o=this.getPoint(r),a=e||(s.isVector2?new eet:new det);return a.copy(o).sub(s).normalize(),a},getTangentAt:function(t,e){const n=this.getUtoTmapping(t);return this.getTangent(n,e)},computeFrenetFrames:function(t,e){const n=new det,i=[],r=[],s=[],o=new det,a=new Uet;for(let d=0;d<=t;d++)i[d]=this.getTangentAt(d/t,new det),i[d].normalize();r[0]=new det,s[0]=new det;let l=Number.MAX_VALUE;const c=Math.abs(i[0].x),u=Math.abs(i[0].y),h=Math.abs(i[0].z);c<=l&&(l=c,n.set(1,0,0)),u<=l&&(l=u,n.set(0,1,0)),h<=l&&n.set(0,0,1),o.crossVectors(i[0],n).normalize(),r[0].crossVectors(i[0],o),s[0].crossVectors(i[0],r[0]);for(let d=1;d<=t;d++){if(r[d]=r[d-1].clone(),s[d]=s[d-1].clone(),o.crossVectors(i[d-1],i[d]),o.length()>Number.EPSILON){o.normalize();const t=Math.acos(tet.clamp(i[d-1].dot(i[d]),-1,1));r[d].applyMatrix4(a.makeRotationAxis(o,t))}s[d].crossVectors(i[d],r[d])}if(!0===e){let e=Math.acos(tet.clamp(r[0].dot(r[t]),-1,1));e/=t,i[0].dot(o.crossVectors(r[0],r[t]))>0&&(e=-e);for(let n=1;n<=t;n++)r[n].applyMatrix4(a.makeRotationAxis(i[n],e*n)),s[n].crossVectors(i[n],r[n])}return{tangents:i,normals:r,binormals:s}},clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.arcLengthDivisions=t.arcLengthDivisions,this},toJSON:function(){const t={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t},fromJSON:function(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}),(ylt.prototype=Object.create(glt.prototype)).constructor=ylt,ylt.prototype.isEllipseCurve=!0,ylt.prototype.getPoint=function(t,e){const n=e||new eet,i=2*Math.PI;let r=this.aEndAngle-this.aStartAngle;const s=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=i;for(;r>i;)r-=i;r<Number.EPSILON&&(r=s?0:i),!0!==this.aClockwise||s||(r===i?r=-i:r-=i);const o=this.aStartAngle+t*r;let a=this.aX+this.xRadius*Math.cos(o),l=this.aY+this.yRadius*Math.sin(o);if(0!==this.aRotation){const t=Math.cos(this.aRotation),e=Math.sin(this.aRotation),n=a-this.aX,i=l-this.aY;a=n*t-i*e+this.aX,l=n*e+i*t+this.aY}return n.set(a,l)},ylt.prototype.copy=function(t){return glt.prototype.copy.call(this,t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this},ylt.prototype.toJSON=function(){const t=glt.prototype.toJSON.call(this);return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t},ylt.prototype.fromJSON=function(t){return glt.prototype.fromJSON.call(this,t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this},(vlt.prototype=Object.create(ylt.prototype)).constructor=vlt,vlt.prototype.isArcCurve=!0;const Alt=new det,xlt=new blt,wlt=new blt,_lt=new blt;function Slt(t=[],e=!1,n="centripetal",i=.5){glt.call(this),this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=n,this.tension=i}function Elt(t,e,n,i,r){const s=.5*(i-e),o=.5*(r-n),a=t*t;return(2*n-2*i+s+o)*(t*a)+(-3*n+3*i-2*s-o)*a+s*t+n}function Clt(t,e,n,i){return function(t,e){const n=1-t;return n*n*e}(t,e)+function(t,e){return 2*(1-t)*t*e}(t,n)+function(t,e){return t*t*e}(t,i)}function Ilt(t,e,n,i,r){return function(t,e){const n=1-t;return n*n*n*e}(t,e)+function(t,e){const n=1-t;return 3*n*n*t*e}(t,n)+function(t,e){return 3*(1-t)*t*t*e}(t,i)+function(t,e){return t*t*t*e}(t,r)}function Tlt(t=new eet,e=new eet,n=new eet,i=new eet){glt.call(this),this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=n,this.v3=i}function Mlt(t=new det,e=new det,n=new det,i=new det){glt.call(this),this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=n,this.v3=i}function klt(t=new eet,e=new eet){glt.call(this),this.type="LineCurve",this.v1=t,this.v2=e}function Rlt(t=new det,e=new det){glt.call(this),this.type="LineCurve3",this.v1=t,this.v2=e}function Nlt(t=new eet,e=new eet,n=new eet){glt.call(this),this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=n}function Llt(t=new det,e=new det,n=new det){glt.call(this),this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=n}function Dlt(t=[]){glt.call(this),this.type="SplineCurve",this.points=t}(Slt.prototype=Object.create(glt.prototype)).constructor=Slt,Slt.prototype.isCatmullRomCurve3=!0,Slt.prototype.getPoint=function(t,e=new det){const n=e,i=this.points,r=i.length,s=(r-(this.closed?0:1))*t;let o,a,l=Math.floor(s),c=s-l;this.closed?l+=l>0?0:(Math.floor(Math.abs(l)/r)+1)*r:0===c&&l===r-1&&(l=r-2,c=1),this.closed||l>0?o=i[(l-1)%r]:(Alt.subVectors(i[0],i[1]).add(i[0]),o=Alt);const u=i[l%r],h=i[(l+1)%r];if(this.closed||l+2<r?a=i[(l+2)%r]:(Alt.subVectors(i[r-1],i[r-2]).add(i[r-1]),a=Alt),"centripetal"===this.curveType||"chordal"===this.curveType){const t="chordal"===this.curveType?.5:.25;let e=Math.pow(o.distanceToSquared(u),t),n=Math.pow(u.distanceToSquared(h),t),i=Math.pow(h.distanceToSquared(a),t);n<1e-4&&(n=1),e<1e-4&&(e=n),i<1e-4&&(i=n),xlt.initNonuniformCatmullRom(o.x,u.x,h.x,a.x,e,n,i),wlt.initNonuniformCatmullRom(o.y,u.y,h.y,a.y,e,n,i),_lt.initNonuniformCatmullRom(o.z,u.z,h.z,a.z,e,n,i)}else"catmullrom"===this.curveType&&(xlt.initCatmullRom(o.x,u.x,h.x,a.x,this.tension),wlt.initCatmullRom(o.y,u.y,h.y,a.y,this.tension),_lt.initCatmullRom(o.z,u.z,h.z,a.z,this.tension));return n.set(xlt.calc(c),wlt.calc(c),_lt.calc(c)),n},Slt.prototype.copy=function(t){glt.prototype.copy.call(this,t),this.points=[];for(let e=0,n=t.points.length;e<n;e++)this.points.push(t.points[e].clone());return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this},Slt.prototype.toJSON=function(){const t=glt.prototype.toJSON.call(this);t.points=[];for(let e=0,n=this.points.length;e<n;e++)t.points.push(this.points[e].toArray());return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t},Slt.prototype.fromJSON=function(t){glt.prototype.fromJSON.call(this,t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push((new det).fromArray(n))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this},(Tlt.prototype=Object.create(glt.prototype)).constructor=Tlt,Tlt.prototype.isCubicBezierCurve=!0,Tlt.prototype.getPoint=function(t,e=new eet){const n=e,i=this.v0,r=this.v1,s=this.v2,o=this.v3;return n.set(Ilt(t,i.x,r.x,s.x,o.x),Ilt(t,i.y,r.y,s.y,o.y)),n},Tlt.prototype.copy=function(t){return glt.prototype.copy.call(this,t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this},Tlt.prototype.toJSON=function(){const t=glt.prototype.toJSON.call(this);return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t},Tlt.prototype.fromJSON=function(t){return glt.prototype.fromJSON.call(this,t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this},(Mlt.prototype=Object.create(glt.prototype)).constructor=Mlt,Mlt.prototype.isCubicBezierCurve3=!0,Mlt.prototype.getPoint=function(t,e=new det){const n=e,i=this.v0,r=this.v1,s=this.v2,o=this.v3;return n.set(Ilt(t,i.x,r.x,s.x,o.x),Ilt(t,i.y,r.y,s.y,o.y),Ilt(t,i.z,r.z,s.z,o.z)),n},Mlt.prototype.copy=function(t){return glt.prototype.copy.call(this,t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this},Mlt.prototype.toJSON=function(){const t=glt.prototype.toJSON.call(this);return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t},Mlt.prototype.fromJSON=function(t){return glt.prototype.fromJSON.call(this,t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this},(klt.prototype=Object.create(glt.prototype)).constructor=klt,klt.prototype.isLineCurve=!0,klt.prototype.getPoint=function(t,e=new eet){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n},klt.prototype.getPointAt=function(t,e){return this.getPoint(t,e)},klt.prototype.getTangent=function(t,e){const n=e||new eet;return n.copy(this.v2).sub(this.v1).normalize(),n},klt.prototype.copy=function(t){return glt.prototype.copy.call(this,t),this.v1.copy(t.v1),this.v2.copy(t.v2),this},klt.prototype.toJSON=function(){const t=glt.prototype.toJSON.call(this);return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t},klt.prototype.fromJSON=function(t){return glt.prototype.fromJSON.call(this,t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this},(Rlt.prototype=Object.create(glt.prototype)).constructor=Rlt,Rlt.prototype.isLineCurve3=!0,Rlt.prototype.getPoint=function(t,e=new det){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n},Rlt.prototype.getPointAt=function(t,e){return this.getPoint(t,e)},Rlt.prototype.copy=function(t){return glt.prototype.copy.call(this,t),this.v1.copy(t.v1),this.v2.copy(t.v2),this},Rlt.prototype.toJSON=function(){const t=glt.prototype.toJSON.call(this);return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t},Rlt.prototype.fromJSON=function(t){return glt.prototype.fromJSON.call(this,t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this},(Nlt.prototype=Object.create(glt.prototype)).constructor=Nlt,Nlt.prototype.isQuadraticBezierCurve=!0,Nlt.prototype.getPoint=function(t,e=new eet){const n=e,i=this.v0,r=this.v1,s=this.v2;return n.set(Clt(t,i.x,r.x,s.x),Clt(t,i.y,r.y,s.y)),n},Nlt.prototype.copy=function(t){return glt.prototype.copy.call(this,t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this},Nlt.prototype.toJSON=function(){const t=glt.prototype.toJSON.call(this);return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t},Nlt.prototype.fromJSON=function(t){return glt.prototype.fromJSON.call(this,t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this},(Llt.prototype=Object.create(glt.prototype)).constructor=Llt,Llt.prototype.isQuadraticBezierCurve3=!0,Llt.prototype.getPoint=function(t,e=new det){const n=e,i=this.v0,r=this.v1,s=this.v2;return n.set(Clt(t,i.x,r.x,s.x),Clt(t,i.y,r.y,s.y),Clt(t,i.z,r.z,s.z)),n},Llt.prototype.copy=function(t){return glt.prototype.copy.call(this,t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this},Llt.prototype.toJSON=function(){const t=glt.prototype.toJSON.call(this);return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t},Llt.prototype.fromJSON=function(t){return glt.prototype.fromJSON.call(this,t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this},(Dlt.prototype=Object.create(glt.prototype)).constructor=Dlt,Dlt.prototype.isSplineCurve=!0,Dlt.prototype.getPoint=function(t,e=new eet){const n=e,i=this.points,r=(i.length-1)*t,s=Math.floor(r),o=r-s,a=i[0===s?s:s-1],l=i[s],c=i[s>i.length-2?i.length-1:s+1],u=i[s>i.length-3?i.length-1:s+2];return n.set(Elt(o,a.x,l.x,c.x,u.x),Elt(o,a.y,l.y,c.y,u.y)),n},Dlt.prototype.copy=function(t){glt.prototype.copy.call(this,t),this.points=[];for(let e=0,n=t.points.length;e<n;e++)this.points.push(t.points[e].clone());return this},Dlt.prototype.toJSON=function(){const t=glt.prototype.toJSON.call(this);t.points=[];for(let e=0,n=this.points.length;e<n;e++)t.points.push(this.points[e].toArray());return t},Dlt.prototype.fromJSON=function(t){glt.prototype.fromJSON.call(this,t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push((new eet).fromArray(n))}return this};var Blt=Object.freeze({__proto__:null,ArcCurve:vlt,CatmullRomCurve3:Slt,CubicBezierCurve:Tlt,CubicBezierCurve3:Mlt,EllipseCurve:ylt,LineCurve:klt,LineCurve3:Rlt,QuadraticBezierCurve:Nlt,QuadraticBezierCurve3:Llt,SplineCurve:Dlt});function Olt(){glt.call(this),this.type="CurvePath",this.curves=[],this.autoClose=!1}function Plt(t){Olt.call(this),this.type="Path",this.currentPoint=new eet,t&&this.setFromPoints(t)}function Flt(t){Plt.call(this,t),this.uuid=tet.generateUUID(),this.type="Shape",this.holes=[]}function $lt(t,e=1){dnt.call(this),this.type="Light",this.color=new Dnt(t),this.intensity=e}function zlt(t,e,n){$lt.call(this,t,n),this.type="HemisphereLight",this.position.copy(dnt.DefaultUp),this.updateMatrix(),this.groundColor=new Dnt(e)}function Ult(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new eet(512,512),this.map=null,this.mapPass=null,this.matrix=new Uet,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Hit,this._frameExtents=new eet(1,1),this._viewportCount=1,this._viewports=[new cet(0,0,1,1)]}function Hlt(){Ult.call(this,new Dit(50,1,.5,500)),this.focus=1}function Vlt(t,e,n,i,r,s){$lt.call(this,t,e),this.type="SpotLight",this.position.copy(dnt.DefaultUp),this.updateMatrix(),this.target=new dnt,Object.defineProperty(this,"power",{get:function(){return this.intensity*Math.PI},set:function(t){this.intensity=t/Math.PI}}),this.distance=void 0!==n?n:0,this.angle=void 0!==i?i:Math.PI/3,this.penumbra=void 0!==r?r:0,this.decay=void 0!==s?s:1,this.shadow=new Hlt}function Glt(){Ult.call(this,new Dit(90,1,.5,500)),this._frameExtents=new eet(4,2),this._viewportCount=6,this._viewports=[new cet(2,1,1,1),new cet(0,1,1,1),new cet(3,1,1,1),new cet(1,1,1,1),new cet(3,0,1,1),new cet(1,0,1,1)],this._cubeDirections=[new det(1,0,0),new det(-1,0,0),new det(0,0,1),new det(0,0,-1),new det(0,1,0),new det(0,-1,0)],this._cubeUps=[new det(0,1,0),new det(0,1,0),new det(0,1,0),new det(0,1,0),new det(0,0,1),new det(0,0,-1)]}function Wlt(t,e,n,i){$lt.call(this,t,e),this.type="PointLight",Object.defineProperty(this,"power",{get:function(){return 4*this.intensity*Math.PI},set:function(t){this.intensity=t/(4*Math.PI)}}),this.distance=void 0!==n?n:0,this.decay=void 0!==i?i:1,this.shadow=new Glt}function jlt(t=-1,e=1,n=1,i=-1,r=.1,s=2e3){Lit.call(this),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=i,this.near=r,this.far=s,this.updateProjectionMatrix()}function Qlt(){Ult.call(this,new jlt(-5,5,5,-5,.5,500))}function qlt(t,e){$lt.call(this,t,e),this.type="DirectionalLight",this.position.copy(dnt.DefaultUp),this.updateMatrix(),this.target=new dnt,this.shadow=new Qlt}function Xlt(t,e){$lt.call(this,t,e),this.type="AmbientLight"}function Ylt(t,e,n,i){$lt.call(this,t,e),this.type="RectAreaLight",this.width=void 0!==n?n:10,this.height=void 0!==i?i:10}Olt.prototype=Object.assign(Object.create(glt.prototype),{constructor:Olt,add:function(t){this.curves.push(t)},closePath:function(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new klt(e,t))},getPoint:function(t){const e=t*this.getLength(),n=this.getCurveLengths();let i=0;for(;i<n.length;){if(n[i]>=e){const t=n[i]-e,r=this.curves[i],s=r.getLength();return r.getPointAt(0===s?0:1-t/s)}i++}return null},getLength:function(){const t=this.getCurveLengths();return t[t.length-1]},updateArcLengths:function(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()},getCurveLengths:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let n=0,i=this.curves.length;n<i;n++)e+=this.curves[n].getLength(),t.push(e);return this.cacheLengths=t,t},getSpacedPoints:function(t=40){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return this.autoClose&&e.push(e[0]),e},getPoints:function(t=12){const e=[];let n;for(let i=0,r=this.curves;i<r.length;i++){const s=r[i],o=s.getPoints(s&&s.isEllipseCurve?2*t:s&&(s.isLineCurve||s.isLineCurve3)?1:s&&s.isSplineCurve?t*s.points.length:t);for(let t=0;t<o.length;t++){const i=o[t];n&&n.equals(i)||(e.push(i),n=i)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e},copy:function(t){glt.prototype.copy.call(this,t),this.curves=[];for(let e=0,n=t.curves.length;e<n;e++)this.curves.push(t.curves[e].clone());return this.autoClose=t.autoClose,this},toJSON:function(){const t=glt.prototype.toJSON.call(this);t.autoClose=this.autoClose,t.curves=[];for(let e=0,n=this.curves.length;e<n;e++)t.curves.push(this.curves[e].toJSON());return t},fromJSON:function(t){glt.prototype.fromJSON.call(this,t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const n=t.curves[e];this.curves.push((new Blt[n.type]).fromJSON(n))}return this}}),Plt.prototype=Object.assign(Object.create(Olt.prototype),{constructor:Plt,setFromPoints:function(t){this.moveTo(t[0].x,t[0].y);for(let e=1,n=t.length;e<n;e++)this.lineTo(t[e].x,t[e].y);return this},moveTo:function(t,e){return this.currentPoint.set(t,e),this},lineTo:function(t,e){const n=new klt(this.currentPoint.clone(),new eet(t,e));return this.curves.push(n),this.currentPoint.set(t,e),this},quadraticCurveTo:function(t,e,n,i){const r=new Nlt(this.currentPoint.clone(),new eet(t,e),new eet(n,i));return this.curves.push(r),this.currentPoint.set(n,i),this},bezierCurveTo:function(t,e,n,i,r,s){const o=new Tlt(this.currentPoint.clone(),new eet(t,e),new eet(n,i),new eet(r,s));return this.curves.push(o),this.currentPoint.set(r,s),this},splineThru:function(t){const e=new Dlt([this.currentPoint.clone()].concat(t));return this.curves.push(e),this.currentPoint.copy(t[t.length-1]),this},arc:function(t,e,n,i,r,s){return this.absarc(t+this.currentPoint.x,e+this.currentPoint.y,n,i,r,s),this},absarc:function(t,e,n,i,r,s){return this.absellipse(t,e,n,n,i,r,s),this},ellipse:function(t,e,n,i,r,s,o,a){return this.absellipse(t+this.currentPoint.x,e+this.currentPoint.y,n,i,r,s,o,a),this},absellipse:function(t,e,n,i,r,s,o,a){const l=new ylt(t,e,n,i,r,s,o,a);if(this.curves.length>0){const t=l.getPoint(0);t.equals(this.currentPoint)||this.lineTo(t.x,t.y)}this.curves.push(l);const c=l.getPoint(1);return this.currentPoint.copy(c),this},copy:function(t){return Olt.prototype.copy.call(this,t),this.currentPoint.copy(t.currentPoint),this},toJSON:function(){const t=Olt.prototype.toJSON.call(this);return t.currentPoint=this.currentPoint.toArray(),t},fromJSON:function(t){return Olt.prototype.fromJSON.call(this,t),this.currentPoint.fromArray(t.currentPoint),this}}),Flt.prototype=Object.assign(Object.create(Plt.prototype),{constructor:Flt,getPointsHoles:function(t){const e=[];for(let n=0,i=this.holes.length;n<i;n++)e[n]=this.holes[n].getPoints(t);return e},extractPoints:function(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}},copy:function(t){Plt.prototype.copy.call(this,t),this.holes=[];for(let e=0,n=t.holes.length;e<n;e++)this.holes.push(t.holes[e].clone());return this},toJSON:function(){const t=Plt.prototype.toJSON.call(this);t.uuid=this.uuid,t.holes=[];for(let e=0,n=this.holes.length;e<n;e++)t.holes.push(this.holes[e].toJSON());return t},fromJSON:function(t){Plt.prototype.fromJSON.call(this,t),this.uuid=t.uuid,this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const n=t.holes[e];this.holes.push((new Plt).fromJSON(n))}return this}}),$lt.prototype=Object.assign(Object.create(dnt.prototype),{constructor:$lt,isLight:!0,copy:function(t){return dnt.prototype.copy.call(this,t),this.color.copy(t.color),this.intensity=t.intensity,this},toJSON:function(t){const e=dnt.prototype.toJSON.call(this,t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,void 0!==this.groundColor&&(e.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(e.object.distance=this.distance),void 0!==this.angle&&(e.object.angle=this.angle),void 0!==this.decay&&(e.object.decay=this.decay),void 0!==this.penumbra&&(e.object.penumbra=this.penumbra),void 0!==this.shadow&&(e.object.shadow=this.shadow.toJSON()),e}}),zlt.prototype=Object.assign(Object.create($lt.prototype),{constructor:zlt,isHemisphereLight:!0,copy:function(t){return $lt.prototype.copy.call(this,t),this.groundColor.copy(t.groundColor),this}}),Object.assign(Ult.prototype,{_projScreenMatrix:new Uet,_lightPositionWorld:new det,_lookTarget:new det,getViewportCount:function(){return this._viewportCount},getFrustum:function(){return this._frustum},updateMatrices:function(t){const e=this.camera,n=this.matrix,i=this._projScreenMatrix,r=this._lookTarget,s=this._lightPositionWorld;s.setFromMatrixPosition(t.matrixWorld),e.position.copy(s),r.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(r),e.updateMatrixWorld(),i.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(i),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(e.projectionMatrix),n.multiply(e.matrixWorldInverse)},getViewport:function(t){return this._viewports[t]},getFrameExtents:function(){return this._frameExtents},copy:function(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this},clone:function(){return(new this.constructor).copy(this)},toJSON:function(){const t={};return 0!==this.bias&&(t.bias=this.bias),0!==this.normalBias&&(t.normalBias=this.normalBias),1!==this.radius&&(t.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}),Hlt.prototype=Object.assign(Object.create(Ult.prototype),{constructor:Hlt,isSpotLightShadow:!0,updateMatrices:function(t){const e=this.camera,n=2*tet.RAD2DEG*t.angle*this.focus,i=this.mapSize.width/this.mapSize.height,r=t.distance||e.far;n===e.fov&&i===e.aspect&&r===e.far||(e.fov=n,e.aspect=i,e.far=r,e.updateProjectionMatrix()),Ult.prototype.updateMatrices.call(this,t)}}),Vlt.prototype=Object.assign(Object.create($lt.prototype),{constructor:Vlt,isSpotLight:!0,copy:function(t){return $lt.prototype.copy.call(this,t),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}),Glt.prototype=Object.assign(Object.create(Ult.prototype),{constructor:Glt,isPointLightShadow:!0,updateMatrices:function(t,e=0){const n=this.camera,i=this.matrix,r=this._lightPositionWorld,s=this._lookTarget,o=this._projScreenMatrix;r.setFromMatrixPosition(t.matrixWorld),n.position.copy(r),s.copy(n.position),s.add(this._cubeDirections[e]),n.up.copy(this._cubeUps[e]),n.lookAt(s),n.updateMatrixWorld(),i.makeTranslation(-r.x,-r.y,-r.z),o.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(o)}}),Wlt.prototype=Object.assign(Object.create($lt.prototype),{constructor:Wlt,isPointLight:!0,copy:function(t){return $lt.prototype.copy.call(this,t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}),jlt.prototype=Object.assign(Object.create(Lit.prototype),{constructor:jlt,isOrthographicCamera:!0,copy:function(t,e){return Lit.prototype.copy.call(this,t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=null===t.view?null:Object.assign({},t.view),this},setViewOffset:function(t,e,n,i,r,s){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=n-t,s=n+t,o=i+e,a=i-e;if(null!==this.view&&this.view.enabled){const t=(this.right-this.left)/this.view.fullWidth/this.zoom,e=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=t*this.view.offsetX,s=r+t*this.view.width,o-=e*this.view.offsetY,a=o-e*this.view.height}this.projectionMatrix.makeOrthographic(r,s,o,a,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(t){const e=dnt.prototype.toJSON.call(this,t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}}),Qlt.prototype=Object.assign(Object.create(Ult.prototype),{constructor:Qlt,isDirectionalLightShadow:!0,updateMatrices:function(t){Ult.prototype.updateMatrices.call(this,t)}}),qlt.prototype=Object.assign(Object.create($lt.prototype),{constructor:qlt,isDirectionalLight:!0,copy:function(t){return $lt.prototype.copy.call(this,t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}),Xlt.prototype=Object.assign(Object.create($lt.prototype),{constructor:Xlt,isAmbientLight:!0}),Ylt.prototype=Object.assign(Object.create($lt.prototype),{constructor:Ylt,isRectAreaLight:!0,copy:function(t){return $lt.prototype.copy.call(this,t),this.width=t.width,this.height=t.height,this},toJSON:function(t){const e=$lt.prototype.toJSON.call(this,t);return e.object.width=this.width,e.object.height=this.height,e}});class Klt{constructor(){Object.defineProperty(this,"isSphericalHarmonics3",{value:!0}),this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new det)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const n=t.x,i=t.y,r=t.z,s=this.coefficients;return e.copy(s[0]).multiplyScalar(.282095),e.addScaledVector(s[1],.488603*i),e.addScaledVector(s[2],.488603*r),e.addScaledVector(s[3],.488603*n),e.addScaledVector(s[4],n*i*1.092548),e.addScaledVector(s[5],i*r*1.092548),e.addScaledVector(s[6],.315392*(3*r*r-1)),e.addScaledVector(s[7],n*r*1.092548),e.addScaledVector(s[8],.546274*(n*n-i*i)),e}getIrradianceAt(t,e){const n=t.x,i=t.y,r=t.z,s=this.coefficients;return e.copy(s[0]).multiplyScalar(.886227),e.addScaledVector(s[1],1.023328*i),e.addScaledVector(s[2],1.023328*r),e.addScaledVector(s[3],1.023328*n),e.addScaledVector(s[4],.858086*n*i),e.addScaledVector(s[5],.858086*i*r),e.addScaledVector(s[6],.743125*r*r-.247708),e.addScaledVector(s[7],.858086*n*r),e.addScaledVector(s[8],.429043*(n*n-i*i)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(t.coefficients[n],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let n=0;n<9;n++)this.coefficients[n].lerp(t.coefficients[n],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(t,e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(t,e+3*i);return this}toArray(t=[],e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(t,e+3*i);return t}static getBasisAt(t,e){const n=t.x,i=t.y,r=t.z;e[0]=.282095,e[1]=.488603*i,e[2]=.488603*r,e[3]=.488603*n,e[4]=1.092548*n*i,e[5]=1.092548*i*r,e[6]=.315392*(3*r*r-1),e[7]=1.092548*n*r,e[8]=.546274*(n*n-i*i)}}function Jlt(t,e){$lt.call(this,void 0,e),this.type="LightProbe",this.sh=void 0!==t?t:new Klt}function Zlt(t){alt.call(this,t),this.textures={}}function tct(){lit.call(this),this.type="InstancedBufferGeometry",this.instanceCount=1/0}function ect(t,e,n,i){"number"==typeof n&&(i=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),Unt.call(this,t,e,n),this.meshPerAttribute=i||1}function nct(t){alt.call(this,t)}function ict(t){"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),alt.call(this,t),this.options={premultiplyAlpha:"none"}}function rct(){this.type="ShapePath",this.color=new Dnt,this.subPaths=[],this.currentPath=null}Jlt.prototype=Object.assign(Object.create($lt.prototype),{constructor:Jlt,isLightProbe:!0,copy:function(t){return $lt.prototype.copy.call(this,t),this.sh.copy(t.sh),this},fromJSON:function(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this},toJSON:function(t){const e=$lt.prototype.toJSON.call(this,t);return e.object.sh=this.sh.toArray(),e}}),Zlt.prototype=Object.assign(Object.create(alt.prototype),{constructor:Zlt,load:function(t,e,n,i){const r=this,s=new clt(r.manager);s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(t,function(n){try{e(r.parse(JSON.parse(n)))}catch(s){i?i(s):console.error(s),r.manager.itemError(t)}},n,i)},parse:function(t){const e=this.textures;function n(t){return void 0===e[t]&&console.warn("THREE.MaterialLoader: Undefined texture",t),e[t]}const i=new Vat[t.type];if(void 0!==t.uuid&&(i.uuid=t.uuid),void 0!==t.name&&(i.name=t.name),void 0!==t.color&&void 0!==i.color&&i.color.setHex(t.color),void 0!==t.roughness&&(i.roughness=t.roughness),void 0!==t.metalness&&(i.metalness=t.metalness),void 0!==t.sheen&&(i.sheen=(new Dnt).setHex(t.sheen)),void 0!==t.emissive&&void 0!==i.emissive&&i.emissive.setHex(t.emissive),void 0!==t.specular&&void 0!==i.specular&&i.specular.setHex(t.specular),void 0!==t.shininess&&(i.shininess=t.shininess),void 0!==t.clearcoat&&(i.clearcoat=t.clearcoat),void 0!==t.clearcoatRoughness&&(i.clearcoatRoughness=t.clearcoatRoughness),void 0!==t.fog&&(i.fog=t.fog),void 0!==t.flatShading&&(i.flatShading=t.flatShading),void 0!==t.blending&&(i.blending=t.blending),void 0!==t.combine&&(i.combine=t.combine),void 0!==t.side&&(i.side=t.side),void 0!==t.opacity&&(i.opacity=t.opacity),void 0!==t.transparent&&(i.transparent=t.transparent),void 0!==t.alphaTest&&(i.alphaTest=t.alphaTest),void 0!==t.depthTest&&(i.depthTest=t.depthTest),void 0!==t.depthWrite&&(i.depthWrite=t.depthWrite),void 0!==t.colorWrite&&(i.colorWrite=t.colorWrite),void 0!==t.stencilWrite&&(i.stencilWrite=t.stencilWrite),void 0!==t.stencilWriteMask&&(i.stencilWriteMask=t.stencilWriteMask),void 0!==t.stencilFunc&&(i.stencilFunc=t.stencilFunc),void 0!==t.stencilRef&&(i.stencilRef=t.stencilRef),void 0!==t.stencilFuncMask&&(i.stencilFuncMask=t.stencilFuncMask),void 0!==t.stencilFail&&(i.stencilFail=t.stencilFail),void 0!==t.stencilZFail&&(i.stencilZFail=t.stencilZFail),void 0!==t.stencilZPass&&(i.stencilZPass=t.stencilZPass),void 0!==t.wireframe&&(i.wireframe=t.wireframe),void 0!==t.wireframeLinewidth&&(i.wireframeLinewidth=t.wireframeLinewidth),void 0!==t.wireframeLinecap&&(i.wireframeLinecap=t.wireframeLinecap),void 0!==t.wireframeLinejoin&&(i.wireframeLinejoin=t.wireframeLinejoin),void 0!==t.rotation&&(i.rotation=t.rotation),1!==t.linewidth&&(i.linewidth=t.linewidth),void 0!==t.dashSize&&(i.dashSize=t.dashSize),void 0!==t.gapSize&&(i.gapSize=t.gapSize),void 0!==t.scale&&(i.scale=t.scale),void 0!==t.polygonOffset&&(i.polygonOffset=t.polygonOffset),void 0!==t.polygonOffsetFactor&&(i.polygonOffsetFactor=t.polygonOffsetFactor),void 0!==t.polygonOffsetUnits&&(i.polygonOffsetUnits=t.polygonOffsetUnits),void 0!==t.skinning&&(i.skinning=t.skinning),void 0!==t.morphTargets&&(i.morphTargets=t.morphTargets),void 0!==t.morphNormals&&(i.morphNormals=t.morphNormals),void 0!==t.dithering&&(i.dithering=t.dithering),void 0!==t.vertexTangents&&(i.vertexTangents=t.vertexTangents),void 0!==t.visible&&(i.visible=t.visible),void 0!==t.toneMapped&&(i.toneMapped=t.toneMapped),void 0!==t.userData&&(i.userData=t.userData),void 0!==t.vertexColors&&(i.vertexColors="number"==typeof t.vertexColors?t.vertexColors>0:t.vertexColors),void 0!==t.uniforms)for(const r in t.uniforms){const e=t.uniforms[r];switch(i.uniforms[r]={},e.type){case"t":i.uniforms[r].value=n(e.value);break;case"c":i.uniforms[r].value=(new Dnt).setHex(e.value);break;case"v2":i.uniforms[r].value=(new eet).fromArray(e.value);break;case"v3":i.uniforms[r].value=(new det).fromArray(e.value);break;case"v4":i.uniforms[r].value=(new cet).fromArray(e.value);break;case"m3":i.uniforms[r].value=(new net).fromArray(e.value);break;case"m4":i.uniforms[r].value=(new Uet).fromArray(e.value);break;default:i.uniforms[r].value=e.value}}if(void 0!==t.defines&&(i.defines=t.defines),void 0!==t.vertexShader&&(i.vertexShader=t.vertexShader),void 0!==t.fragmentShader&&(i.fragmentShader=t.fragmentShader),void 0!==t.extensions)for(const r in t.extensions)i.extensions[r]=t.extensions[r];if(void 0!==t.shading&&(i.flatShading=1===t.shading),void 0!==t.size&&(i.size=t.size),void 0!==t.sizeAttenuation&&(i.sizeAttenuation=t.sizeAttenuation),void 0!==t.map&&(i.map=n(t.map)),void 0!==t.matcap&&(i.matcap=n(t.matcap)),void 0!==t.alphaMap&&(i.alphaMap=n(t.alphaMap)),void 0!==t.bumpMap&&(i.bumpMap=n(t.bumpMap)),void 0!==t.bumpScale&&(i.bumpScale=t.bumpScale),void 0!==t.normalMap&&(i.normalMap=n(t.normalMap)),void 0!==t.normalMapType&&(i.normalMapType=t.normalMapType),void 0!==t.normalScale){let e=t.normalScale;!1===Array.isArray(e)&&(e=[e,e]),i.normalScale=(new eet).fromArray(e)}return void 0!==t.displacementMap&&(i.displacementMap=n(t.displacementMap)),void 0!==t.displacementScale&&(i.displacementScale=t.displacementScale),void 0!==t.displacementBias&&(i.displacementBias=t.displacementBias),void 0!==t.roughnessMap&&(i.roughnessMap=n(t.roughnessMap)),void 0!==t.metalnessMap&&(i.metalnessMap=n(t.metalnessMap)),void 0!==t.emissiveMap&&(i.emissiveMap=n(t.emissiveMap)),void 0!==t.emissiveIntensity&&(i.emissiveIntensity=t.emissiveIntensity),void 0!==t.specularMap&&(i.specularMap=n(t.specularMap)),void 0!==t.envMap&&(i.envMap=n(t.envMap)),void 0!==t.envMapIntensity&&(i.envMapIntensity=t.envMapIntensity),void 0!==t.reflectivity&&(i.reflectivity=t.reflectivity),void 0!==t.refractionRatio&&(i.refractionRatio=t.refractionRatio),void 0!==t.lightMap&&(i.lightMap=n(t.lightMap)),void 0!==t.lightMapIntensity&&(i.lightMapIntensity=t.lightMapIntensity),void 0!==t.aoMap&&(i.aoMap=n(t.aoMap)),void 0!==t.aoMapIntensity&&(i.aoMapIntensity=t.aoMapIntensity),void 0!==t.gradientMap&&(i.gradientMap=n(t.gradientMap)),void 0!==t.clearcoatMap&&(i.clearcoatMap=n(t.clearcoatMap)),void 0!==t.clearcoatRoughnessMap&&(i.clearcoatRoughnessMap=n(t.clearcoatRoughnessMap)),void 0!==t.clearcoatNormalMap&&(i.clearcoatNormalMap=n(t.clearcoatNormalMap)),void 0!==t.clearcoatNormalScale&&(i.clearcoatNormalScale=(new eet).fromArray(t.clearcoatNormalScale)),void 0!==t.transmission&&(i.transmission=t.transmission),void 0!==t.transmissionMap&&(i.transmissionMap=n(t.transmissionMap)),i},setTextures:function(t){return this.textures=t,this}}),tct.prototype=Object.assign(Object.create(lit.prototype),{constructor:tct,isInstancedBufferGeometry:!0,copy:function(t){return lit.prototype.copy.call(this,t),this.instanceCount=t.instanceCount,this},clone:function(){return(new this.constructor).copy(this)},toJSON:function(){const t=lit.prototype.toJSON.call(this);return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}),ect.prototype=Object.assign(Object.create(Unt.prototype),{constructor:ect,isInstancedBufferAttribute:!0,copy:function(t){return Unt.prototype.copy.call(this,t),this.meshPerAttribute=t.meshPerAttribute,this},toJSON:function(){const t=Unt.prototype.toJSON.call(this);return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}),nct.prototype=Object.assign(Object.create(alt.prototype),{constructor:nct,load:function(t,e,n,i){const r=this,s=new clt(r.manager);s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(t,function(n){try{e(r.parse(JSON.parse(n)))}catch(s){i?i(s):console.error(s),r.manager.itemError(t)}},n,i)},parse:function(t){const e={},n={};function i(t,i){if(void 0!==e[i])return e[i];const r=t.interleavedBuffers[i],s=function(t,e){if(void 0!==n[e])return n[e];const i=new Uint32Array(t.arrayBuffers[e]).buffer;return n[e]=i,i}(t,r.buffer),o=new Kst(tit(r.type,s),r.stride);return o.uuid=r.uuid,e[i]=o,o}const r=t.isInstancedBufferGeometry?new tct:new lit,s=t.data.index;if(void 0!==s){const t=tit(s.type,s.array);r.setIndex(new Unt(t,1))}const o=t.data.attributes;for(const u in o){const e=o[u];let n;if(e.isInterleavedBufferAttribute)n=new Zst(i(t.data,e.data),e.itemSize,e.offset,e.normalized);else{const t=tit(e.type,e.array);n=new(e.isInstancedBufferAttribute?ect:Unt)(t,e.itemSize,e.normalized)}void 0!==e.name&&(n.name=e.name),r.setAttribute(u,n)}const a=t.data.morphAttributes;if(a)for(const u in a){const e=a[u],n=[];for(let r=0,s=e.length;r<s;r++){const s=e[r];let o;o=s.isInterleavedBufferAttribute?new Zst(i(t.data,s.data),s.itemSize,s.offset,s.normalized):new Unt(tit(s.type,s.array),s.itemSize,s.normalized),void 0!==s.name&&(o.name=s.name),n.push(o)}r.morphAttributes[u]=n}t.data.morphTargetsRelative&&(r.morphTargetsRelative=!0);const l=t.data.groups||t.data.drawcalls||t.data.offsets;if(void 0!==l)for(let u=0,h=l.length;u!==h;++u){const t=l[u];r.addGroup(t.start,t.count,t.materialIndex)}const c=t.data.boundingSphere;if(void 0!==c){const t=new det;void 0!==c.center&&t.fromArray(c.center),r.boundingSphere=new Net(t,c.radius)}return t.name&&(r.name=t.name),t.userData&&(r.userData=t.userData),r}}),ict.prototype=Object.assign(Object.create(alt.prototype),{constructor:ict,isImageBitmapLoader:!0,setOptions:function(t){return this.options=t,this},load:function(t,e,n,i){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,s=slt.get(t);if(void 0!==s)return r.manager.itemStart(t),setTimeout(function(){e&&e(s),r.manager.itemEnd(t)},0),s;const o={};o.credentials="anonymous"===this.crossOrigin?"same-origin":"include",fetch(t,o).then(function(t){return t.blob()}).then(function(t){return createImageBitmap(t,r.options)}).then(function(n){slt.add(t,n),e&&e(n),r.manager.itemEnd(t)}).catch(function(e){i&&i(e),r.manager.itemError(t),r.manager.itemEnd(t)}),r.manager.itemStart(t)}}),Object.assign(rct.prototype,{moveTo:function(t,e){return this.currentPath=new Plt,this.subPaths.push(this.currentPath),this.currentPath.moveTo(t,e),this},lineTo:function(t,e){return this.currentPath.lineTo(t,e),this},quadraticCurveTo:function(t,e,n,i){return this.currentPath.quadraticCurveTo(t,e,n,i),this},bezierCurveTo:function(t,e,n,i,r,s){return this.currentPath.bezierCurveTo(t,e,n,i,r,s),this},splineThru:function(t){return this.currentPath.splineThru(t),this},toShapes:function(t,e){function n(t){const e=[];for(let n=0,i=t.length;n<i;n++){const i=t[n],r=new Flt;r.curves=i.curves,e.push(r)}return e}function i(t,e){const n=e.length;let i=!1;for(let r=n-1,s=0;s<n;r=s++){let n=e[r],o=e[s],a=o.x-n.x,l=o.y-n.y;if(Math.abs(l)>Number.EPSILON){if(l<0&&(n=e[s],a=-a,o=e[r],l=-l),t.y<n.y||t.y>o.y)continue;if(t.y===n.y){if(t.x===n.x)return!0}else{const e=l*(t.x-n.x)-a*(t.y-n.y);if(0===e)return!0;if(e<0)continue;i=!i}}else{if(t.y!==n.y)continue;if(o.x<=t.x&&t.x<=n.x||n.x<=t.x&&t.x<=o.x)return!0}}return i}const r=Cat.isClockWise,s=this.subPaths;if(0===s.length)return[];if(!0===e)return n(s);let o,a,l;const c=[];if(1===s.length)return a=s[0],l=new Flt,l.curves=a.curves,c.push(l),c;let u=!r(s[0].getPoints());u=t?!u:u;const h=[],d=[];let p,f,m=[],g=0;d[g]=void 0,m[g]=[];for(let y=0,v=s.length;y<v;y++)a=s[y],p=a.getPoints(),o=r(p),o=t?!o:o,o?(!u&&d[g]&&g++,d[g]={s:new Flt,p:p},d[g].s.curves=a.curves,u&&g++,m[g]=[]):m[g].push({h:a,p:p[0]});if(!d[0])return n(s);if(d.length>1){let t=!1;const e=[];for(let n=0,i=d.length;n<i;n++)h[n]=[];for(let n=0,r=d.length;n<r;n++){const r=m[n];for(let s=0;s<r.length;s++){const o=r[s];let a=!0;for(let r=0;r<d.length;r++)i(o.p,d[r].p)&&(n!==r&&e.push({froms:n,tos:r,hole:s}),a?(a=!1,h[r].push(o)):t=!0);a&&h[n].push(o)}}e.length>0&&(t||(m=h))}for(let y=0,v=d.length;y<v;y++){l=d[y].s,c.push(l),f=m[y];for(let t=0,e=f.length;t<e;t++)l.holes.push(f[t].h)}return c}});class sct{constructor(t){Object.defineProperty(this,"isFont",{value:!0}),this.type="Font",this.data=t}generateShapes(t,e=100){const n=[],i=function(t,e,n){const i=Array.from?Array.from(t):String(t).split(""),r=e/n.resolution,s=(n.boundingBox.yMax-n.boundingBox.yMin+n.underlineThickness)*r,o=[];let a=0,l=0;for(let c=0;c<i.length;c++){const t=i[c];if("\n"===t)a=0,l-=s;else{const e=oct(t,r,a,l,n);a+=e.offsetX,o.push(e.path)}}return o}(t,e,this.data);for(let r=0,s=i.length;r<s;r++)Array.prototype.push.apply(n,i[r].toShapes());return n}}function oct(t,e,n,i,r){const s=r.glyphs[t]||r.glyphs["?"];if(!s)return void console.error('THREE.Font: character "'+t+'" does not exists in font family '+r.familyName+".");const o=new rct;let a,l,c,u,h,d,p,f;if(s.o){const t=s._cachedOutline||(s._cachedOutline=s.o.split(" "));for(let r=0,s=t.length;r<s;)switch(t[r++]){case"m":a=t[r++]*e+n,l=t[r++]*e+i,o.moveTo(a,l);break;case"l":a=t[r++]*e+n,l=t[r++]*e+i,o.lineTo(a,l);break;case"q":c=t[r++]*e+n,u=t[r++]*e+i,h=t[r++]*e+n,d=t[r++]*e+i,o.quadraticCurveTo(h,d,c,u);break;case"b":c=t[r++]*e+n,u=t[r++]*e+i,h=t[r++]*e+n,d=t[r++]*e+i,p=t[r++]*e+n,f=t[r++]*e+i,o.bezierCurveTo(h,d,p,f,c,u)}}return{offsetX:s.ha*e,path:o}}function act(t){alt.call(this,t)}let lct;function cct(t){alt.call(this,t)}function uct(t,e,n){Jlt.call(this,void 0,n);const i=(new Dnt).set(t),r=(new Dnt).set(e),s=new det(i.r,i.g,i.b),o=new det(r.r,r.g,r.b),a=Math.sqrt(Math.PI),l=a*Math.sqrt(.75);this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a),this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l)}function hct(t,e){Jlt.call(this,void 0,e);const n=(new Dnt).set(t);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}act.prototype=Object.assign(Object.create(alt.prototype),{constructor:act,load:function(t,e,n,i){const r=this,s=new clt(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(r.withCredentials),s.load(t,function(t){let n;try{n=JSON.parse(t)}catch(s){console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),n=JSON.parse(t.substring(65,t.length-2))}const i=r.parse(n);e&&e(i)},n,i)},parse:function(t){return new sct(t)}}),cct.prototype=Object.assign(Object.create(alt.prototype),{constructor:cct,load:function(t,e,n,i){const r=this,s=new clt(r.manager);s.setResponseType("arraybuffer"),s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(t,function(n){try{const t=n.slice(0);(void 0===lct&&(lct=new(window.AudioContext||window.webkitAudioContext)),lct).decodeAudioData(t,function(t){e(t)})}catch(s){i?i(s):console.error(s),r.manager.itemError(t)}},n,i)}}),uct.prototype=Object.assign(Object.create(Jlt.prototype),{constructor:uct,isHemisphereLightProbe:!0,copy:function(t){return Jlt.prototype.copy.call(this,t),this},toJSON:function(t){return Jlt.prototype.toJSON.call(this,t)}}),hct.prototype=Object.assign(Object.create(Jlt.prototype),{constructor:hct,isAmbientLightProbe:!0,copy:function(t){return Jlt.prototype.copy.call(this,t),this},toJSON:function(t){return Jlt.prototype.toJSON.call(this,t)}});const dct=new Uet,pct=new Uet;function fct(t,e,n){let i,r,s;switch(this.binding=t,this.valueSize=n,e){case"quaternion":i=this._slerp,r=this._slerpAdditive,s=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*n),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,s=this._setAdditiveIdentityOther,this.buffer=new Array(5*n);break;default:i=this._lerp,r=this._lerpAdditive,s=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*n)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=s,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}Object.assign((function(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Dit,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Dit,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}).prototype,{update:function(t){const e=this._cache;if(e.focus!==t.focus||e.fov!==t.fov||e.aspect!==t.aspect*this.aspect||e.near!==t.near||e.far!==t.far||e.zoom!==t.zoom||e.eyeSep!==this.eyeSep){e.focus=t.focus,e.fov=t.fov,e.aspect=t.aspect*this.aspect,e.near=t.near,e.far=t.far,e.zoom=t.zoom,e.eyeSep=this.eyeSep;const n=t.projectionMatrix.clone(),i=e.eyeSep/2,r=i*e.near/e.focus,s=e.near*Math.tan(tet.DEG2RAD*e.fov*.5)/e.zoom;let o,a;pct.elements[12]=-i,dct.elements[12]=i,o=-s*e.aspect+r,a=s*e.aspect+r,n.elements[0]=2*e.near/(a-o),n.elements[8]=(a+o)/(a-o),this.cameraL.projectionMatrix.copy(n),o=-s*e.aspect-r,a=s*e.aspect-r,n.elements[0]=2*e.near/(a-o),n.elements[8]=(a+o)/(a-o),this.cameraR.projectionMatrix.copy(n)}this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(pct),this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(dct)}}),Object.assign(fct.prototype,{accumulate:function(t,e){const n=this.buffer,i=this.valueSize,r=t*i+i;let s=this.cumulativeWeight;if(0===s){for(let t=0;t!==i;++t)n[r+t]=n[t];s=e}else s+=e,this._mixBufferRegion(n,r,0,e/s,i);this.cumulativeWeight=s},accumulateAdditive:function(t){const e=this.buffer,n=this.valueSize,i=n*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(e,i,0,t,n),this.cumulativeWeightAdditive+=t},apply:function(t){const e=this.valueSize,n=this.buffer,i=t*e+e,r=this.cumulativeWeight,s=this.cumulativeWeightAdditive,o=this.binding;this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1&&this._mixBufferRegion(n,i,e*this._origIndex,1-r,e),s>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*e,1,e);for(let a=e,l=e+e;a!==l;++a)if(n[a]!==n[a+e]){o.setValue(n,i);break}},saveOriginalState:function(){const t=this.buffer,e=this.valueSize,n=e*this._origIndex;this.binding.getValue(t,n);for(let i=e,r=n;i!==r;++i)t[i]=t[n+i%e];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0},restoreOriginalState:function(){this.binding.setValue(this.buffer,3*this.valueSize)},_setAdditiveIdentityNumeric:function(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let n=t;n<e;n++)this.buffer[n]=0},_setAdditiveIdentityQuaternion:function(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1},_setAdditiveIdentityOther:function(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[e+n]=this.buffer[t+n]},_select:function(t,e,n,i,r){if(i>=.5)for(let s=0;s!==r;++s)t[e+s]=t[n+s]},_slerp:function(t,e,n,i){het.slerpFlat(t,e,t,e,t,n,i)},_slerpAdditive:function(t,e,n,i,r){const s=this._workIndex*r;het.multiplyQuaternionsFlat(t,s,t,e,t,n),het.slerpFlat(t,e,t,e,t,s,i)},_lerp:function(t,e,n,i,r){const s=1-i;for(let o=0;o!==r;++o){const r=e+o;t[r]=t[r]*s+t[n+o]*i}},_lerpAdditive:function(t,e,n,i,r){for(let s=0;s!==r;++s){const r=e+s;t[r]=t[r]+t[n+s]*i}}});const mct=new RegExp("[\\[\\]\\.:\\/]","g"),gct="[^\\[\\]\\.:\\/]",yct="[^"+"\\[\\]\\.:\\/".replace("\\.","")+"]",vct=/((?:WC+[\/:])*)/.source.replace("WC",gct),bct=/(WCOD+)?/.source.replace("WCOD",yct),Act=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",gct),xct=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",gct),wct=new RegExp("^"+vct+bct+Act+xct+"$"),_ct=["material","materials","bones"];function Sct(t,e,n){const i=n||Ect.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,i)}function Ect(t,e,n){this.path=e,this.parsedPath=n||Ect.parseTrackName(e),this.node=Ect.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t}Object.assign(Sct.prototype,{getValue:function(t,e){this.bind();const n=this._bindings[this._targetGroup.nCachedObjects_];void 0!==n&&n.getValue(t,e)},setValue:function(t,e){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=n.length;i!==r;++i)n[i].setValue(t,e)},bind:function(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].bind()},unbind:function(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].unbind()}}),Object.assign(Ect,{Composite:Sct,create:function(t,e,n){return t&&t.isAnimationObjectGroup?new Ect.Composite(t,e,n):new Ect(t,e,n)},sanitizeNodeName:function(t){return t.replace(/\s/g,"_").replace(mct,"")},parseTrackName:function(t){const e=wct.exec(t);if(!e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const n={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==i&&-1!==i){const t=n.nodeName.substring(i+1);-1!==_ct.indexOf(t)&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=t)}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return n},findNode:function(t,e){if(!e||""===e||"."===e||-1===e||e===t.name||e===t.uuid)return t;if(t.skeleton){const n=t.skeleton.getBoneByName(e);if(void 0!==n)return n}if(t.children){const n=function(t){for(let i=0;i<t.length;i++){const r=t[i];if(r.name===e||r.uuid===e)return r;const s=n(r.children);if(s)return s}return null},i=n(t.children);if(i)return i}return null}}),Object.assign(Ect.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(t,e){t[e]=this.node[this.propertyName]},function(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)t[e++]=n[i]},function(t,e){t[e]=this.resolvedProperty[this.propertyIndex]},function(t,e){this.resolvedProperty.toArray(t,e)}],SetterByBindingTypeAndVersioning:[[function(t,e){this.targetObject[this.propertyName]=t[e]},function(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0},function(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++]},function(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++];this.targetObject.needsUpdate=!0},function(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,e){this.resolvedProperty[this.propertyIndex]=t[e]},function(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0},function(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,e){this.resolvedProperty.fromArray(t,e)},function(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0},function(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}]],getValue:function(t,e){this.bind(),this.getValue(t,e)},setValue:function(t,e){this.bind(),this.setValue(t,e)},bind:function(){let t=this.node;const e=this.parsedPath,n=e.objectName,i=e.propertyName;let r=e.propertyIndex;if(t||(t=Ect.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(n){let i=e.objectIndex;switch(n){case"materials":if(!t.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);t=t.material.materials;break;case"bones":if(!t.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);t=t.skeleton.bones;for(let e=0;e<t.length;e++)if(t[e].name===i){i=e;break}break;default:if(void 0===t[n])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);t=t[n]}if(void 0!==i){if(void 0===t[i])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);t=t[i]}}const s=t[i];if(void 0===s)return void console.error("THREE.PropertyBinding: Trying to update property for track: "+e.nodeName+"."+i+" but it wasn't found.",t);let o=this.Versioning.None;this.targetObject=t,void 0!==t.needsUpdate?o=this.Versioning.NeedsUpdate:void 0!==t.matrixWorldNeedsUpdate&&(o=this.Versioning.MatrixWorldNeedsUpdate);let a=this.BindingType.Direct;if(void 0!==r){if("morphTargetInfluences"===i){if(!t.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!t.geometry.isBufferGeometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);if(!t.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==t.morphTargetDictionary[r]&&(r=t.morphTargetDictionary[r])}a=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=r}else void 0!==s.fromArray&&void 0!==s.toArray?(a=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(a=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=i;this.getValue=this.GetterByBindingType[a],this.setValue=this.SetterByBindingTypeAndVersioning[a][o]},unbind:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}),Object.assign(Ect.prototype,{_getValue_unbound:Ect.prototype.getValue,_setValue_unbound:Ect.prototype.setValue}),Object.assign((function(){this.uuid=tet.generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const t={};this._indicesByUUID=t;for(let n=0,i=arguments.length;n!==i;++n)t[arguments[n].uuid]=n;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const e=this;this.stats={objects:{get total(){return e._objects.length},get inUse(){return this.total-e.nCachedObjects_}},get bindingsPerObject(){return e._bindings.length}}}).prototype,{isAnimationObjectGroup:!0,add:function(){const t=this._objects,e=this._indicesByUUID,n=this._paths,i=this._parsedPaths,r=this._bindings,s=r.length;let o,a=t.length,l=this.nCachedObjects_;for(let c=0,u=arguments.length;c!==u;++c){const u=arguments[c],h=u.uuid;let d=e[h];if(void 0===d){d=a++,e[h]=d,t.push(u);for(let t=0,e=s;t!==e;++t)r[t].push(new Ect(u,n[t],i[t]))}else if(d<l){o=t[d];const a=--l,c=t[a];e[c.uuid]=d,t[d]=c,e[h]=a,t[a]=u;for(let t=0,e=s;t!==e;++t){const e=r[t];let s=e[d];e[d]=e[a],void 0===s&&(s=new Ect(u,n[t],i[t])),e[a]=s}}else t[d]!==o&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l},remove:function(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_;for(let s=0,o=arguments.length;s!==o;++s){const o=arguments[s],a=o.uuid,l=e[a];if(void 0!==l&&l>=r){const s=r++,c=t[s];e[c.uuid]=l,t[l]=c,e[a]=s,t[s]=o;for(let t=0,e=i;t!==e;++t){const e=n[t],i=e[l];e[l]=e[s],e[s]=i}}}this.nCachedObjects_=r},uncache:function(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_,s=t.length;for(let o=0,a=arguments.length;o!==a;++o){const a=arguments[o].uuid,l=e[a];if(void 0!==l)if(delete e[a],l<r){const o=--r,a=t[o],c=--s,u=t[c];e[a.uuid]=l,t[l]=a,e[u.uuid]=o,t[o]=u,t.pop();for(let t=0,e=i;t!==e;++t){const e=n[t],i=e[c];e[l]=e[o],e[o]=i,e.pop()}}else{const r=--s,o=t[r];r>0&&(e[o.uuid]=l),t[l]=o,t.pop();for(let t=0,e=i;t!==e;++t){const e=n[t];e[l]=e[r],e.pop()}}}this.nCachedObjects_=r},subscribe_:function(t,e){const n=this._bindingsIndicesByPath;let i=n[t];const r=this._bindings;if(void 0!==i)return r[i];const s=this._paths,o=this._parsedPaths,a=this._objects,l=this.nCachedObjects_,c=new Array(a.length);i=r.length,n[t]=i,s.push(t),o.push(e),r.push(c);for(let u=l,h=a.length;u!==h;++u)c[u]=new Ect(a[u],t,e);return c},unsubscribe_:function(t){const e=this._bindingsIndicesByPath,n=e[t];if(void 0!==n){const i=this._paths,r=this._parsedPaths,s=this._bindings,o=s.length-1,a=s[o];e[t[o]]=n,s[n]=a,s.pop(),r[n]=r[o],r.pop(),i[n]=i[o],i.pop()}}});class Cct{constructor(t,e,n=null,i=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=n,this.blendMode=i;const r=e.tracks,s=r.length,o=new Array(s),a={endingStart:Vtt,endingEnd:Vtt};for(let l=0;l!==s;++l){const t=r[l].createInterpolant(null);o[l]=t,t.settings=a}this._interpolantSettings=a,this._interpolants=o,this._propertyBindings=new Array(s),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,n){if(t.fadeOut(e),this.fadeIn(e),n){const n=this._clip.duration,i=t._clip.duration,r=n/i;t.warp(1,i/n,e),this.warp(r,1,e)}return this}crossFadeTo(t,e,n){return t.crossFadeFrom(this,e,n)}stopFading(){const t=this._weightInterpolant;return null!==t&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,n){const i=this._mixer,r=i.time,s=this.timeScale;let o=this._timeScaleInterpolant;null===o&&(o=i._lendControlInterpolant(),this._timeScaleInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=r,a[1]=r+n,l[0]=t/s,l[1]=e/s,this}stopWarping(){const t=this._timeScaleInterpolant;return null!==t&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,n,i){if(!this.enabled)return void this._updateWeight(t);const r=this._startTime;if(null!==r){const i=(t-r)*n;if(i<0||0===n)return;this._startTime=null,e=n*i}e*=this._updateTimeScale(t);const s=this._updateTime(e),o=this._updateWeight(t);if(o>0){const t=this._interpolants,e=this._propertyBindings;switch(this.blendMode){case 2501:for(let n=0,i=t.length;n!==i;++n)t[n].evaluate(s),e[n].accumulateAdditive(o);break;case 2500:default:for(let n=0,r=t.length;n!==r;++n)t[n].evaluate(s),e[n].accumulate(i,o)}}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const n=this._weightInterpolant;if(null!==n){const i=n.evaluate(t)[0];e*=i,t>n.parameterPositions[1]&&(this.stopFading(),0===i&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const n=this._timeScaleInterpolant;null!==n&&(e*=n.evaluate(t)[0],t>n.parameterPositions[1]&&(this.stopWarping(),0===e?this.paused=!0:this.timeScale=e))}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,n=this.loop;let i=this.time+t,r=this._loopCount;const s=2202===n;if(0===t)return-1===r?i:s&&1==(1&r)?e-i:i;if(2200===n){-1===r&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(i>=e)i=e;else{if(!(i<0)){this.time=i;break t}i=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(-1===r&&(t>=0?(r=0,this._setEndings(!0,0===this.repetitions,s)):this._setEndings(0===this.repetitions,!0,s)),i>=e||i<0){const n=Math.floor(i/e);i-=e*n,r+=Math.abs(n);const o=this.repetitions-r;if(o<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=t>0?e:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(1===o){const e=t<0;this._setEndings(e,!e,s)}else this._setEndings(!1,!1,s);this._loopCount=r,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:n})}}else this.time=i;if(s&&1==(1&r))return e-i}return i}_setEndings(t,e,n){const i=this._interpolantSettings;n?(i.endingStart=Gtt,i.endingEnd=Gtt):(i.endingStart=t?this.zeroSlopeAtStart?Gtt:Vtt:Wtt,i.endingEnd=e?this.zeroSlopeAtEnd?Gtt:Vtt:Wtt)}_scheduleFading(t,e,n){const i=this._mixer,r=i.time;let s=this._weightInterpolant;null===s&&(s=i._lendControlInterpolant(),this._weightInterpolant=s);const o=s.parameterPositions,a=s.sampleValues;return o[0]=r,a[0]=e,o[1]=r+t,a[1]=n,this}}function Ict(t){this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}Ict.prototype=Object.assign(Object.create(Ktt.prototype),{constructor:Ict,_bindAction:function(t,e){const n=t._localRoot||this._root,i=t._clip.tracks,r=i.length,s=t._propertyBindings,o=t._interpolants,a=n.uuid,l=this._bindingsByRootAndName;let c=l[a];void 0===c&&(c={},l[a]=c);for(let u=0;u!==r;++u){const t=i[u],r=t.name;let l=c[r];if(void 0!==l)s[u]=l;else{if(l=s[u],void 0!==l){null===l._cacheIndex&&(++l.referenceCount,this._addInactiveBinding(l,a,r));continue}l=new fct(Ect.create(n,r,e&&e._propertyBindings[u].binding.parsedPath),t.ValueTypeName,t.getValueSize()),++l.referenceCount,this._addInactiveBinding(l,a,r),s[u]=l}o[u].resultBuffer=l.buffer}},_activateAction:function(t){if(!this._isActiveAction(t)){if(null===t._cacheIndex){const e=(t._localRoot||this._root).uuid,n=t._clip.uuid,i=this._actionsByClip[n];this._bindAction(t,i&&i.knownActions[0]),this._addInactiveAction(t,n,e)}const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==n.useCount++&&(this._lendBinding(n),n.saveOriginalState())}this._lendAction(t)}},_deactivateAction:function(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==--n.useCount&&(n.restoreOriginalState(),this._takeBackBinding(n))}this._takeBackAction(t)}},_initMemoryManager:function(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}},_isActiveAction:function(t){const e=t._cacheIndex;return null!==e&&e<this._nActiveActions},_addInactiveAction:function(t,e,n){const i=this._actions,r=this._actionsByClip;let s=r[e];if(void 0===s)s={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,r[e]=s;else{const e=s.knownActions;t._byClipCacheIndex=e.length,e.push(t)}t._cacheIndex=i.length,i.push(t),s.actionByRoot[n]=t},_removeInactiveAction:function(t){const e=this._actions,n=e[e.length-1],i=t._cacheIndex;n._cacheIndex=i,e[i]=n,e.pop(),t._cacheIndex=null;const r=t._clip.uuid,s=this._actionsByClip,o=s[r],a=o.knownActions,l=a[a.length-1],c=t._byClipCacheIndex;l._byClipCacheIndex=c,a[c]=l,a.pop(),t._byClipCacheIndex=null,delete o.actionByRoot[(t._localRoot||this._root).uuid],0===a.length&&delete s[r],this._removeInactiveBindingsForAction(t)},_removeInactiveBindingsForAction:function(t){const e=t._propertyBindings;for(let n=0,i=e.length;n!==i;++n){const t=e[n];0==--t.referenceCount&&this._removeInactiveBinding(t)}},_lendAction:function(t){const e=this._actions,n=t._cacheIndex,i=this._nActiveActions++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r},_takeBackAction:function(t){const e=this._actions,n=t._cacheIndex,i=--this._nActiveActions,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r},_addInactiveBinding:function(t,e,n){const i=this._bindingsByRootAndName,r=this._bindings;let s=i[e];void 0===s&&(s={},i[e]=s),s[n]=t,t._cacheIndex=r.length,r.push(t)},_removeInactiveBinding:function(t){const e=this._bindings,n=t.binding,i=n.rootNode.uuid,r=n.path,s=this._bindingsByRootAndName,o=s[i],a=e[e.length-1],l=t._cacheIndex;a._cacheIndex=l,e[l]=a,e.pop(),delete o[r],0===Object.keys(o).length&&delete s[i]},_lendBinding:function(t){const e=this._bindings,n=t._cacheIndex,i=this._nActiveBindings++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r},_takeBackBinding:function(t){const e=this._bindings,n=t._cacheIndex,i=--this._nActiveBindings,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r},_lendControlInterpolant:function(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let n=t[e];return void 0===n&&(n=new Qat(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=e,t[e]=n),n},_takeBackControlInterpolant:function(t){const e=this._controlInterpolants,n=t.__cacheIndex,i=--this._nActiveControlInterpolants,r=e[i];t.__cacheIndex=i,e[i]=t,r.__cacheIndex=n,e[n]=r},_controlInterpolantsResultBuffer:new Float32Array(1),clipAction:function(t,e,n){const i=e||this._root,r=i.uuid;let s="string"==typeof t?ilt.findByName(i,t):t;const o=null!==s?s.uuid:t,a=this._actionsByClip[o];let l=null;if(void 0===n&&(n=null!==s?s.blendMode:2500),void 0!==a){const t=a.actionByRoot[r];if(void 0!==t&&t.blendMode===n)return t;l=a.knownActions[0],null===s&&(s=l._clip)}if(null===s)return null;const c=new Cct(this,s,e,n);return this._bindAction(c,l),this._addInactiveAction(c,o,r),c},existingAction:function(t,e){const n=e||this._root,i=n.uuid,r="string"==typeof t?ilt.findByName(n,t):t,s=this._actionsByClip[r?r.uuid:t];return void 0!==s&&s.actionByRoot[i]||null},stopAllAction:function(){const t=this._actions;for(let e=this._nActiveActions-1;e>=0;--e)t[e].stop();return this},update:function(t){const e=this._actions,n=this._nActiveActions,i=this.time+=t*=this.timeScale,r=Math.sign(t),s=this._accuIndex^=1;for(let l=0;l!==n;++l)e[l]._update(i,t,r,s);const o=this._bindings,a=this._nActiveBindings;for(let l=0;l!==a;++l)o[l].apply(s);return this},setTime:function(t){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(t)},getRoot:function(){return this._root},uncacheClip:function(t){const e=this._actions,n=t.uuid,i=this._actionsByClip,r=i[n];if(void 0!==r){const t=r.knownActions;for(let n=0,i=t.length;n!==i;++n){const i=t[n];this._deactivateAction(i);const r=i._cacheIndex,s=e[e.length-1];i._cacheIndex=null,i._byClipCacheIndex=null,s._cacheIndex=r,e[r]=s,e.pop(),this._removeInactiveBindingsForAction(i)}delete i[n]}},uncacheRoot:function(t){const e=t.uuid,n=this._actionsByClip;for(const r in n){const t=n[r].actionByRoot[e];void 0!==t&&(this._deactivateAction(t),this._removeInactiveAction(t))}const i=this._bindingsByRootAndName[e];if(void 0!==i)for(const r in i){const t=i[r];t.restoreOriginalState(),this._removeInactiveBinding(t)}},uncacheAction:function(t,e){const n=this.existingAction(t,e);null!==n&&(this._deactivateAction(n),this._removeInactiveAction(n))}});class Tct{constructor(t){"string"==typeof t&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),t=arguments[1]),this.value=t}clone(){return new Tct(void 0===this.value.clone?this.value:this.value.clone())}}function Mct(t,e,n){Kst.call(this,t,e),this.meshPerAttribute=n||1}function kct(t,e,n,i,r){this.buffer=t,this.type=e,this.itemSize=n,this.elementSize=i,this.count=r,this.version=0}function Rct(t,e,n,i){this.ray=new zet(t,e),this.near=n||0,this.far=i||1/0,this.camera=null,this.layers=new Jet,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}},Object.defineProperties(this.params,{PointCloud:{get:function(){return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),this.Points}}})}function Nct(t,e){return t.distance-e.distance}function Lct(t,e,n,i){if(t.layers.test(e.layers)&&t.raycast(e,n),!0===i){const i=t.children;for(let t=0,r=i.length;t<r;t++)Lct(i[t],e,n,!0)}}Mct.prototype=Object.assign(Object.create(Kst.prototype),{constructor:Mct,isInstancedInterleavedBuffer:!0,copy:function(t){return Kst.prototype.copy.call(this,t),this.meshPerAttribute=t.meshPerAttribute,this},clone:function(t){const e=Kst.prototype.clone.call(this,t);return e.meshPerAttribute=this.meshPerAttribute,e},toJSON:function(t){const e=Kst.prototype.toJSON.call(this,t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}),Object.defineProperty(kct.prototype,"needsUpdate",{set:function(t){!0===t&&this.version++}}),Object.assign(kct.prototype,{isGLBufferAttribute:!0,setBuffer:function(t){return this.buffer=t,this},setType:function(t,e){return this.type=t,this.elementSize=e,this},setItemSize:function(t){return this.itemSize=t,this},setCount:function(t){return this.count=t,this}}),Object.assign(Rct.prototype,{set:function(t,e){this.ray.set(t,e)},setFromCamera:function(t,e){e&&e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e&&e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)},intersectObject:function(t,e,n){const i=n||[];return Lct(t,this,i,e),i.sort(Nct),i},intersectObjects:function(t,e,n){const i=n||[];if(!1===Array.isArray(t))return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),i;for(let r=0,s=t.length;r<s;r++)Lct(t[r],this,i,e);return i.sort(Nct),i}});const Dct=new eet;function Bct(t){dnt.call(this),this.material=t,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}(Bct.prototype=Object.create(dnt.prototype)).constructor=Bct,Bct.prototype.isImmediateRenderObject=!0;const Oct=new det,Pct=new Uet,Fct=new Uet;function $ct(t){const e=[];t&&t.isBone&&e.push(t);for(let n=0;n<t.children.length;n++)e.push.apply(e,$ct(t.children[n]));return e}const zct=new Float32Array(1),Uct=(new Int32Array(zct.buffer),Math.pow(2,8),new Fnt({side:1,depthWrite:!1,depthTest:!1}));function Hct(t){console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),Slt.call(this,t),this.type="catmullrom"}new Cit(new Tit,Uct),Math.sqrt(5),glt.create=function(t,e){return console.log("THREE.Curve.create() has been deprecated"),t.prototype=Object.create(glt.prototype),t.prototype.constructor=t,t.prototype.getPoint=e,t},Object.assign(Plt.prototype,{fromPoints:function(t){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(t)}}),Object.create(Slt.prototype),Object.create(Slt.prototype),Hct.prototype=Object.create(Slt.prototype),Object.assign(Hct.prototype,{initFromArray:function(){console.error("THREE.Spline: .initFromArray() has been removed.")},getControlPointsArray:function(){console.error("THREE.Spline: .getControlPointsArray() has been removed.")},reparametrizeByArcLength:function(){console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")}}),class extends Vot{constructor(t=10,e=10,n=4473924,i=8947848){n=new Dnt(n),i=new Dnt(i);const r=e/2,s=t/e,o=t/2,a=[],l=[];for(let u=0,h=0,d=-o;u<=e;u++,d+=s){a.push(-o,0,d,o,0,d),a.push(d,0,-o,d,0,o);const t=u===r?n:i;t.toArray(l,h),h+=3,t.toArray(l,h),h+=3,t.toArray(l,h),h+=3,t.toArray(l,h),h+=3}const c=new lit;c.setAttribute("position",new Ynt(a,3)),c.setAttribute("color",new Ynt(l,3)),super(c,new Dot({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}}.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},class extends Vot{constructor(t){const e=$ct(t),n=new lit,i=[],r=[],s=new Dnt(0,0,1),o=new Dnt(0,1,0);for(let a=0;a<e.length;a++){const t=e[a];t.parent&&t.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),r.push(s.r,s.g,s.b),r.push(o.r,o.g,o.b))}n.setAttribute("position",new Ynt(i,3)),n.setAttribute("color",new Ynt(r,3)),super(n,new Dot({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,n=this.geometry,i=n.getAttribute("position");Fct.copy(this.root.matrixWorld).invert();for(let r=0,s=0;r<e.length;r++){const t=e[r];t.parent&&t.parent.isBone&&(Pct.multiplyMatrices(Fct,t.matrixWorld),Oct.setFromMatrixPosition(Pct),i.setXYZ(s,Oct.x,Oct.y,Oct.z),Pct.multiplyMatrices(Fct,t.parent.matrixWorld),Oct.setFromMatrixPosition(Pct),i.setXYZ(s+1,Oct.x,Oct.y,Oct.z),s+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},Object.assign(alt.prototype,{extractUrlBase:function(t){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),function(t){const e=t.lastIndexOf("/");return-1===e?"./":t.substr(0,e+1)}(t)}}),alt.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},Object.assign(class{constructor(t,e){Object.defineProperty(this,"isBox2",{value:!0}),this.min=void 0!==t?t:new eet(1/0,1/0),this.max=void 0!==e?e:new eet(-1/0,-1/0)}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=Dct.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return void 0===t&&(console.warn("THREE.Box2: .getCenter() target is now required"),t=new eet),this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return void 0===t&&(console.warn("THREE.Box2: .getSize() target is now required"),t=new eet),this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,e){return void 0===e&&(console.warn("THREE.Box2: .getParameter() target is now required"),e=new eet),e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y)}clampPoint(t,e){return void 0===e&&(console.warn("THREE.Box2: .clampPoint() target is now required"),e=new eet),e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return Dct.copy(t).clamp(this.min,this.max).sub(t).length()}intersect(t){return this.min.max(t.min),this.max.min(t.max),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}.prototype,{center:function(t){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(t)},empty:function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(t){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},size:function(t){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(t)}}),Object.assign(met.prototype,{center:function(t){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(t)},empty:function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(t){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},isIntersectionSphere:function(t){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)},size:function(t){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(t)}}),Object.assign(Net.prototype,{empty:function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()}}),Hit.prototype.setFromMatrix=function(t){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(t)},Object.assign(tet,{random16:function(){return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),Math.random()},nearestPowerOfTwo:function(t){return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),tet.floorPowerOfTwo(t)},nextPowerOfTwo:function(t){return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),tet.ceilPowerOfTwo(t)}}),Object.assign(net.prototype,{flattenToArrayOffset:function(t,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},multiplyVector3:function(t){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),t.applyMatrix3(this)},multiplyVector3Array:function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},applyToBufferAttribute:function(t){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),t.applyMatrix3(this)},applyToVector3Array:function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},getInverse:function(t){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(t).invert()}}),Object.assign(Uet.prototype,{extractPosition:function(t){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(t)},flattenToArrayOffset:function(t,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},getPosition:function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),(new det).setFromMatrixColumn(this,3)},setRotationFromQuaternion:function(t){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(t)},multiplyToArray:function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},multiplyVector3:function(t){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},multiplyVector4:function(t){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},multiplyVector3Array:function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},rotateAxis:function(t){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),t.transformDirection(this)},crossVector:function(t){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},translate:function(){console.error("THREE.Matrix4: .translate() has been removed.")},rotateX:function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},rotateY:function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},rotateZ:function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},rotateByAxis:function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},applyToBufferAttribute:function(t){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},applyToVector3Array:function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},makeFrustum:function(t,e,n,i,r,s){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(t,e,i,n,r,s)},getInverse:function(t){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(t).invert()}}),gnt.prototype.isIntersectionLine=function(t){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(t)},Object.assign(het.prototype,{multiplyVector3:function(t){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),t.applyQuaternion(this)},inverse:function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()}}),Object.assign(zet.prototype,{isIntersectionBox:function(t){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},isIntersectionPlane:function(t){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(t)},isIntersectionSphere:function(t){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)}}),Object.assign(Int.prototype,{area:function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},barycoordFromPoint:function(t,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(t,e)},midpoint:function(t){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(t)},normal:function(t){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(t)},plane:function(t){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(t)}}),Object.assign(Int,{barycoordFromPoint:function(t,e,n,i,r){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),Int.getBarycoord(t,e,n,i,r)},normal:function(t,e,n,i){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),Int.getNormal(t,e,n,i)}}),Object.assign(Flt.prototype,{extractAllPoints:function(t){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(t)},extrude:function(t){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new Mat(this,t)},makeGeometry:function(t){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new Nat(this,t)}}),Object.assign(eet.prototype,{fromAttribute:function(t,e,n){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},distanceToManhattan:function(t){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},lengthManhattan:function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(det.prototype,{setEulerFromRotationMatrix:function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},setEulerFromQuaternion:function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},getPositionFromMatrix:function(t){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(t)},getScaleFromMatrix:function(t){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(t)},getColumnFromMatrix:function(t,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,t)},applyProjection:function(t){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(t)},fromAttribute:function(t,e,n){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},distanceToManhattan:function(t){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},lengthManhattan:function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(cet.prototype,{fromAttribute:function(t,e,n){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},lengthManhattan:function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(dnt.prototype,{getChildByName:function(t){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(t)},renderDepth:function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},translate:function(t,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,t)},getWorldRotation:function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},applyMatrix:function(t){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)}}),Object.defineProperties(dnt.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(t){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=t}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),Object.assign(Cit.prototype,{setDrawMode:function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}),Object.defineProperties(Cit.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),0},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),Object.defineProperties(vot.prototype,{objects:{get:function(){return console.warn("THREE.LOD: .objects has been renamed to .levels."),this.levels}}}),Object.defineProperty(Tot.prototype,"useVertexTexture",{get:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")},set:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")}}),Sot.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},Object.defineProperty(glt.prototype,"__arcLengthDivisions",{get:function(){return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions},set:function(t){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions=t}}),Dit.prototype.setLens=function(t,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),void 0!==e&&(this.filmGauge=e),this.setFocalLength(t)},Object.defineProperties($lt.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(t){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=t}},shadowCameraLeft:{set:function(t){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=t}},shadowCameraRight:{set:function(t){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=t}},shadowCameraTop:{set:function(t){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=t}},shadowCameraBottom:{set:function(t){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=t}},shadowCameraNear:{set:function(t){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=t}},shadowCameraFar:{set:function(t){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=t}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(t){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=t}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(t){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=t}},shadowMapHeight:{set:function(t){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=t}}}),Object.defineProperties(Unt.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===Xtt},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(Xtt)}}}),Object.assign(Unt.prototype,{setDynamic:function(t){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===t?Xtt:qtt),this},copyIndicesArray:function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},setArray:function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}}),Object.assign(lit.prototype,{addIndex:function(t){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(t)},addAttribute:function(t,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),e&&e.isBufferAttribute||e&&e.isInterleavedBufferAttribute?"index"===t?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(t,e):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(t,new Unt(arguments[1],arguments[2])))},addDrawCall:function(t,e,n){void 0!==n&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(t,e)},clearDrawCalls:function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},computeOffsets:function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},removeAttribute:function(t){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(t)},applyMatrix:function(t){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)}}),Object.defineProperties(lit.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),Object.defineProperties(tct.prototype,{maxInstancedCount:{get:function(){return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount},set:function(t){console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount=t}}}),Object.defineProperties(Rct.prototype,{linePrecision:{get:function(){return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold},set:function(t){console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold=t}}}),Object.defineProperties(Kst.prototype,{dynamic:{get:function(){return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.usage===Xtt},set:function(t){console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.setUsage(t)}}}),Object.assign(Kst.prototype,{setDynamic:function(t){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===t?Xtt:qtt),this},setArray:function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}}),Object.assign(Mat.prototype,{getArrays:function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},addShapeList:function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},addShape:function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")}}),Object.assign(class extends dnt{constructor(){super(),Object.defineProperty(this,"isScene",{value:!0}),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),null!==t.background&&(this.background=t.background.clone()),null!==t.environment&&(this.environment=t.environment.clone()),null!==t.fog&&(this.fog=t.fog.clone()),null!==t.overrideMaterial&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return null!==this.background&&(e.object.background=this.background.toJSON(t)),null!==this.environment&&(e.object.environment=this.environment.toJSON(t)),null!==this.fog&&(e.object.fog=this.fog.toJSON()),e}}.prototype,{dispose:function(){console.error("THREE.Scene: .dispose() has been removed.")}}),Object.defineProperties(Tct.prototype,{dynamic:{set:function(){console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")}},onUpdate:{value:function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this}}}),Object.defineProperties(Pnt.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Dnt}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(t){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===t}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(t){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=t}}}),Object.defineProperties(Pat.prototype,{metal:{get:function(){return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),!1},set:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")}}}),Object.defineProperties(Oat.prototype,{transparency:{get:function(){return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission},set:function(t){console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission=t}}}),Object.defineProperties(Nit.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(t){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=t}}}),Object.assign(Xst.prototype,{clearTarget:function(t,e,n,i){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(t),this.clear(e,n,i)},animate:function(t){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(t)},getCurrentRenderTarget:function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},getMaxAnisotropy:function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},getPrecision:function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},resetGLState:function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},supportsFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},supportsHalfFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},supportsStandardDerivatives:function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},supportsCompressedTextureS3TC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},supportsCompressedTexturePVRTC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},supportsBlendMinMax:function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},supportsVertexTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},supportsInstancedArrays:function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},enableScissorTest:function(t){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(t)},initMaterial:function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},addPrePlugin:function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},addPostPlugin:function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},updateShadowMap:function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},setFaceCulling:function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},allocTextureUnit:function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},setTexture:function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},setTexture2D:function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},setTextureCube:function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},getActiveMipMapLevel:function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()}}),Object.defineProperties(Xst.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=t}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=t}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(t){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=!0===t?3001:jtt}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}}),Object.defineProperties(zst.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(uet.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=t}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=t}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=t}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=t}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(t){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=t}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(t){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=t}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(t){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=t}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(t){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=t}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(t){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=t}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(t){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=t}}}),Object.defineProperties(class extends dnt{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(!0===this.isPlaying)return void console.warn("THREE.Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(!1!==this.hasPlaybackControl)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),!0===this._connected?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(!1!==this.hasPlaybackControl)return this.playbackRate=t,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(!1!==this.hasPlaybackControl)return this.loop=t,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}.prototype,{load:{value:function(t){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const e=this;return(new cct).load(t,function(t){e.setBuffer(t)}),this}},startTime:{set:function(){console.warn("THREE.Audio: .startTime is now .play( delay ).")}}}),Oit.prototype.updateCubeMap=function(t,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(t,e)},Oit.prototype.clear=function(t,e,n,i){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(t,e,n,i)},ret.crossOrigin=void 0,ret.loadTexture=function(t,e,n,i){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const r=new mlt;r.setCrossOrigin(this.crossOrigin);const s=r.load(t,n,void 0,i);return e&&(s.mapping=e),s},ret.loadTextureCube=function(t,e,n,i){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const r=new plt;r.setCrossOrigin(this.crossOrigin);const s=r.load(t,n,void 0,i);return e&&(s.mapping=e),s},ret.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},ret.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:"125"}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__="125");let Vct=(()=>{class t{normal(t,e){const n=e.map(e=>t[e]);return{center:new det((n[0].x+n[1].x+n[2].x)/3,(n[0].y+n[1].y+n[2].y)/3,(n[0].z+n[1].z+n[2].z)/3),direction:(new gnt).setFromCoplanarPoints(n[0],n[1],n[2]).normal}}angle(t,e){return(180*Math.atan2(t,e)/Math.PI+360)%360}normalize(t,e,n,i,r=!1){let s=OF(t.map(t=>[t.x,t.y,t.z]));const o=new det(1,0,0),a=e.direction.multiplyScalar(-1),l=(new det).crossVectors(o,a),c=(new det).crossVectors(a,l),u=OF([[c.x,l.x,a.x],[c.y,l.y,a.y],[c.z,l.z,a.z]]);s=s.sub(s.slice(0,1)),s=vP(s,u),r&&(s=s.mul(OF([[-1,1,1]])));const h=s.slice(n[0],1),d=s.slice(n[1],1).sub(h).arraySync(),p=90+this.angle(d[0][1],d[0][0]),f=Math.sin(p*Math.PI/180),m=Math.cos(p*Math.PI/180),g=OF([[m,-f,0],[f,m,0],[0,0,1]]);s=s.dot(g);const y=s.slice(n[0],1),v=s.slice(n[1],1),b=hF(v.sub(y),2).sum().sqrt(),A=TO(200).div(b);return s=s.mul(A),s.sub(s.slice(i,1))}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})(),Gct=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({providers:[sM,Vct],imports:[[FI.forFeature([hM])]]}),t})(),Wct=(()=>{class t{shoulders(t){const e=t[nM.POSE_LANDMARKS.LEFT_SHOULDER],n=t[nM.POSE_LANDMARKS.RIGHT_SHOULDER];return{center:new eet((e.x+n.x)/2,(e.y+n.y)/2),width:Math.abs(e.x-n.x)}}drawShoulders(t,e){const n=qct.textFontSize("\ud8fa\udce1",t.width,e);qct.drawSWText("\ud8fa\udce1",t.center,n,e)}drawArm(t,e,n,i){e.visibility<.8||(i.strokeStyle="black",i.beginPath(),i.moveTo(t.x*i.canvas.width,t.y*i.canvas.height),i.lineTo(e.x*i.canvas.width,e.y*i.canvas.height),n.visibility>.8&&i.lineTo(n.x*i.canvas.width,n.y*i.canvas.height),i.stroke())}drawArms(t,e){e.lineWidth=t.shoulders.width*e.canvas.width/50;const n=[{x:t.shoulders.center.x+.45*t.shoulders.width,y:t.shoulders.center.y},{x:t.shoulders.center.x-.45*t.shoulders.width,y:t.shoulders.center.y}];this.drawArm(n[0],t.elbows[0],t.wrists[0],e),this.drawArm(n[1],t.elbows[1],t.wrists[1],e)}draw(t,e){t&&(this.drawShoulders(t.shoulders,e),this.drawArms(t,e))}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const jct={Eyes:["\ud8f1\udfb1","\ud8f2\udc71","\ud8f2\udc11","\ud8f2\uddf1"],Eyebrows:["\ud8f1\udc51","\ud8f0\udff1","\ud8f1\udcb1"],Mouth:["\ud8f6\udeb1","\ud8f6\udc71","\ud8f6\udd31","\ud8f5\ude31","\ud8f5\udf51","\ud8f6\udc11","\ud8f6\udf71"]};let Qct=(()=>{class t{constructor(t){this.poseNormalization=t}loadModel(){return Gj("assets/models/face-features/model.json").then(t=>this.faceSequentialModel=t)}normalize(t){const e=this.poseNormalization.normal(t,[4,133,362]);return this.poseNormalization.normalize(t,e,[4,6],4)}shape(t){const e=t[4],n=this.faceSequentialModel;if(!n)return{face:{location:e,symbol:"\ud8f1\udf81"}};const i=_O(()=>{const e=this.normalize(t);let i=n.predict(e.reshape([1,1,1404]));i=i.reshape([-1]);const r={};let s=0;for(const[t,n]of Object.entries(jct))r[t]=n[i.slice(s,n.length).argMax(0).dataSync()[0]],s+=n.length;return r}),r=this.shift(i.Eyes,16),s=(t[133].y+t[362].y)/2,o=new eet((t[133].x+t[33].x)/2,s),a=new eet((t[362].x+t[263].x)/2,s),l=(t[65].y+t[362].y)/2,c=this.shift(i.Eyebrows,16),u=new eet(t[282].x,l),h=this.shift(i.Eyebrows,32);return{face:{location:e,symbol:"\ud8ef\udfa1"},eyes:{left:{location:o,symbol:r},right:{location:a,symbol:r}},eyebrows:{left:{location:u,symbol:c},right:{location:new eet(t[52].x,l),symbol:h}},mouth:{location:new eet((t[14].x+t[17].x)/2,(t[14].y+t[17].y)/2),symbol:i.Mouth}}}drawFaceFeature(t,e,n){const i=qct.textFontSize(e.symbol,t,n);qct.drawSWText(e.symbol,e.location,i,n,!1)}draw(t,e){if(!t.face)return;const n=t.body.shoulders.width,{face:i,eyes:r,eyebrows:s,mouth:o}=t.face;i&&this.drawFaceFeature(.7*n,i,e),r&&(this.drawFaceFeature(.2*n,r.left,e),this.drawFaceFeature(.2*n,r.right,e)),s&&(this.drawFaceFeature(.15*n,s.left,e),this.drawFaceFeature(.15*n,s.right,e)),o&&this.drawFaceFeature(.25*n,o,e)}shift(t,e){return String.fromCodePoint(t.codePointAt(0)+e)}}return t.\u0275fac=function(e){return new(e||t)(Xi(Vct))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})(),qct=(()=>{class t{constructor(t,e,n){this.bodyService=t,this.faceService=e,this.handsService=n}static textFontSize(t,e,n){n.font="100px SuttonSignWritingOneD";const i=n.measureText(t);return e*n.canvas.width/i.width*100}static drawSWText(t,e,n,i,r=!0){i.font=n+"px SuttonSignWritingOneD",i.textAlign="center",i.textBaseline="middle",i.fillStyle="black",i.fillText(t,r?e.x*i.canvas.width:e.x,r?e.y*i.canvas.height:e.y)}draw(t,e){this.bodyService.draw(t.body,e),this.faceService.draw(t,e),this.handsService.draw(t,e)}}return t.\u0275fac=function(e){return new(e||t)(Xi(Wct),Xi(Qct),Xi(Xct))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})(),Xct=(()=>{class t{constructor(t){this.poseNormalization=t}loadModel(){return VI(this,void 0,void 0,function*(){return Promise.all([Gj("assets/models/hand-shape/model.json").then(t=>this.leftHandSequentialModel=t),Gj("assets/models/hand-shape/model.json").then(t=>this.rightHandSequentialModel=t)])})}normalizeHand(t,e,n){return this.poseNormalization.normalize(t,e,[0,9],0,n)}shape(t,e,n){const i=n?this.leftHandSequentialModel:this.rightHandSequentialModel;if(!i)return"\ud8d8\udd21";const r=_O(()=>{const r=this.normalizeHand(t,e,n),s=i.predict(r.reshape([1,1,63]));return TF(s).argMax(2).dataSync()[0]});return String.fromCodePoint(262145+96*r)}bbox(t){return(new met).setFromPoints(t)}normal(t,e=!1){const n=this.poseNormalization.normal(t,[0,5,17]);return n.direction=n.direction.multiplyScalar(e?-1:1),n}plane(t){const e=t[0],n=t[13];return 1.5*Math.abs(n.y-e.y)>Math.abs(n.z-e.z)?"wall":"floor"}rotation(t){const e=t[0],n=t[13];let i=this.poseNormalization.angle(n.y-e.y,n.x-e.x)+94;return i+=22.5,i=(i+360)%360,Math.floor(i/45)}direction(t,e,n){const i=n?e.direction.x:-e.direction.x;switch(t){case"wall":const t=this.poseNormalization.angle(e.direction.z,i);return t>210?"me":t>150?"side":"you";case"floor":const n=this.poseNormalization.angle(e.direction.y,i);return n>0?"me":n>-60?"side":"you"}}drawBbox(t,e){const n=new det(e.canvas.width,e.canvas.height,0),i=(new det).multiplyVectors(t.min,n),r=(new det).multiplyVectors(t.max,n);e.strokeStyle="#0000FF",e.beginPath(),e.moveTo(i.x,i.y),e.lineTo(i.x,r.y),e.lineTo(r.x,r.y),e.lineTo(r.x,i.y),e.lineTo(i.x,i.y),e.stroke()}drawNormal(t,e){const n=new det(e.canvas.width,e.canvas.height,e.canvas.width),i=(new det).multiplyVectors(n,t.direction).normalize().multiplyScalar(100),r=(new det).multiplyVectors(n,t.center);e.strokeStyle="#FFFF00",e.lineWidth=10,e.beginPath(),e.moveTo(r.x,r.y),e.lineTo(r.x+i.x,r.y+i.y),e.stroke()}drawShape(t,e,n,i){let r=e.shape.codePointAt(0);const s=new Set(["\ud8c7\ude71","\ud8c7\udcf1","\ud8d8\udd91","\ud8d7\udc51","\ud8c7\uddb1","\ud8c8\udf51","\ud8c8\ude91"].map(t=>t.codePointAt(0))).has(r+16);n||(r+=8),r+=n?(8-e.rotation)%8:e.rotation,s?r+=16:("floor"===e.plane&&(r+=48),r+={you:0,side:16,me:32}[e.direction]);const o=String.fromCodePoint(r),a=new eet((e.bbox.min.x+e.bbox.max.x)/(2*i.canvas.width),(e.bbox.min.y+e.bbox.max.y)/(2*i.canvas.height)),l=qct.textFontSize("\ud8c8\uddc1",t/3,i);qct.drawSWText(o,a,l,i)}drawHand(t,e,n,i){this.drawShape(t,e,n,i)}draw(t,e){t.leftHand&&this.drawHand(t.body.shoulders.width,t.leftHand,!0,e),t.rightHand&&this.drawHand(t.body.shoulders.width,t.rightHand,!1,e)}}return t.\u0275fac=function(e){return new(e||t)(Xi(Vct))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})(),Yct=(()=>{class t{constructor(t,e,n){this.hand=t,this.landmarks=e,this.poseImage=n}}return t.type="[SignWriting - Hands] Estimate Hand Shape",t})(),Kct=(()=>{class t{constructor(t,e){this.landmarks=t,this.poseImage=e}}return t.type="[SignWriting - Face] Estimate Face Shape",t})(),Jct=(()=>{class t{constructor(t){this.pose=t}}return t.type="[SignWriting - Body] Calculate Body Factors",t})();const Zct={timestamp:null,body:null,face:null,leftHand:null,rightHand:null};let tut=(()=>{let t=class{constructor(t,e,n){this.bodyService=t,this.faceService=e,this.handsService=n,this.drawSignWriting=!1}ngxsOnInit({patchState:t,dispatch:e}){this.drawSignWriting$.pipe(np(Boolean),bp(),xp(()=>{this.handsService.loadModel(),this.faceService.loadModel()})).subscribe(),this.drawSignWriting$.subscribe(t=>this.drawSignWriting=t),this.pose$.pipe(np(Boolean),np(()=>this.drawSignWriting),xp(n=>{e([new Jct(n),new Kct(n.faceLandmarks,n.image),new Yct("leftHand",n.leftHandLandmarks,n.image),new Yct("rightHand",n.rightHandLandmarks,n.image)]).subscribe(()=>t({timestamp:Date.now()}))})).subscribe(),this.pose$.pipe(np(Boolean),np(()=>!this.drawSignWriting),xp(e=>{t({timestamp:Date.now()})})).subscribe()}calculateBody({patchState:t},{pose:e}){return VI(this,void 0,void 0,function*(){t(e.poseLandmarks?{body:{shoulders:this.bodyService.shoulders(e.poseLandmarks),elbows:[e.poseLandmarks[nM.POSE_LANDMARKS.LEFT_ELBOW],e.poseLandmarks[nM.POSE_LANDMARKS.RIGHT_ELBOW]],wrists:[e.poseLandmarks[nM.POSE_LANDMARKS.LEFT_WRIST],e.poseLandmarks[nM.POSE_LANDMARKS.RIGHT_WRIST]]}}:{body:null})})}estimateFace({patchState:t},{landmarks:e,poseImage:n}){return VI(this,void 0,void 0,function*(){if(!e)return void t({face:null});const i=e.map(t=>new det(t.x*n.width,t.y*n.height,t.z*n.width));t({face:this.faceService.shape(i)})})}estimateHand({patchState:t},{hand:e,landmarks:n,poseImage:i}){return VI(this,void 0,void 0,function*(){if(!n)return void t({[e]:null});const r="leftHand"===e,s=n.map(t=>new det(t.x*i.width,t.y*i.height,t.z*i.width)),o=this.handsService.normal(s,r),a=this.handsService.plane(s);t({[e]:{bbox:this.handsService.bbox(s),normal:o,plane:a,rotation:this.handsService.rotation(s),direction:this.handsService.direction(a,o,r),shape:this.handsService.shape(s,o,r)}})})}};return t.\u0275fac=function(e){return new(e||t)(Xi(Wct),Xi(Qct),Xi(Xct))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),HI([UI(t=>t.pose.pose)],t.prototype,"pose$",void 0),HI([UI(t=>t.settings.drawSignWriting)],t.prototype,"drawSignWriting$",void 0),HI([$I(Jct)],t.prototype,"calculateBody",null),HI([$I(Kct)],t.prototype,"estimateFace",null),HI([$I(Yct)],t.prototype,"estimateHand",null),t=HI([zI({name:"signWriting",defaults:Zct})],t),t})(),eut=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({providers:[Xct,Wct,Qct],imports:[[FI.forFeature([tut])]]}),t})(),nut=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({providers:[],imports:[[FI.forFeature([jI]),eM,jS]]}),t})(),iut=(()=>{class t{constructor(t){this.pose=t}}return t.type="[Detector] Detect If Signing",t})(),rut=(()=>{class t{constructor(){this.shoulderWidth=new Float32Array(20).fill(0),this.shoulderWidthIndex=0}loadModel(){return Gj("assets/models/sign-detector/model.json").then(t=>this.sequentialModel=t)}distance(t,e){const n=t.x-e.x,i=t.y-e.y;return Math.sqrt(n*n+i*i)}normalizePose(t){const e=t.poseLandmarks||new Array(Object.keys(nM.POSE_LANDMARKS).length).fill(cM),n=t.leftHandLandmarks||new Array(21).fill(cM),i=t.leftHandLandmarks||new Array(21).fill(cM),r=e.concat(n,i).map(t=>this.isValidLandmark(t)?t:cM),s=r[nM.POSE_LANDMARKS.LEFT_SHOULDER],o=r[nM.POSE_LANDMARKS.RIGHT_SHOULDER];if(s.x>0&&o.x>0&&(this.shoulderWidth[this.shoulderWidthIndex%20]=this.distance(s,o),this.shoulderWidthIndex++),this.shoulderWidthIndex<20)return null;const a=this.shoulderWidth.reduce((t,e)=>t+e,0)/20,l=new Array(r.length);return r.forEach((t,e)=>{l[e]={x:t.x/a,y:t.y/a}}),[l[nM.POSE_LANDMARKS.NOSE],{x:(l[nM.POSE_LANDMARKS.LEFT_SHOULDER].x+l[nM.POSE_LANDMARKS.RIGHT_SHOULDER].x)/2,y:(l[nM.POSE_LANDMARKS.LEFT_SHOULDER].y+l[nM.POSE_LANDMARKS.RIGHT_SHOULDER].y)/2},l[nM.POSE_LANDMARKS.RIGHT_SHOULDER],l[nM.POSE_LANDMARKS.RIGHT_ELBOW],l[nM.POSE_LANDMARKS.RIGHT_WRIST],l[nM.POSE_LANDMARKS.LEFT_SHOULDER],l[nM.POSE_LANDMARKS.LEFT_ELBOW],l[nM.POSE_LANDMARKS.LEFT_WRIST],cM,cM,cM,cM,cM,cM,cM,l[nM.POSE_LANDMARKS.RIGHT_EYE],l[nM.POSE_LANDMARKS.LEFT_EYE],l[nM.POSE_LANDMARKS.RIGHT_EAR],l[nM.POSE_LANDMARKS.LEFT_EAR],cM,cM,cM,cM,cM,cM]}isValidLandmark(t){return t.x>.02&&t.x<.98&&t.y>.02&&t.y<.98}distance2DTensors(t,e,n=1){const i=new Float32Array(t.length).fill(0);for(let r=0;r<i.length;r+=1){const s=t[r],o=e[r];s.x>0&&o.x>0&&(i[r]=this.distance(s,o)*n)}return i}getSequentialConfidence(t){return _O(()=>{const e=this.sequentialModel.predict(OD(t).reshape([1,1,t.length]));return TF(e).dataSync()[1]})}detect(t){const e=performance.now()/1e3;let n=0;const i=this.normalizePose(t);if(this.lastPose&&i){const t=this.distance2DTensors(i,this.lastPose,1/(e-this.lastTimestamp));n=this.getSequentialConfidence(t)}return this.lastTimestamp=e,this.lastPose=i,n}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const sut={signingProbability:0,isSigning:!1};let out=(()=>{let t=class{constructor(t){this.detector=t,this.detectSign=!1}ngxsOnInit({dispatch:t}){this.detectSign$.pipe(np(Boolean),bp(),xp(()=>this.detector.loadModel())).subscribe(),this.detectSign$.subscribe(t=>this.detectSign=t),this.pose$.pipe(np(Boolean),np(()=>this.detectSign),xp(e=>t(new iut(e)))).subscribe()}detectSigning({patchState:t},{pose:e}){return VI(this,void 0,void 0,function*(){const n=yield this.detector.detect(e);t({signingProbability:n,isSigning:n>.5})})}};return t.\u0275fac=function(e){return new(e||t)(Xi(rut))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),HI([UI(t=>t.pose.pose)],t.prototype,"pose$",void 0),HI([UI(t=>t.settings.detectSign)],t.prototype,"detectSign$",void 0),HI([$I(iut)],t.prototype,"detectSigning",null),t=HI([zI({name:"detector",defaults:sut})],t),t})(),aut=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({providers:[rut],imports:[[FI.forFeature([out])]]}),t})(),lut=(()=>{class t{constructor(t){this.pose=t}}return t.type="[Animation] Get animation state from pose",t})();const cut=["mixamorigHead.quaternion","mixamorigNeck.quaternion","mixamorigSpine.quaternion","mixamorigSpine1.quaternion","mixamorigSpine2.quaternion","mixamorigHips.quaternion","mixamorigLeftUpLeg.quaternion","mixamorigLeftLeg.quaternion","mixamorigLeftToeBase.quaternion","mixamorigLeftFoot.quaternion","mixamorigLeftArm.quaternion","mixamorigLeftShoulder.quaternion","mixamorigLeftForeArm.quaternion","mixamorigRightUpLeg.quaternion","mixamorigRightLeg.quaternion","mixamorigRightToeBase.quaternion","mixamorigRightFoot.quaternion","mixamorigRightArm.quaternion","mixamorigRightShoulder.quaternion","mixamorigRightForeArm.quaternion","mixamorigLeftHand.quaternion","mixamorigLeftHandThumb1.quaternion","mixamorigLeftHandThumb2.quaternion","mixamorigLeftHandThumb3.quaternion","mixamorigLeftHandIndex1.quaternion","mixamorigLeftHandIndex2.quaternion","mixamorigLeftHandIndex3.quaternion","mixamorigLeftHandMiddle1.quaternion","mixamorigLeftHandMiddle2.quaternion","mixamorigLeftHandMiddle3.quaternion","mixamorigLeftHandRing1.quaternion","mixamorigLeftHandRing2.quaternion","mixamorigLeftHandRing3.quaternion","mixamorigLeftHandPinky1.quaternion","mixamorigLeftHandPinky2.quaternion","mixamorigLeftHandPinky3.quaternion","mixamorigRightHand.quaternion","mixamorigRightHandThumb1.quaternion","mixamorigRightHandThumb2.quaternion","mixamorigRightHandThumb3.quaternion","mixamorigRightHandIndex1.quaternion","mixamorigRightHandIndex2.quaternion","mixamorigRightHandIndex3.quaternion","mixamorigRightHandMiddle1.quaternion","mixamorigRightHandMiddle2.quaternion","mixamorigRightHandMiddle3.quaternion","mixamorigRightHandRing1.quaternion","mixamorigRightHandRing2.quaternion","mixamorigRightHandRing3.quaternion","mixamorigRightHandPinky1.quaternion","mixamorigRightHandPinky2.quaternion","mixamorigRightHandPinky3.quaternion"];let uut=(()=>{class t{loadModel(){return Gj("assets/models/pose-animation/model.json").then(t=>this.sequentialModel=t)}normalizePose(t){const e=t.poseLandmarks||new Array(Object.keys(nM.POSE_LANDMARKS).length).fill(cM),n=t.leftHandLandmarks||new Array(21).fill(cM),i=t.rightHandLandmarks||new Array(21).fill(cM),r=OD(e.concat(n,i).map(t=>[t.x,t.y,t.z])).mul(OD([t.image.width,t.image.height,t.image.width])),s=r.slice(nM.POSE_LANDMARKS.LEFT_SHOULDER,1),o=r.slice(nM.POSE_LANDMARKS.RIGHT_SHOULDER,1),a=RF(hF(o.sub(s),2).sum());let l=$P(r,s.add(o).div(2)).div(a);return l=l.mul(r.notEqual(0)),l}estimate(t){if(!this.sequentialModel)return null;const e=_O(()=>{const e=this.normalizePose(t).reshape([1,1,225]);return this.sequentialModel.predict(e).reshape([cut.length,4]).arraySync()}),n={};return cut.forEach((t,i)=>n[t]=e[i]),n}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const hut={tracks:null};let dut=(()=>{let t=class{constructor(t){this.animation=t,this.isAnimatePose=!1}ngxsOnInit({dispatch:t}){this.animatePose$.pipe(np(Boolean),bp(),xp(()=>this.animation.loadModel())).subscribe(),this.animatePose$.subscribe(t=>this.isAnimatePose=t),this.pose$.pipe(np(Boolean),np(()=>this.isAnimatePose),xp(e=>t(new lut(e)))).subscribe()}animatePose({patchState:t},{pose:e}){return VI(this,void 0,void 0,function*(){const n=yield this.animation.estimate(e);t({tracks:n})})}};return t.\u0275fac=function(e){return new(e||t)(Xi(uut))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),HI([UI(t=>t.pose.pose)],t.prototype,"pose$",void 0),HI([UI(t=>t.settings.animatePose)],t.prototype,"animatePose$",void 0),HI([$I(lut)],t.prototype,"animatePose",null),t=HI([zI({name:"animation",defaults:hut})],t),t})(),put=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({providers:[uut],imports:[[FI.forFeature([dut])]]}),t})(),fut=(()=>{class t{constructor(){this.ngUnsubscribe=new tt}ngOnDestroy(){this.ngUnsubscribe.next(),this.ngUnsubscribe.complete()}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=Se({type:t,selectors:[["app-base"]],decls:0,vars:0,template:function(t,e){},encapsulation:2}),t})(),mut=(()=>{class t extends fut{constructor(t){super(),this.store=t}applySetting(t,e){this.store.dispatch(new GI(t,e))}}return HI([UI(t=>t.settings)],t.prototype,"settingsState$",void 0),t})();function gut(t,e){if(1&t&&(ga(0,"mat-list-option",3),Ja(1),ya()),2&t){const t=e.$implicit,n=ka().$implicit;fa("value",t),Bs(1),Za(n(t))}}function yut(t,e){if(1&t){const t=xa();ga(0,"mat-selection-list",1),Ea("ngModelChange",function(e){return yn(t),ka().onSettingsChange(e)})("ngModelChange",function(e){return yn(t),ka().currentSettings=e}),ha(1,gut,2,2,"mat-list-option",2),ya()}if(2&t){const t=ka();fa("ngModel",t.currentSettings),Bs(1),fa("ngForOf",t.availableSettings)}}let vut=(()=>{class t extends mut{constructor(t){super(t),this.availableSettings=["detectSign","drawVideo","drawPose","drawSignWriting","animatePose"],this.lastSettings=[],this.currentSettings=[]}ngOnInit(){this.settingsState$.pipe(xp(t=>{this.currentSettings=this.lastSettings=this.availableSettings.filter(e=>t[e])}),Jx(this.ngUnsubscribe)).subscribe()}onSettingsChange(t){this.availableSettings.forEach(e=>{this.lastSettings.includes(e)&&!t.includes(e)?this.applySetting(e,!1):!this.lastSettings.includes(e)&&t.includes(e)&&this.applySetting(e,!0)})}}return t.\u0275fac=function(e){return new(e||t)(pa(RI))},t.\u0275cmp=Se({type:t,selectors:[["app-settings"]],features:[Ko],decls:1,vars:1,consts:[[3,"ngModel","ngModelChange",4,"transloco","translocoRead"],[3,"ngModel","ngModelChange"],[3,"value",4,"ngFor","ngForOf"],[3,"value"]],template:function(t,e){1&t&&ha(0,yut,2,2,"mat-selection-list",0),2&t&&fa("translocoRead","settings")},directives:[VT,cE,yS,zS,kh,lE],styles:[""]}),t})();var but=n("MZFn"),Aut=n.n(but);function xut(t){return new Promise(e=>setTimeout(e,t))}String(Math.random()).slice(2),window.trustedTypes&&trustedTypes.createPolicy("lit-html",{createHTML:t=>t});let wut=!1;(()=>{try{const t={get capture(){return wut=!0,!1}};window.addEventListener("test",t,t),window.removeEventListener("test",t,t)}catch(obt){}})(),"undefined"!=typeof window&&(window.litHtmlVersions||(window.litHtmlVersions=[])).push("1.3.0"),void 0===window.ShadyCSS||void 0===window.ShadyCSS.prepareTemplateDom&&console.warn("Incompatible ShadyCSS version detected. Please update to at least @webcomponents/webcomponentsjs@2.0.2 and @webcomponents/shadycss@1.3.1."),window.JSCompiler_renameProperty=(t,e)=>t;const _ut={toAttribute(t,e){switch(e){case Boolean:return t?"":null;case Object:case Array:return null==t?t:JSON.stringify(t)}return t},fromAttribute(t,e){switch(e){case Boolean:return null!==t;case Number:return null===t?null:Number(t);case Object:case Array:return JSON.parse(t)}return t}},Sut=(t,e)=>e!==t&&(e==e||t==t),Eut={attribute:!0,type:String,converter:_ut,reflect:!1,hasChanged:Sut};class Cut extends HTMLElement{constructor(){super(),this.initialize()}static get observedAttributes(){this.finalize();const t=[];return this._classProperties.forEach((e,n)=>{const i=this._attributeNameForProperty(n,e);void 0!==i&&(this._attributeToPropertyMap.set(i,n),t.push(i))}),t}static _ensureClassProperties(){if(!this.hasOwnProperty(JSCompiler_renameProperty("_classProperties",this))){this._classProperties=new Map;const t=Object.getPrototypeOf(this)._classProperties;void 0!==t&&t.forEach((t,e)=>this._classProperties.set(e,t))}}static createProperty(t,e=Eut){if(this._ensureClassProperties(),this._classProperties.set(t,e),e.noAccessor||this.prototype.hasOwnProperty(t))return;const n="symbol"==typeof t?Symbol():`__${t}`,i=this.getPropertyDescriptor(t,n,e);void 0!==i&&Object.defineProperty(this.prototype,t,i)}static getPropertyDescriptor(t,e,n){return{get(){return this[e]},set(i){const r=this[t];this[e]=i,this.requestUpdateInternal(t,r,n)},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this._classProperties&&this._classProperties.get(t)||Eut}static finalize(){const t=Object.getPrototypeOf(this);if(t.hasOwnProperty("finalized")||t.finalize(),this.finalized=!0,this._ensureClassProperties(),this._attributeToPropertyMap=new Map,this.hasOwnProperty(JSCompiler_renameProperty("properties",this))){const t=this.properties,e=[...Object.getOwnPropertyNames(t),..."function"==typeof Object.getOwnPropertySymbols?Object.getOwnPropertySymbols(t):[]];for(const n of e)this.createProperty(n,t[n])}}static _attributeNameForProperty(t,e){const n=e.attribute;return!1===n?void 0:"string"==typeof n?n:"string"==typeof t?t.toLowerCase():void 0}static _valueHasChanged(t,e,n=Sut){return n(t,e)}static _propertyValueFromAttribute(t,e){const n=e.converter||_ut,i="function"==typeof n?n:n.fromAttribute;return i?i(t,e.type):t}static _propertyValueToAttribute(t,e){if(void 0===e.reflect)return;const n=e.converter;return(n&&n.toAttribute||_ut.toAttribute)(t,e.type)}initialize(){this._updateState=0,this._updatePromise=new Promise(t=>this._enableUpdatingResolver=t),this._changedProperties=new Map,this._saveInstanceProperties(),this.requestUpdateInternal()}_saveInstanceProperties(){this.constructor._classProperties.forEach((t,e)=>{if(this.hasOwnProperty(e)){const t=this[e];delete this[e],this._instanceProperties||(this._instanceProperties=new Map),this._instanceProperties.set(e,t)}})}_applyInstanceProperties(){this._instanceProperties.forEach((t,e)=>this[e]=t),this._instanceProperties=void 0}connectedCallback(){this.enableUpdating()}enableUpdating(){void 0!==this._enableUpdatingResolver&&(this._enableUpdatingResolver(),this._enableUpdatingResolver=void 0)}disconnectedCallback(){}attributeChangedCallback(t,e,n){e!==n&&this._attributeToProperty(t,n)}_propertyToAttribute(t,e,n=Eut){const i=this.constructor,r=i._attributeNameForProperty(t,n);if(void 0!==r){const t=i._propertyValueToAttribute(e,n);if(void 0===t)return;this._updateState=8|this._updateState,null==t?this.removeAttribute(r):this.setAttribute(r,t),this._updateState=-9&this._updateState}}_attributeToProperty(t,e){if(8&this._updateState)return;const n=this.constructor,i=n._attributeToPropertyMap.get(t);if(void 0!==i){const t=n.getPropertyOptions(i);this._updateState=16|this._updateState,this[i]=n._propertyValueFromAttribute(e,t),this._updateState=-17&this._updateState}}requestUpdateInternal(t,e,n){let i=!0;if(void 0!==t){const r=this.constructor;n=n||r.getPropertyOptions(t),r._valueHasChanged(this[t],e,n.hasChanged)?(this._changedProperties.has(t)||this._changedProperties.set(t,e),!0!==n.reflect||16&this._updateState||(void 0===this._reflectingProperties&&(this._reflectingProperties=new Map),this._reflectingProperties.set(t,n))):i=!1}!this._hasRequestedUpdate&&i&&(this._updatePromise=this._enqueueUpdate())}requestUpdate(t,e){return this.requestUpdateInternal(t,e),this.updateComplete}async _enqueueUpdate(){this._updateState=4|this._updateState;try{await this._updatePromise}catch(t){}const t=this.performUpdate();return null!=t&&await t,!this._hasRequestedUpdate}get _hasRequestedUpdate(){return 4&this._updateState}get hasUpdated(){return 1&this._updateState}performUpdate(){if(!this._hasRequestedUpdate)return;this._instanceProperties&&this._applyInstanceProperties();let t=!1;const e=this._changedProperties;try{t=this.shouldUpdate(e),t?this.update(e):this._markUpdated()}catch(e){throw t=!1,this._markUpdated(),e}t&&(1&this._updateState||(this._updateState=1|this._updateState,this.firstUpdated(e)),this.updated(e))}_markUpdated(){this._changedProperties=new Map,this._updateState=-5&this._updateState}get updateComplete(){return this._getUpdateComplete()}_getUpdateComplete(){return this._updatePromise}shouldUpdate(t){return!0}update(t){void 0!==this._reflectingProperties&&this._reflectingProperties.size>0&&(this._reflectingProperties.forEach((t,e)=>this._propertyToAttribute(e,this[e],t)),this._reflectingProperties=void 0),this._markUpdated()}updated(t){}firstUpdated(t){}}Cut.finalized=!0;const Iut=(t,e)=>"method"===e.kind&&e.descriptor&&!("value"in e.descriptor)?Object.assign(Object.assign({},e),{finisher(n){n.createProperty(e.key,t)}}):{kind:"field",key:Symbol(),placement:"own",descriptor:{},initializer(){"function"==typeof e.initializer&&(this[e.key]=e.initializer.call(this))},finisher(n){n.createProperty(e.key,t)}};function Tut(t){return(e,n)=>void 0!==n?((t,e,n)=>{e.constructor.createProperty(n,t)})(t,e,n):Iut(t,e)}window.ShadowRoot&&(void 0===window.ShadyCSS||window.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&CSSStyleSheet,(window.litElementVersions||(window.litElementVersions=[])).push("2.4.0");const Mut=null!=navigator.xr&&null!=self.XRSession&&null!=navigator.xr.isSessionSupported,kut=Mut&&self.XRSession.prototype.requestHitTestSource,Rut=null!=self.ResizeObserver,Nut=null!=self.IntersectionObserver,Lut=kut;(()=>{const t=navigator.userAgent||navigator.vendor||self.opera;/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))})(),/\bCrOS\b/.test(navigator.userAgent);const Dut=/android/i.test(navigator.userAgent),But=/iPad|iPhone|iPod/.test(navigator.userAgent)&&!self.MSStream||"MacIntel"===navigator.platform&&navigator.maxTouchPoints>1,Out=(()=>{const t=document.createElement("a");return Boolean(t.relList&&t.relList.supports&&t.relList.supports("ar"))})();/Safari\//.test(navigator.userAgent);const Put=/firefox/i.test(navigator.userAgent),Fut=/OculusBrowser/.test(navigator.userAgent);But&&/CriOS\//.test(navigator.userAgent);const $ut=Dut&&!Put&&!Fut,zut=document.createElement("template");zut.innerHTML='\n<style>\n:host {\n  display: block;\n  position: relative;\n  contain: strict;\n  width: 300px;\n  height: 150px;\n}\n\n/* NOTE: This ruleset is our integration surface area with the\n * :focus-visible polyfill.\n *\n * @see https://github.com/WICG/focus-visible/pull/196 */\n:host([data-js-focus-visible]:focus:not(.focus-visible)),\n:host([data-js-focus-visible]) :focus:not(.focus-visible) {\n  outline: none;\n}\n\n.container {\n  position: relative;\n}\n\n.userInput {\n  width: 100%;\n  height: 100%;\n  display: block;\n  position: relative;\n  overflow: hidden;\n}\n\ncanvas {\n  position: absolute;\n  display: none;\n  pointer-events: none;\n  /* NOTE(cdata): Chrome 76 and below apparently have a bug\n   * that causes our canvas not to display pixels unless it is\n   * on its own render layer\n   * @see https://github.com/google/model-viewer/pull/755#issuecomment-536597893\n   */\n  transform: translateZ(0);\n}\n\ncanvas.show {\n  display: block;\n}\n\n/* Adapted from HTML5 Boilerplate\n *\n * @see https://github.com/h5bp/html5-boilerplate/blob/ceb4620c78fc82e13534fc44202a3f168754873f/dist/css/main.css#L122-L133 */\n.screen-reader-only {\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  white-space: nowrap;\n  width: 1px;\n}\n\n.slot {\n  position: absolute;\n  pointer-events: none;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\n.slot > * {\n  pointer-events: initial;\n}\n\n.annotation-wrapper ::slotted(*) {\n  opacity: var(--max-hotspot-opacity, 1);\n  transition: opacity 0.3s;\n}\n\n.pointer-tumbling .annotation-wrapper ::slotted(*) {\n  pointer-events: none;\n}\n\n.annotation-wrapper ::slotted(*) {\n  pointer-events: initial;\n}\n\n.annotation-wrapper.hide ::slotted(*) {\n  opacity: var(--min-hotspot-opacity, 0.25);\n}\n\n.slot.poster {\n  opacity: 0;\n  transition: opacity 0.3s 0.3s;\n  background-color: inherit;\n}\n\n.slot.poster.show {\n  opacity: 1;\n  transition: none;\n}\n\n.slot.poster > * {\n  pointer-events: initial;\n}\n\n.slot.poster:not(.show) > * {\n  pointer-events: none;\n}\n\n#default-poster {\n  width: 100%;\n  height: 100%;\n  /* The default poster is a <button> so we need to set display\n   * to prevent it from being affected by text-align: */\n  display: block;\n  position: absolute;\n  border: none;\n  padding: 0;\n  background-size: contain;\n  background-repeat: no-repeat;\n  background-position: center;\n  background-color: var(--poster-color, #fff);\n  background-image: var(--poster-image, none);\n}\n\n#default-progress-bar {\n  display: block;\n  position: relative;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  overflow: hidden;\n}\n\n#default-progress-bar > .mask {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: var(--progress-mask, #fff);\n  transition: opacity 0.3s;\n  opacity: 0.2;\n}\n\n#default-progress-bar > .bar {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: var(--progress-bar-height, 5px);\n  background-color: var(--progress-bar-color, rgba(0, 0, 0, 0.4));\n  transition: transform 0.09s;\n  transform-origin: top left;\n  transform: scaleX(0);\n  overflow: hidden;\n}\n\n#default-progress-bar > .bar.hide {\n  transition: opacity 0.3s 1s;\n  opacity: 0;\n}\n\n.slot.interaction-prompt {\n  display: var(--interaction-prompt-display, flex);\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  align-items: center;\n  justify-content: center;\n\n  opacity: 0;\n  will-change: opacity;\n  overflow: hidden;\n  transition: opacity 0.3s;\n}\n\n.slot.interaction-prompt.visible {\n  opacity: 1;\n}\n\n.slot.interaction-prompt > .animated-container {\n  will-change: transform, opacity;\n}\n\n.slot.interaction-prompt > * {\n  pointer-events: none;\n}\n\n.slot.ar-button {\n  -moz-user-select: none;\n  -webkit-tap-highlight-color: transparent;\n  user-select: none;\n\n  display: var(--ar-button-display, block);\n}\n\n.slot.ar-button:not(.enabled) {\n  display: none;\n}\n\n.fab {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  box-sizing: border-box;\n  width: 40px;\n  height: 40px;\n  cursor: pointer;\n  background-color: #fff;\n  box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.15);\n  border-radius: 100px;\n}\n\n.fab > * {\n  opacity: 0.87;\n}\n\n#default-ar-button {\n  position: absolute;\n  bottom: 16px;\n  right: 16px;\n  transform: scale(var(--ar-button-scale, 1));\n  transform-origin: bottom right;\n}\n\n.slot.default {\n  pointer-events: none;\n}\n\n.slot.progress-bar {\n  pointer-events: none;\n}\n\n.slot.exit-webxr-ar-button {\n  pointer-events: none;\n}\n\n.slot.exit-webxr-ar-button:not(.enabled) {\n  display: none;\n}\n\n#default-exit-webxr-ar-button {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: absolute;\n  top: 16px;\n  right: 16px;\n  width: 40px;\n  height: 40px;\n  box-sizing: border-box;\n}\n\n#default-exit-webxr-ar-button > svg {\n  fill: #fff;\n}\n</style>\n<div class="container">\n  <div class="userInput" tabindex="0" role="img"\n      aria-label="A depiction of a 3D model"\n      aria-live="polite">\n      <div class="slot canvas">\n        <slot name="canvas">\n          <canvas></canvas>\n        </slot>\n      </div>\n  </div>\n\n  \x3c!-- NOTE(cdata): We need to wrap slots because browsers without ShadowDOM\n        will have their <slot> elements removed by ShadyCSS --\x3e\n  <div class="slot poster">\n    <slot name="poster">\n      <button type="button" id="default-poster" aria-hidden="true" aria-label="Activate to view in 3D!"></button>\n    </slot>\n  </div>\n\n  <div class="slot ar-button">\n    <slot name="ar-button">\n      <a id="default-ar-button" part="default-ar-button" class="fab"\n          tabindex="2"\n          aria-label="View this 3D model up close">\n        \n<svg version="1.1" id="view_x5F_in_x5F_AR_x5F_icon"\n\t xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="24px" height="24px"\n\t viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve">\n<rect id="Bounding_Box" x="0" y="0" fill="none" width="24" height="24"/>\n<g id="Art_layer">\n\t<path d="M3,4c0-0.55,0.45-1,1-1h2V1H4C2.35,1,1,2.35,1,4v2h2V4z"/>\n\t<path d="M20,3c0.55,0,1,0.45,1,1v2h2V4c0-1.65-1.35-3-3-3h-2v2H20z"/>\n\t<path d="M4,21c-0.55,0-1-0.45-1-1v-2H1v2c0,1.65,1.35,3,3,3h2v-2H4z"/>\n\t<path d="M20,21c0.55,0,1-0.45,1-1v-2h2v2c0,1.65-1.35,3-3,3h-2v-2H20z"/>\n\t<g>\n\t\t<path d="M18.25,7.6l-5.5-3.18c-0.46-0.27-1.04-0.27-1.5,0L5.75,7.6C5.29,7.87,5,8.36,5,8.9v6.35c0,0.54,0.29,1.03,0.75,1.3\n\t\t\tl5.5,3.18c0.46,0.27,1.04,0.27,1.5,0l5.5-3.18c0.46-0.27,0.75-0.76,0.75-1.3V8.9C19,8.36,18.71,7.87,18.25,7.6z M7,14.96v-4.62\n\t\t\tl4,2.32v4.61L7,14.96z M12,10.93L8,8.61l4-2.31l4,2.31L12,10.93z M13,17.27v-4.61l4-2.32v4.62L13,17.27z"/>\n\t</g>\n</g>\n</svg>\n      </a>\n    </slot>\n  </div>\n\n  <div class="slot interaction-prompt">\n    <div class="animated-container">\n      <slot name="interaction-prompt" aria-hidden="true">\n        \n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="36">\n    <defs>\n        <path id="A" d="M.001.232h24.997V36H.001z" />\n    </defs>\n    <g transform="translate(-11 -4)" fill="none" fill-rule="evenodd">\n        <path fill-opacity="0" fill="#fff" d="M0 0h44v44H0z" />\n        <g transform="translate(11 3)">\n            <path d="M8.733 11.165c.04-1.108.766-2.027 1.743-2.307a2.54 2.54 0 0 1 .628-.089c.16 0 .314.017.463.044 1.088.2 1.9 1.092 1.9 2.16v8.88h1.26c2.943-1.39 5-4.45 5-8.025a9.01 9.01 0 0 0-1.9-5.56l-.43-.5c-.765-.838-1.683-1.522-2.712-2-1.057-.49-2.226-.77-3.46-.77s-2.4.278-3.46.77c-1.03.478-1.947 1.162-2.71 2l-.43.5a9.01 9.01 0 0 0-1.9 5.56 9.04 9.04 0 0 0 .094 1.305c.03.21.088.41.13.617l.136.624c.083.286.196.56.305.832l.124.333a8.78 8.78 0 0 0 .509.953l.065.122a8.69 8.69 0 0 0 3.521 3.191l1.11.537v-9.178z" fill-opacity=".5" fill="#e4e4e4" />\n            <path d="M22.94 26.218l-2.76 7.74c-.172.485-.676.8-1.253.8H12.24c-1.606 0-3.092-.68-3.98-1.82-1.592-2.048-3.647-3.822-6.11-5.27-.095-.055-.15-.137-.152-.23-.004-.1.046-.196.193-.297.56-.393 1.234-.6 1.926-.6a3.43 3.43 0 0 1 .691.069l4.922.994V10.972c0-.663.615-1.203 1.37-1.203s1.373.54 1.373 1.203v9.882h2.953c.273 0 .533.073.757.21l6.257 3.874c.027.017.045.042.07.06.41.296.586.77.426 1.22M4.1 16.614c-.024-.04-.042-.083-.065-.122a8.69 8.69 0 0 1-.509-.953c-.048-.107-.08-.223-.124-.333l-.305-.832c-.058-.202-.09-.416-.136-.624l-.13-.617a9.03 9.03 0 0 1-.094-1.305c0-2.107.714-4.04 1.9-5.56l.43-.5c.764-.84 1.682-1.523 2.71-2 1.058-.49 2.226-.77 3.46-.77s2.402.28 3.46.77c1.03.477 1.947 1.16 2.712 2l.428.5a9 9 0 0 1 1.901 5.559c0 3.577-2.056 6.636-5 8.026h-1.26v-8.882c0-1.067-.822-1.96-1.9-2.16-.15-.028-.304-.044-.463-.044-.22 0-.427.037-.628.09-.977.28-1.703 1.198-1.743 2.306v9.178l-1.11-.537C6.18 19.098 4.96 18 4.1 16.614M22.97 24.09l-6.256-3.874c-.102-.063-.218-.098-.33-.144 2.683-1.8 4.354-4.855 4.354-8.243 0-.486-.037-.964-.104-1.43a9.97 9.97 0 0 0-1.57-4.128l-.295-.408-.066-.092a10.05 10.05 0 0 0-.949-1.078c-.342-.334-.708-.643-1.094-.922-1.155-.834-2.492-1.412-3.94-1.65l-.732-.088-.748-.03a9.29 9.29 0 0 0-1.482.119c-1.447.238-2.786.816-3.94 1.65a9.33 9.33 0 0 0-.813.686 9.59 9.59 0 0 0-.845.877l-.385.437-.36.5-.288.468-.418.778-.04.09c-.593 1.28-.93 2.71-.93 4.222 0 3.832 2.182 7.342 5.56 8.938l1.437.68v4.946L5 25.64a4.44 4.44 0 0 0-.888-.086c-.017 0-.034.003-.05.003-.252.004-.503.033-.75.08a5.08 5.08 0 0 0-.237.056c-.193.046-.382.107-.568.18-.075.03-.15.057-.225.1-.25.114-.494.244-.723.405a1.31 1.31 0 0 0-.566 1.122 1.28 1.28 0 0 0 .645 1.051C4 29.925 5.96 31.614 7.473 33.563a5.06 5.06 0 0 0 .434.491c1.086 1.082 2.656 1.713 4.326 1.715h6.697c.748-.001 1.43-.333 1.858-.872.142-.18.256-.38.336-.602l2.757-7.74c.094-.26.13-.53.112-.794s-.088-.52-.203-.76a2.19 2.19 0 0 0-.821-.91" fill-opacity=".6" fill="#000" />\n            <path d="M22.444 24.94l-6.257-3.874a1.45 1.45 0 0 0-.757-.211h-2.953v-9.88c0-.663-.616-1.203-1.373-1.203s-1.37.54-1.37 1.203v16.643l-4.922-.994a3.44 3.44 0 0 0-.692-.069 3.35 3.35 0 0 0-1.925.598c-.147.102-.198.198-.194.298.004.094.058.176.153.23 2.462 1.448 4.517 3.22 6.11 5.27.887 1.14 2.373 1.82 3.98 1.82h6.686c.577 0 1.08-.326 1.253-.8l2.76-7.74c.16-.448-.017-.923-.426-1.22-.025-.02-.043-.043-.07-.06z" fill="#fff" />\n            <g transform="translate(0 .769)">\n                <mask id="B" fill="#fff">\n                    <use xlink:href="#A" />\n                </mask>\n                <path d="M23.993 24.992a1.96 1.96 0 0 1-.111.794l-2.758 7.74c-.08.22-.194.423-.336.602-.427.54-1.11.87-1.857.872h-6.698c-1.67-.002-3.24-.633-4.326-1.715-.154-.154-.3-.318-.434-.49C5.96 30.846 4 29.157 1.646 27.773c-.385-.225-.626-.618-.645-1.05a1.31 1.31 0 0 1 .566-1.122 4.56 4.56 0 0 1 .723-.405l.225-.1a4.3 4.3 0 0 1 .568-.18l.237-.056c.248-.046.5-.075.75-.08.018 0 .034-.003.05-.003.303-.001.597.027.89.086l3.722.752V20.68l-1.436-.68c-3.377-1.596-5.56-5.106-5.56-8.938 0-1.51.336-2.94.93-4.222.015-.03.025-.06.04-.09.127-.267.268-.525.418-.778.093-.16.186-.316.288-.468.063-.095.133-.186.2-.277L3.773 5c.118-.155.26-.29.385-.437.266-.3.544-.604.845-.877a9.33 9.33 0 0 1 .813-.686C6.97 2.167 8.31 1.59 9.757 1.35a9.27 9.27 0 0 1 1.481-.119 8.82 8.82 0 0 1 .748.031c.247.02.49.05.733.088 1.448.238 2.786.816 3.94 1.65.387.28.752.588 1.094.922a9.94 9.94 0 0 1 .949 1.078l.066.092c.102.133.203.268.295.408a9.97 9.97 0 0 1 1.571 4.128c.066.467.103.945.103 1.43 0 3.388-1.67 6.453-4.353 8.243.11.046.227.08.33.144l6.256 3.874c.37.23.645.55.82.9.115.24.185.498.203.76m.697-1.195c-.265-.55-.677-1.007-1.194-1.326l-5.323-3.297c2.255-2.037 3.564-4.97 3.564-8.114 0-2.19-.637-4.304-1.84-6.114-.126-.188-.26-.37-.4-.552-.645-.848-1.402-1.6-2.252-2.204C15.472.91 13.393.232 11.238.232A10.21 10.21 0 0 0 5.23 2.19c-.848.614-1.606 1.356-2.253 2.205-.136.18-.272.363-.398.55C1.374 6.756.737 8.87.737 11.06c0 4.218 2.407 8.08 6.133 9.842l.863.41v3.092l-2.525-.51c-.356-.07-.717-.106-1.076-.106a5.45 5.45 0 0 0-3.14.996c-.653.46-1.022 1.202-.99 1.983a2.28 2.28 0 0 0 1.138 1.872c2.24 1.318 4.106 2.923 5.543 4.772 1.26 1.62 3.333 2.59 5.55 2.592h6.698c1.42-.001 2.68-.86 3.134-2.138l2.76-7.74c.272-.757.224-1.584-.134-2.325" fill-opacity=".05" fill="#000" mask="url(#B)" />\n            </g>\n        </g>\n    </g>\n</svg>\n      </slot>\n    </div>\n  </div>\n\n  <div class="slot default">\n    <slot></slot>\n\n    <div class="slot progress-bar">\n      <slot name="progress-bar">\n        <div id="default-progress-bar" aria-hidden="true">\n          <div class="mask" part="default-progress-mask"></div>\n          <div class="bar" part="default-progress-bar"></div>\n        </div>\n      </slot>\n    </div>\n    \n    <div class="slot exit-webxr-ar-button">\n      <slot name="exit-webxr-ar-button">\n        <a id="default-exit-webxr-ar-button" part="default-exit-webxr-ar-button"\n            tabindex="3"\n            aria-label="Exit AR"\n            aria-hidden="true">\n          \n<svg xmlns="http://www.w3.org/2000/svg" width="24px" height="24px" viewBox="0 0 24 24" fill="#000000">\n    \x3c!-- NOTE(cdata): This SVG filter is a stop-gap until we can implement\n         support for dynamic re-coloring of UI components --\x3e\n    <defs>\n      <filter id="drop-shadow" x="-100%" y="-100%" width="300%" height="300%">\n        <feGaussianBlur in="SourceAlpha" stdDeviation="1"/>\n        <feOffset dx="0" dy="0" result="offsetblur"/>\n        <feFlood flood-color="#000000"/>\n        <feComposite in2="offsetblur" operator="in"/>\n        <feMerge>\n          <feMergeNode/>\n          <feMergeNode in="SourceGraphic"/>\n        </feMerge>\n      </filter>\n    </defs>\n    <path filter="url(#drop-shadow)" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>\n        </a>\n      </slot>\n    </div>\n  </div>\n</div>';class Uut{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[t]&&(n[t]=[]),-1===n[t].indexOf(e)&&n[t].push(e)}hasEventListener(t,e){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[t]&&-1!==n[t].indexOf(e)}removeEventListener(t,e){if(void 0===this._listeners)return;const n=this._listeners[t];if(void 0!==n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}dispatchEvent(t){if(void 0===this._listeners)return;const e=this._listeners[t.type];if(void 0!==e){t.target=this;const n=e.slice(0);for(let e=0,i=n.length;e<i;e++)n[e].call(this,t);t.target=null}}}const Hut=[];for(let Set=0;Set<256;Set++)Hut[Set]=(Set<16?"0":"")+Set.toString(16);let Vut=1234567;const Gut=Math.PI/180,Wut=180/Math.PI;function jut(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,n=4294967295*Math.random()|0,i=4294967295*Math.random()|0;return(Hut[255&t]+Hut[t>>8&255]+Hut[t>>16&255]+Hut[t>>24&255]+"-"+Hut[255&e]+Hut[e>>8&255]+"-"+Hut[e>>16&15|64]+Hut[e>>24&255]+"-"+Hut[63&n|128]+Hut[n>>8&255]+"-"+Hut[n>>16&255]+Hut[n>>24&255]+Hut[255&i]+Hut[i>>8&255]+Hut[i>>16&255]+Hut[i>>24&255]).toUpperCase()}function Qut(t,e,n){return Math.max(e,Math.min(n,t))}function qut(t,e){return(t%e+e)%e}function Xut(t,e,n){return(1-n)*t+n*e}function Yut(t){return 0==(t&t-1)&&0!==t}function Kut(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))}function Jut(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))}var Zut=Object.freeze({__proto__:null,DEG2RAD:Gut,RAD2DEG:Wut,generateUUID:jut,clamp:Qut,euclideanModulo:qut,mapLinear:function(t,e,n,i,r){return i+(t-e)*(r-i)/(n-e)},inverseLerp:function(t,e,n){return t!==e?(n-t)/(e-t):0},lerp:Xut,damp:function(t,e,n,i){return Xut(t,e,1-Math.exp(-n*i))},pingpong:function(t,e=1){return e-Math.abs(qut(t,2*e)-e)},smoothstep:function(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*(3-2*t)},smootherstep:function(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*t*(t*(6*t-15)+10)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},seededRandom:function(t){return void 0!==t&&(Vut=t%2147483647),Vut=16807*Vut%2147483647,(Vut-1)/2147483646},degToRad:function(t){return t*Gut},radToDeg:function(t){return t*Wut},isPowerOfTwo:Yut,ceilPowerOfTwo:Kut,floorPowerOfTwo:Jut,setQuaternionFromProperEuler:function(t,e,n,i,r){const s=Math.cos,o=Math.sin,a=s(n/2),l=o(n/2),c=s((e+i)/2),u=o((e+i)/2),h=s((e-i)/2),d=o((e-i)/2),p=s((i-e)/2),f=o((i-e)/2);switch(r){case"XYX":t.set(a*u,l*h,l*d,a*c);break;case"YZY":t.set(l*d,a*u,l*h,a*c);break;case"ZXZ":t.set(l*h,l*d,a*u,a*c);break;case"XZX":t.set(a*u,l*f,l*p,a*c);break;case"YXY":t.set(l*p,a*u,l*f,a*c);break;case"ZYZ":t.set(l*f,l*p,a*u,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}}});class tht{constructor(t=0,e=0){this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6],this.y=i[1]*e+i[4]*n+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),i=Math.sin(e),r=this.x-t.x,s=this.y-t.y;return this.x=r*n-s*i+t.x,this.y=r*i+s*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}tht.prototype.isVector2=!0;class eht{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,r,s,o,a,l){const c=this.elements;return c[0]=t,c[1]=i,c[2]=o,c[3]=e,c[4]=r,c[5]=a,c[6]=n,c[7]=s,c[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,s=n[0],o=n[3],a=n[6],l=n[1],c=n[4],u=n[7],h=n[2],d=n[5],p=n[8],f=i[0],m=i[3],g=i[6],y=i[1],v=i[4],b=i[7],A=i[2],x=i[5],w=i[8];return r[0]=s*f+o*y+a*A,r[3]=s*m+o*v+a*x,r[6]=s*g+o*b+a*w,r[1]=l*f+c*y+u*A,r[4]=l*m+c*v+u*x,r[7]=l*g+c*b+u*w,r[2]=h*f+d*y+p*A,r[5]=h*m+d*v+p*x,r[8]=h*g+d*b+p*w,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],o=t[5],a=t[6],l=t[7],c=t[8];return e*s*c-e*o*l-n*r*c+n*o*a+i*r*l-i*s*a}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],o=t[5],a=t[6],l=t[7],c=t[8],u=c*s-o*l,h=o*a-c*r,d=l*r-s*a,p=e*u+n*h+i*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const f=1/p;return t[0]=u*f,t[1]=(i*l-c*n)*f,t[2]=(o*n-i*s)*f,t[3]=h*f,t[4]=(c*e-i*a)*f,t[5]=(i*r-o*e)*f,t[6]=d*f,t[7]=(n*a-l*e)*f,t[8]=(s*e-n*r)*f,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,i,r,s,o){const a=Math.cos(r),l=Math.sin(r);return this.set(n*a,n*l,-n*(a*s+l*o)+s+t,-i*l,i*a,-i*(-l*s+a*o)+o+e,0,0,1),this}scale(t,e){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=e,n[4]*=e,n[7]*=e,this}rotate(t){const e=Math.cos(t),n=Math.sin(t),i=this.elements,r=i[0],s=i[3],o=i[6],a=i[1],l=i[4],c=i[7];return i[0]=e*r+n*a,i[3]=e*s+n*l,i[6]=e*o+n*c,i[1]=-n*r+e*a,i[4]=-n*s+e*l,i[7]=-n*o+e*c,this}translate(t,e){const n=this.elements;return n[0]+=t*n[2],n[3]+=t*n[5],n[6]+=t*n[8],n[1]+=e*n[2],n[4]+=e*n[5],n[7]+=e*n[8],this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<9;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return(new this.constructor).fromArray(this.elements)}}let nht;eht.prototype.isMatrix3=!0;class iht{static getDataURL(t){if(/^data:/i.test(t.src))return t.src;if("undefined"==typeof HTMLCanvasElement)return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{void 0===nht&&(nht=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),nht.width=t.width,nht.height=t.height;const n=nht.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=nht}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}}let rht=0;class sht extends Uut{constructor(t=sht.DEFAULT_IMAGE,e=sht.DEFAULT_MAPPING,n=1001,i=1001,r=1006,s=1008,o=1023,a=1009,l=1,c=3e3){super(),Object.defineProperty(this,"id",{value:rht++}),this.uuid=jut(),this.name="",this.image=t,this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=i,this.magFilter=r,this.minFilter=s,this.anisotropy=l,this.format=o,this.internalFormat=null,this.type=a,this.offset=new tht(0,0),this.repeat=new tht(1,1),this.center=new tht(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new eht,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.version=0,this.onUpdate=null}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(t){return this.name=t.name,this.image=t.image,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(void 0!==this.image){const i=this.image;if(void 0===i.uuid&&(i.uuid=jut()),!e&&void 0===t.images[i.uuid]){let e;if(Array.isArray(i)){e=[];for(let t=0,n=i.length;t<n;t++)e.push(oht(i[t].isDataTexture?i[t].image:i[t]))}else e=oht(i);t.images[i.uuid]={uuid:i.uuid,url:e}}n.image=i.uuid}return e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(300!==this.mapping)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case 1e3:t.x=t.x-Math.floor(t.x);break;case 1001:t.x=t.x<0?0:1;break;case 1002:t.x=1===Math.abs(Math.floor(t.x)%2)?Math.ceil(t.x)-t.x:t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case 1e3:t.y=t.y-Math.floor(t.y);break;case 1001:t.y=t.y<0?0:1;break;case 1002:t.y=1===Math.abs(Math.floor(t.y)%2)?Math.ceil(t.y)-t.y:t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){!0===t&&this.version++}}function oht(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?iht.getDataURL(t):t.data?{data:Array.prototype.slice.call(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}sht.DEFAULT_IMAGE=void 0,sht.DEFAULT_MAPPING=300,sht.prototype.isTexture=!0;class aht{constructor(t=0,e=0,n=0,i=1){this.x=t,this.y=e,this.z=n,this.w=i}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,i){return this.x=t,this.y=e,this.z=n,this.w=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=this.w,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*i+s[12]*r,this.y=s[1]*e+s[5]*n+s[9]*i+s[13]*r,this.z=s[2]*e+s[6]*n+s[10]*i+s[14]*r,this.w=s[3]*e+s[7]*n+s[11]*i+s[15]*r,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,i,r;const s=.01,o=.1,a=t.elements,l=a[0],c=a[4],u=a[8],h=a[1],d=a[5],p=a[9],f=a[2],m=a[6],g=a[10];if(Math.abs(c-h)<s&&Math.abs(u-f)<s&&Math.abs(p-m)<s){if(Math.abs(c+h)<o&&Math.abs(u+f)<o&&Math.abs(p+m)<o&&Math.abs(l+d+g-3)<o)return this.set(1,0,0,0),this;e=Math.PI;const t=(l+1)/2,a=(d+1)/2,y=(g+1)/2,v=(c+h)/4,b=(u+f)/4,A=(p+m)/4;return t>a&&t>y?t<s?(n=0,i=.707106781,r=.707106781):(n=Math.sqrt(t),i=v/n,r=b/n):a>y?a<s?(n=.707106781,i=0,r=.707106781):(i=Math.sqrt(a),n=v/i,r=A/i):y<s?(n=.707106781,i=.707106781,r=0):(r=Math.sqrt(y),n=b/r,i=A/r),this.set(n,i,r,e),this}let y=Math.sqrt((m-p)*(m-p)+(u-f)*(u-f)+(h-c)*(h-c));return Math.abs(y)<.001&&(y=1),this.x=(m-p)/y,this.y=(u-f)/y,this.z=(h-c)/y,this.w=Math.acos((l+d+g-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}aht.prototype.isVector4=!0;class lht extends Uut{constructor(t,e,n){super(),this.width=t,this.height=e,this.depth=1,this.scissor=new aht(0,0,t,e),this.scissorTest=!1,this.viewport=new aht(0,0,t,e),this.texture=new sht(void 0,(n=n||{}).mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.image={},this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=1,this.texture.generateMipmaps=void 0!==n.generateMipmaps&&n.generateMipmaps,this.texture.minFilter=void 0!==n.minFilter?n.minFilter:1006,this.depthBuffer=void 0===n.depthBuffer||n.depthBuffer,this.stencilBuffer=void 0!==n.stencilBuffer&&n.stencilBuffer,this.depthTexture=void 0!==n.depthTexture?n.depthTexture:null}setTexture(t){t.image={width:this.width,height:this.height,depth:this.depth},this.texture=t}setSize(t,e,n=1){this.width===t&&this.height===e&&this.depth===n||(this.width=t,this.height=e,this.depth=n,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return(new this.constructor).copy(this)}copy(t){return this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}lht.prototype.isWebGLRenderTarget=!0;class cht{constructor(t=0,e=0,n=0,i=1){this._x=t,this._y=e,this._z=n,this._w=i}static slerp(t,e,n,i){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(t,e,i)}static slerpFlat(t,e,n,i,r,s,o){let a=n[i+0],l=n[i+1],c=n[i+2],u=n[i+3];const h=r[s+0],d=r[s+1],p=r[s+2],f=r[s+3];if(0===o)return t[e+0]=a,t[e+1]=l,t[e+2]=c,void(t[e+3]=u);if(1===o)return t[e+0]=h,t[e+1]=d,t[e+2]=p,void(t[e+3]=f);if(u!==f||a!==h||l!==d||c!==p){let t=1-o;const e=a*h+l*d+c*p+u*f,n=e>=0?1:-1,i=1-e*e;if(i>Number.EPSILON){const r=Math.sqrt(i),s=Math.atan2(r,e*n);t=Math.sin(t*s)/r,o=Math.sin(o*s)/r}const r=o*n;if(a=a*t+h*r,l=l*t+d*r,c=c*t+p*r,u=u*t+f*r,t===1-o){const t=1/Math.sqrt(a*a+l*l+c*c+u*u);a*=t,l*=t,c*=t,u*=t}}t[e]=a,t[e+1]=l,t[e+2]=c,t[e+3]=u}static multiplyQuaternionsFlat(t,e,n,i,r,s){const o=n[i],a=n[i+1],l=n[i+2],c=n[i+3],u=r[s],h=r[s+1],d=r[s+2],p=r[s+3];return t[e]=o*p+c*u+a*d-l*h,t[e+1]=a*p+c*h+l*u-o*d,t[e+2]=l*p+c*d+o*h-a*u,t[e+3]=c*p-o*u-a*h-l*d,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!t||!t.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=t._x,i=t._y,r=t._z,s=t._order,o=Math.cos,a=Math.sin,l=o(n/2),c=o(i/2),u=o(r/2),h=a(n/2),d=a(i/2),p=a(r/2);switch(s){case"XYZ":this._x=h*c*u+l*d*p,this._y=l*d*u-h*c*p,this._z=l*c*p+h*d*u,this._w=l*c*u-h*d*p;break;case"YXZ":this._x=h*c*u+l*d*p,this._y=l*d*u-h*c*p,this._z=l*c*p-h*d*u,this._w=l*c*u+h*d*p;break;case"ZXY":this._x=h*c*u-l*d*p,this._y=l*d*u+h*c*p,this._z=l*c*p+h*d*u,this._w=l*c*u-h*d*p;break;case"ZYX":this._x=h*c*u-l*d*p,this._y=l*d*u+h*c*p,this._z=l*c*p-h*d*u,this._w=l*c*u+h*d*p;break;case"YZX":this._x=h*c*u+l*d*p,this._y=l*d*u+h*c*p,this._z=l*c*p-h*d*u,this._w=l*c*u-h*d*p;break;case"XZY":this._x=h*c*u-l*d*p,this._y=l*d*u-h*c*p,this._z=l*c*p+h*d*u,this._w=l*c*u+h*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return!1!==e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,i=Math.sin(n);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],i=e[4],r=e[8],s=e[1],o=e[5],a=e[9],l=e[2],c=e[6],u=e[10],h=n+o+u;if(h>0){const t=.5/Math.sqrt(h+1);this._w=.25/t,this._x=(c-a)*t,this._y=(r-l)*t,this._z=(s-i)*t}else if(n>o&&n>u){const t=2*Math.sqrt(1+n-o-u);this._w=(c-a)/t,this._x=.25*t,this._y=(i+s)/t,this._z=(r+l)/t}else if(o>u){const t=2*Math.sqrt(1+o-n-u);this._w=(r-l)/t,this._x=(i+s)/t,this._y=.25*t,this._z=(a+c)/t}else{const t=2*Math.sqrt(1+u-n-o);this._w=(s-i)/t,this._x=(r+l)/t,this._y=(a+c)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(Qut(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(0===n)return this;const i=Math.min(1,e/n);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return void 0!==e?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,i=t._y,r=t._z,s=t._w,o=e._x,a=e._y,l=e._z,c=e._w;return this._x=n*c+s*o+i*l-r*a,this._y=i*c+s*a+r*o-n*l,this._z=r*c+s*l+n*a-i*o,this._w=s*c-n*o-i*a-r*l,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);const n=this._x,i=this._y,r=this._z,s=this._w;let o=s*t._w+n*t._x+i*t._y+r*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=s,this._x=n,this._y=i,this._z=r,this;const a=1-o*o;if(a<=Number.EPSILON){const t=1-e;return this._w=t*s+e*this._w,this._x=t*n+e*this._x,this._y=t*i+e*this._y,this._z=t*r+e*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(a),c=Math.atan2(l,o),u=Math.sin((1-e)*c)/l,h=Math.sin(e*c)/l;return this._w=s*u+this._w*h,this._x=n*u+this._x*h,this._y=i*u+this._y*h,this._z=r*u+this._z*h,this._onChangeCallback(),this}slerpQuaternions(t,e,n){this.copy(t).slerp(e,n)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}cht.prototype.isQuaternion=!0;class uht{constructor(t=0,e=0,n=0){this.x=t,this.y=e,this.z=n}set(t,e,n){return void 0===n&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(dht.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(dht.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6]*i,this.y=r[1]*e+r[4]*n+r[7]*i,this.z=r[2]*e+r[5]*n+r[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=t.elements,s=1/(r[3]*e+r[7]*n+r[11]*i+r[15]);return this.x=(r[0]*e+r[4]*n+r[8]*i+r[12])*s,this.y=(r[1]*e+r[5]*n+r[9]*i+r[13])*s,this.z=(r[2]*e+r[6]*n+r[10]*i+r[14])*s,this}applyQuaternion(t){const e=this.x,n=this.y,i=this.z,r=t.x,s=t.y,o=t.z,a=t.w,l=a*e+s*i-o*n,c=a*n+o*e-r*i,u=a*i+r*n-s*e,h=-r*e-s*n-o*i;return this.x=l*a+h*-r+c*-o-u*-s,this.y=c*a+h*-s+u*-r-l*-o,this.z=u*a+h*-o+l*-s-c*-r,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[4]*n+r[8]*i,this.y=r[1]*e+r[5]*n+r[9]*i,this.z=r[2]*e+r[6]*n+r[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t,e){return void 0!==e?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,i=t.y,r=t.z,s=e.x,o=e.y,a=e.z;return this.x=i*a-r*o,this.y=r*s-n*a,this.z=n*o-i*s,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return hht.copy(this).projectOnVector(t),this.sub(hht)}reflect(t){return this.sub(hht.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(Qut(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return e*e+n*n+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const i=Math.sin(e)*t;return this.x=i*Math.sin(n),this.y=Math.cos(e)*t,this.z=i*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}uht.prototype.isVector3=!0;const hht=new uht,dht=new cht;class pht{constructor(t=new uht(1/0,1/0,1/0),e=new uht(-1/0,-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,n=1/0,i=1/0,r=-1/0,s=-1/0,o=-1/0;for(let a=0,l=t.length;a<l;a+=3){const l=t[a],c=t[a+1],u=t[a+2];l<e&&(e=l),c<n&&(n=c),u<i&&(i=u),l>r&&(r=l),c>s&&(s=c),u>o&&(o=u)}return this.min.set(e,n,i),this.max.set(r,s,o),this}setFromBufferAttribute(t){let e=1/0,n=1/0,i=1/0,r=-1/0,s=-1/0,o=-1/0;for(let a=0,l=t.count;a<l;a++){const l=t.getX(a),c=t.getY(a),u=t.getZ(a);l<e&&(e=l),c<n&&(n=c),u<i&&(i=u),l>r&&(r=l),c>s&&(s=c),u>o&&(o=u)}return this.min.set(e,n,i),this.max.set(r,s,o),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=mht.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t){return this.makeEmpty(),this.expandByObject(t)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return void 0===t&&(console.warn("THREE.Box3: .getCenter() target is now required"),t=new uht),this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return void 0===t&&(console.warn("THREE.Box3: .getSize() target is now required"),t=new uht),this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){t.updateWorldMatrix(!1,!1);const e=t.geometry;void 0!==e&&(null===e.boundingBox&&e.computeBoundingBox(),ght.copy(e.boundingBox),ght.applyMatrix4(t.matrixWorld),this.union(ght));const n=t.children;for(let i=0,r=n.length;i<r;i++)this.expandByObject(n[i]);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return void 0===e&&(console.warn("THREE.Box3: .getParameter() target is now required"),e=new uht),e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,mht),mht.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(_ht),Sht.subVectors(this.max,_ht),yht.subVectors(t.a,_ht),vht.subVectors(t.b,_ht),bht.subVectors(t.c,_ht),Aht.subVectors(vht,yht),xht.subVectors(bht,vht),wht.subVectors(yht,bht);let e=[0,-Aht.z,Aht.y,0,-xht.z,xht.y,0,-wht.z,wht.y,Aht.z,0,-Aht.x,xht.z,0,-xht.x,wht.z,0,-wht.x,-Aht.y,Aht.x,0,-xht.y,xht.x,0,-wht.y,wht.x,0];return!!Iht(e,yht,vht,bht,Sht)&&(e=[1,0,0,0,1,0,0,0,1],!!Iht(e,yht,vht,bht,Sht)&&(Eht.crossVectors(Aht,xht),e=[Eht.x,Eht.y,Eht.z],Iht(e,yht,vht,bht,Sht)))}clampPoint(t,e){return void 0===e&&(console.warn("THREE.Box3: .clampPoint() target is now required"),e=new uht),e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return mht.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return void 0===t&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(t.center),t.radius=.5*this.getSize(mht).length(),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(fht[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),fht[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),fht[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),fht[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),fht[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),fht[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),fht[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),fht[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(fht)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}pht.prototype.isBox3=!0;const fht=[new uht,new uht,new uht,new uht,new uht,new uht,new uht,new uht],mht=new uht,ght=new pht,yht=new uht,vht=new uht,bht=new uht,Aht=new uht,xht=new uht,wht=new uht,_ht=new uht,Sht=new uht,Eht=new uht,Cht=new uht;function Iht(t,e,n,i,r){for(let s=0,o=t.length-3;s<=o;s+=3){Cht.fromArray(t,s);const o=r.x*Math.abs(Cht.x)+r.y*Math.abs(Cht.y)+r.z*Math.abs(Cht.z),a=e.dot(Cht),l=n.dot(Cht),c=i.dot(Cht);if(Math.max(-Math.max(a,l,c),Math.min(a,l,c))>o)return!1}return!0}const Tht=new pht,Mht=new uht,kht=new uht,Rht=new uht;class Nht{constructor(t=new uht,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;void 0!==e?n.copy(e):Tht.setFromPoints(t).getCenter(n);let i=0;for(let r=0,s=t.length;r<s;r++)i=Math.max(i,n.distanceToSquared(t[r]));return this.radius=Math.sqrt(i),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return void 0===e&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),e=new uht),e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return void 0===t&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),t=new pht),this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){Rht.subVectors(t,this.center);const e=Rht.lengthSq();if(e>this.radius*this.radius){const t=Math.sqrt(e),n=.5*(t-this.radius);this.center.add(Rht.multiplyScalar(n/t)),this.radius+=n}return this}union(t){return kht.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(Mht.copy(t.center).add(kht)),this.expandByPoint(Mht.copy(t.center).sub(kht)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return(new this.constructor).copy(this)}}const Lht=new uht,Dht=new uht,Bht=new uht,Oht=new uht,Pht=new uht,Fht=new uht,$ht=new uht;class zht{constructor(t=new uht,e=new uht(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return void 0===e&&(console.warn("THREE.Ray: .at() target is now required"),e=new uht),e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,Lht)),this}closestPointToPoint(t,e){void 0===e&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),e=new uht),e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=Lht.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(Lht.copy(this.direction).multiplyScalar(e).add(this.origin),Lht.distanceToSquared(t))}distanceSqToSegment(t,e,n,i){Dht.copy(t).add(e).multiplyScalar(.5),Bht.copy(e).sub(t).normalize(),Oht.copy(this.origin).sub(Dht);const r=.5*t.distanceTo(e),s=-this.direction.dot(Bht),o=Oht.dot(this.direction),a=-Oht.dot(Bht),l=Oht.lengthSq(),c=Math.abs(1-s*s);let u,h,d,p;if(c>0)if(u=s*a-o,h=s*o-a,p=r*c,u>=0)if(h>=-p)if(h<=p){const t=1/c;u*=t,h*=t,d=u*(u+s*h+2*o)+h*(s*u+h+2*a)+l}else h=r,u=Math.max(0,-(s*h+o)),d=-u*u+h*(h+2*a)+l;else h=-r,u=Math.max(0,-(s*h+o)),d=-u*u+h*(h+2*a)+l;else h<=-p?(u=Math.max(0,-(-s*r+o)),h=u>0?-r:Math.min(Math.max(-r,-a),r),d=-u*u+h*(h+2*a)+l):h<=p?(u=0,h=Math.min(Math.max(-r,-a),r),d=h*(h+2*a)+l):(u=Math.max(0,-(s*r+o)),h=u>0?r:Math.min(Math.max(-r,-a),r),d=-u*u+h*(h+2*a)+l);else h=s>0?-r:r,u=Math.max(0,-(s*h+o)),d=-u*u+h*(h+2*a)+l;return n&&n.copy(this.direction).multiplyScalar(u).add(this.origin),i&&i.copy(Bht).multiplyScalar(h).add(Dht),d}intersectSphere(t,e){Lht.subVectors(t.center,this.origin);const n=Lht.dot(this.direction),i=Lht.dot(Lht)-n*n,r=t.radius*t.radius;if(i>r)return null;const s=Math.sqrt(r-i),o=n-s,a=n+s;return o<0&&a<0?null:this.at(o<0?a:o,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(0===e)return 0===t.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return null===n?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return 0===e||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,i,r,s,o,a;const l=1/this.direction.x,c=1/this.direction.y,u=1/this.direction.z,h=this.origin;return l>=0?(n=(t.min.x-h.x)*l,i=(t.max.x-h.x)*l):(n=(t.max.x-h.x)*l,i=(t.min.x-h.x)*l),c>=0?(r=(t.min.y-h.y)*c,s=(t.max.y-h.y)*c):(r=(t.max.y-h.y)*c,s=(t.min.y-h.y)*c),n>s||r>i?null:((r>n||n!=n)&&(n=r),(s<i||i!=i)&&(i=s),u>=0?(o=(t.min.z-h.z)*u,a=(t.max.z-h.z)*u):(o=(t.max.z-h.z)*u,a=(t.min.z-h.z)*u),n>a||o>i?null:((o>n||n!=n)&&(n=o),(a<i||i!=i)&&(i=a),i<0?null:this.at(n>=0?n:i,e)))}intersectsBox(t){return null!==this.intersectBox(t,Lht)}intersectTriangle(t,e,n,i,r){Pht.subVectors(e,t),Fht.subVectors(n,t),$ht.crossVectors(Pht,Fht);let s,o=this.direction.dot($ht);if(o>0){if(i)return null;s=1}else{if(!(o<0))return null;s=-1,o=-o}Oht.subVectors(this.origin,t);const a=s*this.direction.dot(Fht.crossVectors(Oht,Fht));if(a<0)return null;const l=s*this.direction.dot(Pht.cross(Oht));if(l<0)return null;if(a+l>o)return null;const c=-s*Oht.dot($ht);return c<0?null:this.at(c/o,r)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class Uht{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,r,s,o,a,l,c,u,h,d,p,f,m){const g=this.elements;return g[0]=t,g[4]=e,g[8]=n,g[12]=i,g[1]=r,g[5]=s,g[9]=o,g[13]=a,g[2]=l,g[6]=c,g[10]=u,g[14]=h,g[3]=d,g[7]=p,g[11]=f,g[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new Uht).fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,i=1/Hht.setFromMatrixColumn(t,0).length(),r=1/Hht.setFromMatrixColumn(t,1).length(),s=1/Hht.setFromMatrixColumn(t,2).length();return e[0]=n[0]*i,e[1]=n[1]*i,e[2]=n[2]*i,e[3]=0,e[4]=n[4]*r,e[5]=n[5]*r,e[6]=n[6]*r,e[7]=0,e[8]=n[8]*s,e[9]=n[9]*s,e[10]=n[10]*s,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,n=t.x,i=t.y,r=t.z,s=Math.cos(n),o=Math.sin(n),a=Math.cos(i),l=Math.sin(i),c=Math.cos(r),u=Math.sin(r);if("XYZ"===t.order){const t=s*c,n=s*u,i=o*c,r=o*u;e[0]=a*c,e[4]=-a*u,e[8]=l,e[1]=n+i*l,e[5]=t-r*l,e[9]=-o*a,e[2]=r-t*l,e[6]=i+n*l,e[10]=s*a}else if("YXZ"===t.order){const t=a*c,n=a*u,i=l*c,r=l*u;e[0]=t+r*o,e[4]=i*o-n,e[8]=s*l,e[1]=s*u,e[5]=s*c,e[9]=-o,e[2]=n*o-i,e[6]=r+t*o,e[10]=s*a}else if("ZXY"===t.order){const t=a*c,n=a*u,i=l*c,r=l*u;e[0]=t-r*o,e[4]=-s*u,e[8]=i+n*o,e[1]=n+i*o,e[5]=s*c,e[9]=r-t*o,e[2]=-s*l,e[6]=o,e[10]=s*a}else if("ZYX"===t.order){const t=s*c,n=s*u,i=o*c,r=o*u;e[0]=a*c,e[4]=i*l-n,e[8]=t*l+r,e[1]=a*u,e[5]=r*l+t,e[9]=n*l-i,e[2]=-l,e[6]=o*a,e[10]=s*a}else if("YZX"===t.order){const t=s*a,n=s*l,i=o*a,r=o*l;e[0]=a*c,e[4]=r-t*u,e[8]=i*u+n,e[1]=u,e[5]=s*c,e[9]=-o*c,e[2]=-l*c,e[6]=n*u+i,e[10]=t-r*u}else if("XZY"===t.order){const t=s*a,n=s*l,i=o*a,r=o*l;e[0]=a*c,e[4]=-u,e[8]=l*c,e[1]=t*u+r,e[5]=s*c,e[9]=n*u-i,e[2]=i*u-n,e[6]=o*c,e[10]=r*u+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(Ght,t,Wht)}lookAt(t,e,n){const i=this.elements;return qht.subVectors(t,e),0===qht.lengthSq()&&(qht.z=1),qht.normalize(),jht.crossVectors(n,qht),0===jht.lengthSq()&&(1===Math.abs(n.z)?qht.x+=1e-4:qht.z+=1e-4,qht.normalize(),jht.crossVectors(n,qht)),jht.normalize(),Qht.crossVectors(qht,jht),i[0]=jht.x,i[4]=Qht.x,i[8]=qht.x,i[1]=jht.y,i[5]=Qht.y,i[9]=qht.y,i[2]=jht.z,i[6]=Qht.z,i[10]=qht.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,s=n[0],o=n[4],a=n[8],l=n[12],c=n[1],u=n[5],h=n[9],d=n[13],p=n[2],f=n[6],m=n[10],g=n[14],y=n[3],v=n[7],b=n[11],A=n[15],x=i[0],w=i[4],_=i[8],S=i[12],E=i[1],C=i[5],I=i[9],T=i[13],M=i[2],k=i[6],R=i[10],N=i[14],L=i[3],D=i[7],B=i[11],O=i[15];return r[0]=s*x+o*E+a*M+l*L,r[4]=s*w+o*C+a*k+l*D,r[8]=s*_+o*I+a*R+l*B,r[12]=s*S+o*T+a*N+l*O,r[1]=c*x+u*E+h*M+d*L,r[5]=c*w+u*C+h*k+d*D,r[9]=c*_+u*I+h*R+d*B,r[13]=c*S+u*T+h*N+d*O,r[2]=p*x+f*E+m*M+g*L,r[6]=p*w+f*C+m*k+g*D,r[10]=p*_+f*I+m*R+g*B,r[14]=p*S+f*T+m*N+g*O,r[3]=y*x+v*E+b*M+A*L,r[7]=y*w+v*C+b*k+A*D,r[11]=y*_+v*I+b*R+A*B,r[15]=y*S+v*T+b*N+A*O,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],i=t[8],r=t[12],s=t[1],o=t[5],a=t[9],l=t[13],c=t[2],u=t[6],h=t[10],d=t[14];return t[3]*(+r*a*u-i*l*u-r*o*h+n*l*h+i*o*d-n*a*d)+t[7]*(+e*a*d-e*l*h+r*s*h-i*s*d+i*l*c-r*a*c)+t[11]*(+e*l*u-e*o*d-r*s*u+n*s*d+r*o*c-n*l*c)+t[15]*(-i*o*c-e*a*u+e*o*h+i*s*u-n*s*h+n*a*c)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],o=t[5],a=t[6],l=t[7],c=t[8],u=t[9],h=t[10],d=t[11],p=t[12],f=t[13],m=t[14],g=t[15],y=u*m*l-f*h*l+f*a*d-o*m*d-u*a*g+o*h*g,v=p*h*l-c*m*l-p*a*d+s*m*d+c*a*g-s*h*g,b=c*f*l-p*u*l+p*o*d-s*f*d-c*o*g+s*u*g,A=p*u*a-c*f*a-p*o*h+s*f*h+c*o*m-s*u*m,x=e*y+n*v+i*b+r*A;if(0===x)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const w=1/x;return t[0]=y*w,t[1]=(f*h*r-u*m*r-f*i*d+n*m*d+u*i*g-n*h*g)*w,t[2]=(o*m*r-f*a*r+f*i*l-n*m*l-o*i*g+n*a*g)*w,t[3]=(u*a*r-o*h*r-u*i*l+n*h*l+o*i*d-n*a*d)*w,t[4]=v*w,t[5]=(c*m*r-p*h*r+p*i*d-e*m*d-c*i*g+e*h*g)*w,t[6]=(p*a*r-s*m*r-p*i*l+e*m*l+s*i*g-e*a*g)*w,t[7]=(s*h*r-c*a*r+c*i*l-e*h*l-s*i*d+e*a*d)*w,t[8]=b*w,t[9]=(p*u*r-c*f*r-p*n*d+e*f*d+c*n*g-e*u*g)*w,t[10]=(s*f*r-p*o*r+p*n*l-e*f*l-s*n*g+e*o*g)*w,t[11]=(c*o*r-s*u*r-c*n*l+e*u*l+s*n*d-e*o*d)*w,t[12]=A*w,t[13]=(c*f*i-p*u*i+p*n*h-e*f*h-c*n*m+e*u*m)*w,t[14]=(p*o*i-s*f*i-p*n*a+e*f*a+s*n*m-e*o*m)*w,t[15]=(s*u*i-c*o*i+c*n*a-e*u*a-s*n*h+e*o*h)*w,this}scale(t){const e=this.elements,n=t.x,i=t.y,r=t.z;return e[0]*=n,e[4]*=i,e[8]*=r,e[1]*=n,e[5]*=i,e[9]*=r,e[2]*=n,e[6]*=i,e[10]*=r,e[3]*=n,e[7]*=i,e[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements;return Math.sqrt(Math.max(t[0]*t[0]+t[1]*t[1]+t[2]*t[2],t[4]*t[4]+t[5]*t[5]+t[6]*t[6],t[8]*t[8]+t[9]*t[9]+t[10]*t[10]))}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),i=Math.sin(e),r=1-n,s=t.x,o=t.y,a=t.z,l=r*s,c=r*o;return this.set(l*s+n,l*o-i*a,l*a+i*o,0,l*o+i*a,c*o+n,c*a-i*s,0,l*a-i*o,c*a+i*s,r*a*a+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n){return this.set(1,e,n,0,t,1,n,0,t,e,1,0,0,0,0,1),this}compose(t,e,n){const i=this.elements,r=e._x,s=e._y,o=e._z,a=e._w,l=r+r,c=s+s,u=o+o,h=r*l,d=r*c,p=r*u,f=s*c,m=s*u,g=o*u,y=a*l,v=a*c,b=a*u,A=n.x,x=n.y,w=n.z;return i[0]=(1-(f+g))*A,i[1]=(d+b)*A,i[2]=(p-v)*A,i[3]=0,i[4]=(d-b)*x,i[5]=(1-(h+g))*x,i[6]=(m+y)*x,i[7]=0,i[8]=(p+v)*w,i[9]=(m-y)*w,i[10]=(1-(h+f))*w,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,n){const i=this.elements;let r=Hht.set(i[0],i[1],i[2]).length();const s=Hht.set(i[4],i[5],i[6]).length(),o=Hht.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),t.x=i[12],t.y=i[13],t.z=i[14],Vht.copy(this);const a=1/r,l=1/s,c=1/o;return Vht.elements[0]*=a,Vht.elements[1]*=a,Vht.elements[2]*=a,Vht.elements[4]*=l,Vht.elements[5]*=l,Vht.elements[6]*=l,Vht.elements[8]*=c,Vht.elements[9]*=c,Vht.elements[10]*=c,e.setFromRotationMatrix(Vht),n.x=r,n.y=s,n.z=o,this}makePerspective(t,e,n,i,r,s){void 0===s&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const o=this.elements,a=2*r/(n-i),l=(e+t)/(e-t),c=(n+i)/(n-i),u=-(s+r)/(s-r),h=-2*s*r/(s-r);return o[0]=2*r/(e-t),o[4]=0,o[8]=l,o[12]=0,o[1]=0,o[5]=a,o[9]=c,o[13]=0,o[2]=0,o[6]=0,o[10]=u,o[14]=h,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(t,e,n,i,r,s){const o=this.elements,a=1/(e-t),l=1/(n-i),c=1/(s-r),u=(e+t)*a,h=(n+i)*l,d=(s+r)*c;return o[0]=2*a,o[4]=0,o[8]=0,o[12]=-u,o[1]=0,o[5]=2*l,o[9]=0,o[13]=-h,o[2]=0,o[6]=0,o[10]=-2*c,o[14]=-d,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<16;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}Uht.prototype.isMatrix4=!0;const Hht=new uht,Vht=new Uht,Ght=new uht(0,0,0),Wht=new uht(1,1,1),jht=new uht,Qht=new uht,qht=new uht,Xht=new Uht,Yht=new cht;class Kht{constructor(t=0,e=0,n=0,i=Kht.DefaultOrder){this._x=t,this._y=e,this._z=n,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._order=i||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e,n){const i=t.elements,r=i[0],s=i[4],o=i[8],a=i[1],l=i[5],c=i[9],u=i[2],h=i[6],d=i[10];switch(e=e||this._order){case"XYZ":this._y=Math.asin(Qut(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-c,d),this._z=Math.atan2(-s,r)):(this._x=Math.atan2(h,l),this._z=0);break;case"YXZ":this._x=Math.asin(-Qut(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(o,d),this._z=Math.atan2(a,l)):(this._y=Math.atan2(-u,r),this._z=0);break;case"ZXY":this._x=Math.asin(Qut(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(-u,d),this._z=Math.atan2(-s,l)):(this._y=0,this._z=Math.atan2(a,r));break;case"ZYX":this._y=Math.asin(-Qut(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(h,d),this._z=Math.atan2(a,r)):(this._x=0,this._z=Math.atan2(-s,l));break;case"YZX":this._z=Math.asin(Qut(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-c,l),this._y=Math.atan2(-u,r)):(this._x=0,this._y=Math.atan2(o,d));break;case"XZY":this._z=Math.asin(-Qut(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(h,l),this._y=Math.atan2(o,r)):(this._x=Math.atan2(-c,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!1!==n&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return Xht.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Xht,e,n)}setFromVector3(t,e){return this.set(t.x,t.y,t.z,e||this._order)}reorder(t){return Yht.setFromEuler(this),this.setFromQuaternion(Yht,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new uht(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}Kht.prototype.isEuler=!0,Kht.DefaultOrder="XYZ",Kht.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class Jht{constructor(){this.mask=1}set(t){this.mask=1<<t|0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return 0!=(this.mask&t.mask)}}let Zht=0;const tdt=new uht,edt=new cht,ndt=new Uht,idt=new uht,rdt=new uht,sdt=new uht,odt=new cht,adt=new uht(1,0,0),ldt=new uht(0,1,0),cdt=new uht(0,0,1),udt={type:"added"},hdt={type:"removed"};class ddt extends Uut{constructor(){super(),Object.defineProperty(this,"id",{value:Zht++}),this.uuid=jut(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=ddt.DefaultUp.clone();const t=new uht,e=new Kht,n=new cht,i=new uht(1,1,1);e._onChange(function(){n.setFromEuler(e,!1)}),n._onChange(function(){e.setFromQuaternion(n,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new Uht},normalMatrix:{value:new eht}}),this.matrix=new Uht,this.matrixWorld=new Uht,this.matrixAutoUpdate=ddt.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new Jht,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return edt.setFromAxisAngle(t,e),this.quaternion.multiply(edt),this}rotateOnWorldAxis(t,e){return edt.setFromAxisAngle(t,e),this.quaternion.premultiply(edt),this}rotateX(t){return this.rotateOnAxis(adt,t)}rotateY(t){return this.rotateOnAxis(ldt,t)}rotateZ(t){return this.rotateOnAxis(cdt,t)}translateOnAxis(t,e){return tdt.copy(t).applyQuaternion(this.quaternion),this.position.add(tdt.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(adt,t)}translateY(t){return this.translateOnAxis(ldt,t)}translateZ(t){return this.translateOnAxis(cdt,t)}localToWorld(t){return t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return t.applyMatrix4(ndt.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?idt.copy(t):idt.set(t,e,n);const i=this.parent;this.updateWorldMatrix(!0,!1),rdt.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?ndt.lookAt(rdt,idt,this.up):ndt.lookAt(idt,rdt,this.up),this.quaternion.setFromRotationMatrix(ndt),i&&(ndt.extractRotation(i.matrixWorld),edt.setFromRotationMatrix(ndt),this.quaternion.premultiply(edt.invert()))}add(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(null!==t.parent&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(udt)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(t);return-1!==e&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(hdt)),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(hdt)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),ndt.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),ndt.multiply(t.parent.matrixWorld)),t.applyMatrix4(ndt),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,i=this.children.length;n<i;n++){const i=this.children[n].getObjectByProperty(t,e);if(void 0!==i)return i}}getWorldPosition(t){return void 0===t&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),t=new uht),this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return void 0===t&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),t=new cht),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(rdt,t,sdt),t}getWorldScale(t){return void 0===t&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),t=new uht),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(rdt,odt,t),t}getWorldDirection(t){void 0===t&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),t=new uht),this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverse(t)}traverseVisible(t){if(!1===this.visible)return;t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].updateMatrixWorld(t)}updateWorldMatrix(t,e){const n=this.parent;if(!0===t&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===e){const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].updateWorldMatrix(!1,!0)}}toJSON(t){const e=void 0===t||"string"==typeof t,n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};function r(e,n){return void 0===e[n.uuid]&&(e[n.uuid]=n.toJSON(t)),n.uuid}if(i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),!0===this.castShadow&&(i.castShadow=!0),!0===this.receiveShadow&&(i.receiveShadow=!0),!1===this.visible&&(i.visible=!1),!1===this.frustumCulled&&(i.frustumCulled=!1),0!==this.renderOrder&&(i.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(i.instanceColor=this.instanceColor.toJSON())),this.isMesh||this.isLine||this.isPoints){i.geometry=r(t.geometries,this.geometry);const e=this.geometry.parameters;if(void 0!==e&&void 0!==e.shapes){const n=e.shapes;if(Array.isArray(n))for(let e=0,i=n.length;e<i;e++)r(t.shapes,n[e]);else r(t.shapes,n)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(r(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const e=[];for(let n=0,i=this.material.length;n<i;n++)e.push(r(t.materials,this.material[n]));i.material=e}else i.material=r(t.materials,this.material);if(this.children.length>0){i.children=[];for(let e=0;e<this.children.length;e++)i.children.push(this.children[e].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let e=0;e<this.animations.length;e++)i.animations.push(r(t.animations,this.animations[e]))}if(e){const e=s(t.geometries),i=s(t.materials),r=s(t.textures),o=s(t.images),a=s(t.shapes),l=s(t.skeletons),c=s(t.animations);e.length>0&&(n.geometries=e),i.length>0&&(n.materials=i),r.length>0&&(n.textures=r),o.length>0&&(n.images=o),a.length>0&&(n.shapes=a),l.length>0&&(n.skeletons=l),c.length>0&&(n.animations=c)}return n.object=i,n;function s(t){const e=[];for(const n in t){const i=t[n];delete i.metadata,e.push(i)}return e}}clone(t){return(new this.constructor).copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(let n=0;n<t.children.length;n++)this.add(t.children[n].clone());return this}}ddt.DefaultUp=new uht(0,1,0),ddt.DefaultMatrixAutoUpdate=!0,ddt.prototype.isObject3D=!0;const pdt=new uht,fdt=new uht,mdt=new eht;class gdt{constructor(t=new uht(1,0,0),e=0){this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,i){return this.normal.set(t,e,n),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const i=pdt.subVectors(n,e).cross(fdt.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return void 0===e&&(console.warn("THREE.Plane: .projectPoint() target is now required"),e=new uht),e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){void 0===e&&(console.warn("THREE.Plane: .intersectLine() target is now required"),e=new uht);const n=t.delta(pdt),i=this.normal.dot(n);if(0===i)return 0===this.distanceToPoint(t.start)?e.copy(t.start):null;const r=-(t.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:e.copy(n).multiplyScalar(r).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return void 0===t&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),t=new uht),t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||mdt.getNormalMatrix(t),i=this.coplanarPoint(pdt).applyMatrix4(t),r=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return(new this.constructor).copy(this)}}gdt.prototype.isPlane=!0;const ydt=new uht,vdt=new uht,bdt=new uht,Adt=new uht,xdt=new uht,wdt=new uht,_dt=new uht,Sdt=new uht,Edt=new uht,Cdt=new uht;class Idt{constructor(t=new uht,e=new uht,n=new uht){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,i){void 0===i&&(console.warn("THREE.Triangle: .getNormal() target is now required"),i=new uht),i.subVectors(n,e),ydt.subVectors(t,e),i.cross(ydt);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(t,e,n,i,r){ydt.subVectors(i,e),vdt.subVectors(n,e),bdt.subVectors(t,e);const s=ydt.dot(ydt),o=ydt.dot(vdt),a=ydt.dot(bdt),l=vdt.dot(vdt),c=vdt.dot(bdt),u=s*l-o*o;if(void 0===r&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),r=new uht),0===u)return r.set(-2,-1,-1);const h=1/u,d=(l*a-o*c)*h,p=(s*c-o*a)*h;return r.set(1-d-p,p,d)}static containsPoint(t,e,n,i){return this.getBarycoord(t,e,n,i,Adt),Adt.x>=0&&Adt.y>=0&&Adt.x+Adt.y<=1}static getUV(t,e,n,i,r,s,o,a){return this.getBarycoord(t,e,n,i,Adt),a.set(0,0),a.addScaledVector(r,Adt.x),a.addScaledVector(s,Adt.y),a.addScaledVector(o,Adt.z),a}static isFrontFacing(t,e,n,i){return ydt.subVectors(n,e),vdt.subVectors(t,e),ydt.cross(vdt).dot(i)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,i){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[i]),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return ydt.subVectors(this.c,this.b),vdt.subVectors(this.a,this.b),.5*ydt.cross(vdt).length()}getMidpoint(t){return void 0===t&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),t=new uht),t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return Idt.getNormal(this.a,this.b,this.c,t)}getPlane(t){return void 0===t&&(console.warn("THREE.Triangle: .getPlane() target is now required"),t=new gdt),t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return Idt.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,i,r){return Idt.getUV(t,this.a,this.b,this.c,e,n,i,r)}containsPoint(t){return Idt.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return Idt.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){void 0===e&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),e=new uht);const n=this.a,i=this.b,r=this.c;let s,o;xdt.subVectors(i,n),wdt.subVectors(r,n),Sdt.subVectors(t,n);const a=xdt.dot(Sdt),l=wdt.dot(Sdt);if(a<=0&&l<=0)return e.copy(n);Edt.subVectors(t,i);const c=xdt.dot(Edt),u=wdt.dot(Edt);if(c>=0&&u<=c)return e.copy(i);const h=a*u-c*l;if(h<=0&&a>=0&&c<=0)return s=a/(a-c),e.copy(n).addScaledVector(xdt,s);Cdt.subVectors(t,r);const d=xdt.dot(Cdt),p=wdt.dot(Cdt);if(p>=0&&d<=p)return e.copy(r);const f=d*l-a*p;if(f<=0&&l>=0&&p<=0)return o=l/(l-p),e.copy(n).addScaledVector(wdt,o);const m=c*p-d*u;if(m<=0&&u-c>=0&&d-p>=0)return _dt.subVectors(r,i),o=(u-c)/(u-c+(d-p)),e.copy(i).addScaledVector(_dt,o);const g=1/(m+f+h);return s=f*g,o=h*g,e.copy(n).addScaledVector(xdt,s).addScaledVector(wdt,o)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let Tdt=0;function Mdt(){Object.defineProperty(this,"id",{value:Tdt++}),this.uuid=jut(),this.name="",this.type="Material",this.fog=!0,this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=100,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=7680,this.stencilZFail=7680,this.stencilZPass=7680,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}Mdt.prototype=Object.assign(Object.create(Uut.prototype),{constructor:Mdt,isMaterial:!0,onBuild:function(){},onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(t){if(void 0!==t)for(const e in t){const n=t[e];if(void 0===n){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if("shading"===e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===n;continue}const i=this[e];void 0!==i?i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[e]=n:console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.")}},toJSON:function(t){const e=void 0===t||"string"==typeof t;e&&(t={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function i(t){const e=[];for(const n in t){const i=t[n];delete i.metadata,e.push(i)}return e}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(n.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,void 0!==this.combine&&(n.combine=this.combine)),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(n.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),void 0!==this.size&&(n.size=this.size),null!==this.shadowSide&&(n.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(n.blending=this.blending),0!==this.side&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),!0===this.transparent&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.alphaToCoverage&&(n.alphaToCoverage=this.alphaToCoverage),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.morphTargets&&(n.morphTargets=!0),!0===this.morphNormals&&(n.morphNormals=!0),!0===this.skinning&&(n.skinning=!0),!0===this.flatShading&&(n.flatShading=this.flatShading),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),e){const e=i(t.textures),r=i(t.images);e.length>0&&(n.textures=e),r.length>0&&(n.images=r)}return n},clone:function(){return(new this.constructor).copy(this)},copy:function(t){this.name=t.name,this.fog=t.fog,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(null!==e){const t=e.length;n=new Array(t);for(let i=0;i!==t;++i)n[i]=e[i].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),Object.defineProperty(Mdt.prototype,"needsUpdate",{set:function(t){!0===t&&this.version++}});const kdt={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Rdt={h:0,s:0,l:0},Ndt={h:0,s:0,l:0};function Ldt(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+6*(e-t)*n:n<.5?e:n<2/3?t+6*(e-t)*(2/3-n):t}function Ddt(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function Bdt(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}class Odt{constructor(t,e,n){return void 0===e&&void 0===n?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):"number"==typeof t?this.setHex(t):"string"==typeof t&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,this}setRGB(t,e,n){return this.r=t,this.g=e,this.b=n,this}setHSL(t,e,n){if(t=qut(t,1),e=Qut(e,0,1),n=Qut(n,0,1),0===e)this.r=this.g=this.b=n;else{const i=n<=.5?n*(1+e):n+e-n*e,r=2*n-i;this.r=Ldt(r,i,t+1/3),this.g=Ldt(r,i,t),this.b=Ldt(r,i,t-1/3)}return this}setStyle(t){function e(e){void 0!==e&&parseFloat(e)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let t;const i=n[2];switch(n[1]){case"rgb":case"rgba":if(t=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))return this.r=Math.min(255,parseInt(t[1],10))/255,this.g=Math.min(255,parseInt(t[2],10))/255,this.b=Math.min(255,parseInt(t[3],10))/255,e(t[4]),this;if(t=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))return this.r=Math.min(100,parseInt(t[1],10))/100,this.g=Math.min(100,parseInt(t[2],10))/100,this.b=Math.min(100,parseInt(t[3],10))/100,e(t[4]),this;break;case"hsl":case"hsla":if(t=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)){const n=parseFloat(t[1])/360,i=parseInt(t[2],10)/100,r=parseInt(t[3],10)/100;return e(t[4]),this.setHSL(n,i,r)}}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const t=n[1],e=t.length;if(3===e)return this.r=parseInt(t.charAt(0)+t.charAt(0),16)/255,this.g=parseInt(t.charAt(1)+t.charAt(1),16)/255,this.b=parseInt(t.charAt(2)+t.charAt(2),16)/255,this;if(6===e)return this.r=parseInt(t.charAt(0)+t.charAt(1),16)/255,this.g=parseInt(t.charAt(2)+t.charAt(3),16)/255,this.b=parseInt(t.charAt(4)+t.charAt(5),16)/255,this}return t&&t.length>0?this.setColorName(t):this}setColorName(t){const e=kdt[t.toLowerCase()];return void 0!==e?this.setHex(e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copyGammaToLinear(t,e=2){return this.r=Math.pow(t.r,e),this.g=Math.pow(t.g,e),this.b=Math.pow(t.b,e),this}copyLinearToGamma(t,e=2){const n=e>0?1/e:1;return this.r=Math.pow(t.r,n),this.g=Math.pow(t.g,n),this.b=Math.pow(t.b,n),this}convertGammaToLinear(t){return this.copyGammaToLinear(this,t),this}convertLinearToGamma(t){return this.copyLinearToGamma(this,t),this}copySRGBToLinear(t){return this.r=Ddt(t.r),this.g=Ddt(t.g),this.b=Ddt(t.b),this}copyLinearToSRGB(t){return this.r=Bdt(t.r),this.g=Bdt(t.g),this.b=Bdt(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(t){void 0===t&&(console.warn("THREE.Color: .getHSL() target is now required"),t={h:0,s:0,l:0});const e=this.r,n=this.g,i=this.b,r=Math.max(e,n,i),s=Math.min(e,n,i);let o,a;const l=(s+r)/2;if(s===r)o=0,a=0;else{const t=r-s;switch(a=l<=.5?t/(r+s):t/(2-r-s),r){case e:o=(n-i)/t+(n<i?6:0);break;case n:o=(i-e)/t+2;break;case i:o=(e-n)/t+4}o/=6}return t.h=o,t.s=a,t.l=l,t}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(t,e,n){return this.getHSL(Rdt),Rdt.h+=t,Rdt.s+=e,Rdt.l+=n,this.setHSL(Rdt.h,Rdt.s,Rdt.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(Rdt),t.getHSL(Ndt);const n=Xut(Rdt.h,Ndt.h,e),i=Xut(Rdt.s,Ndt.s,e),r=Xut(Rdt.l,Ndt.l,e);return this.setHSL(n,i,r),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),!0===t.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Odt.NAMES=kdt,Odt.prototype.isColor=!0,Odt.prototype.r=1,Odt.prototype.g=1,Odt.prototype.b=1;class Pdt extends Mdt{constructor(t){super(),this.type="MeshBasicMaterial",this.color=new Odt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this}}Pdt.prototype.isMeshBasicMaterial=!0;const Fdt=new uht,$dt=new tht;class zdt{constructor(t,e,n){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=!0===n,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0,this.onUploadCallback=function(){}}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[t+i]=e.array[n+i];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),r=new Odt),e[n++]=r.r,e[n++]=r.g,e[n++]=r.b}return this}copyVector2sArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),r=new tht),e[n++]=r.x,e[n++]=r.y}return this}copyVector3sArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),r=new uht),e[n++]=r.x,e[n++]=r.y,e[n++]=r.z}return this}copyVector4sArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),r=new aht),e[n++]=r.x,e[n++]=r.y,e[n++]=r.z,e[n++]=r.w}return this}applyMatrix3(t){if(2===this.itemSize)for(let e=0,n=this.count;e<n;e++)$dt.fromBufferAttribute(this,e),$dt.applyMatrix3(t),this.setXY(e,$dt.x,$dt.y);else if(3===this.itemSize)for(let e=0,n=this.count;e<n;e++)Fdt.fromBufferAttribute(this,e),Fdt.applyMatrix3(t),this.setXYZ(e,Fdt.x,Fdt.y,Fdt.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)Fdt.x=this.getX(e),Fdt.y=this.getY(e),Fdt.z=this.getZ(e),Fdt.applyMatrix4(t),this.setXYZ(e,Fdt.x,Fdt.y,Fdt.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)Fdt.x=this.getX(e),Fdt.y=this.getY(e),Fdt.z=this.getZ(e),Fdt.applyNormalMatrix(t),this.setXYZ(e,Fdt.x,Fdt.y,Fdt.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)Fdt.x=this.getX(e),Fdt.y=this.getY(e),Fdt.z=this.getZ(e),Fdt.transformDirection(t),this.setXYZ(e,Fdt.x,Fdt.y,Fdt.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return this.array[0+(t*=this.itemSize)]=e,this.array[t+1]=n,this}setXYZ(t,e,n,i){return this.array[0+(t*=this.itemSize)]=e,this.array[t+1]=n,this.array[t+2]=i,this}setXYZW(t,e,n,i,r){return this.array[0+(t*=this.itemSize)]=e,this.array[t+1]=n,this.array[t+2]=i,this.array[t+3]=r,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return""!==this.name&&(t.name=this.name),35044!==this.usage&&(t.usage=this.usage),0===this.updateRange.offset&&-1===this.updateRange.count||(t.updateRange=this.updateRange),t}}zdt.prototype.isBufferAttribute=!0;class Udt extends zdt{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class Hdt extends zdt{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class Vdt extends zdt{constructor(t,e,n){super(new Float32Array(t),e,n)}}function Gdt(t){if(0===t.length)return-1/0;let e=t[0];for(let n=1,i=t.length;n<i;++n)t[n]>e&&(e=t[n]);return e}let Wdt=0;const jdt=new Uht,Qdt=new ddt,qdt=new uht,Xdt=new pht,Ydt=new pht,Kdt=new uht;class Jdt extends Uut{constructor(){super(),Object.defineProperty(this,"id",{value:Wdt++}),this.uuid=jut(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return this.index=Array.isArray(t)?new(Gdt(t)>65535?Hdt:Udt)(t,1):t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const e=(new eht).getNormalMatrix(t);n.applyNormalMatrix(e),n.needsUpdate=!0}const i=this.attributes.tangent;return void 0!==i&&(i.transformDirection(t),i.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}rotateX(t){return jdt.makeRotationX(t),this.applyMatrix4(jdt),this}rotateY(t){return jdt.makeRotationY(t),this.applyMatrix4(jdt),this}rotateZ(t){return jdt.makeRotationZ(t),this.applyMatrix4(jdt),this}translate(t,e,n){return jdt.makeTranslation(t,e,n),this.applyMatrix4(jdt),this}scale(t,e,n){return jdt.makeScale(t,e,n),this.applyMatrix4(jdt),this}lookAt(t){return Qdt.lookAt(t),Qdt.updateMatrix(),this.applyMatrix4(Qdt.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(qdt).negate(),this.translate(qdt.x,qdt.y,qdt.z),this}setFromPoints(t){const e=[];for(let n=0,i=t.length;n<i;n++){const i=t[n];e.push(i.x,i.y,i.z||0)}return this.setAttribute("position",new Vdt(e,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new pht);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new uht(-1/0,-1/0,-1/0),new uht(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let n=0,i=e.length;n<i;n++)Xdt.setFromBufferAttribute(e[n]),this.morphTargetsRelative?(Kdt.addVectors(this.boundingBox.min,Xdt.min),this.boundingBox.expandByPoint(Kdt),Kdt.addVectors(this.boundingBox.max,Xdt.max),this.boundingBox.expandByPoint(Kdt)):(this.boundingBox.expandByPoint(Xdt.min),this.boundingBox.expandByPoint(Xdt.max))}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Nht);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new uht,1/0);if(t){const n=this.boundingSphere.center;if(Xdt.setFromBufferAttribute(t),e)for(let t=0,r=e.length;t<r;t++)Ydt.setFromBufferAttribute(e[t]),this.morphTargetsRelative?(Kdt.addVectors(Xdt.min,Ydt.min),Xdt.expandByPoint(Kdt),Kdt.addVectors(Xdt.max,Ydt.max),Xdt.expandByPoint(Kdt)):(Xdt.expandByPoint(Ydt.min),Xdt.expandByPoint(Ydt.max));Xdt.getCenter(n);let i=0;for(let e=0,r=t.count;e<r;e++)Kdt.fromBufferAttribute(t,e),i=Math.max(i,n.distanceToSquared(Kdt));if(e)for(let r=0,s=e.length;r<s;r++){const s=e[r],o=this.morphTargetsRelative;for(let e=0,r=s.count;e<r;e++)Kdt.fromBufferAttribute(s,e),o&&(qdt.fromBufferAttribute(t,e),Kdt.add(qdt)),i=Math.max(i,n.distanceToSquared(Kdt))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeFaceNormals(){}computeTangents(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=t.array,i=e.position.array,r=e.normal.array,s=e.uv.array,o=i.length/3;void 0===e.tangent&&this.setAttribute("tangent",new zdt(new Float32Array(4*o),4));const a=e.tangent.array,l=[],c=[];for(let E=0;E<o;E++)l[E]=new uht,c[E]=new uht;const u=new uht,h=new uht,d=new uht,p=new tht,f=new tht,m=new tht,g=new uht,y=new uht;function v(t,e,n){u.fromArray(i,3*t),h.fromArray(i,3*e),d.fromArray(i,3*n),p.fromArray(s,2*t),f.fromArray(s,2*e),m.fromArray(s,2*n),h.sub(u),d.sub(u),f.sub(p),m.sub(p);const r=1/(f.x*m.y-m.x*f.y);isFinite(r)&&(g.copy(h).multiplyScalar(m.y).addScaledVector(d,-f.y).multiplyScalar(r),y.copy(d).multiplyScalar(f.x).addScaledVector(h,-m.x).multiplyScalar(r),l[t].add(g),l[e].add(g),l[n].add(g),c[t].add(y),c[e].add(y),c[n].add(y))}let b=this.groups;0===b.length&&(b=[{start:0,count:n.length}]);for(let E=0,C=b.length;E<C;++E){const t=b[E],e=t.start;for(let i=e,r=e+t.count;i<r;i+=3)v(n[i+0],n[i+1],n[i+2])}const A=new uht,x=new uht,w=new uht,_=new uht;function S(t){w.fromArray(r,3*t),_.copy(w);const e=l[t];A.copy(e),A.sub(w.multiplyScalar(w.dot(e))).normalize(),x.crossVectors(_,e);const n=x.dot(c[t])<0?-1:1;a[4*t]=A.x,a[4*t+1]=A.y,a[4*t+2]=A.z,a[4*t+3]=n}for(let E=0,C=b.length;E<C;++E){const t=b[E],e=t.start;for(let i=e,r=e+t.count;i<r;i+=3)S(n[i+0]),S(n[i+1]),S(n[i+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let n=this.getAttribute("normal");if(void 0===n)n=new zdt(new Float32Array(3*e.count),3),this.setAttribute("normal",n);else for(let t=0,e=n.count;t<e;t++)n.setXYZ(t,0,0,0);const i=new uht,r=new uht,s=new uht,o=new uht,a=new uht,l=new uht,c=new uht,u=new uht;if(t)for(let h=0,d=t.count;h<d;h+=3){const d=t.getX(h+0),p=t.getX(h+1),f=t.getX(h+2);i.fromBufferAttribute(e,d),r.fromBufferAttribute(e,p),s.fromBufferAttribute(e,f),c.subVectors(s,r),u.subVectors(i,r),c.cross(u),o.fromBufferAttribute(n,d),a.fromBufferAttribute(n,p),l.fromBufferAttribute(n,f),o.add(c),a.add(c),l.add(c),n.setXYZ(d,o.x,o.y,o.z),n.setXYZ(p,a.x,a.y,a.z),n.setXYZ(f,l.x,l.y,l.z)}else for(let t=0,h=e.count;t<h;t+=3)i.fromBufferAttribute(e,t+0),r.fromBufferAttribute(e,t+1),s.fromBufferAttribute(e,t+2),c.subVectors(s,r),u.subVectors(i,r),c.cross(u),n.setXYZ(t+0,c.x,c.y,c.z),n.setXYZ(t+1,c.x,c.y,c.z),n.setXYZ(t+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(t,e){if(!t||!t.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);void 0===e&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const i in n){if(void 0===t.attributes[i])continue;const r=n[i].array,s=t.attributes[i],o=s.array,a=s.itemSize*e,l=Math.min(o.length,r.length-a);for(let t=0,e=a;t<l;t++,e++)r[e]=o[t]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)Kdt.fromBufferAttribute(t,e),Kdt.normalize(),t.setXYZ(e,Kdt.x,Kdt.y,Kdt.z)}toNonIndexed(){function t(t,e){const n=t.array,i=t.itemSize,r=t.normalized,s=new n.constructor(e.length*i);let o=0,a=0;for(let l=0,c=e.length;l<c;l++){o=e[l]*i;for(let t=0;t<i;t++)s[a++]=n[o++]}return new zdt(s,i,r)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new Jdt,n=this.index.array,i=this.attributes;for(const o in i){const r=t(i[o],n);e.setAttribute(o,r)}const r=this.morphAttributes;for(const o in r){const i=[],s=r[o];for(let e=0,r=s.length;e<r;e++){const r=t(s[e],n);i.push(r)}e.morphAttributes[o]=i}e.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let o=0,a=s.length;o<a;o++){const t=s[o];e.addGroup(t.start,t.count,t.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const n in e)void 0!==e[n]&&(t[n]=e[n]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const a in n)t.data.attributes[a]=n[a].toJSON(t.data);const i={};let r=!1;for(const a in this.morphAttributes){const e=this.morphAttributes[a],n=[];for(let i=0,r=e.length;i<r;i++)n.push(e[i].toJSON(t.data));n.length>0&&(i[a]=n,r=!0)}r&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(t.data.groups=JSON.parse(JSON.stringify(s)));const o=this.boundingSphere;return null!==o&&(t.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),t}clone(){return(new Jdt).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;null!==n&&this.setIndex(n.clone(e));const i=t.attributes;for(const l in i)this.setAttribute(l,i[l].clone(e));const r=t.morphAttributes;for(const l in r){const t=[],n=r[l];for(let i=0,r=n.length;i<r;i++)t.push(n[i].clone(e));this.morphAttributes[l]=t}this.morphTargetsRelative=t.morphTargetsRelative;const s=t.groups;for(let l=0,c=s.length;l<c;l++){const t=s[l];this.addGroup(t.start,t.count,t.materialIndex)}const o=t.boundingBox;null!==o&&(this.boundingBox=o.clone());const a=t.boundingSphere;return null!==a&&(this.boundingSphere=a.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}Jdt.prototype.isBufferGeometry=!0;const Zdt=new Uht,tpt=new zht,ept=new Nht,npt=new uht,ipt=new uht,rpt=new uht,spt=new uht,opt=new uht,apt=new uht,lpt=new uht,cpt=new uht,upt=new uht,hpt=new tht,dpt=new tht,ppt=new tht,fpt=new uht,mpt=new uht;class gpt extends ddt{constructor(t=new Jdt,e=new Pdt){super(),this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(t,e){const n=this.geometry,i=this.material,r=this.matrixWorld;if(void 0===i)return;if(null===n.boundingSphere&&n.computeBoundingSphere(),ept.copy(n.boundingSphere),ept.applyMatrix4(r),!1===t.ray.intersectsSphere(ept))return;if(Zdt.copy(r).invert(),tpt.copy(t.ray).applyMatrix4(Zdt),null!==n.boundingBox&&!1===tpt.intersectsBox(n.boundingBox))return;let s;if(n.isBufferGeometry){const r=n.index,o=n.attributes.position,a=n.morphAttributes.position,l=n.morphTargetsRelative,c=n.attributes.uv,u=n.attributes.uv2,h=n.groups,d=n.drawRange;if(null!==r)if(Array.isArray(i))for(let n=0,p=h.length;n<p;n++){const p=h[n],f=i[p.materialIndex];for(let n=Math.max(p.start,d.start),i=Math.min(p.start+p.count,d.start+d.count);n<i;n+=3){const i=r.getX(n),h=r.getX(n+1),d=r.getX(n+2);s=ypt(this,f,t,tpt,o,a,l,c,u,i,h,d),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=p.materialIndex,e.push(s))}}else for(let n=Math.max(0,d.start),p=Math.min(r.count,d.start+d.count);n<p;n+=3){const h=r.getX(n),d=r.getX(n+1),p=r.getX(n+2);s=ypt(this,i,t,tpt,o,a,l,c,u,h,d,p),s&&(s.faceIndex=Math.floor(n/3),e.push(s))}else if(void 0!==o)if(Array.isArray(i))for(let n=0,p=h.length;n<p;n++){const r=h[n],p=i[r.materialIndex];for(let n=Math.max(r.start,d.start),i=Math.min(r.start+r.count,d.start+d.count);n<i;n+=3)s=ypt(this,p,t,tpt,o,a,l,c,u,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=r.materialIndex,e.push(s))}else for(let n=Math.max(0,d.start),p=Math.min(o.count,d.start+d.count);n<p;n+=3)s=ypt(this,i,t,tpt,o,a,l,c,u,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),e.push(s))}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}function ypt(t,e,n,i,r,s,o,a,l,c,u,h){npt.fromBufferAttribute(r,c),ipt.fromBufferAttribute(r,u),rpt.fromBufferAttribute(r,h);const d=t.morphTargetInfluences;if(e.morphTargets&&s&&d){lpt.set(0,0,0),cpt.set(0,0,0),upt.set(0,0,0);for(let t=0,e=s.length;t<e;t++){const e=d[t],n=s[t];0!==e&&(spt.fromBufferAttribute(n,c),opt.fromBufferAttribute(n,u),apt.fromBufferAttribute(n,h),o?(lpt.addScaledVector(spt,e),cpt.addScaledVector(opt,e),upt.addScaledVector(apt,e)):(lpt.addScaledVector(spt.sub(npt),e),cpt.addScaledVector(opt.sub(ipt),e),upt.addScaledVector(apt.sub(rpt),e)))}npt.add(lpt),ipt.add(cpt),rpt.add(upt)}t.isSkinnedMesh&&e.skinning&&(t.boneTransform(c,npt),t.boneTransform(u,ipt),t.boneTransform(h,rpt));const p=function(t,e,n,i,r,s,o,a){let l;if(l=1===e.side?i.intersectTriangle(o,s,r,!0,a):i.intersectTriangle(r,s,o,2!==e.side,a),null===l)return null;mpt.copy(a),mpt.applyMatrix4(t.matrixWorld);const c=n.ray.origin.distanceTo(mpt);return c<n.near||c>n.far?null:{distance:c,point:mpt.clone(),object:t}}(t,e,n,i,npt,ipt,rpt,fpt);if(p){a&&(hpt.fromBufferAttribute(a,c),dpt.fromBufferAttribute(a,u),ppt.fromBufferAttribute(a,h),p.uv=Idt.getUV(fpt,npt,ipt,rpt,hpt,dpt,ppt,new tht)),l&&(hpt.fromBufferAttribute(l,c),dpt.fromBufferAttribute(l,u),ppt.fromBufferAttribute(l,h),p.uv2=Idt.getUV(fpt,npt,ipt,rpt,hpt,dpt,ppt,new tht));const t={a:c,b:u,c:h,normal:new uht,materialIndex:0};Idt.getNormal(npt,ipt,rpt,t.normal),p.face=t}return p}gpt.prototype.isMesh=!0;class vpt extends Jdt{constructor(t=1,e=1,n=1,i=1,r=1,s=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:i,heightSegments:r,depthSegments:s};const o=this;i=Math.floor(i),r=Math.floor(r),s=Math.floor(s);const a=[],l=[],c=[],u=[];let h=0,d=0;function p(t,e,n,i,r,s,p,f,m,g,y){const v=s/m,b=p/g,A=s/2,x=p/2,w=f/2,_=m+1,S=g+1;let E=0,C=0;const I=new uht;for(let o=0;o<S;o++){const s=o*b-x;for(let a=0;a<_;a++)I[t]=(a*v-A)*i,I[e]=s*r,I[n]=w,l.push(I.x,I.y,I.z),I[t]=0,I[e]=0,I[n]=f>0?1:-1,c.push(I.x,I.y,I.z),u.push(a/m),u.push(1-o/g),E+=1}for(let o=0;o<g;o++)for(let t=0;t<m;t++){const e=h+t+_*(o+1),n=h+(t+1)+_*(o+1),i=h+(t+1)+_*o;a.push(h+t+_*o,e,i),a.push(e,n,i),C+=6}o.addGroup(d,C,y),d+=C,h+=E}p("z","y","x",-1,-1,n,e,t,s,r,0),p("z","y","x",1,-1,n,e,-t,s,r,1),p("x","z","y",1,1,t,n,e,i,s,2),p("x","z","y",1,-1,t,n,-e,i,s,3),p("x","y","z",1,-1,t,e,n,i,r,4),p("x","y","z",-1,-1,t,e,-n,i,r,5),this.setIndex(a),this.setAttribute("position",new Vdt(l,3)),this.setAttribute("normal",new Vdt(c,3)),this.setAttribute("uv",new Vdt(u,2))}}function bpt(t){const e={};for(const n in t){e[n]={};for(const i in t[n]){const r=t[n][i];e[n][i]=r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?r.clone():Array.isArray(r)?r.slice():r}}return e}function Apt(t){const e={};for(let n=0;n<t.length;n++){const i=bpt(t[n]);for(const t in i)e[t]=i[t]}return e}const xpt={clone:bpt,merge:Apt};class wpt extends Mdt{constructor(t){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==t&&(void 0!==t.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=bpt(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.lights=t.lights,this.clipping=t.clipping,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const i in this.uniforms){const n=this.uniforms[i].value;e.uniforms[i]=n&&n.isTexture?{type:"t",value:n.toJSON(t).uuid}:n&&n.isColor?{type:"c",value:n.getHex()}:n&&n.isVector2?{type:"v2",value:n.toArray()}:n&&n.isVector3?{type:"v3",value:n.toArray()}:n&&n.isVector4?{type:"v4",value:n.toArray()}:n&&n.isMatrix3?{type:"m3",value:n.toArray()}:n&&n.isMatrix4?{type:"m4",value:n.toArray()}:{value:n}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const n={};for(const i in this.extensions)!0===this.extensions[i]&&(n[i]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}wpt.prototype.isShaderMaterial=!0;class _pt extends ddt{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new Uht,this.projectionMatrix=new Uht,this.projectionMatrixInverse=new Uht}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this}getWorldDirection(t){void 0===t&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),t=new uht),this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}_pt.prototype.isCamera=!0;class Spt extends _pt{constructor(t=50,e=1,n=.1,i=2e3){super(),this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=null===t.view?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=2*Wut*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(.5*Gut*this.fov);return.5*this.getFilmHeight()/t}getEffectiveFOV(){return 2*Wut*Math.atan(Math.tan(.5*Gut*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,n,i,r,s){this.aspect=t/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(.5*Gut*this.fov)/this.zoom,n=2*e,i=this.aspect*n,r=-.5*i;const s=this.view;if(null!==this.view&&this.view.enabled){const t=s.fullWidth,o=s.fullHeight;r+=s.offsetX*i/t,e-=s.offsetY*n/o,i*=s.width/t,n*=s.height/o}const o=this.filmOffset;0!==o&&(r+=t*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,e,e-n,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}Spt.prototype.isPerspectiveCamera=!0;class Ept extends ddt{constructor(t,e,n){if(super(),this.type="CubeCamera",!0!==n.isWebGLCubeRenderTarget)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=n;const i=new Spt(90,1,t,e);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new uht(1,0,0)),this.add(i);const r=new Spt(90,1,t,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new uht(-1,0,0)),this.add(r);const s=new Spt(90,1,t,e);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(new uht(0,1,0)),this.add(s);const o=new Spt(90,1,t,e);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new uht(0,-1,0)),this.add(o);const a=new Spt(90,1,t,e);a.layers=this.layers,a.up.set(0,-1,0),a.lookAt(new uht(0,0,1)),this.add(a);const l=new Spt(90,1,t,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new uht(0,0,-1)),this.add(l)}update(t,e){null===this.parent&&this.updateMatrixWorld();const n=this.renderTarget,[i,r,s,o,a,l]=this.children,c=t.xr.enabled,u=t.getRenderTarget();t.xr.enabled=!1;const h=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,i),t.setRenderTarget(n,1),t.render(e,r),t.setRenderTarget(n,2),t.render(e,s),t.setRenderTarget(n,3),t.render(e,o),t.setRenderTarget(n,4),t.render(e,a),n.texture.generateMipmaps=h,t.setRenderTarget(n,5),t.render(e,l),t.setRenderTarget(u),t.xr.enabled=c}}class Cpt extends sht{constructor(t,e,n,i,r,s,o,a,l,c){super(t=void 0!==t?t:[],e=void 0!==e?e:301,n,i,r,s,o=void 0!==o?o:1022,a,l,c),this._needsFlipEnvMap=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}Cpt.prototype.isCubeTexture=!0;class Ipt extends lht{constructor(t,e,n){Number.isInteger(e)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),e=n),super(t,t,e),this.texture=new Cpt(void 0,(e=e||{}).mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.generateMipmaps=void 0!==e.generateMipmaps&&e.generateMipmaps,this.texture.minFilter=void 0!==e.minFilter?e.minFilter:1006,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.format=1023,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n=new vpt(5,5,5),i=new wpt({name:"CubemapFromEquirect",uniforms:bpt({tEquirect:{value:null}}),vertexShader:"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",side:1,blending:0});i.uniforms.tEquirect.value=e;const r=new gpt(n,i),s=e.minFilter;return 1008===e.minFilter&&(e.minFilter=1006),new Ept(1,10,this).update(t,r),e.minFilter=s,r.geometry.dispose(),r.material.dispose(),this}clear(t,e,n,i){const r=t.getRenderTarget();for(let s=0;s<6;s++)t.setRenderTarget(this,s),t.clear(e,n,i);t.setRenderTarget(r)}}Ipt.prototype.isWebGLCubeRenderTarget=!0;class Tpt extends sht{constructor(t,e,n,i,r,s,o,a,l,c,u,h){super(null,s,o,a,l,c,i,r,u,h),this.image={data:t||null,width:e||1,height:n||1},this.magFilter=void 0!==l?l:1003,this.minFilter=void 0!==c?c:1003,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Tpt.prototype.isDataTexture=!0;const Mpt=new Nht,kpt=new uht;class Rpt{constructor(t=new gdt,e=new gdt,n=new gdt,i=new gdt,r=new gdt,s=new gdt){this.planes=[t,e,n,i,r,s]}set(t,e,n,i,r,s){const o=this.planes;return o[0].copy(t),o[1].copy(e),o[2].copy(n),o[3].copy(i),o[4].copy(r),o[5].copy(s),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t){const e=this.planes,n=t.elements,i=n[0],r=n[1],s=n[2],o=n[3],a=n[4],l=n[5],c=n[6],u=n[7],h=n[8],d=n[9],p=n[10],f=n[11],m=n[12],g=n[13],y=n[14],v=n[15];return e[0].setComponents(o-i,u-a,f-h,v-m).normalize(),e[1].setComponents(o+i,u+a,f+h,v+m).normalize(),e[2].setComponents(o+r,u+l,f+d,v+g).normalize(),e[3].setComponents(o-r,u-l,f-d,v-g).normalize(),e[4].setComponents(o-s,u-c,f-p,v-y).normalize(),e[5].setComponents(o+s,u+c,f+p,v+y).normalize(),this}intersectsObject(t){const e=t.geometry;return null===e.boundingSphere&&e.computeBoundingSphere(),Mpt.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(Mpt)}intersectsSprite(t){return Mpt.center.set(0,0,0),Mpt.radius=.7071067811865476,Mpt.applyMatrix4(t.matrixWorld),this.intersectsSphere(Mpt)}intersectsSphere(t){const e=this.planes,n=t.center,i=-t.radius;for(let r=0;r<6;r++)if(e[r].distanceToPoint(n)<i)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const i=e[n];if(kpt.x=i.normal.x>0?t.max.x:t.min.x,kpt.y=i.normal.y>0?t.max.y:t.min.y,kpt.z=i.normal.z>0?t.max.z:t.min.z,i.distanceToPoint(kpt)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}function Npt(){let t=null,e=!1,n=null,i=null;function r(e,s){n(e,s),i=t.requestAnimationFrame(r)}return{start:function(){!0!==e&&null!==n&&(i=t.requestAnimationFrame(r),e=!0)},stop:function(){t.cancelAnimationFrame(i),e=!1},setAnimationLoop:function(t){n=t},setContext:function(e){t=e}}}function Lpt(t,e){const n=e.isWebGL2,i=new WeakMap;return{get:function(t){return t.isInterleavedBufferAttribute&&(t=t.data),i.get(t)},remove:function(e){e.isInterleavedBufferAttribute&&(e=e.data);const n=i.get(e);n&&(t.deleteBuffer(n.buffer),i.delete(e))},update:function(e,r){if(e.isGLBufferAttribute){const t=i.get(e);return void((!t||t.version<e.version)&&i.set(e,{buffer:e.buffer,type:e.type,bytesPerElement:e.elementSize,version:e.version}))}e.isInterleavedBufferAttribute&&(e=e.data);const s=i.get(e);void 0===s?i.set(e,function(e,i){const r=e.array,s=e.usage,o=t.createBuffer();t.bindBuffer(i,o),t.bufferData(i,r,s),e.onUploadCallback();let a=5126;return r instanceof Float32Array?a=5126:r instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):r instanceof Uint16Array?e.isFloat16BufferAttribute?n?a=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):a=5123:r instanceof Int16Array?a=5122:r instanceof Uint32Array?a=5125:r instanceof Int32Array?a=5124:r instanceof Int8Array?a=5120:r instanceof Uint8Array&&(a=5121),{buffer:o,type:a,bytesPerElement:r.BYTES_PER_ELEMENT,version:e.version}}(e,r)):s.version<e.version&&(function(e,i,r){const s=i.array,o=i.updateRange;t.bindBuffer(r,e),-1===o.count?t.bufferSubData(r,0,s):(n?t.bufferSubData(r,o.offset*s.BYTES_PER_ELEMENT,s,o.offset,o.count):t.bufferSubData(r,o.offset*s.BYTES_PER_ELEMENT,s.subarray(o.offset,o.offset+o.count)),o.count=-1)}(s.buffer,e,r),s.version=e.version)}}}class Dpt extends Jdt{constructor(t=1,e=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:i};const r=t/2,s=e/2,o=Math.floor(n),a=Math.floor(i),l=o+1,c=a+1,u=t/o,h=e/a,d=[],p=[],f=[],m=[];for(let g=0;g<c;g++){const t=g*h-s;for(let e=0;e<l;e++)p.push(e*u-r,-t,0),f.push(0,0,1),m.push(e/o),m.push(1-g/a)}for(let g=0;g<a;g++)for(let t=0;t<o;t++){const e=t+l*(g+1),n=t+1+l*(g+1),i=t+1+l*g;d.push(t+l*g,e,i),d.push(e,n,i)}this.setIndex(d),this.setAttribute("position",new Vdt(p,3)),this.setAttribute("normal",new Vdt(f,3)),this.setAttribute("uv",new Vdt(m,2))}}const Bpt={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmissionmap_fragment:"#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",transmissionmap_pars_fragment:"#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",normal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",normal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"},Opt={common:{diffuse:{value:new Odt(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new eht},uv2Transform:{value:new eht},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new tht(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Odt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Odt(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new eht}},sprite:{diffuse:{value:new Odt(15658734)},opacity:{value:1},center:{value:new tht(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new eht}}},Ppt={basic:{uniforms:Apt([Opt.common,Opt.specularmap,Opt.envmap,Opt.aomap,Opt.lightmap,Opt.fog]),vertexShader:Bpt.meshbasic_vert,fragmentShader:Bpt.meshbasic_frag},lambert:{uniforms:Apt([Opt.common,Opt.specularmap,Opt.envmap,Opt.aomap,Opt.lightmap,Opt.emissivemap,Opt.fog,Opt.lights,{emissive:{value:new Odt(0)}}]),vertexShader:Bpt.meshlambert_vert,fragmentShader:Bpt.meshlambert_frag},phong:{uniforms:Apt([Opt.common,Opt.specularmap,Opt.envmap,Opt.aomap,Opt.lightmap,Opt.emissivemap,Opt.bumpmap,Opt.normalmap,Opt.displacementmap,Opt.fog,Opt.lights,{emissive:{value:new Odt(0)},specular:{value:new Odt(1118481)},shininess:{value:30}}]),vertexShader:Bpt.meshphong_vert,fragmentShader:Bpt.meshphong_frag},standard:{uniforms:Apt([Opt.common,Opt.envmap,Opt.aomap,Opt.lightmap,Opt.emissivemap,Opt.bumpmap,Opt.normalmap,Opt.displacementmap,Opt.roughnessmap,Opt.metalnessmap,Opt.fog,Opt.lights,{emissive:{value:new Odt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Bpt.meshphysical_vert,fragmentShader:Bpt.meshphysical_frag},toon:{uniforms:Apt([Opt.common,Opt.aomap,Opt.lightmap,Opt.emissivemap,Opt.bumpmap,Opt.normalmap,Opt.displacementmap,Opt.gradientmap,Opt.fog,Opt.lights,{emissive:{value:new Odt(0)}}]),vertexShader:Bpt.meshtoon_vert,fragmentShader:Bpt.meshtoon_frag},matcap:{uniforms:Apt([Opt.common,Opt.bumpmap,Opt.normalmap,Opt.displacementmap,Opt.fog,{matcap:{value:null}}]),vertexShader:Bpt.meshmatcap_vert,fragmentShader:Bpt.meshmatcap_frag},points:{uniforms:Apt([Opt.points,Opt.fog]),vertexShader:Bpt.points_vert,fragmentShader:Bpt.points_frag},dashed:{uniforms:Apt([Opt.common,Opt.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Bpt.linedashed_vert,fragmentShader:Bpt.linedashed_frag},depth:{uniforms:Apt([Opt.common,Opt.displacementmap]),vertexShader:Bpt.depth_vert,fragmentShader:Bpt.depth_frag},normal:{uniforms:Apt([Opt.common,Opt.bumpmap,Opt.normalmap,Opt.displacementmap,{opacity:{value:1}}]),vertexShader:Bpt.normal_vert,fragmentShader:Bpt.normal_frag},sprite:{uniforms:Apt([Opt.sprite,Opt.fog]),vertexShader:Bpt.sprite_vert,fragmentShader:Bpt.sprite_frag},background:{uniforms:{uvTransform:{value:new eht},t2D:{value:null}},vertexShader:Bpt.background_vert,fragmentShader:Bpt.background_frag},cube:{uniforms:Apt([Opt.envmap,{opacity:{value:1}}]),vertexShader:Bpt.cube_vert,fragmentShader:Bpt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Bpt.equirect_vert,fragmentShader:Bpt.equirect_frag},distanceRGBA:{uniforms:Apt([Opt.common,Opt.displacementmap,{referencePosition:{value:new uht},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Bpt.distanceRGBA_vert,fragmentShader:Bpt.distanceRGBA_frag},shadow:{uniforms:Apt([Opt.lights,Opt.fog,{color:{value:new Odt(0)},opacity:{value:1}}]),vertexShader:Bpt.shadow_vert,fragmentShader:Bpt.shadow_frag}};function Fpt(t,e,n,i,r){const s=new Odt(0);let o,a,l=0,c=null,u=0,h=null;function d(t,e){n.buffers.color.setClear(t.r,t.g,t.b,e,r)}return{getClearColor:function(){return s},setClearColor:function(t,e=1){s.set(t),l=e,d(s,l)},getClearAlpha:function(){return l},setClearAlpha:function(t){l=t,d(s,l)},render:function(n,r,p,f){let m=!0===r.isScene?r.background:null;m&&m.isTexture&&(m=e.get(m));const g=t.xr,y=g.getSession&&g.getSession();y&&"additive"===y.environmentBlendMode&&(m=null),null===m?d(s,l):m&&m.isColor&&(d(m,1),f=!0),(t.autoClear||f)&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),m&&(m.isCubeTexture||306===m.mapping)?(void 0===a&&(a=new gpt(new vpt(1,1,1),new wpt({name:"BackgroundCubeMaterial",uniforms:bpt(Ppt.cube.uniforms),vertexShader:Ppt.cube.vertexShader,fragmentShader:Ppt.cube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),a.geometry.deleteAttribute("uv"),a.onBeforeRender=function(t,e,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(a.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(a)),a.material.uniforms.envMap.value=m,a.material.uniforms.flipEnvMap.value=m.isCubeTexture&&m._needsFlipEnvMap?-1:1,c===m&&u===m.version&&h===t.toneMapping||(a.material.needsUpdate=!0,c=m,u=m.version,h=t.toneMapping),n.unshift(a,a.geometry,a.material,0,0,null)):m&&m.isTexture&&(void 0===o&&(o=new gpt(new Dpt(2,2),new wpt({name:"BackgroundMaterial",uniforms:bpt(Ppt.background.uniforms),vertexShader:Ppt.background.vertexShader,fragmentShader:Ppt.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),Object.defineProperty(o.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(o)),o.material.uniforms.t2D.value=m,!0===m.matrixAutoUpdate&&m.updateMatrix(),o.material.uniforms.uvTransform.value.copy(m.matrix),c===m&&u===m.version&&h===t.toneMapping||(o.material.needsUpdate=!0,c=m,u=m.version,h=t.toneMapping),n.unshift(o,o.geometry,o.material,0,0,null))}}}function $pt(t,e,n,i){const r=t.getParameter(34921),s=i.isWebGL2?null:e.get("OES_vertex_array_object"),o=i.isWebGL2||null!==s,a={},l=d(null);let c=l;function u(e){return i.isWebGL2?t.bindVertexArray(e):s.bindVertexArrayOES(e)}function h(e){return i.isWebGL2?t.deleteVertexArray(e):s.deleteVertexArrayOES(e)}function d(t){const e=[],n=[],i=[];for(let s=0;s<r;s++)e[s]=0,n[s]=0,i[s]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:e,enabledAttributes:n,attributeDivisors:i,object:t,attributes:{},index:null}}function p(){const t=c.newAttributes;for(let e=0,n=t.length;e<n;e++)t[e]=0}function f(t){m(t,0)}function m(n,r){const s=c.enabledAttributes,o=c.attributeDivisors;c.newAttributes[n]=1,0===s[n]&&(t.enableVertexAttribArray(n),s[n]=1),o[n]!==r&&((i.isWebGL2?t:e.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](n,r),o[n]=r)}function g(){const e=c.newAttributes,n=c.enabledAttributes;for(let i=0,r=n.length;i<r;i++)n[i]!==e[i]&&(t.disableVertexAttribArray(i),n[i]=0)}function y(e,n,r,s,o,a){!0!==i.isWebGL2||5124!==r&&5125!==r?t.vertexAttribPointer(e,n,r,s,o,a):t.vertexAttribIPointer(e,n,r,o,a)}function v(){b(),c!==l&&(c=l,u(c.object))}function b(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:function(r,l,h,v,b){let A=!1;if(o){const e=function(e,n,r){const o=!0===r.wireframe;let l=a[e.id];void 0===l&&(l={},a[e.id]=l);let c=l[n.id];void 0===c&&(c={},l[n.id]=c);let u=c[o];return void 0===u&&(u=d(i.isWebGL2?t.createVertexArray():s.createVertexArrayOES()),c[o]=u),u}(v,h,l);c!==e&&(c=e,u(c.object)),A=function(t,e){const n=c.attributes,i=t.attributes;let r=0;for(const s in i){const t=n[s],e=i[s];if(void 0===t)return!0;if(t.attribute!==e)return!0;if(t.data!==e.data)return!0;r++}return c.attributesNum!==r||c.index!==e}(v,b),A&&function(t,e){const n={},i=t.attributes;let r=0;for(const s in i){const t=i[s],e={};e.attribute=t,t.data&&(e.data=t.data),n[s]=e,r++}c.attributes=n,c.attributesNum=r,c.index=e}(v,b)}else{const t=!0===l.wireframe;c.geometry===v.id&&c.program===h.id&&c.wireframe===t||(c.geometry=v.id,c.program=h.id,c.wireframe=t,A=!0)}!0===r.isInstancedMesh&&(A=!0),null!==b&&n.update(b,34963),A&&(function(r,s,o,a){if(!1===i.isWebGL2&&(r.isInstancedMesh||a.isInstancedBufferGeometry)&&null===e.get("ANGLE_instanced_arrays"))return;p();const l=a.attributes,c=o.getAttributes(),u=s.defaultAttributeValues;for(const e in c){const i=c[e];if(i>=0){const s=l[e];if(void 0!==s){const e=s.normalized,r=s.itemSize,o=n.get(s);if(void 0===o)continue;const l=o.buffer,c=o.type,u=o.bytesPerElement;if(s.isInterleavedBufferAttribute){const n=s.data,o=n.stride,h=s.offset;n&&n.isInstancedInterleavedBuffer?(m(i,n.meshPerAttribute),void 0===a._maxInstanceCount&&(a._maxInstanceCount=n.meshPerAttribute*n.count)):f(i),t.bindBuffer(34962,l),y(i,r,c,e,o*u,h*u)}else s.isInstancedBufferAttribute?(m(i,s.meshPerAttribute),void 0===a._maxInstanceCount&&(a._maxInstanceCount=s.meshPerAttribute*s.count)):f(i),t.bindBuffer(34962,l),y(i,r,c,e,0,0)}else if("instanceMatrix"===e){const e=n.get(r.instanceMatrix);if(void 0===e)continue;const s=e.buffer,o=e.type;m(i+0,1),m(i+1,1),m(i+2,1),m(i+3,1),t.bindBuffer(34962,s),t.vertexAttribPointer(i+0,4,o,!1,64,0),t.vertexAttribPointer(i+1,4,o,!1,64,16),t.vertexAttribPointer(i+2,4,o,!1,64,32),t.vertexAttribPointer(i+3,4,o,!1,64,48)}else if("instanceColor"===e){const e=n.get(r.instanceColor);if(void 0===e)continue;const s=e.buffer,o=e.type;m(i,1),t.bindBuffer(34962,s),t.vertexAttribPointer(i,3,o,!1,12,0)}else if(void 0!==u){const n=u[e];if(void 0!==n)switch(n.length){case 2:t.vertexAttrib2fv(i,n);break;case 3:t.vertexAttrib3fv(i,n);break;case 4:t.vertexAttrib4fv(i,n);break;default:t.vertexAttrib1fv(i,n)}}}}g()}(r,l,h,v),null!==b&&t.bindBuffer(34963,n.get(b).buffer))},reset:v,resetDefaultState:b,dispose:function(){v();for(const t in a){const e=a[t];for(const t in e){const n=e[t];for(const t in n)h(n[t].object),delete n[t];delete e[t]}delete a[t]}},releaseStatesOfGeometry:function(t){if(void 0===a[t.id])return;const e=a[t.id];for(const n in e){const t=e[n];for(const e in t)h(t[e].object),delete t[e];delete e[n]}delete a[t.id]},releaseStatesOfProgram:function(t){for(const e in a){const n=a[e];if(void 0===n[t.id])continue;const i=n[t.id];for(const t in i)h(i[t].object),delete i[t];delete n[t.id]}},initAttributes:p,enableAttribute:f,disableUnusedAttributes:g}}function zpt(t,e,n,i){const r=i.isWebGL2;let s;this.setMode=function(t){s=t},this.render=function(e,i){t.drawArrays(s,e,i),n.update(i,s,1)},this.renderInstances=function(i,o,a){if(0===a)return;let l,c;if(r)l=t,c="drawArraysInstanced";else if(l=e.get("ANGLE_instanced_arrays"),c="drawArraysInstancedANGLE",null===l)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");l[c](s,i,o,a),n.update(o,s,a)}}function Upt(t,e,n){let i;function r(e){if("highp"===e){if(t.getShaderPrecisionFormat(35633,36338).precision>0&&t.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";e="mediump"}return"mediump"===e&&t.getShaderPrecisionFormat(35633,36337).precision>0&&t.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const s="undefined"!=typeof WebGL2RenderingContext&&t instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&t instanceof WebGL2ComputeRenderingContext;let o=void 0!==n.precision?n.precision:"highp";const a=r(o);a!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",a,"instead."),o=a);const l=!0===n.logarithmicDepthBuffer,c=t.getParameter(34930),u=t.getParameter(35660),h=t.getParameter(3379),d=t.getParameter(34076),p=t.getParameter(34921),f=t.getParameter(36347),m=t.getParameter(36348),g=t.getParameter(36349),y=u>0,v=s||e.has("OES_texture_float");return{isWebGL2:s,getMaxAnisotropy:function(){if(void 0!==i)return i;if(!0===e.has("EXT_texture_filter_anisotropic")){const n=e.get("EXT_texture_filter_anisotropic");i=t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i},getMaxPrecision:r,precision:o,logarithmicDepthBuffer:l,maxTextures:c,maxVertexTextures:u,maxTextureSize:h,maxCubemapSize:d,maxAttributes:p,maxVertexUniforms:f,maxVaryings:m,maxFragmentUniforms:g,vertexTextures:y,floatFragmentTextures:v,floatVertexTextures:y&&v,maxSamples:s?t.getParameter(36183):0}}function Hpt(t){const e=this;let n=null,i=0,r=!1,s=!1;const o=new gdt,a=new eht,l={value:null,needsUpdate:!1};function c(){l.value!==n&&(l.value=n,l.needsUpdate=i>0),e.numPlanes=i,e.numIntersection=0}function u(t,n,i,r){const s=null!==t?t.length:0;let c=null;if(0!==s){if(c=l.value,!0!==r||null===c){const e=i+4*s,r=n.matrixWorldInverse;a.getNormalMatrix(r),(null===c||c.length<e)&&(c=new Float32Array(e));for(let n=0,l=i;n!==s;++n,l+=4)o.copy(t[n]).applyMatrix4(r,a),o.normal.toArray(c,l),c[l+3]=o.constant}l.value=c,l.needsUpdate=!0}return e.numPlanes=s,e.numIntersection=0,c}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(t,e,s){const o=0!==t.length||e||0!==i||r;return r=e,n=u(t,s,0),i=t.length,o},this.beginShadows=function(){s=!0,u(null)},this.endShadows=function(){s=!1,c()},this.setState=function(e,o,a){const h=e.clippingPlanes,d=e.clipIntersection,p=e.clipShadows,f=t.get(e);if(!r||null===h||0===h.length||s&&!p)s?u(null):c();else{const t=s?0:i,e=4*t;let r=f.clippingState||null;l.value=r,r=u(h,o,e,a);for(let i=0;i!==e;++i)r[i]=n[i];f.clippingState=r,this.numIntersection=d?this.numPlanes:0,this.numPlanes+=t}}}function Vpt(t){let e=new WeakMap;function n(t,e){return 303===e?t.mapping=301:304===e&&(t.mapping=302),t}function i(t){const n=t.target;n.removeEventListener("dispose",i);const r=e.get(n);void 0!==r&&(e.delete(n),r.dispose())}return{get:function(r){if(r&&r.isTexture){const s=r.mapping;if(303===s||304===s){if(e.has(r))return n(e.get(r).texture,r.mapping);{const s=r.image;if(s&&s.height>0){const o=t.getRenderTarget(),a=new Ipt(s.height/2);return a.fromEquirectangularTexture(t,r),e.set(r,a),t.setRenderTarget(o),r.addEventListener("dispose",i),n(a.texture,r.mapping)}return null}}}return r},dispose:function(){e=new WeakMap}}}function Gpt(t){const e={};function n(n){if(void 0!==e[n])return e[n];let i;switch(n){case"WEBGL_depth_texture":i=t.getExtension("WEBGL_depth_texture")||t.getExtension("MOZ_WEBGL_depth_texture")||t.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=t.getExtension("WEBGL_compressed_texture_s3tc")||t.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=t.getExtension("WEBGL_compressed_texture_pvrtc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=t.getExtension(n)}return e[n]=i,i}return{has:function(t){return null!==n(t)},init:function(t){t.isWebGL2?n("EXT_color_buffer_float"):(n("WEBGL_depth_texture"),n("OES_texture_float"),n("OES_texture_half_float"),n("OES_texture_half_float_linear"),n("OES_standard_derivatives"),n("OES_element_index_uint"),n("OES_vertex_array_object"),n("ANGLE_instanced_arrays")),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float")},get:function(t){const e=n(t);return null===e&&console.warn("THREE.WebGLRenderer: "+t+" extension not supported."),e}}}function Wpt(t,e,n,i){const r={},s=new WeakMap;function o(t){const a=t.target;null!==a.index&&e.remove(a.index);for(const n in a.attributes)e.remove(a.attributes[n]);a.removeEventListener("dispose",o),delete r[a.id];const l=s.get(a);l&&(e.remove(l),s.delete(a)),i.releaseStatesOfGeometry(a),!0===a.isInstancedBufferGeometry&&delete a._maxInstanceCount,n.memory.geometries--}function a(t){const n=[],i=t.index,r=t.attributes.position;let o=0;if(null!==i){const t=i.array;o=i.version;for(let e=0,i=t.length;e<i;e+=3){const i=t[e+0],r=t[e+1],s=t[e+2];n.push(i,r,r,s,s,i)}}else{o=r.version;for(let t=0,e=r.array.length/3-1;t<e;t+=3){const e=t+0,i=t+1,r=t+2;n.push(e,i,i,r,r,e)}}const a=new(Gdt(n)>65535?Hdt:Udt)(n,1);a.version=o;const l=s.get(t);l&&e.remove(l),s.set(t,a)}return{get:function(t,e){return!0===r[e.id]||(e.addEventListener("dispose",o),r[e.id]=!0,n.memory.geometries++),e},update:function(t){const n=t.attributes;for(const r in n)e.update(n[r],34962);const i=t.morphAttributes;for(const r in i){const t=i[r];for(let n=0,i=t.length;n<i;n++)e.update(t[n],34962)}},getWireframeAttribute:function(t){const e=s.get(t);if(e){const n=t.index;null!==n&&e.version<n.version&&a(t)}else a(t);return s.get(t)}}}function jpt(t,e,n,i){const r=i.isWebGL2;let s,o,a;this.setMode=function(t){s=t},this.setIndex=function(t){o=t.type,a=t.bytesPerElement},this.render=function(e,i){t.drawElements(s,i,o,e*a),n.update(i,s,1)},this.renderInstances=function(i,l,c){if(0===c)return;let u,h;if(r)u=t,h="drawElementsInstanced";else if(u=e.get("ANGLE_instanced_arrays"),h="drawElementsInstancedANGLE",null===u)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");u[h](s,l,o,i*a,c),n.update(l,s,c)}}function Qpt(t){const e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(t,n,i){switch(e.calls++,n){case 4:e.triangles+=i*(t/3);break;case 1:e.lines+=i*(t/2);break;case 3:e.lines+=i*(t-1);break;case 2:e.lines+=i*t;break;case 0:e.points+=i*t;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",n)}}}}function qpt(t,e){return t[0]-e[0]}function Xpt(t,e){return Math.abs(e[1])-Math.abs(t[1])}function Ypt(t){const e={},n=new Float32Array(8),i=[];for(let r=0;r<8;r++)i[r]=[r,0];return{update:function(r,s,o,a){const l=r.morphTargetInfluences,c=void 0===l?0:l.length;let u=e[s.id];if(void 0===u){u=[];for(let t=0;t<c;t++)u[t]=[t,0];e[s.id]=u}for(let t=0;t<c;t++){const e=u[t];e[0]=t,e[1]=l[t]}u.sort(Xpt);for(let t=0;t<8;t++)t<c&&u[t][1]?(i[t][0]=u[t][0],i[t][1]=u[t][1]):(i[t][0]=Number.MAX_SAFE_INTEGER,i[t][1]=0);i.sort(qpt);const h=o.morphTargets&&s.morphAttributes.position,d=o.morphNormals&&s.morphAttributes.normal;let p=0;for(let t=0;t<8;t++){const e=i[t],r=e[0],o=e[1];r!==Number.MAX_SAFE_INTEGER&&o?(h&&s.getAttribute("morphTarget"+t)!==h[r]&&s.setAttribute("morphTarget"+t,h[r]),d&&s.getAttribute("morphNormal"+t)!==d[r]&&s.setAttribute("morphNormal"+t,d[r]),n[t]=o,p+=o):(h&&!0===s.hasAttribute("morphTarget"+t)&&s.deleteAttribute("morphTarget"+t),d&&!0===s.hasAttribute("morphNormal"+t)&&s.deleteAttribute("morphNormal"+t),n[t]=0)}const f=s.morphTargetsRelative?1:1-p;a.getUniforms().setValue(t,"morphTargetBaseInfluence",f),a.getUniforms().setValue(t,"morphTargetInfluences",n)}}}function Kpt(t,e,n,i){let r=new WeakMap;function s(t){const e=t.target;e.removeEventListener("dispose",s),n.remove(e.instanceMatrix),null!==e.instanceColor&&n.remove(e.instanceColor)}return{update:function(t){const o=i.render.frame,a=e.get(t,t.geometry);return r.get(a)!==o&&(e.update(a),r.set(a,o)),t.isInstancedMesh&&(!1===t.hasEventListener("dispose",s)&&t.addEventListener("dispose",s),n.update(t.instanceMatrix,34962),null!==t.instanceColor&&n.update(t.instanceColor,34962)),a},dispose:function(){r=new WeakMap}}}Ppt.physical={uniforms:Apt([Ppt.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new tht(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new Odt(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:Bpt.meshphysical_vert,fragmentShader:Bpt.meshphysical_frag};class Jpt extends sht{constructor(t=null,e=1,n=1,i=1){super(null),this.image={data:t,width:e,height:n,depth:i},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Jpt.prototype.isDataTexture2DArray=!0;class Zpt extends sht{constructor(t=null,e=1,n=1,i=1){super(null),this.image={data:t,width:e,height:n,depth:i},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Zpt.prototype.isDataTexture3D=!0;const tft=new sht,eft=new Jpt,nft=new Zpt,ift=new Cpt,rft=[],sft=[],oft=new Float32Array(16),aft=new Float32Array(9),lft=new Float32Array(4);function cft(t,e,n){const i=t[0];if(i<=0||i>0)return t;const r=e*n;let s=rft[r];if(void 0===s&&(s=new Float32Array(r),rft[r]=s),0!==e){i.toArray(s,0);for(let i=1,r=0;i!==e;++i)r+=n,t[i].toArray(s,r)}return s}function uft(t,e){if(t.length!==e.length)return!1;for(let n=0,i=t.length;n<i;n++)if(t[n]!==e[n])return!1;return!0}function hft(t,e){for(let n=0,i=e.length;n<i;n++)t[n]=e[n]}function dft(t,e){let n=sft[e];void 0===n&&(n=new Int32Array(e),sft[e]=n);for(let i=0;i!==e;++i)n[i]=t.allocateTextureUnit();return n}function pft(t,e){const n=this.cache;n[0]!==e&&(t.uniform1f(this.addr,e),n[0]=e)}function fft(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2f(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(uft(n,e))return;t.uniform2fv(this.addr,e),hft(n,e)}}function mft(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3f(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else if(void 0!==e.r)n[0]===e.r&&n[1]===e.g&&n[2]===e.b||(t.uniform3f(this.addr,e.r,e.g,e.b),n[0]=e.r,n[1]=e.g,n[2]=e.b);else{if(uft(n,e))return;t.uniform3fv(this.addr,e),hft(n,e)}}function gft(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4f(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(uft(n,e))return;t.uniform4fv(this.addr,e),hft(n,e)}}function yft(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(uft(n,e))return;t.uniformMatrix2fv(this.addr,!1,e),hft(n,e)}else{if(uft(n,i))return;lft.set(i),t.uniformMatrix2fv(this.addr,!1,lft),hft(n,i)}}function vft(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(uft(n,e))return;t.uniformMatrix3fv(this.addr,!1,e),hft(n,e)}else{if(uft(n,i))return;aft.set(i),t.uniformMatrix3fv(this.addr,!1,aft),hft(n,i)}}function bft(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(uft(n,e))return;t.uniformMatrix4fv(this.addr,!1,e),hft(n,e)}else{if(uft(n,i))return;oft.set(i),t.uniformMatrix4fv(this.addr,!1,oft),hft(n,i)}}function Aft(t,e){const n=this.cache;n[0]!==e&&(t.uniform1i(this.addr,e),n[0]=e)}function xft(t,e){const n=this.cache;uft(n,e)||(t.uniform2iv(this.addr,e),hft(n,e))}function wft(t,e){const n=this.cache;uft(n,e)||(t.uniform3iv(this.addr,e),hft(n,e))}function _ft(t,e){const n=this.cache;uft(n,e)||(t.uniform4iv(this.addr,e),hft(n,e))}function Sft(t,e){const n=this.cache;n[0]!==e&&(t.uniform1ui(this.addr,e),n[0]=e)}function Eft(t,e){const n=this.cache;uft(n,e)||(t.uniform2uiv(this.addr,e),hft(n,e))}function Cft(t,e){const n=this.cache;uft(n,e)||(t.uniform3uiv(this.addr,e),hft(n,e))}function Ift(t,e){const n=this.cache;uft(n,e)||(t.uniform4uiv(this.addr,e),hft(n,e))}function Tft(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.safeSetTexture2D(e||tft,r)}function Mft(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTexture3D(e||nft,r)}function kft(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.safeSetTextureCube(e||ift,r)}function Rft(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTexture2DArray(e||eft,r)}function Nft(t,e){t.uniform1fv(this.addr,e)}function Lft(t,e){const n=cft(e,this.size,2);t.uniform2fv(this.addr,n)}function Dft(t,e){const n=cft(e,this.size,3);t.uniform3fv(this.addr,n)}function Bft(t,e){const n=cft(e,this.size,4);t.uniform4fv(this.addr,n)}function Oft(t,e){const n=cft(e,this.size,4);t.uniformMatrix2fv(this.addr,!1,n)}function Pft(t,e){const n=cft(e,this.size,9);t.uniformMatrix3fv(this.addr,!1,n)}function Fft(t,e){const n=cft(e,this.size,16);t.uniformMatrix4fv(this.addr,!1,n)}function $ft(t,e){t.uniform1iv(this.addr,e)}function zft(t,e){t.uniform2iv(this.addr,e)}function Uft(t,e){t.uniform3iv(this.addr,e)}function Hft(t,e){t.uniform4iv(this.addr,e)}function Vft(t,e){t.uniform1uiv(this.addr,e)}function Gft(t,e){t.uniform2uiv(this.addr,e)}function Wft(t,e){t.uniform3uiv(this.addr,e)}function jft(t,e){t.uniform4uiv(this.addr,e)}function Qft(t,e,n){const i=e.length,r=dft(n,i);t.uniform1iv(this.addr,r);for(let s=0;s!==i;++s)n.safeSetTexture2D(e[s]||tft,r[s])}function qft(t,e,n){const i=e.length,r=dft(n,i);t.uniform1iv(this.addr,r);for(let s=0;s!==i;++s)n.safeSetTextureCube(e[s]||ift,r[s])}function Xft(t,e,n){this.id=t,this.addr=n,this.cache=[],this.setValue=function(t){switch(t){case 5126:return pft;case 35664:return fft;case 35665:return mft;case 35666:return gft;case 35674:return yft;case 35675:return vft;case 35676:return bft;case 5124:case 35670:return Aft;case 35667:case 35671:return xft;case 35668:case 35672:return wft;case 35669:case 35673:return _ft;case 5125:return Sft;case 36294:return Eft;case 36295:return Cft;case 36296:return Ift;case 35678:case 36198:case 36298:case 36306:case 35682:return Tft;case 35679:case 36299:case 36307:return Mft;case 35680:case 36300:case 36308:case 36293:return kft;case 36289:case 36303:case 36311:case 36292:return Rft}}(e.type)}function Yft(t,e,n){this.id=t,this.addr=n,this.cache=[],this.size=e.size,this.setValue=function(t){switch(t){case 5126:return Nft;case 35664:return Lft;case 35665:return Dft;case 35666:return Bft;case 35674:return Oft;case 35675:return Pft;case 35676:return Fft;case 5124:case 35670:return $ft;case 35667:case 35671:return zft;case 35668:case 35672:return Uft;case 35669:case 35673:return Hft;case 5125:return Vft;case 36294:return Gft;case 36295:return Wft;case 36296:return jft;case 35678:case 36198:case 36298:case 36306:case 35682:return Qft;case 35680:case 36300:case 36308:case 36293:return qft}}(e.type)}function Kft(t){this.id=t,this.seq=[],this.map={}}Yft.prototype.updateCache=function(t){const e=this.cache;t instanceof Float32Array&&e.length!==t.length&&(this.cache=new Float32Array(t.length)),hft(e,t)},Kft.prototype.setValue=function(t,e,n){const i=this.seq;for(let r=0,s=i.length;r!==s;++r){const s=i[r];s.setValue(t,e[s.id],n)}};const Jft=/(\w+)(\])?(\[|\.)?/g;function Zft(t,e){t.seq.push(e),t.map[e.id]=e}function tmt(t,e,n){const i=t.name,r=i.length;for(Jft.lastIndex=0;;){const s=Jft.exec(i),o=Jft.lastIndex;let a=s[1];const l=s[3];if("]"===s[2]&&(a|=0),void 0===l||"["===l&&o+2===r){Zft(n,void 0===l?new Xft(a,t,e):new Yft(a,t,e));break}{let t=n.map[a];void 0===t&&(t=new Kft(a),Zft(n,t)),n=t}}}function emt(t,e){this.seq=[],this.map={};const n=t.getProgramParameter(e,35718);for(let i=0;i<n;++i){const n=t.getActiveUniform(e,i);tmt(n,t.getUniformLocation(e,n.name),this)}}function nmt(t,e,n){const i=t.createShader(e);return t.shaderSource(i,n),t.compileShader(i),i}emt.prototype.setValue=function(t,e,n,i){const r=this.map[e];void 0!==r&&r.setValue(t,n,i)},emt.prototype.setOptional=function(t,e,n){const i=e[n];void 0!==i&&this.setValue(t,n,i)},emt.upload=function(t,e,n,i){for(let r=0,s=e.length;r!==s;++r){const s=e[r],o=n[s.id];!1!==o.needsUpdate&&s.setValue(t,o.value,i)}},emt.seqWithValue=function(t,e){const n=[];for(let i=0,r=t.length;i!==r;++i){const r=t[i];r.id in e&&n.push(r)}return n};let imt=0;function rmt(t){switch(t){case 3e3:return["Linear","( value )"];case 3001:return["sRGB","( value )"];case 3002:return["RGBE","( value )"];case 3004:return["RGBM","( value, 7.0 )"];case 3005:return["RGBM","( value, 16.0 )"];case 3006:return["RGBD","( value, 256.0 )"];case 3007:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case 3003:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",t),["Linear","( value )"]}}function smt(t,e,n){const i=t.getShaderParameter(e,35713),r=t.getShaderInfoLog(e).trim();return i&&""===r?"":"THREE.WebGLShader: gl.getShaderInfoLog() "+n+"\n"+r+function(t){const e=t.split("\n");for(let n=0;n<e.length;n++)e[n]=n+1+": "+e[n];return e.join("\n")}(t.getShaderSource(e))}function omt(t,e){const n=rmt(e);return"vec4 "+t+"( vec4 value ) { return "+n[0]+"ToLinear"+n[1]+"; }"}function amt(t,e){const n=rmt(e);return"vec4 "+t+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function lmt(t,e){let n;switch(e){case 1:n="Linear";break;case 2:n="Reinhard";break;case 3:n="OptimizedCineon";break;case 4:n="ACESFilmic";break;case 5:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),n="Linear"}return"vec3 "+t+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function cmt(t){return""!==t}function umt(t,e){return t.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function hmt(t,e){return t.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const dmt=/^[ \t]*#include +<([\w\d./]+)>/gm;function pmt(t){return t.replace(dmt,fmt)}function fmt(t,e){const n=Bpt[e];if(void 0===n)throw new Error("Can not resolve #include <"+e+">");return pmt(n)}const mmt=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,gmt=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function ymt(t){return t.replace(gmt,bmt).replace(mmt,vmt)}function vmt(t,e,n,i){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),bmt(0,e,n,i)}function bmt(t,e,n,i){let r="";for(let s=parseInt(e);s<parseInt(n);s++)r+=i.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return r}function Amt(t){let e="precision "+t.precision+" float;\nprecision "+t.precision+" int;";return"highp"===t.precision?e+="\n#define HIGH_PRECISION":"mediump"===t.precision?e+="\n#define MEDIUM_PRECISION":"lowp"===t.precision&&(e+="\n#define LOW_PRECISION"),e}function xmt(t,e,n,i){const r=t.getContext(),s=n.defines;let o=n.vertexShader,a=n.fragmentShader;const l=function(t){let e="SHADOWMAP_TYPE_BASIC";return 1===t.shadowMapType?e="SHADOWMAP_TYPE_PCF":2===t.shadowMapType?e="SHADOWMAP_TYPE_PCF_SOFT":3===t.shadowMapType&&(e="SHADOWMAP_TYPE_VSM"),e}(n),c=function(t){let e="ENVMAP_TYPE_CUBE";if(t.envMap)switch(t.envMapMode){case 301:case 302:e="ENVMAP_TYPE_CUBE";break;case 306:case 307:e="ENVMAP_TYPE_CUBE_UV"}return e}(n),u=function(t){let e="ENVMAP_MODE_REFLECTION";if(t.envMap)switch(t.envMapMode){case 302:case 307:e="ENVMAP_MODE_REFRACTION"}return e}(n),h=function(t){let e="ENVMAP_BLENDING_NONE";if(t.envMap)switch(t.combine){case 0:e="ENVMAP_BLENDING_MULTIPLY";break;case 1:e="ENVMAP_BLENDING_MIX";break;case 2:e="ENVMAP_BLENDING_ADD"}return e}(n),d=t.gammaFactor>0?t.gammaFactor:1,p=n.isWebGL2?"":function(t){return[t.extensionDerivatives||t.envMapCubeUV||t.bumpMap||t.tangentSpaceNormalMap||t.clearcoatNormalMap||t.flatShading||"physical"===t.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(t.extensionFragDepth||t.logarithmicDepthBuffer)&&t.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",t.extensionDrawBuffers&&t.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(t.extensionShaderTextureLOD||t.envMap)&&t.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(cmt).join("\n")}(n),f=function(t){const e=[];for(const n in t){const i=t[n];!1!==i&&e.push("#define "+n+" "+i)}return e.join("\n")}(s),m=r.createProgram();let g,y,v=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(g=[f].filter(cmt).join("\n"),g.length>0&&(g+="\n"),y=[p,f].filter(cmt).join("\n"),y.length>0&&(y+="\n")):(g=[Amt(n),"#define SHADER_NAME "+n.shaderName,f,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+d,"#define MAX_BONES "+n.maxBones,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+u:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.useVertexTexture?"#define BONE_TEXTURE":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(cmt).join("\n"),y=[p,Amt(n),"#define SHADER_NAME "+n.shaderName,f,n.alphaTest?"#define ALPHATEST "+n.alphaTest+(n.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+d,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+c:"",n.envMap?"#define "+u:"",n.envMap?"#define "+h:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.sheen?"#define USE_SHEEN":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==n.toneMapping?"#define TONE_MAPPING":"",0!==n.toneMapping?Bpt.tonemapping_pars_fragment:"",0!==n.toneMapping?lmt("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",Bpt.encodings_pars_fragment,n.map?omt("mapTexelToLinear",n.mapEncoding):"",n.matcap?omt("matcapTexelToLinear",n.matcapEncoding):"",n.envMap?omt("envMapTexelToLinear",n.envMapEncoding):"",n.emissiveMap?omt("emissiveMapTexelToLinear",n.emissiveMapEncoding):"",n.lightMap?omt("lightMapTexelToLinear",n.lightMapEncoding):"",amt("linearToOutputTexel",n.outputEncoding),n.depthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(cmt).join("\n")),o=pmt(o),o=umt(o,n),o=hmt(o,n),a=pmt(a),a=umt(a,n),a=hmt(a,n),o=ymt(o),a=ymt(a),n.isWebGL2&&!0!==n.isRawShaderMaterial&&(v="#version 300 es\n",g=["#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+g,y=["#define varying in","300 es"===n.glslVersion?"":"out highp vec4 pc_fragColor;","300 es"===n.glslVersion?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+y);const b=v+y+a,A=nmt(r,35633,v+g+o),x=nmt(r,35632,b);if(r.attachShader(m,A),r.attachShader(m,x),void 0!==n.index0AttributeName?r.bindAttribLocation(m,0,n.index0AttributeName):!0===n.morphTargets&&r.bindAttribLocation(m,0,"position"),r.linkProgram(m),t.debug.checkShaderErrors){const t=r.getProgramInfoLog(m).trim(),e=r.getShaderInfoLog(A).trim(),n=r.getShaderInfoLog(x).trim();let i=!0,s=!0;if(!1===r.getProgramParameter(m,35714)){i=!1;const e=smt(r,A,"vertex"),n=smt(r,x,"fragment");console.error("THREE.WebGLProgram: shader error: ",r.getError(),"35715",r.getProgramParameter(m,35715),"gl.getProgramInfoLog",t,e,n)}else""!==t?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",t):""!==e&&""!==n||(s=!1);s&&(this.diagnostics={runnable:i,programLog:t,vertexShader:{log:e,prefix:g},fragmentShader:{log:n,prefix:y}})}let w,_;return r.deleteShader(A),r.deleteShader(x),this.getUniforms=function(){return void 0===w&&(w=new emt(r,m)),w},this.getAttributes=function(){return void 0===_&&(_=function(t,e){const n={},i=t.getProgramParameter(e,35721);for(let r=0;r<i;r++){const i=t.getActiveAttrib(e,r).name;n[i]=t.getAttribLocation(e,i)}return n}(r,m)),_},this.destroy=function(){i.releaseStatesOfProgram(this),r.deleteProgram(m),this.program=void 0},this.name=n.shaderName,this.id=imt++,this.cacheKey=e,this.usedTimes=1,this.program=m,this.vertexShader=A,this.fragmentShader=x,this}function wmt(t,e,n,i,r,s){const o=[],a=i.isWebGL2,l=i.logarithmicDepthBuffer,c=i.floatVertexTextures,u=i.maxVertexUniforms,h=i.vertexTextures;let d=i.precision;const p={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},f=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function m(t){let e;return t&&t.isTexture?e=t.encoding:t&&t.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),e=t.texture.encoding):e=3e3,e}return{getParameters:function(r,o,f,g,y){const v=g.fog,b=e.get(r.envMap||(r.isMeshStandardMaterial?g.environment:null)),A=p[r.type],x=y.isSkinnedMesh?function(t){const e=t.skeleton.bones;if(c)return 1024;{const t=Math.floor((u-20)/4),n=Math.min(t,e.length);return n<e.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+e.length+" bones. This GPU supports "+n+"."),0):n}}(y):0;let w,_;if(null!==r.precision&&(d=i.getMaxPrecision(r.precision),d!==r.precision&&console.warn("THREE.WebGLProgram.getParameters:",r.precision,"not supported, using",d,"instead.")),A){const t=Ppt[A];w=t.vertexShader,_=t.fragmentShader}else w=r.vertexShader,_=r.fragmentShader;const S=t.getRenderTarget();return{isWebGL2:a,shaderID:A,shaderName:r.type,vertexShader:w,fragmentShader:_,defines:r.defines,isRawShaderMaterial:!0===r.isRawShaderMaterial,glslVersion:r.glslVersion,precision:d,instancing:!0===y.isInstancedMesh,instancingColor:!0===y.isInstancedMesh&&null!==y.instanceColor,supportsVertexTextures:h,outputEncoding:null!==S?m(S.texture):t.outputEncoding,map:!!r.map,mapEncoding:m(r.map),matcap:!!r.matcap,matcapEncoding:m(r.matcap),envMap:!!b,envMapMode:b&&b.mapping,envMapEncoding:m(b),envMapCubeUV:!!b&&(306===b.mapping||307===b.mapping),lightMap:!!r.lightMap,lightMapEncoding:m(r.lightMap),aoMap:!!r.aoMap,emissiveMap:!!r.emissiveMap,emissiveMapEncoding:m(r.emissiveMap),bumpMap:!!r.bumpMap,normalMap:!!r.normalMap,objectSpaceNormalMap:1===r.normalMapType,tangentSpaceNormalMap:0===r.normalMapType,clearcoatMap:!!r.clearcoatMap,clearcoatRoughnessMap:!!r.clearcoatRoughnessMap,clearcoatNormalMap:!!r.clearcoatNormalMap,displacementMap:!!r.displacementMap,roughnessMap:!!r.roughnessMap,metalnessMap:!!r.metalnessMap,specularMap:!!r.specularMap,alphaMap:!!r.alphaMap,gradientMap:!!r.gradientMap,sheen:!!r.sheen,transmissionMap:!!r.transmissionMap,combine:r.combine,vertexTangents:r.normalMap&&r.vertexTangents,vertexColors:r.vertexColors,vertexAlphas:!0===r.vertexColors&&y.geometry&&y.geometry.attributes.color&&4===y.geometry.attributes.color.itemSize,vertexUvs:!!(r.map||r.bumpMap||r.normalMap||r.specularMap||r.alphaMap||r.emissiveMap||r.roughnessMap||r.metalnessMap||r.clearcoatMap||r.clearcoatRoughnessMap||r.clearcoatNormalMap||r.displacementMap||r.transmissionMap),uvsVertexOnly:!(r.map||r.bumpMap||r.normalMap||r.specularMap||r.alphaMap||r.emissiveMap||r.roughnessMap||r.metalnessMap||r.clearcoatNormalMap||r.transmissionMap||!r.displacementMap),fog:!!v,useFog:r.fog,fogExp2:v&&v.isFogExp2,flatShading:!!r.flatShading,sizeAttenuation:r.sizeAttenuation,logarithmicDepthBuffer:l,skinning:r.skinning&&x>0,maxBones:x,useVertexTexture:c,morphTargets:r.morphTargets,morphNormals:r.morphNormals,numDirLights:o.directional.length,numPointLights:o.point.length,numSpotLights:o.spot.length,numRectAreaLights:o.rectArea.length,numHemiLights:o.hemi.length,numDirLightShadows:o.directionalShadowMap.length,numPointLightShadows:o.pointShadowMap.length,numSpotLightShadows:o.spotShadowMap.length,numClippingPlanes:s.numPlanes,numClipIntersection:s.numIntersection,dithering:r.dithering,shadowMapEnabled:t.shadowMap.enabled&&f.length>0,shadowMapType:t.shadowMap.type,toneMapping:r.toneMapped?t.toneMapping:0,physicallyCorrectLights:t.physicallyCorrectLights,premultipliedAlpha:r.premultipliedAlpha,alphaTest:r.alphaTest,doubleSided:2===r.side,flipSided:1===r.side,depthPacking:void 0!==r.depthPacking&&r.depthPacking,index0AttributeName:r.index0AttributeName,extensionDerivatives:r.extensions&&r.extensions.derivatives,extensionFragDepth:r.extensions&&r.extensions.fragDepth,extensionDrawBuffers:r.extensions&&r.extensions.drawBuffers,extensionShaderTextureLOD:r.extensions&&r.extensions.shaderTextureLOD,rendererExtensionFragDepth:a||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:a||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:a||n.has("EXT_shader_texture_lod"),customProgramCacheKey:r.customProgramCacheKey()}},getProgramCacheKey:function(e){const n=[];if(e.shaderID?n.push(e.shaderID):(n.push(e.fragmentShader),n.push(e.vertexShader)),void 0!==e.defines)for(const t in e.defines)n.push(t),n.push(e.defines[t]);if(!1===e.isRawShaderMaterial){for(let t=0;t<f.length;t++)n.push(e[f[t]]);n.push(t.outputEncoding),n.push(t.gammaFactor)}return n.push(e.customProgramCacheKey),n.join()},getUniforms:function(t){const e=p[t.type];let n;return n=e?xpt.clone(Ppt[e].uniforms):t.uniforms,n},acquireProgram:function(e,n){let i;for(let t=0,r=o.length;t<r;t++){const e=o[t];if(e.cacheKey===n){i=e,++i.usedTimes;break}}return void 0===i&&(i=new xmt(t,n,e,r),o.push(i)),i},releaseProgram:function(t){if(0==--t.usedTimes){const e=o.indexOf(t);o[e]=o[o.length-1],o.pop(),t.destroy()}},programs:o}}function _mt(){let t=new WeakMap;return{get:function(e){let n=t.get(e);return void 0===n&&(n={},t.set(e,n)),n},remove:function(e){t.delete(e)},update:function(e,n,i){t.get(e)[n]=i},dispose:function(){t=new WeakMap}}}function Smt(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.program!==e.program?t.program.id-e.program.id:t.material.id!==e.material.id?t.material.id-e.material.id:t.z!==e.z?t.z-e.z:t.id-e.id}function Emt(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.id-e.id}function Cmt(t){const e=[];let n=0;const i=[],r=[],s={id:-1};function o(i,r,o,a,l,c){let u=e[n];const h=t.get(o);return void 0===u?(u={id:i.id,object:i,geometry:r,material:o,program:h.program||s,groupOrder:a,renderOrder:i.renderOrder,z:l,group:c},e[n]=u):(u.id=i.id,u.object=i,u.geometry=r,u.material=o,u.program=h.program||s,u.groupOrder=a,u.renderOrder=i.renderOrder,u.z=l,u.group=c),n++,u}return{opaque:i,transparent:r,init:function(){n=0,i.length=0,r.length=0},push:function(t,e,n,s,a,l){const c=o(t,e,n,s,a,l);(!0===n.transparent?r:i).push(c)},unshift:function(t,e,n,s,a,l){const c=o(t,e,n,s,a,l);(!0===n.transparent?r:i).unshift(c)},finish:function(){for(let t=n,i=e.length;t<i;t++){const n=e[t];if(null===n.id)break;n.id=null,n.object=null,n.geometry=null,n.material=null,n.program=null,n.group=null}},sort:function(t,e){i.length>1&&i.sort(t||Smt),r.length>1&&r.sort(e||Emt)}}}function Imt(t){let e=new WeakMap;return{get:function(n,i){let r;return!1===e.has(n)?(r=new Cmt(t),e.set(n,[r])):i>=e.get(n).length?(r=new Cmt(t),e.get(n).push(r)):r=e.get(n)[i],r},dispose:function(){e=new WeakMap}}}function Tmt(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":n={direction:new uht,color:new Odt};break;case"SpotLight":n={position:new uht,direction:new uht,color:new Odt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new uht,color:new Odt,distance:0,decay:0};break;case"HemisphereLight":n={direction:new uht,skyColor:new Odt,groundColor:new Odt};break;case"RectAreaLight":n={color:new Odt,position:new uht,halfWidth:new uht,halfHeight:new uht}}return t[e.id]=n,n}}}let Mmt=0;function kmt(t,e){return(e.castShadow?1:0)-(t.castShadow?1:0)}function Rmt(t,e){const n=new Tmt,i=function(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new tht};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new tht,shadowCameraNear:1,shadowCameraFar:1e3}}return t[e.id]=n,n}}}(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let l=0;l<9;l++)r.probe.push(new uht);const s=new uht,o=new Uht,a=new Uht;return{setup:function(s){let o=0,a=0,l=0;for(let t=0;t<9;t++)r.probe[t].set(0,0,0);let c=0,u=0,h=0,d=0,p=0,f=0,m=0,g=0;s.sort(kmt);for(let t=0,e=s.length;t<e;t++){const e=s[t],y=e.color,v=e.intensity,b=e.distance,A=e.shadow&&e.shadow.map?e.shadow.map.texture:null;if(e.isAmbientLight)o+=y.r*v,a+=y.g*v,l+=y.b*v;else if(e.isLightProbe)for(let t=0;t<9;t++)r.probe[t].addScaledVector(e.sh.coefficients[t],v);else if(e.isDirectionalLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity),e.castShadow){const t=e.shadow,n=i.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,r.directionalShadow[c]=n,r.directionalShadowMap[c]=A,r.directionalShadowMatrix[c]=e.shadow.matrix,f++}r.directional[c]=t,c++}else if(e.isSpotLight){const t=n.get(e);if(t.position.setFromMatrixPosition(e.matrixWorld),t.color.copy(y).multiplyScalar(v),t.distance=b,t.coneCos=Math.cos(e.angle),t.penumbraCos=Math.cos(e.angle*(1-e.penumbra)),t.decay=e.decay,e.castShadow){const t=e.shadow,n=i.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,r.spotShadow[h]=n,r.spotShadowMap[h]=A,r.spotShadowMatrix[h]=e.shadow.matrix,g++}r.spot[h]=t,h++}else if(e.isRectAreaLight){const t=n.get(e);t.color.copy(y).multiplyScalar(v),t.halfWidth.set(.5*e.width,0,0),t.halfHeight.set(0,.5*e.height,0),r.rectArea[d]=t,d++}else if(e.isPointLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity),t.distance=e.distance,t.decay=e.decay,e.castShadow){const t=e.shadow,n=i.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,n.shadowCameraNear=t.camera.near,n.shadowCameraFar=t.camera.far,r.pointShadow[u]=n,r.pointShadowMap[u]=A,r.pointShadowMatrix[u]=e.shadow.matrix,m++}r.point[u]=t,u++}else if(e.isHemisphereLight){const t=n.get(e);t.skyColor.copy(e.color).multiplyScalar(v),t.groundColor.copy(e.groundColor).multiplyScalar(v),r.hemi[p]=t,p++}}d>0&&(e.isWebGL2||!0===t.has("OES_texture_float_linear")?(r.rectAreaLTC1=Opt.LTC_FLOAT_1,r.rectAreaLTC2=Opt.LTC_FLOAT_2):!0===t.has("OES_texture_half_float_linear")?(r.rectAreaLTC1=Opt.LTC_HALF_1,r.rectAreaLTC2=Opt.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=o,r.ambient[1]=a,r.ambient[2]=l;const y=r.hash;y.directionalLength===c&&y.pointLength===u&&y.spotLength===h&&y.rectAreaLength===d&&y.hemiLength===p&&y.numDirectionalShadows===f&&y.numPointShadows===m&&y.numSpotShadows===g||(r.directional.length=c,r.spot.length=h,r.rectArea.length=d,r.point.length=u,r.hemi.length=p,r.directionalShadow.length=f,r.directionalShadowMap.length=f,r.pointShadow.length=m,r.pointShadowMap.length=m,r.spotShadow.length=g,r.spotShadowMap.length=g,r.directionalShadowMatrix.length=f,r.pointShadowMatrix.length=m,r.spotShadowMatrix.length=g,y.directionalLength=c,y.pointLength=u,y.spotLength=h,y.rectAreaLength=d,y.hemiLength=p,y.numDirectionalShadows=f,y.numPointShadows=m,y.numSpotShadows=g,r.version=Mmt++)},setupView:function(t,e){let n=0,i=0,l=0,c=0,u=0;const h=e.matrixWorldInverse;for(let d=0,p=t.length;d<p;d++){const e=t[d];if(e.isDirectionalLight){const t=r.directional[n];t.direction.setFromMatrixPosition(e.matrixWorld),s.setFromMatrixPosition(e.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(h),n++}else if(e.isSpotLight){const t=r.spot[l];t.position.setFromMatrixPosition(e.matrixWorld),t.position.applyMatrix4(h),t.direction.setFromMatrixPosition(e.matrixWorld),s.setFromMatrixPosition(e.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(h),l++}else if(e.isRectAreaLight){const t=r.rectArea[c];t.position.setFromMatrixPosition(e.matrixWorld),t.position.applyMatrix4(h),a.identity(),o.copy(e.matrixWorld),o.premultiply(h),a.extractRotation(o),t.halfWidth.set(.5*e.width,0,0),t.halfHeight.set(0,.5*e.height,0),t.halfWidth.applyMatrix4(a),t.halfHeight.applyMatrix4(a),c++}else if(e.isPointLight){const t=r.point[i];t.position.setFromMatrixPosition(e.matrixWorld),t.position.applyMatrix4(h),i++}else if(e.isHemisphereLight){const t=r.hemi[u];t.direction.setFromMatrixPosition(e.matrixWorld),t.direction.transformDirection(h),t.direction.normalize(),u++}}},state:r}}function Nmt(t,e){const n=new Rmt(t,e),i=[],r=[];return{init:function(){i.length=0,r.length=0},state:{lightsArray:i,shadowsArray:r,lights:n},setupLights:function(){n.setup(i)},setupLightsView:function(t){n.setupView(i,t)},pushLight:function(t){i.push(t)},pushShadow:function(t){r.push(t)}}}function Lmt(t,e){let n=new WeakMap;return{get:function(i,r=0){let s;return!1===n.has(i)?(s=new Nmt(t,e),n.set(i,[s])):r>=n.get(i).length?(s=new Nmt(t,e),n.get(i).push(s)):s=n.get(i)[r],s},dispose:function(){n=new WeakMap}}}class Dmt extends Mdt{constructor(t){super(),this.type="MeshDepthMaterial",this.depthPacking=3200,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}Dmt.prototype.isMeshDepthMaterial=!0;class Bmt extends Mdt{constructor(t){super(),this.type="MeshDistanceMaterial",this.referencePosition=new uht,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}function Omt(t,e,n){let i=new Rpt;const r=new tht,s=new tht,o=new aht,a=[],l=[],c={},u=n.maxTextureSize,h={0:1,1:0,2:2},d=new wpt({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new tht},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),p=d.clone();p.defines.HORIZONTAL_PASS=1;const f=new Jdt;f.setAttribute("position",new zdt(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const m=new gpt(f,d),g=this;function y(n,i){const r=e.update(m);d.uniforms.shadow_pass.value=n.map.texture,d.uniforms.resolution.value=n.mapSize,d.uniforms.radius.value=n.radius,t.setRenderTarget(n.mapPass),t.clear(),t.renderBufferDirect(i,null,r,d,m,null),p.uniforms.shadow_pass.value=n.mapPass.texture,p.uniforms.resolution.value=n.mapSize,p.uniforms.radius.value=n.radius,t.setRenderTarget(n.map),t.clear(),t.renderBufferDirect(i,null,r,p,m,null)}function v(t,e,n){const i=t<<0|e<<1|n<<2;let r=a[i];return void 0===r&&(r=new Dmt({depthPacking:3201,morphTargets:t,skinning:e}),a[i]=r),r}function b(t,e,n){const i=t<<0|e<<1|n<<2;let r=l[i];return void 0===r&&(r=new Bmt({morphTargets:t,skinning:e}),l[i]=r),r}function A(e,n,i,r,s,o,a){let l=null,u=v,d=e.customDepthMaterial;if(!0===r.isPointLight&&(u=b,d=e.customDistanceMaterial),void 0===d){let t=!1;!0===i.morphTargets&&(t=n.morphAttributes&&n.morphAttributes.position&&n.morphAttributes.position.length>0);let r=!1;!0===e.isSkinnedMesh&&(!0===i.skinning?r=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",e)),l=u(t,r,!0===e.isInstancedMesh)}else l=d;if(t.localClippingEnabled&&!0===i.clipShadows&&0!==i.clippingPlanes.length){const t=l.uuid,e=i.uuid;let n=c[t];void 0===n&&(n={},c[t]=n);let r=n[e];void 0===r&&(r=l.clone(),n[e]=r),l=r}return l.visible=i.visible,l.wireframe=i.wireframe,l.side=3===a?null!==i.shadowSide?i.shadowSide:i.side:null!==i.shadowSide?i.shadowSide:h[i.side],l.clipShadows=i.clipShadows,l.clippingPlanes=i.clippingPlanes,l.clipIntersection=i.clipIntersection,l.wireframeLinewidth=i.wireframeLinewidth,l.linewidth=i.linewidth,!0===r.isPointLight&&!0===l.isMeshDistanceMaterial&&(l.referencePosition.setFromMatrixPosition(r.matrixWorld),l.nearDistance=s,l.farDistance=o),l}function x(n,r,s,o,a){if(!1===n.visible)return;if(n.layers.test(r.layers)&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&3===a)&&(!n.frustumCulled||i.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,n.matrixWorld);const i=e.update(n),r=n.material;if(Array.isArray(r)){const e=i.groups;for(let l=0,c=e.length;l<c;l++){const c=e[l],u=r[c.materialIndex];if(u&&u.visible){const e=A(n,i,u,o,s.near,s.far,a);t.renderBufferDirect(s,null,i,e,n,c)}}}else if(r.visible){const e=A(n,i,r,o,s.near,s.far,a);t.renderBufferDirect(s,null,i,e,n,null)}}const l=n.children;for(let t=0,e=l.length;t<e;t++)x(l[t],r,s,o,a)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function(e,n,a){if(!1===g.enabled)return;if(!1===g.autoUpdate&&!1===g.needsUpdate)return;if(0===e.length)return;const l=t.getRenderTarget(),c=t.getActiveCubeFace(),h=t.getActiveMipmapLevel(),d=t.state;d.setBlending(0),d.buffers.color.setClear(1,1,1,1),d.buffers.depth.setTest(!0),d.setScissorTest(!1);for(let p=0,f=e.length;p<f;p++){const l=e[p],c=l.shadow;if(void 0===c){console.warn("THREE.WebGLShadowMap:",l,"has no shadow.");continue}if(!1===c.autoUpdate&&!1===c.needsUpdate)continue;r.copy(c.mapSize);const h=c.getFrameExtents();if(r.multiply(h),s.copy(c.mapSize),(r.x>u||r.y>u)&&(r.x>u&&(s.x=Math.floor(u/h.x),r.x=s.x*h.x,c.mapSize.x=s.x),r.y>u&&(s.y=Math.floor(u/h.y),r.y=s.y*h.y,c.mapSize.y=s.y)),null===c.map&&!c.isPointLightShadow&&3===this.type){const t={minFilter:1006,magFilter:1006,format:1023};c.map=new lht(r.x,r.y,t),c.map.texture.name=l.name+".shadowMap",c.mapPass=new lht(r.x,r.y,t),c.camera.updateProjectionMatrix()}null===c.map&&(c.map=new lht(r.x,r.y,{minFilter:1003,magFilter:1003,format:1023}),c.map.texture.name=l.name+".shadowMap",c.camera.updateProjectionMatrix()),t.setRenderTarget(c.map),t.clear();const f=c.getViewportCount();for(let t=0;t<f;t++){const e=c.getViewport(t);o.set(s.x*e.x,s.y*e.y,s.x*e.z,s.y*e.w),d.viewport(o),c.updateMatrices(l,t),i=c.getFrustum(),x(n,a,c.camera,l,this.type)}c.isPointLightShadow||3!==this.type||y(c,a),c.needsUpdate=!1}g.needsUpdate=!1,t.setRenderTarget(l,c,h)}}function Pmt(t,e,n){const i=n.isWebGL2,r=new function(){let e=!1;const n=new aht;let i=null;const r=new aht(0,0,0,0);return{setMask:function(n){i===n||e||(t.colorMask(n,n,n,n),i=n)},setLocked:function(t){e=t},setClear:function(e,i,s,o,a){!0===a&&(e*=o,i*=o,s*=o),n.set(e,i,s,o),!1===r.equals(n)&&(t.clearColor(e,i,s,o),r.copy(n))},reset:function(){e=!1,i=null,r.set(-1,0,0,0)}}},s=new function(){let e=!1,n=null,i=null,r=null;return{setTest:function(t){t?B(2929):O(2929)},setMask:function(i){n===i||e||(t.depthMask(i),n=i)},setFunc:function(e){if(i!==e){if(e)switch(e){case 0:t.depthFunc(512);break;case 1:t.depthFunc(519);break;case 2:t.depthFunc(513);break;case 3:t.depthFunc(515);break;case 4:t.depthFunc(514);break;case 5:t.depthFunc(518);break;case 6:t.depthFunc(516);break;case 7:t.depthFunc(517);break;default:t.depthFunc(515)}else t.depthFunc(515);i=e}},setLocked:function(t){e=t},setClear:function(e){r!==e&&(t.clearDepth(e),r=e)},reset:function(){e=!1,n=null,i=null,r=null}}},o=new function(){let e=!1,n=null,i=null,r=null,s=null,o=null,a=null,l=null,c=null;return{setTest:function(t){e||(t?B(2960):O(2960))},setMask:function(i){n===i||e||(t.stencilMask(i),n=i)},setFunc:function(e,n,o){i===e&&r===n&&s===o||(t.stencilFunc(e,n,o),i=e,r=n,s=o)},setOp:function(e,n,i){o===e&&a===n&&l===i||(t.stencilOp(e,n,i),o=e,a=n,l=i)},setLocked:function(t){e=t},setClear:function(e){c!==e&&(t.clearStencil(e),c=e)},reset:function(){e=!1,n=null,i=null,r=null,s=null,o=null,a=null,l=null,c=null}}};let a={},l=null,c={},u=null,h=!1,d=null,p=null,f=null,m=null,g=null,y=null,v=null,b=!1,A=null,x=null,w=null,_=null,S=null;const E=t.getParameter(35661);let C=!1,I=0;const T=t.getParameter(7938);-1!==T.indexOf("WebGL")?(I=parseFloat(/^WebGL (\d)/.exec(T)[1]),C=I>=1):-1!==T.indexOf("OpenGL ES")&&(I=parseFloat(/^OpenGL ES (\d)/.exec(T)[1]),C=I>=2);let M=null,k={};const R=new aht(0,0,t.canvas.width,t.canvas.height),N=new aht(0,0,t.canvas.width,t.canvas.height);function L(e,n,i){const r=new Uint8Array(4),s=t.createTexture();t.bindTexture(e,s),t.texParameteri(e,10241,9728),t.texParameteri(e,10240,9728);for(let o=0;o<i;o++)t.texImage2D(n+o,0,6408,1,1,0,6408,5121,r);return s}const D={};function B(e){!0!==a[e]&&(t.enable(e),a[e]=!0)}function O(e){!1!==a[e]&&(t.disable(e),a[e]=!1)}D[3553]=L(3553,3553,1),D[34067]=L(34067,34069,6),r.setClear(0,0,0,1),s.setClear(1),o.setClear(0),B(2929),s.setFunc(3),z(!1),U(1),B(2884),$(0);const P={100:32774,101:32778,102:32779};if(i)P[103]=32775,P[104]=32776;else{const t=e.get("EXT_blend_minmax");null!==t&&(P[103]=t.MIN_EXT,P[104]=t.MAX_EXT)}const F={200:0,201:1,202:768,204:770,210:776,208:774,206:772,203:769,205:771,209:775,207:773};function $(e,n,i,r,s,o,a,l){if(0!==e){if(!1===h&&(B(3042),h=!0),5===e)s=s||n,o=o||i,a=a||r,n===p&&s===g||(t.blendEquationSeparate(P[n],P[s]),p=n,g=s),i===f&&r===m&&o===y&&a===v||(t.blendFuncSeparate(F[i],F[r],F[o],F[a]),f=i,m=r,y=o,v=a),d=e,b=null;else if(e!==d||l!==b){if(100===p&&100===g||(t.blendEquation(32774),p=100,g=100),l)switch(e){case 1:t.blendFuncSeparate(1,771,1,771);break;case 2:t.blendFunc(1,1);break;case 3:t.blendFuncSeparate(0,0,769,771);break;case 4:t.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}else switch(e){case 1:t.blendFuncSeparate(770,771,1,771);break;case 2:t.blendFunc(770,1);break;case 3:t.blendFunc(0,769);break;case 4:t.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}f=null,m=null,y=null,v=null,d=e,b=l}}else!0===h&&(O(3042),h=!1)}function z(e){A!==e&&(t.frontFace(e?2304:2305),A=e)}function U(e){0!==e?(B(2884),e!==x&&t.cullFace(1===e?1029:2===e?1028:1032)):O(2884),x=e}function H(e,n,i){e?(B(32823),_===n&&S===i||(t.polygonOffset(n,i),_=n,S=i)):O(32823)}function V(e){void 0===e&&(e=33984+E-1),M!==e&&(t.activeTexture(e),M=e)}return{buffers:{color:r,depth:s,stencil:o},enable:B,disable:O,bindFramebuffer:function(e,n){null===n&&null!==l&&(n=l),c[e]!==n&&(t.bindFramebuffer(e,n),c[e]=n,i&&(36009===e&&(c[36160]=n),36160===e&&(c[36009]=n)))},bindXRFramebuffer:function(e){e!==l&&(t.bindFramebuffer(36160,e),l=e)},useProgram:function(e){return u!==e&&(t.useProgram(e),u=e,!0)},setBlending:$,setMaterial:function(t,e){2===t.side?O(2884):B(2884);let n=1===t.side;e&&(n=!n),z(n),1===t.blending&&!1===t.transparent?$(0):$(t.blending,t.blendEquation,t.blendSrc,t.blendDst,t.blendEquationAlpha,t.blendSrcAlpha,t.blendDstAlpha,t.premultipliedAlpha),s.setFunc(t.depthFunc),s.setTest(t.depthTest),s.setMask(t.depthWrite),r.setMask(t.colorWrite);const i=t.stencilWrite;o.setTest(i),i&&(o.setMask(t.stencilWriteMask),o.setFunc(t.stencilFunc,t.stencilRef,t.stencilFuncMask),o.setOp(t.stencilFail,t.stencilZFail,t.stencilZPass)),H(t.polygonOffset,t.polygonOffsetFactor,t.polygonOffsetUnits),!0===t.alphaToCoverage?B(32926):O(32926)},setFlipSided:z,setCullFace:U,setLineWidth:function(e){e!==w&&(C&&t.lineWidth(e),w=e)},setPolygonOffset:H,setScissorTest:function(t){t?B(3089):O(3089)},activeTexture:V,bindTexture:function(e,n){null===M&&V();let i=k[M];void 0===i&&(i={type:void 0,texture:void 0},k[M]=i),i.type===e&&i.texture===n||(t.bindTexture(e,n||D[e]),i.type=e,i.texture=n)},unbindTexture:function(){const e=k[M];void 0!==e&&void 0!==e.type&&(t.bindTexture(e.type,null),e.type=void 0,e.texture=void 0)},compressedTexImage2D:function(){try{t.compressedTexImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage2D:function(){try{t.texImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage3D:function(){try{t.texImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},scissor:function(e){!1===R.equals(e)&&(t.scissor(e.x,e.y,e.z,e.w),R.copy(e))},viewport:function(e){!1===N.equals(e)&&(t.viewport(e.x,e.y,e.z,e.w),N.copy(e))},reset:function(){t.disable(3042),t.disable(2884),t.disable(2929),t.disable(32823),t.disable(3089),t.disable(2960),t.disable(32926),t.blendEquation(32774),t.blendFunc(1,0),t.blendFuncSeparate(1,0,1,0),t.colorMask(!0,!0,!0,!0),t.clearColor(0,0,0,0),t.depthMask(!0),t.depthFunc(513),t.clearDepth(1),t.stencilMask(4294967295),t.stencilFunc(519,0,4294967295),t.stencilOp(7680,7680,7680),t.clearStencil(0),t.cullFace(1029),t.frontFace(2305),t.polygonOffset(0,0),t.activeTexture(33984),t.bindFramebuffer(36160,null),!0===i&&(t.bindFramebuffer(36009,null),t.bindFramebuffer(36008,null)),t.useProgram(null),t.lineWidth(1),t.scissor(0,0,t.canvas.width,t.canvas.height),t.viewport(0,0,t.canvas.width,t.canvas.height),a={},M=null,k={},l=null,c={},u=null,h=!1,d=null,p=null,f=null,m=null,g=null,y=null,v=null,b=!1,A=null,x=null,w=null,_=null,S=null,R.set(0,0,t.canvas.width,t.canvas.height),N.set(0,0,t.canvas.width,t.canvas.height),r.reset(),s.reset(),o.reset()}}}function Fmt(t,e,n,i,r,s,o){const a=r.isWebGL2,l=r.maxTextures,c=r.maxCubemapSize,u=r.maxTextureSize,h=r.maxSamples,d=new WeakMap;let p,f=!1;try{f="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(t){}function m(t,e){return f?new OffscreenCanvas(t,e):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function g(t,e,n,i){let r=1;if((t.width>i||t.height>i)&&(r=i/Math.max(t.width,t.height)),r<1||!0===e){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const i=e?Jut:Math.floor,s=i(r*t.width),o=i(r*t.height);void 0===p&&(p=m(s,o));const a=n?m(s,o):p;return a.width=s,a.height=o,a.getContext("2d").drawImage(t,0,0,s,o),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+t.width+"x"+t.height+") to ("+s+"x"+o+")."),a}return"data"in t&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+t.width+"x"+t.height+")."),t}return t}function y(t){return Yut(t.width)&&Yut(t.height)}function v(t,e){return t.generateMipmaps&&e&&1003!==t.minFilter&&1006!==t.minFilter}function b(e,n,r,s){t.generateMipmap(e),i.get(n).__maxMipLevel=Math.log2(Math.max(r,s))}function A(n,i,r){if(!1===a)return i;if(null!==n){if(void 0!==t[n])return t[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let s=i;return 6403===i&&(5126===r&&(s=33326),5131===r&&(s=33325),5121===r&&(s=33321)),6407===i&&(5126===r&&(s=34837),5131===r&&(s=34843),5121===r&&(s=32849)),6408===i&&(5126===r&&(s=34836),5131===r&&(s=34842),5121===r&&(s=32856)),33325!==s&&33326!==s&&34842!==s&&34836!==s||e.get("EXT_color_buffer_float"),s}function x(t){return 1003===t||1004===t||1005===t?9728:9729}function w(e){const n=e.target;n.removeEventListener("dispose",w),function(e){const n=i.get(e);void 0!==n.__webglInit&&(t.deleteTexture(n.__webglTexture),i.remove(e))}(n),n.isVideoTexture&&d.delete(n),o.memory.textures--}function _(e){const n=e.target;n.removeEventListener("dispose",_),function(e){const n=e.texture,r=i.get(e),s=i.get(n);if(e){if(void 0!==s.__webglTexture&&t.deleteTexture(s.__webglTexture),e.depthTexture&&e.depthTexture.dispose(),e.isWebGLCubeRenderTarget)for(let e=0;e<6;e++)t.deleteFramebuffer(r.__webglFramebuffer[e]),r.__webglDepthbuffer&&t.deleteRenderbuffer(r.__webglDepthbuffer[e]);else t.deleteFramebuffer(r.__webglFramebuffer),r.__webglDepthbuffer&&t.deleteRenderbuffer(r.__webglDepthbuffer),r.__webglMultisampledFramebuffer&&t.deleteFramebuffer(r.__webglMultisampledFramebuffer),r.__webglColorRenderbuffer&&t.deleteRenderbuffer(r.__webglColorRenderbuffer),r.__webglDepthRenderbuffer&&t.deleteRenderbuffer(r.__webglDepthRenderbuffer);i.remove(n),i.remove(e)}}(n),o.memory.textures--}let S=0;function E(t,e){const r=i.get(t);if(t.isVideoTexture&&function(t){const e=o.render.frame;d.get(t)!==e&&(d.set(t,e),t.update())}(t),t.version>0&&r.__version!==t.version){const n=t.image;if(void 0===n)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else{if(!1!==n.complete)return void R(r,t,e);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.activeTexture(33984+e),n.bindTexture(3553,r.__webglTexture)}function C(e,r){const o=i.get(e);e.version>0&&o.__version!==e.version?function(e,i,r){if(6!==i.image.length)return;k(e,i),n.activeTexture(33984+r),n.bindTexture(34067,e.__webglTexture),t.pixelStorei(37440,i.flipY),t.pixelStorei(37441,i.premultiplyAlpha),t.pixelStorei(3317,i.unpackAlignment),t.pixelStorei(37443,0);const o=i&&(i.isCompressedTexture||i.image[0].isCompressedTexture),l=i.image[0]&&i.image[0].isDataTexture,u=[];for(let t=0;t<6;t++)u[t]=o||l?l?i.image[t].image:i.image[t]:g(i.image[t],!1,!0,c);const h=u[0],d=y(h)||a,p=s.convert(i.format),f=s.convert(i.type),m=A(i.internalFormat,p,f);let x;if(M(34067,i,d),o){for(let t=0;t<6;t++){x=u[t].mipmaps;for(let e=0;e<x.length;e++){const r=x[e];1023!==i.format&&1022!==i.format?null!==p?n.compressedTexImage2D(34069+t,e,m,r.width,r.height,0,r.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):n.texImage2D(34069+t,e,m,r.width,r.height,0,p,f,r.data)}}e.__maxMipLevel=x.length-1}else{x=i.mipmaps;for(let t=0;t<6;t++)if(l){n.texImage2D(34069+t,0,m,u[t].width,u[t].height,0,p,f,u[t].data);for(let e=0;e<x.length;e++){const i=x[e].image[t].image;n.texImage2D(34069+t,e+1,m,i.width,i.height,0,p,f,i.data)}}else{n.texImage2D(34069+t,0,m,p,f,u[t]);for(let e=0;e<x.length;e++)n.texImage2D(34069+t,e+1,m,p,f,x[e].image[t])}e.__maxMipLevel=x.length}v(i,d)&&b(34067,i,h.width,h.height),e.__version=i.version,i.onUpdate&&i.onUpdate(i)}(o,e,r):(n.activeTexture(33984+r),n.bindTexture(34067,o.__webglTexture))}const I={1e3:10497,1001:33071,1002:33648},T={1003:9728,1004:9984,1005:9986,1006:9729,1007:9985,1008:9987};function M(n,s,o){if(o?(t.texParameteri(n,10242,I[s.wrapS]),t.texParameteri(n,10243,I[s.wrapT]),32879!==n&&35866!==n||t.texParameteri(n,32882,I[s.wrapR]),t.texParameteri(n,10240,T[s.magFilter]),t.texParameteri(n,10241,T[s.minFilter])):(t.texParameteri(n,10242,33071),t.texParameteri(n,10243,33071),32879!==n&&35866!==n||t.texParameteri(n,32882,33071),1001===s.wrapS&&1001===s.wrapT||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),t.texParameteri(n,10240,x(s.magFilter)),t.texParameteri(n,10241,x(s.minFilter)),1003!==s.minFilter&&1006!==s.minFilter&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),!0===e.has("EXT_texture_filter_anisotropic")){const o=e.get("EXT_texture_filter_anisotropic");if(1015===s.type&&!1===e.has("OES_texture_float_linear"))return;if(!1===a&&1016===s.type&&!1===e.has("OES_texture_half_float_linear"))return;(s.anisotropy>1||i.get(s).__currentAnisotropy)&&(t.texParameterf(n,o.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(s.anisotropy,r.getMaxAnisotropy())),i.get(s).__currentAnisotropy=s.anisotropy)}}function k(e,n){void 0===e.__webglInit&&(e.__webglInit=!0,n.addEventListener("dispose",w),e.__webglTexture=t.createTexture(),o.memory.textures++)}function R(e,i,r){let o=3553;i.isDataTexture2DArray&&(o=35866),i.isDataTexture3D&&(o=32879),k(e,i),n.activeTexture(33984+r),n.bindTexture(o,e.__webglTexture),t.pixelStorei(37440,i.flipY),t.pixelStorei(37441,i.premultiplyAlpha),t.pixelStorei(3317,i.unpackAlignment),t.pixelStorei(37443,0);const l=function(t){return!a&&(1001!==t.wrapS||1001!==t.wrapT||1003!==t.minFilter&&1006!==t.minFilter)}(i)&&!1===y(i.image),c=g(i.image,l,!1,u),h=y(c)||a,d=s.convert(i.format);let p,f=s.convert(i.type),m=A(i.internalFormat,d,f);M(o,i,h);const x=i.mipmaps;if(i.isDepthTexture)m=6402,a?m=1015===i.type?36012:1014===i.type?33190:1020===i.type?35056:33189:1015===i.type&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),1026===i.format&&6402===m&&1012!==i.type&&1014!==i.type&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),i.type=1012,f=s.convert(i.type)),1027===i.format&&6402===m&&(m=34041,1020!==i.type&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),i.type=1020,f=s.convert(i.type))),n.texImage2D(3553,0,m,c.width,c.height,0,d,f,null);else if(i.isDataTexture)if(x.length>0&&h){for(let t=0,e=x.length;t<e;t++)p=x[t],n.texImage2D(3553,t,m,p.width,p.height,0,d,f,p.data);i.generateMipmaps=!1,e.__maxMipLevel=x.length-1}else n.texImage2D(3553,0,m,c.width,c.height,0,d,f,c.data),e.__maxMipLevel=0;else if(i.isCompressedTexture){for(let t=0,e=x.length;t<e;t++)p=x[t],1023!==i.format&&1022!==i.format?null!==d?n.compressedTexImage2D(3553,t,m,p.width,p.height,0,p.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):n.texImage2D(3553,t,m,p.width,p.height,0,d,f,p.data);e.__maxMipLevel=x.length-1}else if(i.isDataTexture2DArray)n.texImage3D(35866,0,m,c.width,c.height,c.depth,0,d,f,c.data),e.__maxMipLevel=0;else if(i.isDataTexture3D)n.texImage3D(32879,0,m,c.width,c.height,c.depth,0,d,f,c.data),e.__maxMipLevel=0;else if(x.length>0&&h){for(let t=0,e=x.length;t<e;t++)p=x[t],n.texImage2D(3553,t,m,d,f,p);i.generateMipmaps=!1,e.__maxMipLevel=x.length-1}else n.texImage2D(3553,0,m,d,f,c),e.__maxMipLevel=0;v(i,h)&&b(o,i,c.width,c.height),e.__version=i.version,i.onUpdate&&i.onUpdate(i)}function N(e,r,o,a){const l=r.texture,c=s.convert(l.format),u=s.convert(l.type),h=A(l.internalFormat,c,u);32879===a||35866===a?n.texImage3D(a,0,h,r.width,r.height,r.depth,0,c,u,null):n.texImage2D(a,0,h,r.width,r.height,0,c,u,null),n.bindFramebuffer(36160,e),t.framebufferTexture2D(36160,o,a,i.get(l).__webglTexture,0),n.bindFramebuffer(36160,null)}function L(e,n,i){if(t.bindRenderbuffer(36161,e),n.depthBuffer&&!n.stencilBuffer){let r=33189;if(i){const e=n.depthTexture;e&&e.isDepthTexture&&(1015===e.type?r=36012:1014===e.type&&(r=33190));const i=D(n);t.renderbufferStorageMultisample(36161,i,r,n.width,n.height)}else t.renderbufferStorage(36161,r,n.width,n.height);t.framebufferRenderbuffer(36160,36096,36161,e)}else if(n.depthBuffer&&n.stencilBuffer){if(i){const e=D(n);t.renderbufferStorageMultisample(36161,e,35056,n.width,n.height)}else t.renderbufferStorage(36161,34041,n.width,n.height);t.framebufferRenderbuffer(36160,33306,36161,e)}else{const e=n.texture,r=s.convert(e.format),o=s.convert(e.type),a=A(e.internalFormat,r,o);if(i){const e=D(n);t.renderbufferStorageMultisample(36161,e,a,n.width,n.height)}else t.renderbufferStorage(36161,a,n.width,n.height)}t.bindRenderbuffer(36161,null)}function D(t){return a&&t.isWebGLMultisampleRenderTarget?Math.min(h,t.samples):0}let B=!1,O=!1;this.allocateTextureUnit=function(){const t=S;return t>=l&&console.warn("THREE.WebGLTextures: Trying to use "+t+" texture units while this GPU supports only "+l),S+=1,t},this.resetTextureUnits=function(){S=0},this.setTexture2D=E,this.setTexture2DArray=function(t,e){const r=i.get(t);t.version>0&&r.__version!==t.version?R(r,t,e):(n.activeTexture(33984+e),n.bindTexture(35866,r.__webglTexture))},this.setTexture3D=function(t,e){const r=i.get(t);t.version>0&&r.__version!==t.version?R(r,t,e):(n.activeTexture(33984+e),n.bindTexture(32879,r.__webglTexture))},this.setTextureCube=C,this.setupRenderTarget=function(e){const r=e.texture,l=i.get(e),c=i.get(r);e.addEventListener("dispose",_),c.__webglTexture=t.createTexture(),c.__version=r.version,o.memory.textures++;const u=!0===e.isWebGLCubeRenderTarget,h=!0===e.isWebGLMultisampleRenderTarget,d=r.isDataTexture3D||r.isDataTexture2DArray,p=y(e)||a;if(!a||1022!==r.format||1015!==r.type&&1016!==r.type||(r.format=1023,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),u){l.__webglFramebuffer=[];for(let e=0;e<6;e++)l.__webglFramebuffer[e]=t.createFramebuffer()}else if(l.__webglFramebuffer=t.createFramebuffer(),h)if(a){l.__webglMultisampledFramebuffer=t.createFramebuffer(),l.__webglColorRenderbuffer=t.createRenderbuffer(),t.bindRenderbuffer(36161,l.__webglColorRenderbuffer);const i=s.convert(r.format),o=s.convert(r.type),a=A(r.internalFormat,i,o),c=D(e);t.renderbufferStorageMultisample(36161,c,a,e.width,e.height),n.bindFramebuffer(36160,l.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(36160,36064,36161,l.__webglColorRenderbuffer),t.bindRenderbuffer(36161,null),e.depthBuffer&&(l.__webglDepthRenderbuffer=t.createRenderbuffer(),L(l.__webglDepthRenderbuffer,e,!0)),n.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(u){n.bindTexture(34067,c.__webglTexture),M(34067,r,p);for(let t=0;t<6;t++)N(l.__webglFramebuffer[t],e,36064,34069+t);v(r,p)&&b(34067,r,e.width,e.height),n.bindTexture(34067,null)}else{let t=3553;d&&(a?t=r.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),n.bindTexture(t,c.__webglTexture),M(t,r,p),N(l.__webglFramebuffer,e,36064,t),v(r,p)&&b(3553,r,e.width,e.height),n.bindTexture(3553,null)}e.depthBuffer&&function(e){const r=i.get(e),s=!0===e.isWebGLCubeRenderTarget;if(e.depthTexture){if(s)throw new Error("target.depthTexture not supported in Cube render targets");!function(e,r){if(r&&r.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(36160,e),!r.depthTexture||!r.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");i.get(r.depthTexture).__webglTexture&&r.depthTexture.image.width===r.width&&r.depthTexture.image.height===r.height||(r.depthTexture.image.width=r.width,r.depthTexture.image.height=r.height,r.depthTexture.needsUpdate=!0),E(r.depthTexture,0);const s=i.get(r.depthTexture).__webglTexture;if(1026===r.depthTexture.format)t.framebufferTexture2D(36160,36096,3553,s,0);else{if(1027!==r.depthTexture.format)throw new Error("Unknown depthTexture format");t.framebufferTexture2D(36160,33306,3553,s,0)}}(r.__webglFramebuffer,e)}else if(s){r.__webglDepthbuffer=[];for(let i=0;i<6;i++)n.bindFramebuffer(36160,r.__webglFramebuffer[i]),r.__webglDepthbuffer[i]=t.createRenderbuffer(),L(r.__webglDepthbuffer[i],e,!1)}else n.bindFramebuffer(36160,r.__webglFramebuffer),r.__webglDepthbuffer=t.createRenderbuffer(),L(r.__webglDepthbuffer,e,!1);n.bindFramebuffer(36160,null)}(e)},this.updateRenderTargetMipmap=function(t){const e=t.texture;if(v(e,y(t)||a)){const r=t.isWebGLCubeRenderTarget?34067:3553,s=i.get(e).__webglTexture;n.bindTexture(r,s),b(r,e,t.width,t.height),n.bindTexture(r,null)}},this.updateMultisampleRenderTarget=function(e){if(e.isWebGLMultisampleRenderTarget)if(a){const r=e.width,s=e.height;let o=16384;e.depthBuffer&&(o|=256),e.stencilBuffer&&(o|=1024);const a=i.get(e);n.bindFramebuffer(36008,a.__webglMultisampledFramebuffer),n.bindFramebuffer(36009,a.__webglFramebuffer),t.blitFramebuffer(0,0,r,s,0,0,r,s,o,9728),n.bindFramebuffer(36008,null),n.bindFramebuffer(36009,a.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")},this.safeSetTexture2D=function(t,e){t&&t.isWebGLRenderTarget&&(!1===B&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),B=!0),t=t.texture),E(t,e)},this.safeSetTextureCube=function(t,e){t&&t.isWebGLCubeRenderTarget&&(!1===O&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),O=!0),t=t.texture),C(t,e)}}function $mt(t,e,n){const i=n.isWebGL2;return{convert:function(t){let n;if(1009===t)return 5121;if(1017===t)return 32819;if(1018===t)return 32820;if(1019===t)return 33635;if(1010===t)return 5120;if(1011===t)return 5122;if(1012===t)return 5123;if(1013===t)return 5124;if(1014===t)return 5125;if(1015===t)return 5126;if(1016===t)return i?5131:(n=e.get("OES_texture_half_float"),null!==n?n.HALF_FLOAT_OES:null);if(1021===t)return 6406;if(1022===t)return 6407;if(1023===t)return 6408;if(1024===t)return 6409;if(1025===t)return 6410;if(1026===t)return 6402;if(1027===t)return 34041;if(1028===t)return 6403;if(1029===t)return 36244;if(1030===t)return 33319;if(1031===t)return 33320;if(1032===t)return 36248;if(1033===t)return 36249;if(33776===t||33777===t||33778===t||33779===t){if(n=e.get("WEBGL_compressed_texture_s3tc"),null===n)return null;if(33776===t)return n.COMPRESSED_RGB_S3TC_DXT1_EXT;if(33777===t)return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(33778===t)return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(33779===t)return n.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(35840===t||35841===t||35842===t||35843===t){if(n=e.get("WEBGL_compressed_texture_pvrtc"),null===n)return null;if(35840===t)return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(35841===t)return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(35842===t)return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(35843===t)return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(36196===t)return n=e.get("WEBGL_compressed_texture_etc1"),null!==n?n.COMPRESSED_RGB_ETC1_WEBGL:null;if((37492===t||37496===t)&&(n=e.get("WEBGL_compressed_texture_etc"),null!==n)){if(37492===t)return n.COMPRESSED_RGB8_ETC2;if(37496===t)return n.COMPRESSED_RGBA8_ETC2_EAC}return 37808===t||37809===t||37810===t||37811===t||37812===t||37813===t||37814===t||37815===t||37816===t||37817===t||37818===t||37819===t||37820===t||37821===t||37840===t||37841===t||37842===t||37843===t||37844===t||37845===t||37846===t||37847===t||37848===t||37849===t||37850===t||37851===t||37852===t||37853===t?(n=e.get("WEBGL_compressed_texture_astc"),null!==n?t:null):36492===t?(n=e.get("EXT_texture_compression_bptc"),null!==n?t:null):1020===t?i?34042:(n=e.get("WEBGL_depth_texture"),null!==n?n.UNSIGNED_INT_24_8_WEBGL:null):void 0}}}Bmt.prototype.isMeshDistanceMaterial=!0;class zmt extends Spt{constructor(t=[]){super(),this.cameras=t}}zmt.prototype.isArrayCamera=!0;class Umt extends ddt{constructor(){super(),this.type="Group"}}Umt.prototype.isGroup=!0;const Hmt={type:"move"};class Vmt{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new Umt,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new Umt,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new uht,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new uht),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new Umt,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new uht,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new uht),this._grip}dispatchEvent(t){return null!==this._targetRay&&this._targetRay.dispatchEvent(t),null!==this._grip&&this._grip.dispatchEvent(t),null!==this._hand&&this._hand.dispatchEvent(t),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(t,e,n){let i=null,r=null,s=null;const o=this._targetRay,a=this._grip,l=this._hand;if(t&&"visible-blurred"!==e.session.visibilityState)if(null!==o&&(i=e.getPose(t.targetRaySpace,n),null!==i&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),i.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(i.linearVelocity)):o.hasLinearVelocity=!1,i.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(i.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(Hmt))),l&&t.hand){s=!0;for(const s of t.hand.values()){const t=e.getJointPose(s,n);if(void 0===l.joints[s.jointName]){const t=new Umt;t.matrixAutoUpdate=!1,t.visible=!1,l.joints[s.jointName]=t,l.add(t)}const i=l.joints[s.jointName];null!==t&&(i.matrix.fromArray(t.transform.matrix),i.matrix.decompose(i.position,i.rotation,i.scale),i.jointRadius=t.radius),i.visible=null!==t}const i=l.joints["index-finger-tip"].position.distanceTo(l.joints["thumb-tip"].position),r=.02,o=.005;l.inputState.pinching&&i>r+o?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!l.inputState.pinching&&i<=r-o&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else null!==a&&t.gripSpace&&(r=e.getPose(t.gripSpace,n),null!==r&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),r.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(r.linearVelocity)):a.hasLinearVelocity=!1,r.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(r.angularVelocity)):a.hasAngularVelocity=!1));return null!==o&&(o.visible=null!==i),null!==a&&(a.visible=null!==r),null!==l&&(l.visible=null!==s),this}}class Gmt extends Uut{constructor(t,e){super();const n=this,i=t.state;let r=null,s=1,o=null,a="local-floor",l=null;const c=[],u=new Map,h=new Spt;h.layers.enable(1),h.viewport=new aht;const d=new Spt;d.layers.enable(2),d.viewport=new aht;const p=[h,d],f=new zmt;f.layers.enable(1),f.layers.enable(2);let m=null,g=null;function y(t){const e=u.get(t.inputSource);e&&e.dispatchEvent({type:t.type,data:t.inputSource})}function v(){u.forEach(function(t,e){t.disconnect(e)}),u.clear(),m=null,g=null,i.bindXRFramebuffer(null),t.setRenderTarget(t.getRenderTarget()),S.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function b(t){const e=r.inputSources;for(let n=0;n<c.length;n++)u.set(e[n],c[n]);for(let n=0;n<t.removed.length;n++){const e=t.removed[n],i=u.get(e);i&&(i.dispatchEvent({type:"disconnected",data:e}),u.delete(e))}for(let n=0;n<t.added.length;n++){const e=t.added[n],i=u.get(e);i&&i.dispatchEvent({type:"connected",data:e})}}this.enabled=!1,this.isPresenting=!1,this.getController=function(t){let e=c[t];return void 0===e&&(e=new Vmt,c[t]=e),e.getTargetRaySpace()},this.getControllerGrip=function(t){let e=c[t];return void 0===e&&(e=new Vmt,c[t]=e),e.getGripSpace()},this.getHand=function(t){let e=c[t];return void 0===e&&(e=new Vmt,c[t]=e),e.getHandSpace()},this.setFramebufferScaleFactor=function(t){s=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(t){a=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return o},this.getSession=function(){return r},this.setSession=async function(t){if(r=t,null!==r){r.addEventListener("select",y),r.addEventListener("selectstart",y),r.addEventListener("selectend",y),r.addEventListener("squeeze",y),r.addEventListener("squeezestart",y),r.addEventListener("squeezeend",y),r.addEventListener("end",v),r.addEventListener("inputsourceschange",b);const t=e.getContextAttributes();!0!==t.xrCompatible&&await e.makeXRCompatible();const i=new XRWebGLLayer(r,e,{antialias:t.antialias,alpha:t.alpha,depth:t.depth,stencil:t.stencil,framebufferScaleFactor:s});r.updateRenderState({baseLayer:i}),o=await r.requestReferenceSpace(a),S.setContext(r),S.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};const A=new uht,x=new uht;function w(t,e){null===e?t.matrixWorld.copy(t.matrix):t.matrixWorld.multiplyMatrices(e.matrixWorld,t.matrix),t.matrixWorldInverse.copy(t.matrixWorld).invert()}this.getCamera=function(t){f.near=d.near=h.near=t.near,f.far=d.far=h.far=t.far,m===f.near&&g===f.far||(r.updateRenderState({depthNear:f.near,depthFar:f.far}),m=f.near,g=f.far);const e=t.parent,n=f.cameras;w(f,e);for(let r=0;r<n.length;r++)w(n[r],e);t.matrixWorld.copy(f.matrixWorld),t.matrix.copy(f.matrix),t.matrix.decompose(t.position,t.quaternion,t.scale);const i=t.children;for(let r=0,s=i.length;r<s;r++)i[r].updateMatrixWorld(!0);return 2===n.length?function(t,e,n){A.setFromMatrixPosition(e.matrixWorld),x.setFromMatrixPosition(n.matrixWorld);const i=A.distanceTo(x),r=e.projectionMatrix.elements,s=n.projectionMatrix.elements,o=r[14]/(r[10]-1),a=r[14]/(r[10]+1),l=(r[9]+1)/r[5],c=(r[9]-1)/r[5],u=(r[8]-1)/r[0],h=(s[8]+1)/s[0],d=o*u,p=o*h,f=i/(-u+h),m=f*-u;e.matrixWorld.decompose(t.position,t.quaternion,t.scale),t.translateX(m),t.translateZ(f),t.matrixWorld.compose(t.position,t.quaternion,t.scale),t.matrixWorldInverse.copy(t.matrixWorld).invert();const g=o+f,y=a+f;t.projectionMatrix.makePerspective(d-m,p+(i-m),l*a/y*g,c*a/y*g,g,y)}(f,h,d):f.projectionMatrix.copy(h.projectionMatrix),f};let _=null;const S=new Npt;S.setAnimationLoop(function(t,e){if(l=e.getViewerPose(o),null!==l){const t=l.views,e=r.renderState.baseLayer;i.bindXRFramebuffer(e.framebuffer);let n=!1;t.length!==f.cameras.length&&(f.cameras.length=0,n=!0);for(let i=0;i<t.length;i++){const r=t[i],s=e.getViewport(r),o=p[i];o.matrix.fromArray(r.transform.matrix),o.projectionMatrix.fromArray(r.projectionMatrix),o.viewport.set(s.x,s.y,s.width,s.height),0===i&&f.matrix.copy(o.matrix),!0===n&&f.cameras.push(o)}}const n=r.inputSources;for(let i=0;i<c.length;i++)c[i].update(n[i],e,o);_&&_(t,e)}),this.setAnimationLoop=function(t){_=t},this.dispose=function(){}}}function Wmt(t){function e(e,n){e.opacity.value=n.opacity,n.color&&e.diffuse.value.copy(n.color),n.emissive&&e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),n.map&&(e.map.value=n.map),n.alphaMap&&(e.alphaMap.value=n.alphaMap),n.specularMap&&(e.specularMap.value=n.specularMap);const i=t.get(n).envMap;if(i){e.envMap.value=i,e.flipEnvMap.value=i.isCubeTexture&&i._needsFlipEnvMap?-1:1,e.reflectivity.value=n.reflectivity,e.refractionRatio.value=n.refractionRatio;const r=t.get(i).__maxMipLevel;void 0!==r&&(e.maxMipLevel.value=r)}let r,s;n.lightMap&&(e.lightMap.value=n.lightMap,e.lightMapIntensity.value=n.lightMapIntensity),n.aoMap&&(e.aoMap.value=n.aoMap,e.aoMapIntensity.value=n.aoMapIntensity),n.map?r=n.map:n.specularMap?r=n.specularMap:n.displacementMap?r=n.displacementMap:n.normalMap?r=n.normalMap:n.bumpMap?r=n.bumpMap:n.roughnessMap?r=n.roughnessMap:n.metalnessMap?r=n.metalnessMap:n.alphaMap?r=n.alphaMap:n.emissiveMap?r=n.emissiveMap:n.clearcoatMap?r=n.clearcoatMap:n.clearcoatNormalMap?r=n.clearcoatNormalMap:n.clearcoatRoughnessMap&&(r=n.clearcoatRoughnessMap),void 0!==r&&(r.isWebGLRenderTarget&&(r=r.texture),!0===r.matrixAutoUpdate&&r.updateMatrix(),e.uvTransform.value.copy(r.matrix)),n.aoMap?s=n.aoMap:n.lightMap&&(s=n.lightMap),void 0!==s&&(s.isWebGLRenderTarget&&(s=s.texture),!0===s.matrixAutoUpdate&&s.updateMatrix(),e.uv2Transform.value.copy(s.matrix))}function n(e,n){e.roughness.value=n.roughness,e.metalness.value=n.metalness,n.roughnessMap&&(e.roughnessMap.value=n.roughnessMap),n.metalnessMap&&(e.metalnessMap.value=n.metalnessMap),n.emissiveMap&&(e.emissiveMap.value=n.emissiveMap),n.bumpMap&&(e.bumpMap.value=n.bumpMap,e.bumpScale.value=n.bumpScale,1===n.side&&(e.bumpScale.value*=-1)),n.normalMap&&(e.normalMap.value=n.normalMap,e.normalScale.value.copy(n.normalScale),1===n.side&&e.normalScale.value.negate()),n.displacementMap&&(e.displacementMap.value=n.displacementMap,e.displacementScale.value=n.displacementScale,e.displacementBias.value=n.displacementBias),t.get(n).envMap&&(e.envMapIntensity.value=n.envMapIntensity)}return{refreshFogUniforms:function(t,e){t.fogColor.value.copy(e.color),e.isFog?(t.fogNear.value=e.near,t.fogFar.value=e.far):e.isFogExp2&&(t.fogDensity.value=e.density)},refreshMaterialUniforms:function(t,i,r,s){i.isMeshBasicMaterial?e(t,i):i.isMeshLambertMaterial?(e(t,i),function(t,e){e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap)}(t,i)):i.isMeshToonMaterial?(e(t,i),function(t,e){e.gradientMap&&(t.gradientMap.value=e.gradientMap),e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap),e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1)),e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate()),e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshPhongMaterial?(e(t,i),function(t,e){t.specular.value.copy(e.specular),t.shininess.value=Math.max(e.shininess,1e-4),e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap),e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1)),e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate()),e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshStandardMaterial?(e(t,i),i.isMeshPhysicalMaterial?function(t,e){n(t,e),t.reflectivity.value=e.reflectivity,t.clearcoat.value=e.clearcoat,t.clearcoatRoughness.value=e.clearcoatRoughness,e.sheen&&t.sheen.value.copy(e.sheen),e.clearcoatMap&&(t.clearcoatMap.value=e.clearcoatMap),e.clearcoatRoughnessMap&&(t.clearcoatRoughnessMap.value=e.clearcoatRoughnessMap),e.clearcoatNormalMap&&(t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),t.clearcoatNormalMap.value=e.clearcoatNormalMap,1===e.side&&t.clearcoatNormalScale.value.negate()),t.transmission.value=e.transmission,e.transmissionMap&&(t.transmissionMap.value=e.transmissionMap)}(t,i):n(t,i)):i.isMeshMatcapMaterial?(e(t,i),function(t,e){e.matcap&&(t.matcap.value=e.matcap),e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1)),e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate()),e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshDepthMaterial?(e(t,i),function(t,e){e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshDistanceMaterial?(e(t,i),function(t,e){e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias),t.referencePosition.value.copy(e.referencePosition),t.nearDistance.value=e.nearDistance,t.farDistance.value=e.farDistance}(t,i)):i.isMeshNormalMaterial?(e(t,i),function(t,e){e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1)),e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate()),e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isLineBasicMaterial?(function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity}(t,i),i.isLineDashedMaterial&&function(t,e){t.dashSize.value=e.dashSize,t.totalSize.value=e.dashSize+e.gapSize,t.scale.value=e.scale}(t,i)):i.isPointsMaterial?function(t,e,n,i){let r;t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.size.value=e.size*n,t.scale.value=.5*i,e.map&&(t.map.value=e.map),e.alphaMap&&(t.alphaMap.value=e.alphaMap),e.map?r=e.map:e.alphaMap&&(r=e.alphaMap),void 0!==r&&(!0===r.matrixAutoUpdate&&r.updateMatrix(),t.uvTransform.value.copy(r.matrix))}(t,i,r,s):i.isSpriteMaterial?function(t,e){let n;t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.rotation.value=e.rotation,e.map&&(t.map.value=e.map),e.alphaMap&&(t.alphaMap.value=e.alphaMap),e.map?n=e.map:e.alphaMap&&(n=e.alphaMap),void 0!==n&&(!0===n.matrixAutoUpdate&&n.updateMatrix(),t.uvTransform.value.copy(n.matrix))}(t,i):i.isShadowMaterial?(t.color.value.copy(i.color),t.opacity.value=i.opacity):i.isShaderMaterial&&(i.uniformsNeedUpdate=!1)}}}function jmt(t){const e=void 0!==(t=t||{}).canvas?t.canvas:function(){const t=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return t.style.display="block",t}(),n=void 0!==t.context?t.context:null,i=void 0!==t.alpha&&t.alpha,r=void 0===t.depth||t.depth,s=void 0===t.stencil||t.stencil,o=void 0!==t.antialias&&t.antialias,a=void 0===t.premultipliedAlpha||t.premultipliedAlpha,l=void 0!==t.preserveDrawingBuffer&&t.preserveDrawingBuffer,c=void 0!==t.powerPreference?t.powerPreference:"default",u=void 0!==t.failIfMajorPerformanceCaveat&&t.failIfMajorPerformanceCaveat;let h=null,d=null;const p=[],f=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=3e3,this.physicallyCorrectLights=!1,this.toneMapping=0,this.toneMappingExposure=1;const m=this;let g=!1,y=0,v=0,b=null,A=-1,x=null;const w=new aht,_=new aht;let S=null,E=e.width,C=e.height,I=1,T=null,M=null;const k=new aht(0,0,E,C),R=new aht(0,0,E,C);let N=!1;const L=new Rpt;let D=!1,B=!1;const O=new Uht,P=new uht,F={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function $(){return null===b?I:1}let z,U,H,V,G,W,j,Q,q,X,Y,K,J,Z,tt,et,nt,it,rt,st,ot,at,lt=n;function ct(t,n){for(let i=0;i<t.length;i++){const r=e.getContext(t[i],n);if(null!==r)return r}return null}try{const t={alpha:i,depth:r,stencil:s,antialias:o,premultipliedAlpha:a,preserveDrawingBuffer:l,powerPreference:c,failIfMajorPerformanceCaveat:u};if(e.addEventListener("webglcontextlost",dt,!1),e.addEventListener("webglcontextrestored",pt,!1),null===lt){const e=["webgl2","webgl","experimental-webgl"];if(!0===m.isWebGL1Renderer&&e.shift(),lt=ct(e,t),null===lt)throw ct(e)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===lt.getShaderPrecisionFormat&&(lt.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(t){throw console.error("THREE.WebGLRenderer: "+t.message),t}function ut(){z=new Gpt(lt),U=new Upt(lt,z,t),z.init(U),ot=new $mt(lt,z,U),H=new Pmt(lt,z,U),V=new Qpt(lt),G=new _mt,W=new Fmt(lt,z,H,G,U,ot,V),j=new Vpt(m),Q=new Lpt(lt,U),at=new $pt(lt,z,Q,U),q=new Wpt(lt,Q,V,at),X=new Kpt(lt,q,Q,V),it=new Ypt(lt),tt=new Hpt(G),Y=new wmt(m,j,z,U,at,tt),K=new Wmt(G),J=new Imt(G),Z=new Lmt(z,U),nt=new Fpt(m,j,H,X,a),et=new Omt(m,X,U),rt=new zpt(lt,z,V,U),st=new jpt(lt,z,V,U),V.programs=Y.programs,m.capabilities=U,m.extensions=z,m.properties=G,m.renderLists=J,m.shadowMap=et,m.state=H,m.info=V}ut();const ht=new Gmt(m,lt);function dt(t){t.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),g=!0}function pt(){console.log("THREE.WebGLRenderer: Context Restored."),g=!1;const t=V.autoReset,e=et.enabled,n=et.autoUpdate,i=et.needsUpdate,r=et.type;ut(),V.autoReset=t,et.enabled=e,et.autoUpdate=n,et.needsUpdate=i,et.type=r}function ft(t){const e=t.target;e.removeEventListener("dispose",ft),function(t){(function(t){const e=G.get(t).programs;void 0!==e&&e.forEach(function(t){Y.releaseProgram(t)})})(t),G.remove(t)}(e)}this.xr=ht,this.getContext=function(){return lt},this.getContextAttributes=function(){return lt.getContextAttributes()},this.forceContextLoss=function(){const t=z.get("WEBGL_lose_context");t&&t.loseContext()},this.forceContextRestore=function(){const t=z.get("WEBGL_lose_context");t&&t.restoreContext()},this.getPixelRatio=function(){return I},this.setPixelRatio=function(t){void 0!==t&&(I=t,this.setSize(E,C,!1))},this.getSize=function(t){return void 0===t&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),t=new tht),t.set(E,C)},this.setSize=function(t,n,i){ht.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(E=t,C=n,e.width=Math.floor(t*I),e.height=Math.floor(n*I),!1!==i&&(e.style.width=t+"px",e.style.height=n+"px"),this.setViewport(0,0,t,n))},this.getDrawingBufferSize=function(t){return void 0===t&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),t=new tht),t.set(E*I,C*I).floor()},this.setDrawingBufferSize=function(t,n,i){E=t,C=n,I=i,e.width=Math.floor(t*i),e.height=Math.floor(n*i),this.setViewport(0,0,t,n)},this.getCurrentViewport=function(t){return void 0===t&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),t=new aht),t.copy(w)},this.getViewport=function(t){return t.copy(k)},this.setViewport=function(t,e,n,i){t.isVector4?k.set(t.x,t.y,t.z,t.w):k.set(t,e,n,i),H.viewport(w.copy(k).multiplyScalar(I).floor())},this.getScissor=function(t){return t.copy(R)},this.setScissor=function(t,e,n,i){t.isVector4?R.set(t.x,t.y,t.z,t.w):R.set(t,e,n,i),H.scissor(_.copy(R).multiplyScalar(I).floor())},this.getScissorTest=function(){return N},this.setScissorTest=function(t){H.setScissorTest(N=t)},this.setOpaqueSort=function(t){T=t},this.setTransparentSort=function(t){M=t},this.getClearColor=function(t){return void 0===t&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),t=new Odt),t.copy(nt.getClearColor())},this.setClearColor=function(){nt.setClearColor.apply(nt,arguments)},this.getClearAlpha=function(){return nt.getClearAlpha()},this.setClearAlpha=function(){nt.setClearAlpha.apply(nt,arguments)},this.clear=function(t,e,n){let i=0;(void 0===t||t)&&(i|=16384),(void 0===e||e)&&(i|=256),(void 0===n||n)&&(i|=1024),lt.clear(i)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",dt,!1),e.removeEventListener("webglcontextrestored",pt,!1),J.dispose(),Z.dispose(),G.dispose(),j.dispose(),X.dispose(),at.dispose(),ht.dispose(),ht.removeEventListener("sessionstart",gt),ht.removeEventListener("sessionend",yt),vt.stop()},this.renderBufferImmediate=function(t,e){at.initAttributes();const n=G.get(t);t.hasPositions&&!n.position&&(n.position=lt.createBuffer()),t.hasNormals&&!n.normal&&(n.normal=lt.createBuffer()),t.hasUvs&&!n.uv&&(n.uv=lt.createBuffer()),t.hasColors&&!n.color&&(n.color=lt.createBuffer());const i=e.getAttributes();t.hasPositions&&(lt.bindBuffer(34962,n.position),lt.bufferData(34962,t.positionArray,35048),at.enableAttribute(i.position),lt.vertexAttribPointer(i.position,3,5126,!1,0,0)),t.hasNormals&&(lt.bindBuffer(34962,n.normal),lt.bufferData(34962,t.normalArray,35048),at.enableAttribute(i.normal),lt.vertexAttribPointer(i.normal,3,5126,!1,0,0)),t.hasUvs&&(lt.bindBuffer(34962,n.uv),lt.bufferData(34962,t.uvArray,35048),at.enableAttribute(i.uv),lt.vertexAttribPointer(i.uv,2,5126,!1,0,0)),t.hasColors&&(lt.bindBuffer(34962,n.color),lt.bufferData(34962,t.colorArray,35048),at.enableAttribute(i.color),lt.vertexAttribPointer(i.color,3,5126,!1,0,0)),at.disableUnusedAttributes(),lt.drawArrays(4,0,t.count),t.count=0},this.renderBufferDirect=function(t,e,n,i,r,s){null===e&&(e=F);const o=r.isMesh&&r.matrixWorld.determinant()<0,a=St(t,e,i,r);H.setMaterial(i,o);let l=n.index;const c=n.attributes.position;if(null===l){if(void 0===c||0===c.count)return}else if(0===l.count)return;let u,h=1;!0===i.wireframe&&(l=q.getWireframeAttribute(n),h=2),(i.morphTargets||i.morphNormals)&&it.update(r,n,i,a),at.setup(r,i,a,n,l);let d=rt;null!==l&&(u=Q.get(l),d=st,d.setIndex(u));const p=null!==l?l.count:c.count,f=n.drawRange.start*h,m=n.drawRange.count*h,g=null!==s?s.start*h:0,y=null!==s?s.count*h:1/0,v=Math.max(f,g),b=Math.min(p,f+m,g+y)-1,A=Math.max(0,b-v+1);if(0!==A){if(r.isMesh)!0===i.wireframe?(H.setLineWidth(i.wireframeLinewidth*$()),d.setMode(1)):d.setMode(4);else if(r.isLine){let t=i.linewidth;void 0===t&&(t=1),H.setLineWidth(t*$()),d.setMode(r.isLineSegments?1:r.isLineLoop?2:3)}else r.isPoints?d.setMode(0):r.isSprite&&d.setMode(4);if(r.isInstancedMesh)d.renderInstances(v,A,r.count);else if(n.isInstancedBufferGeometry){const t=Math.min(n.instanceCount,n._maxInstanceCount);d.renderInstances(v,A,t)}else d.render(v,A)}},this.compile=function(t,e){d=Z.get(t),d.init(),t.traverseVisible(function(t){t.isLight&&t.layers.test(e.layers)&&(d.pushLight(t),t.castShadow&&d.pushShadow(t))}),d.setupLights(),t.traverse(function(e){const n=e.material;if(n)if(Array.isArray(n))for(let i=0;i<n.length;i++)wt(n[i],t,e);else wt(n,t,e)})};let mt=null;function gt(){vt.stop()}function yt(){vt.start()}const vt=new Npt;function bt(t,e,n,i){if(!1===t.visible)return;if(t.layers.test(e.layers))if(t.isGroup)n=t.renderOrder;else if(t.isLOD)!0===t.autoUpdate&&t.update(e);else if(t.isLight)d.pushLight(t),t.castShadow&&d.pushShadow(t);else if(t.isSprite){if(!t.frustumCulled||L.intersectsSprite(t)){i&&P.setFromMatrixPosition(t.matrixWorld).applyMatrix4(O);const e=X.update(t),r=t.material;r.visible&&h.push(t,e,r,n,P.z,null)}}else if(t.isImmediateRenderObject)i&&P.setFromMatrixPosition(t.matrixWorld).applyMatrix4(O),h.push(t,null,t.material,n,P.z,null);else if((t.isMesh||t.isLine||t.isPoints)&&(t.isSkinnedMesh&&t.skeleton.frame!==V.render.frame&&(t.skeleton.update(),t.skeleton.frame=V.render.frame),!t.frustumCulled||L.intersectsObject(t))){i&&P.setFromMatrixPosition(t.matrixWorld).applyMatrix4(O);const e=X.update(t),r=t.material;if(Array.isArray(r)){const i=e.groups;for(let s=0,o=i.length;s<o;s++){const o=i[s],a=r[o.materialIndex];a&&a.visible&&h.push(t,e,a,n,P.z,o)}}else r.visible&&h.push(t,e,r,n,P.z,null)}const r=t.children;for(let s=0,o=r.length;s<o;s++)bt(r[s],e,n,i)}function At(t,e,n){const i=!0===e.isScene?e.overrideMaterial:null;for(let r=0,s=t.length;r<s;r++){const s=t[r],o=s.object,a=s.geometry,l=null===i?s.material:i,c=s.group;if(n.isArrayCamera){const t=n.cameras;for(let n=0,i=t.length;n<i;n++){const i=t[n];o.layers.test(i.layers)&&(H.viewport(w.copy(i.viewport)),d.setupLightsView(i),xt(o,e,i,a,l,c))}}else xt(o,e,n,a,l,c)}}function xt(t,e,n,i,r,s){if(t.onBeforeRender(m,e,n,i,r,s),t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix),t.isImmediateRenderObject){const i=St(n,e,r,t);H.setMaterial(r),at.reset(),function(t,e){t.render(function(t){m.renderBufferImmediate(t,e)})}(t,i)}else m.renderBufferDirect(n,e,i,r,t,s);t.onAfterRender(m,e,n,i,r,s)}function wt(t,e,n){!0!==e.isScene&&(e=F);const i=G.get(t),r=d.state.lights,s=r.state.version,o=Y.getParameters(t,r.state,d.state.shadowsArray,e,n),a=Y.getProgramCacheKey(o);let l=i.programs;i.environment=t.isMeshStandardMaterial?e.environment:null,i.fog=e.fog,i.envMap=j.get(t.envMap||i.environment),void 0===l&&(t.addEventListener("dispose",ft),l=new Map,i.programs=l);let c=l.get(a);if(void 0!==c){if(i.currentProgram===c&&i.lightsStateVersion===s)return _t(t,o),c}else o.uniforms=Y.getUniforms(t),t.onBuild(o,m),t.onBeforeCompile(o,m),c=Y.acquireProgram(o,a),l.set(a,c),i.uniforms=o.uniforms;const u=i.uniforms;(t.isShaderMaterial||t.isRawShaderMaterial)&&!0!==t.clipping||(u.clippingPlanes=tt.uniform),_t(t,o),i.needsLights=function(t){return t.isMeshLambertMaterial||t.isMeshToonMaterial||t.isMeshPhongMaterial||t.isMeshStandardMaterial||t.isShadowMaterial||t.isShaderMaterial&&!0===t.lights}(t),i.lightsStateVersion=s,i.needsLights&&(u.ambientLightColor.value=r.state.ambient,u.lightProbe.value=r.state.probe,u.directionalLights.value=r.state.directional,u.directionalLightShadows.value=r.state.directionalShadow,u.spotLights.value=r.state.spot,u.spotLightShadows.value=r.state.spotShadow,u.rectAreaLights.value=r.state.rectArea,u.ltc_1.value=r.state.rectAreaLTC1,u.ltc_2.value=r.state.rectAreaLTC2,u.pointLights.value=r.state.point,u.pointLightShadows.value=r.state.pointShadow,u.hemisphereLights.value=r.state.hemi,u.directionalShadowMap.value=r.state.directionalShadowMap,u.directionalShadowMatrix.value=r.state.directionalShadowMatrix,u.spotShadowMap.value=r.state.spotShadowMap,u.spotShadowMatrix.value=r.state.spotShadowMatrix,u.pointShadowMap.value=r.state.pointShadowMap,u.pointShadowMatrix.value=r.state.pointShadowMatrix);const h=c.getUniforms(),p=emt.seqWithValue(h.seq,u);return i.currentProgram=c,i.uniformsList=p,c}function _t(t,e){const n=G.get(t);n.outputEncoding=e.outputEncoding,n.instancing=e.instancing,n.numClippingPlanes=e.numClippingPlanes,n.numIntersection=e.numClipIntersection,n.vertexAlphas=e.vertexAlphas}function St(t,e,n,i){!0!==e.isScene&&(e=F),W.resetTextureUnits();const r=e.fog,s=null===b?m.outputEncoding:b.texture.encoding,o=j.get(n.envMap||(n.isMeshStandardMaterial?e.environment:null)),a=!0===n.vertexColors&&i.geometry&&i.geometry.attributes.color&&4===i.geometry.attributes.color.itemSize,l=G.get(n),c=d.state.lights;!0!==D||!0!==B&&t===x||tt.setState(n,t,t===x&&n.id===A);let u=!1;n.version===l.__version?l.needsLights&&l.lightsStateVersion!==c.state.version||l.outputEncoding!==s||i.isInstancedMesh&&!1===l.instancing?u=!0:i.isInstancedMesh||!0!==l.instancing?l.envMap!==o||n.fog&&l.fog!==r?u=!0:void 0===l.numClippingPlanes||l.numClippingPlanes===tt.numPlanes&&l.numIntersection===tt.numIntersection?l.vertexAlphas!==a&&(u=!0):u=!0:u=!0:(u=!0,l.__version=n.version);let h=l.currentProgram;!0===u&&(h=wt(n,e,i));let p=!1,f=!1,g=!1;const y=h.getUniforms(),v=l.uniforms;if(H.useProgram(h.program)&&(p=!0,f=!0,g=!0),n.id!==A&&(A=n.id,f=!0),p||x!==t){if(y.setValue(lt,"projectionMatrix",t.projectionMatrix),U.logarithmicDepthBuffer&&y.setValue(lt,"logDepthBufFC",2/(Math.log(t.far+1)/Math.LN2)),x!==t&&(x=t,f=!0,g=!0),n.isShaderMaterial||n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshStandardMaterial||n.envMap){const e=y.map.cameraPosition;void 0!==e&&e.setValue(lt,P.setFromMatrixPosition(t.matrixWorld))}(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial)&&y.setValue(lt,"isOrthographic",!0===t.isOrthographicCamera),(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial||n.isShadowMaterial||n.skinning)&&y.setValue(lt,"viewMatrix",t.matrixWorldInverse)}if(n.skinning){y.setOptional(lt,i,"bindMatrix"),y.setOptional(lt,i,"bindMatrixInverse");const t=i.skeleton;if(t){const e=t.bones;if(U.floatVertexTextures){if(null===t.boneTexture){let n=Math.sqrt(4*e.length);n=Kut(n),n=Math.max(n,4);const i=new Float32Array(n*n*4);i.set(t.boneMatrices);const r=new Tpt(i,n,n,1023,1015);t.boneMatrices=i,t.boneTexture=r,t.boneTextureSize=n}y.setValue(lt,"boneTexture",t.boneTexture,W),y.setValue(lt,"boneTextureSize",t.boneTextureSize)}else y.setOptional(lt,t,"boneMatrices")}}var w,_;return(f||l.receiveShadow!==i.receiveShadow)&&(l.receiveShadow=i.receiveShadow,y.setValue(lt,"receiveShadow",i.receiveShadow)),f&&(y.setValue(lt,"toneMappingExposure",m.toneMappingExposure),l.needsLights&&((w=v).ambientLightColor.needsUpdate=_=g,w.lightProbe.needsUpdate=_,w.directionalLights.needsUpdate=_,w.directionalLightShadows.needsUpdate=_,w.pointLights.needsUpdate=_,w.pointLightShadows.needsUpdate=_,w.spotLights.needsUpdate=_,w.spotLightShadows.needsUpdate=_,w.rectAreaLights.needsUpdate=_,w.hemisphereLights.needsUpdate=_),r&&n.fog&&K.refreshFogUniforms(v,r),K.refreshMaterialUniforms(v,n,I,C),emt.upload(lt,l.uniformsList,v,W)),n.isShaderMaterial&&!0===n.uniformsNeedUpdate&&(emt.upload(lt,l.uniformsList,v,W),n.uniformsNeedUpdate=!1),n.isSpriteMaterial&&y.setValue(lt,"center",i.center),y.setValue(lt,"modelViewMatrix",i.modelViewMatrix),y.setValue(lt,"normalMatrix",i.normalMatrix),y.setValue(lt,"modelMatrix",i.matrixWorld),h}vt.setAnimationLoop(function(t){mt&&mt(t)}),"undefined"!=typeof window&&vt.setContext(window),this.setAnimationLoop=function(t){mt=t,ht.setAnimationLoop(t),null===t?vt.stop():vt.start()},ht.addEventListener("sessionstart",gt),ht.addEventListener("sessionend",yt),this.render=function(t,e){let n,i;if(void 0!==arguments[2]&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),n=arguments[2]),void 0!==arguments[3]&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),i=arguments[3]),void 0!==e&&!0!==e.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===g)return;!0===t.autoUpdate&&t.updateMatrixWorld(),null===e.parent&&e.updateMatrixWorld(),!0===ht.enabled&&!0===ht.isPresenting&&(e=ht.getCamera(e)),!0===t.isScene&&t.onBeforeRender(m,t,e,n||b),d=Z.get(t,f.length),d.init(),f.push(d),O.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),L.setFromProjectionMatrix(O),B=this.localClippingEnabled,D=tt.init(this.clippingPlanes,B,e),h=J.get(t,p.length),h.init(),p.push(h),bt(t,e,0,m.sortObjects),h.finish(),!0===m.sortObjects&&h.sort(T,M),!0===D&&tt.beginShadows();const r=d.state.shadowsArray;et.render(r,t,e),d.setupLights(),d.setupLightsView(e),!0===D&&tt.endShadows(),!0===this.info.autoReset&&this.info.reset(),void 0!==n&&this.setRenderTarget(n),nt.render(h,t,e,i);const s=h.opaque,o=h.transparent;s.length>0&&At(s,t,e),o.length>0&&At(o,t,e),null!==b&&(W.updateRenderTargetMipmap(b),W.updateMultisampleRenderTarget(b)),!0===t.isScene&&t.onAfterRender(m,t,e),H.buffers.depth.setTest(!0),H.buffers.depth.setMask(!0),H.buffers.color.setMask(!0),H.setPolygonOffset(!1),at.resetDefaultState(),A=-1,x=null,f.pop(),d=f.length>0?f[f.length-1]:null,p.pop(),h=p.length>0?p[p.length-1]:null},this.getActiveCubeFace=function(){return y},this.getActiveMipmapLevel=function(){return v},this.getRenderTarget=function(){return b},this.setRenderTarget=function(t,e=0,n=0){b=t,y=e,v=n,t&&void 0===G.get(t).__webglFramebuffer&&W.setupRenderTarget(t);let i=null,r=!1,s=!1;if(t){const n=t.texture;(n.isDataTexture3D||n.isDataTexture2DArray)&&(s=!0);const o=G.get(t).__webglFramebuffer;t.isWebGLCubeRenderTarget?(i=o[e],r=!0):i=t.isWebGLMultisampleRenderTarget?G.get(t).__webglMultisampledFramebuffer:o,w.copy(t.viewport),_.copy(t.scissor),S=t.scissorTest}else w.copy(k).multiplyScalar(I).floor(),_.copy(R).multiplyScalar(I).floor(),S=N;if(H.bindFramebuffer(36160,i),H.viewport(w),H.scissor(_),H.setScissorTest(S),r){const i=G.get(t.texture);lt.framebufferTexture2D(36160,36064,34069+e,i.__webglTexture,n)}else if(s){const i=G.get(t.texture);lt.framebufferTextureLayer(36160,36064,i.__webglTexture,n||0,e||0)}},this.readRenderTargetPixels=function(t,e,n,i,r,s,o){if(!t||!t.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let a=G.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==o&&(a=a[o]),a){H.bindFramebuffer(36160,a);try{const o=t.texture,a=o.format,l=o.type;if(1023!==a&&ot.convert(a)!==lt.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const c=1016===l&&(z.has("EXT_color_buffer_half_float")||U.isWebGL2&&z.has("EXT_color_buffer_float"));if(!(1009===l||ot.convert(l)===lt.getParameter(35738)||1015===l&&(U.isWebGL2||z.has("OES_texture_float")||z.has("WEBGL_color_buffer_float"))||c))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");36053===lt.checkFramebufferStatus(36160)?e>=0&&e<=t.width-i&&n>=0&&n<=t.height-r&&lt.readPixels(e,n,i,r,ot.convert(a),ot.convert(l),s):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const t=null!==b?G.get(b).__webglFramebuffer:null;H.bindFramebuffer(36160,t)}}},this.copyFramebufferToTexture=function(t,e,n=0){const i=Math.pow(2,-n),r=Math.floor(e.image.width*i),s=Math.floor(e.image.height*i),o=ot.convert(e.format);W.setTexture2D(e,0),lt.copyTexImage2D(3553,n,o,t.x,t.y,r,s,0),H.unbindTexture()},this.copyTextureToTexture=function(t,e,n,i=0){const r=e.image.width,s=e.image.height,o=ot.convert(n.format),a=ot.convert(n.type);W.setTexture2D(n,0),lt.pixelStorei(37440,n.flipY),lt.pixelStorei(37441,n.premultiplyAlpha),lt.pixelStorei(3317,n.unpackAlignment),e.isDataTexture?lt.texSubImage2D(3553,i,t.x,t.y,r,s,o,a,e.image.data):e.isCompressedTexture?lt.compressedTexSubImage2D(3553,i,t.x,t.y,e.mipmaps[0].width,e.mipmaps[0].height,o,e.mipmaps[0].data):lt.texSubImage2D(3553,i,t.x,t.y,o,a,e.image),0===i&&n.generateMipmaps&&lt.generateMipmap(3553),H.unbindTexture()},this.copyTextureToTexture3D=function(t,e,n,i,r=0){if(m.isWebGL1Renderer)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const{width:s,height:o,data:a}=n.image,l=ot.convert(i.format),c=ot.convert(i.type);let u;if(i.isDataTexture3D)W.setTexture3D(i,0),u=32879;else{if(!i.isDataTexture2DArray)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");W.setTexture2DArray(i,0),u=35866}lt.pixelStorei(37440,i.flipY),lt.pixelStorei(37441,i.premultiplyAlpha),lt.pixelStorei(3317,i.unpackAlignment);const h=lt.getParameter(3314),d=lt.getParameter(32878),p=lt.getParameter(3316),f=lt.getParameter(3315),g=lt.getParameter(32877);lt.pixelStorei(3314,s),lt.pixelStorei(32878,o),lt.pixelStorei(3316,t.min.x),lt.pixelStorei(3315,t.min.y),lt.pixelStorei(32877,t.min.z),lt.texSubImage3D(u,r,e.x,e.y,e.z,t.max.x-t.min.x+1,t.max.y-t.min.y+1,t.max.z-t.min.z+1,l,c,a),lt.pixelStorei(3314,h),lt.pixelStorei(32878,d),lt.pixelStorei(3316,p),lt.pixelStorei(3315,f),lt.pixelStorei(32877,g),0===r&&i.generateMipmaps&&lt.generateMipmap(u),H.unbindTexture()},this.initTexture=function(t){W.setTexture2D(t,0),H.unbindTexture()},this.resetState=function(){y=0,v=0,b=null,H.reset(),at.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class Qmt extends jmt{}Qmt.prototype.isWebGL1Renderer=!0;class qmt extends ddt{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),null!==t.background&&(this.background=t.background.clone()),null!==t.environment&&(this.environment=t.environment.clone()),null!==t.fog&&(this.fog=t.fog.clone()),null!==t.overrideMaterial&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return null!==this.background&&(e.object.background=this.background.toJSON(t)),null!==this.environment&&(e.object.environment=this.environment.toJSON(t)),null!==this.fog&&(e.object.fog=this.fog.toJSON()),e}}qmt.prototype.isScene=!0;class Xmt{constructor(t,e){this.array=t,this.stride=e,this.count=void 0!==t?t.length/e:0,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=jut(),this.onUploadCallback=function(){}}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,n){t*=this.stride,n*=e.stride;for(let i=0,r=this.stride;i<r;i++)this.array[t+i]=e.array[n+i];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=jut()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),n=new Xmt(e,this.stride);return n.setUsage(this.usage),n}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=jut()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}Xmt.prototype.isInterleavedBuffer=!0;const Ymt=new uht;class Kmt{constructor(t,e,n,i){this.name="",this.data=t,this.itemSize=e,this.offset=n,this.normalized=!0===i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,n=this.data.count;e<n;e++)Ymt.x=this.getX(e),Ymt.y=this.getY(e),Ymt.z=this.getZ(e),Ymt.applyMatrix4(t),this.setXYZ(e,Ymt.x,Ymt.y,Ymt.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)Ymt.x=this.getX(e),Ymt.y=this.getY(e),Ymt.z=this.getZ(e),Ymt.applyNormalMatrix(t),this.setXYZ(e,Ymt.x,Ymt.y,Ymt.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)Ymt.x=this.getX(e),Ymt.y=this.getY(e),Ymt.z=this.getZ(e),Ymt.transformDirection(t),this.setXYZ(e,Ymt.x,Ymt.y,Ymt.z);return this}setX(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){return this.data.array[t*this.data.stride+this.offset]}getY(t){return this.data.array[t*this.data.stride+this.offset+1]}getZ(t){return this.data.array[t*this.data.stride+this.offset+2]}getW(t){return this.data.array[t*this.data.stride+this.offset+3]}setXY(t,e,n){return this.data.array[(t=t*this.data.stride+this.offset)+0]=e,this.data.array[t+1]=n,this}setXYZ(t,e,n,i){return this.data.array[(t=t*this.data.stride+this.offset)+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this}setXYZW(t,e,n,i,r){return this.data.array[(t=t*this.data.stride+this.offset)+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this.data.array[t+3]=r,this}clone(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return new zdt(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new Kmt(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}Kmt.prototype.isInterleavedBufferAttribute=!0;const Jmt=new uht,Zmt=new aht,tgt=new aht,egt=new uht,ngt=new Uht;class igt extends gpt{constructor(t,e){super(t,e),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Uht,this.bindMatrixInverse=new Uht}copy(t){return super.copy(t),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this}bind(t,e){this.skeleton=t,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new aht,e=this.geometry.attributes.skinWeight;for(let n=0,i=e.count;n<i;n++){t.x=e.getX(n),t.y=e.getY(n),t.z=e.getZ(n),t.w=e.getW(n);const i=1/t.manhattanLength();i!==1/0?t.multiplyScalar(i):t.set(1,0,0,0),e.setXYZW(n,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(t,e){const n=this.skeleton,i=this.geometry;Zmt.fromBufferAttribute(i.attributes.skinIndex,t),tgt.fromBufferAttribute(i.attributes.skinWeight,t),Jmt.fromBufferAttribute(i.attributes.position,t).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let r=0;r<4;r++){const t=tgt.getComponent(r);if(0!==t){const i=Zmt.getComponent(r);ngt.multiplyMatrices(n.bones[i].matrixWorld,n.boneInverses[i]),e.addScaledVector(egt.copy(Jmt).applyMatrix4(ngt),t)}}return e.applyMatrix4(this.bindMatrixInverse)}}igt.prototype.isSkinnedMesh=!0;class rgt extends ddt{constructor(){super(),this.type="Bone"}}rgt.prototype.isBone=!0;const sgt=new Uht,ogt=new Uht;class agt{constructor(t=[],e=[]){this.uuid=jut(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(16*t.length),0===e.length)this.calculateInverses();else if(t.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let t=0,e=this.bones.length;t<e;t++)this.boneInverses.push(new Uht)}}calculateInverses(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const e=new Uht;this.bones[t]&&e.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(e)}}pose(){for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&e.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&(e.parent&&e.parent.isBone?(e.matrix.copy(e.parent.matrixWorld).invert(),e.matrix.multiply(e.matrixWorld)):e.matrix.copy(e.matrixWorld),e.matrix.decompose(e.position,e.quaternion,e.scale))}}update(){const t=this.bones,e=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let r=0,s=t.length;r<s;r++)sgt.multiplyMatrices(t[r]?t[r].matrixWorld:ogt,e[r]),sgt.toArray(n,16*r);null!==i&&(i.needsUpdate=!0)}clone(){return new agt(this.bones,this.boneInverses)}getBoneByName(t){for(let e=0,n=this.bones.length;e<n;e++){const n=this.bones[e];if(n.name===t)return n}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(t,e){this.uuid=t.uuid;for(let n=0,i=t.bones.length;n<i;n++){const i=t.bones[n];let r=e[i];void 0===r&&(console.warn("THREE.Skeleton: No bone found with UUID:",i),r=new rgt),this.bones.push(r),this.boneInverses.push((new Uht).fromArray(t.boneInverses[n]))}return this.init(),this}toJSON(){const t={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,n=this.boneInverses;for(let i=0,r=e.length;i<r;i++)t.bones.push(e[i].uuid),t.boneInverses.push(n[i].toArray());return t}}class lgt extends Mdt{constructor(t){super(),this.type="LineBasicMaterial",this.color=new Odt(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.morphTargets=t.morphTargets,this}}lgt.prototype.isLineBasicMaterial=!0;const cgt=new uht,ugt=new uht,hgt=new Uht,dgt=new zht,pgt=new Nht;class fgt extends ddt{constructor(t=new Jdt,e=new lgt){super(),this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(null===t.index){const e=t.attributes.position,n=[0];for(let t=1,i=e.count;t<i;t++)cgt.fromBufferAttribute(e,t-1),ugt.fromBufferAttribute(e,t),n[t]=n[t-1],n[t]+=cgt.distanceTo(ugt);t.setAttribute("lineDistance",new Vdt(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,r=t.params.Line.threshold,s=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),pgt.copy(n.boundingSphere),pgt.applyMatrix4(i),pgt.radius+=r,!1===t.ray.intersectsSphere(pgt))return;hgt.copy(i).invert(),dgt.copy(t.ray).applyMatrix4(hgt);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),a=o*o,l=new uht,c=new uht,u=new uht,h=new uht,d=this.isLineSegments?2:1;if(n.isBufferGeometry){const i=n.index,r=n.attributes.position;if(null!==i)for(let n=Math.max(0,s.start),o=Math.min(i.count,s.start+s.count)-1;n<o;n+=d){const s=i.getX(n),o=i.getX(n+1);if(l.fromBufferAttribute(r,s),c.fromBufferAttribute(r,o),dgt.distanceSqToSegment(l,c,h,u)>a)continue;h.applyMatrix4(this.matrixWorld);const d=t.ray.origin.distanceTo(h);d<t.near||d>t.far||e.push({distance:d,point:u.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}else for(let n=Math.max(0,s.start),o=Math.min(r.count,s.start+s.count)-1;n<o;n+=d){if(l.fromBufferAttribute(r,n),c.fromBufferAttribute(r,n+1),dgt.distanceSqToSegment(l,c,h,u)>a)continue;h.applyMatrix4(this.matrixWorld);const i=t.ray.origin.distanceTo(h);i<t.near||i>t.far||e.push({distance:i,point:u.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}fgt.prototype.isLine=!0;const mgt=new uht,ggt=new uht;class ygt extends fgt{constructor(t,e){super(t,e),this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(null===t.index){const e=t.attributes.position,n=[];for(let t=0,i=e.count;t<i;t+=2)mgt.fromBufferAttribute(e,t),ggt.fromBufferAttribute(e,t+1),n[t]=0===t?0:n[t-1],n[t+1]=n[t]+mgt.distanceTo(ggt);t.setAttribute("lineDistance",new Vdt(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}ygt.prototype.isLineSegments=!0;class vgt extends fgt{constructor(t,e){super(t,e),this.type="LineLoop"}}vgt.prototype.isLineLoop=!0;class bgt extends Mdt{constructor(t){super(),this.type="PointsMaterial",this.color=new Odt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.morphTargets=t.morphTargets,this}}bgt.prototype.isPointsMaterial=!0;const Agt=new Uht,xgt=new zht,wgt=new Nht,_gt=new uht;class Sgt extends ddt{constructor(t=new Jdt,e=new bgt){super(),this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,r=t.params.Points.threshold,s=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),wgt.copy(n.boundingSphere),wgt.applyMatrix4(i),wgt.radius+=r,!1===t.ray.intersectsSphere(wgt))return;Agt.copy(i).invert(),xgt.copy(t.ray).applyMatrix4(Agt);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),a=o*o;if(n.isBufferGeometry){const r=n.index,o=n.attributes.position;if(null!==r)for(let n=Math.max(0,s.start),l=Math.min(r.count,s.start+s.count);n<l;n++){const s=r.getX(n);_gt.fromBufferAttribute(o,s),Egt(_gt,s,a,i,t,e,this)}else for(let n=Math.max(0,s.start),l=Math.min(o.count,s.start+s.count);n<l;n++)_gt.fromBufferAttribute(o,n),Egt(_gt,n,a,i,t,e,this)}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}function Egt(t,e,n,i,r,s,o){const a=xgt.distanceSqToPoint(t);if(a<n){const n=new uht;xgt.closestPointToPoint(t,n),n.applyMatrix4(i);const l=r.ray.origin.distanceTo(n);if(l<r.near||l>r.far)return;s.push({distance:l,distanceToRay:Math.sqrt(a),point:n,index:e,face:null,object:o})}}Sgt.prototype.isPoints=!0;class Cgt extends sht{constructor(t,e,n,i,r,s,o,a,l,c,u,h){super(null,s,o,a,l,c,i,r,u,h),this.image={width:e,height:n},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}Cgt.prototype.isCompressedTexture=!0;class Igt extends sht{constructor(t,e,n,i,r,s,o,a,l){super(t,e,n,i,r,s,o,a,l),this.needsUpdate=!0}}Igt.prototype.isCanvasTexture=!0;class Tgt extends Mdt{constructor(t){super(),this.type="ShadowMaterial",this.color=new Odt(0),this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this}}Tgt.prototype.isShadowMaterial=!0;class Mgt extends wpt{constructor(t){super(t),this.type="RawShaderMaterial"}}Mgt.prototype.isRawShaderMaterial=!0;class kgt extends Mdt{constructor(t){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Odt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Odt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new tht(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.vertexTangents=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this.flatShading=t.flatShading,this.vertexTangents=t.vertexTangents,this}}kgt.prototype.isMeshStandardMaterial=!0;class Rgt extends kgt{constructor(t){super(),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new tht(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,Object.defineProperty(this,"ior",{get:function(){return(1+.4*this.reflectivity)/(1-.4*this.reflectivity)},set:function(t){this.reflectivity=Qut(2.5*(t-1)/(t+1),0,1)}}),this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.reflectivity=t.reflectivity,this.sheen=t.sheen?(this.sheen||new Odt).copy(t.sheen):null,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this}}Rgt.prototype.isMeshPhysicalMaterial=!0;const Ngt={arraySlice:function(t,e,n){return Ngt.isTypedArray(t)?new t.constructor(t.subarray(e,void 0!==n?n:t.length)):t.slice(e,n)},convertArray:function(t,e,n){return!t||!n&&t.constructor===e?t:"number"==typeof e.BYTES_PER_ELEMENT?new e(t):Array.prototype.slice.call(t)},isTypedArray:function(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)},getKeyframeOrder:function(t){const e=t.length,n=new Array(e);for(let i=0;i!==e;++i)n[i]=i;return n.sort(function(e,n){return t[e]-t[n]}),n},sortedArray:function(t,e,n){const i=t.length,r=new t.constructor(i);for(let s=0,o=0;o!==i;++s){const i=n[s]*e;for(let n=0;n!==e;++n)r[o++]=t[i+n]}return r},flattenJSON:function(t,e,n,i){let r=1,s=t[0];for(;void 0!==s&&void 0===s[i];)s=t[r++];if(void 0===s)return;let o=s[i];if(void 0!==o)if(Array.isArray(o))do{o=s[i],void 0!==o&&(e.push(s.time),n.push.apply(n,o)),s=t[r++]}while(void 0!==s);else if(void 0!==o.toArray)do{o=s[i],void 0!==o&&(e.push(s.time),o.toArray(n,n.length)),s=t[r++]}while(void 0!==s);else do{o=s[i],void 0!==o&&(e.push(s.time),n.push(o)),s=t[r++]}while(void 0!==s)},subclip:function(t,e,n,i,r=30){const s=t.clone();s.name=e;const o=[];for(let l=0;l<s.tracks.length;++l){const t=s.tracks[l],e=t.getValueSize(),a=[],c=[];for(let s=0;s<t.times.length;++s){const o=t.times[s]*r;if(!(o<n||o>=i)){a.push(t.times[s]);for(let n=0;n<e;++n)c.push(t.values[s*e+n])}}0!==a.length&&(t.times=Ngt.convertArray(a,t.times.constructor),t.values=Ngt.convertArray(c,t.values.constructor),o.push(t))}s.tracks=o;let a=1/0;for(let l=0;l<s.tracks.length;++l)a>s.tracks[l].times[0]&&(a=s.tracks[l].times[0]);for(let l=0;l<s.tracks.length;++l)s.tracks[l].shift(-1*a);return s.resetDuration(),s},makeClipAdditive:function(t,e=0,n=t,i=30){i<=0&&(i=30);const r=n.tracks.length,s=e/i;for(let o=0;o<r;++o){const e=n.tracks[o],i=e.ValueTypeName;if("bool"===i||"string"===i)continue;const r=t.tracks.find(function(t){return t.name===e.name&&t.ValueTypeName===i});if(void 0===r)continue;let a=0;const l=e.getValueSize();e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(a=l/3);let c=0;const u=r.getValueSize();r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=u/3);const h=e.times.length-1;let d;if(s<=e.times[0])d=Ngt.arraySlice(e.values,a,l-a);else if(s>=e.times[h]){const t=h*l+a;d=Ngt.arraySlice(e.values,t,t+l-a)}else{const t=e.createInterpolant(),n=a,i=l-a;t.evaluate(s),d=Ngt.arraySlice(t.resultBuffer,n,i)}"quaternion"===i&&(new cht).fromArray(d).normalize().conjugate().toArray(d);const p=r.times.length;for(let t=0;t<p;++t){const e=t*u+c;if("quaternion"===i)cht.multiplyQuaternionsFlat(r.values,e,d,0,r.values,e);else{const t=u-2*c;for(let n=0;n<t;++n)r.values[e+n]-=d[n]}}}return t.blendMode=2501,t}};class Lgt{constructor(t,e,n,i){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=void 0!==i?i:new e.constructor(n),this.sampleValues=e,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let n=this._cachedIndex,i=e[n],r=e[n-1];t:{e:{let s;n:{i:if(!(t<i)){for(let s=n+2;;){if(void 0===i){if(t<r)break i;return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,t,r)}if(n===s)break;if(r=i,i=e[++n],t<i)break e}s=e.length;break n}if(t>=r)break t;{const o=e[1];t<o&&(n=2,r=o);for(let s=n-2;;){if(void 0===r)return this._cachedIndex=0,this.beforeStart_(0,t,i);if(n===s)break;if(i=r,r=e[--n-1],t>=r)break e}s=n,n=0}}for(;n<s;){const i=n+s>>>1;t<e[i]?s=i:n=i+1}if(i=e[n],r=e[n-1],void 0===r)return this._cachedIndex=0,this.beforeStart_(0,t,i);if(void 0===i)return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,r,t)}this._cachedIndex=n,this.intervalChanged_(n,r,i)}return this.interpolate_(n,r,t,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,i=this.valueSize,r=t*i;for(let s=0;s!==i;++s)e[s]=n[r+s];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}Lgt.prototype.beforeStart_=Lgt.prototype.copySampleValue_,Lgt.prototype.afterEnd_=Lgt.prototype.copySampleValue_;class Dgt extends Lgt{constructor(t,e,n,i){super(t,e,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:2400,endingEnd:2400}}intervalChanged_(t,e,n){const i=this.parameterPositions;let r=t-2,s=t+1,o=i[r],a=i[s];if(void 0===o)switch(this.getSettings_().endingStart){case 2401:r=t,o=2*e-n;break;case 2402:r=i.length-2,o=e+i[r]-i[r+1];break;default:r=t,o=n}if(void 0===a)switch(this.getSettings_().endingEnd){case 2401:s=t,a=2*n-e;break;case 2402:s=1,a=n+i[1]-i[0];break;default:s=t-1,a=e}const l=.5*(n-e),c=this.valueSize;this._weightPrev=l/(e-o),this._weightNext=l/(a-n),this._offsetPrev=r*c,this._offsetNext=s*c}interpolate_(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=t*o,l=a-o,c=this._offsetPrev,u=this._offsetNext,h=this._weightPrev,d=this._weightNext,p=(n-e)/(i-e),f=p*p,m=f*p,g=-h*m+2*h*f-h*p,y=(1+h)*m+(-1.5-2*h)*f+(-.5+h)*p+1,v=(-1-d)*m+(1.5+d)*f+.5*p,b=d*m-d*f;for(let A=0;A!==o;++A)r[A]=g*s[c+A]+y*s[l+A]+v*s[a+A]+b*s[u+A];return r}}class Bgt extends Lgt{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=t*o,l=a-o,c=(n-e)/(i-e),u=1-c;for(let h=0;h!==o;++h)r[h]=s[l+h]*u+s[a+h]*c;return r}}class Ogt extends Lgt{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t){return this.copySampleValue_(t-1)}}class Pgt{constructor(t,e,n,i){if(void 0===t)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===e||0===e.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=Ngt.convertArray(e,this.TimeBufferType),this.values=Ngt.convertArray(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let n;if(e.toJSON!==this.toJSON)n=e.toJSON(t);else{n={name:t.name,times:Ngt.convertArray(t.times,Array),values:Ngt.convertArray(t.values,Array)};const e=t.getInterpolation();e!==t.DefaultInterpolation&&(n.interpolation=e)}return n.type=t.ValueTypeName,n}InterpolantFactoryMethodDiscrete(t){return new Ogt(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new Bgt(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new Dgt(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case 2300:e=this.InterpolantFactoryMethodDiscrete;break;case 2301:e=this.InterpolantFactoryMethodLinear;break;case 2302:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){const e="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(t===this.DefaultInterpolation)throw new Error(e);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",e),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return 2300;case this.InterpolantFactoryMethodLinear:return 2301;case this.InterpolantFactoryMethodSmooth:return 2302}}getValueSize(){return this.values.length/this.times.length}shift(t){if(0!==t){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]+=t}return this}scale(t){if(1!==t){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]*=t}return this}trim(t,e){const n=this.times,i=n.length;let r=0,s=i-1;for(;r!==i&&n[r]<t;)++r;for(;-1!==s&&n[s]>e;)--s;if(++s,0!==r||s!==i){r>=s&&(s=Math.max(s,1),r=s-1);const t=this.getValueSize();this.times=Ngt.arraySlice(n,r,s),this.values=Ngt.arraySlice(this.values,r*t,s*t)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const n=this.times,i=this.values,r=n.length;0===r&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let s=null;for(let o=0;o!==r;o++){const e=n[o];if("number"==typeof e&&isNaN(e)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,e),t=!1;break}if(null!==s&&s>e){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,e,s),t=!1;break}s=e}if(void 0!==i&&Ngt.isTypedArray(i))for(let o=0,a=i.length;o!==a;++o){const e=i[o];if(isNaN(e)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,e),t=!1;break}}return t}optimize(){const t=Ngt.arraySlice(this.times),e=Ngt.arraySlice(this.values),n=this.getValueSize(),i=2302===this.getInterpolation(),r=t.length-1;let s=1;for(let o=1;o<r;++o){let r=!1;const a=t[o];if(a!==t[o+1]&&(1!==o||a!==t[0]))if(i)r=!0;else{const t=o*n,i=t-n,s=t+n;for(let o=0;o!==n;++o){const n=e[t+o];if(n!==e[i+o]||n!==e[s+o]){r=!0;break}}}if(r){if(o!==s){t[s]=t[o];const i=o*n,r=s*n;for(let t=0;t!==n;++t)e[r+t]=e[i+t]}++s}}if(r>0){t[s]=t[r];for(let t=r*n,i=s*n,o=0;o!==n;++o)e[i+o]=e[t+o];++s}return s!==t.length?(this.times=Ngt.arraySlice(t,0,s),this.values=Ngt.arraySlice(e,0,s*n)):(this.times=t,this.values=e),this}clone(){const t=Ngt.arraySlice(this.times,0),e=Ngt.arraySlice(this.values,0),n=new(0,this.constructor)(this.name,t,e);return n.createInterpolant=this.createInterpolant,n}}Pgt.prototype.TimeBufferType=Float32Array,Pgt.prototype.ValueBufferType=Float32Array,Pgt.prototype.DefaultInterpolation=2301;class Fgt extends Pgt{}Fgt.prototype.ValueTypeName="bool",Fgt.prototype.ValueBufferType=Array,Fgt.prototype.DefaultInterpolation=2300,Fgt.prototype.InterpolantFactoryMethodLinear=void 0,Fgt.prototype.InterpolantFactoryMethodSmooth=void 0;class $gt extends Pgt{}$gt.prototype.ValueTypeName="color";class zgt extends Pgt{}zgt.prototype.ValueTypeName="number";class Ugt extends Lgt{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=(n-e)/(i-e);let l=t*o;for(let c=l+o;l!==c;l+=4)cht.slerpFlat(r,0,s,l-o,s,l,a);return r}}class Hgt extends Pgt{InterpolantFactoryMethodLinear(t){return new Ugt(this.times,this.values,this.getValueSize(),t)}}Hgt.prototype.ValueTypeName="quaternion",Hgt.prototype.DefaultInterpolation=2301,Hgt.prototype.InterpolantFactoryMethodSmooth=void 0;class Vgt extends Pgt{}Vgt.prototype.ValueTypeName="string",Vgt.prototype.ValueBufferType=Array,Vgt.prototype.DefaultInterpolation=2300,Vgt.prototype.InterpolantFactoryMethodLinear=void 0,Vgt.prototype.InterpolantFactoryMethodSmooth=void 0;class Ggt extends Pgt{}Ggt.prototype.ValueTypeName="vector";class Wgt{constructor(t,e=-1,n,i=2500){this.name=t,this.tracks=n,this.duration=e,this.blendMode=i,this.uuid=jut(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],n=t.tracks,i=1/(t.fps||1);for(let s=0,o=n.length;s!==o;++s)e.push(jgt(n[s]).scale(i));const r=new this(t.name,t.duration,e,t.blendMode);return r.uuid=t.uuid,r}static toJSON(t){const e=[],n=t.tracks,i={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let r=0,s=n.length;r!==s;++r)e.push(Pgt.toJSON(n[r]));return i}static CreateFromMorphTargetSequence(t,e,n,i){const r=e.length,s=[];for(let o=0;o<r;o++){let t=[],a=[];t.push((o+r-1)%r,o,(o+1)%r),a.push(0,1,0);const l=Ngt.getKeyframeOrder(t);t=Ngt.sortedArray(t,1,l),a=Ngt.sortedArray(a,1,l),i||0!==t[0]||(t.push(r),a.push(a[0])),s.push(new zgt(".morphTargetInfluences["+e[o].name+"]",t,a).scale(1/n))}return new this(t,-1,s)}static findByName(t,e){let n=t;if(!Array.isArray(t)){const e=t;n=e.geometry&&e.geometry.animations||e.animations}for(let i=0;i<n.length;i++)if(n[i].name===e)return n[i];return null}static CreateClipsFromMorphTargetSequences(t,e,n){const i={},r=/^([\w-]*?)([\d]+)$/;for(let o=0,a=t.length;o<a;o++){const e=t[o],n=e.name.match(r);if(n&&n.length>1){const t=n[1];let r=i[t];r||(i[t]=r=[]),r.push(e)}}const s=[];for(const o in i)s.push(this.CreateFromMorphTargetSequence(o,i[o],e,n));return s}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(t,e,n,i,r){if(0!==n.length){const s=[],o=[];Ngt.flattenJSON(n,s,o,i),0!==s.length&&r.push(new t(e,s,o))}},i=[],r=t.name||"default",s=t.fps||30,o=t.blendMode;let a=t.length||-1;const l=t.hierarchy||[];for(let c=0;c<l.length;c++){const t=l[c].keys;if(t&&0!==t.length)if(t[0].morphTargets){const e={};let n;for(n=0;n<t.length;n++)if(t[n].morphTargets)for(let i=0;i<t[n].morphTargets.length;i++)e[t[n].morphTargets[i]]=-1;for(const r in e){const e=[],s=[];for(let i=0;i!==t[n].morphTargets.length;++i){const i=t[n];e.push(i.time),s.push(i.morphTarget===r?1:0)}i.push(new zgt(".morphTargetInfluence["+r+"]",e,s))}a=e.length*(s||1)}else{const r=".bones["+e[c].name+"]";n(Ggt,r+".position",t,"pos",i),n(Hgt,r+".quaternion",t,"rot",i),n(Ggt,r+".scale",t,"scl",i)}}return 0===i.length?null:new this(r,a,i,o)}resetDuration(){let t=0;for(let e=0,n=this.tracks.length;e!==n;++e){const n=this.tracks[e];t=Math.max(t,n.times[n.times.length-1])}return this.duration=t,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function jgt(t){if(void 0===t.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=function(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return zgt;case"vector":case"vector2":case"vector3":case"vector4":return Ggt;case"color":return $gt;case"quaternion":return Hgt;case"bool":case"boolean":return Fgt;case"string":return Vgt}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}(t.type);if(void 0===t.times){const e=[],n=[];Ngt.flattenJSON(t.keys,e,n,"value"),t.times=e,t.values=n}return void 0!==e.parse?e.parse(t):new e(t.name,t.times,t.values,t.interpolation)}const Qgt={enabled:!1,files:{},add:function(t,e){!1!==this.enabled&&(this.files[t]=e)},get:function(t){if(!1!==this.enabled)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}},qgt=new class{constructor(t,e,n){const i=this;let r,s=!1,o=0,a=0;const l=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this.itemStart=function(t){a++,!1===s&&void 0!==i.onStart&&i.onStart(t,o,a),s=!0},this.itemEnd=function(t){o++,void 0!==i.onProgress&&i.onProgress(t,o,a),o===a&&(s=!1,void 0!==i.onLoad&&i.onLoad())},this.itemError=function(t){void 0!==i.onError&&i.onError(t)},this.resolveURL=function(t){return r?r(t):t},this.setURLModifier=function(t){return r=t,this},this.addHandler=function(t,e){return l.push(t,e),this},this.removeHandler=function(t){const e=l.indexOf(t);return-1!==e&&l.splice(e,2),this},this.getHandler=function(t){for(let e=0,n=l.length;e<n;e+=2){const n=l[e],i=l[e+1];if(n.global&&(n.lastIndex=0),n.test(t))return i}return null}}};class Xgt{constructor(t){this.manager=void 0!==t?t:qgt,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise(function(i,r){n.load(t,i,e,r)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}const Ygt={};class Kgt extends Xgt{constructor(t){super(t)}load(t,e,n,i){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,s=Qgt.get(t);if(void 0!==s)return r.manager.itemStart(t),setTimeout(function(){e&&e(s),r.manager.itemEnd(t)},0),s;if(void 0!==Ygt[t])return void Ygt[t].push({onLoad:e,onProgress:n,onError:i});const o=t.match(/^data:(.*?)(;base64)?,(.*)$/);let a;if(o){const n=o[1],s=!!o[2];let a=o[3];a=decodeURIComponent(a),s&&(a=atob(a));try{let i;const s=(this.responseType||"").toLowerCase();switch(s){case"arraybuffer":case"blob":const t=new Uint8Array(a.length);for(let n=0;n<a.length;n++)t[n]=a.charCodeAt(n);i="blob"===s?new Blob([t.buffer],{type:n}):t.buffer;break;case"document":const e=new DOMParser;i=e.parseFromString(a,n);break;case"json":i=JSON.parse(a);break;default:i=a}setTimeout(function(){e&&e(i),r.manager.itemEnd(t)},0)}catch(e){setTimeout(function(){i&&i(e),r.manager.itemError(t),r.manager.itemEnd(t)},0)}}else{Ygt[t]=[],Ygt[t].push({onLoad:e,onProgress:n,onError:i}),a=new XMLHttpRequest,a.open("GET",t,!0),a.addEventListener("load",function(e){const n=this.response,i=Ygt[t];if(delete Ygt[t],200===this.status||0===this.status){0===this.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),Qgt.add(t,n);for(let t=0,e=i.length;t<e;t++){const e=i[t];e.onLoad&&e.onLoad(n)}r.manager.itemEnd(t)}else{for(let t=0,n=i.length;t<n;t++){const n=i[t];n.onError&&n.onError(e)}r.manager.itemError(t),r.manager.itemEnd(t)}},!1),a.addEventListener("progress",function(e){const n=Ygt[t];for(let t=0,i=n.length;t<i;t++){const i=n[t];i.onProgress&&i.onProgress(e)}},!1),a.addEventListener("error",function(e){const n=Ygt[t];delete Ygt[t];for(let t=0,i=n.length;t<i;t++){const i=n[t];i.onError&&i.onError(e)}r.manager.itemError(t),r.manager.itemEnd(t)},!1),a.addEventListener("abort",function(e){const n=Ygt[t];delete Ygt[t];for(let t=0,i=n.length;t<i;t++){const i=n[t];i.onError&&i.onError(e)}r.manager.itemError(t),r.manager.itemEnd(t)},!1),void 0!==this.responseType&&(a.responseType=this.responseType),void 0!==this.withCredentials&&(a.withCredentials=this.withCredentials),a.overrideMimeType&&a.overrideMimeType(void 0!==this.mimeType?this.mimeType:"text/plain");for(const t in this.requestHeader)a.setRequestHeader(t,this.requestHeader[t]);a.send(null)}return r.manager.itemStart(t),a}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class Jgt extends Xgt{constructor(t){super(t)}load(t,e,n,i){const r=this,s=[],o=new Cgt,a=new Kgt(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(r.withCredentials);let l=0;function c(c){a.load(t[c],function(t){const n=r.parse(t,!0);s[c]={width:n.width,height:n.height,format:n.format,mipmaps:n.mipmaps},l+=1,6===l&&(1===n.mipmapCount&&(o.minFilter=1006),o.image=s,o.format=n.format,o.needsUpdate=!0,e&&e(o))},n,i)}if(Array.isArray(t))for(let u=0,h=t.length;u<h;++u)c(u);else a.load(t,function(t){const n=r.parse(t,!0);if(n.isCubemap){const t=n.mipmaps.length/n.mipmapCount;for(let e=0;e<t;e++){s[e]={mipmaps:[]};for(let t=0;t<n.mipmapCount;t++)s[e].mipmaps.push(n.mipmaps[e*n.mipmapCount+t]),s[e].format=n.format,s[e].width=n.width,s[e].height=n.height}o.image=s}else o.image.width=n.width,o.image.height=n.height,o.mipmaps=n.mipmaps;1===n.mipmapCount&&(o.minFilter=1006),o.format=n.format,o.needsUpdate=!0,e&&e(o)},n,i);return o}}class Zgt extends Xgt{constructor(t){super(t)}load(t,e,n,i){void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,s=Qgt.get(t);if(void 0!==s)return r.manager.itemStart(t),setTimeout(function(){e&&e(s),r.manager.itemEnd(t)},0),s;const o=document.createElementNS("http://www.w3.org/1999/xhtml","img");function a(){o.removeEventListener("load",a,!1),o.removeEventListener("error",l,!1),Qgt.add(t,this),e&&e(this),r.manager.itemEnd(t)}function l(e){o.removeEventListener("load",a,!1),o.removeEventListener("error",l,!1),i&&i(e),r.manager.itemError(t),r.manager.itemEnd(t)}return o.addEventListener("load",a,!1),o.addEventListener("error",l,!1),"data:"!==t.substr(0,5)&&void 0!==this.crossOrigin&&(o.crossOrigin=this.crossOrigin),r.manager.itemStart(t),o.src=t,o}}class tyt extends Xgt{constructor(t){super(t)}load(t,e,n,i){const r=new Cpt,s=new Zgt(this.manager);s.setCrossOrigin(this.crossOrigin),s.setPath(this.path);let o=0;function a(n){s.load(t[n],function(t){r.images[n]=t,o++,6===o&&(r.needsUpdate=!0,e&&e(r))},void 0,i)}for(let l=0;l<t.length;++l)a(l);return r}}class eyt extends Xgt{constructor(t){super(t)}load(t,e,n,i){const r=this,s=new Tpt,o=new Kgt(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(r.withCredentials),o.load(t,function(t){const n=r.parse(t);n&&(void 0!==n.image?s.image=n.image:void 0!==n.data&&(s.image.width=n.width,s.image.height=n.height,s.image.data=n.data),s.wrapS=void 0!==n.wrapS?n.wrapS:1001,s.wrapT=void 0!==n.wrapT?n.wrapT:1001,s.magFilter=void 0!==n.magFilter?n.magFilter:1006,s.minFilter=void 0!==n.minFilter?n.minFilter:1006,s.anisotropy=void 0!==n.anisotropy?n.anisotropy:1,void 0!==n.encoding&&(s.encoding=n.encoding),void 0!==n.flipY&&(s.flipY=n.flipY),void 0!==n.format&&(s.format=n.format),void 0!==n.type&&(s.type=n.type),void 0!==n.mipmaps&&(s.mipmaps=n.mipmaps,s.minFilter=1008),1===n.mipmapCount&&(s.minFilter=1006),void 0!==n.generateMipmaps&&(s.generateMipmaps=n.generateMipmaps),s.needsUpdate=!0,e&&e(s,n))},n,i),s}}class nyt extends Xgt{constructor(t){super(t)}load(t,e,n,i){const r=new sht,s=new Zgt(this.manager);return s.setCrossOrigin(this.crossOrigin),s.setPath(this.path),s.load(t,function(n){r.image=n;const i=t.search(/\.jpe?g($|\?)/i)>0||0===t.search(/^data\:image\/jpeg/);r.format=i?1022:1023,r.needsUpdate=!0,void 0!==e&&e(r)},n,i),r}}class iyt extends ddt{constructor(t,e=1){super(),this.type="Light",this.color=new Odt(t),this.intensity=e}dispose(){}copy(t){return super.copy(t),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,void 0!==this.groundColor&&(e.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(e.object.distance=this.distance),void 0!==this.angle&&(e.object.angle=this.angle),void 0!==this.decay&&(e.object.decay=this.decay),void 0!==this.penumbra&&(e.object.penumbra=this.penumbra),void 0!==this.shadow&&(e.object.shadow=this.shadow.toJSON()),e}}iyt.prototype.isLight=!0;const ryt=new Uht,syt=new uht,oyt=new uht;class ayt{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new tht(512,512),this.map=null,this.mapPass=null,this.matrix=new Uht,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Rpt,this._frameExtents=new tht(1,1),this._viewportCount=1,this._viewports=[new aht(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,n=this.matrix;syt.setFromMatrixPosition(t.matrixWorld),e.position.copy(syt),oyt.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(oyt),e.updateMatrixWorld(),ryt.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(ryt),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(e.projectionMatrix),n.multiply(e.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const t={};return 0!==this.bias&&(t.bias=this.bias),0!==this.normalBias&&(t.normalBias=this.normalBias),1!==this.radius&&(t.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class lyt extends ayt{constructor(){super(new Spt(50,1,.5,500)),this.focus=1}updateMatrices(t){const e=this.camera,n=2*Wut*t.angle*this.focus,i=this.mapSize.width/this.mapSize.height,r=t.distance||e.far;n===e.fov&&i===e.aspect&&r===e.far||(e.fov=n,e.aspect=i,e.far=r,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}lyt.prototype.isSpotLightShadow=!0;class cyt extends iyt{constructor(t,e,n=0,i=Math.PI/3,r=0,s=1){super(t,e),this.type="SpotLight",this.position.copy(ddt.DefaultUp),this.updateMatrix(),this.target=new ddt,this.distance=n,this.angle=i,this.penumbra=r,this.decay=s,this.shadow=new lyt}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}cyt.prototype.isSpotLight=!0;const uyt=new Uht,hyt=new uht,dyt=new uht;class pyt extends ayt{constructor(){super(new Spt(90,1,.5,500)),this._frameExtents=new tht(4,2),this._viewportCount=6,this._viewports=[new aht(2,1,1,1),new aht(0,1,1,1),new aht(3,1,1,1),new aht(1,1,1,1),new aht(3,0,1,1),new aht(1,0,1,1)],this._cubeDirections=[new uht(1,0,0),new uht(-1,0,0),new uht(0,0,1),new uht(0,0,-1),new uht(0,1,0),new uht(0,-1,0)],this._cubeUps=[new uht(0,1,0),new uht(0,1,0),new uht(0,1,0),new uht(0,1,0),new uht(0,0,1),new uht(0,0,-1)]}updateMatrices(t,e=0){const n=this.camera,i=this.matrix,r=t.distance||n.far;r!==n.far&&(n.far=r,n.updateProjectionMatrix()),hyt.setFromMatrixPosition(t.matrixWorld),n.position.copy(hyt),dyt.copy(n.position),dyt.add(this._cubeDirections[e]),n.up.copy(this._cubeUps[e]),n.lookAt(dyt),n.updateMatrixWorld(),i.makeTranslation(-hyt.x,-hyt.y,-hyt.z),uyt.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(uyt)}}pyt.prototype.isPointLightShadow=!0;class fyt extends iyt{constructor(t,e,n=0,i=1){super(t,e),this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new pyt}get power(){return 4*this.intensity*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}fyt.prototype.isPointLight=!0;class myt extends _pt{constructor(t=-1,e=1,n=1,i=-1,r=.1,s=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=i,this.near=r,this.far=s,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=null===t.view?null:Object.assign({},t.view),this}setViewOffset(t,e,n,i,r,s){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=n-t,s=n+t,o=i+e,a=i-e;if(null!==this.view&&this.view.enabled){const t=(this.right-this.left)/this.view.fullWidth/this.zoom,e=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=t*this.view.offsetX,s=r+t*this.view.width,o-=e*this.view.offsetY,a=o-e*this.view.height}this.projectionMatrix.makeOrthographic(r,s,o,a,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}}myt.prototype.isOrthographicCamera=!0;class gyt extends ayt{constructor(){super(new myt(-5,5,5,-5,.5,500))}}gyt.prototype.isDirectionalLightShadow=!0;class yyt extends iyt{constructor(t,e){super(t,e),this.type="DirectionalLight",this.position.copy(ddt.DefaultUp),this.updateMatrix(),this.target=new ddt,this.shadow=new gyt}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}yyt.prototype.isDirectionalLight=!0;class vyt{static decodeText(t){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(t);let e="";for(let n=0,i=t.length;n<i;n++)e+=String.fromCharCode(t[n]);try{return decodeURIComponent(escape(e))}catch(t){return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return-1===e?"./":t.substr(0,e+1)}}class byt extends Xgt{constructor(t){super(t),"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,n,i){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,s=Qgt.get(t);if(void 0!==s)return r.manager.itemStart(t),setTimeout(function(){e&&e(s),r.manager.itemEnd(t)},0),s;const o={};o.credentials="anonymous"===this.crossOrigin?"same-origin":"include",o.headers=this.requestHeader,fetch(t,o).then(function(t){return t.blob()}).then(function(t){return createImageBitmap(t,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(n){Qgt.add(t,n),e&&e(n),r.manager.itemEnd(t)}).catch(function(e){i&&i(e),r.manager.itemError(t),r.manager.itemEnd(t)}),r.manager.itemStart(t)}}byt.prototype.isImageBitmapLoader=!0;class Ayt{constructor(t,e,n){let i,r,s;switch(this.binding=t,this.valueSize=n,e){case"quaternion":i=this._slerp,r=this._slerpAdditive,s=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*n),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,s=this._setAdditiveIdentityOther,this.buffer=new Array(5*n);break;default:i=this._lerp,r=this._lerpAdditive,s=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*n)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=s,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const n=this.buffer,i=this.valueSize,r=t*i+i;let s=this.cumulativeWeight;if(0===s){for(let t=0;t!==i;++t)n[r+t]=n[t];s=e}else s+=e,this._mixBufferRegion(n,r,0,e/s,i);this.cumulativeWeight=s}accumulateAdditive(t){const e=this.buffer,n=this.valueSize,i=n*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(e,i,0,t,n),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,n=this.buffer,i=t*e+e,r=this.cumulativeWeight,s=this.cumulativeWeightAdditive,o=this.binding;this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1&&this._mixBufferRegion(n,i,e*this._origIndex,1-r,e),s>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*e,1,e);for(let a=e,l=e+e;a!==l;++a)if(n[a]!==n[a+e]){o.setValue(n,i);break}}saveOriginalState(){const t=this.buffer,e=this.valueSize,n=e*this._origIndex;this.binding.getValue(t,n);for(let i=e,r=n;i!==r;++i)t[i]=t[n+i%e];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){this.binding.setValue(this.buffer,3*this.valueSize)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let n=t;n<e;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[e+n]=this.buffer[t+n]}_select(t,e,n,i,r){if(i>=.5)for(let s=0;s!==r;++s)t[e+s]=t[n+s]}_slerp(t,e,n,i){cht.slerpFlat(t,e,t,e,t,n,i)}_slerpAdditive(t,e,n,i,r){const s=this._workIndex*r;cht.multiplyQuaternionsFlat(t,s,t,e,t,n),cht.slerpFlat(t,e,t,e,t,s,i)}_lerp(t,e,n,i,r){const s=1-i;for(let o=0;o!==r;++o){const r=e+o;t[r]=t[r]*s+t[n+o]*i}}_lerpAdditive(t,e,n,i,r){for(let s=0;s!==r;++s){const r=e+s;t[r]=t[r]+t[n+s]*i}}}const xyt=new RegExp("[\\[\\]\\.:\\/]","g"),wyt="[^"+"\\[\\]\\.:\\/".replace("\\.","")+"]",_yt=/((?:WC+[\/:])*)/.source.replace("WC","[^\\[\\]\\.:\\/]"),Syt=/(WCOD+)?/.source.replace("WCOD",wyt),Eyt=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC","[^\\[\\]\\.:\\/]"),Cyt=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC","[^\\[\\]\\.:\\/]"),Iyt=new RegExp("^"+_yt+Syt+Eyt+Cyt+"$"),Tyt=["material","materials","bones"];class Myt{constructor(t,e,n){this.path=e,this.parsedPath=n||Myt.parseTrackName(e),this.node=Myt.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,n){return t&&t.isAnimationObjectGroup?new Myt.Composite(t,e,n):new Myt(t,e,n)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(xyt,"")}static parseTrackName(t){const e=Iyt.exec(t);if(!e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const n={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==i&&-1!==i){const t=n.nodeName.substring(i+1);-1!==Tyt.indexOf(t)&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=t)}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return n}static findNode(t,e){if(!e||""===e||"."===e||-1===e||e===t.name||e===t.uuid)return t;if(t.skeleton){const n=t.skeleton.getBoneByName(e);if(void 0!==n)return n}if(t.children){const n=function(t){for(let i=0;i<t.length;i++){const r=t[i];if(r.name===e||r.uuid===e)return r;const s=n(r.children);if(s)return s}return null},i=n(t.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.node[this.propertyName]}_getValue_array(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)t[e++]=n[i]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,n=e.objectName,i=e.propertyName;let r=e.propertyIndex;if(t||(t=Myt.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(n){let i=e.objectIndex;switch(n){case"materials":if(!t.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);t=t.material.materials;break;case"bones":if(!t.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);t=t.skeleton.bones;for(let e=0;e<t.length;e++)if(t[e].name===i){i=e;break}break;default:if(void 0===t[n])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);t=t[n]}if(void 0!==i){if(void 0===t[i])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);t=t[i]}}const s=t[i];if(void 0===s)return void console.error("THREE.PropertyBinding: Trying to update property for track: "+e.nodeName+"."+i+" but it wasn't found.",t);let o=this.Versioning.None;this.targetObject=t,void 0!==t.needsUpdate?o=this.Versioning.NeedsUpdate:void 0!==t.matrixWorldNeedsUpdate&&(o=this.Versioning.MatrixWorldNeedsUpdate);let a=this.BindingType.Direct;if(void 0!==r){if("morphTargetInfluences"===i){if(!t.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!t.geometry.isBufferGeometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);if(!t.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==t.morphTargetDictionary[r]&&(r=t.morphTargetDictionary[r])}a=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=r}else void 0!==s.fromArray&&void 0!==s.toArray?(a=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(a=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=i;this.getValue=this.GetterByBindingType[a],this.setValue=this.SetterByBindingTypeAndVersioning[a][o]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Myt.Composite=class{constructor(t,e,n){const i=n||Myt.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,i)}getValue(t,e){this.bind();const n=this._bindings[this._targetGroup.nCachedObjects_];void 0!==n&&n.getValue(t,e)}setValue(t,e){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=n.length;i!==r;++i)n[i].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].unbind()}},Myt.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Myt.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},Myt.prototype.GetterByBindingType=[Myt.prototype._getValue_direct,Myt.prototype._getValue_array,Myt.prototype._getValue_arrayElement,Myt.prototype._getValue_toArray],Myt.prototype.SetterByBindingTypeAndVersioning=[[Myt.prototype._setValue_direct,Myt.prototype._setValue_direct_setNeedsUpdate,Myt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Myt.prototype._setValue_array,Myt.prototype._setValue_array_setNeedsUpdate,Myt.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Myt.prototype._setValue_arrayElement,Myt.prototype._setValue_arrayElement_setNeedsUpdate,Myt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Myt.prototype._setValue_fromArray,Myt.prototype._setValue_fromArray_setNeedsUpdate,Myt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class kyt{constructor(t,e,n=null,i=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=n,this.blendMode=i;const r=e.tracks,s=r.length,o=new Array(s),a={endingStart:2400,endingEnd:2400};for(let l=0;l!==s;++l){const t=r[l].createInterpolant(null);o[l]=t,t.settings=a}this._interpolantSettings=a,this._interpolants=o,this._propertyBindings=new Array(s),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,n){if(t.fadeOut(e),this.fadeIn(e),n){const n=this._clip.duration,i=t._clip.duration,r=n/i;t.warp(1,i/n,e),this.warp(r,1,e)}return this}crossFadeTo(t,e,n){return t.crossFadeFrom(this,e,n)}stopFading(){const t=this._weightInterpolant;return null!==t&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,n){const i=this._mixer,r=i.time,s=this.timeScale;let o=this._timeScaleInterpolant;null===o&&(o=i._lendControlInterpolant(),this._timeScaleInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=r,a[1]=r+n,l[0]=t/s,l[1]=e/s,this}stopWarping(){const t=this._timeScaleInterpolant;return null!==t&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,n,i){if(!this.enabled)return void this._updateWeight(t);const r=this._startTime;if(null!==r){const i=(t-r)*n;if(i<0||0===n)return;this._startTime=null,e=n*i}e*=this._updateTimeScale(t);const s=this._updateTime(e),o=this._updateWeight(t);if(o>0){const t=this._interpolants,e=this._propertyBindings;switch(this.blendMode){case 2501:for(let n=0,i=t.length;n!==i;++n)t[n].evaluate(s),e[n].accumulateAdditive(o);break;case 2500:default:for(let n=0,r=t.length;n!==r;++n)t[n].evaluate(s),e[n].accumulate(i,o)}}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const n=this._weightInterpolant;if(null!==n){const i=n.evaluate(t)[0];e*=i,t>n.parameterPositions[1]&&(this.stopFading(),0===i&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const n=this._timeScaleInterpolant;null!==n&&(e*=n.evaluate(t)[0],t>n.parameterPositions[1]&&(this.stopWarping(),0===e?this.paused=!0:this.timeScale=e))}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,n=this.loop;let i=this.time+t,r=this._loopCount;const s=2202===n;if(0===t)return-1===r?i:s&&1==(1&r)?e-i:i;if(2200===n){-1===r&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(i>=e)i=e;else{if(!(i<0)){this.time=i;break t}i=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(-1===r&&(t>=0?(r=0,this._setEndings(!0,0===this.repetitions,s)):this._setEndings(0===this.repetitions,!0,s)),i>=e||i<0){const n=Math.floor(i/e);i-=e*n,r+=Math.abs(n);const o=this.repetitions-r;if(o<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=t>0?e:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(1===o){const e=t<0;this._setEndings(e,!e,s)}else this._setEndings(!1,!1,s);this._loopCount=r,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:n})}}else this.time=i;if(s&&1==(1&r))return e-i}return i}_setEndings(t,e,n){const i=this._interpolantSettings;n?(i.endingStart=2401,i.endingEnd=2401):(i.endingStart=t?this.zeroSlopeAtStart?2401:2400:2402,i.endingEnd=e?this.zeroSlopeAtEnd?2401:2400:2402)}_scheduleFading(t,e,n){const i=this._mixer,r=i.time;let s=this._weightInterpolant;null===s&&(s=i._lendControlInterpolant(),this._weightInterpolant=s);const o=s.parameterPositions,a=s.sampleValues;return o[0]=r,a[0]=e,o[1]=r+t,a[1]=n,this}}class Ryt extends Uut{constructor(t){super(),this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const n=t._localRoot||this._root,i=t._clip.tracks,r=i.length,s=t._propertyBindings,o=t._interpolants,a=n.uuid,l=this._bindingsByRootAndName;let c=l[a];void 0===c&&(c={},l[a]=c);for(let u=0;u!==r;++u){const t=i[u],r=t.name;let l=c[r];if(void 0!==l)s[u]=l;else{if(l=s[u],void 0!==l){null===l._cacheIndex&&(++l.referenceCount,this._addInactiveBinding(l,a,r));continue}l=new Ayt(Myt.create(n,r,e&&e._propertyBindings[u].binding.parsedPath),t.ValueTypeName,t.getValueSize()),++l.referenceCount,this._addInactiveBinding(l,a,r),s[u]=l}o[u].resultBuffer=l.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(null===t._cacheIndex){const e=(t._localRoot||this._root).uuid,n=t._clip.uuid,i=this._actionsByClip[n];this._bindAction(t,i&&i.knownActions[0]),this._addInactiveAction(t,n,e)}const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==n.useCount++&&(this._lendBinding(n),n.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==--n.useCount&&(n.restoreOriginalState(),this._takeBackBinding(n))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return null!==e&&e<this._nActiveActions}_addInactiveAction(t,e,n){const i=this._actions,r=this._actionsByClip;let s=r[e];if(void 0===s)s={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,r[e]=s;else{const e=s.knownActions;t._byClipCacheIndex=e.length,e.push(t)}t._cacheIndex=i.length,i.push(t),s.actionByRoot[n]=t}_removeInactiveAction(t){const e=this._actions,n=e[e.length-1],i=t._cacheIndex;n._cacheIndex=i,e[i]=n,e.pop(),t._cacheIndex=null;const r=t._clip.uuid,s=this._actionsByClip,o=s[r],a=o.knownActions,l=a[a.length-1],c=t._byClipCacheIndex;l._byClipCacheIndex=c,a[c]=l,a.pop(),t._byClipCacheIndex=null,delete o.actionByRoot[(t._localRoot||this._root).uuid],0===a.length&&delete s[r],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let n=0,i=e.length;n!==i;++n){const t=e[n];0==--t.referenceCount&&this._removeInactiveBinding(t)}}_lendAction(t){const e=this._actions,n=t._cacheIndex,i=this._nActiveActions++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_takeBackAction(t){const e=this._actions,n=t._cacheIndex,i=--this._nActiveActions,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_addInactiveBinding(t,e,n){const i=this._bindingsByRootAndName,r=this._bindings;let s=i[e];void 0===s&&(s={},i[e]=s),s[n]=t,t._cacheIndex=r.length,r.push(t)}_removeInactiveBinding(t){const e=this._bindings,n=t.binding,i=n.rootNode.uuid,r=n.path,s=this._bindingsByRootAndName,o=s[i],a=e[e.length-1],l=t._cacheIndex;a._cacheIndex=l,e[l]=a,e.pop(),delete o[r],0===Object.keys(o).length&&delete s[i]}_lendBinding(t){const e=this._bindings,n=t._cacheIndex,i=this._nActiveBindings++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_takeBackBinding(t){const e=this._bindings,n=t._cacheIndex,i=--this._nActiveBindings,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let n=t[e];return void 0===n&&(n=new Bgt(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=e,t[e]=n),n}_takeBackControlInterpolant(t){const e=this._controlInterpolants,n=t.__cacheIndex,i=--this._nActiveControlInterpolants,r=e[i];t.__cacheIndex=i,e[i]=t,r.__cacheIndex=n,e[n]=r}clipAction(t,e,n){const i=e||this._root,r=i.uuid;let s="string"==typeof t?Wgt.findByName(i,t):t;const o=null!==s?s.uuid:t,a=this._actionsByClip[o];let l=null;if(void 0===n&&(n=null!==s?s.blendMode:2500),void 0!==a){const t=a.actionByRoot[r];if(void 0!==t&&t.blendMode===n)return t;l=a.knownActions[0],null===s&&(s=l._clip)}if(null===s)return null;const c=new kyt(this,s,e,n);return this._bindAction(c,l),this._addInactiveAction(c,o,r),c}existingAction(t,e){const n=e||this._root,i=n.uuid,r="string"==typeof t?Wgt.findByName(n,t):t,s=this._actionsByClip[r?r.uuid:t];return void 0!==s&&s.actionByRoot[i]||null}stopAllAction(){const t=this._actions;for(let e=this._nActiveActions-1;e>=0;--e)t[e].stop();return this}update(t){const e=this._actions,n=this._nActiveActions,i=this.time+=t*=this.timeScale,r=Math.sign(t),s=this._accuIndex^=1;for(let l=0;l!==n;++l)e[l]._update(i,t,r,s);const o=this._bindings,a=this._nActiveBindings;for(let l=0;l!==a;++l)o[l].apply(s);return this}setTime(t){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,n=t.uuid,i=this._actionsByClip,r=i[n];if(void 0!==r){const t=r.knownActions;for(let n=0,i=t.length;n!==i;++n){const i=t[n];this._deactivateAction(i);const r=i._cacheIndex,s=e[e.length-1];i._cacheIndex=null,i._byClipCacheIndex=null,s._cacheIndex=r,e[r]=s,e.pop(),this._removeInactiveBindingsForAction(i)}delete i[n]}}uncacheRoot(t){const e=t.uuid,n=this._actionsByClip;for(const r in n){const t=n[r].actionByRoot[e];void 0!==t&&(this._deactivateAction(t),this._removeInactiveAction(t))}const i=this._bindingsByRootAndName[e];if(void 0!==i)for(const r in i){const t=i[r];t.restoreOriginalState(),this._removeInactiveBinding(t)}}uncacheAction(t,e){const n=this.existingAction(t,e);null!==n&&(this._deactivateAction(n),this._removeInactiveAction(n))}}function Nyt(t,e){return t.distance-e.distance}function Lyt(t,e,n,i){if(t.layers.test(e.layers)&&t.raycast(e,n),!0===i){const i=t.children;for(let t=0,r=i.length;t<r;t++)Lyt(i[t],e,n,!0)}}Ryt.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class Dyt{constructor(t=1,e=0,n=0){return this.radius=t,this.phi=e,this.theta=n,this}set(t,e,n){return this.radius=t,this.phi=e,this.theta=n,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){const t=1e-6;return this.phi=Math.max(t,Math.min(Math.PI-t,this.phi)),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+e*e+n*n),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,n),this.phi=Math.acos(Qut(e/this.radius,-1,1))),this}clone(){return(new this.constructor).copy(this)}}const Byt=new uht,Oyt=new Uht,Pyt=new Uht;class Fyt extends ygt{constructor(t){const e=$yt(t),n=new Jdt,i=[],r=[],s=new Odt(0,0,1),o=new Odt(0,1,0);for(let a=0;a<e.length;a++){const t=e[a];t.parent&&t.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),r.push(s.r,s.g,s.b),r.push(o.r,o.g,o.b))}n.setAttribute("position",new Vdt(i,3)),n.setAttribute("color",new Vdt(r,3)),super(n,new lgt({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,n=this.geometry,i=n.getAttribute("position");Pyt.copy(this.root.matrixWorld).invert();for(let r=0,s=0;r<e.length;r++){const t=e[r];t.parent&&t.parent.isBone&&(Oyt.multiplyMatrices(Pyt,t.matrixWorld),Byt.setFromMatrixPosition(Oyt),i.setXYZ(s,Byt.x,Byt.y,Byt.z),Oyt.multiplyMatrices(Pyt,t.parent.matrixWorld),Byt.setFromMatrixPosition(Oyt),i.setXYZ(s+1,Byt.x,Byt.y,Byt.z),s+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}function $yt(t){const e=[];t&&t.isBone&&e.push(t);for(let n=0;n<t.children.length;n++)e.push.apply(e,$yt(t.children[n]));return e}const zyt=new Float32Array(1),Uyt=new Int32Array(zyt.buffer);class Hyt{static toHalfFloat(t){zyt[0]=t;const e=Uyt[0];let n=e>>16&32768,i=e>>12&2047;const r=e>>23&255;return r<103?n:r>142?(n|=31744,n|=(255==r?0:1)&&8388607&e,n):r<113?(i|=2048,n|=(i>>114-r)+(i>>113-r&1),n):(n|=r-112<<10|i>>1,n+=1&i,n)}}const Vyt=Math.pow(2,8),Gyt=[.125,.215,.35,.446,.526,.582],Wyt=5+Gyt.length,jyt={3e3:0,3001:1,3002:2,3004:3,3005:4,3006:5,3007:6},Qyt=new Pdt({side:1,depthWrite:!1,depthTest:!1}),qyt=new gpt(new vpt,Qyt),Xyt=new myt,{_lodPlanes:Yyt,_sizeLods:Kyt,_sigmas:Jyt}=function(){const t=[],e=[],n=[];let i=8;for(let r=0;r<Wyt;r++){const s=Math.pow(2,i);e.push(s);let o=1/s;r>4?o=Gyt[r-8+4-1]:0==r&&(o=0),n.push(o);const a=1/(s-1),l=-a/2,c=1+a/2,u=[l,l,c,l,c,c,l,l,c,c,l,c],h=6,d=6,p=3,f=2,m=1,g=new Float32Array(p*d*h),y=new Float32Array(f*d*h),v=new Float32Array(m*d*h);for(let t=0;t<h;t++){const e=t%3*2/3-1,n=t>2?0:-1;g.set([e,n,0,e+2/3,n,0,e+2/3,n+1,0,e,n,0,e+2/3,n+1,0,e,n+1,0],p*d*t),y.set(u,f*d*t),v.set([t,t,t,t,t,t],m*d*t)}const b=new Jdt;b.setAttribute("position",new zdt(g,p)),b.setAttribute("uv",new zdt(y,f)),b.setAttribute("faceIndex",new zdt(v,m)),t.push(b),i>4&&i--}return{_lodPlanes:t,_sizeLods:e,_sigmas:n}}(),Zyt=new Odt;let tvt=null;const evt=(1+Math.sqrt(5))/2,nvt=1/evt,ivt=[new uht(1,1,1),new uht(-1,1,1),new uht(1,1,-1),new uht(-1,1,-1),new uht(0,evt,nvt),new uht(0,evt,-nvt),new uht(nvt,0,evt),new uht(-nvt,0,evt),new uht(evt,nvt,0),new uht(-evt,nvt,0)];function rvt(t){const e=Math.max(t.r,t.g,t.b),n=Math.min(Math.max(Math.ceil(Math.log2(e)),-128),127);return t.multiplyScalar(Math.pow(2,-n)),(n+128)/255}class svt{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._blurMaterial=function(t){const e=new Float32Array(20),n=new uht(0,1,0);return new Mgt({name:"SphericalGaussianBlur",defines:{n:20},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:e},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:n},inputEncoding:{value:jyt[3e3]},outputEncoding:{value:jyt[3e3]}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}(),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,n=.1,i=100){tvt=this._renderer.getRenderTarget();const r=this._allocateTargets();return this._sceneToCubeUV(t,n,i,r),e>0&&this._blur(r,0,0,e),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(t){return this._fromTexture(t)}fromCubemap(t){return this._fromTexture(t)}compileCubemapShader(){null===this._cubemapShader&&(this._cubemapShader=uvt(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){null===this._equirectShader&&(this._equirectShader=cvt(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),null!==this._cubemapShader&&this._cubemapShader.dispose(),null!==this._equirectShader&&this._equirectShader.dispose();for(let t=0;t<Yyt.length;t++)Yyt[t].dispose()}_cleanup(t){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(tvt),t.scissorTest=!1,lvt(t,0,0,t.width,t.height)}_fromTexture(t){tvt=this._renderer.getRenderTarget();const e=this._allocateTargets(t);return this._textureToCubeUV(t,e),this._applyPMREM(e),this._cleanup(e),e}_allocateTargets(t){const e={magFilter:1003,minFilter:1003,generateMipmaps:!1,type:1009,format:1023,encoding:ovt(t)?t.encoding:3002,depthBuffer:!1},n=avt(e);return n.depthBuffer=!t,this._pingPongRenderTarget=avt(e),n}_compileMaterial(t){const e=new gpt(Yyt[0],t);this._renderer.compile(e,Xyt)}_sceneToCubeUV(t,e,n,i){const r=new Spt(90,1,e,n),s=[1,-1,1,1,1,1],o=[1,1,1,-1,-1,-1],a=this._renderer,l=a.autoClear,c=a.outputEncoding,u=a.toneMapping;a.getClearColor(Zyt),a.toneMapping=0,a.outputEncoding=3e3,a.autoClear=!1;let h=!1;const d=t.background;if(d){if(d.isColor){Qyt.color.copy(d).convertSRGBToLinear(),t.background=null;const e=rvt(Qyt.color);Qyt.opacity=e,h=!0}}else{Qyt.color.copy(Zyt).convertSRGBToLinear();const t=rvt(Qyt.color);Qyt.opacity=t,h=!0}for(let p=0;p<6;p++){const e=p%3;0==e?(r.up.set(0,s[p],0),r.lookAt(o[p],0,0)):1==e?(r.up.set(0,0,s[p]),r.lookAt(0,o[p],0)):(r.up.set(0,s[p],0),r.lookAt(0,0,o[p])),lvt(i,e*Vyt,p>2?Vyt:0,Vyt,Vyt),a.setRenderTarget(i),h&&a.render(qyt,r),a.render(t,r)}a.toneMapping=u,a.outputEncoding=c,a.autoClear=l}_textureToCubeUV(t,e){const n=this._renderer;t.isCubeTexture?null==this._cubemapShader&&(this._cubemapShader=uvt()):null==this._equirectShader&&(this._equirectShader=cvt());const i=t.isCubeTexture?this._cubemapShader:this._equirectShader,r=new gpt(Yyt[0],i),s=i.uniforms;s.envMap.value=t,t.isCubeTexture||s.texelSize.value.set(1/t.image.width,1/t.image.height),s.inputEncoding.value=jyt[t.encoding],s.outputEncoding.value=jyt[e.texture.encoding],lvt(e,0,0,3*Vyt,2*Vyt),n.setRenderTarget(e),n.render(r,Xyt)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;for(let i=1;i<Wyt;i++){const e=Math.sqrt(Jyt[i]*Jyt[i]-Jyt[i-1]*Jyt[i-1]);this._blur(t,i-1,i,e,ivt[(i-1)%ivt.length])}e.autoClear=n}_blur(t,e,n,i,r){const s=this._pingPongRenderTarget;this._halfBlur(t,s,e,n,i,"latitudinal",r),this._halfBlur(s,t,n,n,i,"longitudinal",r)}_halfBlur(t,e,n,i,r,s,o){const a=this._renderer,l=this._blurMaterial;"latitudinal"!==s&&"longitudinal"!==s&&console.error("blur direction must be either latitudinal or longitudinal!");const c=new gpt(Yyt[i],l),u=l.uniforms,h=Kyt[n]-1,d=isFinite(r)?Math.PI/(2*h):2*Math.PI/39,p=r/d,f=isFinite(r)?1+Math.floor(3*p):20;f>20&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);const m=[];let g=0;for(let v=0;v<20;++v){const t=v/p,e=Math.exp(-t*t/2);m.push(e),0==v?g+=e:v<f&&(g+=2*e)}for(let v=0;v<m.length;v++)m[v]=m[v]/g;u.envMap.value=t.texture,u.samples.value=f,u.weights.value=m,u.latitudinal.value="latitudinal"===s,o&&(u.poleAxis.value=o),u.dTheta.value=d,u.mipInt.value=8-n,u.inputEncoding.value=jyt[t.texture.encoding],u.outputEncoding.value=jyt[t.texture.encoding];const y=Kyt[i];lvt(e,3*Math.max(0,Vyt-2*y),(0===i?0:2*Vyt)+2*y*(i>4?i-8+4:0),3*y,2*y),a.setRenderTarget(e),a.render(c,Xyt)}}function ovt(t){return void 0!==t&&1009===t.type&&(3e3===t.encoding||3001===t.encoding||3007===t.encoding)}function avt(t){const e=new lht(3*Vyt,3*Vyt,t);return e.texture.mapping=306,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function lvt(t,e,n,i,r){t.viewport.set(e,n,i,r),t.scissor.set(e,n,i,r)}function cvt(){const t=new tht(1,1);return new Mgt({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:t},inputEncoding:{value:jyt[3e3]},outputEncoding:{value:jyt[3e3]}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}function uvt(){return new Mgt({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:jyt[3e3]},outputEncoding:{value:jyt[3e3]}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}Fyt.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},Xgt.prototype.extractUrlBase=function(t){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),vyt.extractUrlBase(t)},Xgt.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},pht.prototype.center=function(t){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(t)},pht.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},pht.prototype.isIntersectionBox=function(t){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},pht.prototype.isIntersectionSphere=function(t){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)},pht.prototype.size=function(t){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(t)},Nht.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()},Rpt.prototype.setFromMatrix=function(t){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(t)},eht.prototype.flattenToArrayOffset=function(t,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},eht.prototype.multiplyVector3=function(t){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),t.applyMatrix3(this)},eht.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},eht.prototype.applyToBufferAttribute=function(t){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),t.applyMatrix3(this)},eht.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},eht.prototype.getInverse=function(t){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(t).invert()},Uht.prototype.extractPosition=function(t){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(t)},Uht.prototype.flattenToArrayOffset=function(t,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},Uht.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),(new uht).setFromMatrixColumn(this,3)},Uht.prototype.setRotationFromQuaternion=function(t){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(t)},Uht.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},Uht.prototype.multiplyVector3=function(t){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},Uht.prototype.multiplyVector4=function(t){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},Uht.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},Uht.prototype.rotateAxis=function(t){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),t.transformDirection(this)},Uht.prototype.crossVector=function(t){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},Uht.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")},Uht.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},Uht.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},Uht.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},Uht.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},Uht.prototype.applyToBufferAttribute=function(t){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},Uht.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},Uht.prototype.makeFrustum=function(t,e,n,i,r,s){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(t,e,i,n,r,s)},Uht.prototype.getInverse=function(t){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(t).invert()},gdt.prototype.isIntersectionLine=function(t){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(t)},cht.prototype.multiplyVector3=function(t){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),t.applyQuaternion(this)},cht.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()},zht.prototype.isIntersectionBox=function(t){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},zht.prototype.isIntersectionPlane=function(t){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(t)},zht.prototype.isIntersectionSphere=function(t){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)},Idt.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},Idt.prototype.barycoordFromPoint=function(t,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(t,e)},Idt.prototype.midpoint=function(t){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(t)},Idt.prototypenormal=function(t){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(t)},Idt.prototype.plane=function(t){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(t)},Idt.barycoordFromPoint=function(t,e,n,i,r){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),Idt.getBarycoord(t,e,n,i,r)},Idt.normal=function(t,e,n,i){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),Idt.getNormal(t,e,n,i)},tht.prototype.fromAttribute=function(t,e,n){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},tht.prototype.distanceToManhattan=function(t){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},tht.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},uht.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},uht.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},uht.prototype.getPositionFromMatrix=function(t){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(t)},uht.prototype.getScaleFromMatrix=function(t){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(t)},uht.prototype.getColumnFromMatrix=function(t,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,t)},uht.prototype.applyProjection=function(t){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(t)},uht.prototype.fromAttribute=function(t,e,n){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},uht.prototype.distanceToManhattan=function(t){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},uht.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},aht.prototype.fromAttribute=function(t,e,n){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},aht.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},ddt.prototype.getChildByName=function(t){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(t)},ddt.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},ddt.prototype.translate=function(t,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,t)},ddt.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},ddt.prototype.applyMatrix=function(t){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)},Object.defineProperties(ddt.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(t){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=t}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),gpt.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")},Object.defineProperties(gpt.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),0},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),igt.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},Spt.prototype.setLens=function(t,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),void 0!==e&&(this.filmGauge=e),this.setFocalLength(t)},Object.defineProperties(iyt.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(t){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=t}},shadowCameraLeft:{set:function(t){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=t}},shadowCameraRight:{set:function(t){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=t}},shadowCameraTop:{set:function(t){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=t}},shadowCameraBottom:{set:function(t){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=t}},shadowCameraNear:{set:function(t){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=t}},shadowCameraFar:{set:function(t){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=t}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(t){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=t}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(t){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=t}},shadowMapHeight:{set:function(t){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=t}}}),Object.defineProperties(zdt.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),35048===this.usage},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(35048)}}}),zdt.prototype.setDynamic=function(t){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===t?35048:35044),this},zdt.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},zdt.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},Jdt.prototype.addIndex=function(t){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(t)},Jdt.prototype.addAttribute=function(t,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),e&&e.isBufferAttribute||e&&e.isInterleavedBufferAttribute?"index"===t?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(t,e):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(t,new zdt(arguments[1],arguments[2])))},Jdt.prototype.addDrawCall=function(t,e,n){void 0!==n&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(t,e)},Jdt.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},Jdt.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},Jdt.prototype.removeAttribute=function(t){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(t)},Jdt.prototype.applyMatrix=function(t){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)},Object.defineProperties(Jdt.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),Xmt.prototype.setDynamic=function(t){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===t?35048:35044),this},Xmt.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},qmt.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")},Object.defineProperties(Mdt.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Odt}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(t){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===t}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(t){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=t}}}),Object.defineProperties(wpt.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(t){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=t}}}),jmt.prototype.clearTarget=function(t,e,n,i){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(t),this.clear(e,n,i)},jmt.prototype.animate=function(t){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(t)},jmt.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},jmt.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},jmt.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},jmt.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},jmt.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},jmt.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},jmt.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},jmt.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},jmt.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},jmt.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},jmt.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},jmt.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},jmt.prototype.enableScissorTest=function(t){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(t)},jmt.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},jmt.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},jmt.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},jmt.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},jmt.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},jmt.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},jmt.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},jmt.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},jmt.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},jmt.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()},Object.defineProperties(jmt.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=t}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=t}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(t){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=!0===t?3001:3e3}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}}),Object.defineProperties(Omt.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(lht.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=t}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=t}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=t}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=t}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(t){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=t}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(t){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=t}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(t){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=t}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(t){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=t}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(t){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=t}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(t){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=t}}}),Ept.prototype.updateCubeMap=function(t,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(t,e)},Ept.prototype.clear=function(t,e,n,i){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(t,e,n,i)},iht.crossOrigin=void 0,iht.loadTexture=function(t,e,n,i){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const r=new nyt;r.setCrossOrigin(this.crossOrigin);const s=r.load(t,n,void 0,i);return e&&(s.mapping=e),s},iht.loadTextureCube=function(t,e,n,i){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const r=new tyt;r.setCrossOrigin(this.crossOrigin);const s=r.load(t,n,void 0,i);return e&&(s.mapping=e),s},iht.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},iht.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:"128"}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__="128");const hvt=new WeakMap;function dvt(){let t,e;function n(t,e,n,i,r,s){const o=s.num_components(),a=n.num_points()*o,l=a*r.BYTES_PER_ELEMENT,c=function(t,e){switch(e){case Float32Array:return t.DT_FLOAT32;case Int8Array:return t.DT_INT8;case Int16Array:return t.DT_INT16;case Int32Array:return t.DT_INT32;case Uint8Array:return t.DT_UINT8;case Uint16Array:return t.DT_UINT16;case Uint32Array:return t.DT_UINT32}}(t,r),u=t._malloc(l);e.GetAttributeDataArrayForAllPoints(n,s,c,l,u);const h=new r(t.HEAPF32.buffer,u,a).slice();return t._free(u),{name:i,array:h,itemSize:o}}onmessage=function(i){const r=i.data;switch(r.type){case"init":t=r.decoderConfig,e=new Promise(function(e){t.onModuleLoaded=function(t){e({draco:t})},DracoDecoderModule(t)});break;case"decode":const i=r.buffer,s=r.taskConfig;e.then(t=>{const e=t.draco,o=new e.Decoder,a=new e.DecoderBuffer;a.Init(new Int8Array(i),i.byteLength);try{const t=function(t,e,i,r){const s=r.attributeIDs,o=r.attributeTypes;let a,l;const c=e.GetEncodedGeometryType(i);if(c===t.TRIANGULAR_MESH)a=new t.Mesh,l=e.DecodeBufferToMesh(i,a);else{if(c!==t.POINT_CLOUD)throw new Error("THREE.DRACOLoader: Unexpected geometry type.");a=new t.PointCloud,l=e.DecodeBufferToPointCloud(i,a)}if(!l.ok()||0===a.ptr)throw new Error("THREE.DRACOLoader: Decoding failed: "+l.error_msg());const u={index:null,attributes:[]};for(const h in s){const i=self[o[h]];let l,c;if(r.useUniqueIDs)c=s[h],l=e.GetAttributeByUniqueId(a,c);else{if(c=e.GetAttributeId(a,t[s[h]]),-1===c)continue;l=e.GetAttribute(a,c)}u.attributes.push(n(t,e,a,h,i,l))}return c===t.TRIANGULAR_MESH&&(u.index=function(t,e,n){const i=3*n.num_faces(),r=4*i,s=t._malloc(r);e.GetTrianglesUInt32Array(n,r,s);const o=new Uint32Array(t.HEAPF32.buffer,s,i).slice();return t._free(s),{array:o,itemSize:1}}(t,e,a)),t.destroy(a),u}(e,o,a,s),i=t.attributes.map(t=>t.array.buffer);t.index&&i.push(t.index.array.buffer),self.postMessage({type:"decode",id:r.id,geometry:t},i)}catch(t){console.error(t),self.postMessage({type:"error",id:r.id,error:t.message})}finally{e.destroy(a),e.destroy(o)}})}}}class pvt extends Xgt{constructor(t){super(t),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new vvt(t)}),this.register(function(t){return new Avt(t)}),this.register(function(t){return new xvt(t)}),this.register(function(t){return new bvt(t)}),this.register(function(t){return new gvt(t)}),this.register(function(t){return new wvt(t)})}load(t,e,n,i){const r=this;let s;s=""!==this.resourcePath?this.resourcePath:""!==this.path?this.path:vyt.extractUrlBase(t),this.manager.itemStart(t);const o=function(e){i?i(e):console.error(e),r.manager.itemError(t),r.manager.itemEnd(t)},a=new Kgt(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,function(n){try{r.parse(n,s,function(n){e(n),r.manager.itemEnd(t)},o)}catch(t){o(t)}},n,o)}setDRACOLoader(t){return this.dracoLoader=t,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(t){return this.ktx2Loader=t,this}setMeshoptDecoder(t){return this.meshoptDecoder=t,this}register(t){return-1===this.pluginCallbacks.indexOf(t)&&this.pluginCallbacks.push(t),this}unregister(t){return-1!==this.pluginCallbacks.indexOf(t)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t),1),this}parse(t,e,n,i){let r;const s={},o={};if("string"==typeof t)r=t;else if(vyt.decodeText(new Uint8Array(t,0,4))===_vt){try{s[mvt.KHR_BINARY_GLTF]=new Svt(t)}catch(t){return void(i&&i(t))}r=s[mvt.KHR_BINARY_GLTF].content}else r=vyt.decodeText(new Uint8Array(t));const a=JSON.parse(r);if(void 0===a.asset||a.asset.version[0]<2)return void(i&&i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const l=new jvt(a,{path:e||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let c=0;c<this.pluginCallbacks.length;c++){const t=this.pluginCallbacks[c](l);o[t.name]=t,s[t.name]=!0}if(a.extensionsUsed)for(let c=0;c<a.extensionsUsed.length;++c){const t=a.extensionsUsed[c],e=a.extensionsRequired||[];switch(t){case mvt.KHR_MATERIALS_UNLIT:s[t]=new yvt;break;case mvt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:s[t]=new Tvt;break;case mvt.KHR_DRACO_MESH_COMPRESSION:s[t]=new Evt(a,this.dracoLoader);break;case mvt.KHR_TEXTURE_TRANSFORM:s[t]=new Cvt;break;case mvt.KHR_MESH_QUANTIZATION:s[t]=new Mvt;break;default:e.indexOf(t)>=0&&void 0===o[t]&&console.warn('THREE.GLTFLoader: Unknown extension "'+t+'".')}}l.setExtensions(s),l.setPlugins(o),l.parse(n,i)}}function fvt(){let t={};return{get:function(e){return t[e]},add:function(e,n){t[e]=n},remove:function(e){delete t[e]},removeAll:function(){t={}}}}const mvt={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class gvt{constructor(t){this.parser=t,this.name=mvt.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const t=this.parser,e=this.parser.json.nodes||[];for(let n=0,i=e.length;n<i;n++){const i=e[n];i.extensions&&i.extensions[this.name]&&void 0!==i.extensions[this.name].light&&t._addNodeRef(this.cache,i.extensions[this.name].light)}}_loadLight(t){const e=this.parser,n="light:"+t;let i=e.cache.get(n);if(i)return i;const r=e.json,s=((r.extensions&&r.extensions[this.name]||{}).lights||[])[t];let o;const a=new Odt(16777215);void 0!==s.color&&a.fromArray(s.color);const l=void 0!==s.range?s.range:0;switch(s.type){case"directional":o=new yyt(a),o.target.position.set(0,0,-1),o.add(o.target);break;case"point":o=new fyt(a),o.distance=l;break;case"spot":o=new cyt(a),o.distance=l,s.spot=s.spot||{},s.spot.innerConeAngle=void 0!==s.spot.innerConeAngle?s.spot.innerConeAngle:0,s.spot.outerConeAngle=void 0!==s.spot.outerConeAngle?s.spot.outerConeAngle:Math.PI/4,o.angle=s.spot.outerConeAngle,o.penumbra=1-s.spot.innerConeAngle/s.spot.outerConeAngle,o.target.position.set(0,0,-1),o.add(o.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+s.type)}return o.position.set(0,0,0),o.decay=2,void 0!==s.intensity&&(o.intensity=s.intensity),o.name=e.createUniqueName(s.name||"light_"+t),i=Promise.resolve(o),e.cache.add(n,i),i}createNodeAttachment(t){const e=this,n=this.parser,i=n.json.nodes[t],r=(i.extensions&&i.extensions[this.name]||{}).light;return void 0===r?null:this._loadLight(r).then(function(t){return n._getNodeRef(e.cache,r,t)})}}class yvt{constructor(){this.name=mvt.KHR_MATERIALS_UNLIT}getMaterialType(){return Pdt}extendParams(t,e,n){const i=[];t.color=new Odt(1,1,1),t.opacity=1;const r=e.pbrMetallicRoughness;if(r){if(Array.isArray(r.baseColorFactor)){const e=r.baseColorFactor;t.color.fromArray(e),t.opacity=e[3]}void 0!==r.baseColorTexture&&i.push(n.assignTexture(t,"map",r.baseColorTexture))}return Promise.all(i)}}class vvt{constructor(t){this.parser=t,this.name=mvt.KHR_MATERIALS_CLEARCOAT}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?Rgt:null}extendMaterialParams(t,e){const n=this.parser,i=n.json.materials[t];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],s=i.extensions[this.name];if(void 0!==s.clearcoatFactor&&(e.clearcoat=s.clearcoatFactor),void 0!==s.clearcoatTexture&&r.push(n.assignTexture(e,"clearcoatMap",s.clearcoatTexture)),void 0!==s.clearcoatRoughnessFactor&&(e.clearcoatRoughness=s.clearcoatRoughnessFactor),void 0!==s.clearcoatRoughnessTexture&&r.push(n.assignTexture(e,"clearcoatRoughnessMap",s.clearcoatRoughnessTexture)),void 0!==s.clearcoatNormalTexture&&(r.push(n.assignTexture(e,"clearcoatNormalMap",s.clearcoatNormalTexture)),void 0!==s.clearcoatNormalTexture.scale)){const t=s.clearcoatNormalTexture.scale;e.clearcoatNormalScale=new tht(t,-t)}return Promise.all(r)}}class bvt{constructor(t){this.parser=t,this.name=mvt.KHR_MATERIALS_TRANSMISSION}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?Rgt:null}extendMaterialParams(t,e){const n=this.parser,i=n.json.materials[t];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],s=i.extensions[this.name];return void 0!==s.transmissionFactor&&(e.transmission=s.transmissionFactor),void 0!==s.transmissionTexture&&r.push(n.assignTexture(e,"transmissionMap",s.transmissionTexture)),Promise.all(r)}}class Avt{constructor(t){this.parser=t,this.name=mvt.KHR_TEXTURE_BASISU}loadTexture(t){const e=this.parser,n=e.json,i=n.textures[t];if(!i.extensions||!i.extensions[this.name])return null;const r=n.images[i.extensions[this.name].source],s=e.options.ktx2Loader;if(!s){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return e.loadTextureImage(t,r,s)}}class xvt{constructor(t){this.parser=t,this.name=mvt.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(t){const e=this.name,n=this.parser,i=n.json,r=i.textures[t];if(!r.extensions||!r.extensions[e])return null;const s=i.images[r.extensions[e].source];let o=n.textureLoader;if(s.uri){const t=n.options.manager.getHandler(s.uri);null!==t&&(o=t)}return this.detectSupport().then(function(r){if(r)return n.loadTextureImage(t,s,o);if(i.extensionsRequired&&i.extensionsRequired.indexOf(e)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return n.loadTexture(t)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(t){const e=new Image;e.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",e.onload=e.onerror=function(){t(1===e.height)}})),this.isSupported}}class wvt{constructor(t){this.name=mvt.EXT_MESHOPT_COMPRESSION,this.parser=t}loadBufferView(t){const e=this.parser.json,n=e.bufferViews[t];if(n.extensions&&n.extensions[this.name]){const t=n.extensions[this.name],i=this.parser.getDependency("buffer",t.buffer),r=this.parser.options.meshoptDecoder;if(!r||!r.supported){if(e.extensionsRequired&&e.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([i,r.ready]).then(function(e){const n=t.byteOffset||0,i=t.byteLength||0,s=t.count,o=t.byteStride,a=new ArrayBuffer(s*o),l=new Uint8Array(e[0],n,i);return r.decodeGltfBuffer(new Uint8Array(a),s,o,l,t.mode,t.filter),a})}return null}}const _vt="glTF";class Svt{constructor(t){this.name=mvt.KHR_BINARY_GLTF,this.content=null,this.body=null;const e=new DataView(t,0,12);if(this.header={magic:vyt.decodeText(new Uint8Array(t.slice(0,4))),version:e.getUint32(4,!0),length:e.getUint32(8,!0)},this.header.magic!==_vt)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-12,i=new DataView(t,12);let r=0;for(;r<n;){const e=i.getUint32(r,!0);r+=4;const n=i.getUint32(r,!0);if(r+=4,1313821514===n){const n=new Uint8Array(t,12+r,e);this.content=vyt.decodeText(n)}else if(5130562===n){const n=12+r;this.body=t.slice(n,n+e)}r+=e}if(null===this.content)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class Evt{constructor(t,e){if(!e)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=mvt.KHR_DRACO_MESH_COMPRESSION,this.json=t,this.dracoLoader=e,this.dracoLoader.preload()}decodePrimitive(t,e){const n=this.json,i=this.dracoLoader,r=t.extensions[this.name].bufferView,s=t.extensions[this.name].attributes,o={},a={},l={};for(const c in s){const t=Bvt[c]||c.toLowerCase();o[t]=s[c]}for(const c in t.attributes){const e=Bvt[c]||c.toLowerCase();if(void 0!==s[c]){const i=n.accessors[t.attributes[c]];l[e]=Rvt[i.componentType],a[e]=!0===i.normalized}}return e.getDependency("bufferView",r).then(function(t){return new Promise(function(e){i.decodeDracoFile(t,function(t){for(const e in t.attributes){const n=t.attributes[e],i=a[e];void 0!==i&&(n.normalized=i)}e(t)},o,l)})})}}class Cvt{constructor(){this.name=mvt.KHR_TEXTURE_TRANSFORM}extendTexture(t,e){return t=t.clone(),void 0!==e.offset&&t.offset.fromArray(e.offset),void 0!==e.rotation&&(t.rotation=e.rotation),void 0!==e.scale&&t.repeat.fromArray(e.scale),void 0!==e.texCoord&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),t.needsUpdate=!0,t}}class Ivt extends kgt{constructor(t){super(),this.isGLTFSpecularGlossinessMaterial=!0;const e=["#ifdef USE_SPECULARMAP","\tuniform sampler2D specularMap;","#endif"].join("\n"),n=["#ifdef USE_GLOSSINESSMAP","\tuniform sampler2D glossinessMap;","#endif"].join("\n"),i=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","\tvec4 texelSpecular = texture2D( specularMap, vUv );","\ttexelSpecular = sRGBToLinear( texelSpecular );","\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","\tspecularFactor *= texelSpecular.rgb;","#endif"].join("\n"),r=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );","\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","\tglossinessFactor *= texelGlossiness.a;","#endif"].join("\n"),s=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.specularRoughness += geometryRoughness;","material.specularRoughness = min( material.specularRoughness, 1.0 );","material.specularColor = specularFactor;"].join("\n"),o={specular:{value:(new Odt).setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=o,this.onBeforeCompile=function(t){for(const e in o)t.uniforms[e]=o[e];t.fragmentShader=t.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",e).replace("#include <metalnessmap_pars_fragment>",n).replace("#include <roughnessmap_fragment>",i).replace("#include <metalnessmap_fragment>",r).replace("#include <lights_physical_fragment>",s)},Object.defineProperties(this,{specular:{get:function(){return o.specular.value},set:function(t){o.specular.value=t}},specularMap:{get:function(){return o.specularMap.value},set:function(t){o.specularMap.value=t,t?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return o.glossiness.value},set:function(t){o.glossiness.value=t}},glossinessMap:{get:function(){return o.glossinessMap.value},set:function(t){o.glossinessMap.value=t,t?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(t)}copy(t){return super.copy(t),this.specularMap=t.specularMap,this.specular.copy(t.specular),this.glossinessMap=t.glossinessMap,this.glossiness=t.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}class Tvt{constructor(){this.name=mvt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity","refractionRatio"]}getMaterialType(){return Ivt}extendParams(t,e,n){const i=e.extensions[this.name];t.color=new Odt(1,1,1),t.opacity=1;const r=[];if(Array.isArray(i.diffuseFactor)){const e=i.diffuseFactor;t.color.fromArray(e),t.opacity=e[3]}if(void 0!==i.diffuseTexture&&r.push(n.assignTexture(t,"map",i.diffuseTexture)),t.emissive=new Odt(0,0,0),t.glossiness=void 0!==i.glossinessFactor?i.glossinessFactor:1,t.specular=new Odt(1,1,1),Array.isArray(i.specularFactor)&&t.specular.fromArray(i.specularFactor),void 0!==i.specularGlossinessTexture){const e=i.specularGlossinessTexture;r.push(n.assignTexture(t,"glossinessMap",e)),r.push(n.assignTexture(t,"specularMap",e))}return Promise.all(r)}createMaterial(t){const e=new Ivt(t);return e.fog=!0,e.color=t.color,e.map=void 0===t.map?null:t.map,e.lightMap=null,e.lightMapIntensity=1,e.aoMap=void 0===t.aoMap?null:t.aoMap,e.aoMapIntensity=1,e.emissive=t.emissive,e.emissiveIntensity=1,e.emissiveMap=void 0===t.emissiveMap?null:t.emissiveMap,e.bumpMap=void 0===t.bumpMap?null:t.bumpMap,e.bumpScale=1,e.normalMap=void 0===t.normalMap?null:t.normalMap,e.normalMapType=0,t.normalScale&&(e.normalScale=t.normalScale),e.displacementMap=null,e.displacementScale=1,e.displacementBias=0,e.specularMap=void 0===t.specularMap?null:t.specularMap,e.specular=t.specular,e.glossinessMap=void 0===t.glossinessMap?null:t.glossinessMap,e.glossiness=t.glossiness,e.alphaMap=null,e.envMap=void 0===t.envMap?null:t.envMap,e.envMapIntensity=1,e.refractionRatio=.98,e}}class Mvt{constructor(){this.name=mvt.KHR_MESH_QUANTIZATION}}class kvt extends Lgt{constructor(t,e,n,i){super(t,e,n,i)}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,i=this.valueSize,r=t*i*3+i;for(let s=0;s!==i;s++)e[s]=n[r+s];return e}}kvt.prototype.beforeStart_=kvt.prototype.copySampleValue_,kvt.prototype.afterEnd_=kvt.prototype.copySampleValue_,kvt.prototype.interpolate_=function(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=2*o,l=3*o,c=i-e,u=(n-e)/c,h=u*u,d=h*u,p=t*l,f=p-l,m=-2*d+3*h,g=d-h,y=1-m,v=g-h+u;for(let b=0;b!==o;b++)r[b]=y*s[f+b+o]+v*(s[f+b+a]*c)+m*s[p+b+o]+g*(s[p+b]*c);return r};const Rvt={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Nvt={9728:1003,9729:1006,9984:1004,9985:1007,9986:1005,9987:1008},Lvt={33071:1001,33648:1002,10497:1e3},Dvt={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Bvt={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Ovt={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Pvt={CUBICSPLINE:void 0,LINEAR:2301,STEP:2300};function Fvt(t,e){return"string"!=typeof t||""===t?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}function $vt(t){return void 0===t.DefaultMaterial&&(t.DefaultMaterial=new kgt({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:0})),t.DefaultMaterial}function zvt(t,e,n){for(const i in n.extensions)void 0===t[i]&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[i]=n.extensions[i])}function Uvt(t,e){void 0!==e.extras&&("object"==typeof e.extras?Object.assign(t.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function Hvt(t,e){if(t.updateMorphTargets(),void 0!==e.weights)for(let n=0,i=e.weights.length;n<i;n++)t.morphTargetInfluences[n]=e.weights[n];if(e.extras&&Array.isArray(e.extras.targetNames)){const n=e.extras.targetNames;if(t.morphTargetInfluences.length===n.length){t.morphTargetDictionary={};for(let e=0,i=n.length;e<i;e++)t.morphTargetDictionary[n[e]]=e}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function Vvt(t){const e=t.extensions&&t.extensions[mvt.KHR_DRACO_MESH_COMPRESSION];let n;return n=e?"draco:"+e.bufferView+":"+e.indices+":"+Gvt(e.attributes):t.indices+":"+Gvt(t.attributes)+":"+t.mode,n}function Gvt(t){let e="";const n=Object.keys(t).sort();for(let i=0,r=n.length;i<r;i++)e+=n[i]+":"+t[n[i]]+";";return e}function Wvt(t){switch(t){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}class jvt{constructor(t={},e={}){this.json=t,this.extensions={},this.plugins={},this.options=e,this.cache=new fvt,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.nodeNamesUsed={},this.textureLoader="undefined"!=typeof createImageBitmap&&!1===/Firefox/.test(navigator.userAgent)?new byt(this.options.manager):new nyt(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Kgt(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(t){this.extensions=t}setPlugins(t){this.plugins=t}parse(t,e){const n=this,i=this.json,r=this.extensions;this.cache.removeAll(),this._invokeAll(function(t){return t._markDefs&&t._markDefs()}),Promise.all(this._invokeAll(function(t){return t.beforeRoot&&t.beforeRoot()})).then(function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])}).then(function(e){const s={scene:e[0][i.scene||0],scenes:e[0],animations:e[1],cameras:e[2],asset:i.asset,parser:n,userData:{}};zvt(r,s,i),Uvt(s,i),Promise.all(n._invokeAll(function(t){return t.afterRoot&&t.afterRoot(s)})).then(function(){t(s)})}).catch(e)}_markDefs(){const t=this.json.nodes||[],e=this.json.skins||[],n=this.json.meshes||[];for(let i=0,r=e.length;i<r;i++){const n=e[i].joints;for(let e=0,i=n.length;e<i;e++)t[n[e]].isBone=!0}for(let i=0,r=t.length;i<r;i++){const e=t[i];void 0!==e.mesh&&(this._addNodeRef(this.meshCache,e.mesh),void 0!==e.skin&&(n[e.mesh].isSkinnedMesh=!0)),void 0!==e.camera&&this._addNodeRef(this.cameraCache,e.camera)}}_addNodeRef(t,e){void 0!==e&&(void 0===t.refs[e]&&(t.refs[e]=t.uses[e]=0),t.refs[e]++)}_getNodeRef(t,e,n){if(t.refs[e]<=1)return n;const i=n.clone();return i.name+="_instance_"+t.uses[e]++,i}_invokeOne(t){const e=Object.values(this.plugins);e.push(this);for(let n=0;n<e.length;n++){const i=t(e[n]);if(i)return i}return null}_invokeAll(t){const e=Object.values(this.plugins);e.unshift(this);const n=[];for(let i=0;i<e.length;i++){const r=t(e[i]);r&&n.push(r)}return n}getDependency(t,e){const n=t+":"+e;let i=this.cache.get(n);if(!i){switch(t){case"scene":i=this.loadScene(e);break;case"node":i=this.loadNode(e);break;case"mesh":i=this._invokeOne(function(t){return t.loadMesh&&t.loadMesh(e)});break;case"accessor":i=this.loadAccessor(e);break;case"bufferView":i=this._invokeOne(function(t){return t.loadBufferView&&t.loadBufferView(e)});break;case"buffer":i=this.loadBuffer(e);break;case"material":i=this._invokeOne(function(t){return t.loadMaterial&&t.loadMaterial(e)});break;case"texture":i=this._invokeOne(function(t){return t.loadTexture&&t.loadTexture(e)});break;case"skin":i=this.loadSkin(e);break;case"animation":i=this.loadAnimation(e);break;case"camera":i=this.loadCamera(e);break;default:throw new Error("Unknown type: "+t)}this.cache.add(n,i)}return i}getDependencies(t){let e=this.cache.get(t);if(!e){const n=this;e=Promise.all((this.json[t+("mesh"===t?"es":"s")]||[]).map(function(e,i){return n.getDependency(t,i)})),this.cache.add(t,e)}return e}loadBuffer(t){const e=this.json.buffers[t],n=this.fileLoader;if(e.type&&"arraybuffer"!==e.type)throw new Error("THREE.GLTFLoader: "+e.type+" buffer type is not supported.");if(void 0===e.uri&&0===t)return Promise.resolve(this.extensions[mvt.KHR_BINARY_GLTF].body);const i=this.options;return new Promise(function(t,r){n.load(Fvt(e.uri,i.path),t,void 0,function(){r(new Error('THREE.GLTFLoader: Failed to load buffer "'+e.uri+'".'))})})}loadBufferView(t){const e=this.json.bufferViews[t];return this.getDependency("buffer",e.buffer).then(function(t){const n=e.byteOffset||0;return t.slice(n,n+(e.byteLength||0))})}loadAccessor(t){const e=this,n=this.json,i=this.json.accessors[t];if(void 0===i.bufferView&&void 0===i.sparse)return Promise.resolve(null);const r=[];return r.push(void 0!==i.bufferView?this.getDependency("bufferView",i.bufferView):null),void 0!==i.sparse&&(r.push(this.getDependency("bufferView",i.sparse.indices.bufferView)),r.push(this.getDependency("bufferView",i.sparse.values.bufferView))),Promise.all(r).then(function(t){const r=t[0],s=Dvt[i.type],o=Rvt[i.componentType],a=o.BYTES_PER_ELEMENT,l=i.byteOffset||0,c=void 0!==i.bufferView?n.bufferViews[i.bufferView].byteStride:void 0,u=!0===i.normalized;let h,d;if(c&&c!==a*s){const t=Math.floor(l/c),n="InterleavedBuffer:"+i.bufferView+":"+i.componentType+":"+t+":"+i.count;let p=e.cache.get(n);p||(h=new o(r,t*c,i.count*c/a),p=new Xmt(h,c/a),e.cache.add(n,p)),d=new Kmt(p,s,l%c/a,u)}else h=null===r?new o(i.count*s):new o(r,l,i.count*s),d=new zdt(h,s,u);if(void 0!==i.sparse){const e=i.sparse.values.byteOffset||0,n=new(0,Rvt[i.sparse.indices.componentType])(t[1],i.sparse.indices.byteOffset||0,i.sparse.count*Dvt.SCALAR),a=new o(t[2],e,i.sparse.count*s);null!==r&&(d=new zdt(d.array.slice(),d.itemSize,d.normalized));for(let t=0,i=n.length;t<i;t++){const e=n[t];if(d.setX(e,a[t*s]),s>=2&&d.setY(e,a[t*s+1]),s>=3&&d.setZ(e,a[t*s+2]),s>=4&&d.setW(e,a[t*s+3]),s>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return d})}loadTexture(t){const e=this.json,n=e.images[e.textures[t].source];let i=this.textureLoader;if(n.uri){const t=this.options.manager.getHandler(n.uri);null!==t&&(i=t)}return this.loadTextureImage(t,n,i)}loadTextureImage(t,e,n){const i=this,r=this.json,s=this.options,o=r.textures[t],a=self.URL||self.webkitURL;let l=e.uri,c=!1,u=!0;if("image/jpeg"===e.mimeType&&(u=!1),void 0!==e.bufferView)l=i.getDependency("bufferView",e.bufferView).then(function(t){if("image/png"===e.mimeType){const e=new DataView(t,25,1).getUint8(0,!1);u=6===e||4===e||3===e}c=!0;const n=new Blob([t],{type:e.mimeType});return l=a.createObjectURL(n),l});else if(void 0===e.uri)throw new Error("THREE.GLTFLoader: Image "+t+" is missing URI and bufferView");return Promise.resolve(l).then(function(t){return new Promise(function(e,i){let r=e;!0===n.isImageBitmapLoader&&(r=function(t){e(new Igt(t))}),n.load(Fvt(t,s.path),r,void 0,i)})}).then(function(e){!0===c&&a.revokeObjectURL(l),e.flipY=!1,o.name&&(e.name=o.name),u||(e.format=1022);const n=(r.samplers||{})[o.sampler]||{};return e.magFilter=Nvt[n.magFilter]||1006,e.minFilter=Nvt[n.minFilter]||1008,e.wrapS=Lvt[n.wrapS]||1e3,e.wrapT=Lvt[n.wrapT]||1e3,i.associations.set(e,{type:"textures",index:t}),e})}assignTexture(t,e,n){const i=this;return this.getDependency("texture",n.index).then(function(r){if(void 0===n.texCoord||0==n.texCoord||"aoMap"===e&&1==n.texCoord||console.warn("THREE.GLTFLoader: Custom UV set "+n.texCoord+" for texture "+e+" not yet supported."),i.extensions[mvt.KHR_TEXTURE_TRANSFORM]){const t=void 0!==n.extensions?n.extensions[mvt.KHR_TEXTURE_TRANSFORM]:void 0;if(t){const e=i.associations.get(r);r=i.extensions[mvt.KHR_TEXTURE_TRANSFORM].extendTexture(r,t),i.associations.set(r,e)}}t[e]=r})}assignFinalMaterial(t){const e=t.geometry;let n=t.material;const i=void 0!==e.attributes.tangent,r=void 0!==e.attributes.color,s=void 0===e.attributes.normal,o=!0===t.isSkinnedMesh,a=Object.keys(e.morphAttributes).length>0,l=a&&void 0!==e.morphAttributes.normal;if(t.isPoints){const t="PointsMaterial:"+n.uuid;let e=this.cache.get(t);e||(e=new bgt,Mdt.prototype.copy.call(e,n),e.color.copy(n.color),e.map=n.map,e.sizeAttenuation=!1,this.cache.add(t,e)),n=e}else if(t.isLine){const t="LineBasicMaterial:"+n.uuid;let e=this.cache.get(t);e||(e=new lgt,Mdt.prototype.copy.call(e,n),e.color.copy(n.color),this.cache.add(t,e)),n=e}if(i||r||s||o||a){let t="ClonedMaterial:"+n.uuid+":";n.isGLTFSpecularGlossinessMaterial&&(t+="specular-glossiness:"),o&&(t+="skinning:"),i&&(t+="vertex-tangents:"),r&&(t+="vertex-colors:"),s&&(t+="flat-shading:"),a&&(t+="morph-targets:"),l&&(t+="morph-normals:");let e=this.cache.get(t);e||(e=n.clone(),o&&(e.skinning=!0),r&&(e.vertexColors=!0),s&&(e.flatShading=!0),a&&(e.morphTargets=!0),l&&(e.morphNormals=!0),i&&(e.vertexTangents=!0,e.normalScale&&(e.normalScale.y*=-1),e.clearcoatNormalScale&&(e.clearcoatNormalScale.y*=-1)),this.cache.add(t,e),this.associations.set(e,this.associations.get(n))),n=e}n.aoMap&&void 0===e.attributes.uv2&&void 0!==e.attributes.uv&&e.setAttribute("uv2",e.attributes.uv),t.material=n}getMaterialType(){return kgt}loadMaterial(t){const e=this,n=this.extensions,i=this.json.materials[t];let r;const s={},o=i.extensions||{},a=[];if(o[mvt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){const t=n[mvt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];r=t.getMaterialType(),a.push(t.extendParams(s,i,e))}else if(o[mvt.KHR_MATERIALS_UNLIT]){const t=n[mvt.KHR_MATERIALS_UNLIT];r=t.getMaterialType(),a.push(t.extendParams(s,i,e))}else{const n=i.pbrMetallicRoughness||{};if(s.color=new Odt(1,1,1),s.opacity=1,Array.isArray(n.baseColorFactor)){const t=n.baseColorFactor;s.color.fromArray(t),s.opacity=t[3]}void 0!==n.baseColorTexture&&a.push(e.assignTexture(s,"map",n.baseColorTexture)),s.metalness=void 0!==n.metallicFactor?n.metallicFactor:1,s.roughness=void 0!==n.roughnessFactor?n.roughnessFactor:1,void 0!==n.metallicRoughnessTexture&&(a.push(e.assignTexture(s,"metalnessMap",n.metallicRoughnessTexture)),a.push(e.assignTexture(s,"roughnessMap",n.metallicRoughnessTexture))),r=this._invokeOne(function(e){return e.getMaterialType&&e.getMaterialType(t)}),a.push(Promise.all(this._invokeAll(function(e){return e.extendMaterialParams&&e.extendMaterialParams(t,s)})))}!0===i.doubleSided&&(s.side=2);const l=i.alphaMode||"OPAQUE";return"BLEND"===l?(s.transparent=!0,s.depthWrite=!1):(s.transparent=!1,"MASK"===l&&(s.alphaTest=void 0!==i.alphaCutoff?i.alphaCutoff:.5)),void 0!==i.normalTexture&&r!==Pdt&&(a.push(e.assignTexture(s,"normalMap",i.normalTexture)),s.normalScale=new tht(1,-1),void 0!==i.normalTexture.scale&&s.normalScale.set(i.normalTexture.scale,-i.normalTexture.scale)),void 0!==i.occlusionTexture&&r!==Pdt&&(a.push(e.assignTexture(s,"aoMap",i.occlusionTexture)),void 0!==i.occlusionTexture.strength&&(s.aoMapIntensity=i.occlusionTexture.strength)),void 0!==i.emissiveFactor&&r!==Pdt&&(s.emissive=(new Odt).fromArray(i.emissiveFactor)),void 0!==i.emissiveTexture&&r!==Pdt&&a.push(e.assignTexture(s,"emissiveMap",i.emissiveTexture)),Promise.all(a).then(function(){let o;return o=r===Ivt?n[mvt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(s):new r(s),i.name&&(o.name=i.name),o.map&&(o.map.encoding=3001),o.emissiveMap&&(o.emissiveMap.encoding=3001),Uvt(o,i),e.associations.set(o,{type:"materials",index:t}),i.extensions&&zvt(n,o,i),o})}createUniqueName(t){const e=Myt.sanitizeNodeName(t||"");let n=e;for(let i=1;this.nodeNamesUsed[n];++i)n=e+"_"+i;return this.nodeNamesUsed[n]=!0,n}loadGeometries(t){const e=this,n=this.extensions,i=this.primitiveCache;function r(t){return n[mvt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t,e).then(function(n){return qvt(n,t,e)})}const s=[];for(let o=0,a=t.length;o<a;o++){const n=t[o],a=Vvt(n),l=i[a];if(l)s.push(l.promise);else{let t;t=n.extensions&&n.extensions[mvt.KHR_DRACO_MESH_COMPRESSION]?r(n):qvt(new Jdt,n,e),i[a]={primitive:n,promise:t},s.push(t)}}return Promise.all(s)}loadMesh(t){const e=this,n=this.extensions,i=this.json.meshes[t],r=i.primitives,s=[];for(let o=0,a=r.length;o<a;o++){const t=void 0===r[o].material?$vt(this.cache):this.getDependency("material",r[o].material);s.push(t)}return s.push(e.loadGeometries(r)),Promise.all(s).then(function(s){const o=s.slice(0,s.length-1),a=s[s.length-1],l=[];for(let u=0,h=a.length;u<h;u++){const s=a[u],c=r[u];let h;const d=o[u];if(4===c.mode||5===c.mode||6===c.mode||void 0===c.mode)h=!0===i.isSkinnedMesh?new igt(s,d):new gpt(s,d),!0!==h.isSkinnedMesh||h.geometry.attributes.skinWeight.normalized||h.normalizeSkinWeights(),5===c.mode?h.geometry=Xvt(h.geometry,1):6===c.mode&&(h.geometry=Xvt(h.geometry,2));else if(1===c.mode)h=new ygt(s,d);else if(3===c.mode)h=new fgt(s,d);else if(2===c.mode)h=new vgt(s,d);else{if(0!==c.mode)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+c.mode);h=new Sgt(s,d)}Object.keys(h.geometry.morphAttributes).length>0&&Hvt(h,i),h.name=e.createUniqueName(i.name||"mesh_"+t),Uvt(h,i),c.extensions&&zvt(n,h,c),e.assignFinalMaterial(h),l.push(h)}if(1===l.length)return l[0];const c=new Umt;for(let t=0,e=l.length;t<e;t++)c.add(l[t]);return c})}loadCamera(t){let e;const n=this.json.cameras[t],i=n[n.type];if(i)return"perspective"===n.type?e=new Spt(Zut.radToDeg(i.yfov),i.aspectRatio||1,i.znear||1,i.zfar||2e6):"orthographic"===n.type&&(e=new myt(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),n.name&&(e.name=this.createUniqueName(n.name)),Uvt(e,n),Promise.resolve(e);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(t){const e=this.json.skins[t],n={joints:e.joints};return void 0===e.inverseBindMatrices?Promise.resolve(n):this.getDependency("accessor",e.inverseBindMatrices).then(function(t){return n.inverseBindMatrices=t,n})}loadAnimation(t){const e=this.json.animations[t],n=[],i=[],r=[],s=[],o=[];for(let a=0,l=e.channels.length;a<l;a++){const t=e.channels[a],l=e.samplers[t.sampler],c=t.target,u=void 0!==e.parameters?e.parameters[l.input]:l.input,h=void 0!==e.parameters?e.parameters[l.output]:l.output;n.push(this.getDependency("node",void 0!==c.node?c.node:c.id)),i.push(this.getDependency("accessor",u)),r.push(this.getDependency("accessor",h)),s.push(l),o.push(c)}return Promise.all([Promise.all(n),Promise.all(i),Promise.all(r),Promise.all(s),Promise.all(o)]).then(function(n){const i=n[0],r=n[1],s=n[2],o=n[3],a=n[4],l=[];for(let t=0,e=i.length;t<e;t++){const e=i[t],n=r[t],c=s[t],u=o[t],h=a[t];if(void 0===e)continue;let d;switch(e.updateMatrix(),e.matrixAutoUpdate=!0,Ovt[h.path]){case Ovt.weights:d=zgt;break;case Ovt.rotation:d=Hgt;break;case Ovt.position:case Ovt.scale:default:d=Ggt}const p=e.name?e.name:e.uuid,f=void 0!==u.interpolation?Pvt[u.interpolation]:2301,m=[];Ovt[h.path]===Ovt.weights?e.traverse(function(t){!0===t.isMesh&&t.morphTargetInfluences&&m.push(t.name?t.name:t.uuid)}):m.push(p);let g=c.array;if(c.normalized){const t=Wvt(g.constructor),e=new Float32Array(g.length);for(let n=0,i=g.length;n<i;n++)e[n]=g[n]*t;g=e}for(let t=0,i=m.length;t<i;t++){const e=new d(m[t]+"."+Ovt[h.path],n.array,g,f);"CUBICSPLINE"===u.interpolation&&(e.createInterpolant=function(t){return new kvt(this.times,this.values,this.getValueSize()/3,t)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),l.push(e)}}return new Wgt(e.name?e.name:"animation_"+t,void 0,l)})}createNodeMesh(t){const e=this,n=this.json.nodes[t];return void 0===n.mesh?null:e.getDependency("mesh",n.mesh).then(function(t){const i=e._getNodeRef(e.meshCache,n.mesh,t);return void 0!==n.weights&&i.traverse(function(t){if(t.isMesh)for(let e=0,i=n.weights.length;e<i;e++)t.morphTargetInfluences[e]=n.weights[e]}),i})}loadNode(t){const e=this.extensions,n=this,i=this.json.nodes[t],r=i.name?n.createUniqueName(i.name):"";return function(){const e=[],r=n._invokeOne(function(e){return e.createNodeMesh&&e.createNodeMesh(t)});return r&&e.push(r),void 0!==i.camera&&e.push(n.getDependency("camera",i.camera).then(function(t){return n._getNodeRef(n.cameraCache,i.camera,t)})),n._invokeAll(function(e){return e.createNodeAttachment&&e.createNodeAttachment(t)}).forEach(function(t){e.push(t)}),Promise.all(e)}().then(function(s){let o;if(o=!0===i.isBone?new rgt:s.length>1?new Umt:1===s.length?s[0]:new ddt,o!==s[0])for(let t=0,e=s.length;t<e;t++)o.add(s[t]);if(i.name&&(o.userData.name=i.name,o.name=r),Uvt(o,i),i.extensions&&zvt(e,o,i),void 0!==i.matrix){const t=new Uht;t.fromArray(i.matrix),o.applyMatrix4(t)}else void 0!==i.translation&&o.position.fromArray(i.translation),void 0!==i.rotation&&o.quaternion.fromArray(i.rotation),void 0!==i.scale&&o.scale.fromArray(i.scale);return n.associations.set(o,{type:"nodes",index:t}),o})}loadScene(t){const e=this.json,n=this.extensions,i=this.json.scenes[t],r=this,s=new Umt;i.name&&(s.name=r.createUniqueName(i.name)),Uvt(s,i),i.extensions&&zvt(n,s,i);const o=i.nodes||[],a=[];for(let l=0,c=o.length;l<c;l++)a.push(Qvt(o[l],s,e,r));return Promise.all(a).then(function(){return s})}}function Qvt(t,e,n,i){const r=n.nodes[t];return i.getDependency("node",t).then(function(t){if(void 0===r.skin)return t;let e;return i.getDependency("skin",r.skin).then(function(t){e=t;const n=[];for(let r=0,s=e.joints.length;r<s;r++)n.push(i.getDependency("node",e.joints[r]));return Promise.all(n)}).then(function(n){return t.traverse(function(t){if(!t.isMesh)return;const i=[],r=[];for(let s=0,o=n.length;s<o;s++){const t=n[s];if(t){i.push(t);const n=new Uht;void 0!==e.inverseBindMatrices&&n.fromArray(e.inverseBindMatrices.array,16*s),r.push(n)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',e.joints[s])}t.bind(new agt(i,r),t.matrixWorld)}),t})}).then(function(t){e.add(t);const s=[];if(r.children){const e=r.children;for(let r=0,o=e.length;r<o;r++)s.push(Qvt(e[r],t,n,i))}return Promise.all(s)})}function qvt(t,e,n){const i=e.attributes,r=[];function s(e,i){return n.getDependency("accessor",e).then(function(e){t.setAttribute(i,e)})}for(const o in i){const e=Bvt[o]||o.toLowerCase();e in t.attributes||r.push(s(i[o],e))}if(void 0!==e.indices&&!t.index){const i=n.getDependency("accessor",e.indices).then(function(e){t.setIndex(e)});r.push(i)}return Uvt(t,e),function(t,e,n){const i=e.attributes,r=new pht;if(void 0===i.POSITION)return;{const t=n.json.accessors[i.POSITION],e=t.min,s=t.max;if(void 0===e||void 0===s)return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");if(r.set(new uht(e[0],e[1],e[2]),new uht(s[0],s[1],s[2])),t.normalized){const e=Wvt(Rvt[t.componentType]);r.min.multiplyScalar(e),r.max.multiplyScalar(e)}}const s=e.targets;if(void 0!==s){const t=new uht,e=new uht;for(let i=0,r=s.length;i<r;i++){const r=s[i];if(void 0!==r.POSITION){const i=n.json.accessors[r.POSITION],s=i.min,o=i.max;if(void 0!==s&&void 0!==o){if(e.setX(Math.max(Math.abs(s[0]),Math.abs(o[0]))),e.setY(Math.max(Math.abs(s[1]),Math.abs(o[1]))),e.setZ(Math.max(Math.abs(s[2]),Math.abs(o[2]))),i.normalized){const t=Wvt(Rvt[i.componentType]);e.multiplyScalar(t)}t.max(e)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}r.expandByVector(t)}t.boundingBox=r;const o=new Nht;r.getCenter(o.center),o.radius=r.min.distanceTo(r.max)/2,t.boundingSphere=o}(t,e,n),Promise.all(r).then(function(){return void 0!==e.targets?function(t,e,n){let i=!1,r=!1;for(let a=0,l=e.length;a<l;a++){const t=e[a];if(void 0!==t.POSITION&&(i=!0),void 0!==t.NORMAL&&(r=!0),i&&r)break}if(!i&&!r)return Promise.resolve(t);const s=[],o=[];for(let a=0,l=e.length;a<l;a++){const l=e[a];if(i){const e=void 0!==l.POSITION?n.getDependency("accessor",l.POSITION):t.attributes.position;s.push(e)}if(r){const e=void 0!==l.NORMAL?n.getDependency("accessor",l.NORMAL):t.attributes.normal;o.push(e)}}return Promise.all([Promise.all(s),Promise.all(o)]).then(function(e){const n=e[1];return i&&(t.morphAttributes.position=e[0]),r&&(t.morphAttributes.normal=n),t.morphTargetsRelative=!0,t})}(t,e.targets,n):t})}function Xvt(t,e){let n=t.getIndex();if(null===n){const e=[],i=t.getAttribute("position");if(void 0===i)return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),t;for(let t=0;t<i.count;t++)e.push(t);t.setIndex(e),n=t.getIndex()}const i=n.count-2,r=[];if(2===e)for(let o=1;o<=i;o++)r.push(n.getX(0)),r.push(n.getX(o)),r.push(n.getX(o+1));else for(let o=0;o<i;o++)o%2==0?(r.push(n.getX(o)),r.push(n.getX(o+1)),r.push(n.getX(o+2))):(r.push(n.getX(o+2)),r.push(n.getX(o+1)),r.push(n.getX(o)));r.length/3!==i&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const s=t.clone();return s.setIndex(r),s}const Yvt=[171,75,84,88,32,50,48,187,13,10,26,10];var Kvt,Jvt,Zvt,tbt,ebt,nbt,ibt,rbt,sbt,obt;(sbt=Kvt||(Kvt={}))[sbt.NONE=0]="NONE",sbt[sbt.BASISLZ=1]="BASISLZ",sbt[sbt.ZSTD=2]="ZSTD",sbt[sbt.ZLIB=3]="ZLIB",(obt=Jvt||(Jvt={}))[obt.BASICFORMAT=0]="BASICFORMAT",function(t){t[t.UNSPECIFIED=0]="UNSPECIFIED",t[t.ETC1S=163]="ETC1S",t[t.UASTC=166]="UASTC"}(Zvt||(Zvt={})),function(t){t[t.UNSPECIFIED=0]="UNSPECIFIED",t[t.SRGB=1]="SRGB"}(tbt||(tbt={})),function(t){t[t.UNSPECIFIED=0]="UNSPECIFIED",t[t.LINEAR=1]="LINEAR",t[t.SRGB=2]="SRGB",t[t.ITU=3]="ITU",t[t.NTSC=4]="NTSC",t[t.SLOG=5]="SLOG",t[t.SLOG2=6]="SLOG2"}(ebt||(ebt={})),function(t){t[t.ALPHA_STRAIGHT=0]="ALPHA_STRAIGHT",t[t.ALPHA_PREMULTIPLIED=1]="ALPHA_PREMULTIPLIED"}(nbt||(nbt={})),function(t){t[t.RGB=0]="RGB",t[t.RRR=3]="RRR",t[t.GGG=4]="GGG",t[t.AAA=15]="AAA"}(ibt||(ibt={})),function(t){t[t.RGB=0]="RGB",t[t.RGBA=3]="RGBA",t[t.RRR=4]="RRR",t[t.RRRG=5]="RRRG"}(rbt||(rbt={}));class abt{constructor(){this.vkFormat=0,this.typeSize=1,this.pixelWidth=0,this.pixelHeight=0,this.pixelDepth=0,this.layerCount=0,this.faceCount=1,this.supercompressionScheme=Kvt.NONE,this.levels=[],this.dataFormatDescriptor=[{vendorId:0,descriptorType:Jvt.BASICFORMAT,versionNumber:2,descriptorBlockSize:40,colorModel:Zvt.UNSPECIFIED,colorPrimaries:tbt.SRGB,transferFunction:tbt.SRGB,flags:nbt.ALPHA_STRAIGHT,texelBlockDimension:{x:4,y:4,z:1,w:1},bytesPlane:[],samples:[]}],this.keyValue={},this.globalData=null}}class lbt{constructor(t,e,n,i){this._dataView=new DataView(t.buffer,t.byteOffset+e,n),this._littleEndian=i,this._offset=0}_nextUint8(){const t=this._dataView.getUint8(this._offset);return this._offset+=1,t}_nextUint16(){const t=this._dataView.getUint16(this._offset,this._littleEndian);return this._offset+=2,t}_nextUint32(){const t=this._dataView.getUint32(this._offset,this._littleEndian);return this._offset+=4,t}_nextUint64(){const t=this._dataView.getUint32(this._offset,this._littleEndian)+2**32*this._dataView.getUint32(this._offset+4,this._littleEndian);return this._offset+=8,t}_skip(t){return this._offset+=t,this}_scan(t,e=0){const n=this._offset;let i=0;for(;this._dataView.getUint8(this._offset)!==e&&i<t;)i++,this._offset++;return i<t&&this._offset++,new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+n,i)}}function cbt(t){return"undefined"!=typeof TextDecoder?(new TextDecoder).decode(t):Buffer.from(t).toString("utf8")}const ubt=new WeakMap;class hbt extends Xgt{constructor(t){super(t),this.transcoderPath="",this.transcoderBinary=null,this.transcoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.workerConfig=null}setTranscoderPath(t){return this.transcoderPath=t,this}setWorkerLimit(t){return this.workerLimit=t,this}detectSupport(t){return this.workerConfig={astcSupported:t.extensions.has("WEBGL_compressed_texture_astc"),etc1Supported:t.extensions.has("WEBGL_compressed_texture_etc1"),etc2Supported:t.extensions.has("WEBGL_compressed_texture_etc"),dxtSupported:t.extensions.has("WEBGL_compressed_texture_s3tc"),bptcSupported:t.extensions.has("EXT_texture_compression_bptc"),pvrtcSupported:t.extensions.has("WEBGL_compressed_texture_pvrtc")||t.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")},this}load(t,e,n,i){const r=new Kgt(this.manager);r.setResponseType("arraybuffer"),r.setWithCredentials(this.withCredentials);const s=new Cgt;return r.load(t,t=>{if(ubt.has(t))return ubt.get(t).promise.then(e).catch(i);this._createTexture([t]).then(function(t){s.copy(t),s.needsUpdate=!0,e&&e(s)}).catch(i)},n,i),s}parseInternalAsync(t){const{levels:e}=t,n=new Set;for(let i=0;i<e.length;i++)n.add(e[i].data.buffer);return this._createTexture(Array.from(n),{...t,lowLevel:!0})}_createTexture(t,e={}){let n,i;const r=e;let s=0;for(let a=0;a<t.length;a++)s+=t[a].byteLength;const o=this._allocateWorker(s).then(e=>(n=e,i=this.workerNextTaskID++,new Promise((e,s)=>{n._callbacks[i]={resolve:e,reject:s},n.postMessage({type:"transcode",id:i,buffers:t,taskConfig:r},t)}))).then(t=>{const{mipmaps:e,width:n,height:i,format:r}=t,s=new Cgt(e,n,i,r,1009);return s.minFilter=1===e.length?1006:1008,s.magFilter=1006,s.generateMipmaps=!1,s.needsUpdate=!0,s});return o.catch(()=>!0).then(()=>{n&&i&&(n._taskLoad-=s,delete n._callbacks[i])}),ubt.set(t[0],{promise:o}),o}_initTranscoder(){if(!this.transcoderPending){const t=new Kgt(this.manager);t.setPath(this.transcoderPath),t.setWithCredentials(this.withCredentials);const e=new Promise((e,n)=>{t.load("basis_transcoder.js",e,void 0,n)}),n=new Kgt(this.manager);n.setPath(this.transcoderPath),n.setResponseType("arraybuffer"),n.setWithCredentials(this.withCredentials);const i=new Promise((t,e)=>{n.load("basis_transcoder.wasm",t,void 0,e)});this.transcoderPending=Promise.all([e,i]).then(([t,e])=>{const n=hbt.BasisWorker.toString(),i=["/* constants */","let _EngineFormat = "+JSON.stringify(hbt.EngineFormat),"let _TranscoderFormat = "+JSON.stringify(hbt.TranscoderFormat),"let _BasisFormat = "+JSON.stringify(hbt.BasisFormat),"/* basis_transcoder.js */",t,"/* worker */",n.substring(n.indexOf("{")+1,n.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([i])),this.transcoderBinary=e})}return this.transcoderPending}_allocateWorker(t){return this._initTranscoder().then(()=>{if(this.workerPool.length<this.workerLimit){const t=new Worker(this.workerSourceURL);t._callbacks={},t._taskLoad=0,t.postMessage({type:"init",config:this.workerConfig,transcoderBinary:this.transcoderBinary}),t.onmessage=function(e){const n=e.data;switch(n.type){case"transcode":t._callbacks[n.id].resolve(n);break;case"error":t._callbacks[n.id].reject(n);break;default:console.error('THREE.BasisTextureLoader: Unexpected message, "'+n.type+'"')}},this.workerPool.push(t)}else this.workerPool.sort(function(t,e){return t._taskLoad>e._taskLoad?-1:1});const e=this.workerPool[this.workerPool.length-1];return e._taskLoad+=t,e})}dispose(){for(let t=0;t<this.workerPool.length;t++)this.workerPool[t].terminate();return this.workerPool.length=0,this}}let dbt,pbt,fbt;hbt.BasisFormat={ETC1S:0,UASTC_4x4:1},hbt.TranscoderFormat={ETC1:0,ETC2:1,BC1:2,BC3:3,BC4:4,BC5:5,BC7_M6_OPAQUE_ONLY:6,BC7_M5:7,PVRTC1_4_RGB:8,PVRTC1_4_RGBA:9,ASTC_4x4:10,ATC_RGB:11,ATC_RGBA_INTERPOLATED_ALPHA:12,RGBA32:13,RGB565:14,BGR565:15,RGBA4444:16},hbt.EngineFormat={RGBAFormat:1023,RGBA_ASTC_4x4_Format:37808,RGBA_BPTC_Format:36492,RGBA_ETC2_EAC_Format:37496,RGBA_PVRTC_4BPPV1_Format:35842,RGBA_S3TC_DXT5_Format:33779,RGB_ETC1_Format:36196,RGB_ETC2_Format:37492,RGB_PVRTC_4BPPV1_Format:35840,RGB_S3TC_DXT1_Format:33776},hbt.BasisWorker=function(){let t,e,n;const i=_EngineFormat,r=_TranscoderFormat,s=_BasisFormat;onmessage=function(i){const r=i.data;switch(r.type){case"init":t=r.config,o=r.transcoderBinary,e=new Promise(t=>{n={wasmBinary:o,onRuntimeInitialized:t},BASIS(n)}).then(()=>{n.initializeBasis()});break;case"transcode":e.then(()=>{try{const{width:t,height:e,hasAlpha:i,mipmaps:o,format:a}=r.taskConfig.lowLevel?function(t){const{basisFormat:e,width:i,height:r,hasAlpha:o}=t,{transcoderFormat:a,engineFormat:l}=c(e,i,r,o),f=n.getBytesPerBlockOrPixel(a);u(n.isFormatSupported(a),"THREE.BasisTextureLoader: Unsupported format.");const m=[];if(e===s.ETC1S){const e=new n.LowLevelETC1SImageTranscoder,{endpointCount:i,endpointsData:r,selectorCount:s,selectorsData:l,tablesData:c}=t.globalData;try{let n;n=e.decodePalettes(i,r,s,l),u(n,"THREE.BasisTextureLoader: decodePalettes() failed."),n=e.decodeTables(c),u(n,"THREE.BasisTextureLoader: decodeTables() failed.");for(let i=0;i<t.levels.length;i++){const r=t.levels[i],s=t.globalData.imageDescs[i],l=p(a,r.width,r.height),c=new Uint8Array(l);n=e.transcodeImage(a,c,l/f,r.data,h(a,r.width),d(a,r.height),r.width,r.height,r.index,s.rgbSliceByteOffset,s.rgbSliceByteLength,s.alphaSliceByteOffset,s.alphaSliceByteLength,s.imageFlags,o,!1,0,0),u(n,"THREE.BasisTextureLoader: transcodeImage() failed for level "+r.index+"."),m.push({data:c,width:r.width,height:r.height})}}finally{e.delete()}}else for(let s=0;s<t.levels.length;s++){const e=t.levels[s],i=p(a,e.width,e.height),r=new Uint8Array(i);u(n.transcodeUASTCImage(a,r,i/f,e.data,h(a,e.width),d(a,e.height),e.width,e.height,e.index,0,e.data.byteLength,0,o,!1,0,0,-1,-1),"THREE.BasisTextureLoader: transcodeUASTCImage() failed for level "+e.index+"."),m.push({data:r,width:e.width,height:e.height})}return{width:i,height:r,hasAlpha:o,mipmaps:m,format:l}}(r.taskConfig):function(t){const e=new n.BasisFile(new Uint8Array(t)),i=e.isUASTC()?s.UASTC_4x4:s.ETC1S,r=e.getImageWidth(0,0),o=e.getImageHeight(0,0),a=e.getNumLevels(0),l=e.getHasAlpha();function u(){e.close(),e.delete()}const{transcoderFormat:h,engineFormat:d}=c(i,r,o,l);if(!r||!o||!a)throw u(),new Error("THREE.BasisTextureLoader:\tInvalid texture");if(!e.startTranscoding())throw u(),new Error("THREE.BasisTextureLoader: .startTranscoding failed");const p=[];for(let n=0;n<a;n++){const t=e.getImageWidth(0,n),i=e.getImageHeight(0,n),r=new Uint8Array(e.getImageTranscodedSizeInBytes(0,n,h));if(!e.transcodeImage(r,0,n,h,0,l))throw u(),new Error("THREE.BasisTextureLoader: .transcodeImage failed.");p.push({data:r,width:t,height:i})}return u(),{width:r,height:o,hasAlpha:l,mipmaps:p,format:d}}(r.buffers[0]),l=[];for(let n=0;n<o.length;++n)l.push(o[n].data.buffer);self.postMessage({type:"transcode",id:r.id,width:t,height:e,hasAlpha:i,mipmaps:o,format:a},l)}catch(t){console.error(t),self.postMessage({type:"error",id:r.id,error:t.message})}})}var o};const o=[{if:"astcSupported",basisFormat:[s.UASTC_4x4],transcoderFormat:[r.ASTC_4x4,r.ASTC_4x4],engineFormat:[i.RGBA_ASTC_4x4_Format,i.RGBA_ASTC_4x4_Format],priorityETC1S:1/0,priorityUASTC:1,needsPowerOfTwo:!1},{if:"bptcSupported",basisFormat:[s.ETC1S,s.UASTC_4x4],transcoderFormat:[r.BC7_M5,r.BC7_M5],engineFormat:[i.RGBA_BPTC_Format,i.RGBA_BPTC_Format],priorityETC1S:3,priorityUASTC:2,needsPowerOfTwo:!1},{if:"dxtSupported",basisFormat:[s.ETC1S,s.UASTC_4x4],transcoderFormat:[r.BC1,r.BC3],engineFormat:[i.RGB_S3TC_DXT1_Format,i.RGBA_S3TC_DXT5_Format],priorityETC1S:4,priorityUASTC:5,needsPowerOfTwo:!1},{if:"etc2Supported",basisFormat:[s.ETC1S,s.UASTC_4x4],transcoderFormat:[r.ETC1,r.ETC2],engineFormat:[i.RGB_ETC2_Format,i.RGBA_ETC2_EAC_Format],priorityETC1S:1,priorityUASTC:3,needsPowerOfTwo:!1},{if:"etc1Supported",basisFormat:[s.ETC1S,s.UASTC_4x4],transcoderFormat:[r.ETC1,r.ETC1],engineFormat:[i.RGB_ETC1_Format,i.RGB_ETC1_Format],priorityETC1S:2,priorityUASTC:4,needsPowerOfTwo:!1},{if:"pvrtcSupported",basisFormat:[s.ETC1S,s.UASTC_4x4],transcoderFormat:[r.PVRTC1_4_RGB,r.PVRTC1_4_RGBA],engineFormat:[i.RGB_PVRTC_4BPPV1_Format,i.RGBA_PVRTC_4BPPV1_Format],priorityETC1S:5,priorityUASTC:6,needsPowerOfTwo:!0}],a=o.sort(function(t,e){return t.priorityETC1S-e.priorityETC1S}),l=o.sort(function(t,e){return t.priorityUASTC-e.priorityUASTC});function c(e,n,o,c){let u,h;const d=e===s.ETC1S?a:l;for(let i=0;i<d.length;i++){const r=d[i];if(t[r.if]&&r.basisFormat.includes(e)&&(!r.needsPowerOfTwo||f(n)&&f(o)))return u=r.transcoderFormat[c?1:0],h=r.engineFormat[c?1:0],{transcoderFormat:u,engineFormat:h}}return console.warn("THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32."),u=r.RGBA32,h=i.RGBAFormat,{transcoderFormat:u,engineFormat:h}}function u(t,e){if(!t)throw new Error(e)}function h(t,e){return Math.ceil(e/n.getFormatBlockWidth(t))}function d(t,e){return Math.ceil(e/n.getFormatBlockHeight(t))}function p(t,e,i){const s=n.getBytesPerBlockOrPixel(t);if(n.formatIsUncompressed(t))return e*i*s;if(t===r.PVRTC1_4_RGB||t===r.PVRTC1_4_RGBA){const t=i+3&-4;return(Math.max(8,e+3&-4)*Math.max(8,t)*4+7)/8}return h(t,e)*d(t,i)*s}function f(t){return t<=2||0==(t&t-1)&&0!==t}};const mbt={env:{emscripten_notify_memory_growth:function(t){fbt=new Uint8Array(pbt.exports.memory.buffer)}}};class gbt{init(){return dbt||(dbt=fetch("data:application/wasm;base64,"+ybt).then(t=>t.arrayBuffer()).then(t=>WebAssembly.instantiate(t,mbt)).then(t=>{pbt=t.instance,mbt.env.emscripten_notify_memory_growth(0)})),dbt}decode(t,e=0){const n=t.byteLength,i=pbt.exports.malloc(n);fbt.set(t,i),e=e||Number(pbt.exports.ZSTD_findDecompressedSize(i,n));const r=pbt.exports.malloc(e),s=pbt.exports.ZSTD_decompress(r,e,i,n),o=fbt.slice(r,r+s);return pbt.exports.free(i),pbt.exports.free(r),o}}const ybt="AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ";var vbt,bbt,Abt={createLevels:async function(t,e){t.supercompressionScheme===Kvt.ZSTD&&await e.init();for(var n=[],i=t.pixelWidth,r=t.pixelHeight,s=0;s<t.levels.length;s++){var o=Math.max(1,Math.floor(i/Math.pow(2,s))),a=Math.max(1,Math.floor(r/Math.pow(2,s))),l=t.levels[s].levelData;t.supercompressionScheme===Kvt.ZSTD&&(l=e.decode(l,t.levels[s].uncompressedByteLength)),n.push({index:s,width:o,height:a,data:l})}return n},getBasicDFD:function(t){return t.dataFormatDescriptor[0]},getAlpha:function(t){var e=this.getBasicDFD(t);return e.colorModel===Zvt.UASTC?(15&e.samples[0].channelID)===rbt.RGBA:2===e.samples.length&&(15&e.samples[1].channelID)===ibt.AAA},getPremultiplyAlpha:function(t){return!!(this.getBasicDFD(t).flags&nbt.ALPHA_PREMULTIPLIED)}};const xbt=Symbol("retainerCount"),wbt=Symbol("recentlyUsed"),_bt=Symbol("evict"),Sbt=Symbol("evictionThreshold"),Ebt=Symbol("cache");class Cbt{constructor(t,e=5){this[vbt]=new Map,this[bbt]=[],this[Ebt]=t,this[Sbt]=e}set evictionThreshold(t){this[Sbt]=t,this[_bt]()}get evictionThreshold(){return this[Sbt]}get cache(){return this[Ebt]}retainerCount(t){return this[xbt].get(t)||0}reset(){this[xbt].clear(),this[wbt]=[]}retain(t){this[xbt].has(t)||this[xbt].set(t,0),this[xbt].set(t,this[xbt].get(t)+1);const e=this[wbt].indexOf(t);-1!==e&&this[wbt].splice(e,1),this[wbt].unshift(t),this[_bt]()}release(t){this[xbt].has(t)&&this[xbt].set(t,Math.max(this[xbt].get(t)-1,0)),this[_bt]()}[(vbt=xbt,bbt=wbt,_bt)](){if(!(this[wbt].length<this[Sbt]))for(let t=this[wbt].length-1;t>=this[Sbt];--t){const e=this[wbt][t];0===this[xbt].get(e)&&(this[Ebt].delete(e),this[wbt].splice(t,1))}}}var Ibt,Tbt;const Mbt=new Map,kbt=new Map;let Rbt;const Nbt=new class extends Xgt{constructor(t){super(t),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(t){return this.decoderPath=t,this}setDecoderConfig(t){return this.decoderConfig=t,this}setWorkerLimit(t){return this.workerLimit=t,this}load(t,e,n,i){const r=new Kgt(this.manager);r.setPath(this.path),r.setResponseType("arraybuffer"),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(t,t=>{this.decodeGeometry(t,{attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1}).then(e).catch(i)},n,i)}decodeDracoFile(t,e,n,i){this.decodeGeometry(t,{attributeIDs:n||this.defaultAttributeIDs,attributeTypes:i||this.defaultAttributeTypes,useUniqueIDs:!!n}).then(e)}decodeGeometry(t,e){for(const o in e.attributeTypes){const t=e.attributeTypes[o];void 0!==t.BYTES_PER_ELEMENT&&(e.attributeTypes[o]=t.name)}const n=JSON.stringify(e);if(hvt.has(t)){const e=hvt.get(t);if(e.key===n)return e.promise;if(0===t.byteLength)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let i;const r=this.workerNextTaskID++,s=this._getWorker(r,t.byteLength).then(n=>(i=n,new Promise((n,s)=>{i._callbacks[r]={resolve:n,reject:s},i.postMessage({type:"decode",id:r,taskConfig:e,buffer:t},[t])}))).then(t=>this._createGeometry(t.geometry));return s.catch(()=>!0).then(()=>{i&&r&&this._releaseTask(i,r)}),hvt.set(t,{key:n,promise:s}),s}_createGeometry(t){const e=new Jdt;t.index&&e.setIndex(new zdt(t.index.array,1));for(let n=0;n<t.attributes.length;n++){const i=t.attributes[n];e.setAttribute(i.name,new zdt(i.array,i.itemSize))}return e}_loadLibrary(t,e){const n=new Kgt(this.manager);return n.setPath(this.decoderPath),n.setResponseType(e),n.setWithCredentials(this.withCredentials),new Promise((e,i)=>{n.load(t,e,void 0,i)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const t="object"!=typeof WebAssembly||"js"===this.decoderConfig.type,e=[];return t?e.push(this._loadLibrary("draco_decoder.js","text")):(e.push(this._loadLibrary("draco_wasm_wrapper.js","text")),e.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(e).then(e=>{const n=e[0];t||(this.decoderConfig.wasmBinary=e[1]);const i=dvt.toString(),r=["/* draco decoder */",n,"","/* worker */",i.substring(i.indexOf("{")+1,i.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([r]))}),this.decoderPending}_getWorker(t,e){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const t=new Worker(this.workerSourceURL);t._callbacks={},t._taskCosts={},t._taskLoad=0,t.postMessage({type:"init",decoderConfig:this.decoderConfig}),t.onmessage=function(e){const n=e.data;switch(n.type){case"decode":t._callbacks[n.id].resolve(n);break;case"error":t._callbacks[n.id].reject(n);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+n.type+'"')}},this.workerPool.push(t)}else this.workerPool.sort(function(t,e){return t._taskLoad>e._taskLoad?-1:1});const n=this.workerPool[this.workerPool.length-1];return n._taskCosts[t]=e,n._taskLoad+=e,n})}_releaseTask(t,e){t._taskLoad-=t._taskCosts[e],delete t._callbacks[e],delete t._taskCosts[e]}debug(){console.log("Task load: ",this.workerPool.map(t=>t._taskLoad))}dispose(){for(let t=0;t<this.workerPool.length;++t)this.workerPool[t].terminate();return this.workerPool.length=0,this}};let Lbt;const Dbt=new class extends Jgt{constructor(t){super(t),this.basisLoader=new hbt(t),this.zstd=new gbt,this.zstd.init(),"undefined"!=typeof MSC_TRANSCODER&&console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.')}setTranscoderPath(t){return this.basisLoader.setTranscoderPath(t),this}setWorkerLimit(t){return this.basisLoader.setWorkerLimit(t),this}detectSupport(t){return this.basisLoader.detectSupport(t),this}dispose(){return this.basisLoader.dispose(),this}load(t,e,n,i){var r=this,s=new Cgt;return new Promise(function(e,i){new Kgt(r.manager).setPath(r.path).setResponseType("arraybuffer").load(t,e,n,i)}).then(function(t){r.parse(t,function(t){s.copy(t),s.needsUpdate=!0,e&&e(s)},i)}).catch(i),s}parse(t,e,n){var i=this,r=function(t){const e=new Uint8Array(t.buffer,t.byteOffset,Yvt.length);if(e[0]!==Yvt[0]||e[1]!==Yvt[1]||e[2]!==Yvt[2]||e[3]!==Yvt[3]||e[4]!==Yvt[4]||e[5]!==Yvt[5]||e[6]!==Yvt[6]||e[7]!==Yvt[7]||e[8]!==Yvt[8]||e[9]!==Yvt[9]||e[10]!==Yvt[10]||e[11]!==Yvt[11])throw new Error("Missing KTX 2.0 identifier.");const n=new abt,i=17*Uint32Array.BYTES_PER_ELEMENT,r=new lbt(t,Yvt.length,i,!0);n.vkFormat=r._nextUint32(),n.typeSize=r._nextUint32(),n.pixelWidth=r._nextUint32(),n.pixelHeight=r._nextUint32(),n.pixelDepth=r._nextUint32(),n.layerCount=r._nextUint32(),n.faceCount=r._nextUint32();const s=r._nextUint32();n.supercompressionScheme=r._nextUint32();const o=r._nextUint32(),a=r._nextUint32(),l=r._nextUint32(),c=r._nextUint32(),u=r._nextUint64(),h=r._nextUint64(),d=new lbt(t,Yvt.length+i,3*s*8,!0);for(let L=0;L<s;L++)n.levels.push({levelData:new Uint8Array(t.buffer,t.byteOffset+d._nextUint64(),d._nextUint64()),uncompressedByteLength:d._nextUint64()});const p=new lbt(t,o,a,!0),f={vendorId:p._skip(4)._nextUint16(),descriptorType:p._nextUint16(),versionNumber:p._nextUint16(),descriptorBlockSize:p._nextUint16(),colorModel:p._nextUint8(),colorPrimaries:p._nextUint8(),transferFunction:p._nextUint8(),flags:p._nextUint8(),texelBlockDimension:{x:p._nextUint8()+1,y:p._nextUint8()+1,z:p._nextUint8()+1,w:p._nextUint8()+1},bytesPlane:[p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8()],samples:[]},m=(f.descriptorBlockSize/4-6)/4;for(let L=0;L<m;L++)f.samples[L]={bitOffset:p._nextUint16(),bitLength:p._nextUint8(),channelID:p._nextUint8(),samplePosition:[p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8()],sampleLower:p._nextUint32(),sampleUpper:p._nextUint32()};n.dataFormatDescriptor.length=0,n.dataFormatDescriptor.push(f);const g=new lbt(t,l,c,!0);for(;g._offset<c;){const t=g._nextUint32(),e=g._scan(t),i=cbt(e),r=g._scan(t-e.byteLength);n.keyValue[i]=i.match(/^ktx/i)?cbt(r):r,g._offset%4&&g._skip(4-g._offset%4)}if(h<=0)return n;const y=new lbt(t,u,h,!0),v=y._nextUint16(),b=y._nextUint16(),A=y._nextUint32(),x=y._nextUint32(),w=y._nextUint32(),_=y._nextUint32(),S=[];for(let L=0;L<s;L++)S.push({imageFlags:y._nextUint32(),rgbSliceByteOffset:y._nextUint32(),rgbSliceByteLength:y._nextUint32(),alphaSliceByteOffset:y._nextUint32(),alphaSliceByteLength:y._nextUint32()});const E=u+y._offset,C=E+A,I=C+x,T=I+w,M=new Uint8Array(t.buffer,t.byteOffset+E,A),k=new Uint8Array(t.buffer,t.byteOffset+C,x),R=new Uint8Array(t.buffer,t.byteOffset+I,w),N=new Uint8Array(t.buffer,t.byteOffset+T,_);return n.globalData={endpointCount:v,selectorCount:b,imageDescs:S,endpointsData:M,selectorsData:k,tablesData:R,extendedData:N},n}(new Uint8Array(t));if(r.pixelDepth>0)throw new Error("THREE.KTX2Loader: Only 2D textures are currently supported.");if(r.layerCount>1)throw new Error("THREE.KTX2Loader: Array textures are not currently supported.");if(r.faceCount>1)throw new Error("THREE.KTX2Loader: Cube textures are not currently supported.");var s=Abt.getBasicDFD(r);return Abt.createLevels(r,this.zstd).then(function(t){var e=s.colorModel===Zvt.UASTC?hbt.BasisFormat.UASTC_4x4:hbt.BasisFormat.ETC1S,n={levels:t,width:r.pixelWidth,height:r.pixelHeight,basisFormat:e,hasAlpha:Abt.getAlpha(r)};return e===hbt.BasisFormat.ETC1S&&(n.globalData=r.globalData),i.basisLoader.parseInternalAsync(n)}).then(function(t){t.encoding=s.transferFunction===ebt.SRGB?3001:3e3,t.premultiplyAlpha=Abt.getPremultiplyAlpha(r),e(t)}).catch(n),this}},Bbt=Symbol("loader"),Obt=Symbol("evictionPolicy"),Pbt=Symbol("GLTFInstance");class Fbt extends Uut{constructor(t){super(),this[Tbt]=new pvt,this[Pbt]=t,this[Bbt].setDRACOLoader(Nbt),this[Bbt].setKTX2Loader(Dbt)}static setDRACODecoderLocation(t){Rbt=t,Nbt.setDecoderPath(t)}static getDRACODecoderLocation(){return Rbt}static setKTX2TranscoderLocation(t){Lbt=t,Dbt.setTranscoderPath(t)}static getKTX2TranscoderLocation(){return Lbt}static initializeKTX2Loader(t){Dbt.detectSupport(t)}static get cache(){return Mbt}static clearCache(){Mbt.forEach((t,e)=>{this.delete(e)}),this[Obt].reset()}static has(t){return Mbt.has(t)}static async delete(t){if(!this.has(t))return;const e=Mbt.get(t);kbt.delete(t),Mbt.delete(t),(await e).dispose()}static hasFinishedLoading(t){return!!kbt.get(t)}get[(Ibt=Obt,Tbt=Bbt,Obt)](){return this.constructor[Obt]}async preload(t,e,n=(()=>{})){if(this.dispatchEvent({type:"preload",element:e,src:t}),!Mbt.has(t)){const e=((t,e,n=(()=>{}))=>{const i=t=>{const e=t.loaded/t.total;n(Math.max(0,Math.min(1,isFinite(e)?e:1)))};return new Promise((n,r)=>{e.load(t,n,i,r)})})(t,this[Bbt],t=>{n(.8*t)}),i=this[Pbt],r=e.then(t=>i.prepare(t)).then(t=>(n(.9),new i(t)));Mbt.set(t,r)}await Mbt.get(t),kbt.set(t,!0),n&&n(1)}async load(t,e,n=(()=>{})){await this.preload(t,e,n);const i=await Mbt.get(t),r=await i.clone();return this[Obt].retain(t),r.dispose=(()=>{const e=r.dispose;let n=!1;return()=>{n||(n=!0,e.apply(r),this[Obt].release(t))}})(),r}}Fbt[Ibt]=new Cbt(Fbt);class $bt extends ddt{constructor(t){super(),this.element=t||document.createElement("div"),this.element.style.position="absolute",this.addEventListener("removed",function(){this.traverse(function(t){t.element instanceof Element&&null!==t.element.parentNode&&t.element.parentNode.removeChild(t.element)})})}copy(t,e){return super.copy(t,e),this.element=t.element.cloneNode(!0),this}}$bt.prototype.isCSS2DObject=!0;const zbt=new uht,Ubt=new Uht,Hbt=new Uht,Vbt=new uht,Gbt=new uht;class Wbt{constructor(){const t=this;let e,n,i,r;const s={objects:new WeakMap},o=document.createElement("div");function a(e,n,c){if(e.isCSS2DObject){e.onBeforeRender(t,n,c),zbt.setFromMatrixPosition(e.matrixWorld),zbt.applyMatrix4(Hbt);const a=e.element;a.style.transform=/apple/i.test(navigator.vendor)?"translate(-50%,-50%) translate("+Math.round(zbt.x*i+i)+"px,"+Math.round(-zbt.y*r+r)+"px)":"translate(-50%,-50%) translate("+(zbt.x*i+i)+"px,"+(-zbt.y*r+r)+"px)",a.style.display=e.visible&&zbt.z>=-1&&zbt.z<=1?"":"none";const u={distanceToCameraSquared:l(c,e)};s.objects.set(e,u),a.parentNode!==o&&o.appendChild(a),e.onAfterRender(t,n,c)}for(let t=0,i=e.children.length;t<i;t++)a(e.children[t],n,c)}function l(t,e){return Vbt.setFromMatrixPosition(t.matrixWorld),Gbt.setFromMatrixPosition(e.matrixWorld),Vbt.distanceToSquared(Gbt)}o.style.overflow="hidden",this.domElement=o,this.getSize=function(){return{width:e,height:n}},this.render=function(t,e){!0===t.autoUpdate&&t.updateMatrixWorld(),null===e.parent&&e.updateMatrixWorld(),Ubt.copy(e.matrixWorldInverse),Hbt.multiplyMatrices(e.projectionMatrix,Ubt),a(t,t,e),function(t){const e=function(t){const e=[];return t.traverse(function(t){t.isCSS2DObject&&e.push(t)}),e}(t).sort(function(t,e){return s.objects.get(t).distanceToCameraSquared-s.objects.get(e).distanceToCameraSquared}),n=e.length;for(let i=0,r=e.length;i<r;i++)e[i].element.style.zIndex=n-i}(t)},this.setSize=function(t,s){e=t,n=s,i=e/2,r=n/2,o.style.width=t+"px",o.style.height=s+"px"}}}const jbt=t=>t&&"null"!==t?qbt(t):null,Qbt=()=>{if(Lut)return;const t=[];throw Mut||t.push("WebXR Device API"),kut||t.push("WebXR Hit Test API"),new Error(`The following APIs are required for AR, but are missing in this browser: ${t.join(", ")}`)},qbt=t=>new URL(t,window.location.toString()).toString(),Xbt=(t,e)=>{let n=null;return(...i)=>{null!=n&&self.clearTimeout(n),n=self.setTimeout(()=>{n=null,t(...i)},e)}},Ybt=(t,e,n)=>Math.max(e,Math.min(n,t)),Kbt=(()=>{const t=(()=>{const t=null!=document.head?Array.from(document.head.querySelectorAll("meta")):[];for(const e of t)if("viewport"===e.name)return!0;return!1})();return t||console.warn('No <meta name="viewport"> detected; <model-viewer> will cap pixel density at 1.'),()=>t?window.devicePixelRatio:1})(),Jbt=(()=>{const t=new RegExp("[?&]model-viewer-debug-mode(&|$)");return()=>self.ModelViewerElement&&self.ModelViewerElement.debugMode||self.location&&self.location.search&&self.location.search.match(t)})();class Zbt{constructor(t=50){this.velocity=0,this.naturalFrequency=0,this.setDecayTime(t)}setDecayTime(t){this.naturalFrequency=1/Math.max(.001,t)}update(t,e,n,i){const r=2e-4*this.naturalFrequency;if(null==t||0===i)return e;if(t===e&&0===this.velocity)return e;if(n<0)return t;const s=t-e,o=this.velocity+this.naturalFrequency*s,a=s+n*o,l=Math.exp(-this.naturalFrequency*n),c=(o-this.naturalFrequency*a)*l,u=-this.naturalFrequency*(c+o*l);return Math.abs(c)<r*Math.abs(i)&&u*s>=0?(this.velocity=0,e):(this.velocity=c,e+a*l)}}const tAt=(t,e)=>({type:"number",number:t,unit:e}),eAt=(()=>{const t={};return e=>{const n=e;if(n in t)return t[n];const i=[];let r=0;for(;e;){if(++r>1e3){e="";break}const t=nAt(e),n=t.nodes[0];if(null==n||0===n.terms.length)break;i.push(n),e=t.remainingInput}return t[n]=i}})(),nAt=(()=>{const t=/^(\-\-|[a-z\u0240-\uffff])/i,e=/^([\*\+\/]|[\-]\s)/i,n=/^[\),]/;return i=>{const r=[];for(;i.length&&(i=i.trim(),!n.test(i));)if("("===i[0]){const{nodes:t,remainingInput:e}=oAt(i);i=e,r.push({type:"function",name:{type:"ident",value:"calc"},arguments:t})}else if(t.test(i)){const t=iAt(i),e=t.nodes[0];if("("===(i=t.remainingInput)[0]){const{nodes:t,remainingInput:n}=oAt(i);r.push({type:"function",name:e,arguments:t}),i=n}else r.push(e)}else if(e.test(i))r.push({type:"operator",value:i[0]}),i=i.slice(1);else{const{nodes:t,remainingInput:e}="#"===i[0]?sAt(i):rAt(i);if(0===t.length)break;r.push(t[0]),i=e}return{nodes:[{type:"expression",terms:r}],remainingInput:i}}})(),iAt=(()=>{const t=/[^a-z^0-9^_^\-^\u0240-\uffff]/i;return e=>{const n=e.match(t);return{nodes:[{type:"ident",value:null==n?e:e.substr(0,n.index)}],remainingInput:null==n?"":e.substr(n.index)}}})(),rAt=(()=>{const t=/[\+\-]?(\d+[\.]\d+|\d+|[\.]\d+)([eE][\+\-]?\d+)?/,e=/^[a-z%]+/i,n=/^(m|mm|cm|rad|deg|[%])$/;return i=>{const r=i.match(t),s=null==r?"0":r[0],o=(i=null==s?i:i.slice(s.length)).match(e);let a=null!=o&&""!==o[0]?o[0]:null;const l=null==o?i:i.slice(a.length);return null==a||n.test(a)||(a=null),{nodes:[{type:"number",number:parseFloat(s)||0,unit:a}],remainingInput:l}}})(),sAt=(()=>{const t=/^[a-f0-9]*/i;return e=>{const n=(e=e.slice(1).trim()).match(t);return{nodes:null==n?[]:[{type:"hex",value:n[0]}],remainingInput:null==n?e:e.slice(n[0].length)}}})(),oAt=t=>{const e=[];for(t=t.slice(1).trim();t.length;){const n=nAt(t);if(e.push(n.nodes[0]),","===(t=n.remainingInput.trim())[0])t=t.slice(1).trim();else if(")"===t[0]){t=t.slice(1);break}}return{nodes:e,remainingInput:t}},aAt=Symbol("visitedTypes");class lAt{constructor(t){this[aAt]=t}walk(t,e){const n=t.slice();for(;n.length;){const t=n.shift();switch(this[aAt].indexOf(t.type)>-1&&e(t),t.type){case"expression":n.unshift(...t.terms);break;case"function":n.unshift(t.name,...t.arguments)}}}}const cAt=Object.freeze({type:"number",number:0,unit:null}),uAt=(t,e=0)=>{let{number:n,unit:i}=t;if(isFinite(n)){if("rad"===t.unit||null==t.unit)return t}else n=e,i="rad";return{type:"number",number:("deg"===i&&null!=n?n:0)*Math.PI/180,unit:"rad"}},hAt=(t,e=0)=>{let n,{number:i,unit:r}=t;if(isFinite(i)){if("m"===t.unit)return t}else i=e,r="m";switch(r){default:n=1;break;case"cm":n=.01;break;case"mm":n=.001}return{type:"number",number:n*i,unit:"m"}},dAt=(()=>{const t=t=>t,e={rad:t,deg:uAt,m:t,mm:hAt,cm:hAt};return(t,n=cAt)=>{let{number:i,unit:r}=t;if(isFinite(i)||(i=n.number,r=n.unit),null==r)return t;const s=e[r];return null==s?n:s(t)}})();class pAt extends $bt{constructor(t){super(document.createElement("div")),this.normal=new uht(0,1,0),this.initialized=!1,this.referenceCount=1,this.pivot=document.createElement("div"),this.slot=document.createElement("slot"),this.element.classList.add("annotation-wrapper"),this.slot.name=t.name,this.element.appendChild(this.pivot),this.pivot.appendChild(this.slot),this.updatePosition(t.position),this.updateNormal(t.normal)}get facingCamera(){return!this.element.classList.contains("hide")}show(){this.facingCamera&&this.initialized||this.updateVisibility(!0)}hide(){!this.facingCamera&&this.initialized||this.updateVisibility(!1)}increment(){this.referenceCount++}decrement(){return this.referenceCount>0&&--this.referenceCount,0===this.referenceCount}updatePosition(t){if(null==t)return;const e=eAt(t)[0].terms;for(let n=0;n<3;++n)this.position.setComponent(n,dAt(e[n]).number);this.updateMatrixWorld()}updateNormal(t){if(null==t)return;const e=eAt(t)[0].terms;for(let n=0;n<3;++n)this.normal.setComponent(n,dAt(e[n]).number)}orient(t){this.pivot.style.transform=`rotate(${t}rad)`}updateVisibility(t){t?this.element.classList.remove("hide"):this.element.classList.add("hide"),this.slot.assignedNodes().forEach(e=>{if(e.nodeType!==Node.ELEMENT_NODE)return;const n=e,i=n.dataset.visibilityAttribute;if(null!=i){const e=`data-${i}`;t?n.setAttribute(e,""):n.removeAttribute(e)}n.dispatchEvent(new CustomEvent("hotspot-visibility",{detail:{visible:t}}))}),this.initialized=!0}}const fAt=(t,e,n)=>{let i=n;const r=new uht;return t.traverse(t=>{let n,s;t.updateWorldMatrix(!1,!1);const o=t.geometry;if(void 0!==o)if(o.isGeometry){const a=o.vertices;for(n=0,s=a.length;n<s;n++)r.copy(a[n]),r.applyMatrix4(t.matrixWorld),i=e(i,r)}else if(o.isBufferGeometry){const{position:a}=o.attributes;if(void 0!==a)for(n=0,s=a.count;n<s;n++)r.fromBufferAttribute(a,n).applyMatrix4(t.matrixWorld),i=e(i,r)}}),i};class mAt extends yyt{constructor(t,e,n){super(),this.shadowMaterial=new Tgt,this.boundingBox=new pht,this.size=new uht,this.shadowScale=1,this.isAnimated=!1,this.side="bottom",this.needsUpdate=!1,this.intensity=0,this.castShadow=!0,this.frustumCulled=!1,this.floor=new gpt(new Dpt,this.shadowMaterial),this.floor.rotateX(-Math.PI/2),this.floor.receiveShadow=!0,this.floor.castShadow=!1,this.floor.frustumCulled=!1,this.add(this.floor),t.target.add(this),this.target=t.target,this.setScene(t,e,n)}setScene(t,e,n){if(this.side=n,this.isAnimated=t.animationNames.length>0,this.boundingBox.copy(t.boundingBox),this.size.copy(t.size),"back"===this.side){const{min:t,max:e}=this.boundingBox;[t.y,t.z]=[t.z,t.y],[e.y,e.z]=[e.z,e.y],[this.size.y,this.size.z]=[this.size.z,this.size.y],this.rotation.x=Math.PI/2,this.rotation.y=Math.PI}const{boundingBox:i,size:r}=this;if(this.isAnimated){const t=2*Math.max(r.x,r.y,r.z);r.y=t,i.expandByVector(r.subScalar(t).multiplyScalar(-.5)),i.max.y=i.min.y+t,r.set(t,t,t)}i.getCenter(this.floor.position);const s=i.max.y+.002*r.y;"bottom"===n?(this.position.y=s,this.shadow.camera.up.set(0,0,1)):(this.position.y=0,this.position.z=s,this.shadow.camera.up.set(0,1,0)),this.setSoftness(e)}setSoftness(t){const e=Math.pow(2,9-3*t);this.setMapSize(e)}setMapSize(t){const{camera:e,mapSize:n,map:i}=this.shadow,{size:r,boundingBox:s}=this;null!=i&&(i.dispose(),this.shadow.map=null),this.isAnimated&&(t*=2);const o=Math.floor(r.x>r.z?t:t*r.x/r.z),a=Math.floor(r.x>r.z?t*r.z/r.x:t);n.set(o,a);const l=2.5*r.x/o,c=2.5*r.z/a;e.left=-s.max.x-l,e.right=-s.min.x+l,e.bottom=s.min.z-c,e.top=s.max.z+c,this.setScaleAndOffset(this.shadowScale,0),this.floor.scale.set(r.x+2*l,r.z+2*c,1),this.needsUpdate=!0}setIntensity(t){this.shadowMaterial.opacity=t,t>0?(this.visible=!0,this.floor.visible=!0):(this.visible=!1,this.floor.visible=!1)}getIntensity(){return this.shadowMaterial.opacity}setRotation(t){"bottom"===this.side?(this.shadow.camera.up.set(Math.sin(t),0,Math.cos(t)),this.shadow.updateMatrices(this)):this.shadow.updateMatrices(this)}setScaleAndOffset(t,e){const n=this.size.y,{camera:i}=this.shadow;this.shadowScale=t,i.near=0,i.far=n-e/t,i.updateProjectionMatrix(),i.scale.setScalar(t),this.floor.position.y=.002*n*2-i.far}}const gAt=22.5*Math.PI/180,yAt=Math.sin(gAt),vAt=Math.tan(gAt),bAt=new uht,AAt=new uht,xAt=new uht,wAt=new class{constructor(t,e,n=0,i=1/0){this.ray=new zht(t,e),this.near=n,this.far=i,this.camera=null,this.layers=new Jht,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,e){this.ray.set(t,e)}setFromCamera(t,e){e&&e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e&&e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}intersectObject(t,e=!1,n=[]){return Lyt(t,this,n,e),n.sort(Nyt),n}intersectObjects(t,e=!1,n=[]){for(let i=0,r=t.length;i<r;i++)Lyt(t[i],this,n,e);return n.sort(Nyt),n}},_At=new uht;class SAt extends qmt{constructor({canvas:t,element:e,width:n,height:i}){super(),this.context=null,this.annotationRenderer=new Wbt,this.width=1,this.height=1,this.aspect=1,this.isDirty=!1,this.renderCount=0,this.externalRenderer=null,this.camera=new Spt(45,1,.1,100),this.url=null,this.target=new ddt,this.modelContainer=new ddt,this.animationNames=[],this.boundingBox=new pht,this.size=new uht,this.idealCameraDistance=0,this.fieldOfViewAspect=0,this.framedFieldOfView=45,this.shadow=null,this.shadowIntensity=0,this.shadowSoftness=1,this.exposure=1,this.canScale=!0,this.tightBounds=!1,this.goalTarget=new uht,this.targetDamperX=new Zbt,this.targetDamperY=new Zbt,this.targetDamperZ=new Zbt,this._currentGLTF=null,this.cancelPendingSourceChange=null,this.animationsByName=new Map,this.currentAnimationAction=null,this.name="ModelScene",this.element=e,this.canvas=t,this.camera=new Spt(45,1,.1,100),this.camera.name="MainCamera",this.add(this.target),this.setSize(n,i),this.target.name="Target",this.modelContainer.name="ModelContainer",this.target.add(this.modelContainer),this.mixer=new Ryt(this.modelContainer);const{domElement:r}=this.annotationRenderer,{style:s}=r;s.display="none",s.pointerEvents="none",s.position="absolute",s.top="0",this.element.shadowRoot.querySelector(".default").appendChild(r)}createContext(){this.context=this.canvas.getContext("2d")}async setObject(t){this.reset(),this.modelContainer.add(t),await this.setupScene()}async setSource(t,e=(()=>{})){if(!t||t===this.url)return void e(1);if(this.reset(),this.url=t,null!=this.externalRenderer){const t=await this.externalRenderer.load(e);return this.idealCameraDistance=t.framedRadius/yAt,this.fieldOfViewAspect=t.fieldOfViewAspect,this.frameModel(),void this.dispatchEvent({type:"model-load",url:this.url})}let n;null!=this.cancelPendingSourceChange&&(this.cancelPendingSourceChange(),this.cancelPendingSourceChange=null);try{n=await new Promise(async(n,i)=>{this.cancelPendingSourceChange=()=>i();try{n(await this.element[rwt].loader.load(t,this.element,e))}catch(t){i(t)}})}catch(t){if(null==t)return;throw t}this.reset(),this.url=t,this._currentGLTF=n,null!=n&&this.modelContainer.add(n.scene);const{animations:i}=n,r=new Map,s=[];for(const o of i)r.set(o.name,o),s.push(o.name);this.animations=i,this.animationsByName=r,this.animationNames=s,await this.setupScene()}async setupScene(){this.updateBoundingBox();let t=null;!0===this.tightBounds&&(await this.element.requestUpdate("cameraTarget"),t=this.getTarget()),this.updateFraming(t),this.frameModel(),this.setShadowIntensity(this.shadowIntensity),this.dispatchEvent({type:"model-load",url:this.url})}reset(){this.url=null,this.isDirty=!0,null!=this.shadow&&this.shadow.setIntensity(0);const t=this._currentGLTF;if(null!=t){for(const t of this.modelContainer.children)this.modelContainer.remove(t);t.dispose(),this._currentGLTF=null}null!=this.currentAnimationAction&&(this.currentAnimationAction.stop(),this.currentAnimationAction=null),this.mixer.stopAllAction(),this.mixer.uncacheRoot(this)}get currentGLTF(){return this._currentGLTF}setSize(t,e){if(this.width!==t||this.height!==e){if(this.width=Math.max(t,1),this.height=Math.max(e,1),this.annotationRenderer.setSize(t,e),this.aspect=this.width/this.height,this.frameModel(),null!=this.externalRenderer){const n=Kbt();this.externalRenderer.resize(t*n,e*n)}this.isDirty=!0}}updateBoundingBox(){this.target.remove(this.modelContainer),!0===this.tightBounds?this.boundingBox=fAt(this.modelContainer,(t,e)=>t.expandByPoint(e),new pht):this.boundingBox.setFromObject(this.modelContainer),this.boundingBox.getSize(this.size),this.target.add(this.modelContainer)}updateFraming(t=null){this.target.remove(this.modelContainer),null==t&&(t=this.boundingBox.getCenter(new uht));const e=Math.sqrt(fAt(this.modelContainer,(e,n)=>Math.max(e,t.distanceToSquared(n)),0));this.idealCameraDistance=e/yAt,this.fieldOfViewAspect=fAt(this.modelContainer,(e,n)=>{n.sub(t);const i=Math.sqrt(n.x*n.x+n.z*n.z);return Math.max(e,i/(this.idealCameraDistance-Math.abs(n.y)))},0)/vAt,this.target.add(this.modelContainer)}frameModel(){const t=vAt*Math.max(1,this.fieldOfViewAspect/this.aspect);this.framedFieldOfView=2*Math.atan(t)*180/Math.PI}getSize(){return{width:this.width,height:this.height}}setTarget(t,e,n){this.goalTarget.set(-t,-e,-n)}setTargetDamperDecayTime(t){this.targetDamperX.setDecayTime(t),this.targetDamperY.setDecayTime(t),this.targetDamperZ.setDecayTime(t)}getTarget(){return _At.copy(this.goalTarget).multiplyScalar(-1)}jumpToGoal(){this.updateTarget(1e4)}updateTarget(t){const e=this.goalTarget,n=this.target.position;if(!e.equals(n)){const i=this.idealCameraDistance;let{x:r,y:s,z:o}=n;r=this.targetDamperX.update(r,e.x,t,i),s=this.targetDamperY.update(s,e.y,t,i),o=this.targetDamperZ.update(o,e.z,t,i),this.target.position.set(r,s,o),this.target.updateMatrixWorld(),this.setShadowRotation(this.yaw),this.isDirty=!0}}pointTowards(t,e){const{x:n,z:i}=this.position;this.yaw=Math.atan2(t-n,e-i)}set yaw(t){this.rotation.y=t,this.updateMatrixWorld(!0),this.setShadowRotation(t),this.isDirty=!0}get yaw(){return this.rotation.y}set animationTime(t){this.mixer.setTime(t)}get animationTime(){return null!=this.currentAnimationAction?this.currentAnimationAction.time:0}get duration(){return null!=this.currentAnimationAction&&this.currentAnimationAction.getClip()?this.currentAnimationAction.getClip().duration:0}get hasActiveAnimation(){return null!=this.currentAnimationAction}playAnimation(t=null,e=0){if(null==this._currentGLTF)return;const{animations:n}=this;if(null==n||0===n.length)return void console.warn("Cannot play animation (model does not have any animations)");let i=null;null!=t&&(i=this.animationsByName.get(t)),null==i&&(i=n[0]);try{const{currentAnimationAction:t}=this;this.currentAnimationAction=this.mixer.clipAction(i,this).play(),this.currentAnimationAction.enabled=!0,null!=t&&this.currentAnimationAction!==t&&this.currentAnimationAction.crossFadeFrom(t,e,!1)}catch(t){console.error(t)}}stopAnimation(){null!=this.currentAnimationAction&&(this.currentAnimationAction.stop(),this.currentAnimationAction.reset(),this.currentAnimationAction=null),this.mixer.stopAllAction()}updateAnimation(t){this.mixer.update(t)}updateShadow(){const t=this.shadow;null!=t&&t.setScene(this,this.shadowSoftness,"wall"===this.element.arPlacement?"back":"bottom")}setShadowIntensity(t){if(this.shadowIntensity=t,null==this._currentGLTF)return;let e=this.shadow;const n="wall"===this.element.arPlacement?"back":"bottom";null!=e?(e.setIntensity(t),e.setScene(this,this.shadowSoftness,n)):t>0&&(e=new mAt(this,this.shadowSoftness,n),e.setIntensity(t),this.shadow=e)}setShadowSoftness(t){this.shadowSoftness=t;const e=this.shadow;null!=e&&e.setSoftness(t)}setShadowRotation(t){const e=this.shadow;null!=e&&e.setRotation(t)}isShadowDirty(){const t=this.shadow;if(null==t)return!1;{const{needsUpdate:e}=t;return t.needsUpdate=!1,e}}setShadowScaleAndOffset(t,e){const n=this.shadow;null!=n&&n.setScaleAndOffset(t,e)}positionAndNormalFromPoint(t,e=this){wAt.setFromCamera(t,this.camera);const n=wAt.intersectObject(e,!0);if(0===n.length)return null;const i=n[0];return null==i.face?null:(i.face.normal.applyNormalMatrix((new eht).getNormalMatrix(i.object.matrixWorld)),{position:i.point,normal:i.face.normal})}addHotspot(t){this.target.add(t),this.annotationRenderer.domElement.appendChild(t.element)}removeHotspot(t){this.target.remove(t)}forHotspots(t){const{children:e}=this.target;for(let n=0,i=e.length;n<i;n++){const i=e[n];i instanceof pAt&&t(i)}}updateHotspots(t){this.forHotspots(e=>{bAt.copy(t),AAt.setFromMatrixPosition(e.matrixWorld),bAt.sub(AAt),xAt.copy(e.normal).transformDirection(this.target.matrixWorld),bAt.dot(xAt)<0?e.hide():e.show()})}orientHotspots(t){this.forHotspots(e=>{e.orient(t)})}setHotspotsVisibility(t){this.forHotspots(e=>{e.visible=t})}postRender(){const{camera:t}=this;this.isDirty&&(this.updateHotspots(t.position),this.annotationRenderer.domElement.style.display="",this.annotationRenderer.render(this,t))}}const EAt=function(){const t=new Mgt({uniforms:{roughnessMap:{value:null},normalMap:{value:null},texelSize:{value:new tht(1,1)}},vertexShader:"\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tattribute vec3 position;\n\t\t\tattribute vec2 uv;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tvoid main() {\n\n\t\t\t\tvUv = uv;\n\n\t\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t\t}\n\t\t",fragmentShader:"\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tuniform sampler2D roughnessMap;\n\t\t\tuniform sampler2D normalMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\n\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tfloat roughnessToVariance( float roughness ) {\n\n\t\t\t\tfloat variance = 0.0;\n\n\t\t\t\tif ( roughness >= r1 ) {\n\n\t\t\t\t\tvariance = ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;\n\n\t\t\t\t} else if ( roughness >= r4 ) {\n\n\t\t\t\t\tvariance = ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;\n\n\t\t\t\t} else if ( roughness >= r5 ) {\n\n\t\t\t\t\tvariance = ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfloat roughness2 = roughness * roughness;\n\n\t\t\t\t\tvariance = 1.79 * roughness2 * roughness2;\n\n\t\t\t\t}\n\n\t\t\t\treturn variance;\n\n\t\t\t}\n\n\t\t\tfloat varianceToRoughness( float variance ) {\n\n\t\t\t\tfloat roughness = 0.0;\n\n\t\t\t\tif ( variance >= v1 ) {\n\n\t\t\t\t\troughness = ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;\n\n\t\t\t\t} else if ( variance >= v4 ) {\n\n\t\t\t\t\troughness = ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;\n\n\t\t\t\t} else if ( variance >= v5 ) {\n\n\t\t\t\t\troughness = ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\troughness = pow( 0.559 * variance, 0.25 ); // 0.559 = 1.0 / 1.79\n\n\t\t\t\t}\n\n\t\t\t\treturn roughness;\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = texture2D( roughnessMap, vUv, - 1.0 );\n\n\t\t\t\tif ( texelSize.x == 0.0 ) return;\n\n\t\t\t\tfloat roughness = gl_FragColor.g;\n\n\t\t\t\tfloat variance = roughnessToVariance( roughness );\n\n\t\t\t\tvec3 avgNormal;\n\n\t\t\t\tfor ( float x = - 1.0; x < 2.0; x += 2.0 ) {\n\n\t\t\t\t\tfor ( float y = - 1.0; y < 2.0; y += 2.0 ) {\n\n\t\t\t\t\t\tvec2 uv = vUv + vec2( x, y ) * 0.25 * texelSize;\n\n\t\t\t\t\t\tavgNormal += normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvariance += 1.0 - 0.25 * length( avgNormal );\n\n\t\t\t\tgl_FragColor.g = varianceToRoughness( variance );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1});return t.type="RoughnessMipmapper",t}(),CAt=new gpt(new Dpt(2,2),EAt),IAt=new myt(0,1,0,1,0,1);let TAt=null,MAt=null;class kAt{constructor(t){MAt=t,MAt.compile(CAt,IAt)}generateMipmaps(t){if("roughnessMap"in t==0)return;const{roughnessMap:e,normalMap:n}=t;if(null===e||null===n||!e.generateMipmaps||t.userData.roughnessUpdated)return;t.userData.roughnessUpdated=!0;let i=Math.max(e.image.width,n.image.width),r=Math.max(e.image.height,n.image.height);if(!Zut.isPowerOfTwo(i)||!Zut.isPowerOfTwo(r))return;const s=MAt.getRenderTarget(),o=MAt.autoClear;if(MAt.autoClear=!1,null!==TAt&&TAt.width===i&&TAt.height===r||(null!==TAt&&TAt.dispose(),TAt=new lht(i,r,{depthBuffer:!1}),TAt.scissorTest=!0),i!==e.image.width||r!==e.image.height){const n=new lht(i,r,{wrapS:e.wrapS,wrapT:e.wrapT,magFilter:e.magFilter,minFilter:e.minFilter,depthBuffer:!1});n.texture.generateMipmaps=!0,MAt.setRenderTarget(n),t.roughnessMap=n.texture,t.metalnessMap==e&&(t.metalnessMap=t.roughnessMap),t.aoMap==e&&(t.aoMap=t.roughnessMap),t.roughnessMap.offset.copy(e.offset),t.roughnessMap.repeat.copy(e.repeat),t.roughnessMap.center.copy(e.center),t.roughnessMap.rotation=e.rotation,t.roughnessMap.matrixAutoUpdate=e.matrixAutoUpdate,t.roughnessMap.matrix.copy(e.matrix)}EAt.uniforms.roughnessMap.value=e,EAt.uniforms.normalMap.value=n;const a=new tht(0,0),l=EAt.uniforms.texelSize.value;for(let c=0;i>=1&&r>=1;++c,i/=2,r/=2)l.set(1/i,1/r),0==c&&l.set(0,0),TAt.viewport.set(a.x,a.y,i,r),TAt.scissor.set(a.x,a.y,i,r),MAt.setRenderTarget(TAt),MAt.render(CAt,IAt),MAt.copyFramebufferToTexture(a,t.roughnessMap,c),EAt.uniforms.roughnessMap.value=t.roughnessMap;e!==t.roughnessMap&&e.dispose(),MAt.setRenderTarget(s),MAt.autoClear=o}dispose(){EAt.dispose(),CAt.geometry.dispose(),null!=TAt&&TAt.dispose()}}const RAt=Math.PI/24,NAt=new tht,LAt=(t,e,n)=>{let i=e>0?n>0?0:-Math.PI/2:n>0?Math.PI/2:Math.PI;for(let r=0;r<=12;++r)t.push(e+.17*Math.cos(i),n+.17*Math.sin(i),0,e+.2*Math.cos(i),n+.2*Math.sin(i),0),i+=RAt};class DAt extends gpt{constructor(t,e){const n=new Jdt,i=[],r=[],{size:s,boundingBox:o}=t,a=s.x/2,l=("back"===e?s.y:s.z)/2;LAt(r,a,l),LAt(r,-a,l),LAt(r,-a,-l),LAt(r,a,-l);const c=r.length/3;for(let d=0;d<c-2;d+=2)i.push(d,d+1,d+3,d,d+3,d+2);const u=c-2;i.push(u,u+1,1,u,1,0),n.setAttribute("position",new Vdt(r,3)),n.setIndex(i),super(n),this.side=e;const h=this.material;switch(h.side=2,h.transparent=!0,h.opacity=0,this.goalOpacity=0,this.opacityDamper=new Zbt,this.hitPlane=new gpt(new Dpt(2*(a+.2),2*(l+.2))),this.hitPlane.visible=!1,this.add(this.hitPlane),o.getCenter(this.position),e){case"bottom":this.rotateX(-Math.PI/2),this.shadowHeight=o.min.y,this.position.y=this.shadowHeight;break;case"back":this.shadowHeight=o.min.z,this.position.z=this.shadowHeight}t.target.add(this)}getHit(t,e,n){NAt.set(e,-n),this.hitPlane.visible=!0;const i=t.positionAndNormalFromPoint(NAt,this.hitPlane);return this.hitPlane.visible=!1,null==i?null:i.position}set offsetHeight(t){"back"===this.side?this.position.z=this.shadowHeight+t:this.position.y=this.shadowHeight+t}get offsetHeight(){return"back"===this.side?this.position.z-this.shadowHeight:this.position.y-this.shadowHeight}set show(t){this.goalOpacity=t?.75:0}updateOpacity(t){const e=this.material;e.opacity=this.opacityDamper.update(e.opacity,this.goalOpacity,t,1),this.visible=e.opacity>0}dispose(){var t;const{geometry:e,material:n}=this.hitPlane;e.dispose(),n.dispose(),this.geometry.dispose(),this.material.dispose(),null===(t=this.parent)||void 0===t||t.remove(this)}}const BAt="not-presenting",OAt="session-started",PAt="tracking",FAt=new uht,$At=new Uht,zAt=new uht;class UAt extends Uut{constructor(t){super(),this.renderer=t,this.currentSession=null,this.placeOnWall=!1,this.cameraPosition=new uht,this.placementBox=null,this.lastTick=null,this.turntableRotation=null,this.oldShadowIntensity=null,this.oldBackground=null,this.frame=null,this.initialHitSource=null,this.transientHitTestSource=null,this.inputSource=null,this._presentedScene=null,this.resolveCleanup=null,this.exitWebXRButtonContainer=null,this.overlay=null,this.tracking=!0,this.frames=0,this.initialized=!1,this.projectionMatrix=new Uht,this.projectionMatrixInverse=new Uht,this.oldTarget=new uht,this.placementComplete=!1,this.isTranslating=!1,this.isRotating=!1,this.isTwoFingering=!1,this.lastDragPosition=new uht,this.firstRatio=0,this.lastAngle=0,this.goalPosition=new uht,this.goalYaw=0,this.goalScale=1,this.xDamper=new Zbt,this.yDamper=new Zbt,this.zDamper=new Zbt,this.yawDamper=new Zbt,this.scaleDamper=new Zbt,this.onExitWebXRButtonContainerClick=()=>this.stopPresenting(),this.onUpdateScene=()=>{null!=this.placementBox&&this.isPresenting&&(this.placementBox.dispose(),this.placementBox=new DAt(this.presentedScene,this.placeOnWall?"back":"bottom"))},this.onSelectStart=t=>{const e=this.transientHitTestSource;if(null==e)return;const n=this.frame.getHitTestResultsForTransientInput(e),i=this.presentedScene,r=this.placementBox;if(1===n.length){this.inputSource=t.inputSource;const{axes:e}=this.inputSource.gamepad,n=r.getHit(this.presentedScene,e[0],e[1]);r.show=!0,null!=n?(this.isTranslating=!0,this.lastDragPosition.copy(n)):!1===this.placeOnWall&&(this.isRotating=!0,this.lastAngle=1.5*e[0])}else if(2===n.length){r.show=!0,this.isTwoFingering=!0;const{separation:t}=this.fingerPolar(n);this.firstRatio=t/i.scale.x}},this.onSelectEnd=()=>{this.isTranslating=!1,this.isRotating=!1,this.isTwoFingering=!1,this.inputSource=null,this.goalPosition.y+=this.placementBox.offsetHeight*this.presentedScene.scale.x,this.placementBox.show=!1},this.threeRenderer=t.threeRenderer,this.threeRenderer.xr.enabled=!0}async resolveARSession(){Qbt();const t=await navigator.xr.requestSession("immersive-ar",{requiredFeatures:["hit-test"],optionalFeatures:["dom-overlay"],domOverlay:{root:this.overlay}});return this.threeRenderer.xr.setReferenceSpaceType("local"),await this.threeRenderer.xr.setSession(t),t}get presentedScene(){return this._presentedScene}async supportsPresentation(){try{return Qbt(),await navigator.xr.isSessionSupported("immersive-ar")}catch(obt){return console.warn("Request to present in WebXR denied:"),console.warn(obt),console.warn("Falling back to next ar-mode"),!1}}async present(t){this.isPresenting&&console.warn("Cannot present while a model is already presenting");let e=new Promise((t,e)=>{requestAnimationFrame(()=>t())});t.setHotspotsVisibility(!1),t.isDirty=!0,await e,this._presentedScene=t,this.overlay=t.element.shadowRoot.querySelector("div.default");const n=await this.resolveARSession();n.addEventListener("end",()=>{this.postSessionCleanup()},{once:!0});const i=t.element.shadowRoot.querySelector(".slot.exit-webxr-ar-button");i.classList.add("enabled"),i.addEventListener("click",this.onExitWebXRButtonContainerClick),this.exitWebXRButtonContainer=i;const r=await n.requestReferenceSpace("viewer");this.tracking=!0,this.frames=0,this.initialized=!1,this.turntableRotation=t.yaw,this.goalYaw=t.yaw,this.goalScale=1,this.oldBackground=t.background,t.background=null,this.oldShadowIntensity=t.shadowIntensity,t.setShadowIntensity(0),this.oldTarget.copy(t.getTarget()),t.addEventListener("model-load",this.onUpdateScene);const s=20*Math.PI/180,o=!0===this.placeOnWall?void 0:new XRRay(new DOMPoint(0,0,0),{x:0,y:-Math.sin(s),z:-Math.cos(s)});n.requestHitTestSource({space:r,offsetRay:o}).then(t=>{this.initialHitSource=t}),this.currentSession=n,this.placementBox=new DAt(t,this.placeOnWall?"back":"bottom"),this.placementComplete=!1,this.xDamper.setDecayTime(120),this.yDamper.setDecayTime(120),this.zDamper.setDecayTime(120),this.lastTick=performance.now(),this.dispatchEvent({type:"status",status:OAt})}async stopPresenting(){if(!this.isPresenting)return;const t=new Promise(t=>{this.resolveCleanup=t});try{await this.currentSession.end(),await t}catch(t){console.warn("Error while trying to end WebXR AR session"),console.warn(t),this.postSessionCleanup()}}get isPresenting(){return null!=this.presentedScene}get target(){return this.oldTarget}updateTarget(){const t=this.presentedScene;if(null!=t){const e=t.getTarget();this.oldTarget.copy(e),this.placeOnWall?t.setTarget(e.x,e.y,t.boundingBox.min.z):t.setTarget(e.x,t.boundingBox.min.y,e.z)}}postSessionCleanup(){const t=this.currentSession;null!=t&&(t.removeEventListener("selectstart",this.onSelectStart),t.removeEventListener("selectend",this.onSelectEnd),this.currentSession=null);const e=this.presentedScene;if(null!=e){const{element:t}=e;e.position.set(0,0,0),e.scale.set(1,1,1),e.setShadowScaleAndOffset(1,0);const n=this.turntableRotation;null!=n&&(e.yaw=n);const i=this.oldShadowIntensity;null!=i&&e.setShadowIntensity(i);const r=this.oldBackground;null!=r&&(e.background=r);const s=this.oldTarget;e.setTarget(s.x,s.y,s.z),e.removeEventListener("model-load",this.onUpdateScene),e.orientHotspots(0),t.requestUpdate("cameraTarget"),t.requestUpdate("maxCameraOrbit"),t[iwt](t.getBoundingClientRect())}this.renderer.height=0;const n=this.exitWebXRButtonContainer;null!=n&&(n.classList.remove("enabled"),n.removeEventListener("click",this.onExitWebXRButtonContainerClick),this.exitWebXRButtonContainer=null);const i=this.transientHitTestSource;null!=i&&(i.cancel(),this.transientHitTestSource=null);const r=this.initialHitSource;null!=r&&(r.cancel(),this.initialHitSource=null),null!=this.placementBox&&(this.placementBox.dispose(),this.placementBox=null),this.lastTick=null,this.turntableRotation=null,this.oldShadowIntensity=null,this.oldBackground=null,this._presentedScene=null,this.frame=null,this.inputSource=null,this.overlay=null,null!=this.resolveCleanup&&this.resolveCleanup(),this.dispatchEvent({type:"status",status:BAt})}updateView(t){const e=t.transform.matrix,n=this.presentedScene,{camera:i}=n;if(i.near=.1,i.far=100,this.presentedScene.orientHotspots(Math.atan2(e[1],e[5])),this.cameraPosition.set(e[12],e[13],e[14]),!this.initialized){const{position:t,element:r}=n,{width:s,height:o}=this.overlay.getBoundingClientRect();n.setSize(s,o),null!=this.threeRenderer.xr.getSession()&&(this.projectionMatrix.copy(this.threeRenderer.xr.getCamera(i).projectionMatrix),this.projectionMatrixInverse.copy(this.projectionMatrix).invert());const{theta:a,radius:l}=r.getCameraOrbit(),c=FAt.set(e[8],e[9],e[10]);n.yaw=Math.atan2(c.x,c.z)-a,this.goalYaw=n.yaw,t.copy(this.cameraPosition).add(c.multiplyScalar(-1*l)),this.goalPosition.copy(t),n.setHotspotsVisibility(!0),this.initialized=!0}i.projectionMatrix.copy(this.projectionMatrix),i.projectionMatrixInverse.copy(this.projectionMatrixInverse),t.requestViewportScale&&t.recommendedViewportScale&&t.requestViewportScale(Math.max(t.recommendedViewportScale,.25));const r=this.currentSession.renderState.baseLayer.getViewport(t);this.threeRenderer.setViewport(r.x,r.y,r.width,r.height)}placeInitially(t){const e=this.initialHitSource;if(null==e)return;const n=t.getHitTestResults(e);if(0==n.length)return;const i=this.getHitPoint(n[0]);if(null==i)return;this.placeModel(i),e.cancel(),this.initialHitSource=null;const{session:r}=t;r.addEventListener("selectstart",this.onSelectStart),r.addEventListener("selectend",this.onSelectEnd),r.requestHitTestSourceForTransientInput({profile:"generic-touchscreen"}).then(t=>{this.transientHitTestSource=t})}getHitPoint(t){const e=this.threeRenderer.xr.getReferenceSpace(),n=t.getPose(e);if(null==n)return null;const i=$At.fromArray(n.transform.matrix);return!0===this.placeOnWall&&(this.goalYaw=Math.atan2(i.elements[4],i.elements[6])),i.elements[5]>.75!==this.placeOnWall?zAt.setFromMatrixPosition(i):null}placeModel(t){this.placementBox.show=!0,this.placeOnWall?this.goalPosition.copy(t):this.goalPosition.y=t.y,this.updateTarget(),this.dispatchEvent({type:"status",status:"object-placed"})}fingerPolar(t){const e=t[0].inputSource.gamepad.axes,n=t[1].inputSource.gamepad.axes,i=n[0]-e[0],r=n[1]-e[1],s=Math.atan2(r,i);let o=this.lastAngle-s;return o>Math.PI?o-=2*Math.PI:o<-Math.PI&&(o+=2*Math.PI),this.lastAngle=s,{separation:Math.sqrt(i*i+r*r),deltaYaw:o}}processInput(t){const e=this.transientHitTestSource;if(null==e)return;if(!this.isTranslating&&!this.isTwoFingering&&!this.isRotating)return;const n=t.getHitTestResultsForTransientInput(e),i=this.presentedScene,r=i.scale.x;if(this.isTwoFingering)if(n.length<2)this.isTwoFingering=!1;else{const{separation:t,deltaYaw:e}=this.fingerPolar(n);if(!1===this.placeOnWall&&(this.goalYaw+=e),i.canScale){const e=t/this.firstRatio;this.goalScale=e<1.2&&e>.8333333333333334?1:e}}else if(2!==n.length)if(this.isRotating){const t=1.5*this.inputSource.gamepad.axes[0];this.goalYaw+=t-this.lastAngle,this.lastAngle=t}else this.isTranslating&&n.forEach(t=>{if(t.inputSource!==this.inputSource||t.results.length<1)return;const e=this.getHitPoint(t.results[0]);if(null!=e){if(this.goalPosition.sub(this.lastDragPosition),!1===this.placeOnWall){const t=e.y-this.lastDragPosition.y;if(t<0){this.placementBox.offsetHeight=t/r,this.presentedScene.setShadowScaleAndOffset(r,t);const n=FAt.copy(this.cameraPosition),i=-t/(n.y-e.y);n.multiplyScalar(i),e.multiplyScalar(1-i).add(n)}}this.goalPosition.add(e),this.lastDragPosition.copy(e)}});else{this.isTranslating=!1,this.isRotating=!1,this.isTwoFingering=!0;const{separation:t}=this.fingerPolar(n);this.firstRatio=t/r}}moveScene(t){const e=this.presentedScene,{position:n,yaw:i,idealCameraDistance:r}=e,s=this.goalPosition,o=e.scale.x,a=this.placementBox;if(null==this.initialHitSource&&(!s.equals(n)||this.goalScale!==o)){let{x:i,y:l,z:c}=n;i=this.xDamper.update(i,s.x,t,r),l=this.yDamper.update(l,s.y,t,r),c=this.zDamper.update(c,s.z,t,r),n.set(i,l,c);const u=this.scaleDamper.update(o,this.goalScale,t,1);if(e.scale.set(u,u,u),!this.isTranslating){const t=s.y-l;this.placementComplete&&!1===this.placeOnWall?(a.offsetHeight=t/u,e.setShadowScaleAndOffset(u,t)):0===t&&(this.placementComplete=!0,a.show=!1,e.setShadowIntensity(.3),this.xDamper.setDecayTime(50),this.yDamper.setDecayTime(50),this.zDamper.setDecayTime(50))}}a.updateOpacity(t),e.updateTarget(t),e.yaw=this.yawDamper.update(i,this.goalYaw,t,Math.PI)}onWebXRFrame(t,e){this.frame=e,++this.frames;const n=this.threeRenderer.xr.getReferenceSpace(),i=e.getViewerPose(n);null==i&&!0===this.tracking&&this.frames>30&&(this.tracking=!1,this.dispatchEvent({type:"tracking",status:"not-tracking"}));const r=this.presentedScene;if(null==i||null==r||!r.element[cwt]())return void this.threeRenderer.clear();!1===this.tracking&&(this.tracking=!0,this.dispatchEvent({type:"tracking",status:PAt}));let s=!0;for(const o of i.views){if(this.updateView(o),s){this.placeInitially(e),this.processInput(e);const n=t-this.lastTick;this.moveScene(n),this.renderer.preRender(r,t,n),this.lastTick=t}const n=this.threeRenderer.getContext();n.depthMask(!1),n.clear(n.DEPTH_BUFFER_BIT),n.depthMask(!0),this.threeRenderer.render(r,r.camera),s=!1}}}class HAt{constructor(t){t.threeRenderer.debug={checkShaderErrors:!0},Promise.resolve().then(()=>{self.dispatchEvent(new CustomEvent("model-viewer-renderer-debug",{detail:{renderer:t,THREE:{ShaderMaterial:wpt,Texture:sht,Mesh:gpt,Scene:qmt,PlaneBufferGeometry:Dpt,OrthographicCamera:myt,WebGLRenderTarget:lht}}}))})}addScene(t){self.dispatchEvent(new CustomEvent("model-viewer-scene-added-debug",{detail:{scene:t}}))}removeScene(t){self.dispatchEvent(new CustomEvent("model-viewer-scene-removed-debug",{detail:{scene:t}}))}}function VAt(t,e,n){n(t,e);for(let i=0;i<t.children.length;i++)VAt(t.children[i],e.children[i],n)}const GAt=Symbol("prepared"),WAt=Symbol("prepare"),jAt=Symbol("preparedGLTF"),QAt=Symbol("clone");class qAt{constructor(t){this[jAt]=t}static prepare(t){if(null==t.scene)throw new Error("Model does not have a scene");if(t[GAt])return t;const e=this[WAt](t);return e[GAt]=!0,e}static[WAt](t){const{scene:e}=t,n=[e];return Object.assign(Object.assign({},t),{scene:e,scenes:n})}get parser(){return this[jAt].parser}get animations(){return this[jAt].animations}get scene(){return this[jAt].scene}get scenes(){return this[jAt].scenes}get cameras(){return this[jAt].cameras}get asset(){return this[jAt].asset}get userData(){return this[jAt].userData}clone(){return new(0,this.constructor)(this[QAt]())}dispose(){this.scenes.forEach(t=>{t.traverse(t=>{if(!t.isMesh)return;const e=t;(Array.isArray(e.material)?e.material:[e.material]).forEach(t=>{t.dispose()}),e.geometry.dispose()})})}[QAt](){const t=this[jAt],e=class{static retarget(t,e,n={}){const i=new uht,r=new cht,s=new uht,o=new Uht,a=new Uht,l=new Uht;n.preserveMatrix=void 0===n.preserveMatrix||n.preserveMatrix,n.preservePosition=void 0===n.preservePosition||n.preservePosition,n.preserveHipPosition=void 0!==n.preserveHipPosition&&n.preserveHipPosition,n.useTargetMatrix=void 0!==n.useTargetMatrix&&n.useTargetMatrix,n.hip=void 0!==n.hip?n.hip:"hip",n.names=n.names||{};const c=e.isObject3D?e.skeleton.bones:this.getBones(e),u=t.isObject3D?t.skeleton.bones:this.getBones(t);let h,d,p,f,m;if(t.isObject3D?t.skeleton.pose():(n.useTargetMatrix=!0,n.preserveMatrix=!1),n.preservePosition){m=[];for(let t=0;t<u.length;t++)m.push(u[t].position.clone())}if(n.preserveMatrix){t.updateMatrixWorld(),t.matrixWorld.identity();for(let e=0;e<t.children.length;++e)t.children[e].updateMatrixWorld(!0)}if(n.offsets){h=[];for(let t=0;t<u.length;++t)d=u[t],p=n.names[d.name]||d.name,n.offsets&&n.offsets[p]&&(d.matrix.multiply(n.offsets[p]),d.matrix.decompose(d.position,d.quaternion,d.scale),d.updateMatrixWorld()),h.push(d.matrixWorld.clone())}for(let g=0;g<u.length;++g){if(d=u[g],p=n.names[d.name]||d.name,f=this.getBoneByName(p,c),l.copy(d.matrixWorld),f){if(f.updateMatrixWorld(),n.useTargetMatrix?a.copy(f.matrixWorld):(a.copy(t.matrixWorld).invert(),a.multiply(f.matrixWorld)),s.setFromMatrixScale(a),a.scale(s.set(1/s.x,1/s.y,1/s.z)),l.makeRotationFromQuaternion(r.setFromRotationMatrix(a)),t.isObject3D){const e=u.indexOf(d),n=h?h[e]:o.copy(t.skeleton.boneInverses[e]).invert();l.multiply(n)}l.copyPosition(a)}d.parent&&d.parent.isBone?(d.matrix.copy(d.parent.matrixWorld).invert(),d.matrix.multiply(l)):d.matrix.copy(l),n.preserveHipPosition&&p===n.hip&&d.matrix.setPosition(i.set(0,d.position.y,0)),d.matrix.decompose(d.position,d.quaternion,d.scale),d.updateMatrixWorld()}if(n.preservePosition)for(let g=0;g<u.length;++g)d=u[g],p=n.names[d.name]||d.name,p!==n.hip&&d.position.copy(m[g]);n.preserveMatrix&&t.updateMatrixWorld(!0)}static retargetClip(t,e,n,i={}){i.useFirstFramePosition=void 0!==i.useFirstFramePosition&&i.useFirstFramePosition,i.fps=void 0!==i.fps?i.fps:30,i.names=i.names||[],e.isObject3D||(e=this.getHelperFromSkeleton(e));const r=Math.round(n.duration*(i.fps/1e3)*1e3),s=1/i.fps,o=[],a=new Ryt(e),l=this.getBones(t.skeleton),c=[];let u,h,d,p,f;a.clipAction(n).play(),a.update(0),e.updateMatrixWorld();for(let m=0;m<r;++m){const n=m*s;this.retarget(t,e,i);for(let t=0;t<l.length;++t)f=i.names[l[t].name]||l[t].name,d=this.getBoneByName(f,e.skeleton),d&&(h=l[t],p=c[t]=c[t]||{bone:h},i.hip===f&&(p.pos||(p.pos={times:new Float32Array(r),values:new Float32Array(3*r)}),i.useFirstFramePosition&&(0===m&&(u=h.position.clone()),h.position.sub(u)),p.pos.times[m]=n,h.position.toArray(p.pos.values,3*m)),p.quat||(p.quat={times:new Float32Array(r),values:new Float32Array(4*r)}),p.quat.times[m]=n,h.quaternion.toArray(p.quat.values,4*m));a.update(s),e.updateMatrixWorld()}for(let m=0;m<c.length;++m)p=c[m],p&&(p.pos&&o.push(new Ggt(".bones["+p.bone.name+"].position",p.pos.times,p.pos.values)),o.push(new Hgt(".bones["+p.bone.name+"].quaternion",p.quat.times,p.quat.values)));return a.uncacheAction(n),new Wgt(n.name,-1,o)}static getHelperFromSkeleton(t){const e=new Fyt(t.bones[0]);return e.skeleton=t,e}static getSkeletonOffsets(t,e,n={}){const i=new uht,r=new uht,s=new uht,o=new uht,a=new tht,l=new tht;n.hip=void 0!==n.hip?n.hip:"hip",n.names=n.names||{},e.isObject3D||(e=this.getHelperFromSkeleton(e));const c=Object.keys(n.names),u=Object.values(n.names),h=e.isObject3D?e.skeleton.bones:this.getBones(e),d=t.isObject3D?t.skeleton.bones:this.getBones(t),p=[];let f,m,g,y;for(t.skeleton.pose(),y=0;y<d.length;++y)if(f=d[y],g=n.names[f.name]||f.name,m=this.getBoneByName(g,h),m&&g!==n.hip){const t=this.getNearestBone(f.parent,c),e=this.getNearestBone(m.parent,u);t.updateMatrixWorld(),e.updateMatrixWorld(),i.setFromMatrixPosition(t.matrixWorld),r.setFromMatrixPosition(f.matrixWorld),s.setFromMatrixPosition(e.matrixWorld),o.setFromMatrixPosition(m.matrixWorld),a.subVectors(new tht(r.x,r.y),new tht(i.x,i.y)).normalize(),l.subVectors(new tht(o.x,o.y),new tht(s.x,s.y)).normalize();const n=a.angle()-l.angle(),h=(new Uht).makeRotationFromEuler(new Kht(0,0,n));f.matrix.multiply(h),f.matrix.decompose(f.position,f.quaternion,f.scale),f.updateMatrixWorld(),p[g]=h}return p}static renameBones(t,e){const n=this.getBones(t);for(let i=0;i<n.length;++i){const t=n[i];e[t.name]&&(t.name=e[t.name])}return this}static getBones(t){return Array.isArray(t)?t:t.bones}static getBoneByName(t,e){for(let n=0,i=this.getBones(e);n<i.length;n++)if(t===i[n].name)return i[n]}static getNearestBone(t,e){for(;t.isBone;){if(-1!==e.indexOf(t.name))return t;t=t.parent}}static findBoneTrackData(t,e){const n=/\[(.*)\]\.(.*)/,i={name:t};for(let r=0;r<e.length;++r){const s=n.exec(e[r].name);s&&t===s[1]&&(i[s[2]]=r)}return i}static getEqualsBonesNames(t,e){const n=this.getBones(t),i=this.getBones(e),r=[];t:for(let s=0;s<n.length;s++){const t=n[s].name;for(let e=0;e<i.length;e++)if(t===i[e].name){r.push(t);continue t}}return r}static clone(t){const e=new Map,n=new Map,i=t.clone();return VAt(t,i,function(t,i){e.set(i,t),n.set(t,i)}),i.traverse(function(t){if(!t.isSkinnedMesh)return;const i=t,r=e.get(t),s=r.skeleton.bones;i.skeleton=r.skeleton.clone(),i.bindMatrix.copy(r.bindMatrix),i.skeleton.bones=s.map(function(t){return n.get(t)}),i.bind(i.skeleton,i.bindMatrix)}),i}}.clone(this.scene),n=[e],i=t.userData?Object.assign({},t.userData):{};return Object.assign(Object.assign({},t),{scene:e,scenes:n,userData:i})}}const XAt="\n#ifdef ALPHATEST\n\n    if ( diffuseColor.a < ALPHATEST ) discard;\n    diffuseColor.a = 1.0;\n\n#endif\n",YAt=Symbol("threeGLTF"),KAt=Symbol("gltf"),JAt=Symbol("gltfElementMap"),ZAt=Symbol("threeObjectMap"),txt=Symbol("parallelTraverseThreeScene"),ext=Symbol("correlateOriginalThreeGLTF"),nxt=Symbol("correlateCloneThreeGLTF");class ixt{constructor(t,e,n,i){this[YAt]=t,this[KAt]=e,this[JAt]=i,this[ZAt]=n}static from(t,e){return null!=e?this[nxt](t,e):this[ext](t)}static[ext](t){const e=t.parser.json,{associations:n}=t.parser,i=new Map,r={name:"Default"},s={type:"materials",index:-1};return n.forEach((t,n)=>{null==t&&(s.index<0&&(null==e.materials&&(e.materials=[]),s.index=e.materials.length,e.materials.push(r)),t=s);const{type:o,index:a}=t,l=(e[o]||[])[a];if(null==l)return;let c=i.get(l);null==c&&(c=new Set,i.set(l,c)),c.add(n)}),new ixt(t,e,n,i)}static[nxt](t,e){const n=e.threeGLTF,i=JSON.parse(JSON.stringify(e.gltf)),r=new Map,s=new Map,o={name:"Default"},a={type:"materials",index:-1};for(let l=0;l<n.scenes.length;l++)this[txt](n.scenes[l],t.scenes[l],(t,n)=>{let l=e.threeObjectMap.get(t);null==l&&(a.index<0&&(null==i.materials&&(i.materials=[]),a.index=i.materials.length,i.materials.push(o)),l=a);const{type:c,index:u}=l,h=i[c][u];r.set(n,{type:c,index:u});const d=s.get(h)||new Set;d.add(n),s.set(h,d)});return new ixt(t,i,r,s)}static[txt](t,e,n){const i=(t,e)=>{if(n(t,e),t.isObject3D){if(t.isMesh)if(Array.isArray(t.material))for(let n=0;n<t.material.length;++n)i(t.material[n],e.material[n]);else i(t.material,e.material);for(let n=0;n<t.children.length;++n)i(t.children[n],e.children[n])}};i(t,e)}get threeGLTF(){return this[YAt]}get gltf(){return this[KAt]}get gltfElementMap(){return this[JAt]}get threeObjectMap(){return this[ZAt]}loadVariant(t,e=(()=>{})){const n=new Set;return this.threeGLTF.scene.traverse(async i=>{const{gltfExtensions:r}=i.userData;if(!i.isMesh||null==r)return;const s=r.KHR_materials_variants;if(null==s)return;let o=-1;for(const e of s.mappings)if(e.variants.indexOf(t)>=0){o=e.material;break}if(o<0)return;const a=await this.threeGLTF.parser.getDependency("material",o);n.add(o),i.material=a,this.threeGLTF.parser.assignFinalMaterial(i),e();const l=this.gltf.materials[o];let c=this.gltfElementMap.get(l);null==c&&(c=new Set,this.gltfElementMap.set(l,c)),c.add(i.material)}),n}}const rxt=Symbol("cloneAndPatchMaterial"),sxt=Symbol("correlatedSceneGraph");class oxt extends qAt{static[WAt](t){const e=super[WAt](t);null==e[sxt]&&(e[sxt]=ixt.from(e));const{scene:n}=e,i=[];n.traverse(t=>{if(t.renderOrder=1e3,t.frustumCulled=!1,t.name||(t.name=t.uuid),!t.isMesh)return;t.castShadow=!0;const e=t;let n=!1;(Array.isArray(e.material)?e.material:[e.material]).forEach(t=>{t.isMeshStandardMaterial&&t.transparent&&2===t.side&&(n=!0,t.side=0)}),n&&i.push(e)});for(const r of i){const t=(Array.isArray(r.material)?r.material:[r.material]).map(t=>{const e=t.clone();return e.side=1,e}),e=Array.isArray(r.material)?t:t[0],n=r.clone();n.material=e,n.renderOrder=-1,r.parent.add(n)}return e}get correlatedSceneGraph(){return this[jAt][sxt]}[QAt](){const t=super[QAt](),e=new Map;return t.scene.traverse(t=>{if(t.isMesh){const n=t;Array.isArray(n.material)?n.material=n.material.map(t=>this[rxt](t,e)):null!=n.material&&(n.material=this[rxt](n.material,e))}}),t[sxt]=ixt.from(t,this.correlatedSceneGraph),t}[rxt](t,e){if(e.has(t.uuid))return e.get(t.uuid);const n=t.clone();null!=t.map&&(n.map=t.map.clone(),n.map.needsUpdate=!0),null!=t.normalMap&&(n.normalMap=t.normalMap.clone(),n.normalMap.needsUpdate=!0),null!=t.emissiveMap&&(n.emissiveMap=t.emissiveMap.clone(),n.emissiveMap.needsUpdate=!0);let i=null;if(null!=t.roughnessMap&&(i=t.roughnessMap.clone()),null!=i){i.needsUpdate=!0,n.roughnessMap=i;const{threeRenderer:t,roughnessMipmapper:e}=mxt.singleton,{enabled:r}=t.xr;t.xr.enabled=!1,e.generateMipmaps(n),t.xr.enabled=r}t.roughnessMap===t.metalnessMap?n.metalnessMap=i:null!=t.metalnessMap&&(n.metalnessMap=t.metalnessMap.clone(),n.metalnessMap.needsUpdate=!0),t.roughnessMap===t.aoMap?n.aoMap=i:null!=t.aoMap&&(n.aoMap=t.aoMap.clone(),n.aoMap.needsUpdate=!0);const r=t.onBeforeCompile;return n.onBeforeCompile=t.isGLTFSpecularGlossinessMaterial?t=>{r(t,void 0),t.fragmentShader=t.fragmentShader.replace("#include <alphatest_fragment>",XAt)}:t=>{t.fragmentShader=t.fragmentShader.replace("#include <alphatest_fragment>",XAt),r(t,void 0)},n.shadowSide=0,n.transparent&&(n.depthWrite=!1),n.alphaTest||n.transparent||(n.alphaTest=-.5),e.set(t.uuid,n),n}}class axt extends qmt{constructor(){super(),this.position.y=-3.5;const t=new vpt;t.deleteAttribute("uv");const e=new kgt({metalness:0,side:1}),n=new kgt({metalness:0}),i=new fyt(16777215,500,28,2);i.position.set(.418,16.199,.3),this.add(i);const r=new gpt(t,e);r.position.set(-.757,13.219,.717),r.scale.set(31.713,28.305,28.591),this.add(r);const s=new gpt(t,n);s.position.set(-10.906,2.009,1.846),s.rotation.set(0,-.195,0),s.scale.set(2.328,7.905,4.651),this.add(s);const o=new gpt(t,n);o.position.set(-5.607,-.754,-.758),o.rotation.set(0,.994,0),o.scale.set(1.97,1.534,3.955),this.add(o);const a=new gpt(t,n);a.position.set(6.167,.857,7.803),a.rotation.set(0,.561,0),a.scale.set(3.927,6.285,3.687),this.add(a);const l=new gpt(t,n);l.position.set(-2.017,.018,6.124),l.rotation.set(0,.333,0),l.scale.set(2.002,4.566,2.064),this.add(l);const c=new gpt(t,n);c.position.set(2.291,-.756,-2.621),c.rotation.set(0,-.286,0),c.scale.set(1.546,1.552,1.496),this.add(c);const u=new gpt(t,n);u.position.set(-2.193,-.369,-5.547),u.rotation.set(0,.516,0),u.scale.set(3.875,3.487,2.986),this.add(u);const h=new gpt(t,this.createAreaLightMaterial(50));h.position.set(-16.116,14.37,8.208),h.scale.set(.1,2.428,2.739),this.add(h);const d=new gpt(t,this.createAreaLightMaterial(50));d.position.set(-16.109,18.021,-8.207),d.scale.set(.1,2.425,2.751),this.add(d);const p=new gpt(t,this.createAreaLightMaterial(17));p.position.set(14.904,12.198,-1.832),p.scale.set(.15,4.265,6.331),this.add(p);const f=new gpt(t,this.createAreaLightMaterial(43));f.position.set(-.462,8.89,14.52),f.scale.set(4.38,5.441,.088),this.add(f);const m=new gpt(t,this.createAreaLightMaterial(20));m.position.set(3.235,11.486,-12.541),m.scale.set(2.5,2,.1),this.add(m);const g=new gpt(t,this.createAreaLightMaterial(100));g.position.set(0,20,0),g.scale.set(1,.1,1),this.add(g)}createAreaLightMaterial(t){const e=new Pdt;return e.color.setScalar(t),e}}class lxt extends qmt{constructor(){super(),this.position.y=-3.5;const t=new vpt;t.deleteAttribute("uv");const e=new kgt({metalness:0,side:1}),n=new kgt({metalness:0}),i=new fyt(16777215,400,28,2);i.position.set(.5,14,.5),this.add(i);const r=new gpt(t,e);r.position.set(0,13.2,0),r.scale.set(31.5,28.5,31.5),this.add(r);const s=new gpt(t,n);s.position.set(-10.906,-1,1.846),s.rotation.set(0,-.195,0),s.scale.set(2.328,7.905,4.651),this.add(s);const o=new gpt(t,n);o.position.set(-5.607,-.754,-.758),o.rotation.set(0,.994,0),o.scale.set(1.97,1.534,3.955),this.add(o);const a=new gpt(t,n);a.position.set(6.167,-.16,7.803),a.rotation.set(0,.561,0),a.scale.set(3.927,6.285,3.687),this.add(a);const l=new gpt(t,n);l.position.set(-2.017,.018,6.124),l.rotation.set(0,.333,0),l.scale.set(2.002,4.566,2.064),this.add(l);const c=new gpt(t,n);c.position.set(2.291,-.756,-2.621),c.rotation.set(0,-.286,0),c.scale.set(1.546,1.552,1.496),this.add(c);const u=new gpt(t,n);u.position.set(-2.193,-.369,-5.547),u.rotation.set(0,.516,0),u.scale.set(3.875,3.487,2.986),this.add(u);const h=new gpt(t,this.createAreaLightMaterial(80));h.position.set(-14,10,8),h.scale.set(.1,2.5,2.5),this.add(h);const d=new gpt(t,this.createAreaLightMaterial(80));d.position.set(-14,14,-4),d.scale.set(.1,2.5,2.5),this.add(d);const p=new gpt(t,this.createAreaLightMaterial(23));p.position.set(14,12,0),p.scale.set(.1,5,5),this.add(p);const f=new gpt(t,this.createAreaLightMaterial(16));f.position.set(0,9,14),f.scale.set(5,5,.1),this.add(f);const m=new gpt(t,this.createAreaLightMaterial(80));m.position.set(7,8,-14),m.scale.set(2.5,2.5,.1),this.add(m);const g=new gpt(t,this.createAreaLightMaterial(80));g.position.set(-7,16,-14),g.scale.set(2.5,2.5,.1),this.add(g);const y=new gpt(t,this.createAreaLightMaterial(1));y.position.set(0,20,0),y.scale.set(.1,.1,.1),this.add(y)}createAreaLightMaterial(t){const e=new Pdt;return e.color.setScalar(t),e}}const cxt=/\.hdr(\.js)?$/,uxt=new nyt,hxt=new class extends eyt{constructor(t){super(t),this.type=1009}parse(t){const e=function(t,e){switch(t){case 1:console.error("THREE.RGBELoader Read Error: "+(e||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(e||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(e||""));break;default:case 4:console.error("THREE.RGBELoader: Error: "+(e||""))}return-1},n=function(t,e,n){e=e||1024;let i=t.pos,r=-1,s=0,o="",a=String.fromCharCode.apply(null,new Uint16Array(t.subarray(i,i+128)));for(;0>(r=a.indexOf("\n"))&&s<e&&i<t.byteLength;)o+=a,s+=a.length,i+=128,a+=String.fromCharCode.apply(null,new Uint16Array(t.subarray(i,i+128)));return-1<r&&(!1!==n&&(t.pos+=s+r+1),o+a.slice(0,r))},i=function(t,e,n,i){const r=Math.pow(2,t[e+3]-128)/255;n[i+0]=t[e+0]*r,n[i+1]=t[e+1]*r,n[i+2]=t[e+2]*r},r=function(t,e,n,i){const r=Math.pow(2,t[e+3]-128)/255;n[i+0]=Hyt.toHalfFloat(t[e+0]*r),n[i+1]=Hyt.toHalfFloat(t[e+1]*r),n[i+2]=Hyt.toHalfFloat(t[e+2]*r)},s=new Uint8Array(t);s.pos=0;const o=function(t){const i=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,r=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,s=/^\s*FORMAT=(\S+)\s*$/,o=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,a={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let l,c;if(t.pos>=t.byteLength||!(l=n(t)))return e(1,"no header found");if(!(c=l.match(/^#\?(\S+)/)))return e(3,"bad initial token");for(a.valid|=1,a.programtype=c[1],a.string+=l+"\n";l=n(t),!1!==l;)if(a.string+=l+"\n","#"!==l.charAt(0)){if((c=l.match(i))&&(a.gamma=parseFloat(c[1],10)),(c=l.match(r))&&(a.exposure=parseFloat(c[1],10)),(c=l.match(s))&&(a.valid|=2,a.format=c[1]),(c=l.match(o))&&(a.valid|=4,a.height=parseInt(c[1],10),a.width=parseInt(c[2],10)),2&a.valid&&4&a.valid)break}else a.comments+=l+"\n";return 2&a.valid?4&a.valid?a:e(3,"missing image size specifier"):e(3,"missing format specifier")}(s);if(-1!==o){const t=o.width,n=o.height,a=function(t,n,i){const r=n;if(r<8||r>32767||2!==t[0]||2!==t[1]||128&t[2])return new Uint8Array(t);if(r!==(t[2]<<8|t[3]))return e(3,"wrong scanline width");const s=new Uint8Array(4*n*i);if(!s.length)return e(4,"unable to allocate buffer space");let o=0,a=0;const l=4*r,c=new Uint8Array(4),u=new Uint8Array(l);let h=i;for(;h>0&&a<t.byteLength;){if(a+4>t.byteLength)return e(1);if(c[0]=t[a++],c[1]=t[a++],c[2]=t[a++],c[3]=t[a++],2!=c[0]||2!=c[1]||(c[2]<<8|c[3])!=r)return e(3,"bad rgbe scanline format");let n,i=0;for(;i<l&&a<t.byteLength;){n=t[a++];const r=n>128;if(r&&(n-=128),0===n||i+n>l)return e(3,"bad scanline data");if(r){const e=t[a++];for(let t=0;t<n;t++)u[i++]=e}else u.set(t.subarray(a,a+n),i),i+=n,a+=n}const d=r;for(let t=0;t<d;t++){let e=0;s[o]=u[t+e],e+=r,s[o+1]=u[t+e],e+=r,s[o+2]=u[t+e],e+=r,s[o+3]=u[t+e],o+=4}h--}return s}(s.subarray(s.pos),t,n);if(-1!==a){let e,s,l,c;switch(this.type){case 1009:e=a,s=1023,l=1009;break;case 1015:c=a.length/4*3;const t=new Float32Array(c);for(let e=0;e<c;e++)i(a,4*e,t,3*e);e=t,s=1022,l=1015;break;case 1016:c=a.length/4*3;const n=new Uint16Array(c);for(let e=0;e<c;e++)r(a,4*e,n,3*e);e=n,s=1022,l=1016;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type)}return{width:t,height:n,data:e,header:o.string,gamma:o.gamma,exposure:o.exposure,format:s,type:l}}}return null}setDataType(t){return this.type=t,this}load(t,e,n,i){return super.load(t,function(t,n){switch(t.type){case 1009:t.encoding=3002,t.minFilter=1003,t.magFilter=1003,t.generateMipmaps=!1,t.flipY=!0;break;case 1015:case 1016:t.encoding=3e3,t.minFilter=1006,t.magFilter=1006,t.generateMipmaps=!1,t.flipY=!0}e&&e(t,n)},n,i)}},dxt={url:null};class pxt extends Uut{constructor(t){super(),this.generatedEnvironmentMap=null,this.generatedEnvironmentMapAlt=null,this.skyboxCache=new Map,this.environmentMapCache=new Map,this.PMREMGenerator=new svt(t)}async load(t,e=(()=>{})){try{const n=cxt.test(t),i=n?hxt:uxt,r=await new Promise((n,r)=>i.load(t,n,t=>{e(t.loaded/t.total*.9)},r));return e(1),this.addMetadata(r,t),r.mapping=303,n?(r.encoding=3002,r.minFilter=1003,r.magFilter=1003,r.flipY=!0):r.encoding=3007,r}finally{e&&e(1)}}async generateEnvironmentMapAndSkybox(t=null,e=null,n={}){const{progressTracker:i}=n,r=null!=i?i.beginActivity():()=>{},s="neutral"===e;!0===s&&(e=null);const o=jbt(e);try{let e,n=Promise.resolve(null);t&&(n=this.loadSkyboxFromUrl(t,i)),e=o?this.loadEnvironmentMapFromUrl(o,i):t?this.loadEnvironmentMapFromUrl(t,i):!0===s?this.loadGeneratedEnvironmentMapAlt():this.loadGeneratedEnvironmentMap();let[a,l]=await Promise.all([e,n]);if(null==a)throw new Error("Failed to load environment map.");return{environmentMap:a,skybox:l}}finally{r(1)}}addMetadata(t,e){null!=t&&(t.userData=Object.assign(Object.assign({},dxt),{url:e}))}loadSkyboxFromUrl(t,e){if(!this.skyboxCache.has(t)){const n=e?e.beginActivity():()=>{},i=this.load(t,n);this.skyboxCache.set(t,i)}return this.skyboxCache.get(t)}loadEnvironmentMapFromUrl(t,e){if(!this.environmentMapCache.has(t)){const n=this.loadSkyboxFromUrl(t,e).then(e=>{const n=this.PMREMGenerator.fromEquirectangular(e);return this.addMetadata(n.texture,t),n});this.PMREMGenerator.compileEquirectangularShader(),this.environmentMapCache.set(t,n)}return this.environmentMapCache.get(t)}loadGeneratedEnvironmentMap(){if(null==this.generatedEnvironmentMap){const t=new axt;this.generatedEnvironmentMap=this.PMREMGenerator.fromScene(t,.04),this.addMetadata(this.generatedEnvironmentMap.texture,null)}return Promise.resolve(this.generatedEnvironmentMap)}loadGeneratedEnvironmentMapAlt(){if(null==this.generatedEnvironmentMapAlt){const t=new lxt;this.generatedEnvironmentMapAlt=this.PMREMGenerator.fromScene(t,.04),this.addMetadata(this.generatedEnvironmentMapAlt.texture,null)}return Promise.resolve(this.generatedEnvironmentMapAlt)}async dispose(){const t=[];this.environmentMapCache.forEach(e=>{t.push(e)}),this.environmentMapCache.clear();for(const e of t)try{(await e).dispose()}catch(t){}null!=this.generatedEnvironmentMap&&(this.generatedEnvironmentMap.dispose(),this.generatedEnvironmentMap=null),null!=this.generatedEnvironmentMapAlt&&(this.generatedEnvironmentMapAlt.dispose(),this.generatedEnvironmentMapAlt=null)}}const fxt=[1,.79,.62,.5,.4,.31,.25];class mxt extends Uut{constructor(t){super(),this.loader=new Fbt(oxt),this.width=0,this.height=0,this.dpr=1,this.debugger=null,this.scenes=new Set,this.multipleScenesVisible=!1,this.scaleStep=0,this.lastStep=3,this.avgFrameDuration=22,this.onWebGLContextLost=t=>{this.dispatchEvent({type:"contextlost",sourceEvent:t})},this.dpr=Kbt(),this.canvasElement=document.createElement("canvas"),this.canvasElement.id="webgl-canvas",this.canvas3D=this.canvasElement,this.canvas3D.addEventListener("webglcontextlost",this.onWebGLContextLost);try{this.threeRenderer=new Qmt({canvas:this.canvas3D,alpha:!0,antialias:!0,powerPreference:"high-performance",preserveDrawingBuffer:!0}),this.threeRenderer.autoClear=!0,this.threeRenderer.outputEncoding=3007,this.threeRenderer.physicallyCorrectLights=!0,this.threeRenderer.setPixelRatio(1),this.threeRenderer.shadowMap.enabled=!0,this.threeRenderer.shadowMap.type=2,this.threeRenderer.shadowMap.autoUpdate=!1,this.debugger=null!=t&&t.debug?new HAt(this):null,this.threeRenderer.debug={checkShaderErrors:!!this.debugger},this.threeRenderer.toneMapping=4}catch(t){console.warn(t)}this.arRenderer=new UAt(this),this.textureUtils=this.canRender?new pxt(this.threeRenderer):null,this.roughnessMipmapper=new kAt(this.threeRenderer),Fbt.initializeKTX2Loader(this.threeRenderer),this.updateRendererSize(),this.lastTick=performance.now(),this.avgFrameDuration=0}static get singleton(){return this._singleton}static resetSingleton(){this._singleton.dispose(),this._singleton=new mxt({debug:Jbt()})}get canRender(){return null!=this.threeRenderer}get scaleFactor(){return fxt[this.scaleStep]}set minScale(t){let e=1;for(;e<fxt.length&&!(fxt[e]<t);)++e;this.lastStep=e-1}updateRendererSize(){const t=Kbt();if(t!==this.dpr)for(const o of this.scenes){const{element:t}=o;t[Hxt](t.getBoundingClientRect())}let e=0,n=0;for(const o of this.scenes)e=Math.max(e,o.width),n=Math.max(n,o.height);if(e===this.width&&n===this.height&&t===this.dpr)return;this.width=e,this.height=n,this.dpr=t,this.canRender&&this.threeRenderer.setSize(e*t,n*t,!1);const i=this.scaleFactor,r=e/i,s=n/i;this.canvasElement.style.width=`${r}px`,this.canvasElement.style.height=`${s}px`;for(const o of this.scenes){const{canvas:i}=o;i.width=Math.round(e*t),i.height=Math.round(n*t),i.style.width=`${r}px`,i.style.height=`${s}px`,o.isDirty=!0}}updateRendererScale(){const t=this.scaleStep;if(this.avgFrameDuration>26&&this.scaleStep<this.lastStep?++this.scaleStep:this.avgFrameDuration<18&&this.scaleStep>0&&--this.scaleStep,t==this.scaleStep)return;const e=this.scaleFactor;this.avgFrameDuration=22;const n=this.width/e,i=this.height/e;this.canvasElement.style.width=`${n}px`,this.canvasElement.style.height=`${i}px`;for(const r of this.scenes){const{style:t}=r.canvas;t.width=`${n}px`,t.height=`${i}px`,r.isDirty=!0}}registerScene(t){this.scenes.add(t);const{canvas:e}=t,n=this.scaleFactor;e.width=Math.round(this.width*this.dpr),e.height=Math.round(this.height*this.dpr),e.style.width=this.width/n+"px",e.style.height=this.height/n+"px",this.multipleScenesVisible&&e.classList.add("show"),t.isDirty=!0,this.canRender&&this.scenes.size>0&&this.threeRenderer.setAnimationLoop((t,e)=>this.render(t,e)),null!=this.debugger&&this.debugger.addScene(t)}unregisterScene(t){this.scenes.delete(t),this.canRender&&0===this.scenes.size&&this.threeRenderer.setAnimationLoop(null),null!=this.debugger&&this.debugger.removeScene(t)}displayCanvas(t){return this.multipleScenesVisible?t.element[Jxt]:this.canvasElement}selectCanvas(){let t=0,e=null;for(const r of this.scenes){const{element:n}=r;n.modelIsVisible&&null==r.externalRenderer&&(++t,e=r.canvas)}if(null==e)return;const n=t>1||!1,{canvasElement:i}=this;if(n!==this.multipleScenesVisible||!n&&i.parentElement!==e.parentElement){this.multipleScenesVisible=n,n&&i.classList.remove("show");for(const t of this.scenes){if(null!=t.externalRenderer)continue;const r=t.element[Jxt];n?(r.classList.add("show"),t.isDirty=!0):t.canvas===e&&(t.canvas.parentElement.appendChild(i),i.classList.add("show"),r.classList.remove("show"),t.isDirty=!0)}}}orderedScenes(){const t=[];for(const e of[!1,!0])for(const n of this.scenes)n.element.modelIsVisible===e&&t.push(n);return t}get isPresenting(){return this.arRenderer.isPresenting}preRender(t,e,n){const{element:i,exposure:r}=t;i[ewt](e,n);const s="number"==typeof r&&!self.isNaN(r);this.threeRenderer.toneMappingExposure=s?r:1,t.isShadowDirty()&&(this.threeRenderer.shadowMap.needsUpdate=!0)}render(t,e){if(null!=e)return this.arRenderer.onWebXRFrame(t,e),void this.arRenderer.presentedScene.postRender();const n=t-this.lastTick;if(this.lastTick=t,!this.canRender||this.isPresenting)return;this.avgFrameDuration+=Ybt(.2*(n-this.avgFrameDuration),-2,2),this.selectCanvas(),this.updateRendererSize(),this.updateRendererScale();const{dpr:i,scaleFactor:r}=this;for(const s of this.orderedScenes()){const{element:e}=s;if(!e.modelIsVisible&&s.renderCount>0)continue;if(this.preRender(s,t,n),!s.isDirty)continue;if(null!=s.externalRenderer){s.camera.updateMatrix();const{matrix:t,projectionMatrix:e}=s.camera,n=t.elements.slice(),i=s.getTarget();n[12]+=i.x,n[13]+=i.y,n[14]+=i.z,s.externalRenderer.render({viewMatrix:n,projectionMatrix:e.elements});continue}if(!e.modelIsVisible&&!this.multipleScenesVisible)for(const t of this.scenes)t.element.modelIsVisible&&(t.isDirty=!0);const o=Math.min(Math.ceil(s.width*r*i),this.canvas3D.width),a=Math.min(Math.ceil(s.height*r*i),this.canvas3D.height);if(this.threeRenderer.setRenderTarget(null),this.threeRenderer.setViewport(0,Math.floor(this.height*i)-a,o,a),this.threeRenderer.render(s,s.camera),s.postRender(),this.multipleScenesVisible){null==s.context&&s.createContext();{const t=s.context;t.clearRect(0,0,o,a),t.drawImage(this.canvas3D,0,0,o,a,0,0,o,a)}}s.isDirty=!1,e.loaded&&++s.renderCount}}dispose(){null!=this.textureUtils&&this.textureUtils.dispose(),null!=this.threeRenderer&&this.threeRenderer.dispose(),this.textureUtils=null,this.threeRenderer=null,this.scenes.clear(),this.canvas3D.removeEventListener("webglcontextlost",this.onWebGLContextLost)}}var gxt,yxt;mxt._singleton=new mxt({debug:Jbt()});const vxt=Symbol("ongoingActivities"),bxt=Symbol("announceTotalProgress"),Axt=Symbol("eventDelegate");class xxt{constructor(){this[gxt]=document.createDocumentFragment(),this.addEventListener=(...t)=>this[Axt].addEventListener(...t),this.removeEventListener=(...t)=>this[Axt].removeEventListener(...t),this.dispatchEvent=(...t)=>this[Axt].dispatchEvent(...t),this[yxt]=new Set}get ongoingActivityCount(){return this[vxt].size}beginActivity(){const t={progress:0};return this[vxt].add(t),1===this.ongoingActivityCount&&this[bxt](),e=>{let n;return n=Math.max(Ybt(e,0,1),t.progress),n!==t.progress&&(t.progress=n,this[bxt]()),t.progress}}[(gxt=Axt,yxt=vxt,bxt)](){let t=0,e=0,n=0;for(const i of this[vxt]){const{progress:r}=i;t+=r*(.5/Math.pow(2,e++)),1===r&&n++}n===this.ongoingActivityCount&&(t=1,this[vxt].clear()),this.dispatchEvent(new CustomEvent("progress",{detail:{totalProgress:t}}))}}var wxt,_xt,Sxt,Ext,Cxt,Ixt,Txt,Mxt,kxt,Rxt,Nxt=function(t,e,n,i){for(var r,s=arguments.length,o=s<3?e:null===i?i=Object.getOwnPropertyDescriptor(e,n):i,a=t.length-1;a>=0;a--)(r=t[a])&&(o=(s<3?r(o):s>3?r(e,n,o):r(e,n))||o);return s>3&&o&&Object.defineProperty(e,n,o),o};const Lxt=document.createElement("canvas");let Dxt=null;const Bxt=Symbol("template"),Oxt=Symbol("fallbackResizeHandler"),Pxt=Symbol("defaultAriaLabel"),Fxt=Symbol("resizeObserver"),$xt=Symbol("clearModelTimeout"),zxt=Symbol("onContextLost"),Uxt=Symbol("loaded"),Hxt=Symbol("updateSize"),Vxt=Symbol("intersectionObserver"),Gxt=Symbol("isElementInViewport"),Wxt=Symbol("announceModelVisibility"),jxt=Symbol("ariaLabel"),Qxt=Symbol("loadedTime"),qxt=Symbol("updateSource"),Xxt=Symbol("markLoaded"),Yxt=Symbol("container"),Kxt=Symbol("input"),Jxt=Symbol("canvas"),Zxt=Symbol("scene"),twt=Symbol("needsRender"),ewt=Symbol("tick"),nwt=Symbol("onModelLoad"),iwt=Symbol("onResize"),rwt=Symbol("renderer"),swt=Symbol("progressTracker"),owt=Symbol("getLoaded"),awt=Symbol("getModelIsVisible"),lwt=Symbol("shouldAttemptPreload"),cwt=Symbol("sceneIsReady"),uwt=Symbol("hasTransitioned"),hwt=t=>({x:t.x,y:t.y,z:t.z,toString(){return`${this.x}m ${this.y}m ${this.z}m`}});class dwt extends Cut{constructor(){super(),this.alt=null,this.src=null,this[wxt]=!1,this[_xt]=!1,this[Sxt]=0,this[Ext]=null,this[Cxt]=Xbt(()=>{const t=this.getBoundingClientRect();this[Hxt](t)},50),this[Ixt]=Xbt(t=>{const e=this.modelIsVisible;e!==t&&this.dispatchEvent(new CustomEvent("model-visibility",{detail:{visible:e}}))},0),this[Txt]=null,this[Mxt]=null,this[kxt]=new xxt,this[Rxt]=t=>{this.dispatchEvent(new CustomEvent("error",{detail:{type:"webglcontextlost",sourceError:t.sourceEvent}}))};const t=this.constructor.template;window.ShadyCSS&&window.ShadyCSS.styleElement(this,{}),this.attachShadow({mode:"open"});const e=this.shadowRoot;let n,i;if(e.appendChild(t.content.cloneNode(!0)),this[Yxt]=e.querySelector(".container"),this[Kxt]=e.querySelector(".userInput"),this[Jxt]=e.querySelector("canvas"),this[Pxt]=this[Kxt].getAttribute("aria-label"),this.isConnected){const t=this.getBoundingClientRect();n=t.width,i=t.height}else n=300,i=150;this[Zxt]=new SAt({canvas:this[Jxt],element:this,width:n,height:i}),this[Zxt].addEventListener("model-load",async t=>{this[Xxt](),this[nwt](),await((t=0)=>new Promise(e=>setTimeout(e,t)))(),this.dispatchEvent(new CustomEvent("load",{detail:{url:t.url}}))}),Promise.resolve().then(()=>{this[Hxt](this.getBoundingClientRect())}),Rut&&(this[Fxt]=new ResizeObserver(t=>{if(!this[rwt].isPresenting)for(let e of t)e.target===this&&this[Hxt](e.contentRect)})),Nut?this[Vxt]=new IntersectionObserver(t=>{for(let e of t)if(e.target===this){const t=this.modelIsVisible;this[Gxt]=e.isIntersecting,this[Wxt](t),this[Gxt]&&!this[cwt]()&&this[qxt]()}},{root:null,rootMargin:"0px",threshold:0}):this[Gxt]=!0}static get is(){return"model-viewer"}static get template(){return this.hasOwnProperty(Bxt)||(this[Bxt]=(t=>{const e=document.createElement("template");return e.innerHTML=zut.innerHTML,window.ShadyCSS&&window.ShadyCSS.prepareTemplate(e,t),e})(this.is)),this[Bxt]}static set modelCacheSize(t){Fbt[Obt].evictionThreshold=t}static get modelCacheSize(){return Fbt[Obt].evictionThreshold}static set minimumRenderScale(t){t>1&&console.warn("<model-viewer> minimumRenderScale has been clamped to a maximum value of 1."),t<=0&&console.warn("<model-viewer> minimumRenderScale has been clamped to a minimum value of 0.25."),mxt.singleton.minScale=t}static get minimumRenderScale(){return mxt.singleton.minScale}get loaded(){return this[owt]()}get[(wxt=Gxt,_xt=Uxt,Sxt=Qxt,Ext=$xt,Cxt=Oxt,Ixt=Wxt,Txt=Fxt,Mxt=Vxt,kxt=swt,rwt)](){return mxt.singleton}get modelIsVisible(){return this[awt]()}connectedCallback(){super.connectedCallback&&super.connectedCallback(),Rut?this[Fxt].observe(this):self.addEventListener("resize",this[Oxt]),Nut&&this[Vxt].observe(this);const t=this[rwt];t.addEventListener("contextlost",this[zxt]),t.registerScene(this[Zxt]),null!=this[$xt]&&(self.clearTimeout(this[$xt]),this[$xt]=null,this.requestUpdate("src",null))}disconnectedCallback(){super.disconnectedCallback&&super.disconnectedCallback(),Rut?this[Fxt].unobserve(this):self.removeEventListener("resize",this[Oxt]),Nut&&this[Vxt].unobserve(this);const t=this[rwt];t.removeEventListener("contextlost",this[zxt]),t.unregisterScene(this[Zxt]),this[$xt]=self.setTimeout(()=>{this[Zxt].reset()},1e3)}updated(t){super.updated(t),t.has("src")&&(null==this.src?(this[Uxt]=!1,this[Qxt]=0,this[Zxt].reset()):this.src!==this[Zxt].url&&(this[Uxt]=!1,this[Qxt]=0,this[qxt]())),t.has("alt")&&this[Kxt].setAttribute("aria-label",null==this.alt?this[Pxt]:this.alt)}toDataURL(t,e){return this[rwt].displayCanvas(this[Zxt]).toDataURL(t,e)}async toBlob(t){const e=t?t.mimeType:void 0,n=t?t.qualityArgument:void 0,i=t?t.idealAspect:void 0,{width:r,height:s,fieldOfViewAspect:o,aspect:a}=this[Zxt],{dpr:l,scaleFactor:c}=this[rwt];let u=r*c*l,h=s*c*l,d=0,p=0;if(!0===i)if(o>a){const t=h;h=Math.round(u/o),p=(t-h)/2}else{const t=u;u=Math.round(h*o),d=(t-u)/2}Lxt.width=u,Lxt.height=h;try{return new Promise(async(t,i)=>(null==Dxt&&(Dxt=Lxt.getContext("2d")),Dxt.drawImage(this[rwt].displayCanvas(this[Zxt]),d,p,u,h,0,0,u,h),!Lxt.msToBlob||e&&"image/png"!==e?Lxt.toBlob?void Lxt.toBlob(e=>{if(!e)return i(new Error("Unable to retrieve canvas blob"));t(e)},e,n):t(await(async t=>new Promise((e,n)=>{const i=t.match(/data:(.*);/);if(!i)return n(new Error(`${t} is not a valid data Url`));const r=i[1],s=t.replace(/data:image\/\w+;base64,/,""),o=atob(s),a=[];for(let t=0;t<o.length;t+=512){const e=o.slice(t,t+512),n=new Array(e.length);for(let t=0;t<e.length;t++)n[t]=e.charCodeAt(t);const i=new Uint8Array(n);a.push(i)}e(new Blob(a,{type:r}))}))(Lxt.toDataURL(e,n))):t(Lxt.msToBlob())))}finally{this[Hxt]({width:r,height:s})}}registerRenderer(t){this[Zxt].externalRenderer=t}unregisterRenderer(){this[Zxt].externalRenderer=null}get[jxt](){return null==this.alt||"null"===this.alt?this[Pxt]:this.alt}[owt](){return this[Uxt]}[awt](){return this.loaded&&this[Gxt]}[uwt](){return this.modelIsVisible}[lwt](){return!!this.src&&this[Gxt]}[cwt](){return this[Uxt]}[Hxt]({width:t,height:e}){this[Yxt].style.width=`${t}px`,this[Yxt].style.height=`${e}px`,this[iwt]({width:parseFloat(t),height:parseFloat(e)})}[ewt](t,e){}[Xxt](){this[Uxt]||(this[Uxt]=!0,this[Qxt]=performance.now())}[twt](){this[Zxt].isDirty=!0}[nwt](){}[iwt](t){this[Zxt].setSize(t.width,t.height)}async[(Rxt=zxt,qxt)](){if(this.loaded||!this[lwt]())return;const t=this[swt].beginActivity(),e=this.src;try{await this[Zxt].setSource(e,e=>t(.8*e)),this.dispatchEvent(new CustomEvent("preload",{detail:{url:e}}))}catch(t){this.dispatchEvent(new CustomEvent("error",{detail:t}))}finally{t(.9),requestAnimationFrame(()=>{requestAnimationFrame(()=>{t(1)})})}}}Nxt([Tut({type:String})],dwt.prototype,"alt",void 0),Nxt([Tut({type:String})],dwt.prototype,"src",void 0);var pwt=function(t,e,n,i){for(var r,s=arguments.length,o=s<3?e:null===i?i=Object.getOwnPropertyDescriptor(e,n):i,a=t.length-1;a>=0;a--)(r=t[a])&&(o=(s<3?r(o):s>3?r(e,n,o):r(e,n))||o);return s>3&&o&&Object.defineProperty(e,n,o),o};const fwt=Symbol("changeAnimation"),mwt=Symbol("paused"),gwt=Symbol("hotspotMap"),ywt=Symbol("mutationCallback"),vwt=Symbol("observer"),bwt=Symbol("addHotspot"),Awt=Symbol("removeHotspot"),xwt=new tht,wwt=new Uht,_wt=new eht;var Swt=function(t){return URL.createObjectURL(new Blob([t],{type:"text/javascript"}))};try{URL.revokeObjectURL(Swt(""))}catch(Yvt){Swt=function(t){return"data:application/javascript;charset=UTF-8,"+encodeURI(t)}}var Ewt=Uint8Array,Cwt=Uint16Array,Iwt=Uint32Array,Twt=new Ewt([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Mwt=new Ewt([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),kwt=new Ewt([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Rwt=function(t,e){for(var n=new Cwt(31),i=0;i<31;++i)n[i]=e+=1<<t[i-1];var r=new Iwt(n[30]);for(i=1;i<30;++i)for(var s=n[i];s<n[i+1];++s)r[s]=s-n[i]<<5|i;return[n,r]},Nwt=Rwt(Twt,2),Lwt=Nwt[1];Nwt[0][28]=258,Lwt[258]=28;for(var Dwt=Rwt(Mwt,0)[1],Bwt=new Cwt(32768),Owt=0;Owt<32768;++Owt){var Pwt=(43690&Owt)>>>1|(21845&Owt)<<1;Pwt=(61680&(Pwt=(52428&Pwt)>>>2|(13107&Pwt)<<2))>>>4|(3855&Pwt)<<4,Bwt[Owt]=((65280&Pwt)>>>8|(255&Pwt)<<8)>>>1}var Fwt=function(t,e,n){for(var i=t.length,r=0,s=new Cwt(e);r<i;++r)++s[t[r]-1];var o,a=new Cwt(e);for(r=0;r<e;++r)a[r]=a[r-1]+s[r-1]<<1;if(n){o=new Cwt(1<<e);var l=15-e;for(r=0;r<i;++r)if(t[r])for(var c=r<<4|t[r],u=e-t[r],h=a[t[r]-1]++<<u,d=h|(1<<u)-1;h<=d;++h)o[Bwt[h]>>>l]=c}else for(o=new Cwt(i),r=0;r<i;++r)t[r]&&(o[r]=Bwt[a[t[r]-1]++]>>>15-t[r]);return o},$wt=new Ewt(288);for(Owt=0;Owt<144;++Owt)$wt[Owt]=8;for(Owt=144;Owt<256;++Owt)$wt[Owt]=9;for(Owt=256;Owt<280;++Owt)$wt[Owt]=7;for(Owt=280;Owt<288;++Owt)$wt[Owt]=8;var zwt=new Ewt(32);for(Owt=0;Owt<32;++Owt)zwt[Owt]=5;var Uwt=Fwt($wt,9,0),Hwt=Fwt(zwt,5,0),Vwt=function(t){return(t/8|0)+(7&t&&1)},Gwt=function(t,e,n){(null==e||e<0)&&(e=0),(null==n||n>t.length)&&(n=t.length);var i=new(t instanceof Cwt?Cwt:t instanceof Iwt?Iwt:Ewt)(n-e);return i.set(t.subarray(e,n)),i},Wwt=function(t,e,n){var i=e/8|0;t[i]|=n<<=7&e,t[i+1]|=n>>>8},jwt=function(t,e,n){var i=e/8|0;t[i]|=n<<=7&e,t[i+1]|=n>>>8,t[i+2]|=n>>>16},Qwt=function(t,e){for(var n=[],i=0;i<t.length;++i)t[i]&&n.push({s:i,f:t[i]});var r=n.length,s=n.slice();if(!r)return[t_t,0];if(1==r){var o=new Ewt(n[0].s+1);return o[n[0].s]=1,[o,1]}n.sort(function(t,e){return t.f-e.f}),n.push({s:-1,f:25001});var a=n[0],l=n[1],c=0,u=1,h=2;for(n[0]={s:-1,f:a.f+l.f,l:a,r:l};u!=r-1;)a=n[n[c].f<n[h].f?c++:h++],l=n[c!=u&&n[c].f<n[h].f?c++:h++],n[u++]={s:-1,f:a.f+l.f,l:a,r:l};var d=s[0].s;for(i=1;i<r;++i)s[i].s>d&&(d=s[i].s);var p=new Cwt(d+1),f=qwt(n[u-1],p,0);if(f>e){i=0;var m=0,g=f-e,y=1<<g;for(s.sort(function(t,e){return p[e.s]-p[t.s]||t.f-e.f});i<r;++i){var v=s[i].s;if(!(p[v]>e))break;m+=y-(1<<f-p[v]),p[v]=e}for(m>>>=g;m>0;){var b=s[i].s;p[b]<e?m-=1<<e-p[b]++-1:++i}for(;i>=0&&m;--i){var A=s[i].s;p[A]==e&&(--p[A],++m)}f=e}return[new Ewt(p),f]},qwt=function(t,e,n){return-1==t.s?Math.max(qwt(t.l,e,n+1),qwt(t.r,e,n+1)):e[t.s]=n},Xwt=function(t){for(var e=t.length;e&&!t[--e];);for(var n=new Cwt(++e),i=0,r=t[0],s=1,o=function(t){n[i++]=t},a=1;a<=e;++a)if(t[a]==r&&a!=e)++s;else{if(!r&&s>2){for(;s>138;s-=138)o(32754);s>2&&(o(s>10?s-11<<5|28690:s-3<<5|12305),s=0)}else if(s>3){for(o(r),--s;s>6;s-=6)o(8304);s>2&&(o(s-3<<5|8208),s=0)}for(;s--;)o(r);s=1,r=t[a]}return[n.subarray(0,i),e]},Ywt=function(t,e){for(var n=0,i=0;i<e.length;++i)n+=t[i]*e[i];return n},Kwt=function(t,e,n){var i=n.length,r=Vwt(e+2);t[r]=255&i,t[r+1]=i>>>8,t[r+2]=255^t[r],t[r+3]=255^t[r+1];for(var s=0;s<i;++s)t[r+s+4]=n[s];return 8*(r+4+i)},Jwt=function(t,e,n,i,r,s,o,a,l,c,u){Wwt(e,u++,n),++r[256];for(var h=Qwt(r,15),d=h[0],p=h[1],f=Qwt(s,15),m=f[0],g=f[1],y=Xwt(d),v=y[0],b=y[1],A=Xwt(m),x=A[0],w=A[1],_=new Cwt(19),S=0;S<v.length;++S)_[31&v[S]]++;for(S=0;S<x.length;++S)_[31&x[S]]++;for(var E=Qwt(_,7),C=E[0],I=E[1],T=19;T>4&&!C[kwt[T-1]];--T);var M,k,R,N,L=c+5<<3,D=Ywt(r,$wt)+Ywt(s,zwt)+o,B=Ywt(r,d)+Ywt(s,m)+o+14+3*T+Ywt(_,C)+(2*_[16]+3*_[17]+7*_[18]);if(L<=D&&L<=B)return Kwt(e,u,t.subarray(l,l+c));if(Wwt(e,u,1+(B<D)),u+=2,B<D){M=Fwt(d,p,0),k=d,R=Fwt(m,g,0),N=m;var O=Fwt(C,I,0);for(Wwt(e,u,b-257),Wwt(e,u+5,w-1),Wwt(e,u+10,T-4),u+=14,S=0;S<T;++S)Wwt(e,u+3*S,C[kwt[S]]);u+=3*T;for(var P=[v,x],F=0;F<2;++F){var $=P[F];for(S=0;S<$.length;++S){var z=31&$[S];Wwt(e,u,O[z]),u+=C[z],z>15&&(Wwt(e,u,$[S]>>>5&127),u+=$[S]>>>12)}}}else M=Uwt,k=$wt,R=Hwt,N=zwt;for(S=0;S<a;++S)if(i[S]>255){jwt(e,u,M[257+(z=i[S]>>>18&31)]),u+=k[z+257],z>7&&(Wwt(e,u,i[S]>>>23&31),u+=Twt[z]);var U=31&i[S];jwt(e,u,R[U]),u+=N[U],U>3&&(jwt(e,u,i[S]>>>5&8191),u+=Mwt[U])}else jwt(e,u,M[i[S]]),u+=k[i[S]];return jwt(e,u,M[256]),u+k[256]},Zwt=new Iwt([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),t_t=new Ewt(0),e_t=function(){for(var t=new Iwt(256),e=0;e<256;++e){for(var n=e,i=9;--i;)n=(1&n&&3988292384)^n>>>1;t[e]=n}return t}(),n_t=function(){var t=-1;return{p:function(e){for(var n=t,i=0;i<e.length;++i)n=e_t[255&n^e[i]]^n>>>8;t=n},d:function(){return~t}}},i_t=function(t,e){var n={};for(var i in t)n[i]=t[i];for(var i in e)n[i]=e[i];return n},r_t=function(t,e,n){for(;n;++e)t[e]=n,n>>>=8};function s_t(t,e){return function(t,e,n,i,r){return function(t,e,n,i,r,s){var o=t.length,a=new Ewt(0+o+5*(1+Math.ceil(o/7e3))+0),l=a.subarray(0,a.length-0),c=0;if(!e||o<8)for(var u=0;u<=o;u+=65535){var h=u+65535;h<o?c=Kwt(l,c,t.subarray(u,h)):(l[u]=true,c=Kwt(l,c,t.subarray(u,o)))}else{for(var d=Zwt[e-1],p=d>>>13,f=8191&d,m=(1<<n)-1,g=new Cwt(32768),y=new Cwt(m+1),v=Math.ceil(n/3),b=2*v,A=function(e){return(t[e]^t[e+1]<<v^t[e+2]<<b)&m},x=new Iwt(25e3),w=new Cwt(288),_=new Cwt(32),S=0,E=0,C=(u=0,0),I=0,T=0;u<o;++u){var M=A(u),k=32767&u,R=y[M];if(g[k]=R,y[M]=k,I<=u){var N=o-u;if((S>7e3||C>24576)&&N>423){c=Jwt(t,l,0,x,w,_,E,C,T,u-T,c),C=S=E=0,T=u;for(var L=0;L<286;++L)w[L]=0;for(L=0;L<30;++L)_[L]=0}var D=2,B=0,O=f,P=k-R&32767;if(N>2&&M==A(u-P))for(var F=Math.min(p,N)-1,$=Math.min(32767,u),z=Math.min(258,N);P<=$&&--O&&k!=R;){if(t[u+D]==t[u+D-P]){for(var U=0;U<z&&t[u+U]==t[u+U-P];++U);if(U>D){if(D=U,B=P,U>F)break;var H=Math.min(P,U-2),V=0;for(L=0;L<H;++L){var G=u-P+L+32768&32767,W=G-g[G]+32768&32767;W>V&&(V=W,R=G)}}}P+=(k=R)-(R=g[k])+32768&32767}if(B){x[C++]=268435456|Lwt[D]<<18|Dwt[B];var j=31&Lwt[D],Q=31&Dwt[B];E+=Twt[j]+Mwt[Q],++w[257+j],++_[Q],I=u+D,++S}else x[C++]=t[u],++w[t[u]]}}c=Jwt(t,l,true,x,w,_,E,C,T,u-T,c)}return Gwt(a,0,0+Vwt(c)+0)}(t,null==e.level?6:e.level,null==e.mem?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(t.length)))):12+e.mem)}(t,e||{})}var o_t=function(t,e,n,i){for(var r in t){var s=t[r],o=e+r;s instanceof Ewt?n[o]=[s,i]:Array.isArray(s)?n[o]=[s[0],i_t(i,s[1])]:o_t(s,o+"/",n,i)}},a_t="undefined"!=typeof TextEncoder&&new TextEncoder,l_t="undefined"!=typeof TextDecoder&&new TextDecoder;try{l_t.decode(t_t,{stream:!0})}catch(Yvt){}function c_t(t,e){if(e){for(var n=new Ewt(t.length),i=0;i<t.length;++i)n[i]=t.charCodeAt(i);return n}if(a_t)return a_t.encode(t);var r=t.length,s=new Ewt(t.length+(t.length>>1)),o=0,a=function(t){s[o++]=t};for(i=0;i<r;++i){if(o+5>s.length){var l=new Ewt(o+8+(r-i<<1));l.set(s),s=l}var c=t.charCodeAt(i);c<128||e?a(c):c<2048?(a(192|c>>6),a(128|63&c)):c>55295&&c<57344?(a(240|(c=65536+(1047552&c)|1023&t.charCodeAt(++i))>>18),a(128|c>>12&63),a(128|c>>6&63),a(128|63&c)):(a(224|c>>12),a(128|c>>6&63),a(128|63&c))}return Gwt(s,0,o)}var u_t=function(t){var e=0;if(t)for(var n in t){var i=t[n].length;if(i>65535)throw"extra field too long";e+=i+4}return e},h_t=function(t,e,n,i,r,s,o,a){var l=i.length,c=n.extra,u=a&&a.length,h=u_t(c);r_t(t,e,null!=o?33639248:67324752),e+=4,null!=o&&(t[e++]=20,t[e++]=n.os),t[e]=20,e+=2,t[e++]=n.flag<<1|(null==s&&8),t[e++]=r&&8,t[e++]=255&n.compression,t[e++]=n.compression>>8;var d=new Date(null==n.mtime?Date.now():n.mtime),p=d.getFullYear()-1980;if(p<0||p>119)throw"date not in range 1980-2099";if(r_t(t,e,p<<25|d.getMonth()+1<<21|d.getDate()<<16|d.getHours()<<11|d.getMinutes()<<5|d.getSeconds()>>>1),e+=4,null!=s&&(r_t(t,e,n.crc),r_t(t,e+4,s),r_t(t,e+8,n.size)),r_t(t,e+12,l),r_t(t,e+14,h),e+=16,null!=o&&(r_t(t,e,u),r_t(t,e+6,n.attrs),r_t(t,e+10,o),e+=14),t.set(i,e),e+=l,h)for(var f in c){var m=c[f],g=m.length;r_t(t,e,+f),r_t(t,e+2,g),t.set(m,e+4),e+=4+g}return u&&(t.set(a,e),e+=u),e};class d_t{async parse(t){let e='#usda 1.0\n(\n    customLayerData = {\n        string creator = "Three.js USDZExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n';const n={},i={};t.traverse(t=>{if(t.isMesh){const r=t.geometry,s=t.material;n[s.uuid]=s,null!==s.map&&(i[s.map.uuid]=s.map),null!==s.normalMap&&(i[s.normalMap.uuid]=s.normalMap),null!==s.aoMap&&(i[s.aoMap.uuid]=s.aoMap),null!==s.roughnessMap&&(i[s.roughnessMap.uuid]=s.roughnessMap),null!==s.metalnessMap&&(i[s.metalnessMap.uuid]=s.metalnessMap),null!==s.emissiveMap&&(i[s.emissiveMap.uuid]=s.emissiveMap),e+=function(t,e){return`def Xform "${"Object_"+t.id}"\n{\n    matrix4d xformOp:transform = ${function(t){const e=t.elements;return`( ${f_t(e,0)}, ${f_t(e,4)}, ${f_t(e,8)}, ${f_t(e,12)} )`}(t.matrixWorld)}\n    uniform token[] xformOpOrder = ["xformOp:transform"]\n\n    ${e}\n}\n\n`}(t,function(t,e){const n="Geometry_"+t.id,i=t.attributes,r=i.position.count;return"uv2"in i&&console.warn("THREE.USDZExporter: uv2 not supported yet."),`def Mesh "${n}"\n    {\n        int[] faceVertexCounts = [${function(t){return Array((null!==t.index?t.index.array.length:t.attributes.position.count)/3).fill(3).join(", ")}(t)}]\n        int[] faceVertexIndices = [${function(t){if(null!==t.index)return t.index.array.join(", ");const e=[],n=t.attributes.position.count;for(let i=0;i<n;i++)e.push(i);return e.join(", ")}(t)}]\n        rel material:binding = </Materials/Material_${e.id}>\n        normal3f[] normals = [${m_t(i.normal,r)}] (\n            interpolation = "vertex"\n        )\n        point3f[] points = [${m_t(i.position,r)}]\n        float2[] primvars:st = [${function(t,e){if(void 0===t)return console.warn("USDZExporter: UVs missing."),Array(e).fill("(0, 0)").join(", ");const n=[],i=t.array;for(let r=0;r<i.length;r+=2)n.push(`(${i[r+0].toPrecision(7)}, ${1-i[r+1].toPrecision(7)})`);return n.join(", ")}(i.uv,r)}] (\n            interpolation = "vertex"\n        )\n        uniform token subdivisionScheme = "none"\n    }\n`}(r,s))}}),e+=function(t){const e=[];for(const n in t)e.push(g_t(t[n]));return`def "Materials"\n{\n${e.join("")}\n}\n\n`}(n),e+=function(t){const e=[];for(const n in t)e.push(y_t(t[n]));return`def "Textures"\n{\n${e.join("")}\n}\n\n`}(i);const r={"model.usda":c_t(e)};for(const o in i){const t=i[o];r["textures/Texture_"+t.id+".jpg"]=await p_t(t.image)}let s=0;for(const o in r){const t=r[o];s+=34+o.length;const e=63&s;if(4!==e){const n=new Uint8Array(64-e);r[o]=[t,{extra:{12345:n}}]}s=t.length}return function(t,e){e||(e={});var n={},i=[];o_t(t,"",n,e);var r=0,s=0;for(var o in n){var a=n[o],l=a[0],c=a[1],u=0==c.level?0:8,h=(_=c_t(o)).length,d=c.comment,p=d&&c_t(d),f=p&&p.length,m=u_t(c.extra);if(h>65535)throw"filename too long";var g=u?s_t(l,c):l,y=g.length,v=n_t();v.p(l),i.push(i_t(c,{size:l.length,crc:v.d(),c:g,f:_,m:p,u:h!=o.length||p&&d.length!=f,o:r,compression:u})),r+=30+h+m+y,s+=76+2*(h+m)+(f||0)+y}for(var b=new Ewt(s+22),A=r,x=s-r,w=0;w<i.length;++w){var _=i[w];h_t(b,_.o,_,_.f,_.u,_.c.length);var S=30+_.f.length+u_t(_.extra);b.set(_.c,_.o+S),h_t(b,r,_,_.f,_.u,_.c.length,_.o,_.m),r+=16+S+(_.m?_.m.length:0)}return function(t,e,n,i,r){r_t(t,e,101010256),r_t(t,e+8,n),r_t(t,e+10,n),r_t(t,e+12,i),r_t(t,e+16,r)}(b,r,i.length,x,A),b}(r,{level:0})}}async function p_t(t){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const e=1024/Math.max(t.width,t.height),n=document.createElement("canvas");n.width=t.width*Math.min(1,e),n.height=t.height*Math.min(1,e),n.getContext("2d").drawImage(t,0,0,n.width,n.height);const i=await new Promise(t=>n.toBlob(t,"image/jpeg",1));return new Uint8Array(await i.arrayBuffer())}}function f_t(t,e){return`(${t[e+0]}, ${t[e+1]}, ${t[e+2]}, ${t[e+3]})`}function m_t(t,e){if(void 0===t)return console.warn("USDZExporter: Normals missing."),Array(e).fill("(0, 0, 0)").join(", ");const n=[],i=t.array;for(let r=0;r<i.length;r+=3)n.push(`(${i[r+0].toPrecision(7)}, ${i[r+1].toPrecision(7)}, ${i[r+2].toPrecision(7)})`);return n.join(", ")}function g_t(t){const e="            ",n=[];return n.push(null!==t.map?`${e}color3f inputs:diffuseColor.connect = </Textures/Texture_${t.map.id}.outputs:rgb>`:`${e}color3f inputs:diffuseColor = ${v_t(t.color)}`),null!==t.emissiveMap?n.push(`${e}color3f inputs:emissiveColor.connect = </Textures/Texture_${t.emissiveMap.id}.outputs:rgb>`):t.emissive.getHex()>0&&n.push(`${e}color3f inputs:emissiveColor = ${v_t(t.emissive)}`),null!==t.normalMap&&n.push(`${e}normal3f inputs:normal.connect = </Textures/Texture_${t.normalMap.id}.outputs:rgb>`),null!==t.aoMap&&n.push(`${e}float inputs:occlusion.connect = </Textures/Texture_${t.aoMap.id}.outputs:r>`),n.push(null!==t.roughnessMap?`${e}float inputs:roughness.connect = </Textures/Texture_${t.roughnessMap.id}.outputs:g>`:`${e}float inputs:roughness = ${t.roughness}`),n.push(null!==t.metalnessMap?`${e}float inputs:metallic.connect = </Textures/Texture_${t.metalnessMap.id}.outputs:b>`:`${e}float inputs:metallic = ${t.metalness}`),`\n    def Material "Material_${t.id}"\n    {\n        token outputs:surface.connect = </Materials/Material_${t.id}/PreviewSurface.outputs:surface>\n\n        def Shader "PreviewSurface"\n        {\n            uniform token info:id = "UsdPreviewSurface"\n${n.join("\n")}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n    }\n`}function y_t(t){return`\n    def Shader "Texture_${t.id}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${t.id}.jpg@\n        token inputs:wrapS = "repeat"\n        token inputs:wrapT = "repeat"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n    }\n`}function v_t(t){return`(${t.r}, ${t.g}, ${t.b})`}var b_t=function(t,e,n,i){for(var r,s=arguments.length,o=s<3?e:null===i?i=Object.getOwnPropertyDescriptor(e,n):i,a=t.length-1;a>=0;a--)(r=t[a])&&(o=(s<3?r(o):s>3?r(e,n,o):r(e,n))||o);return s>3&&o&&Object.defineProperty(e,n,o),o};let A_t=!1,x_t=!1;const w_t=(__t=["quick-look","scene-viewer","webxr","none"],t=>{try{const e=eAt(t),n=(e.length?e[0].terms:[]).filter(t=>t&&"ident"===t.type).map(t=>t.value).filter(t=>__t.indexOf(t)>-1),i=new Set;for(const t of n)i.add(t);return i}catch(t){}return new Set});var __t;const S_t="quick-look",E_t="scene-viewer",C_t="webxr",I_t="none",T_t=Symbol("arButtonContainer"),M_t=Symbol("enterARWithWebXR"),k_t=Symbol("openSceneViewer"),R_t=Symbol("openIOSARQuickLook"),N_t=Symbol("canActivateAR"),L_t=Symbol("arMode"),D_t=Symbol("arModes"),B_t=Symbol("arAnchor"),O_t=Symbol("preload"),P_t=Symbol("onARButtonContainerClick"),F_t=Symbol("onARStatus"),$_t=Symbol("onARTracking"),z_t=Symbol("onARTap"),U_t=Symbol("selectARMode"),H_t=Symbol("triggerLoad");var V_t,G_t,W_t;const j_t=Symbol("evaluate"),Q_t=Symbol("lastValue");class q_t{constructor(){this[V_t]=null}static evaluatableFor(t,e=cAt){if(t instanceof q_t)return t;if("number"===t.type)return"%"===t.unit?new K_t(t,e):t;switch(t.name.value){case"calc":return new nSt(t,e);case"env":return new Z_t(t)}return cAt}static evaluate(t){return t instanceof q_t?t.evaluate():t}static isConstant(t){return!(t instanceof q_t)||t.isConstant}static applyIntrinsics(t,e){const{basis:n,keywords:i}=e,{auto:r}=i;return n.map((e,n)=>{const s=null==r[n]?e:r[n];let o=t[n]?t[n]:s;if("ident"===o.type){const t=o.value;t in i&&(o=i[t][n])}return null!=o&&"ident"!==o.type||(o=s),"%"===o.unit?tAt(o.number/100*e.number,e.unit):(o=dAt(o,e),o.unit!==e.unit?e:o)})}get isConstant(){return!1}evaluate(){return this.isConstant&&null!=this[Q_t]||(this[Q_t]=this[j_t]()),this[Q_t]}}V_t=Q_t;const X_t=Symbol("percentage"),Y_t=Symbol("basis");class K_t extends q_t{constructor(t,e){super(),this[X_t]=t,this[Y_t]=e}get isConstant(){return!0}[j_t](){return tAt(this[X_t].number/100*this[Y_t].number,this[Y_t].unit)}}const J_t=Symbol("identNode");class Z_t extends q_t{constructor(t){super(),this[G_t]=null;const e=t.arguments.length?t.arguments[0].terms[0]:null;null!=e&&"ident"===e.type&&(this[J_t]=e)}get isConstant(){return!1}[(G_t=J_t,j_t)](){if(null!=this[J_t])switch(this[J_t].value){case"window-scroll-y":return{type:"number",number:window.pageYOffset/(Math.max(document.body.scrollHeight,document.body.offsetHeight,document.documentElement.clientHeight,document.documentElement.scrollHeight,document.documentElement.offsetHeight)-window.innerHeight)||0,unit:null}}return cAt}}const tSt=/[\*\/]/,eSt=Symbol("evalutor");class nSt extends q_t{constructor(t,e=cAt){if(super(),this[W_t]=null,1!==t.arguments.length)return;const n=t.arguments[0].terms.slice(),i=[];for(;n.length;){const t=n.shift();if(i.length>0){const n=i[i.length-1];if("operator"===n.type&&tSt.test(n.value)){const n=i.pop(),r=i.pop();if(null==r)return;i.push(new oSt(n,q_t.evaluatableFor(r,e),q_t.evaluatableFor(t,e)));continue}}i.push("operator"===t.type?t:q_t.evaluatableFor(t,e))}for(;i.length>2;){const[t,n,r]=i.splice(0,3);if("operator"!==n.type)return;i.unshift(new oSt(n,q_t.evaluatableFor(t,e),q_t.evaluatableFor(r,e)))}1===i.length&&(this[eSt]=i[0])}get isConstant(){return null==this[eSt]||q_t.isConstant(this[eSt])}[(W_t=eSt,j_t)](){return null!=this[eSt]?q_t.evaluate(this[eSt]):cAt}}const iSt=Symbol("operator"),rSt=Symbol("left"),sSt=Symbol("right");class oSt extends q_t{constructor(t,e,n){super(),this[iSt]=t,this[rSt]=e,this[sSt]=n}get isConstant(){return q_t.isConstant(this[rSt])&&q_t.isConstant(this[sSt])}[j_t](){const t=dAt(q_t.evaluate(this[rSt])),e=dAt(q_t.evaluate(this[sSt])),{number:n,unit:i}=t,{number:r,unit:s}=e;if(null!=s&&null!=i&&s!=i)return cAt;const o=i||s;let a;switch(this[iSt].value){case"+":a=n+r;break;case"-":a=n-r;break;case"/":a=n/r;break;case"*":a=n*r;break;default:return cAt}return{type:"number",number:a,unit:o}}}const aSt=Symbol("evaluatables"),lSt=Symbol("intrinsics");class cSt extends q_t{constructor(t,e){super(),this[lSt]=e;const n=t[0],i=null!=n?n.terms:[];this[aSt]=e.basis.map((t,e)=>{const n=i[e];return null==n?{type:"ident",value:"auto"}:"ident"===n.type?n:q_t.evaluatableFor(n,t)})}get isConstant(){for(const t of this[aSt])if(!q_t.isConstant(t))return!1;return!0}[j_t](){const t=this[aSt].map(t=>q_t.evaluate(t));return q_t.applyIntrinsics(t,this[lSt]).map(t=>t.number)}}var uSt,hSt,dSt,pSt;const fSt=Symbol("instances"),mSt=Symbol("activateListener"),gSt=Symbol("deactivateListener"),ySt=Symbol("notifyInstances"),vSt=Symbol("notify"),bSt=Symbol("callback");class ASt{constructor(t){this[bSt]=t}static[ySt](){for(const t of ASt[fSt])t[vSt]()}static[(uSt=fSt,mSt)](){window.addEventListener("scroll",this[ySt],{passive:!0})}static[gSt](){window.removeEventListener("scroll",this[ySt])}observe(){0===ASt[fSt].size&&ASt[mSt](),ASt[fSt].add(this)}disconnect(){ASt[fSt].delete(this),0===ASt[fSt].size&&ASt[gSt]()}[vSt](){this[bSt]()}}ASt[uSt]=new Set;const xSt=Symbol("computeStyleCallback"),wSt=Symbol("astWalker"),_St=Symbol("dependencies"),SSt=Symbol("onScroll");class ESt{constructor(t){this[hSt]={},this[dSt]=new lAt(["function"]),this[pSt]=()=>{this[xSt]({relatedState:"window-scroll"})},this[xSt]=t}observeEffectsFor(t){const e={},n=this[_St];this[wSt].walk(t,t=>{const{name:i}=t,r=t.arguments[0].terms[0];if("env"===i.value&&null!=r&&"ident"===r.type)switch(r.value){case"window-scroll-y":if(null==e["window-scroll"]){const t="window-scroll"in n?n["window-scroll"]:new ASt(this[SSt]);t.observe(),delete n["window-scroll"],e["window-scroll"]=t}}});for(const i in n)n[i].disconnect();this[_St]=e}dispose(){for(const t in this[_St])this[_St][t].disconnect()}}hSt=_St,dSt=wSt,pSt=SSt;const CSt=t=>{const e=t.observeEffects||!1,n=t.intrinsics instanceof Function?t.intrinsics:()=>t.intrinsics;return(i,r)=>{const s=i.updated,o=i.connectedCallback,a=i.disconnectedCallback,l=Symbol(`${r}StyleEffector`),c=Symbol(`${r}StyleEvaluator`),u=Symbol(`${r}UpdateEvaluator`),h=Symbol(`${r}EvaluateAndSync`);Object.defineProperties(i,{[l]:{value:null,writable:!0},[c]:{value:null,writable:!0},[u]:{value:function(){const t=eAt(this[r]);this[c]=new cSt(t,n(this)),null==this[l]&&e&&(this[l]=new ESt(()=>this[h]())),null!=this[l]&&this[l].observeEffectsFor(t)}},[h]:{value:function(){if(null==this[c])return;const e=this[c].evaluate();this[t.updateHandler](e)}},updated:{value:function(t){t.has(r)&&(this[u](),this[h]()),s.call(this,t)}},connectedCallback:{value:function(){o.call(this),this.requestUpdate(r,this[r])}},disconnectedCallback:{value:function(){a.call(this),null!=this[l]&&(this[l].dispose(),this[l]=null)}}})}},ISt=Object.freeze({minimumRadius:0,maximumRadius:1/0,minimumPolarAngle:Math.PI/8,maximumPolarAngle:Math.PI-Math.PI/8,minimumAzimuthalAngle:-1/0,maximumAzimuthalAngle:1/0,minimumFieldOfView:10,maximumFieldOfView:45,interactionPolicy:"always-allow",touchAction:"pan-y"}),TSt=/^touch(start|end|move)$/,MSt=Math.PI/8,kSt="user-interaction";class RSt extends Uut{constructor(t,e){super(),this.camera=t,this.element=e,this.sensitivity=1,this._interactionEnabled=!1,this._disableZoom=!1,this.isUserChange=!1,this.isUserPointing=!1,this.spherical=new Dyt,this.goalSpherical=new Dyt,this.thetaDamper=new Zbt,this.phiDamper=new Zbt,this.radiusDamper=new Zbt,this.logFov=Math.log(ISt.maximumFieldOfView),this.goalLogFov=this.logFov,this.fovDamper=new Zbt,this.pointerIsDown=!1,this.lastPointerPosition={clientX:0,clientY:0},this.touchMode="rotate",this.touchDecided=!1,this.onPointerMove=t=>{if(this.pointerIsDown&&this.canInteract){if(TSt.test(t.type)){const{touches:e}=t;switch(this.touchMode){case"zoom":if(this.lastTouches.length>1&&e.length>1){const t=.04*(this.twoTouchDistance(this.lastTouches[0],this.lastTouches[1])-this.twoTouchDistance(e[0],e[1]))/10;this.userAdjustOrbit(0,0,t)}break;case"rotate":const{touchAction:t}=this._options;if(!this.touchDecided&&"none"!==t){this.touchDecided=!0;const{clientX:n,clientY:i}=e[0],r=Math.abs(n-this.lastPointerPosition.clientX),s=Math.abs(i-this.lastPointerPosition.clientY);if("pan-y"===t&&s>r||"pan-x"===t&&r>s)return void(this.touchMode="scroll")}this.handleSinglePointerMove(e[0]);break;case"scroll":return}this.lastTouches=e}else this.handleSinglePointerMove(t);t.cancelable&&t.preventDefault()}},this.onPointerDown=t=>{if(this.pointerIsDown=!0,this.isUserPointing=!1,TSt.test(t.type)){const{touches:e}=t;switch(this.touchDecided=!1,e.length){default:case 1:this.touchMode="rotate",this.handleSinglePointerDown(e[0]);break;case 2:this.touchMode=this._disableZoom?"scroll":"zoom"}this.lastTouches=e}else this.handleSinglePointerDown(t)},this.onPointerUp=t=>{this.element.style.cursor="grab",this.pointerIsDown=!1,this.isUserPointing&&this.dispatchEvent({type:"pointer-change-end",pointer:Object.assign({},this.lastPointerPosition)})},this.onWheel=t=>{this.canInteract&&(this.userAdjustOrbit(0,0,t.deltaY*(1==t.deltaMode?18:1)*.04/30),t.cancelable&&t.preventDefault())},this.onKeyDown=t=>{let e=!1;switch(t.keyCode){case 33:e=!0,this.userAdjustOrbit(0,0,.04);break;case 34:e=!0,this.userAdjustOrbit(0,0,-.04);break;case 38:e=!0,this.userAdjustOrbit(0,-MSt,0);break;case 40:e=!0,this.userAdjustOrbit(0,MSt,0);break;case 37:e=!0,this.userAdjustOrbit(-MSt,0,0);break;case 39:e=!0,this.userAdjustOrbit(MSt,0,0)}e&&t.cancelable&&t.preventDefault()},this._options=Object.assign({},ISt),this.setOrbit(0,Math.PI/2,1),this.setFieldOfView(100),this.jumpToGoal()}get interactionEnabled(){return this._interactionEnabled}enableInteraction(){if(!1===this._interactionEnabled){const{element:t}=this;t.addEventListener("mousemove",this.onPointerMove),t.addEventListener("mousedown",this.onPointerDown),this._disableZoom||t.addEventListener("wheel",this.onWheel),t.addEventListener("keydown",this.onKeyDown),t.addEventListener("touchstart",this.onPointerDown,{passive:!0}),t.addEventListener("touchmove",this.onPointerMove),self.addEventListener("mouseup",this.onPointerUp),self.addEventListener("touchend",this.onPointerUp),this.element.style.cursor="grab",this._interactionEnabled=!0}}disableInteraction(){if(!0===this._interactionEnabled){const{element:t}=this;t.removeEventListener("mousemove",this.onPointerMove),t.removeEventListener("mousedown",this.onPointerDown),this._disableZoom||t.removeEventListener("wheel",this.onWheel),t.removeEventListener("keydown",this.onKeyDown),t.removeEventListener("touchstart",this.onPointerDown),t.removeEventListener("touchmove",this.onPointerMove),self.removeEventListener("mouseup",this.onPointerUp),self.removeEventListener("touchend",this.onPointerUp),t.style.cursor="",this._interactionEnabled=!1}}get options(){return this._options}set disableZoom(t){this._disableZoom!=t&&(this._disableZoom=t,!0===t?this.element.removeEventListener("wheel",this.onWheel):this.element.addEventListener("wheel",this.onWheel))}getCameraSpherical(t=new Dyt){return t.copy(this.spherical)}getFieldOfView(){return this.camera.fov}applyOptions(t){Object.assign(this._options,t),this.setOrbit(),this.setFieldOfView(Math.exp(this.goalLogFov))}updateNearFar(t,e){this.camera.near=Math.max(t,e/1e3),this.camera.far=e,this.camera.updateProjectionMatrix()}updateAspect(t){this.camera.aspect=t,this.camera.updateProjectionMatrix()}setOrbit(t=this.goalSpherical.theta,e=this.goalSpherical.phi,n=this.goalSpherical.radius){const{minimumAzimuthalAngle:i,maximumAzimuthalAngle:r,minimumPolarAngle:s,maximumPolarAngle:o,minimumRadius:a,maximumRadius:l}=this._options,{theta:c,phi:u,radius:h}=this.goalSpherical,d=Ybt(t,i,r);isFinite(i)||isFinite(r)||(this.spherical.theta=this.wrapAngle(this.spherical.theta-d)+d);const p=Ybt(e,s,o),f=Ybt(n,a,l);return(d!==c||p!==u||f!==h)&&(this.goalSpherical.theta=d,this.goalSpherical.phi=p,this.goalSpherical.radius=f,this.goalSpherical.makeSafe(),this.isUserChange=!1,!0)}setRadius(t){this.goalSpherical.radius=t,this.setOrbit()}setFieldOfView(t){const{minimumFieldOfView:e,maximumFieldOfView:n}=this._options;t=Ybt(t,e,n),this.goalLogFov=Math.log(t)}setDamperDecayTime(t){this.thetaDamper.setDecayTime(t),this.phiDamper.setDecayTime(t),this.radiusDamper.setDecayTime(t),this.fovDamper.setDecayTime(t)}adjustOrbit(t,e,n){const{theta:i,phi:r,radius:s}=this.goalSpherical,{minimumRadius:o,maximumRadius:a,minimumFieldOfView:l,maximumFieldOfView:c}=this._options,u=this.spherical.theta-i,h=Math.PI-.001,d=i-Ybt(t,-h-u,h-u),p=r-e,f=0===n?0:n>0?(a-s)/(Math.log(c)-this.goalLogFov):(s-o)/(this.goalLogFov-Math.log(l)),m=s+n*Math.min(isFinite(f)?f:1/0,a-o);this.setOrbit(d,p,m),0!==n&&this.setFieldOfView(Math.exp(this.goalLogFov+n))}jumpToGoal(){this.update(0,1e4)}update(t,e){if(this.isStationary())return;const{maximumPolarAngle:n,maximumRadius:i}=this._options,r=this.spherical.theta-this.goalSpherical.theta;Math.abs(r)>Math.PI&&!isFinite(this._options.minimumAzimuthalAngle)&&!isFinite(this._options.maximumAzimuthalAngle)&&(this.spherical.theta-=2*Math.sign(r)*Math.PI),this.spherical.theta=this.thetaDamper.update(this.spherical.theta,this.goalSpherical.theta,e,Math.PI),this.spherical.phi=this.phiDamper.update(this.spherical.phi,this.goalSpherical.phi,e,n),this.spherical.radius=this.radiusDamper.update(this.spherical.radius,this.goalSpherical.radius,e,i),this.logFov=this.fovDamper.update(this.logFov,this.goalLogFov,e,1),this.moveCamera()}isStationary(){return this.goalSpherical.theta===this.spherical.theta&&this.goalSpherical.phi===this.spherical.phi&&this.goalSpherical.radius===this.spherical.radius&&this.goalLogFov===this.logFov}moveCamera(){this.spherical.makeSafe(),this.camera.position.setFromSpherical(this.spherical),this.camera.setRotationFromEuler(new Kht(this.spherical.phi-Math.PI/2,this.spherical.theta,0,"YXZ")),this.camera.fov!==Math.exp(this.logFov)&&(this.camera.fov=Math.exp(this.logFov),this.camera.updateProjectionMatrix()),this.dispatchEvent({type:"change",source:this.isUserChange?kSt:"none"})}get canInteract(){return"allow-when-focused"==this._options.interactionPolicy?this.element.getRootNode().activeElement===this.element:"always-allow"===this._options.interactionPolicy}userAdjustOrbit(t,e,n){this.adjustOrbit(t*this.sensitivity,e*this.sensitivity,n),this.isUserChange=!0,this.dispatchEvent({type:"change",source:kSt})}wrapAngle(t){const e=(t+Math.PI)/(2*Math.PI);return 2*(e-Math.floor(e))*Math.PI-Math.PI}pixelLengthToSphericalAngle(t){return 2*Math.PI*t/this.element.clientHeight}twoTouchDistance(t,e){const{clientX:n,clientY:i}=t,{clientX:r,clientY:s}=e,o=r-n,a=s-i;return Math.sqrt(o*o+a*a)}handleSinglePointerMove(t){const{clientX:e,clientY:n}=t,i=this.pixelLengthToSphericalAngle(e-this.lastPointerPosition.clientX),r=this.pixelLengthToSphericalAngle(n-this.lastPointerPosition.clientY);this.lastPointerPosition.clientX=e,this.lastPointerPosition.clientY=n,!1===this.isUserPointing&&(this.isUserPointing=!0,this.dispatchEvent({type:"pointer-change-start",pointer:Object.assign({},t)})),this.userAdjustOrbit(i,r,0)}handleSinglePointerDown(t){this.lastPointerPosition.clientX=t.clientX,this.lastPointerPosition.clientY=t.clientY,this.element.style.cursor="grabbing"}}const NSt=t=>t<.5?2*t*t:(4-2*t)*t-1,LSt=(t,e,n=NSt)=>i=>t+(e-t)*n(i),DSt=(t,e)=>{const n=[],i=[];let r=t;for(let s=0;s<e.length;++s){const t=e[s],{value:o,frames:a}=t,l=LSt(r,o,t.ease||NSt);n.push(l),i.push(a),r=o}return((t,e)=>{const n=e.reduce((t,e)=>t+e,0),i=e.map(t=>t/n);return e=>{let n=0,r=1/0,s=()=>0;for(let o=0;o<i.length&&(r=i[o],s=t[o],!(e<=n+r));++o)n+=r;return s((e-n)/r)}})(n,i)};var BSt=function(t,e,n,i){for(var r,s=arguments.length,o=s<3?e:null===i?i=Object.getOwnPropertyDescriptor(e,n):i,a=t.length-1;a>=0;a--)(r=t[a])&&(o=(s<3?r(o):s>3?r(e,n,o):r(e,n))||o);return s>3&&o&&Object.defineProperty(e,n,o),o};const OSt=DSt(0,[{frames:5,value:-1},{frames:1,value:-1},{frames:8,value:1},{frames:1,value:1},{frames:5,value:0},{frames:18,value:0}]),PSt=DSt(0,[{frames:1,value:1},{frames:5,value:1},{frames:1,value:0},{frames:6,value:0}]),FSt=1.1*yAt,$St=["front","right","back","left"],zSt=["upper-","","lower-"],USt="auto",HSt="when-focused",VSt="wiggle",GSt=t=>({basis:[tAt(t[gEt]*Math.PI/180,"rad")],keywords:{auto:[null]}}),WSt={basis:[uAt(tAt(25,"deg"))],keywords:{auto:[null]}},jSt=t=>{const e=t[Zxt];return{basis:[uAt(tAt(45,"deg"))],keywords:{auto:[tAt(e.framedFieldOfView,"deg")]}}},QSt=(()=>{const t=eAt("0deg 75deg 105%")[0].terms,e=dAt(t[0]),n=dAt(t[1]);return t=>({basis:[e,n,tAt(t[Zxt].idealCameraDistance,"m")],keywords:{auto:[null,null,tAt(105,"%")]}})})(),qSt=t=>{const e=FSt*t[Zxt].idealCameraDistance;return{basis:[tAt(-1/0,"rad"),tAt(Math.PI/8,"rad"),tAt(e,"m")],keywords:{auto:[null,null,null]}}},XSt=t=>{const e=QSt(t),n=new cSt([],e).evaluate()[2];return{basis:[tAt(1/0,"rad"),tAt(Math.PI-Math.PI/8,"rad"),tAt(n,"m")],keywords:{auto:[null,null,null]}}},YSt=t=>{const e=t[Zxt].boundingBox.getCenter(new uht);return{basis:[tAt(e.x,"m"),tAt(e.y,"m"),tAt(e.z,"m")],keywords:{auto:[null,null,null]}}},KSt=Math.PI/2,JSt=Math.PI/3,ZSt=KSt/2,tEt=2*Math.PI,eEt=Symbol("controls"),nEt=Symbol("promptElement"),iEt=Symbol("promptAnimatedContainer"),rEt=Symbol("deferInteractionPrompt"),sEt=Symbol("updateAria"),oEt=Symbol("updateCameraForRadius"),aEt=Symbol("onBlur"),lEt=Symbol("onFocus"),cEt=Symbol("onChange"),uEt=Symbol("onPointerChange"),hEt=Symbol("waitingToPromptUser"),dEt=Symbol("userHasInteracted"),pEt=Symbol("promptElementVisibleTime"),fEt=Symbol("lastPromptOffset"),mEt=Symbol("focusedTime"),gEt=Symbol("zoomAdjustedFieldOfView"),yEt=Symbol("lastSpherical"),vEt=Symbol("jumpCamera"),bEt=Symbol("initialized"),AEt=Symbol("maintainThetaPhi"),xEt=Symbol("syncCameraOrbit"),wEt=Symbol("syncFieldOfView"),_Et=Symbol("syncCameraTarget"),SEt=Symbol("syncMinCameraOrbit"),EEt=Symbol("syncMaxCameraOrbit"),CEt=Symbol("syncMinFieldOfView"),IEt=Symbol("syncMaxFieldOfView");var TEt=function(t,e,n,i){for(var r,s=arguments.length,o=s<3?e:null===i?i=Object.getOwnPropertyDescriptor(e,n):i,a=t.length-1;a>=0;a--)(r=t[a])&&(o=(s<3?r(o):s>3?r(e,n,o):r(e,n))||o);return s>3&&o&&Object.defineProperty(e,n,o),o};const MEt=Symbol("currentEnvironmentMap"),kEt=Symbol("applyEnvironmentMap"),REt=Symbol("updateEnvironment"),NEt=Symbol("cancelEnvironmentUpdate"),LEt=Symbol("onPreload");var DEt,BEt;const OEt=Symbol("modelViewerStatusInstance"),PEt=Symbol("updateStatus");DEt=OEt,BEt=PEt;var FEt=function(t,e,n,i){for(var r,s=arguments.length,o=s<3?e:null===i?i=Object.getOwnPropertyDescriptor(e,n):i,a=t.length-1;a>=0;a--)(r=t[a])&&(o=(s<3?r(o):s>3?r(e,n,o):r(e,n))||o);return s>3&&o&&Object.defineProperty(e,n,o),o};const $Et="auto",zEt="manual",UEt=new class extends Uut{constructor(){super(),this[DEt]=null,this.registeredInstanceStatuses=new Map,this.loadingPromises=[],this.statusElement=document.createElement("p"),this.statusUpdateInProgress=!1,this[BEt]=Xbt(()=>this.updateStatus(),100);const{statusElement:t}=this,{style:e}=t;t.setAttribute("role","status"),t.classList.add("screen-reader-only"),e.top=e.left="0",e.pointerEvents="none"}registerInstance(t){if(this.registeredInstanceStatuses.has(t))return;let e=()=>{};const n=!1===t.loaded&&!!t.src,i=new Promise(i=>{if(!n)return void i();const r=()=>{i(),t.removeEventListener("load",r),t.removeEventListener("error",r)};t.addEventListener("load",r),t.addEventListener("error",r),e=r});this.registeredInstanceStatuses.set(t,{onUnregistered:e}),this.loadingPromises.push(i),null==this.modelViewerStatusInstance&&(this.modelViewerStatusInstance=t)}unregisterInstance(t){if(!this.registeredInstanceStatuses.has(t))return;const e=this.registeredInstanceStatuses,n=e.get(t);e.delete(t),n.onUnregistered(),this.modelViewerStatusInstance===t&&(this.modelViewerStatusInstance=e.size>0?(t=>{if(null!=t.keys)return t.keys().next().value||null;let e=null;try{t.forEach((t,n,i)=>{throw e=n,new Error})}catch(t){}return e})(e):null)}get modelViewerStatusInstance(){return this[OEt]}set modelViewerStatusInstance(t){if(this[OEt]===t)return;const{statusElement:e}=this;null!=t&&null!=t.shadowRoot?t.shadowRoot.appendChild(e):null!=e.parentNode&&e.parentNode.removeChild(e),this[OEt]=t,this[PEt]()}async updateStatus(){if(!this.statusUpdateInProgress&&0!==this.loadingPromises.length){for(this.statusElement.textContent="This page includes one or more 3D models that are loading",this.statusUpdateInProgress=!0,this.dispatchEvent({type:"initial-status-announced"});this.loadingPromises.length;){const{loadingPromises:t}=this;this.loadingPromises=[],await Promise.all(t)}this.statusElement.textContent="All 3D models in the page have loaded",this.statusUpdateInProgress=!1,this.dispatchEvent({type:"finished-loading-announced"})}}},HEt=Symbol("defaultProgressBarElement"),VEt=Symbol("defaultProgressMaskElement"),GEt=Symbol("posterContainerElement"),WEt=Symbol("defaultPosterElement"),jEt=Symbol("posterDismissalSource"),QEt=Symbol("hidePoster"),qEt=Symbol("modelIsRevealed"),XEt=Symbol("updateProgressBar"),YEt=Symbol("lastReportedProgress"),KEt=Symbol("transitioned"),JEt=Symbol("ariaLabelCallToAction"),ZEt=Symbol("onClick"),tCt=Symbol("onKeydown"),eCt=Symbol("onProgress");class nCt{constructor(){this.pluginCallbacks=[],this.register(function(t){return new dCt(t)}),this.register(function(t){return new pCt(t)}),this.register(function(t){return new fCt(t)})}register(t){return-1===this.pluginCallbacks.indexOf(t)&&this.pluginCallbacks.push(t),this}unregister(t){return-1!==this.pluginCallbacks.indexOf(t)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t),1),this}parse(t,e,n){const i=new hCt,r=[];for(let s=0,o=this.pluginCallbacks.length;s<o;s++)r.push(this.pluginCallbacks[s](i));i.setPlugins(r),i.write(t,e,n)}}const iCt=5121,rCt=5123,sCt={1003:9728,1004:9984,1005:9986,1006:9729,1007:9985,1008:9987,1001:33071,1e3:10497,1002:33648},oCt={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"};function aCt(t,e){return t.length===e.length&&t.every(function(t,n){return t===e[n]})}function lCt(t){return 4*Math.ceil(t/4)}function cCt(t,e=0){const n=lCt(t.byteLength);if(n!==t.byteLength){const i=new Uint8Array(n);if(i.set(new Uint8Array(t)),0!==e)for(let r=t.byteLength;r<n;r++)i[r]=e;return i.buffer}return t}let uCt=null;class hCt{constructor(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"THREE.GLTFExporter"}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map}}setPlugins(t){this.plugins=t}write(t,e,n){this.options=Object.assign({},{binary:!1,trs:!1,onlyVisible:!0,truncateDrawRange:!0,embedImages:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},n),this.options.animations.length>0&&(this.options.trs=!0),this.processInput(t);const i=this;Promise.all(this.pending).then(function(){const t=i.json,n=i.options,r=i.extensionsUsed,s=new Blob(i.buffers,{type:"application/octet-stream"}),o=Object.keys(r);if(o.length>0&&(t.extensionsUsed=o),t.buffers&&t.buffers.length>0&&(t.buffers[0].byteLength=s.size),!0===n.binary){const n=new window.FileReader;n.readAsArrayBuffer(s),n.onloadend=function(){const i=cCt(n.result),r=new DataView(new ArrayBuffer(8));r.setUint32(0,i.byteLength,!0),r.setUint32(4,5130562,!0);const s=cCt(function(t){if(void 0!==window.TextEncoder)return(new TextEncoder).encode(t).buffer;const e=new Uint8Array(new ArrayBuffer(t.length));for(let n=0,i=t.length;n<i;n++){const i=t.charCodeAt(n);e[n]=i>255?32:i}return e.buffer}(JSON.stringify(t)),32),o=new DataView(new ArrayBuffer(8));o.setUint32(0,s.byteLength,!0),o.setUint32(4,1313821514,!0);const a=new ArrayBuffer(12),l=new DataView(a);l.setUint32(0,1179937895,!0),l.setUint32(4,2,!0),l.setUint32(8,12+o.byteLength+s.byteLength+r.byteLength+i.byteLength,!0);const c=new Blob([a,o,s,r,i],{type:"application/octet-stream"}),u=new window.FileReader;u.readAsArrayBuffer(c),u.onloadend=function(){e(u.result)}}}else if(t.buffers&&t.buffers.length>0){const n=new window.FileReader;n.readAsDataURL(s),n.onloadend=function(){t.buffers[0].uri=n.result,e(t)}}else e(t)})}serializeUserData(t,e){if(0===Object.keys(t.userData).length)return;const n=this.options,i=this.extensionsUsed;try{const r=JSON.parse(JSON.stringify(t.userData));if(n.includeCustomExtensions&&r.gltfExtensions){void 0===e.extensions&&(e.extensions={});for(const t in r.gltfExtensions)e.extensions[t]=r.gltfExtensions[t],i[t]=!0;delete r.gltfExtensions}Object.keys(r).length>0&&(e.extras=r)}catch(e){console.warn("THREE.GLTFExporter: userData of '"+t.name+"' won't be serialized because of JSON.stringify error - "+e.message)}}getUID(t){return this.uids.has(t)||this.uids.set(t,this.uid++),this.uids.get(t)}isNormalizedNormalAttribute(t){if(this.cache.attributesNormalized.has(t))return!1;const e=new uht;for(let n=0,i=t.count;n<i;n++)if(Math.abs(e.fromBufferAttribute(t,n).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(t){const e=this.cache;if(e.attributesNormalized.has(t))return e.attributesNormalized.get(t);const n=t.clone(),i=new uht;for(let r=0,s=n.count;r<s;r++)i.fromBufferAttribute(n,r),0===i.x&&0===i.y&&0===i.z?i.setX(1):i.normalize(),n.setXYZ(r,i.x,i.y,i.z);return e.attributesNormalized.set(t,n),n}applyTextureTransform(t,e){let n=!1;const i={};0===e.offset.x&&0===e.offset.y||(i.offset=e.offset.toArray(),n=!0),0!==e.rotation&&(i.rotation=e.rotation,n=!0),1===e.repeat.x&&1===e.repeat.y||(i.scale=e.repeat.toArray(),n=!0),n&&(t.extensions=t.extensions||{},t.extensions.KHR_texture_transform=i,this.extensionsUsed.KHR_texture_transform=!0)}processBuffer(t){const e=this.json,n=this.buffers;return e.buffers||(e.buffers=[{byteLength:0}]),n.push(t),0}processBufferView(t,e,n,i,r){const s=this.json;let o;s.bufferViews||(s.bufferViews=[]),o=e===iCt?1:e===rCt?2:4;const a=lCt(i*t.itemSize*o),l=new DataView(new ArrayBuffer(a));let c=0;for(let h=n;h<n+i;h++)for(let n=0;n<t.itemSize;n++){let i;t.itemSize>4?i=t.array[h*t.itemSize+n]:0===n?i=t.getX(h):1===n?i=t.getY(h):2===n?i=t.getZ(h):3===n&&(i=t.getW(h)),5126===e?l.setFloat32(c,i,!0):5125===e?l.setUint32(c,i,!0):e===rCt?l.setUint16(c,i,!0):e===iCt&&l.setUint8(c,i),c+=o}const u={buffer:this.processBuffer(l.buffer),byteOffset:this.byteOffset,byteLength:a};return void 0!==r&&(u.target=r),34962===r&&(u.byteStride=t.itemSize*o),this.byteOffset+=a,s.bufferViews.push(u),{id:s.bufferViews.length-1,byteLength:0}}processBufferViewImage(t){const e=this,n=e.json;return n.bufferViews||(n.bufferViews=[]),new Promise(function(i){const r=new window.FileReader;r.readAsArrayBuffer(t),r.onloadend=function(){const t=cCt(r.result),s={buffer:e.processBuffer(t),byteOffset:e.byteOffset,byteLength:t.byteLength};e.byteOffset+=t.byteLength,i(n.bufferViews.push(s)-1)}})}processAccessor(t,e,n,i){const r=this.options,s=this.json;let o;if(t.array.constructor===Float32Array)o=5126;else if(t.array.constructor===Uint32Array)o=5125;else if(t.array.constructor===Uint16Array)o=rCt;else{if(t.array.constructor!==Uint8Array)throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");o=iCt}if(void 0===n&&(n=0),void 0===i&&(i=t.count),r.truncateDrawRange&&void 0!==e&&null===e.index){const r=n+i,s=e.drawRange.count===1/0?t.count:e.drawRange.start+e.drawRange.count;n=Math.max(n,e.drawRange.start),(i=Math.min(r,s)-n)<0&&(i=0)}if(0===i)return null;const a=function(t,e,n){const i={min:new Array(t.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(t.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let r=e;r<e+n;r++)for(let e=0;e<t.itemSize;e++){let n;t.itemSize>4?n=t.array[r*t.itemSize+e]:0===e?n=t.getX(r):1===e?n=t.getY(r):2===e?n=t.getZ(r):3===e&&(n=t.getW(r)),i.min[e]=Math.min(i.min[e],n),i.max[e]=Math.max(i.max[e],n)}return i}(t,n,i);let l;void 0!==e&&(l=t===e.index?34963:34962);const c=this.processBufferView(t,o,n,i,l),u={bufferView:c.id,byteOffset:c.byteOffset,componentType:o,count:i,max:a.max,min:a.min,type:{1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",16:"MAT4"}[t.itemSize]};return!0===t.normalized&&(u.normalized=!0),s.accessors||(s.accessors=[]),s.accessors.push(u)-1}processImage(t,e,n){const i=this,r=i.cache,s=i.json,o=i.options,a=i.pending;r.images.has(t)||r.images.set(t,{});const l=r.images.get(t),c=1023===e?"image/png":"image/jpeg",u=c+":flipY/"+n.toString();if(void 0!==l[u])return l[u];s.images||(s.images=[]);const h={mimeType:c};if(o.embedImages){const r=uCt=uCt||document.createElement("canvas");r.width=Math.min(t.width,o.maxTextureSize),r.height=Math.min(t.height,o.maxTextureSize);const s=r.getContext("2d");if(!0===n&&(s.translate(0,r.height),s.scale(1,-1)),"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap)s.drawImage(t,0,0,r.width,r.height);else{1023!==e&&1022!==e&&console.error("GLTFExporter: Only RGB and RGBA formats are supported."),(t.width>o.maxTextureSize||t.height>o.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",t);let n=t.data;if(1022===e){n=new Uint8ClampedArray(t.height*t.width*4);for(let e=0,i=0;e<n.length;e+=4,i+=3)n[e+0]=t.data[i+0],n[e+1]=t.data[i+1],n[e+2]=t.data[i+2],n[e+3]=255}s.putImageData(new ImageData(n,t.width,t.height),0,0)}!0===o.binary?a.push(new Promise(function(t){r.toBlob(function(e){i.processBufferViewImage(e).then(function(e){h.bufferView=e,t()})},c)})):h.uri=r.toDataURL(c)}else h.uri=t.src;const d=s.images.push(h)-1;return l[u]=d,d}processSampler(t){const e=this.json;return e.samplers||(e.samplers=[]),e.samplers.push({magFilter:sCt[t.magFilter],minFilter:sCt[t.minFilter],wrapS:sCt[t.wrapS],wrapT:sCt[t.wrapT]})-1}processTexture(t){const e=this.cache,n=this.json;if(e.textures.has(t))return e.textures.get(t);n.textures||(n.textures=[]);const i={sampler:this.processSampler(t),source:this.processImage(t.image,t.format,t.flipY)};t.name&&(i.name=t.name),this._invokeAll(function(e){e.writeTexture&&e.writeTexture(t,i)});const r=n.textures.push(i)-1;return e.textures.set(t,r),r}processMaterial(t){const e=this.cache,n=this.json;if(e.materials.has(t))return e.materials.get(t);if(t.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;n.materials||(n.materials=[]);const i={pbrMetallicRoughness:{}};!0!==t.isMeshStandardMaterial&&!0!==t.isMeshBasicMaterial&&console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");const r=t.color.toArray().concat([t.opacity]);if(aCt(r,[1,1,1,1])||(i.pbrMetallicRoughness.baseColorFactor=r),t.isMeshStandardMaterial?(i.pbrMetallicRoughness.metallicFactor=t.metalness,i.pbrMetallicRoughness.roughnessFactor=t.roughness):(i.pbrMetallicRoughness.metallicFactor=.5,i.pbrMetallicRoughness.roughnessFactor=.5),t.metalnessMap||t.roughnessMap)if(t.metalnessMap===t.roughnessMap){const e={index:this.processTexture(t.metalnessMap)};this.applyTextureTransform(e,t.metalnessMap),i.pbrMetallicRoughness.metallicRoughnessTexture=e}else console.warn("THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.");if(t.map){const e={index:this.processTexture(t.map)};this.applyTextureTransform(e,t.map),i.pbrMetallicRoughness.baseColorTexture=e}if(t.emissive){const e=t.emissive.clone().multiplyScalar(t.emissiveIntensity).toArray();if(aCt(e,[0,0,0])||(i.emissiveFactor=e),t.emissiveMap){const e={index:this.processTexture(t.emissiveMap)};this.applyTextureTransform(e,t.emissiveMap),i.emissiveTexture=e}}if(t.normalMap){const e={index:this.processTexture(t.normalMap)};t.normalScale&&-1!==t.normalScale.x&&(t.normalScale.x!==t.normalScale.y&&console.warn("THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X."),e.scale=t.normalScale.x),this.applyTextureTransform(e,t.normalMap),i.normalTexture=e}if(t.aoMap){const e={index:this.processTexture(t.aoMap),texCoord:1};1!==t.aoMapIntensity&&(e.strength=t.aoMapIntensity),this.applyTextureTransform(e,t.aoMap),i.occlusionTexture=e}t.transparent?i.alphaMode="BLEND":t.alphaTest>0&&(i.alphaMode="MASK",i.alphaCutoff=t.alphaTest),2===t.side&&(i.doubleSided=!0),""!==t.name&&(i.name=t.name),this.serializeUserData(t,i),this._invokeAll(function(e){e.writeMaterial&&e.writeMaterial(t,i)});const s=n.materials.push(i)-1;return e.materials.set(t,s),s}processMesh(t){const e=this.cache,n=this.json,i=[t.geometry.uuid];if(Array.isArray(t.material))for(let v=0,b=t.material.length;v<b;v++)i.push(t.material[v].uuid);else i.push(t.material.uuid);const r=i.join(":");if(e.meshes.has(r))return e.meshes.get(r);const s=t.geometry;let o;if(o=t.isLineSegments?1:t.isLineLoop?2:t.isLine?3:t.isPoints?0:t.material.wireframe?1:4,!0!==s.isBufferGeometry)throw new Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.");const a={},l={},c=[],u=[],h={uv:"TEXCOORD_0",uv2:"TEXCOORD_1",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},d=s.getAttribute("normal");void 0===d||this.isNormalizedNormalAttribute(d)||(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),s.setAttribute("normal",this.createNormalizedNormalAttribute(d)));let p=null;for(let v in s.attributes){if("morph"===v.substr(0,5))continue;const t=s.attributes[v];if(v=h[v]||v.toUpperCase(),/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(v)||(v="_"+v),e.attributes.has(this.getUID(t))){l[v]=e.attributes.get(this.getUID(t));continue}p=null;const n=t.array;"JOINTS_0"!==v||n instanceof Uint16Array||n instanceof Uint8Array||(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),p=new zdt(new Uint16Array(n),t.itemSize,t.normalized));const i=this.processAccessor(p||t,s);null!==i&&(l[v]=i,e.attributes.set(this.getUID(t),i))}if(void 0!==d&&s.setAttribute("normal",d),0===Object.keys(l).length)return null;if(void 0!==t.morphTargetInfluences&&t.morphTargetInfluences.length>0){const n=[],i=[],r={};if(void 0!==t.morphTargetDictionary)for(const e in t.morphTargetDictionary)r[t.morphTargetDictionary[e]]=e;for(let o=0;o<t.morphTargetInfluences.length;++o){const a={};let l=!1;for(const t in s.morphAttributes){if("position"!==t&&"normal"!==t){l||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),l=!0);continue}const n=s.morphAttributes[t][o],i=t.toUpperCase(),r=s.attributes[t];if(e.attributes.has(this.getUID(n))){a[i]=e.attributes.get(this.getUID(n));continue}const c=n.clone();if(!s.morphTargetsRelative)for(let t=0,e=n.count;t<e;t++)c.setXYZ(t,n.getX(t)-r.getX(t),n.getY(t)-r.getY(t),n.getZ(t)-r.getZ(t));a[i]=this.processAccessor(c,s),e.attributes.set(this.getUID(r),a[i])}u.push(a),n.push(t.morphTargetInfluences[o]),void 0!==t.morphTargetDictionary&&i.push(r[o])}a.weights=n,i.length>0&&(a.extras={},a.extras.targetNames=i)}const f=Array.isArray(t.material);if(f&&0===s.groups.length)return null;const m=f?t.material:[t.material],g=f?s.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let v=0,b=g.length;v<b;v++){const t={mode:o,attributes:l};if(this.serializeUserData(s,t),u.length>0&&(t.targets=u),null!==s.index){let n=this.getUID(s.index);void 0===g[v].start&&void 0===g[v].count||(n+=":"+g[v].start+":"+g[v].count),e.attributes.has(n)?t.indices=e.attributes.get(n):(t.indices=this.processAccessor(s.index,s,g[v].start,g[v].count),e.attributes.set(n,t.indices)),null===t.indices&&delete t.indices}const n=this.processMaterial(m[g[v].materialIndex]);null!==n&&(t.material=n),c.push(t)}a.primitives=c,n.meshes||(n.meshes=[]),this._invokeAll(function(e){e.writeMesh&&e.writeMesh(t,a)});const y=n.meshes.push(a)-1;return e.meshes.set(r,y),y}processCamera(t){const e=this.json;e.cameras||(e.cameras=[]);const n=t.isOrthographicCamera,i={type:n?"orthographic":"perspective"};return n?i.orthographic={xmag:2*t.right,ymag:2*t.top,zfar:t.far<=0?.001:t.far,znear:t.near<0?0:t.near}:i.perspective={aspectRatio:t.aspect,yfov:Zut.degToRad(t.fov),zfar:t.far<=0?.001:t.far,znear:t.near<0?0:t.near},""!==t.name&&(i.name=t.type),e.cameras.push(i)-1}processAnimation(t,e){const n=this.json,i=this.nodeMap;n.animations||(n.animations=[]);const r=(t=nCt.Utils.mergeMorphTargetTracks(t.clone(),e)).tracks,s=[],o=[];for(let a=0;a<r.length;++a){const t=r[a],n=Myt.parseTrackName(t.name);let l=Myt.findNode(e,n.nodeName);const c=oCt[n.propertyName];if("bones"===n.objectName&&(l=!0===l.isSkinnedMesh?l.skeleton.getBoneByName(n.objectIndex):void 0),!l||!c)return console.warn('THREE.GLTFExporter: Could not export animation track "%s".',t.name),null;const u=1;let h,d=t.values.length/t.times.length;c===oCt.morphTargetInfluences&&(d/=l.morphTargetInfluences.length),!0===t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline?(h="CUBICSPLINE",d/=3):h=2300===t.getInterpolation()?"STEP":"LINEAR",o.push({input:this.processAccessor(new zdt(t.times,u)),output:this.processAccessor(new zdt(t.values,d)),interpolation:h}),s.push({sampler:o.length-1,target:{node:i.get(l),path:c}})}return n.animations.push({name:t.name||"clip_"+n.animations.length,samplers:o,channels:s}),n.animations.length-1}processSkin(t){const e=this.json,n=this.nodeMap,i=e.nodes[n.get(t)],r=t.skeleton;if(void 0===r)return null;const s=t.skeleton.bones[0];if(void 0===s)return null;const o=[],a=new Float32Array(16*r.bones.length),l=new Uht;for(let c=0;c<r.bones.length;++c)o.push(n.get(r.bones[c])),l.copy(r.boneInverses[c]),l.multiply(t.bindMatrix).toArray(a,16*c);return void 0===e.skins&&(e.skins=[]),e.skins.push({inverseBindMatrices:this.processAccessor(new zdt(a,16)),joints:o,skeleton:n.get(s)}),i.skin=e.skins.length-1}processNode(t){const e=this.json,n=this.options,i=this.nodeMap;e.nodes||(e.nodes=[]);const r={};if(n.trs){const e=t.quaternion.toArray(),n=t.position.toArray(),i=t.scale.toArray();aCt(e,[0,0,0,1])||(r.rotation=e),aCt(n,[0,0,0])||(r.translation=n),aCt(i,[1,1,1])||(r.scale=i)}else t.matrixAutoUpdate&&t.updateMatrix(),!1===aCt(t.matrix.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])&&(r.matrix=t.matrix.elements);if(""!==t.name&&(r.name=String(t.name)),this.serializeUserData(t,r),t.isMesh||t.isLine||t.isPoints){const e=this.processMesh(t);null!==e&&(r.mesh=e)}else t.isCamera&&(r.camera=this.processCamera(t));if(t.isSkinnedMesh&&this.skins.push(t),t.children.length>0){const e=[];for(let i=0,r=t.children.length;i<r;i++){const r=t.children[i];if(r.visible||!1===n.onlyVisible){const t=this.processNode(r);null!==t&&e.push(t)}}e.length>0&&(r.children=e)}this._invokeAll(function(e){e.writeNode&&e.writeNode(t,r)});const s=e.nodes.push(r)-1;return i.set(t,s),s}processScene(t){const e=this.json,n=this.options;e.scenes||(e.scenes=[],e.scene=0);const i={};""!==t.name&&(i.name=t.name),e.scenes.push(i);const r=[];for(let s=0,o=t.children.length;s<o;s++){const e=t.children[s];if(e.visible||!1===n.onlyVisible){const t=this.processNode(e);null!==t&&r.push(t)}}r.length>0&&(i.nodes=r),this.serializeUserData(t,i)}processObjects(t){const e=new qmt;e.name="AuxScene";for(let n=0;n<t.length;n++)e.children.push(t[n]);this.processScene(e)}processInput(t){const e=this.options;t=t instanceof Array?t:[t],this._invokeAll(function(e){e.beforeParse&&e.beforeParse(t)});const n=[];for(let i=0;i<t.length;i++)t[i]instanceof qmt?this.processScene(t[i]):n.push(t[i]);n.length>0&&this.processObjects(n);for(let i=0;i<this.skins.length;++i)this.processSkin(this.skins[i]);for(let i=0;i<e.animations.length;++i)this.processAnimation(e.animations[i],t[0]);this._invokeAll(function(e){e.afterParse&&e.afterParse(t)})}_invokeAll(t){for(let e=0,n=this.plugins.length;e<n;e++)t(this.plugins[e])}}class dCt{constructor(t){this.writer=t,this.name="KHR_lights_punctual"}writeNode(t,e){if(!t.isLight)return;if(!t.isDirectionalLight&&!t.isPointLight&&!t.isSpotLight)return void console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",t);const n=this.writer,i=n.json,r=n.extensionsUsed,s={};t.name&&(s.name=t.name),s.color=t.color.toArray(),s.intensity=t.intensity,t.isDirectionalLight?s.type="directional":t.isPointLight?(s.type="point",t.distance>0&&(s.range=t.distance)):t.isSpotLight&&(s.type="spot",t.distance>0&&(s.range=t.distance),s.spot={},s.spot.innerConeAngle=(t.penumbra-1)*t.angle*-1,s.spot.outerConeAngle=t.angle),void 0!==t.decay&&2!==t.decay&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),!t.target||t.target.parent===t&&0===t.target.position.x&&0===t.target.position.y&&-1===t.target.position.z||console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),r[this.name]||(i.extensions=i.extensions||{},i.extensions[this.name]={lights:[]},r[this.name]=!0);const o=i.extensions[this.name].lights;o.push(s),e.extensions=e.extensions||{},e.extensions[this.name]={light:o.length-1}}}class pCt{constructor(t){this.writer=t,this.name="KHR_materials_unlit"}writeMaterial(t,e){if(!t.isMeshBasicMaterial)return;const n=this.writer.extensionsUsed;e.extensions=e.extensions||{},e.extensions[this.name]={},n[this.name]=!0,e.pbrMetallicRoughness.metallicFactor=0,e.pbrMetallicRoughness.roughnessFactor=.9}}class fCt{constructor(t){this.writer=t,this.name="KHR_materials_pbrSpecularGlossiness"}writeMaterial(t,e){if(!t.isGLTFSpecularGlossinessMaterial)return;const n=this.writer,i=n.extensionsUsed,r={};e.pbrMetallicRoughness.baseColorFactor&&(r.diffuseFactor=e.pbrMetallicRoughness.baseColorFactor);const s=[1,1,1];if(t.specular.toArray(s,0),r.specularFactor=s,r.glossinessFactor=t.glossiness,e.pbrMetallicRoughness.baseColorTexture&&(r.diffuseTexture=e.pbrMetallicRoughness.baseColorTexture),t.specularMap){const e={index:n.processTexture(t.specularMap)};n.applyTextureTransform(e,t.specularMap),r.specularGlossinessTexture=e}e.extensions=e.extensions||{},e.extensions[this.name]=r,i[this.name]=!0}}nCt.Utils={insertKeyframe:function(t,e){const n=.001,i=t.getValueSize(),r=new t.TimeBufferType(t.times.length+1),s=new t.ValueBufferType(t.values.length+i),o=t.createInterpolant(new t.ValueBufferType(i));let a;if(0===t.times.length){r[0]=e;for(let t=0;t<i;t++)s[t]=0;a=0}else if(e<t.times[0]){if(Math.abs(t.times[0]-e)<n)return 0;r[0]=e,r.set(t.times,1),s.set(o.evaluate(e),0),s.set(t.values,i),a=0}else if(e>t.times[t.times.length-1]){if(Math.abs(t.times[t.times.length-1]-e)<n)return t.times.length-1;r[r.length-1]=e,r.set(t.times,0),s.set(t.values,0),s.set(o.evaluate(e),t.values.length),a=r.length-1}else for(let l=0;l<t.times.length;l++){if(Math.abs(t.times[l]-e)<n)return l;if(t.times[l]<e&&t.times[l+1]>e){r.set(t.times.slice(0,l+1),0),r[l+1]=e,r.set(t.times.slice(l+1),l+2),s.set(t.values.slice(0,(l+1)*i),0),s.set(o.evaluate(e),(l+1)*i),s.set(t.values.slice((l+1)*i),(l+2)*i),a=l+1;break}}return t.times=r,t.values=s,a},mergeMorphTargetTracks:function(t,e){const n=[],i={},r=t.tracks;for(let s=0;s<r.length;++s){let t=r[s];const o=Myt.parseTrackName(t.name),a=Myt.findNode(e,o.nodeName);if("morphTargetInfluences"!==o.propertyName||void 0===o.propertyIndex){n.push(t);continue}if(t.createInterpolant!==t.InterpolantFactoryMethodDiscrete&&t.createInterpolant!==t.InterpolantFactoryMethodLinear){if(t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),t=t.clone(),t.setInterpolation(2301)}const l=a.morphTargetInfluences.length,c=a.morphTargetDictionary[o.propertyIndex];if(void 0===c)throw new Error("THREE.GLTFExporter: Morph target name not found: "+o.propertyIndex);let u;if(void 0===i[a.uuid]){u=t.clone();const e=new u.ValueBufferType(l*u.times.length);for(let t=0;t<u.times.length;t++)e[t*l+c]=u.values[t];u.name=(o.nodeName||"")+".morphTargetInfluences",u.values=e,i[a.uuid]=u,n.push(u);continue}const h=t.createInterpolant(new t.ValueBufferType(1));u=i[a.uuid];for(let e=0;e<u.times.length;e++)u.values[e*l+c]=h.evaluate(u.times[e]);for(let e=0;e<t.times.length;e++){const n=this.insertKeyframe(u,t.times[e]);u.values[n*l+c]=t.values[e]}}return t.tracks=n,t}};const mCt=Symbol("correlatedObjects"),gCt=Symbol("sourceObject"),yCt=Symbol("onUpdate");class vCt{constructor(t,e,n=null){this[yCt]=t,this[gCt]=e,this[mCt]=n}}var bCt,ACt;const xCt=new Zgt,wCt=Symbol("threeTextures"),_Ct=Symbol("uri"),SCt=Symbol("bufferViewImages");class ECt extends vCt{constructor(t,e,n){if(super(t,e,n),this[bCt]=void 0,this[ACt]=new WeakMap,null!=e.uri&&(this[_Ct]=e.uri),null!=e.bufferView)for(const i of n)this[SCt].set(i,i.image)}get[wCt](){return this[mCt]}get name(){return this[gCt].name||""}get uri(){return this[_Ct]}get type(){return null!=this.uri?"external":"embedded"}async setURI(t){this[_Ct]=t;const e=await new Promise((e,n)=>{xCt.load(t,e,void 0,n)});for(const n of this[wCt])n.image=null==e&&null!=this[gCt].bufferView?this[SCt].get(n):e,n.needsUpdate=!0;this[yCt]()}}bCt=_Ct,ACt=SCt;const CCt=(()=>{const t=[9728,9729,9984,9985,9986,9987];return e=>t.indexOf(e)>-1})(),ICt=(()=>{const t=[9728,9729];return e=>t.indexOf(e)>-1})(),TCt=(()=>{const t=[33071,33648,10497];return e=>t.indexOf(e)>-1})(),MCt=Symbol("threeTextures"),kCt=Symbol("setProperty");class RCt extends vCt{get[MCt](){return this[mCt]}constructor(t,e,n){null==e.minFilter&&(e.minFilter=9987),null==e.magFilter&&(e.magFilter=9729),null==e.wrapS&&(e.wrapS=10497),null==e.wrapT&&(e.wrapT=10497),super(t,e,n)}get name(){return this[gCt].name||""}get minFilter(){return this[gCt].minFilter}get magFilter(){return this[gCt].magFilter}get wrapS(){return this[gCt].wrapS}get wrapT(){return this[gCt].wrapT}setMinFilter(t){this[kCt]("minFilter",t)}setMagFilter(t){this[kCt]("magFilter",t)}setWrapS(t){this[kCt]("wrapS",t)}setWrapT(t){this[kCt]("wrapT",t)}[kCt](t,e){const n=this[gCt];if(((t,e)=>{switch(t){case"minFilter":return CCt(e);case"magFilter":return ICt(e);case"wrapS":case"wrapT":return TCt(e);default:throw new Error(`Cannot configure property "${t}" on Sampler`)}})(t,e)){n[t]=e;for(const n of this[MCt])n[t]=e,n.needsUpdate=!0}this[yCt]()}}const NCt=Symbol("source"),LCt=Symbol("sampler");class DCt extends vCt{constructor(t,e,n,i){super(t,n,i);const{sampler:r,source:s}=n;if(this[LCt]=new RCt(t,null!=e.samplers&&null!=r?e.samplers[r]:{},i),null!=e.images&&null!=s){const n=e.images[s];null!=n&&(this[NCt]=new ECt(t,n,i))}}get name(){return this[gCt].name||""}get sampler(){return this[LCt]}get source(){return this[NCt]}}const BCt=Symbol("texture");class OCt extends vCt{constructor(t,e,n,i){super(t,n,i);const{index:r}=n,s=e.textures[r];null!=s&&(this[BCt]=new DCt(t,e,s,i))}get texture(){return this[BCt]}}var PCt,FCt;const $Ct=Symbol("threeMaterials"),zCt=Symbol("baseColorTexture"),UCt=Symbol("metallicRoughnessTexture");class HCt extends vCt{constructor(t,e,n,i){super(t,n,i),this[PCt]=null,this[FCt]=null,null==n.baseColorFactor&&(n.baseColorFactor=[1,1,1,1]),null==n.roughnessFactor&&(n.roughnessFactor=0),null==n.metallicFactor&&(n.metallicFactor=0);const{baseColorTexture:r,metallicRoughnessTexture:s}=n,o=new Set,a=new Set;for(const l of i)null!=r&&null!=l.map&&o.add(l.map),null!=s&&null!=l.metalnessMap&&a.add(l.metalnessMap);o.size>0&&(this[zCt]=new OCt(t,e,r,o)),a.size>0&&(this[UCt]=new OCt(t,e,s,a))}get[(PCt=zCt,FCt=UCt,$Ct)](){return this[mCt]}get baseColorFactor(){return this[gCt].baseColorFactor}get metallicFactor(){return this[gCt].metallicFactor}get roughnessFactor(){return this[gCt].roughnessFactor}get baseColorTexture(){return this[zCt]}get metallicRoughnessTexture(){return this[UCt]}setBaseColorFactor(t){for(const e of this[$Ct])e.color.fromArray(t),e.opacity=t[3];this[gCt].baseColorFactor=t,this[yCt]()}setMetallicFactor(t){for(const e of this[$Ct])e.metalness=t;this[gCt].metallicFactor=t,this[yCt]()}setRoughnessFactor(t){for(const e of this[$Ct])e.roughness=t;this[gCt].roughnessFactor=t,this[yCt]()}}var VCt,GCt,WCt;const jCt=Symbol("pbrMetallicRoughness"),QCt=Symbol("normalTexture"),qCt=Symbol("occlusionTexture"),XCt=Symbol("emissiveTexture");class YCt extends vCt{constructor(t,e,n,i){if(super(t,n,i),this[VCt]=null,this[GCt]=null,this[WCt]=null,null==i)return;null==n.pbrMetallicRoughness&&(n.pbrMetallicRoughness={}),this[jCt]=new HCt(t,e,n.pbrMetallicRoughness,i);const{normalTexture:r,occlusionTexture:s,emissiveTexture:o}=n,a=new Set,l=new Set,c=new Set;for(const u of i){const{normalMap:t,aoMap:e,emissiveMap:n}=u;null!=r&&null!=t&&a.add(t),null!=s&&null!=e&&l.add(e),null!=o&&null!=n&&c.add(n)}a.size>0&&(this[QCt]=new OCt(t,e,r,a)),l.size>0&&(this[qCt]=new OCt(t,e,s,l)),c.size>0&&(this[XCt]=new OCt(t,e,o,c))}get name(){return this[gCt].name||""}get pbrMetallicRoughness(){return this[jCt]}get normalTexture(){return this[QCt]}get occlusionTexture(){return this[qCt]}get emissiveTexture(){return this[XCt]}get emissiveFactor(){return this[gCt].emissiveFactor}setEmissiveFactor(t){for(const e of this[mCt])e.emissive.fromArray(t);this[gCt].emissiveFactor=t,this[yCt]()}}var KCt;VCt=QCt,GCt=qCt,WCt=XCt;const JCt=Symbol("materials");class ZCt{constructor(t,e=(()=>{})){this[KCt]=[];const{gltf:n,gltfElementMap:i}=t;n.materials.forEach(t=>{this[JCt].push(new YCt(e,n,t,i.get(t)))})}get materials(){return this[JCt]}}KCt=JCt;var tIt=function(t,e,n,i){for(var r,s=arguments.length,o=s<3?e:null===i?i=Object.getOwnPropertyDescriptor(e,n):i,a=t.length-1;a>=0;a--)(r=t[a])&&(o=(s<3?r(o):s>3?r(e,n,o):r(e,n))||o);return s>3&&o&&Object.defineProperty(e,n,o),o};const eIt=Symbol("currentGLTF"),nIt=Symbol("model"),iIt=Symbol("variants");var rIt=function(t,e,n,i){for(var r,s=arguments.length,o=s<3?e:null===i?i=Object.getOwnPropertyDescriptor(e,n):i,a=t.length-1;a>=0;a--)(r=t[a])&&(o=(s<3?r(o):s>3?r(e,n,o):r(e,n))||o);return s>3&&o&&Object.defineProperty(e,n,o),o};const sIt=Math.PI/32,oIt={basis:[uAt(tAt(sIt,"rad"))],keywords:{auto:[null]}},aIt=Symbol("autoRotateStartTime"),lIt=Symbol("radiansPerSecond"),cIt=Symbol("syncRotationRate"),uIt=Symbol("onCameraChange"),hIt=(t=>{var e,n,i;class r extends t{constructor(){super(...arguments),this[e]=new Map,this[n]=t=>{t.forEach(t=>{t instanceof MutationRecord&&"childList"!==t.type||(t.addedNodes.forEach(t=>{this[bwt](t)}),t.removedNodes.forEach(t=>{this[Awt](t)}),this[twt]())})},this[i]=new MutationObserver(this[ywt])}connectedCallback(){super.connectedCallback();for(let e=0;e<this.children.length;++e)this[bwt](this.children[e]);const{ShadyDOM:t}=self;null==t?this[vwt].observe(this,{childList:!0}):this[vwt]=t.observeChildren(this,this[ywt])}disconnectedCallback(){super.disconnectedCallback();const{ShadyDOM:t}=self;null==t?this[vwt].disconnect():t.unobserveChildren(this[vwt])}updateHotspot(t){const e=this[gwt].get(t.name);null!=e&&(e.updatePosition(t.position),e.updateNormal(t.normal),this[twt]())}positionAndNormalFromPoint(t,e){const n=this[Zxt],{width:i,height:r,target:s}=n;xwt.set(t/i,e/r).multiplyScalar(2).subScalar(1),xwt.y*=-1;const o=n.positionAndNormalFromPoint(xwt);if(null==o)return null;wwt.copy(s.matrixWorld).invert();const a=hwt(o.position.applyMatrix4(wwt));return _wt.getNormalMatrix(wwt),{position:a,normal:hwt(o.normal.applyNormalMatrix(_wt))}}[(e=gwt,n=ywt,i=vwt,bwt)](t){if(!(t instanceof HTMLElement&&0===t.slot.indexOf("hotspot")))return;let e=this[gwt].get(t.slot);null!=e?e.increment():(e=new pAt({name:t.slot,position:t.dataset.position,normal:t.dataset.normal}),this[gwt].set(t.slot,e),this[Zxt].addHotspot(e)),this[Zxt].isDirty=!0}[Awt](t){if(!(t instanceof HTMLElement))return;const e=this[gwt].get(t.slot);e&&(e.decrement()&&(this[Zxt].removeHotspot(e),this[gwt].delete(t.slot)),this[Zxt].isDirty=!0)}}return r})((t=>{var e,n,i;class r extends t{constructor(){super(...arguments),this[e]=void 0,this[n]=null,this[i]=[],this.variantName=void 0,this.orientation="0 0 0",this.scale="1 1 1"}get model(){return this[nIt]}get availableVariants(){return this[iIt]}updated(t){if(super.updated(t),t.has("variantName")){const t=this[iIt],e=this[eIt],{variantName:n}=this,i=t.findIndex(t=>t===n);if(null==e||i<0)return;const r=()=>{this[twt]()},s=e.correlatedSceneGraph.loadVariant(i,r),{gltf:o,gltfElementMap:a}=e.correlatedSceneGraph;for(const l of s){const t=o.materials[l];this[nIt].materials[l]=new YCt(r,o,t,a.get(t))}}if(t.has("orientation")||t.has("scale")){const{modelContainer:t}=this[Zxt],e=eAt(this.orientation)[0].terms,n=dAt(e[0]).number,i=dAt(e[1]).number,r=dAt(e[2]).number;t.quaternion.setFromEuler(new Kht(i,r,n,"YXZ"));const s=eAt(this.scale)[0].terms;t.scale.set(s[0].number,s[1].number,s[2].number),this[Zxt].updateBoundingBox(),this[Zxt].updateShadow(),this[rwt].arRenderer.onUpdateScene(),this[twt]()}}[(e=nIt,n=eIt,i=iIt,nwt)](){super[nwt](),this[iIt]=[];const{currentGLTF:t}=this[Zxt];if(null!=t){const{correlatedSceneGraph:e}=t;null!=e&&t!==this[eIt]&&(this[nIt]=new ZCt(e,()=>{this[twt]()}));const{gltfExtensions:n}=t.userData;if(null!=n){const t=n.KHR_materials_variants;null!=t&&(this[iIt]=t.variants.map(t=>t.name),this.requestUpdate("variantName"))}}this[eIt]=t,this.dispatchEvent(new CustomEvent("scene-graph-ready"))}async exportScene(t){const e=this[Zxt];return new Promise(async n=>{const i={binary:!0,onlyVisible:!0,maxTextureSize:1/0,forcePowerOfTwoTextures:!1,includeCustomExtensions:!1,embedImages:!0};Object.assign(i,t),i.animations=e.animations,i.truncateDrawRange=!0;const r=e.shadow;let s=!1;null!=r&&(s=r.visible,r.visible=!1),(new nCt).parse(e.modelContainer,t=>n(new Blob([i.binary?t:JSON.stringify(t)],{type:i.binary?"application/octet-stream":"application/json"})),i),null!=r&&(r.visible=s)})}}return tIt([Tut({type:String,attribute:"variant-name"})],r.prototype,"variantName",void 0),tIt([Tut({type:String,attribute:"orientation"})],r.prototype,"orientation",void 0),tIt([Tut({type:String,attribute:"scale"})],r.prototype,"scale",void 0),r})((t=>{var e,n,i;class r extends t{constructor(){super(...arguments),this.autoRotate=!1,this.autoRotateDelay=3e3,this.rotationPerSecond="auto",this[e]=performance.now(),this[n]=0,this[i]=t=>{this.autoRotate&&"user-interaction"===t.detail.source&&(this[aIt]=performance.now())}}connectedCallback(){super.connectedCallback(),this.addEventListener("camera-change",this[uIt]),this[aIt]=performance.now()}disconnectedCallback(){super.disconnectedCallback(),this.removeEventListener("camera-change",this[uIt]),this[aIt]=performance.now()}updated(t){super.updated(t),t.has("autoRotate")&&(this[aIt]=performance.now())}[(e=aIt,n=lIt,cIt)](t){this[lIt]=t[0]}[ewt](t,e){if(super[ewt](t,e),!this.autoRotate||!this[uwt]()||this[rwt].isPresenting)return;const n=Math.min(e,t-this[aIt]-this.autoRotateDelay);n>0&&(this[Zxt].yaw=this.turntableRotation+this[lIt]*n*.001)}get turntableRotation(){return this[Zxt].yaw}resetTurntableRotation(t=0){this[Zxt].yaw=t}}return i=uIt,rIt([Tut({type:Boolean,attribute:"auto-rotate"})],r.prototype,"autoRotate",void 0),rIt([Tut({type:Number,attribute:"auto-rotate-delay"})],r.prototype,"autoRotateDelay",void 0),rIt([CSt({intrinsics:oIt,updateHandler:cIt}),Tut({type:String,attribute:"rotation-per-second"})],r.prototype,"rotationPerSecond",void 0),r})((t=>{var e,n,i;class r extends t{constructor(){super(...arguments),this.environmentImage=null,this.skyboxImage=null,this.shadowIntensity=0,this.shadowSoftness=1,this.exposure=1,this[e]=null,this[n]=null,this[i]=t=>{t.element===this&&this[REt]()}}connectedCallback(){super.connectedCallback(),this[rwt].loader.addEventListener("preload",this[LEt])}disconnectedCallback(){super.disconnectedCallback(),this[rwt].loader.removeEventListener("preload",this[LEt])}updated(t){super.updated(t),t.has("shadowIntensity")&&(this[Zxt].setShadowIntensity(.1*this.shadowIntensity),this[twt]()),t.has("shadowSoftness")&&(this[Zxt].setShadowSoftness(this.shadowSoftness),this[twt]()),t.has("exposure")&&(this[Zxt].exposure=this.exposure,this[twt]()),(t.has("environmentImage")||t.has("skyboxImage"))&&this[lwt]()&&this[REt]()}[(e=MEt,n=NEt,i=LEt,nwt)](){super[nwt](),null!=this[MEt]&&this[kEt](this[MEt])}async[REt](){const{skyboxImage:t,environmentImage:e}=this;null!=this[NEt]&&(this[NEt](),this[NEt]=null);const{textureUtils:n}=this[rwt];if(null!=n)try{const{environmentMap:i,skybox:r}=await new Promise(async(i,r)=>{const s=n.generateEnvironmentMapAndSkybox(jbt(t),e,{progressTracker:this[swt]});this[NEt]=()=>r(s),i(await s)}),s=i.texture;this[Zxt].background=null!=r?r.userData.url===s.userData.url?s:r:null,this[kEt](i.texture),this[Zxt].dispatchEvent({type:"envmap-update"})}catch(t){if(t instanceof Error)throw this[kEt](null),t}}[kEt](t){this[MEt]=t,this[Zxt].environment=this[MEt],this.dispatchEvent(new CustomEvent("environment-change")),this[twt]()}}return TEt([Tut({type:String,attribute:"environment-image"})],r.prototype,"environmentImage",void 0),TEt([Tut({type:String,attribute:"skybox-image"})],r.prototype,"skyboxImage",void 0),TEt([Tut({type:Number,attribute:"shadow-intensity"})],r.prototype,"shadowIntensity",void 0),TEt([Tut({type:Number,attribute:"shadow-softness"})],r.prototype,"shadowSoftness",void 0),TEt([Tut({type:Number})],r.prototype,"exposure",void 0),r})((t=>{var e,n,i,r,s,o,a,l,c,u,h,d,p,f,m,g,y;class v extends t{constructor(){super(...arguments),this.cameraControls=!1,this.cameraOrbit="0deg 75deg 105%",this.cameraTarget="auto auto auto",this.fieldOfView="auto",this.minCameraOrbit="auto",this.maxCameraOrbit="auto",this.minFieldOfView="auto",this.maxFieldOfView="auto",this.interactionPromptThreshold=3e3,this.interactionPromptStyle=VSt,this.interactionPrompt=USt,this.interactionPolicy="always-allow",this.orbitSensitivity=1,this.touchAction="pan-y",this.disableZoom=!1,this.interpolationDecay=50,this.bounds="legacy",this[e]=this.shadowRoot.querySelector(".interaction-prompt"),this[n]=this.shadowRoot.querySelector(".interaction-prompt > .animated-container"),this[i]=1/0,this[r]=0,this[s]=1/0,this[o]=!1,this[a]=!1,this[l]=new RSt(this[Zxt].camera,this[Kxt]),this[c]=0,this[u]=new Dyt,this[h]=!1,this[d]=!1,this[p]=!1,this[f]=()=>{const t=this[Kxt];isFinite(this[mEt])||(this[mEt]=performance.now());const e=this[jxt];t.getAttribute("aria-label")!==e&&t.setAttribute("aria-label",e),this.interactionPrompt!==HSt||this[dEt]||(this[hEt]=!0)},this[m]=()=>{this.interactionPrompt===HSt&&(this[hEt]=!1,this[nEt].classList.remove("visible"),this[pEt]=1/0,this[mEt]=1/0)},this[g]=({source:t})=>{this[sEt](),this[twt](),t===kSt&&(this[dEt]=!0,this[rEt]()),this.dispatchEvent(new CustomEvent("camera-change",{detail:{source:t}}))},this[y]=t=>{"pointer-change-start"===t.type?this[Yxt].classList.add("pointer-tumbling"):this[Yxt].classList.remove("pointer-tumbling")}}getCameraOrbit(){const{theta:t,phi:e,radius:n}=this[yEt];return{theta:t,phi:e,radius:n,toString(){return`${this.theta}rad ${this.phi}rad ${this.radius}m`}}}getCameraTarget(){return hwt(this[rwt].isPresenting?this[rwt].arRenderer.target:this[Zxt].getTarget())}getFieldOfView(){return this[eEt].getFieldOfView()}getMinimumFieldOfView(){return this[eEt].options.minimumFieldOfView}getMaximumFieldOfView(){return this[eEt].options.maximumFieldOfView}jumpCameraToGoal(){this[vEt]=!0,this.requestUpdate(vEt,!1)}resetInteractionPrompt(){this[fEt]=0,this[pEt]=1/0,this[dEt]=!1,this[hEt]=this.interactionPrompt===USt&&this.cameraControls}connectedCallback(){super.connectedCallback(),this[eEt].addEventListener("change",this[cEt]),this[eEt].addEventListener("pointer-change-start",this[uEt]),this[eEt].addEventListener("pointer-change-end",this[uEt])}disconnectedCallback(){super.disconnectedCallback(),this[eEt].removeEventListener("change",this[cEt]),this[eEt].removeEventListener("pointer-change-start",this[uEt]),this[eEt].removeEventListener("pointer-change-end",this[uEt])}updated(t){super.updated(t);const e=this[eEt],n=this[Kxt];t.has("cameraControls")&&(this.cameraControls?(e.enableInteraction(),this.interactionPrompt===USt&&(this[hEt]=!0),n.addEventListener("focus",this[lEt]),n.addEventListener("blur",this[aEt])):(n.removeEventListener("focus",this[lEt]),n.removeEventListener("blur",this[aEt]),e.disableInteraction(),this[rEt]())),t.has("disableZoom")&&(e.disableZoom=this.disableZoom),t.has("bounds")&&(this[Zxt].tightBounds="tight"===this.bounds),(t.has("interactionPrompt")||t.has("cameraControls")||t.has("src"))&&(this.interactionPrompt===USt&&this.cameraControls&&!this[dEt]?this[hEt]=!0:this[rEt]()),t.has("interactionPromptStyle")&&this[nEt].classList.toggle("wiggle",this.interactionPromptStyle===VSt),t.has("interactionPolicy")&&e.applyOptions({interactionPolicy:this.interactionPolicy}),t.has("touchAction")&&e.applyOptions({touchAction:this.touchAction}),t.has("orbitSensitivity")&&(e.sensitivity=this.orbitSensitivity),t.has("interpolationDecay")&&(e.setDamperDecayTime(this.interpolationDecay),this[Zxt].setTargetDamperDecayTime(this.interpolationDecay)),!0===this[vEt]&&Promise.resolve().then(()=>{e.jumpToGoal(),this[Zxt].jumpToGoal(),this[vEt]=!1})}async updateFraming(){const t=this[Zxt],e=t.framedFieldOfView;await this.requestUpdate("cameraTarget"),t.updateFraming("tight"===this.bounds?t.getTarget():void 0),t.frameModel();const n=t.framedFieldOfView,i=this[eEt].getFieldOfView()/e;this[gEt]=n*i,this[AEt]=!0,this.requestUpdate("maxFieldOfView"),this.requestUpdate("fieldOfView"),this.requestUpdate("minCameraOrbit"),this.requestUpdate("maxCameraOrbit"),await this.requestUpdate("cameraOrbit")}[(e=nEt,n=iEt,i=mEt,r=fEt,s=pEt,o=dEt,a=hEt,l=eEt,c=gEt,u=yEt,h=vEt,d=bEt,p=AEt,wEt)](t){this[eEt].setFieldOfView(180*t[0]/Math.PI)}[xEt](t){if(this[AEt]){const{theta:e,phi:n}=this.getCameraOrbit();t[0]=e,t[1]=n,this[AEt]=!1}this[eEt].setOrbit(t[0],t[1],t[2])}[SEt](t){this[eEt].applyOptions({minimumAzimuthalAngle:t[0],minimumPolarAngle:t[1],minimumRadius:t[2]}),this.jumpCameraToGoal()}[EEt](t){this[eEt].applyOptions({maximumAzimuthalAngle:t[0],maximumPolarAngle:t[1],maximumRadius:t[2]}),this[oEt](t[2]),this.jumpCameraToGoal()}[CEt](t){this[eEt].applyOptions({minimumFieldOfView:180*t[0]/Math.PI}),this.jumpCameraToGoal()}[IEt](t){this[eEt].applyOptions({maximumFieldOfView:180*t[0]/Math.PI}),this.jumpCameraToGoal()}[_Et](t){const[e,n,i]=t;this[Zxt].setTarget(e,n,i),this[rwt].arRenderer.updateTarget()}[ewt](t,e){if(super[ewt](t,e),this[rwt].isPresenting||!this[uwt]())return;const n=performance.now();if(this[hEt]){const t=this.interactionPrompt===USt?this[Qxt]:this[mEt];this.loaded&&n>t+this.interactionPromptThreshold&&(this[Kxt].setAttribute("aria-label","Use mouse, touch or arrow keys to control the camera!"),this[hEt]=!1,this[pEt]=n,this[nEt].classList.add("visible"))}if(isFinite(this[pEt])&&this.interactionPromptStyle===VSt){const t=this[Zxt],e=(n-this[pEt])/5e3%1,i=OSt(e),r=PSt(e);if(this[iEt].style.opacity=`${r}`,i!==this[fEt]){const e=(i-this[fEt])*Math.PI/16;this[iEt].style.transform=`translateX(${i*t.width*.05}px)`,this[eEt].adjustOrbit(e,0,0),this[fEt]=i}}this[eEt].update(t,e),this[Zxt].updateTarget(e)}[rEt](){this[hEt]=!1,this[nEt].classList.remove("visible"),this[pEt]=1/0}[oEt](t){const{idealCameraDistance:e}=this[Zxt],n=2*Math.max(e,t);this[eEt].updateNearFar(0,n)}[sEt](){const{theta:t,phi:e}=this[yEt],{theta:n,phi:i}=this[eEt].getCameraSpherical(this[yEt]),r=this.getRootNode();if(null!=r&&r.activeElement===this){const r=(4+Math.floor((t%tEt+ZSt)/KSt))%4,s=(4+Math.floor((n%tEt+ZSt)/KSt))%4,o=Math.floor(e/JSt),a=Math.floor(i/JSt);s===r&&a===o||this[Kxt].setAttribute("aria-label",`View from stage ${zSt[a]}${$St[s]}`)}}[iwt](t){const e=this[eEt],n=this[Zxt].framedFieldOfView;super[iwt](t);const i=this[Zxt].framedFieldOfView,r=e.getFieldOfView()/n;this[gEt]=i*r,e.updateAspect(this[Zxt].aspect),this.requestUpdate("maxFieldOfView",this.maxFieldOfView),this.requestUpdate("fieldOfView",this.fieldOfView),this.jumpCameraToGoal()}[nwt](){super[nwt]();const{framedFieldOfView:t}=this[Zxt];this[gEt]=t,this[bEt]?this[AEt]=!0:this[bEt]=!0,this.requestUpdate("maxFieldOfView",this.maxFieldOfView),this.requestUpdate("fieldOfView",this.fieldOfView),this.requestUpdate("minCameraOrbit",this.minCameraOrbit),this.requestUpdate("maxCameraOrbit",this.maxCameraOrbit),this.requestUpdate("cameraOrbit",this.cameraOrbit),this.requestUpdate("cameraTarget",this.cameraTarget),this.jumpCameraToGoal()}}return f=lEt,m=aEt,g=cEt,y=uEt,BSt([Tut({type:Boolean,attribute:"camera-controls"})],v.prototype,"cameraControls",void 0),BSt([CSt({intrinsics:QSt,observeEffects:!0,updateHandler:xEt}),Tut({type:String,attribute:"camera-orbit",hasChanged:()=>!0})],v.prototype,"cameraOrbit",void 0),BSt([CSt({intrinsics:YSt,observeEffects:!0,updateHandler:_Et}),Tut({type:String,attribute:"camera-target",hasChanged:()=>!0})],v.prototype,"cameraTarget",void 0),BSt([CSt({intrinsics:GSt,observeEffects:!0,updateHandler:wEt}),Tut({type:String,attribute:"field-of-view",hasChanged:()=>!0})],v.prototype,"fieldOfView",void 0),BSt([CSt({intrinsics:qSt,updateHandler:SEt}),Tut({type:String,attribute:"min-camera-orbit",hasChanged:()=>!0})],v.prototype,"minCameraOrbit",void 0),BSt([CSt({intrinsics:XSt,updateHandler:EEt}),Tut({type:String,attribute:"max-camera-orbit",hasChanged:()=>!0})],v.prototype,"maxCameraOrbit",void 0),BSt([CSt({intrinsics:WSt,updateHandler:CEt}),Tut({type:String,attribute:"min-field-of-view",hasChanged:()=>!0})],v.prototype,"minFieldOfView",void 0),BSt([CSt({intrinsics:jSt,updateHandler:IEt}),Tut({type:String,attribute:"max-field-of-view",hasChanged:()=>!0})],v.prototype,"maxFieldOfView",void 0),BSt([Tut({type:Number,attribute:"interaction-prompt-threshold"})],v.prototype,"interactionPromptThreshold",void 0),BSt([Tut({type:String,attribute:"interaction-prompt-style"})],v.prototype,"interactionPromptStyle",void 0),BSt([Tut({type:String,attribute:"interaction-prompt"})],v.prototype,"interactionPrompt",void 0),BSt([Tut({type:String,attribute:"interaction-policy"})],v.prototype,"interactionPolicy",void 0),BSt([Tut({type:Number,attribute:"orbit-sensitivity"})],v.prototype,"orbitSensitivity",void 0),BSt([Tut({type:String,attribute:"touch-action"})],v.prototype,"touchAction",void 0),BSt([Tut({type:Boolean,attribute:"disable-zoom"})],v.prototype,"disableZoom",void 0),BSt([Tut({type:Number,attribute:"interpolation-decay"})],v.prototype,"interpolationDecay",void 0),BSt([Tut({type:String,attribute:"bounds"})],v.prototype,"bounds",void 0),v})((t=>{var e,n,i,r,s,o,a,l,c,u;class h extends t{constructor(){super(...arguments),this.ar=!1,this.arScale="auto",this.arPlacement="floor",this.arModes="webxr scene-viewer",this.iosSrc=null,this[e]=!1,this[n]=this.shadowRoot.querySelector(".ar-button"),this[i]=document.createElement("a"),this[r]=new Set,this[s]=I_t,this[o]=!1,this[a]=t=>{t.preventDefault(),this.activateAR()},this[l]=({status:t})=>{t!==BAt&&this[rwt].arRenderer.presentedScene!==this[Zxt]||(this.setAttribute("ar-status",t),this.dispatchEvent(new CustomEvent("ar-status",{detail:{status:t}})),t===BAt?this.removeAttribute("ar-tracking"):t===OAt&&this.setAttribute("ar-tracking",PAt))},this[c]=({status:t})=>{this.setAttribute("ar-tracking",t),this.dispatchEvent(new CustomEvent("ar-tracking",{detail:{status:t}}))},this[u]=t=>{"_apple_ar_quicklook_button_tapped"==t.data&&this.dispatchEvent(new CustomEvent("quick-look-button-tapped"))}}get canActivateAR(){return this[L_t]!==I_t}connectedCallback(){super.connectedCallback(),this[rwt].arRenderer.addEventListener("status",this[F_t]),this.setAttribute("ar-status",BAt),this[rwt].arRenderer.addEventListener("tracking",this[$_t]),this[B_t].addEventListener("message",this[z_t])}disconnectedCallback(){super.disconnectedCallback(),this[rwt].arRenderer.removeEventListener("status",this[F_t]),this[rwt].arRenderer.removeEventListener("tracking",this[$_t]),this[B_t].removeEventListener("message",this[z_t])}async update(t){super.update(t),t.has("arScale")&&(this[Zxt].canScale="fixed"!==this.arScale),t.has("arPlacement")&&(this[Zxt].setShadowIntensity(this[Zxt].shadowIntensity),this[twt]()),(t.has("ar")||t.has("arModes")||t.has("iosSrc"))&&(t.has("arModes")&&(this[D_t]=w_t(this.arModes)),this[U_t]())}async activateAR(){switch(this[L_t]){case S_t:this[R_t]();break;case C_t:await this[M_t]();break;case E_t:this[k_t]();break;default:console.warn("No AR Mode can be activated. This is probably due to missing configuration or device capabilities")}}async[(e=N_t,n=T_t,i=B_t,r=D_t,s=L_t,o=O_t,a=P_t,l=F_t,c=$_t,u=z_t,U_t)](){if(this[L_t]=I_t,this.ar){const t=[];this[D_t].forEach(e=>{t.push(e)});for(const e of t){if("webxr"===e&&Lut&&!A_t&&await this[rwt].arRenderer.supportsPresentation()){this[L_t]=C_t;break}if("scene-viewer"===e&&$ut&&!x_t){this[L_t]=E_t;break}if("quick-look"===e&&Out){this[L_t]=S_t;break}}!this.canActivateAR&&null!=this.iosSrc&&Out&&(this[L_t]=S_t)}if(this.canActivateAR)this[T_t].classList.add("enabled"),this[T_t].addEventListener("click",this[P_t]);else if(this[T_t].classList.contains("enabled")){this[T_t].removeEventListener("click",this[P_t]),this[T_t].classList.remove("enabled");const t="failed";this.setAttribute("ar-status",t),this.dispatchEvent(new CustomEvent("ar-status",{detail:{status:t}}))}}async[M_t](){console.log("Attempting to present in AR with WebXR..."),await this[H_t]();try{this[T_t].removeEventListener("click",this[P_t]);const{arRenderer:t}=this[rwt];t.placeOnWall="wall"===this.arPlacement,await t.present(this[Zxt])}catch(t){console.warn("Error while trying to present in AR with WebXR"),console.error(t),await this[rwt].arRenderer.stopPresenting(),A_t=!0,console.warn("Falling back to next ar-mode"),await this[U_t](),this.activateAR()}finally{this[U_t]()}}async[H_t](){this.loaded||(this[O_t]=!0,this[qxt](),await((t,e,n=null)=>new Promise(i=>{t.addEventListener(e,function r(s){n&&!n(s)||(i(s),t.removeEventListener(e,r))})}))(this,"load"),this[O_t]=!1)}[lwt](){return super[lwt]()||this[O_t]}[k_t](){const t=self.location.toString(),e=new URL(t),n=new URL(this.src,t),i=new URLSearchParams(n.search);if(e.hash="#model-viewer-no-ar-fallback",i.set("mode","ar_preferred"),i.has("disable_occlusion")||i.set("disable_occlusion","true"),"fixed"===this.arScale&&i.set("resizable","false"),"wall"===this.arPlacement&&i.set("enable_vertical_placement","true"),i.has("sound")){const e=new URL(i.get("sound"),t);i.set("sound",e.toString())}if(i.has("link")){const e=new URL(i.get("link"),t);i.set("link",e.toString())}const r=`intent://arvr.google.com/scene-viewer/1.0?${i.toString()+"&file="+encodeURIComponent(n.toString())}#Intent;scheme=https;package=com.google.ar.core;action=android.intent.action.VIEW;S.browser_fallback_url=${encodeURIComponent(e.toString())};end;`;self.addEventListener("hashchange",()=>{"#model-viewer-no-ar-fallback"===self.location.hash&&(x_t=!0,self.history.back(),console.warn("Error while trying to present in AR with Scene Viewer"),console.warn("Falling back to next ar-mode"),this[U_t]())},{once:!0}),this[B_t].setAttribute("href",r),console.log("Attempting to present in AR with Scene Viewer..."),this[B_t].click()}async[R_t](){const t=!this.iosSrc;this[T_t].classList.remove("enabled");const e=t?await this.prepareUSDZ():this.iosSrc,n=new URL(e,self.location.toString());"fixed"===this.arScale&&(n.hash&&(n.hash+="&"),n.hash+="allowsContentScaling=0");const i=this[B_t];i.setAttribute("rel","ar");const r=document.createElement("img");i.appendChild(r),i.setAttribute("href",n.toString()),t&&i.setAttribute("download","model.usdz"),console.log("Attempting to present in AR with Quick Look..."),i.click(),i.removeChild(r),t&&URL.revokeObjectURL(e),this[T_t].classList.add("enabled")}async prepareUSDZ(){const t=this[swt].beginActivity();await this[H_t]();const e=this[Zxt],n=e.shadow;let i=!1;null!=n&&(i=n.visible,n.visible=!1),t(.2);const r=new d_t,s=await r.parse(e.modelContainer),o=new Blob([s],{type:"model/vnd.usdz+zip"}),a=URL.createObjectURL(o);return t(1),null!=n&&(n.visible=i),a}}return b_t([Tut({type:Boolean,attribute:"ar"})],h.prototype,"ar",void 0),b_t([Tut({type:String,attribute:"ar-scale"})],h.prototype,"arScale",void 0),b_t([Tut({type:String,attribute:"ar-placement"})],h.prototype,"arPlacement",void 0),b_t([Tut({type:String,attribute:"ar-modes"})],h.prototype,"arModes",void 0),b_t([Tut({type:String,attribute:"ios-src"})],h.prototype,"iosSrc",void 0),h})((t=>{var e,n,i,r,s,o,a,l,c,u,h,d,p;class f extends t{constructor(...t){super(...t),this.poster=null,this.reveal=$Et,this.loading="auto",this[e]=!1,this[n]=!1,this[i]=0,this[r]=null,this[s]=this.shadowRoot.querySelector(".slot.poster"),this[o]=this.shadowRoot.querySelector("#default-poster"),this[a]=this.shadowRoot.querySelector("#default-progress-bar > .bar"),this[l]=this.shadowRoot.querySelector("#default-progress-bar > .mask"),this[c]=this[WEt].getAttribute("aria-label"),this[u]=((t,e)=>{let n=null;const i=(...e)=>{null==n&&(t(...e),n=self.setTimeout(()=>n=null,100))};return i.flush=()=>{null!=n&&(self.clearTimeout(n),n=null)},i})(t=>{const e=this[HEt].parentNode;requestAnimationFrame(()=>{this[VEt].style.opacity=""+.2*(1-t),this[HEt].style.transform=`scaleX(${t})`,0===t&&(e.removeChild(this[HEt]),e.appendChild(this[HEt])),1===t?this[HEt].classList.add("hide"):this[HEt].classList.remove("hide")})}),this[h]=()=>{this.reveal!==zEt&&this.dismissPoster()},this[d]=t=>{if(this.reveal!==zEt)switch(t.keyCode){case 32:case 13:this.dismissPoster()}},this[p]=t=>{const e=t.detail.totalProgress;this[YEt]=Math.max(e,this[YEt]),1===e&&(this[XEt].flush(),!this[cwt]()||null==this[jEt]&&this.reveal!==$Et||this[QEt]()),this[XEt](e),this.dispatchEvent(new CustomEvent("progress",{detail:{totalProgress:e}}))};const f=self.ModelViewerElement||{};Fbt.setDRACODecoderLocation(f.dracoDecoderLocation||"https://www.gstatic.com/draco/versioned/decoders/1.3.6/"),Fbt.setKTX2TranscoderLocation(f.ktx2TranscoderLocation||"https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/")}static set dracoDecoderLocation(t){Fbt.setDRACODecoderLocation(t)}static get dracoDecoderLocation(){return Fbt.getDRACODecoderLocation()}static set ktx2TranscoderLocation(t){Fbt.setKTX2TranscoderLocation(t)}static get ktx2TranscoderLocation(){return Fbt.getKTX2TranscoderLocation()}static mapURLs(t){mxt.singleton.loader[Bbt].manager.setURLModifier(t)}dismissPoster(){this[cwt]()?this[QEt]():(this[jEt]="interaction",this[qxt]())}showPoster(){const t=this[GEt],e=this[WEt];e.removeAttribute("tabindex"),e.removeAttribute("aria-hidden"),t.classList.add("show");const n=this.modelIsVisible;this[qEt]=!1,this[Wxt](n),this[KEt]=!1}getDimensions(){return hwt(this[Zxt].size)}connectedCallback(){super.connectedCallback(),this[GEt].addEventListener("click",this[ZEt]),this[GEt].addEventListener("keydown",this[tCt]),this[swt].addEventListener("progress",this[eCt]),UEt.registerInstance(this)}disconnectedCallback(){super.disconnectedCallback(),this[GEt].removeEventListener("click",this[ZEt]),this[GEt].removeEventListener("keydown",this[tCt]),this[swt].removeEventListener("progress",this[eCt]),UEt.unregisterInstance(this)}async updated(t){super.updated(t),t.has("poster")&&null!=this.poster&&(this[WEt].style.backgroundImage=`url(${this.poster})`),t.has("alt")&&this[WEt].setAttribute("aria-label",`${this[jxt]}. ${this[JEt]}`),(t.has("reveal")||t.has("loading"))&&this[qxt]()}[(e=qEt,n=KEt,i=YEt,r=jEt,s=GEt,o=WEt,a=HEt,l=VEt,c=JEt,u=XEt,h=ZEt,d=tCt,p=eCt,lwt)](){return!!this.src&&(null!=this[jEt]||"eager"===this.loading||this.reveal===$Et&&this[Gxt])}[cwt](){const{src:t}=this;return!!t&&super[cwt]()&&1===this[YEt]}[QEt](){this[jEt]=null;const t=this[GEt],e=this[WEt];if(t.classList.contains("show")){t.classList.remove("show");const n=this.modelIsVisible;this[qEt]=!0,this[Wxt](n),t.addEventListener("transitionend",()=>{requestAnimationFrame(()=>{this[KEt]=!0;const t=this.getRootNode();t&&t.activeElement===this&&this[Kxt].focus(),e.setAttribute("aria-hidden","true"),e.tabIndex=-1,this.dispatchEvent(new CustomEvent("poster-dismissed"))})},{once:!0})}}[awt](){return super[awt]()&&this[qEt]}[uwt](){return super[uwt]()&&this[KEt]}async[qxt](){this[YEt]=0,null!=this[Zxt].currentGLTF&&null!=this.src&&this[lwt]()||this.showPoster(),await super[qxt]()}}return FEt([Tut({type:String})],f.prototype,"poster",void 0),FEt([Tut({type:String})],f.prototype,"reveal",void 0),FEt([Tut({type:String})],f.prototype,"loading",void 0),f})((t=>{var e;class n extends t{constructor(){super(...arguments),this.autoplay=!1,this.animationName=void 0,this.animationCrossfadeDuration=300,this[e]=!0}get availableAnimations(){return this.loaded?this[Zxt].animationNames:[]}get duration(){return this[Zxt].duration}get paused(){return this[mwt]}get currentTime(){return this[Zxt].animationTime}set currentTime(t){this[Zxt].animationTime=t,this[rwt].threeRenderer.shadowMap.needsUpdate=!0,this[twt]()}pause(){this[mwt]||(this[mwt]=!0,this[rwt].threeRenderer.shadowMap.autoUpdate=!1,this.dispatchEvent(new CustomEvent("pause")))}play(){this[mwt]&&this.availableAnimations.length>0&&(this[mwt]=!1,this[rwt].threeRenderer.shadowMap.autoUpdate=!0,this[Zxt].hasActiveAnimation||this[fwt](),this.dispatchEvent(new CustomEvent("play")))}[(e=mwt,nwt)](){super[nwt](),this[mwt]=!0,this.autoplay&&(this[fwt](),this.play())}[ewt](t,e){super[ewt](t,e),this[mwt]||!this[uwt]()&&!this[rwt].isPresenting||(this[Zxt].updateAnimation(e/1e3),this[twt]())}updated(t){super.updated(t),t.has("autoplay")&&this.autoplay&&this.play(),t.has("animationName")&&this[fwt]()}async[qxt](){return this[Zxt].stopAnimation(),super[qxt]()}[fwt](){this[Zxt].playAnimation(this.animationName,this.animationCrossfadeDuration/1e3),this[mwt]&&(this[Zxt].updateAnimation(0),this[twt]())}}return pwt([Tut({type:Boolean})],n.prototype,"autoplay",void 0),pwt([Tut({type:String,attribute:"animation-name"})],n.prototype,"animationName",void 0),pwt([Tut({type:Number,attribute:"animation-crossfade-duration"})],n.prototype,"animationCrossfadeDuration",void 0),n})((t=>{var e;const n=Symbol("endPolyfillCoordination");return e=n,class extends t{constructor(){super(...arguments),this[e]=null}connectedCallback(){super.connectedCallback&&super.connectedCallback(),null==this[n]&&(this[n]=(t=>{if(null==t.shadowRoot||t.hasAttribute("data-js-focus-visible"))return()=>{};if(!self.applyFocusVisiblePolyfill){const e=()=>{self.applyFocusVisiblePolyfill(t.shadowRoot)};return self.addEventListener("focus-visible-polyfill-ready",e,{once:!0}),()=>{self.removeEventListener("focus-visible-polyfill-ready",e)}}return self.applyFocusVisiblePolyfill(t.shadowRoot),()=>{}})(this))}disconnectedCallback(){super.disconnectedCallback&&super.disconnectedCallback(),null!=this[n]&&(this[n](),this[n]=null)}}})(dwt)))))))));customElements.define("model-viewer",hIt);const dIt=["modelViewer"];let pIt=(()=>{class t extends fut{ngAfterViewInit(){customElements.get("model-viewer").minimumRenderScale=1;let t=0;const e=this.modelViewerEl.nativeElement;e.addEventListener("load",()=>{const n=e[Object.getOwnPropertySymbols(e)[14]];this.animationState$.pipe(it(t=>t.tracks),xp(i=>{const r="u"+t++,s=[new nlt("mixamorigHips.position",[0],[0,0,0])];i&&Object.entries(i).forEach(([t,e])=>{s.push(new tlt(t,[0],e))});const o=new ilt(r,0,s);n.animationsByName.set(r,o),n.playAnimation(r),e.paused&&e.play()}),Jx(this.ngUnsubscribe)).subscribe()})}}return t.\u0275fac=function(e){return fIt(e||t)},t.\u0275cmp=Se({type:t,selectors:[["app-animation"]],viewQuery:function(t,e){if(1&t&&Wc(dIt,1),2&t){let t;Gc(t=Qc())&&(e.modelViewerEl=t.first)}},features:[Ko],decls:2,vars:0,consts:[["alt","3D Avatar","camera-controls","","camera-orbit","0deg 90deg auto","camera-target","0m .8m 0m","field-of-view","20deg","interaction-prompt","none","loading","eager","preload","","src","assets/3d/character.glb"],["modelViewer",""]],template:function(t,e){1&t&&va(0,"model-viewer",0,1)},styles:["[_nghost-%COMP%]{position:absolute;width:100%;height:100%}model-viewer[_ngcontent-%COMP%]{width:100%;height:100%}"]}),HI([UI(t=>t.animation)],t.prototype,"animationState$",void 0),t})();const fIt=Ci(pIt);function mIt(t,e){if(1&t){const t=xa();ga(0,"button",5),Ea("click",function(){return yn(t),ka(3).applySetting("receiveVideo",!1)}),ga(1,"mat-icon"),Ja(2,"videocam"),ya(),ya()}if(2&t){const t=ka(2).$implicit;fa("matTooltipPosition","above")("matTooltip",t("receiveVideo.on")),ua("aria-label",t("receiveVideo.on"))}}function gIt(t,e){if(1&t){const t=xa();ga(0,"button",6),Ea("click",function(){return yn(t),ka(3).applySetting("receiveVideo",!0)}),ga(1,"mat-icon"),Ja(2,"videocam_off"),ya(),ya()}if(2&t){const t=ka(2).$implicit;fa("matTooltipPosition","above")("matTooltip",t("receiveVideo.off")),ua("aria-label",t("receiveVideo.off"))}}function yIt(t,e){if(1&t&&(ba(0),ba(1,2),ha(2,mIt,3,3,"button",3),ha(3,gIt,3,3,"button",4),Aa(),Aa()),2&t){const t=e.ngIf;Bs(1),fa("ngSwitch",t.receiveVideo),Bs(1),fa("ngSwitchCase",!0),Bs(1),fa("ngSwitchCase",!1)}}function vIt(t,e){if(1&t&&(ba(0),ha(1,yIt,4,3,"ng-container",1),Mc(2,"async"),Aa()),2&t){const t=ka();Bs(1),fa("ngIf",kc(2,1,t.settingsState$))}}let bIt=(()=>{class t extends mut{constructor(t){super(t)}}return t.\u0275fac=function(e){return new(e||t)(pa(RI))},t.\u0275cmp=Se({type:t,selectors:[["app-video-controls"]],features:[Ko],decls:1,vars:1,consts:[[4,"transloco","translocoRead"],[4,"ngIf"],[3,"ngSwitch"],["class","transparent","mat-fab","",3,"matTooltipPosition","matTooltip","click",4,"ngSwitchCase"],["color","warn","mat-fab","",3,"matTooltipPosition","matTooltip","click",4,"ngSwitchCase"],["mat-fab","",1,"transparent",3,"matTooltipPosition","matTooltip","click"],["color","warn","mat-fab","",3,"matTooltipPosition","matTooltip","click"]],template:function(t,e){1&t&&ha(0,vIt,3,3,"ng-container",0),2&t&&fa("translocoRead","video.controls")},directives:[VT,Nh,Oh,Ph,GA,IE,Hx],pipes:[Gh],styles:["button[mat-fab][_ngcontent-%COMP%]{position:absolute;right:16px;bottom:0;margin:0 6px}button[mat-fab].transparent[_ngcontent-%COMP%]{box-shadow:inset 0 0 0 1px #fff;background:#0000}"]}),t})();const AIt=["video"],xIt=["canvas"],wIt=["stats"];function _It(t,e){if(1&t&&(ga(0,"p"),Ja(1),ya()),2&t){const t=ka().$implicit,e=ka(2).ngIf;Bs(1),Za(t("errors."+e.error))}}function SIt(t,e){1&t&&(ga(0,"p"),Ja(1),Mc(2,"transloco"),ya()),2&t&&(Bs(1),Za(kc(2,1,"pose.loading")))}function EIt(t,e){if(1&t&&(ba(0),ha(1,_It,2,1,"p",0),ha(2,SIt,3,3,"p",0),Aa()),2&t){const t=ka().ngIf,e=ka().ngIf;Bs(1),fa("ngIf",e.error),Bs(1),fa("ngIf",!e.error&&!t.isLoaded)}}function CIt(t,e){1&t&&va(0,"app-animation")}function IIt(t,e){1&t&&va(0,"app-video-controls")}function TIt(t,e){if(1&t&&(ba(0),ha(1,EIt,3,2,"ng-container",1),ga(2,"div",2),va(3,"video",3,4),va(5,"canvas",5,6),va(7,"div",null,7),ya(),ha(9,CIt,1,0,"app-animation",0),Mc(10,"async"),ha(11,IIt,1,0,"app-video-controls",0),Aa()),2&t){const t=e.ngIf,n=ka().ngIf,i=ka();Bs(1),fa("translocoRead","video"),Bs(1),fa("hidden",n.error||!t.isLoaded),Bs(7),fa("ngIf",kc(10,4,i.animatePose$)),Bs(2),fa("ngIf",i.displayControls)}}function MIt(t,e){if(1&t&&(ba(0),ha(1,TIt,12,6,"ng-container",0),Mc(2,"async"),Aa()),2&t){const t=ka();Bs(1),fa("ngIf",kc(2,1,t.poseState$))}}let kIt=(()=>{class t extends fut{constructor(t,e,n,i){super(),this.store=t,this.poseService=e,this.signWritingService=n,this.elementRef=i,this.aspectRatio="aspect-16-9",this.displayFps=!0,this.displayControls=!0,this.fpsStats=new Aut.a,this.signingStats=new Aut.a}ngAfterViewInit(){this.setCamera(),this.setStats(),this.trackPose(),this.canvasCtx=this.canvasEl.nativeElement.getContext("2d"),this.preloadSignWritingFont(),this.drawChanges(),this.videoEl.nativeElement.addEventListener("loadeddata",this.appLoop.bind(this)),new ResizeObserver(this.scaleCanvas.bind(this)).observe(this.elementRef.nativeElement)}appLoop(){return VI(this,void 0,void 0,function*(){const t=this.videoEl.nativeElement,e=new aM(this.videoEl.nativeElement);let n=null;for(;0!==t.readyState;)t.currentTime!==n&&(n=t.currentTime,yield this.store.dispatch(e).toPromise()),yield xut(0)})}setCamera(){const t=this.videoEl.nativeElement;t.muted=!0,t.addEventListener("loadedmetadata",e=>t.play()),this.videoState$.pipe(xp(({camera:e,src:n})=>{t.src=n||"",t.srcObject=e}),Jx(this.ngUnsubscribe)).subscribe(),this.videoState$.pipe(it(t=>t.videoSettings),np(Boolean),xp(({width:t,height:e})=>{this.canvasEl.nativeElement.width=t,this.canvasEl.nativeElement.height=e,requestAnimationFrame(this.scaleCanvas.bind(this))}),xp(t=>this.aspectRatio="aspect-"+t.aspectRatio),Jx(this.ngUnsubscribe)).subscribe()}scaleCanvas(){window.requestAnimationFrame(()=>{const t=this.elementRef.nativeElement.getBoundingClientRect().width/this.canvasEl.nativeElement.width;this.canvasEl.nativeElement.style.transform=`scale(${t})`,this.elementRef.nativeElement.style.height=this.canvasEl.nativeElement.height*t+"px"})}trackPose(){this.poseState$.pipe(it(t=>t.pose),np(Boolean),xp(t=>{this.fpsStats.end(),this.fpsStats.begin()}),Jx(this.ngUnsubscribe)).subscribe()}preloadSignWritingFont(){this.canvasCtx.font="100px SuttonSignWritingOneD",this.canvasCtx.fillText("Preload SignWriting",0,0)}drawChanges(){const t=this.canvasCtx,e=t.canvas;Pd([this.poseState$,this.signWritingState$,this.settingsState$]).pipe(yw((t,e)=>t[1].timestamp===e[1].timestamp),xp(([n,i,r])=>{n.pose&&(t.clearRect(0,0,e.width,e.height),r.drawVideo?t.drawImage(n.pose.image,0,0,e.width,e.height):(t.fillStyle="white",t.fillRect(0,0,e.width,e.height)),r.drawPose&&this.poseService.draw(n.pose,t),r.drawSignWriting&&this.signWritingService.draw(i,t))}),Jx(this.ngUnsubscribe)).subscribe()}setStats(){this.fpsStats.showPanel(0),this.fpsStats.domElement.style.position="absolute",this.statsEl.nativeElement.appendChild(this.fpsStats.dom),this.displayFps||(this.fpsStats.domElement.style.display="none");const t=new Aut.a.Panel("Signing","#ff8","#221");this.signingStats.dom.innerHTML="",this.signingStats.addPanel(t),this.signingStats.showPanel(0),this.signingStats.domElement.style.position="absolute",this.signingStats.domElement.style.left="80px",this.statsEl.nativeElement.appendChild(this.signingStats.dom),this.setDetectorListener(t)}setDetectorListener(t){this.signingProbability$.pipe(xp(e=>t.update(100*e,100)),Jx(this.ngUnsubscribe)).subscribe(),this.settingsState$.pipe(it(t=>t.detectSign),yw(),xp(t=>{this.signingStats.domElement.style.display=t?"block":"none"}),Jx(this.ngUnsubscribe)).subscribe()}}return t.\u0275fac=function(e){return new(e||t)(pa(RI),pa(sM),pa(qct),pa(Cl))},t.\u0275cmp=Se({type:t,selectors:[["app-video"]],viewQuery:function(t,e){if(1&t&&(Wc(AIt,1),Wc(xIt,1),Wc(wIt,1)),2&t){let t;Gc(t=Qc())&&(e.videoEl=t.first),Gc(t=Qc())&&(e.canvasEl=t.first),Gc(t=Qc())&&(e.statsEl=t.first)}},hostVars:2,hostBindings:function(t,e){2&t&&function(t,e,n,i){const r=gn(),s=Tn(2);r.firstUpdatePass&&Wa(r,null,s,i);const o=mn();if(n!==Ds&&la(o,s,n)){const a=r.data[Hn()];if(Ka(a,i)&&!Ga(r,s)){let t=a.classesWithoutHost;null!==t&&(n=Ot(t,n||"")),ma(r,a,o,n,i)}else!function(t,e,n,i,r,s,o,a){r===Ds&&(r=fe);let l=0,c=0,u=0<r.length?r[0]:null,h=0<s.length?s[0]:null;for(;null!==u||null!==h;){const o=l<r.length?r[l+1]:void 0,d=c<s.length?s[c+1]:void 0;let p,f=null;u===h?(l+=2,c+=2,o!==d&&(f=h,p=d)):null===h||null!==u&&u<h?(l+=2,f=u):(c+=2,f=h,p=d),null!==f&&qa(t,e,n,i,f,p,!0,a),u=l<r.length?r[l]:null,h=c<s.length?s[c]:null}}(r,a,o,o[11],o[s+1],o[s+1]=function(t,e,n){if(null==n||""===n)return fe;const i=[],r=dr(n);if(Array.isArray(r))for(let s=0;s<r.length;s++)t(i,r[s],!0);else if("object"==typeof r)for(const s in r)r.hasOwnProperty(s)&&t(i,s,r[s]);else"string"==typeof r&&e(i,r);return i}(t,e,n),0,s)}}($i,Ha,e.aspectRatio,!0)},inputs:{displayFps:"displayFps",displayControls:"displayControls"},features:[Ko],decls:2,vars:3,consts:[[4,"ngIf"],[4,"transloco","translocoRead"],["id","video-container",3,"hidden"],["autoplay","","loop",""],["video",""],["height","100%","width","100%",1,"flip"],["canvas",""],["stats",""]],template:function(t,e){1&t&&(ha(0,MIt,3,3,"ng-container",0),Mc(1,"async")),2&t&&fa("ngIf",kc(1,1,e.videoState$))},directives:[Nh,VT,pIt,bIt],pipes:[Gh,GT],styles:["[_nghost-%COMP%]{background:#202124;display:flex;position:relative;color:#fff;text-align:center;align-items:center;overflow:hidden;min-height:216px}p[_ngcontent-%COMP%]{margin:auto;font-size:36px}#video-container[_ngcontent-%COMP%]{height:100%}#video-container[_ngcontent-%COMP%]   video[_ngcontent-%COMP%]{display:none}#video-container[_ngcontent-%COMP%]   canvas[_ngcontent-%COMP%]{transform-origin:top left}.flip[_ngcontent-%COMP%]{transform:scaleX(-1)}app-video-controls[_ngcontent-%COMP%]{position:absolute;bottom:16px;left:0;right:0}app-video-help[_ngcontent-%COMP%]{position:absolute;top:16px;right:16px}"]}),HI([UI(t=>t.settings)],t.prototype,"settingsState$",void 0),HI([UI(t=>t.settings.animatePose)],t.prototype,"animatePose$",void 0),HI([UI(t=>t.video)],t.prototype,"videoState$",void 0),HI([UI(t=>t.pose)],t.prototype,"poseState$",void 0),HI([UI(t=>t.signWriting)],t.prototype,"signWritingState$",void 0),HI([UI(t=>t.detector.signingProbability)],t.prototype,"signingProbability$",void 0),t})();function RIt(t,e){if(1&t&&(ga(0,"mat-toolbar"),ga(1,"mat-icon"),Ja(2,"hearing"),ya(),ga(3,"span"),Ja(4),ya(),ya()),2&t){const t=e.$implicit;Bs(4),Za(t("title"))}}let NIt=(()=>{class t extends fut{constructor(t){super(),this.store=t}ngOnInit(){this.receiveVideo$.pipe(np(Boolean),xp(()=>this.store.dispatch(QI)),Jx(this.ngUnsubscribe)).subscribe(),this.store.dispatch(new qI("assets/tmp/example-sentence.mp4"))}}return t.\u0275fac=function(e){return new(e||t)(pa(RI))},t.\u0275cmp=Se({type:t,selectors:[["app-playground"]],features:[Ko],decls:6,vars:1,consts:[[4,"transloco","translocoRead"],["mode","side","opened",""]],template:function(t,e){1&t&&(ha(0,RIt,5,1,"mat-toolbar",0),ga(1,"mat-drawer-container"),ga(2,"mat-drawer",1),va(3,"app-settings"),ya(),ga(4,"mat-drawer-content"),va(5,"app-video"),ya(),ya()),2&t&&fa("translocoRead","playground")},directives:[VT,X_,q_,vut,Q_,kIt,PA,Hx],styles:["[_nghost-%COMP%]{height:100vh;display:flex;flex-direction:column}mat-drawer-container[_ngcontent-%COMP%]{height:100%}mat-drawer-content[_ngcontent-%COMP%]{display:flex;height:100%;align-items:center;justify-content:center}app-video[_ngcontent-%COMP%]{border-radius:8px;height:720px;max-height:45vw}app-video.aspect-4-3[_ngcontent-%COMP%]{min-width:288px;width:960px;max-width:60vw}app-video.aspect-16-9[_ngcontent-%COMP%]{min-width:384px;width:1280px;max-width:80vw}app-video.aspect-2-1[_ngcontent-%COMP%]{min-width:432px;width:1440px;max-width:90vw}"]}),HI([UI(t=>t.settings.receiveVideo)],t.prototype,"receiveVideo$",void 0),t})();function LIt(t,e){if(1&t){const t=xa();ba(0),ga(1,"button",12),Ea("click",function(){return yn(t),ka(2).setInputMode("text")}),ga(2,"mat-icon"),Ja(3,"translate"),ya(),Ja(4),ya(),Aa()}if(2&t){const t=ka().$implicit,e=ka();Bs(1),Ua("selected","text"===e.inputMode),Bs(3),tl(" ",t("input.text")," ")}}function DIt(t,e){if(1&t){const t=xa();ba(0),ga(1,"button",12),Ea("click",function(){return yn(t),ka(2).setInputMode("webcam")}),ga(2,"mat-icon"),Ja(3,"videocam"),ya(),Ja(4),ya(),ga(5,"button",12),Ea("click",function(){return yn(t),ka(2).setInputMode("upload")}),ga(6,"mat-icon"),Ja(7,"upload"),ya(),Ja(8),ya(),Aa()}if(2&t){const t=ka().$implicit,e=ka();Bs(1),Ua("selected","webcam"===e.inputMode),Bs(3),tl(" ",t("input.webcam")," "),Bs(1),Ua("selected","upload"===e.inputMode),Bs(3),tl(" ",t("input.upload")," ")}}function BIt(t,e){1&t&&va(0,"app-spoken-to-signed")}function OIt(t,e){1&t&&va(0,"app-signed-to-spoken",13),2&t&&fa("inputMode",ka(2).inputMode)}function PIt(t,e){if(1&t){const t=xa();ba(0),ga(1,"mat-toolbar"),ga(2,"mat-icon"),Ja(3,"waving_hand"),ya(),ga(4,"span"),Ja(5),ya(),ya(),ga(6,"div",1),ga(7,"div",2),ha(8,LIt,5,3,"ng-container",3),ha(9,DIt,9,6,"ng-container",3),ya(),ga(10,"div",4),ga(11,"div",5),va(12,"app-language-selector",6),ga(13,"button",7),Ea("click",function(){return yn(t),ka().swapLanguages()}),ga(14,"mat-icon"),Ja(15,"swap_horiz"),ya(),ya(),va(16,"app-language-selector",8),ya(),ga(17,"div",9),ha(18,BIt,1,0,"app-spoken-to-signed",3),ha(19,OIt,1,1,"app-signed-to-spoken",10),ya(),ya(),ga(20,"a",11),Ja(21),ya(),ya(),Aa()}if(2&t){const t=e.$implicit,n=ka();Bs(5),tl("\xa0",t("title"),""),Bs(3),fa("ngIf",n.spokenToSigned),Bs(1),fa("ngIf",!n.spokenToSigned),Bs(3),fa("flags",!0)("hasLanguageDetection",!n.spokenToSigned)("languages",n.signedLanguages),Bs(1),fa("matTooltip",t("swapLanguages")),Bs(3),fa("hasLanguageDetection",n.spokenToSigned)("languages",n.spokenLanguages),Bs(2),fa("ngIf",n.spokenToSigned),Bs(1),fa("ngIf",!n.spokenToSigned),Bs(2),tl(" ",t("feedback")," ")}}let FIt=(()=>{class t{constructor(t){this.store=t,this.spokenToSigned=!0,this.signedLanguages=["us","fr","es","sy","by","bg","fl","hr","cz","dk","in","nz","gb","ee","fi","at","de","cy","gr","is","isl","it","jp","lv","lt","ir","pl","br","pt","ro","ru","sk","ar","cl","cu","mx","se","tr","ua","pk"],this.spokenLanguages=["en","fr","es","af","sq","am","ar","hy","az","eu","be","bn","bs","bg","ca","ceb","zh-CN","zh-TW","co","hr","cs","da","nl","eo","et","fi","fy","gl","ka","de","el","gu","ht","ha","haw","he","hi","hmn","hu","is","ig","id","ga","it","ja","jw","kn","kk","km","ko","ku","ky","lo","la","lv","lt","lb","mk","mg","ms","ml","mt","mi","mr","mn","my","ne","no","ny","ps","fa","pl","pt","pa","ro","ru","sm","gd","sr","st","sn","sd","si","sk","sl","so","su","sw","sv","tl","tg","ta","te","th","tr","uk","ur","uz","vi","cy","xh","yi","yo","zu"],document.title="Sign Translate",this.store.dispatch([new GI("receiveVideo",!0),new GI("detectSign",!1),new GI("drawPose",!0)]),this.setInputMode("text")}setInputMode(t){this.inputMode!==t&&(this.inputMode=t,this.store.dispatch(XI),"webcam"===t&&this.store.dispatch(QI))}swapLanguages(){this.spokenToSigned=!this.spokenToSigned,this.setInputMode(this.spokenToSigned?"text":"webcam")}}return t.\u0275fac=function(e){return new(e||t)(pa(RI))},t.\u0275cmp=Se({type:t,selectors:[["app-translate"]],hostVars:2,hostBindings:function(t,e){2&t&&Ua("spoken-to-signed",e.spokenToSigned)},decls:1,vars:1,consts:[[4,"transloco","translocoRead"],["id","container"],["id","input-mode-group"],[4,"ngIf"],["id","translation-card"],["id","language-selector"],["translationKey","translate.languages.signed",3,"flags","hasLanguageDetection","languages"],["id","swap-languages","mat-icon-button","",3,"matTooltip","click"],["translationKey","translate.languages.spoken",3,"hasLanguageDetection","languages"],["id","content"],[3,"inputMode",4,"ngIf"],["href","mailto:amitmoryossef@gmail.com?subject=Sign Language Translate Feedback","id","feedback"],["color","primary","mat-stroked-button","",3,"click"],[3,"inputMode"]],template:function(t,e){1&t&&ha(0,PIt,22,12,"ng-container",0),2&t&&fa("translocoRead","translate")},styles:['body{background-color:#fff;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility}@media (prefers-color-scheme:dark){  body{background-color:#212121}}[_nghost-%COMP%]{height:100vh}[_nghost-%COMP%]:before{background-color:#fafafa;border-bottom:1px solid #0000001f;content:"";display:block;height:162px;width:100%;position:absolute;z-index:-1}@media (prefers-color-scheme:dark){[_nghost-%COMP%]:before{background-color:#2a2a2a;border-bottom:1px solid #ffffff1f}}mat-toolbar[_ngcontent-%COMP%]{box-sizing:border-box;border-bottom:1px solid #ffffff1f;font-family:Product Sans,Arial,sans-serif;font-weight:400}@media (prefers-color-scheme:light){mat-toolbar[_ngcontent-%COMP%]{background-color:#fff;border-bottom:1px solid #0000001f;color:#424242}}#container[_ngcontent-%COMP%]{width:auto;max-width:1280px;margin:0 auto;transition:all .6s cubic-bezier(.4,0,.2,1)}@media screen and (min-width:1280px){#container[_ngcontent-%COMP%]{padding:0 48px}}#container[_ngcontent-%COMP%]   #input-mode-group[_ngcontent-%COMP%]{height:68px;font-family:Google Sans,Roboto,Arial,sans-serif;align-items:center;display:flex;gap:.5em}#container[_ngcontent-%COMP%]   #input-mode-group[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{transition:background-color .2s cubic-bezier(.4,0,.2,1)}#container[_ngcontent-%COMP%]   #input-mode-group[_ngcontent-%COMP%]   button.selected[_ngcontent-%COMP%]{background-color:#4285f41f}@media screen and (max-width:1279px){#container[_ngcontent-%COMP%]   #input-mode-group[_ngcontent-%COMP%]{padding:0 12px}}@media screen and (max-width:599px){#container[_ngcontent-%COMP%]   #input-mode-group[_ngcontent-%COMP%]{display:none}}#container[_ngcontent-%COMP%]   #translation-card[_ngcontent-%COMP%]{background-color:#fff;overflow:hidden;width:100%;transition:all .6s cubic-bezier(.4,0,.2,1);box-shadow:0 3px 2px 0 #0000005e}@media (prefers-color-scheme:dark){#container[_ngcontent-%COMP%]   #translation-card[_ngcontent-%COMP%]{background-color:#212121}}@media screen and (min-width:600px){#container[_ngcontent-%COMP%]   #translation-card[_ngcontent-%COMP%]{box-shadow:0 1px 4px 0 #0000005e}}@media screen and (min-width:1280px){#container[_ngcontent-%COMP%]   #translation-card[_ngcontent-%COMP%]{border-radius:8px}}#container[_ngcontent-%COMP%]   #translation-card[_ngcontent-%COMP%]   #language-selector[_ngcontent-%COMP%]{display:flex;border-bottom:1px solid #0000001f}@media (prefers-color-scheme:dark){#container[_ngcontent-%COMP%]   #translation-card[_ngcontent-%COMP%]   #language-selector[_ngcontent-%COMP%]{border-bottom:1px solid #ffffff1f}}#container[_ngcontent-%COMP%]   #translation-card[_ngcontent-%COMP%]   #language-selector[_ngcontent-%COMP%]   app-language-selector[_ngcontent-%COMP%]{width:calc(50% - 20px)}#container[_ngcontent-%COMP%]   #translation-card[_ngcontent-%COMP%]   #swap-languages[_ngcontent-%COMP%]{color:#424242;margin-top:3px}#feedback[_ngcontent-%COMP%]{float:right;color:#424242;font-size:11px;font-style:italic;font-weight:400;margin:8px 0;text-decoration:none}@media screen and (max-width:1279px){#feedback[_ngcontent-%COMP%]{padding:0 12px}}@media (prefers-color-scheme:dark){#feedback[_ngcontent-%COMP%]{color:#bdbdbd}}.spoken-to-signed[_nghost-%COMP%]   #language-selector[_ngcontent-%COMP%]{flex-direction:row-reverse}']}),t})();const $It=[{path:"",component:NIt},{path:"translate",component:FIt}];let zIt=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[[ug.forRoot($It)],ug]}),t})(),UIt=(()=>{class t{constructor(){}ngOnInit(){this.squared=null!=this.squared}addingFlagClasses(){return`flag-icon flag-icon-${this.country} ${this.squared?"flag-icon-squared":""}`}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=Se({type:t,selectors:[["flag-icon"]],inputs:{squared:"squared",country:"country"},decls:1,vars:1,consts:[[3,"ngClass"]],template:function(t,e){1&t&&va(0,"span",0),2&t&&fa("ngClass",e.addingFlagClasses())},directives:[Th],encapsulation:2}),t})(),HIt=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({imports:[[jh]]}),t})();class VIt{constructor(t){this.durationSelector=t}call(t,e){return e.subscribe(new GIt(t,this.durationSelector))}}class GIt extends mt{constructor(t,e){super(t),this.durationSelector=e,this.hasValue=!1}_next(t){try{const e=this.durationSelector.call(this,t);e&&this._tryNext(t,e)}catch(WTt){this.destination.error(WTt)}}_complete(){this.emitValue(),this.destination.complete()}_tryNext(t,e){let n=this.durationSubscription;this.value=t,this.hasValue=!0,n&&(n.unsubscribe(),this.remove(n)),n=gt(e,new ft(this)),n&&!n.closed&&this.add(this.durationSubscription=n)}notifyNext(){this.emitValue()}notifyComplete(){this.emitValue()}emitValue(){if(this.hasValue){const t=this.value,e=this.durationSubscription;e&&(this.durationSubscription=void 0,e.unsubscribe(),this.remove(e)),this.value=void 0,this.hasValue=!1,super._next(t)}}}function WIt(t){const{subscriber:e,counter:n,period:i}=t;e.next(n),this.schedule({subscriber:e,counter:n+1,period:i},i)}function jIt(t,e){if(1&t){const t=xa();ga(0,"button",4),Ea("click",function(){yn(t);const e=ka(3);return e.isSpeaking?e.cancel():e.play()}),ga(1,"mat-icon"),Ja(2),ya(),ya()}if(2&t){const t=ka(2).$implicit,e=ka();fa("matTooltipPosition","below")("matTooltip",t(e.isSpeaking?"cancel":"play")),ua("aria-label",t(e.isSpeaking?"cancel":"play")),Bs(2),Za(e.isSpeaking?"stop":"volume_up")}}function QIt(t,e){1&t&&(ga(0,"button",5),ga(1,"mat-icon"),Ja(2,"volume_off"),ya(),ya()),2&t&&ua("aria-label",(0,ka(2).$implicit)("unavailable"))}function qIt(t,e){if(1&t&&(ba(0),ha(1,jIt,3,4,"button",2),ha(2,QIt,3,1,"button",3),Aa()),2&t){const t=ka(2);Bs(1),fa("ngIf",t.isSupported),Bs(1),fa("ngIf",!t.isSupported)}}function XIt(t,e){if(1&t&&(ba(0),ha(1,qIt,3,2,"ng-container",1),Aa()),2&t){const t=ka();Bs(1),fa("ngIf",t.text)}}let YIt=(()=>{class t{constructor(){this.lang="en",this.text="",this.voices=[],this.isSupported=!1,this.isSpeaking=!1,this.speech=new SpeechSynthesisUtterance,this.listeners={}}ngOnInit(){const t=()=>{this.voices=window.speechSynthesis.getVoices(),this.setVoice()};this.listeners.voiceschanged=t,t();for(const[e,n]of Object.entries(this.listeners))window.speechSynthesis.addEventListener(e,n);this.speech.addEventListener("start",()=>this.isSpeaking=!0),this.speech.addEventListener("end",()=>this.isSpeaking=!1)}ngOnDestroy(){for(const[t,e]of Object.entries(this.listeners))window.speechSynthesis.removeEventListener(t,e)}ngOnChanges(t){t.lang&&(this.speech.lang=this.lang,this.setVoice())}setVoice(){if(this.isSupported=!1,0===this.voices.length)return;const t=this.voices.find(t=>t.localService&&t.lang.startsWith(this.lang));if(t)return this.speech.voice=t,void(this.isSupported=!0);const e=this.voices.find(t=>t.lang.startsWith(this.lang));return e?(this.speech.voice=e,void(this.isSupported=!0)):void 0}play(){this.speech.text=this.text,window.speechSynthesis.speak(this.speech)}cancel(){window.speechSynthesis.cancel()}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=Se({type:t,selectors:[["app-text-to-speech"]],inputs:{lang:"lang",text:"text"},features:[Ge],decls:1,vars:1,consts:[[4,"transloco","translocoRead"],[4,"ngIf"],["mat-icon-button","",3,"matTooltipPosition","matTooltip","click",4,"ngIf"],["mat-icon-button","",4,"ngIf"],["mat-icon-button","",3,"matTooltipPosition","matTooltip","click"],["mat-icon-button",""]],template:function(t,e){1&t&&ha(0,XIt,2,1,"ng-container",0),2&t&&fa("translocoRead","text-to-speech")},directives:[VT,Nh,GA,IE,Hx],styles:["button[_ngcontent-%COMP%]{color:#5f6368}"]}),t})();function KIt(t,e){1&t&&va(0,"sgnw-sign"),2&t&&ua("fsw",e.$implicit)}n("YCnO").font.cssAppend("assets/fonts/signwriting/");let JIt=(()=>{class t{constructor(){this.colorSchemeMedia=window.matchMedia("(prefers-color-scheme: dark)")}ngOnInit(){this.colorSchemeListener=()=>{const t=this.signs;this.signs=[],requestAnimationFrame(()=>this.signs=t)},this.colorSchemeMedia.addEventListener("change",this.colorSchemeListener)}ngOnDestroy(){this.colorSchemeMedia.removeEventListener("change",this.colorSchemeListener)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=Se({type:t,selectors:[["app-sign-writing"]],inputs:{signs:"signs"},decls:1,vars:1,consts:[[4,"ngFor","ngForOf"]],template:function(t,e){1&t&&ha(0,KIt,1,1,"sgnw-sign",0),2&t&&fa("ngForOf",e.signs)},directives:[kh],styles:["[_nghost-%COMP%]{width:100px!important;text-align:center;padding:20px 0}@media (prefers-color-scheme:dark){[_nghost-%COMP%]{color:#fff}}sgnw-sign[_ngcontent-%COMP%]{display:block;margin:20px 0}"]}),t})(),ZIt=(()=>{class t{loadModel(){return VI(this,void 0,void 0,function*(){if(this.sequentialModel)return;const t=yield Gj("assets/models/pose-to-person/model.json");this.sequentialModel=t})}translate(t,e){return VI(this,void 0,void 0,function*(){if(!this.sequentialModel)return null;console.log(this.sequentialModel.getWeights());for(const t of this.sequentialModel.getWeights()){const e=yield t.data();LP(e).any().print()}_O(()=>{const e=a.fromPixels(t).toFloat(),n=$P(gP(e,TO(127.5)),TO(1)).reshape([1,t.width,t.height,3]);n.print(),this.sequentialModel.predict(n).print()})})}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Wt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const tTt=["poseViewer"],eTt=["canvas"];function nTt(t,e){1&t&&va(0,"mat-progress-bar",5),2&t&&fa("value",ka().progress())}function iTt(t){return new Promise(e=>{requestAnimationFrame(()=>VI(this,void 0,void 0,function*(){e(yield t())}))})}let rTt=(()=>{class t extends fut{constructor(t){super(),this.pix2pix=t,this.autoplay=!1,this.loop=!1,this.cache=[],this.ready=!1}ngAfterViewInit(){const t=this.poseEl.nativeElement,e=this.canvasEl.nativeElement,n=e.getContext("2d");t.addEventListener("loadeddata$",()=>VI(this,void 0,void 0,function*(){for(this.cache=[],this.ready=!1,yield this.pix2pix.loadModel();!t.ended;){yield iTt(()=>{const n=t.shadowRoot.querySelector("canvas");return this.pix2pix.translate(n,e)});const i=n.getImageData(0,0,e.width,e.height);this.cache.push(i),yield t.nextFrame();break}console.log("Ended"),this.ready=!0}))}progress(){if(!this.poseEl)return 0;const t=this.poseEl.nativeElement;return t.duration?100*t.currentTime/t.duration:0}}return t.\u0275fac=function(e){return new(e||t)(pa(ZIt))},t.\u0275cmp=Se({type:t,selectors:[["app-pose-viewer"]],viewQuery:function(t,e){if(1&t&&(Wc(tTt,1),Wc(eTt,1)),2&t){let t;Gc(t=Qc())&&(e.poseEl=t.first),Gc(t=Qc())&&(e.canvasEl=t.first)}},inputs:{src:"src",autoplay:"autoplay",loop:"loop",width:"width",height:"height"},features:[Ko],decls:5,vars:4,consts:[["mode","determinate",3,"value",4,"ngIf"],["width","256px","height","256px"],["poseViewer",""],["width","256","height","256"],["canvas",""],["mode","determinate",3,"value"]],template:function(t,e){1&t&&(ha(0,nTt,1,1,"mat-progress-bar",0),va(1,"pose-viewer",1,2),va(3,"canvas",3,4)),2&t&&(fa("ngIf",!e.ready),Bs(1),ua("src",e.src)("autoplay",!1)("loop",!1))},directives:[Nh,CC],styles:["[_nghost-%COMP%]{display:block}pose-viewer[_ngcontent-%COMP%]{display:none}canvas[_ngcontent-%COMP%]{width:100%;display:block}"]}),t})();function sTt(t,e){1&t&&va(0,"app-pose-viewer",10),2&t&&fa("src",ka(2).pose)}function oTt(t,e){1&t&&va(0,"pose-viewer",11),2&t&&ua("src",ka(2).pose)}function aTt(t,e){1&t&&va(0,"img",12)}function lTt(t,e){if(1&t&&(ga(0,"div",6),ha(1,sTt,1,1,"app-pose-viewer",7),ha(2,oTt,1,1,"pose-viewer",8),ha(3,aTt,1,0,"img",9),ya()),2&t){const t=e.ngIf,n=ka();Bs(1),fa("ngIf",n.pose&&t.humanize),Bs(1),fa("ngIf",n.pose&&!t.humanize),Bs(1),fa("ngIf",!n.pose)}}const cTt=function(t){return{humanize:t}};let uTt=(()=>{class t extends fut{constructor(){super(...arguments),this.text=new BS("A"),this.maxTextLength=500,this.signWriting=["M507x523S15a28494x496S26500493x477","M522x525S11541498x491S11549479x498S20600489x476","AS14c31S14c39S27102S27116S30300S30a00S36e00M554x585S30a00481x488S30300481x477S14c31508x546S14c39465x545S27102539x545S27116445x545"]}ngOnInit(){const t=t=>{this.pose=t?"https://nlp.biu.ac.il/~ccohenya8/sign/sentence/?lang=en.us&sentence="+encodeURIComponent(t):null};var e;this.text.valueChanges.pipe((e=()=>function(t=0,e=Eg){return(!ww(t)||t<0)&&(t=0),e&&"function"==typeof e.schedule||(e=Eg),new X(n=>(n.add(e.schedule(WIt,t,{subscriber:n,counter:0,period:t})),n))}(500),t=>t.lift(new VIt(e))),xp(t),Jx(this.ngUnsubscribe)).subscribe(),t(this.text.value)}}return t.\u0275fac=function(e){return hTt(e||t)},t.\u0275cmp=Se({type:t,selectors:[["app-spoken-to-signed"]],features:[Ko],decls:11,vars:16,consts:[[1,"translation-text"],["autofocus","","data-gramm_editor","false",3,"formControl","maxLength"],[3,"lang","text"],["id","char-count"],[3,"signs"],["class","sign-language",4,"ngIf"],[1,"sign-language"],["autoplay","","loop","",3,"src",4,"ngIf"],["autoplay","","loop","","width","100%",4,"ngIf"],["src","https://explorit.ch/wp-content/uploads/2019/10/placeholder.png","style","display: block","width","100%",4,"ngIf"],["autoplay","","loop","",3,"src"],["autoplay","","loop","","width","100%"],["src","https://explorit.ch/wp-content/uploads/2019/10/placeholder.png","width","100%",2,"display","block"]],template:function(t,e){1&t&&(ga(0,"div",0),va(1,"textarea",1),ga(2,"div"),va(3,"app-text-to-speech",2),ga(4,"div",3),Ja(5),Mc(6,"number"),Mc(7,"number"),ya(),ya(),ya(),va(8,"app-sign-writing",4),ha(9,lTt,4,3,"div",5),Mc(10,"async")),2&t&&(Bs(1),fa("formControl",e.text)("maxLength",e.maxTextLength),Bs(2),fa("lang","en")("text",e.text.value),Bs(2),el("",kc(6,8,e.text.value.length)," / ",kc(7,10,e.maxTextLength),""),Bs(3),fa("signs",e.signWriting),Bs(1),fa("ngIf",Cc(14,cTt,kc(10,12,e.humanize$))))},directives:[tS,yS,GS,YIt,JIt,Nh,rTt],pipes:[Wh,Gh],styles:['[_nghost-%COMP%]{display:grid;width:100%;grid-template-areas:"spoken signwriting signed";grid-template-columns:auto 100px 50%}@media screen and (max-width:599px){[_nghost-%COMP%]{grid-template-areas:"spoken signwriting" "signed signed";grid-template-columns:auto 100px}[_nghost-%COMP%]   .sign-language[_ngcontent-%COMP%]{border-top:1px solid #0000001f}}@media screen and (max-width:599px) and (prefers-color-scheme:dark){[_nghost-%COMP%]   .sign-language[_ngcontent-%COMP%]{border-top:1px solid #ffffff1f}}[_nghost-%COMP%] > [_ngcontent-%COMP%]:not(:last-child){border-right:1px solid #0000001f}@media (prefers-color-scheme:dark){[_nghost-%COMP%] > [_ngcontent-%COMP%]:not(:last-child){border-right:1px solid #ffffff1f}}.translation-text[_ngcontent-%COMP%]{padding:20px 24px;color:#878787;line-height:32px;flex:1}.translation-text[_ngcontent-%COMP%]   textarea[_ngcontent-%COMP%]{background-color:initial;font-size:24px;line-height:32px;width:100%;height:calc(100% - 40px);border:none;resize:none;outline:none}@media (prefers-color-scheme:dark){.translation-text[_ngcontent-%COMP%]   textarea[_ngcontent-%COMP%]{color:#fff}}.translation-text[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{display:flex}.translation-text[_ngcontent-%COMP%]   #char-count[_ngcontent-%COMP%]{flex-grow:1;align-self:center;text-align:end;font-size:12px}.sign-language[_ngcontent-%COMP%]{grid-area:signed}pose-viewer[_ngcontent-%COMP%]{display:block}']}),HI([UI(t=>t.settings.humanizePose)],t.prototype,"humanize$",void 0),t})();const hTt=Ci(uTt);function dTt(t,e){if(1&t){const t=xa();ba(0),ga(1,"h3"),Ja(2),ya(),ga(3,"p"),Ja(4),ya(),ga(5,"button",1),Ea("click",function(){return yn(t),ka().upload()}),Ja(6),ya(),Aa()}if(2&t){const t=e.$implicit;Bs(2),Za(t("title")),Bs(2),Za(t("types")),Bs(2),tl(" ",t("browse")," ")}}let pTt=(()=>{class t{constructor(t){this.store=t,this.uploadEl=document.createElement("input"),this.uploadEl.setAttribute("type","file"),this.uploadEl.setAttribute("accept",".mp4, .ogv, .webm"),this.uploadEl.addEventListener("change",this.onFileUpload.bind(this))}upload(){this.uploadEl.click()}onFileUpload(){const t=this.uploadEl.files[0];if(t){const e=(window.URL||window.webkitURL).createObjectURL(t);this.store.dispatch(new qI(e))}}}return t.\u0275fac=function(e){return new(e||t)(pa(RI))},t.\u0275cmp=Se({type:t,selectors:[["app-upload"]],decls:1,vars:1,consts:[[4,"transloco","translocoRead"],["color","primary","mat-flat-button","",3,"click"]],template:function(t,e){1&t&&ha(0,dTt,7,3,"ng-container",0),2&t&&fa("translocoRead","translate.upload")},directives:[VT,GA],styles:["h3[_ngcontent-%COMP%]{font-family:Google Sans,sans-serif;font-size:24px;font-weight:400;line-height:30px;margin:0}@media (prefers-color-scheme:dark){h3[_ngcontent-%COMP%]{color:#fff}}p[_ngcontent-%COMP%]{color:#0000008a;font-size:14px;font-weight:400;margin-top:8px;margin-bottom:26px}@media (prefers-color-scheme:dark){p[_ngcontent-%COMP%]{color:#ffffffb3}}button[_ngcontent-%COMP%]{font-family:Google Sans,sans-serif;font-size:14px;font-weight:500;letter-spacing:.3px}"]}),t})();function fTt(t,e){1&t&&va(0,"app-upload")}function mTt(t,e){if(1&t&&(ga(0,"div",2),ga(1,"div",3),va(2,"app-video",4),ya(),va(3,"app-sign-writing",5),ga(4,"div",6),Ja(5),ya(),ya()),2&t){const t=ka(3);Bs(2),fa("displayControls",!1)("displayFps",!1),Bs(1),fa("signs",t.signWriting),Bs(2),Za(t.translation)}}function gTt(t,e){if(1&t&&(ba(0),ha(1,fTt,1,0,"app-upload",0),ha(2,mTt,6,4,"div",1),Aa()),2&t){const t=e.ngIf;Bs(1),fa("ngIf",!t.src),Bs(1),fa("ngIf",t.src)}}function yTt(t,e){if(1&t&&(ba(0),ha(1,gTt,3,2,"ng-container",0),Mc(2,"async"),Aa()),2&t){const t=ka();Bs(1),fa("ngIf",kc(2,1,t.videoState$))}}function vTt(t,e){1&t&&(ga(0,"div",2),ga(1,"div",3),va(2,"app-video",4),ya(),ga(3,"div",6),Ja(4,"Translation"),ya(),ya()),2&t&&(Bs(2),fa("displayControls",!1)("displayFps",!1))}const bTt=[{time:.618368,sw:["M507x523S15a28494x496"],text:"B"},{time:.876432,sw:["M507x523S15a28494x496S26500493x477"],text:"Your"},{time:1.102468,sw:["M507x523S15a28494x496S26500493x477","M522x525S11541498x491S115494"],text:"Your h"},{time:1.102468,sw:["M507x523S15a28494x496S26500493x477","M522x525S11541498x491"],text:"Your h"},{time:1.438297,sw:["M507x523S15a28494x496S26500493x477","M522x525S11541498x491S11549479x498"],text:"Your"},{time:1.628503,sw:["M507x523S15a28494x496S26500493x477","M522x525S11541498x491S11549479x498S20500489x476"],text:"Your"},{time:1.786967,sw:["M507x523S15a28494x496S26500493x477","M522x525S11541498x491S11549479x498S20600489x476"],text:"Your name"},{time:1.993408,sw:["M507x523S15a28494x496S26500493x477","M522x525S11541498x491S11549479x498S20600489x476","AS14c31S14c39S27102S27116S30300S30a00S36e00M554x585S30a00481x488S14c39465x545S14c31508x546"],text:"Your name"},{time:2.163386,sw:["M507x523S15a28494x496S26500493x477","M522x525S11541498x491S11549479x498S20600489x476","AS14c31S14c39S27102S27116S30300S30a00S36e00M554x585S30a00481x488S30300481x477S14c31508x546S14c39465x545S26506539x545S26512445x545"],text:"Your name"},{time:3.113322,sw:["M507x523S15a28494x496S26500493x477","M522x525S11541498x491S11549479x498S20600489x476","AS14c31S14c39S27102S27116S30300S30a00S36e00M554x585S30a00481x488S30300481x477S14c31508x546S14c39465x545S27102539x545S27116445x545"],text:"What is your name?"}];let ATt=(()=>{class t{constructor(){this.translation="Translation",this.signWriting=[]}ngOnInit(){const t=()=>{this.translation="Translation",this.signWriting=["M507x523S15a28494x496S26500493x477","M522x525S11541498x491S11549479x498S20600489x476","AS14c31S14c39S27102S27116S30300S30a00S36e00M554x585S30a00481x488S30300481x477S14c31508x546S14c39465x545S27102539x545S27116445x545"];const e=document.querySelector("video");if(e)for(const t of bTt)t.time<=e.currentTime&&(this.translation=t.text,this.signWriting=t.sw);requestAnimationFrame(t)};t()}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=Se({type:t,selectors:[["app-signed-to-spoken"]],inputs:{inputMode:"inputMode"},decls:2,vars:2,consts:[[4,"ngIf"],["class","interface",4,"ngIf"],[1,"interface"],[1,"sign-language"],[3,"displayControls","displayFps"],[3,"signs"],[1,"translation-text"]],template:function(t,e){1&t&&(ha(0,yTt,3,3,"ng-container",0),ha(1,vTt,5,2,"div",1)),2&t&&(fa("ngIf","upload"===e.inputMode),Bs(1),fa("ngIf","webcam"===e.inputMode))},directives:[Nh,pTt,kIt,JIt],pipes:[Gh],styles:['[_nghost-%COMP%]{display:flex}.interface[_ngcontent-%COMP%]{display:grid;width:100%;grid-template-areas:"signed spoken signwriting";grid-template-columns:50% 100px auto}@media screen and (max-width:599px){.interface[_ngcontent-%COMP%]{grid-template-areas:"signed signed" "spoken signwriting";grid-template-columns:100px auto}}.interface[_ngcontent-%COMP%]   app-sign-writing[_ngcontent-%COMP%]{border-right:1px solid #0000001f}@media (prefers-color-scheme:dark){.interface[_ngcontent-%COMP%]   app-sign-writing[_ngcontent-%COMP%]{border-right:1px solid #ffffff1f}}.sign-language[_ngcontent-%COMP%]{grid-area:signed}.translation-text[_ngcontent-%COMP%]{font-family:Roboto,RobotoDraft,Helvetica,Arial,sans-serif;padding:20px 58px 20px 24px;color:#878787;font-size:24px;line-height:32px;flex:1}app-upload[_ngcontent-%COMP%]{text-align:center;padding:43px 16px 65px;width:100%}app-video[_ngcontent-%COMP%]{width:100%}']}),HI([UI(t=>t.video)],t.prototype,"videoState$",void 0),t})();function xTt(t,e){1&t&&va(0,"mat-tab",9)}function wTt(t,e){1&t&&va(0,"flag-icon",12),2&t&&fa("country",ka(2).$implicit)}function _Tt(t,e){if(1&t&&(ha(0,wTt,1,1,"flag-icon",4),Ja(1),Mc(2,"transloco")),2&t){const t=ka().$implicit,e=ka();fa("ngIf",e.flags),Bs(1),tl(" ",kc(2,2,e.translationKey+"."+t)," ")}}function STt(t,e){if(1&t){const t=xa();ga(0,"mat-tab",10),Ea("select",function(){yn(t);const n=e.$implicit;return ka().selectLanguage(n)}),ha(1,_Tt,3,4,"ng-template",11),ya()}}function ETt(t,e){1&t&&va(0,"flag-icon",12),2&t&&fa("country",ka().language)}function CTt(t,e){1&t&&va(0,"flag-icon",12),2&t&&fa("country",ka().$implicit)}function ITt(t,e){if(1&t){const t=xa();ga(0,"button",13),Ea("click",function(){yn(t);const n=e.$implicit;return ka().selectLanguage(n)}),ha(1,CTt,1,1,"flag-icon",4),Ja(2),Mc(3,"transloco"),ya()}if(2&t){const t=e.$implicit,n=ka();Bs(1),fa("ngIf",n.flags),Bs(1),tl(" ",kc(3,2,n.translationKey+"."+t)," ")}}let TTt=(()=>{class t{constructor(){this.flags=!1,this.hasLanguageDetection=!1,this.selectedIndex=0}ngOnInit(){this.topLanguages=this.languages.slice(0,3),this.selectLanguage(this.languages[0])}selectLanguage(t){if(t===this.language)return;t&&!this.topLanguages.includes(t)&&(this.topLanguages.unshift(t),this.topLanguages.pop()),this.language=t;const e=this.topLanguages.indexOf(this.language);this.selectedIndex=e+Number(this.hasLanguageDetection)}selectLanguageIndex(t){this.selectLanguage(0===t&&this.hasLanguageDetection?null:this.topLanguages[t-Number(this.hasLanguageDetection)])}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=Se({type:t,selectors:[["app-language-selector"]],inputs:{flags:"flags",hasLanguageDetection:"hasLanguageDetection",languages:"languages",translationKey:"translationKey"},decls:13,vars:11,consts:[[3,"selectedIndex","disablePagination","selectedIndexChange"],["disabled","","label","Detect Language",4,"ngIf"],[3,"select",4,"ngFor","ngForOf"],["color","primary","mat-button","",1,"menu-language-button",3,"matMenuTriggerFor"],[3,"country",4,"ngIf"],["mat-icon-button","",1,"menu-icon-button",3,"matMenuTriggerFor"],[1,"language-selector-menu"],["signedLanguagesMenu",""],["mat-menu-item","",3,"click",4,"ngFor","ngForOf"],["disabled","","label","Detect Language"],[3,"select"],["mat-tab-label",""],[3,"country"],["mat-menu-item","",3,"click"]],template:function(t,e){if(1&t&&(ga(0,"mat-tab-group",0),Ea("selectedIndexChange",function(t){return e.selectLanguageIndex(t)})("selectedIndexChange",function(t){return e.selectedIndex=t}),ha(1,xTt,1,0,"mat-tab",1),ha(2,STt,2,0,"mat-tab",2),ya(),ga(3,"button",3),ha(4,ETt,1,1,"flag-icon",4),Ja(5),Mc(6,"transloco"),ya(),ga(7,"button",5),ga(8,"mat-icon"),Ja(9,"expand_more"),ya(),ya(),ga(10,"mat-menu",6,7),ha(12,ITt,4,4,"button",8),ya()),2&t){const t=da(11);fa("selectedIndex",e.selectedIndex)("disablePagination",!0),Bs(1),fa("ngIf",e.hasLanguageDetection),Bs(1),fa("ngForOf",e.topLanguages),Bs(1),fa("matMenuTriggerFor",t),Bs(1),fa("ngIf",e.flags),Bs(1),tl(" ",kc(6,9,e.translationKey+"."+e.language),"\n"),Bs(2),fa("matMenuTriggerFor",t),Bs(5),fa("ngForOf",e.languages)}},directives:[dC,Nh,kh,GA,L_,Hx,M_,eC,YE,UIt,E_],pipes:[GT],styles:["[_nghost-%COMP%]{display:flex}mat-tab-group[_ngcontent-%COMP%]{display:inline-block}button.menu-icon-button[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{transition:transform .2s cubic-bezier(.4,0,.2,1)}button.menu-icon-button[aria-expanded][_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{transform:rotate(-180deg)}@media (prefers-color-scheme:dark){button.menu-icon-button[_ngcontent-%COMP%]{color:#fff}}button.menu-language-button[_ngcontent-%COMP%]{display:none;width:100%;height:100%;text-transform:uppercase}@media screen and (max-width:959px){button.menu-icon-button[_ngcontent-%COMP%], mat-tab-group[_ngcontent-%COMP%]{display:none}button.menu-language-button[_ngcontent-%COMP%]{display:block}}  mat-tab-header{border-bottom:none!important}  .mat-tab-label{min-width:unset!important;text-transform:uppercase;padding:0 16px!important}@media (prefers-color-scheme:dark){  .mat-tab-label{opacity:1!important}}  .mat-tab-label[aria-selected=true]{color:#2196f3;transition:color .2s}  .mat-tab-body-wrapper{display:none!important}  .flag-icon{background-size:cover;border-radius:50%;width:1em;margin-right:.5em}  .language-selector-menu{margin-top:5px}"]}),t})();const MTt=new X(Ap),kTt="Service workers are disabled or not supported by this browser";class RTt{constructor(t){if(this.serviceWorker=t,t){const e=mw(t,"controllerchange").pipe(it(()=>t.controller)),n=Ud(Gd(()=>Rd(t.controller)),e);this.worker=n.pipe(np(t=>!!t)),this.registration=this.worker.pipe(Wd(()=>t.getRegistration()));const i=mw(t,"message").pipe(it(t=>t.data)).pipe(np(t=>t&&t.type)).pipe(Mt(new tt));i.connect(),this.events=i}else this.worker=this.events=this.registration=Gd(()=>jA(new Error("Service workers are disabled or not supported by this browser")))}postMessage(t,e){return this.worker.pipe(Xd(1),xp(n=>{n.postMessage(Object.assign({action:t},e))})).toPromise().then(()=>{})}postMessageWithStatus(t,e,n){const i=this.waitForStatus(n),r=this.postMessage(t,e);return Promise.all([i,r]).then(()=>{})}generateNonce(){return Math.round(1e7*Math.random())}eventsOfType(t){return this.events.pipe(np(e=>e.type===t))}nextEventOfType(t){return this.eventsOfType(t).pipe(Xd(1))}waitForStatus(t){return this.eventsOfType("STATUS").pipe(np(e=>e.nonce===t),Xd(1),it(t=>{if(!t.status)throw new Error(t.error)})).toPromise()}get isEnabled(){return!!this.serviceWorker}}let NTt=(()=>{class t{constructor(t){if(this.sw=t,this.subscriptionChanges=new tt,!t.isEnabled)return this.messages=MTt,this.notificationClicks=MTt,void(this.subscription=MTt);this.messages=this.sw.eventsOfType("PUSH").pipe(it(t=>t.data)),this.notificationClicks=this.sw.eventsOfType("NOTIFICATION_CLICK").pipe(it(t=>t.data)),this.pushManager=this.sw.registration.pipe(it(t=>t.pushManager));const e=this.pushManager.pipe(Wd(t=>t.getSubscription()));this.subscription=wt(e,this.subscriptionChanges)}get isEnabled(){return this.sw.isEnabled}requestSubscription(t){if(!this.sw.isEnabled)return Promise.reject(new Error(kTt));const e={userVisibleOnly:!0};let n=this.decodeBase64(t.serverPublicKey.replace(/_/g,"/").replace(/-/g,"+")),i=new Uint8Array(new ArrayBuffer(n.length));for(let r=0;r<n.length;r++)i[r]=n.charCodeAt(r);return e.applicationServerKey=i,this.pushManager.pipe(Wd(t=>t.subscribe(e)),Xd(1)).toPromise().then(t=>(this.subscriptionChanges.next(t),t))}unsubscribe(){return this.sw.isEnabled?this.subscription.pipe(Xd(1),Wd(t=>{if(null===t)throw new Error("Not subscribed to push notifications.");return t.unsubscribe().then(t=>{if(!t)throw new Error("Unsubscribe failed!");this.subscriptionChanges.next(null)})})).toPromise():Promise.reject(new Error(kTt))}decodeBase64(t){return atob(t)}}return t.\u0275fac=function(e){return new(e||t)(Xi(RTt))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})(),LTt=(()=>{class t{constructor(t){if(this.sw=t,!t.isEnabled)return this.available=MTt,this.activated=MTt,void(this.unrecoverable=MTt);this.available=this.sw.eventsOfType("UPDATE_AVAILABLE"),this.activated=this.sw.eventsOfType("UPDATE_ACTIVATED"),this.unrecoverable=this.sw.eventsOfType("UNRECOVERABLE_STATE")}get isEnabled(){return this.sw.isEnabled}checkForUpdate(){if(!this.sw.isEnabled)return Promise.reject(new Error(kTt));const t=this.sw.generateNonce();return this.sw.postMessageWithStatus("CHECK_FOR_UPDATES",{statusNonce:t},t)}activateUpdate(){if(!this.sw.isEnabled)return Promise.reject(new Error(kTt));const t=this.sw.generateNonce();return this.sw.postMessageWithStatus("ACTIVATE_UPDATE",{statusNonce:t},t)}}return t.\u0275fac=function(e){return new(e||t)(Xi(RTt))},t.\u0275prov=Wt({token:t,factory:t.\u0275fac}),t})();class DTt{}const BTt=new Ri("NGSW_REGISTER_SCRIPT");function OTt(t,e,n,i){return()=>{if(!Qh(i)||!("serviceWorker"in navigator)||!1===n.enabled)return;let r;if(navigator.serviceWorker.addEventListener("controllerchange",()=>{null!==navigator.serviceWorker.controller&&navigator.serviceWorker.controller.postMessage({action:"INITIALIZE"})}),"function"==typeof n.registrationStrategy)r=n.registrationStrategy();else{const[e,...i]=(n.registrationStrategy||"registerWhenStable:30000").split(":");switch(e){case"registerImmediately":r=Rd(null);break;case"registerWithDelay":r=PTt(+i[0]||0);break;case"registerWhenStable":r=i[0]?wt(FTt(t),PTt(+i[0])):FTt(t);break;default:throw new Error(`Unknown ServiceWorker registration strategy: ${n.registrationStrategy}`)}}t.get(Au).runOutsideAngular(()=>r.pipe(Xd(1)).subscribe(()=>navigator.serviceWorker.register(e,{scope:n.scope}).catch(t=>console.error("Service worker registration failed with:",t))))}}function PTt(t){return Rd(null).pipe(nw(t))}function FTt(t){return t.get(Uu).isStable.pipe(np(t=>t))}function $Tt(t,e){return new RTt(Qh(e)&&!1!==t.enabled?navigator.serviceWorker:void 0)}let zTt=(()=>{class t{static register(e,n={}){return{ngModule:t,providers:[{provide:BTt,useValue:e},{provide:DTt,useValue:n},{provide:RTt,useFactory:$Tt,deps:[DTt,ru]},{provide:Jc,useFactory:OTt,deps:[Xo,BTt,DTt,ru],multi:!0}]}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({providers:[NTt,LTt]}),t})(),UTt=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t}),t.\u0275inj=Qt({providers:[ZIt]}),t})(),HTt=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Te({type:t,bootstrap:[bg]}),t.\u0275inj=Qt({providers:[YI],imports:[[Id,QS,zIt,eM,nut,Gct,eut,aut,put,UTt,HIt,zTt.register("ngsw-worker.js",{enabled:true,registrationStrategy:"registerWhenStable:30000"})]]}),t})();!function(t,e,n){const i=t.\u0275cmp;i.directiveDefs=()=>e.map(Ee),i.pipeDefs=()=>n.map(Ce)}(FIt,[VT,PA,Hx,Nh,GA,TTt,IE,uTt,ATt],[]);var VTt=n("VcDv");(function(){if(Lu)throw new Error("Cannot enable prod mode after platform setup.");Nu=!1})(),Ed().bootstrapModule(HTt).catch(t=>console.error(t)),"undefined"==typeof window?Promise.resolve():Object(Td.k)().then(()=>(Object(kd.c)(),Object(Md.d)(),Object(Td.d)(JSON.parse('[["ion-button_14",[[1,"sgnw-symbol-picker",{"fsw":[513],"swu":[513],"iid":[514],"uni":[513]}],[33,"ion-button",{"color":[1],"buttonType":[1025,"button-type"],"disabled":[516],"expand":[513],"fill":[1537],"routerDirection":[1,"router-direction"],"routerAnimation":[16],"download":[1],"href":[1],"rel":[1],"shape":[513],"size":[513],"strong":[4],"target":[1],"type":[1]}],[33,"ion-card",{"color":[1],"button":[4],"type":[1],"disabled":[4],"download":[1],"href":[1],"rel":[1],"routerDirection":[1,"router-direction"],"routerAnimation":[16],"target":[1]}],[1,"ion-col",{"offset":[1],"offsetXs":[1,"offset-xs"],"offsetSm":[1,"offset-sm"],"offsetMd":[1,"offset-md"],"offsetLg":[1,"offset-lg"],"offsetXl":[1,"offset-xl"],"pull":[1],"pullXs":[1,"pull-xs"],"pullSm":[1,"pull-sm"],"pullMd":[1,"pull-md"],"pullLg":[1,"pull-lg"],"pullXl":[1,"pull-xl"],"push":[1],"pushXs":[1,"push-xs"],"pushSm":[1,"push-sm"],"pushMd":[1,"push-md"],"pushLg":[1,"push-lg"],"pushXl":[1,"push-xl"],"size":[1],"sizeXs":[1,"size-xs"],"sizeSm":[1,"size-sm"],"sizeMd":[1,"size-md"],"sizeLg":[1,"size-lg"],"sizeXl":[1,"size-xl"]},[[9,"resize","onResize"]]],[1,"ion-grid",{"fixed":[4]}],[34,"ion-input",{"fireFocusEvents":[4,"fire-focus-events"],"color":[1],"accept":[1],"autocapitalize":[1],"autocomplete":[1],"autocorrect":[1],"autofocus":[4],"clearInput":[4,"clear-input"],"clearOnEdit":[4,"clear-on-edit"],"debounce":[2],"disabled":[4],"enterkeyhint":[1],"inputmode":[1],"max":[1],"maxlength":[2],"min":[1],"minlength":[2],"multiple":[4],"name":[1],"pattern":[1],"placeholder":[1],"readonly":[4],"required":[4],"spellcheck":[4],"step":[1],"size":[2],"type":[1],"value":[1032],"hasFocus":[32],"setFocus":[64],"setBlur":[64],"getInputElement":[64]}],[33,"ion-range",{"color":[1],"debounce":[2],"name":[1],"dualKnobs":[4,"dual-knobs"],"min":[2],"max":[2],"pin":[4],"snaps":[4],"step":[2],"ticks":[4],"disabled":[4],"value":[1026],"ratioA":[32],"ratioB":[32],"pressedKnob":[32]}],[1,"ion-row"],[33,"ion-title",{"color":[1],"size":[1]}],[1,"sgnw-symbol",{"iid":[1538],"fsw":[1537],"swu":[1537],"styling":[1537],"sgnw":[32]}],[49,"ion-item",{"color":[1],"button":[4],"detail":[4],"detailIcon":[1,"detail-icon"],"disabled":[4],"download":[1],"href":[1],"rel":[1],"lines":[1],"routerAnimation":[16],"routerDirection":[1,"router-direction"],"target":[1],"type":[1],"multipleInputs":[32]},[[0,"ionColor","labelColorChanged"],[0,"ionStyle","itemStyle"]]],[34,"ion-label",{"color":[1],"position":[1],"noAnimate":[32]}],[1,"ion-icon",{"mode":[1025],"color":[1],"ariaLabel":[1537,"aria-label"],"ariaHidden":[513,"aria-hidden"],"ios":[1],"md":[1],"flipRtl":[4,"flip-rtl"],"name":[1],"src":[1],"icon":[8],"size":[1],"lazy":[4],"sanitize":[4],"svgContent":[32],"isVisible":[32]}],[1,"ion-ripple-effect",{"type":[1],"addRipple":[64]}]]],["ion-select-popover",[[2,"ion-select-popover",{"header":[1],"subHeader":[1,"sub-header"],"message":[1],"options":[16]},[[0,"ionChange","onSelect"]]]]],["ion-action-sheet",[[34,"ion-action-sheet",{"overlayIndex":[2,"overlay-index"],"keyboardClose":[4,"keyboard-close"],"enterAnimation":[16],"leaveAnimation":[16],"buttons":[16],"cssClass":[1,"css-class"],"backdropDismiss":[4,"backdrop-dismiss"],"header":[1],"subHeader":[1,"sub-header"],"translucent":[4],"animated":[4],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64]}]]],["ion-alert",[[34,"ion-alert",{"overlayIndex":[2,"overlay-index"],"keyboardClose":[4,"keyboard-close"],"enterAnimation":[16],"leaveAnimation":[16],"cssClass":[1,"css-class"],"header":[1],"subHeader":[1,"sub-header"],"message":[1],"buttons":[16],"inputs":[1040],"backdropDismiss":[4,"backdrop-dismiss"],"translucent":[4],"animated":[4],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64]},[[4,"keydown","onKeydown"]]]]],["ion-back-button",[[33,"ion-back-button",{"color":[1],"defaultHref":[1025,"default-href"],"disabled":[516],"icon":[1],"text":[1],"type":[1],"routerAnimation":[16]}]]],["ion-fab-button",[[33,"ion-fab-button",{"color":[1],"activated":[4],"disabled":[4],"download":[1],"href":[1],"rel":[1],"routerDirection":[1,"router-direction"],"routerAnimation":[16],"target":[1],"show":[4],"translucent":[4],"type":[1],"size":[1],"closeIcon":[1,"close-icon"]}]]],["ion-loading",[[34,"ion-loading",{"overlayIndex":[2,"overlay-index"],"keyboardClose":[4,"keyboard-close"],"enterAnimation":[16],"leaveAnimation":[16],"message":[1],"cssClass":[1,"css-class"],"duration":[2],"backdropDismiss":[4,"backdrop-dismiss"],"showBackdrop":[4,"show-backdrop"],"spinner":[1025],"translucent":[4],"animated":[4],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64]}]]],["ion-menu-button",[[33,"ion-menu-button",{"color":[1],"disabled":[4],"menu":[1],"autoHide":[4,"auto-hide"],"type":[1],"visible":[32]},[[16,"ionMenuChange","visibilityChanged"],[16,"ionSplitPaneVisible","visibilityChanged"]]]]],["ion-picker",[[34,"ion-picker",{"overlayIndex":[2,"overlay-index"],"keyboardClose":[4,"keyboard-close"],"enterAnimation":[16],"leaveAnimation":[16],"buttons":[16],"columns":[16],"cssClass":[1,"css-class"],"duration":[2],"showBackdrop":[4,"show-backdrop"],"backdropDismiss":[4,"backdrop-dismiss"],"animated":[4],"presented":[32],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64],"getColumn":[64]}]]],["ion-refresher-content",[[0,"ion-refresher-content",{"pullingIcon":[1025,"pulling-icon"],"pullingText":[1,"pulling-text"],"refreshingSpinner":[1025,"refreshing-spinner"],"refreshingText":[1,"refreshing-text"]}]]],["ion-toast",[[33,"ion-toast",{"overlayIndex":[2,"overlay-index"],"color":[1],"enterAnimation":[16],"leaveAnimation":[16],"cssClass":[1,"css-class"],"duration":[2],"header":[1],"message":[1],"keyboardClose":[4,"keyboard-close"],"position":[1],"buttons":[16],"translucent":[4],"animated":[4],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64]}]]],["ion-chip",[[33,"ion-chip",{"color":[1],"outline":[4],"disabled":[4]}]]],["ion-infinite-scroll-content",[[32,"ion-infinite-scroll-content",{"loadingSpinner":[1025,"loading-spinner"],"loadingText":[1,"loading-text"]}]]],["ion-item-option",[[33,"ion-item-option",{"color":[1],"disabled":[4],"download":[1],"expandable":[4],"href":[1],"rel":[1],"target":[1],"type":[1]}]]],["ion-menu",[[33,"ion-menu",{"contentId":[513,"content-id"],"menuId":[513,"menu-id"],"type":[1025],"disabled":[1028],"side":[513],"swipeGesture":[4,"swipe-gesture"],"maxEdgeStart":[2,"max-edge-start"],"isPaneVisible":[32],"isEndSide":[32],"isOpen":[64],"isActive":[64],"open":[64],"close":[64],"toggle":[64],"setOpen":[64]},[[16,"ionSplitPaneVisible","onSplitPaneChanged"],[2,"click","onBackdropClick"]]]]],["ion-modal",[[34,"ion-modal",{"overlayIndex":[2,"overlay-index"],"delegate":[16],"keyboardClose":[4,"keyboard-close"],"enterAnimation":[16],"leaveAnimation":[16],"component":[1],"componentProps":[16],"cssClass":[1,"css-class"],"backdropDismiss":[4,"backdrop-dismiss"],"showBackdrop":[4,"show-backdrop"],"animated":[4],"swipeToClose":[4,"swipe-to-close"],"presentingElement":[16],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64]}]]],["ion-popover",[[34,"ion-popover",{"delegate":[16],"overlayIndex":[2,"overlay-index"],"enterAnimation":[16],"leaveAnimation":[16],"component":[1],"componentProps":[16],"keyboardClose":[4,"keyboard-close"],"cssClass":[1,"css-class"],"backdropDismiss":[4,"backdrop-dismiss"],"event":[8],"showBackdrop":[4,"show-backdrop"],"translucent":[4],"animated":[4],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64]}]]],["ion-reorder",[[33,"ion-reorder",null,[[2,"click","onClick"]]]]],["ion-searchbar",[[34,"ion-searchbar",{"color":[1],"animated":[4],"autocomplete":[1],"autocorrect":[1],"cancelButtonIcon":[1,"cancel-button-icon"],"cancelButtonText":[1,"cancel-button-text"],"clearIcon":[1,"clear-icon"],"debounce":[2],"disabled":[4],"inputmode":[1],"enterkeyhint":[1],"placeholder":[1],"searchIcon":[1,"search-icon"],"showCancelButton":[1,"show-cancel-button"],"spellcheck":[4],"type":[1],"value":[1025],"focused":[32],"noAnimate":[32],"setFocus":[64],"getInputElement":[64]}]]],["ion-segment-button",[[33,"ion-segment-button",{"disabled":[4],"layout":[1],"type":[1],"value":[1],"checked":[32]}]]],["ion-tab-button",[[33,"ion-tab-button",{"disabled":[4],"download":[1],"href":[1],"rel":[1],"layout":[1025],"selected":[1028],"tab":[1],"target":[1]},[[8,"ionTabBarChanged","onTabBarChanged"]]]]],["ion-app",[[0,"ion-app"]]],["ion-avatar",[[33,"ion-avatar"]]],["ion-badge",[[33,"ion-badge",{"color":[1]}]]],["ion-buttons",[[34,"ion-buttons",{"collapse":[4]}]]],["ion-card-content",[[32,"ion-card-content"]]],["ion-card-header",[[33,"ion-card-header",{"color":[1],"translucent":[4]}]]],["ion-card-subtitle",[[33,"ion-card-subtitle",{"color":[1]}]]],["ion-card-title",[[33,"ion-card-title",{"color":[1]}]]],["ion-checkbox",[[33,"ion-checkbox",{"color":[1],"name":[1],"checked":[1028],"indeterminate":[1028],"disabled":[4],"value":[1]}]]],["ion-content",[[1,"ion-content",{"color":[1],"fullscreen":[4],"forceOverscroll":[1028,"force-overscroll"],"scrollX":[4,"scroll-x"],"scrollY":[4,"scroll-y"],"scrollEvents":[4,"scroll-events"],"getScrollElement":[64],"scrollToTop":[64],"scrollToBottom":[64],"scrollByPoint":[64],"scrollToPoint":[64]},[[8,"appload","onAppLoad"],[2,"click","onClick"]]]]],["ion-datetime",[[33,"ion-datetime",{"name":[1],"disabled":[4],"readonly":[4],"min":[1025],"max":[1025],"displayFormat":[1,"display-format"],"displayTimezone":[1,"display-timezone"],"pickerFormat":[1,"picker-format"],"cancelText":[1,"cancel-text"],"doneText":[1,"done-text"],"yearValues":[8,"year-values"],"monthValues":[8,"month-values"],"dayValues":[8,"day-values"],"hourValues":[8,"hour-values"],"minuteValues":[8,"minute-values"],"monthNames":[1,"month-names"],"monthShortNames":[1,"month-short-names"],"dayNames":[1,"day-names"],"dayShortNames":[1,"day-short-names"],"pickerOptions":[16],"placeholder":[1],"value":[1025],"isExpanded":[32],"open":[64]}]]],["ion-fab",[[1,"ion-fab",{"horizontal":[1],"vertical":[1],"edge":[4],"activated":[1028],"close":[64]}]]],["ion-fab-list",[[1,"ion-fab-list",{"activated":[4],"side":[1]}]]],["ion-footer",[[36,"ion-footer",{"translucent":[4]}]]],["ion-header",[[36,"ion-header",{"collapse":[1],"translucent":[4]}]]],["ion-img",[[1,"ion-img",{"alt":[1],"src":[1],"loadSrc":[32],"loadError":[32]}]]],["ion-infinite-scroll",[[0,"ion-infinite-scroll",{"threshold":[1],"disabled":[4],"position":[1],"isLoading":[32],"complete":[64]}]]],["ion-item-divider",[[33,"ion-item-divider",{"color":[1],"sticky":[4]}]]],["ion-item-group",[[32,"ion-item-group"]]],["ion-item-options",[[32,"ion-item-options",{"side":[1],"fireSwipeEvent":[64]}]]],["ion-item-sliding",[[0,"ion-item-sliding",{"disabled":[4],"state":[32],"getOpenAmount":[64],"getSlidingRatio":[64],"open":[64],"close":[64],"closeOpened":[64]}]]],["ion-menu-toggle",[[1,"ion-menu-toggle",{"menu":[1],"autoHide":[4,"auto-hide"],"visible":[32]},[[16,"ionMenuChange","visibilityChanged"],[16,"ionSplitPaneVisible","visibilityChanged"]]]]],["ion-nav",[[1,"ion-nav",{"delegate":[16],"swipeGesture":[1028,"swipe-gesture"],"animated":[4],"animation":[16],"rootParams":[16],"root":[1],"push":[64],"insert":[64],"insertPages":[64],"pop":[64],"popTo":[64],"popToRoot":[64],"removeIndex":[64],"setRoot":[64],"setPages":[64],"setRouteId":[64],"getRouteId":[64],"getActive":[64],"getByIndex":[64],"canGoBack":[64],"getPrevious":[64]}]]],["ion-nav-link",[[0,"ion-nav-link",{"component":[1],"componentProps":[16],"routerDirection":[1,"router-direction"],"routerAnimation":[16]}]]],["ion-note",[[33,"ion-note",{"color":[1]}]]],["ion-progress-bar",[[33,"ion-progress-bar",{"type":[1],"reversed":[4],"value":[2],"buffer":[2],"color":[1]}]]],["ion-refresher",[[32,"ion-refresher",{"pullMin":[2,"pull-min"],"pullMax":[2,"pull-max"],"closeDuration":[1,"close-duration"],"snapbackDuration":[1,"snapback-duration"],"pullFactor":[2,"pull-factor"],"disabled":[4],"nativeRefresher":[32],"state":[32],"complete":[64],"cancel":[64],"getProgress":[64]}]]],["ion-reorder-group",[[0,"ion-reorder-group",{"disabled":[4],"state":[32],"complete":[64]}]]],["ion-route",[[0,"ion-route",{"url":[1],"component":[1],"componentProps":[16],"beforeLeave":[16],"beforeEnter":[16]}]]],["ion-route-redirect",[[0,"ion-route-redirect",{"from":[1],"to":[1]}]]],["ion-router",[[0,"ion-router",{"root":[1],"useHash":[4,"use-hash"],"canTransition":[64],"push":[64],"back":[64],"printDebug":[64],"navChanged":[64]},[[8,"popstate","onPopState"],[4,"ionBackButton","onBackButton"]]]]],["ion-router-link",[[1,"ion-router-link",{"color":[1],"href":[1],"rel":[1],"routerDirection":[1,"router-direction"],"routerAnimation":[16],"target":[1]}]]],["ion-router-outlet",[[1,"ion-router-outlet",{"mode":[1025],"delegate":[16],"animated":[4],"animation":[16],"swipeHandler":[16],"commit":[64],"setRouteId":[64],"getRouteId":[64]}]]],["ion-segment",[[33,"ion-segment",{"color":[1],"disabled":[4],"scrollable":[4],"swipeGesture":[4,"swipe-gesture"],"value":[1025],"activated":[32]}]]],["ion-select",[[33,"ion-select",{"disabled":[4],"cancelText":[1,"cancel-text"],"okText":[1,"ok-text"],"placeholder":[1],"name":[1],"selectedText":[1,"selected-text"],"multiple":[4],"interface":[1],"interfaceOptions":[8,"interface-options"],"compareWith":[1,"compare-with"],"value":[1032],"isExpanded":[32],"open":[64]}]]],["ion-select-option",[[1,"ion-select-option",{"disabled":[4],"value":[8]}]]],["ion-skeleton-text",[[1,"ion-skeleton-text",{"animated":[4]}]]],["ion-slide",[[0,"ion-slide"]]],["ion-slides",[[36,"ion-slides",{"options":[8],"pager":[4],"scrollbar":[4],"update":[64],"updateAutoHeight":[64],"slideTo":[64],"slideNext":[64],"slidePrev":[64],"getActiveIndex":[64],"getPreviousIndex":[64],"length":[64],"isEnd":[64],"isBeginning":[64],"startAutoplay":[64],"stopAutoplay":[64],"lockSwipeToNext":[64],"lockSwipeToPrev":[64],"lockSwipes":[64],"getSwiper":[64]}]]],["ion-split-pane",[[33,"ion-split-pane",{"contentId":[513,"content-id"],"disabled":[4],"when":[8],"visible":[32]}]]],["ion-tab",[[1,"ion-tab",{"active":[1028],"delegate":[16],"tab":[1],"component":[1],"setActive":[64]}]]],["ion-tab-bar",[[33,"ion-tab-bar",{"color":[1],"selectedTab":[1,"selected-tab"],"translucent":[4],"keyboardVisible":[32]},[[8,"keyboardWillHide","onKeyboardWillHide"],[8,"keyboardWillShow","onKeyboardWillShow"]]]]],["ion-tabs",[[1,"ion-tabs",{"useRouter":[1028,"use-router"],"selectedTab":[32],"select":[64],"getTab":[64],"getSelected":[64],"setRouteId":[64],"getRouteId":[64]}]]],["ion-text",[[1,"ion-text",{"color":[1]}]]],["ion-textarea",[[34,"ion-textarea",{"fireFocusEvents":[4,"fire-focus-events"],"color":[1],"autocapitalize":[1],"autofocus":[4],"clearOnEdit":[1028,"clear-on-edit"],"debounce":[2],"disabled":[4],"inputmode":[1],"enterkeyhint":[1],"maxlength":[2],"minlength":[2],"name":[1],"placeholder":[1],"readonly":[4],"required":[4],"spellcheck":[4],"cols":[2],"rows":[2],"wrap":[1],"autoGrow":[4,"auto-grow"],"value":[1025],"hasFocus":[32],"setFocus":[64],"setBlur":[64],"getInputElement":[64]}]]],["ion-thumbnail",[[1,"ion-thumbnail"]]],["ion-toggle",[[33,"ion-toggle",{"color":[1],"name":[1],"checked":[1028],"disabled":[4],"value":[1],"activated":[32]}]]],["ion-toolbar",[[33,"ion-toolbar",{"color":[1]},[[0,"ionStyle","childrenStyle"]]]]],["ion-virtual-scroll",[[0,"ion-virtual-scroll",{"approxItemHeight":[2,"approx-item-height"],"approxHeaderHeight":[2,"approx-header-height"],"approxFooterHeight":[2,"approx-footer-height"],"headerFn":[16],"footerFn":[16],"items":[16],"itemHeight":[16],"headerHeight":[16],"footerHeight":[16],"renderItem":[16],"renderHeader":[16],"renderFooter":[16],"nodeRender":[16],"domRender":[16],"totalHeight":[32],"positionForItem":[64],"checkRange":[64],"checkEnd":[64]},[[9,"resize","onResize"]]]]],["sgnw-sign",[[1,"sgnw-sign",{"fsw":[1537],"swu":[1537],"styling":[1537],"sgnw":[32]}]]],["sgnw-uni8-string",[[1,"sgnw-uni8-string",{"uni":[1537]}]]],["sgnw-uni8-symbol",[[1,"sgnw-uni8-symbol",{"uni":[1537]}]]],["ion-picker-column",[[32,"ion-picker-column",{"col":[16]}]]],["ion-spinner",[[1,"ion-spinner",{"color":[1],"duration":[2],"name":[1],"paused":[4]}]]],["ion-list_4",[[32,"ion-list",{"lines":[1],"inset":[4],"closeSlidingItems":[64]}],[33,"ion-list-header",{"color":[1],"lines":[1]}],[33,"ion-radio",{"color":[1],"name":[1],"disabled":[4],"value":[8],"checked":[32],"buttonTabindex":[32],"setFocus":[64],"setButtonTabindex":[64]}],[0,"ion-radio-group",{"allowEmptySelection":[4,"allow-empty-selection"],"name":[1],"value":[1032]},[[4,"keydown","onKeydown"]]]]],["ion-backdrop",[[33,"ion-backdrop",{"visible":[4],"tappable":[4],"stopPropagation":[4,"stop-propagation"]},[[2,"click","onMouseDown"]]]]]]'),void 0))),"undefined"==typeof window?Promise.resolve():Object(VTt.f)().then(()=>Object(VTt.b)([["pose-viewer",[[1,"pose-viewer",{src:[1],svg:[4],width:[1],height:[1],loop:[1028],autoplay:[4],playbackRate:[1026,"playback-rate"],currentTime:[1026,"current-time"],duration:[1026],ended:[1028],paused:[1028],readyState:[1026,"ready-state"],syncMedia:[64],nextFrame:[64]}]]]],void 0))},zn8P:function(t,e){function n(t){return Promise.resolve().then(function(){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e})}n.keys=function(){return[]},n.resolve=n,t.exports=n,n.id="zn8P"}},[[0,3]]]);